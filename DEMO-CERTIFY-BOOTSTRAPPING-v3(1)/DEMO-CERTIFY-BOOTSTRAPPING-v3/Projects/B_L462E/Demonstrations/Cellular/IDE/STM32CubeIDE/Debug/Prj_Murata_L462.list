
Prj_Murata_L462.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002b0f4  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000c538  0802b298  0802b298  0003b298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080377d0  080377d0  00050904  2**0
                  CONTENTS
  4 .ARM          00000008  080377d0  080377d0  000477d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080377d8  080377d8  00050904  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  080377d8  080377d8  000477d8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080377e0  080377e0  000477e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000904  20000000  080377e4  00050000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000117a4  20000904  080380e8  00050904  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  200120a8  080380e8  000520a8  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00050904  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  00050934  2**0
                  CONTENTS, READONLY
 13 .debug_line   0007cbf5  00000000  00000000  00050977  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line_str 000000c8  00000000  00000000  000cd56c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info   000982c9  00000000  00000000  000cd634  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev 0000e3da  00000000  00000000  001658fd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_aranges 00003ed0  00000000  00000000  00173cd8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    0011d4f8  00000000  00000000  00177ba8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_rnglists 00003871  00000000  00000000  002950a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loclists 00028178  00000000  00000000  00298911  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_macro  0003cc5f  00000000  00000000  002c0a89  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_frame  0000cbd0  00000000  00000000  002fd6e8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000904 	.word	0x20000904
 80001bc:	00000000 	.word	0x00000000
 80001c0:	0802b27c 	.word	0x0802b27c

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000908 	.word	0x20000908
 80001dc:	0802b27c 	.word	0x0802b27c

080001e0 <strcmp>:
 80001e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001e8:	2a01      	cmp	r2, #1
 80001ea:	bf28      	it	cs
 80001ec:	429a      	cmpcs	r2, r3
 80001ee:	d0f7      	beq.n	80001e0 <strcmp>
 80001f0:	1ad0      	subs	r0, r2, r3
 80001f2:	4770      	bx	lr

080001f4 <strlen>:
 80001f4:	4603      	mov	r3, r0
 80001f6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001fa:	2a00      	cmp	r2, #0
 80001fc:	d1fb      	bne.n	80001f6 <strlen+0x2>
 80001fe:	1a18      	subs	r0, r3, r0
 8000200:	3801      	subs	r0, #1
 8000202:	4770      	bx	lr
	...

08000210 <memchr>:
 8000210:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000214:	2a10      	cmp	r2, #16
 8000216:	db2b      	blt.n	8000270 <memchr+0x60>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	d008      	beq.n	8000230 <memchr+0x20>
 800021e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000222:	3a01      	subs	r2, #1
 8000224:	428b      	cmp	r3, r1
 8000226:	d02d      	beq.n	8000284 <memchr+0x74>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	b342      	cbz	r2, 8000280 <memchr+0x70>
 800022e:	d1f6      	bne.n	800021e <memchr+0xe>
 8000230:	b4f0      	push	{r4, r5, r6, r7}
 8000232:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000236:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800023a:	f022 0407 	bic.w	r4, r2, #7
 800023e:	f07f 0700 	mvns.w	r7, #0
 8000242:	2300      	movs	r3, #0
 8000244:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000248:	3c08      	subs	r4, #8
 800024a:	ea85 0501 	eor.w	r5, r5, r1
 800024e:	ea86 0601 	eor.w	r6, r6, r1
 8000252:	fa85 f547 	uadd8	r5, r5, r7
 8000256:	faa3 f587 	sel	r5, r3, r7
 800025a:	fa86 f647 	uadd8	r6, r6, r7
 800025e:	faa5 f687 	sel	r6, r5, r7
 8000262:	b98e      	cbnz	r6, 8000288 <memchr+0x78>
 8000264:	d1ee      	bne.n	8000244 <memchr+0x34>
 8000266:	bcf0      	pop	{r4, r5, r6, r7}
 8000268:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800026c:	f002 0207 	and.w	r2, r2, #7
 8000270:	b132      	cbz	r2, 8000280 <memchr+0x70>
 8000272:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000276:	3a01      	subs	r2, #1
 8000278:	ea83 0301 	eor.w	r3, r3, r1
 800027c:	b113      	cbz	r3, 8000284 <memchr+0x74>
 800027e:	d1f8      	bne.n	8000272 <memchr+0x62>
 8000280:	2000      	movs	r0, #0
 8000282:	4770      	bx	lr
 8000284:	3801      	subs	r0, #1
 8000286:	4770      	bx	lr
 8000288:	2d00      	cmp	r5, #0
 800028a:	bf06      	itte	eq
 800028c:	4635      	moveq	r5, r6
 800028e:	3803      	subeq	r0, #3
 8000290:	3807      	subne	r0, #7
 8000292:	f015 0f01 	tst.w	r5, #1
 8000296:	d107      	bne.n	80002a8 <memchr+0x98>
 8000298:	3001      	adds	r0, #1
 800029a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800029e:	bf02      	ittt	eq
 80002a0:	3001      	addeq	r0, #1
 80002a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002a6:	3001      	addeq	r0, #1
 80002a8:	bcf0      	pop	{r4, r5, r6, r7}
 80002aa:	3801      	subs	r0, #1
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop

080002b0 <__aeabi_drsub>:
 80002b0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002b4:	e002      	b.n	80002bc <__adddf3>
 80002b6:	bf00      	nop

080002b8 <__aeabi_dsub>:
 80002b8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002bc <__adddf3>:
 80002bc:	b530      	push	{r4, r5, lr}
 80002be:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002c2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002c6:	ea94 0f05 	teq	r4, r5
 80002ca:	bf08      	it	eq
 80002cc:	ea90 0f02 	teqeq	r0, r2
 80002d0:	bf1f      	itttt	ne
 80002d2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002d6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002da:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002de:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002e2:	f000 80e2 	beq.w	80004aa <__adddf3+0x1ee>
 80002e6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ea:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ee:	bfb8      	it	lt
 80002f0:	426d      	neglt	r5, r5
 80002f2:	dd0c      	ble.n	800030e <__adddf3+0x52>
 80002f4:	442c      	add	r4, r5
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	ea82 0000 	eor.w	r0, r2, r0
 8000302:	ea83 0101 	eor.w	r1, r3, r1
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	2d36      	cmp	r5, #54	; 0x36
 8000310:	bf88      	it	hi
 8000312:	bd30      	pophi	{r4, r5, pc}
 8000314:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000318:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800031c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000320:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x70>
 8000326:	4240      	negs	r0, r0
 8000328:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800032c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000330:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000334:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000338:	d002      	beq.n	8000340 <__adddf3+0x84>
 800033a:	4252      	negs	r2, r2
 800033c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000340:	ea94 0f05 	teq	r4, r5
 8000344:	f000 80a7 	beq.w	8000496 <__adddf3+0x1da>
 8000348:	f1a4 0401 	sub.w	r4, r4, #1
 800034c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000350:	db0d      	blt.n	800036e <__adddf3+0xb2>
 8000352:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000356:	fa22 f205 	lsr.w	r2, r2, r5
 800035a:	1880      	adds	r0, r0, r2
 800035c:	f141 0100 	adc.w	r1, r1, #0
 8000360:	fa03 f20e 	lsl.w	r2, r3, lr
 8000364:	1880      	adds	r0, r0, r2
 8000366:	fa43 f305 	asr.w	r3, r3, r5
 800036a:	4159      	adcs	r1, r3
 800036c:	e00e      	b.n	800038c <__adddf3+0xd0>
 800036e:	f1a5 0520 	sub.w	r5, r5, #32
 8000372:	f10e 0e20 	add.w	lr, lr, #32
 8000376:	2a01      	cmp	r2, #1
 8000378:	fa03 fc0e 	lsl.w	ip, r3, lr
 800037c:	bf28      	it	cs
 800037e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000382:	fa43 f305 	asr.w	r3, r3, r5
 8000386:	18c0      	adds	r0, r0, r3
 8000388:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800038c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000390:	d507      	bpl.n	80003a2 <__adddf3+0xe6>
 8000392:	f04f 0e00 	mov.w	lr, #0
 8000396:	f1dc 0c00 	rsbs	ip, ip, #0
 800039a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800039e:	eb6e 0101 	sbc.w	r1, lr, r1
 80003a2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003a6:	d31b      	bcc.n	80003e0 <__adddf3+0x124>
 80003a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003ac:	d30c      	bcc.n	80003c8 <__adddf3+0x10c>
 80003ae:	0849      	lsrs	r1, r1, #1
 80003b0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003b4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003b8:	f104 0401 	add.w	r4, r4, #1
 80003bc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003c0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003c4:	f080 809a 	bcs.w	80004fc <__adddf3+0x240>
 80003c8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003cc:	bf08      	it	eq
 80003ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003d2:	f150 0000 	adcs.w	r0, r0, #0
 80003d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003da:	ea41 0105 	orr.w	r1, r1, r5
 80003de:	bd30      	pop	{r4, r5, pc}
 80003e0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003e4:	4140      	adcs	r0, r0
 80003e6:	eb41 0101 	adc.w	r1, r1, r1
 80003ea:	3c01      	subs	r4, #1
 80003ec:	bf28      	it	cs
 80003ee:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80003f2:	d2e9      	bcs.n	80003c8 <__adddf3+0x10c>
 80003f4:	f091 0f00 	teq	r1, #0
 80003f8:	bf04      	itt	eq
 80003fa:	4601      	moveq	r1, r0
 80003fc:	2000      	moveq	r0, #0
 80003fe:	fab1 f381 	clz	r3, r1
 8000402:	bf08      	it	eq
 8000404:	3320      	addeq	r3, #32
 8000406:	f1a3 030b 	sub.w	r3, r3, #11
 800040a:	f1b3 0220 	subs.w	r2, r3, #32
 800040e:	da0c      	bge.n	800042a <__adddf3+0x16e>
 8000410:	320c      	adds	r2, #12
 8000412:	dd08      	ble.n	8000426 <__adddf3+0x16a>
 8000414:	f102 0c14 	add.w	ip, r2, #20
 8000418:	f1c2 020c 	rsb	r2, r2, #12
 800041c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000420:	fa21 f102 	lsr.w	r1, r1, r2
 8000424:	e00c      	b.n	8000440 <__adddf3+0x184>
 8000426:	f102 0214 	add.w	r2, r2, #20
 800042a:	bfd8      	it	le
 800042c:	f1c2 0c20 	rsble	ip, r2, #32
 8000430:	fa01 f102 	lsl.w	r1, r1, r2
 8000434:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000438:	bfdc      	itt	le
 800043a:	ea41 010c 	orrle.w	r1, r1, ip
 800043e:	4090      	lslle	r0, r2
 8000440:	1ae4      	subs	r4, r4, r3
 8000442:	bfa2      	ittt	ge
 8000444:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000448:	4329      	orrge	r1, r5
 800044a:	bd30      	popge	{r4, r5, pc}
 800044c:	ea6f 0404 	mvn.w	r4, r4
 8000450:	3c1f      	subs	r4, #31
 8000452:	da1c      	bge.n	800048e <__adddf3+0x1d2>
 8000454:	340c      	adds	r4, #12
 8000456:	dc0e      	bgt.n	8000476 <__adddf3+0x1ba>
 8000458:	f104 0414 	add.w	r4, r4, #20
 800045c:	f1c4 0220 	rsb	r2, r4, #32
 8000460:	fa20 f004 	lsr.w	r0, r0, r4
 8000464:	fa01 f302 	lsl.w	r3, r1, r2
 8000468:	ea40 0003 	orr.w	r0, r0, r3
 800046c:	fa21 f304 	lsr.w	r3, r1, r4
 8000470:	ea45 0103 	orr.w	r1, r5, r3
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f1c4 040c 	rsb	r4, r4, #12
 800047a:	f1c4 0220 	rsb	r2, r4, #32
 800047e:	fa20 f002 	lsr.w	r0, r0, r2
 8000482:	fa01 f304 	lsl.w	r3, r1, r4
 8000486:	ea40 0003 	orr.w	r0, r0, r3
 800048a:	4629      	mov	r1, r5
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	fa21 f004 	lsr.w	r0, r1, r4
 8000492:	4629      	mov	r1, r5
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f094 0f00 	teq	r4, #0
 800049a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800049e:	bf06      	itte	eq
 80004a0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004a4:	3401      	addeq	r4, #1
 80004a6:	3d01      	subne	r5, #1
 80004a8:	e74e      	b.n	8000348 <__adddf3+0x8c>
 80004aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ae:	bf18      	it	ne
 80004b0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004b4:	d029      	beq.n	800050a <__adddf3+0x24e>
 80004b6:	ea94 0f05 	teq	r4, r5
 80004ba:	bf08      	it	eq
 80004bc:	ea90 0f02 	teqeq	r0, r2
 80004c0:	d005      	beq.n	80004ce <__adddf3+0x212>
 80004c2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004c6:	bf04      	itt	eq
 80004c8:	4619      	moveq	r1, r3
 80004ca:	4610      	moveq	r0, r2
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	ea91 0f03 	teq	r1, r3
 80004d2:	bf1e      	ittt	ne
 80004d4:	2100      	movne	r1, #0
 80004d6:	2000      	movne	r0, #0
 80004d8:	bd30      	popne	{r4, r5, pc}
 80004da:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004de:	d105      	bne.n	80004ec <__adddf3+0x230>
 80004e0:	0040      	lsls	r0, r0, #1
 80004e2:	4149      	adcs	r1, r1
 80004e4:	bf28      	it	cs
 80004e6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ea:	bd30      	pop	{r4, r5, pc}
 80004ec:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004f0:	bf3c      	itt	cc
 80004f2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004f6:	bd30      	popcc	{r4, r5, pc}
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000500:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000504:	f04f 0000 	mov.w	r0, #0
 8000508:	bd30      	pop	{r4, r5, pc}
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf1a      	itte	ne
 8000510:	4619      	movne	r1, r3
 8000512:	4610      	movne	r0, r2
 8000514:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000518:	bf1c      	itt	ne
 800051a:	460b      	movne	r3, r1
 800051c:	4602      	movne	r2, r0
 800051e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000522:	bf06      	itte	eq
 8000524:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000528:	ea91 0f03 	teqeq	r1, r3
 800052c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	bf00      	nop

08000534 <__aeabi_ui2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f04f 0500 	mov.w	r5, #0
 800054c:	f04f 0100 	mov.w	r1, #0
 8000550:	e750      	b.n	80003f4 <__adddf3+0x138>
 8000552:	bf00      	nop

08000554 <__aeabi_i2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800056c:	bf48      	it	mi
 800056e:	4240      	negmi	r0, r0
 8000570:	f04f 0100 	mov.w	r1, #0
 8000574:	e73e      	b.n	80003f4 <__adddf3+0x138>
 8000576:	bf00      	nop

08000578 <__aeabi_f2d>:
 8000578:	0042      	lsls	r2, r0, #1
 800057a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800057e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000582:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000586:	bf1f      	itttt	ne
 8000588:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000594:	4770      	bxne	lr
 8000596:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800059a:	bf08      	it	eq
 800059c:	4770      	bxeq	lr
 800059e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005a2:	bf04      	itt	eq
 80005a4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005a8:	4770      	bxeq	lr
 80005aa:	b530      	push	{r4, r5, lr}
 80005ac:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005b0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005b4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005b8:	e71c      	b.n	80003f4 <__adddf3+0x138>
 80005ba:	bf00      	nop

080005bc <__aeabi_ul2d>:
 80005bc:	ea50 0201 	orrs.w	r2, r0, r1
 80005c0:	bf08      	it	eq
 80005c2:	4770      	bxeq	lr
 80005c4:	b530      	push	{r4, r5, lr}
 80005c6:	f04f 0500 	mov.w	r5, #0
 80005ca:	e00a      	b.n	80005e2 <__aeabi_l2d+0x16>

080005cc <__aeabi_l2d>:
 80005cc:	ea50 0201 	orrs.w	r2, r0, r1
 80005d0:	bf08      	it	eq
 80005d2:	4770      	bxeq	lr
 80005d4:	b530      	push	{r4, r5, lr}
 80005d6:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005da:	d502      	bpl.n	80005e2 <__aeabi_l2d+0x16>
 80005dc:	4240      	negs	r0, r0
 80005de:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005e2:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005e6:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005ea:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005ee:	f43f aed8 	beq.w	80003a2 <__adddf3+0xe6>
 80005f2:	f04f 0203 	mov.w	r2, #3
 80005f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005fa:	bf18      	it	ne
 80005fc:	3203      	addne	r2, #3
 80005fe:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000602:	bf18      	it	ne
 8000604:	3203      	addne	r2, #3
 8000606:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800060a:	f1c2 0320 	rsb	r3, r2, #32
 800060e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000612:	fa20 f002 	lsr.w	r0, r0, r2
 8000616:	fa01 fe03 	lsl.w	lr, r1, r3
 800061a:	ea40 000e 	orr.w	r0, r0, lr
 800061e:	fa21 f102 	lsr.w	r1, r1, r2
 8000622:	4414      	add	r4, r2
 8000624:	e6bd      	b.n	80003a2 <__adddf3+0xe6>
 8000626:	bf00      	nop

08000628 <__aeabi_dmul>:
 8000628:	b570      	push	{r4, r5, r6, lr}
 800062a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800062e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000632:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000636:	bf1d      	ittte	ne
 8000638:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800063c:	ea94 0f0c 	teqne	r4, ip
 8000640:	ea95 0f0c 	teqne	r5, ip
 8000644:	f000 f8de 	bleq	8000804 <__aeabi_dmul+0x1dc>
 8000648:	442c      	add	r4, r5
 800064a:	ea81 0603 	eor.w	r6, r1, r3
 800064e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000652:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000656:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800065a:	bf18      	it	ne
 800065c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000660:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000664:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000668:	d038      	beq.n	80006dc <__aeabi_dmul+0xb4>
 800066a:	fba0 ce02 	umull	ip, lr, r0, r2
 800066e:	f04f 0500 	mov.w	r5, #0
 8000672:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000676:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800067a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800067e:	f04f 0600 	mov.w	r6, #0
 8000682:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000686:	f09c 0f00 	teq	ip, #0
 800068a:	bf18      	it	ne
 800068c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000690:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000694:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000698:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800069c:	d204      	bcs.n	80006a8 <__aeabi_dmul+0x80>
 800069e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006a2:	416d      	adcs	r5, r5
 80006a4:	eb46 0606 	adc.w	r6, r6, r6
 80006a8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006ac:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006b0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006b4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006b8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006bc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006c0:	bf88      	it	hi
 80006c2:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006c6:	d81e      	bhi.n	8000706 <__aeabi_dmul+0xde>
 80006c8:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006cc:	bf08      	it	eq
 80006ce:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006d2:	f150 0000 	adcs.w	r0, r0, #0
 80006d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006da:	bd70      	pop	{r4, r5, r6, pc}
 80006dc:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006e0:	ea46 0101 	orr.w	r1, r6, r1
 80006e4:	ea40 0002 	orr.w	r0, r0, r2
 80006e8:	ea81 0103 	eor.w	r1, r1, r3
 80006ec:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006f0:	bfc2      	ittt	gt
 80006f2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006f6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006fa:	bd70      	popgt	{r4, r5, r6, pc}
 80006fc:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000700:	f04f 0e00 	mov.w	lr, #0
 8000704:	3c01      	subs	r4, #1
 8000706:	f300 80ab 	bgt.w	8000860 <__aeabi_dmul+0x238>
 800070a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800070e:	bfde      	ittt	le
 8000710:	2000      	movle	r0, #0
 8000712:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8000716:	bd70      	pople	{r4, r5, r6, pc}
 8000718:	f1c4 0400 	rsb	r4, r4, #0
 800071c:	3c20      	subs	r4, #32
 800071e:	da35      	bge.n	800078c <__aeabi_dmul+0x164>
 8000720:	340c      	adds	r4, #12
 8000722:	dc1b      	bgt.n	800075c <__aeabi_dmul+0x134>
 8000724:	f104 0414 	add.w	r4, r4, #20
 8000728:	f1c4 0520 	rsb	r5, r4, #32
 800072c:	fa00 f305 	lsl.w	r3, r0, r5
 8000730:	fa20 f004 	lsr.w	r0, r0, r4
 8000734:	fa01 f205 	lsl.w	r2, r1, r5
 8000738:	ea40 0002 	orr.w	r0, r0, r2
 800073c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000740:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000744:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000748:	fa21 f604 	lsr.w	r6, r1, r4
 800074c:	eb42 0106 	adc.w	r1, r2, r6
 8000750:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000754:	bf08      	it	eq
 8000756:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800075a:	bd70      	pop	{r4, r5, r6, pc}
 800075c:	f1c4 040c 	rsb	r4, r4, #12
 8000760:	f1c4 0520 	rsb	r5, r4, #32
 8000764:	fa00 f304 	lsl.w	r3, r0, r4
 8000768:	fa20 f005 	lsr.w	r0, r0, r5
 800076c:	fa01 f204 	lsl.w	r2, r1, r4
 8000770:	ea40 0002 	orr.w	r0, r0, r2
 8000774:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000778:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800077c:	f141 0100 	adc.w	r1, r1, #0
 8000780:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000784:	bf08      	it	eq
 8000786:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800078a:	bd70      	pop	{r4, r5, r6, pc}
 800078c:	f1c4 0520 	rsb	r5, r4, #32
 8000790:	fa00 f205 	lsl.w	r2, r0, r5
 8000794:	ea4e 0e02 	orr.w	lr, lr, r2
 8000798:	fa20 f304 	lsr.w	r3, r0, r4
 800079c:	fa01 f205 	lsl.w	r2, r1, r5
 80007a0:	ea43 0302 	orr.w	r3, r3, r2
 80007a4:	fa21 f004 	lsr.w	r0, r1, r4
 80007a8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007ac:	fa21 f204 	lsr.w	r2, r1, r4
 80007b0:	ea20 0002 	bic.w	r0, r0, r2
 80007b4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007b8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007bc:	bf08      	it	eq
 80007be:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007c2:	bd70      	pop	{r4, r5, r6, pc}
 80007c4:	f094 0f00 	teq	r4, #0
 80007c8:	d10f      	bne.n	80007ea <__aeabi_dmul+0x1c2>
 80007ca:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007ce:	0040      	lsls	r0, r0, #1
 80007d0:	eb41 0101 	adc.w	r1, r1, r1
 80007d4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007d8:	bf08      	it	eq
 80007da:	3c01      	subeq	r4, #1
 80007dc:	d0f7      	beq.n	80007ce <__aeabi_dmul+0x1a6>
 80007de:	ea41 0106 	orr.w	r1, r1, r6
 80007e2:	f095 0f00 	teq	r5, #0
 80007e6:	bf18      	it	ne
 80007e8:	4770      	bxne	lr
 80007ea:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007ee:	0052      	lsls	r2, r2, #1
 80007f0:	eb43 0303 	adc.w	r3, r3, r3
 80007f4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007f8:	bf08      	it	eq
 80007fa:	3d01      	subeq	r5, #1
 80007fc:	d0f7      	beq.n	80007ee <__aeabi_dmul+0x1c6>
 80007fe:	ea43 0306 	orr.w	r3, r3, r6
 8000802:	4770      	bx	lr
 8000804:	ea94 0f0c 	teq	r4, ip
 8000808:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800080c:	bf18      	it	ne
 800080e:	ea95 0f0c 	teqne	r5, ip
 8000812:	d00c      	beq.n	800082e <__aeabi_dmul+0x206>
 8000814:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000818:	bf18      	it	ne
 800081a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800081e:	d1d1      	bne.n	80007c4 <__aeabi_dmul+0x19c>
 8000820:	ea81 0103 	eor.w	r1, r1, r3
 8000824:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000828:	f04f 0000 	mov.w	r0, #0
 800082c:	bd70      	pop	{r4, r5, r6, pc}
 800082e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000832:	bf06      	itte	eq
 8000834:	4610      	moveq	r0, r2
 8000836:	4619      	moveq	r1, r3
 8000838:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800083c:	d019      	beq.n	8000872 <__aeabi_dmul+0x24a>
 800083e:	ea94 0f0c 	teq	r4, ip
 8000842:	d102      	bne.n	800084a <__aeabi_dmul+0x222>
 8000844:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000848:	d113      	bne.n	8000872 <__aeabi_dmul+0x24a>
 800084a:	ea95 0f0c 	teq	r5, ip
 800084e:	d105      	bne.n	800085c <__aeabi_dmul+0x234>
 8000850:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000854:	bf1c      	itt	ne
 8000856:	4610      	movne	r0, r2
 8000858:	4619      	movne	r1, r3
 800085a:	d10a      	bne.n	8000872 <__aeabi_dmul+0x24a>
 800085c:	ea81 0103 	eor.w	r1, r1, r3
 8000860:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000864:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000868:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800086c:	f04f 0000 	mov.w	r0, #0
 8000870:	bd70      	pop	{r4, r5, r6, pc}
 8000872:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000876:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800087a:	bd70      	pop	{r4, r5, r6, pc}

0800087c <__aeabi_ddiv>:
 800087c:	b570      	push	{r4, r5, r6, lr}
 800087e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000882:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000886:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800088a:	bf1d      	ittte	ne
 800088c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000890:	ea94 0f0c 	teqne	r4, ip
 8000894:	ea95 0f0c 	teqne	r5, ip
 8000898:	f000 f8a7 	bleq	80009ea <__aeabi_ddiv+0x16e>
 800089c:	eba4 0405 	sub.w	r4, r4, r5
 80008a0:	ea81 0e03 	eor.w	lr, r1, r3
 80008a4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008a8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008ac:	f000 8088 	beq.w	80009c0 <__aeabi_ddiv+0x144>
 80008b0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008b4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008b8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008bc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008c0:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008c4:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008c8:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008cc:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008d0:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008d4:	429d      	cmp	r5, r3
 80008d6:	bf08      	it	eq
 80008d8:	4296      	cmpeq	r6, r2
 80008da:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008de:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008e2:	d202      	bcs.n	80008ea <__aeabi_ddiv+0x6e>
 80008e4:	085b      	lsrs	r3, r3, #1
 80008e6:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ea:	1ab6      	subs	r6, r6, r2
 80008ec:	eb65 0503 	sbc.w	r5, r5, r3
 80008f0:	085b      	lsrs	r3, r3, #1
 80008f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80008f6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008fa:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008fe:	ebb6 0e02 	subs.w	lr, r6, r2
 8000902:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000906:	bf22      	ittt	cs
 8000908:	1ab6      	subcs	r6, r6, r2
 800090a:	4675      	movcs	r5, lr
 800090c:	ea40 000c 	orrcs.w	r0, r0, ip
 8000910:	085b      	lsrs	r3, r3, #1
 8000912:	ea4f 0232 	mov.w	r2, r2, rrx
 8000916:	ebb6 0e02 	subs.w	lr, r6, r2
 800091a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800091e:	bf22      	ittt	cs
 8000920:	1ab6      	subcs	r6, r6, r2
 8000922:	4675      	movcs	r5, lr
 8000924:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000928:	085b      	lsrs	r3, r3, #1
 800092a:	ea4f 0232 	mov.w	r2, r2, rrx
 800092e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000932:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000936:	bf22      	ittt	cs
 8000938:	1ab6      	subcs	r6, r6, r2
 800093a:	4675      	movcs	r5, lr
 800093c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000940:	085b      	lsrs	r3, r3, #1
 8000942:	ea4f 0232 	mov.w	r2, r2, rrx
 8000946:	ebb6 0e02 	subs.w	lr, r6, r2
 800094a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800094e:	bf22      	ittt	cs
 8000950:	1ab6      	subcs	r6, r6, r2
 8000952:	4675      	movcs	r5, lr
 8000954:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000958:	ea55 0e06 	orrs.w	lr, r5, r6
 800095c:	d018      	beq.n	8000990 <__aeabi_ddiv+0x114>
 800095e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000962:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000966:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800096a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800096e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000972:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000976:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800097a:	d1c0      	bne.n	80008fe <__aeabi_ddiv+0x82>
 800097c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000980:	d10b      	bne.n	800099a <__aeabi_ddiv+0x11e>
 8000982:	ea41 0100 	orr.w	r1, r1, r0
 8000986:	f04f 0000 	mov.w	r0, #0
 800098a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800098e:	e7b6      	b.n	80008fe <__aeabi_ddiv+0x82>
 8000990:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000994:	bf04      	itt	eq
 8000996:	4301      	orreq	r1, r0
 8000998:	2000      	moveq	r0, #0
 800099a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800099e:	bf88      	it	hi
 80009a0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009a4:	f63f aeaf 	bhi.w	8000706 <__aeabi_dmul+0xde>
 80009a8:	ebb5 0c03 	subs.w	ip, r5, r3
 80009ac:	bf04      	itt	eq
 80009ae:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009b2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009b6:	f150 0000 	adcs.w	r0, r0, #0
 80009ba:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009be:	bd70      	pop	{r4, r5, r6, pc}
 80009c0:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009c4:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009c8:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009cc:	bfc2      	ittt	gt
 80009ce:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009d2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009d6:	bd70      	popgt	{r4, r5, r6, pc}
 80009d8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009dc:	f04f 0e00 	mov.w	lr, #0
 80009e0:	3c01      	subs	r4, #1
 80009e2:	e690      	b.n	8000706 <__aeabi_dmul+0xde>
 80009e4:	ea45 0e06 	orr.w	lr, r5, r6
 80009e8:	e68d      	b.n	8000706 <__aeabi_dmul+0xde>
 80009ea:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009ee:	ea94 0f0c 	teq	r4, ip
 80009f2:	bf08      	it	eq
 80009f4:	ea95 0f0c 	teqeq	r5, ip
 80009f8:	f43f af3b 	beq.w	8000872 <__aeabi_dmul+0x24a>
 80009fc:	ea94 0f0c 	teq	r4, ip
 8000a00:	d10a      	bne.n	8000a18 <__aeabi_ddiv+0x19c>
 8000a02:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a06:	f47f af34 	bne.w	8000872 <__aeabi_dmul+0x24a>
 8000a0a:	ea95 0f0c 	teq	r5, ip
 8000a0e:	f47f af25 	bne.w	800085c <__aeabi_dmul+0x234>
 8000a12:	4610      	mov	r0, r2
 8000a14:	4619      	mov	r1, r3
 8000a16:	e72c      	b.n	8000872 <__aeabi_dmul+0x24a>
 8000a18:	ea95 0f0c 	teq	r5, ip
 8000a1c:	d106      	bne.n	8000a2c <__aeabi_ddiv+0x1b0>
 8000a1e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a22:	f43f aefd 	beq.w	8000820 <__aeabi_dmul+0x1f8>
 8000a26:	4610      	mov	r0, r2
 8000a28:	4619      	mov	r1, r3
 8000a2a:	e722      	b.n	8000872 <__aeabi_dmul+0x24a>
 8000a2c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a30:	bf18      	it	ne
 8000a32:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a36:	f47f aec5 	bne.w	80007c4 <__aeabi_dmul+0x19c>
 8000a3a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a3e:	f47f af0d 	bne.w	800085c <__aeabi_dmul+0x234>
 8000a42:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a46:	f47f aeeb 	bne.w	8000820 <__aeabi_dmul+0x1f8>
 8000a4a:	e712      	b.n	8000872 <__aeabi_dmul+0x24a>

08000a4c <__gedf2>:
 8000a4c:	f04f 3cff 	mov.w	ip, #4294967295
 8000a50:	e006      	b.n	8000a60 <__cmpdf2+0x4>
 8000a52:	bf00      	nop

08000a54 <__ledf2>:
 8000a54:	f04f 0c01 	mov.w	ip, #1
 8000a58:	e002      	b.n	8000a60 <__cmpdf2+0x4>
 8000a5a:	bf00      	nop

08000a5c <__cmpdf2>:
 8000a5c:	f04f 0c01 	mov.w	ip, #1
 8000a60:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000a64:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000a68:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000a6c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000a70:	bf18      	it	ne
 8000a72:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000a76:	d01b      	beq.n	8000ab0 <__cmpdf2+0x54>
 8000a78:	b001      	add	sp, #4
 8000a7a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000a7e:	bf0c      	ite	eq
 8000a80:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000a84:	ea91 0f03 	teqne	r1, r3
 8000a88:	bf02      	ittt	eq
 8000a8a:	ea90 0f02 	teqeq	r0, r2
 8000a8e:	2000      	moveq	r0, #0
 8000a90:	4770      	bxeq	lr
 8000a92:	f110 0f00 	cmn.w	r0, #0
 8000a96:	ea91 0f03 	teq	r1, r3
 8000a9a:	bf58      	it	pl
 8000a9c:	4299      	cmppl	r1, r3
 8000a9e:	bf08      	it	eq
 8000aa0:	4290      	cmpeq	r0, r2
 8000aa2:	bf2c      	ite	cs
 8000aa4:	17d8      	asrcs	r0, r3, #31
 8000aa6:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000aaa:	f040 0001 	orr.w	r0, r0, #1
 8000aae:	4770      	bx	lr
 8000ab0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000ab4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ab8:	d102      	bne.n	8000ac0 <__cmpdf2+0x64>
 8000aba:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000abe:	d107      	bne.n	8000ad0 <__cmpdf2+0x74>
 8000ac0:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000ac4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000ac8:	d1d6      	bne.n	8000a78 <__cmpdf2+0x1c>
 8000aca:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000ace:	d0d3      	beq.n	8000a78 <__cmpdf2+0x1c>
 8000ad0:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000ad4:	4770      	bx	lr
 8000ad6:	bf00      	nop

08000ad8 <__aeabi_cdrcmple>:
 8000ad8:	4684      	mov	ip, r0
 8000ada:	4610      	mov	r0, r2
 8000adc:	4662      	mov	r2, ip
 8000ade:	468c      	mov	ip, r1
 8000ae0:	4619      	mov	r1, r3
 8000ae2:	4663      	mov	r3, ip
 8000ae4:	e000      	b.n	8000ae8 <__aeabi_cdcmpeq>
 8000ae6:	bf00      	nop

08000ae8 <__aeabi_cdcmpeq>:
 8000ae8:	b501      	push	{r0, lr}
 8000aea:	f7ff ffb7 	bl	8000a5c <__cmpdf2>
 8000aee:	2800      	cmp	r0, #0
 8000af0:	bf48      	it	mi
 8000af2:	f110 0f00 	cmnmi.w	r0, #0
 8000af6:	bd01      	pop	{r0, pc}

08000af8 <__aeabi_dcmpeq>:
 8000af8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000afc:	f7ff fff4 	bl	8000ae8 <__aeabi_cdcmpeq>
 8000b00:	bf0c      	ite	eq
 8000b02:	2001      	moveq	r0, #1
 8000b04:	2000      	movne	r0, #0
 8000b06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b0a:	bf00      	nop

08000b0c <__aeabi_dcmplt>:
 8000b0c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b10:	f7ff ffea 	bl	8000ae8 <__aeabi_cdcmpeq>
 8000b14:	bf34      	ite	cc
 8000b16:	2001      	movcc	r0, #1
 8000b18:	2000      	movcs	r0, #0
 8000b1a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b1e:	bf00      	nop

08000b20 <__aeabi_dcmple>:
 8000b20:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b24:	f7ff ffe0 	bl	8000ae8 <__aeabi_cdcmpeq>
 8000b28:	bf94      	ite	ls
 8000b2a:	2001      	movls	r0, #1
 8000b2c:	2000      	movhi	r0, #0
 8000b2e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b32:	bf00      	nop

08000b34 <__aeabi_dcmpge>:
 8000b34:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b38:	f7ff ffce 	bl	8000ad8 <__aeabi_cdrcmple>
 8000b3c:	bf94      	ite	ls
 8000b3e:	2001      	movls	r0, #1
 8000b40:	2000      	movhi	r0, #0
 8000b42:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b46:	bf00      	nop

08000b48 <__aeabi_dcmpgt>:
 8000b48:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000b4c:	f7ff ffc4 	bl	8000ad8 <__aeabi_cdrcmple>
 8000b50:	bf34      	ite	cc
 8000b52:	2001      	movcc	r0, #1
 8000b54:	2000      	movcs	r0, #0
 8000b56:	f85d fb08 	ldr.w	pc, [sp], #8
 8000b5a:	bf00      	nop

08000b5c <__aeabi_dcmpun>:
 8000b5c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000b60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b64:	d102      	bne.n	8000b6c <__aeabi_dcmpun+0x10>
 8000b66:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000b6a:	d10a      	bne.n	8000b82 <__aeabi_dcmpun+0x26>
 8000b6c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000b70:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000b74:	d102      	bne.n	8000b7c <__aeabi_dcmpun+0x20>
 8000b76:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000b7a:	d102      	bne.n	8000b82 <__aeabi_dcmpun+0x26>
 8000b7c:	f04f 0000 	mov.w	r0, #0
 8000b80:	4770      	bx	lr
 8000b82:	f04f 0001 	mov.w	r0, #1
 8000b86:	4770      	bx	lr

08000b88 <__aeabi_d2iz>:
 8000b88:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000b8c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000b90:	d215      	bcs.n	8000bbe <__aeabi_d2iz+0x36>
 8000b92:	d511      	bpl.n	8000bb8 <__aeabi_d2iz+0x30>
 8000b94:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000b98:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000b9c:	d912      	bls.n	8000bc4 <__aeabi_d2iz+0x3c>
 8000b9e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ba2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000ba6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000baa:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000bae:	fa23 f002 	lsr.w	r0, r3, r2
 8000bb2:	bf18      	it	ne
 8000bb4:	4240      	negne	r0, r0
 8000bb6:	4770      	bx	lr
 8000bb8:	f04f 0000 	mov.w	r0, #0
 8000bbc:	4770      	bx	lr
 8000bbe:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000bc2:	d105      	bne.n	8000bd0 <__aeabi_d2iz+0x48>
 8000bc4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000bc8:	bf08      	it	eq
 8000bca:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000bce:	4770      	bx	lr
 8000bd0:	f04f 0000 	mov.w	r0, #0
 8000bd4:	4770      	bx	lr
 8000bd6:	bf00      	nop

08000bd8 <__aeabi_uldivmod>:
 8000bd8:	b953      	cbnz	r3, 8000bf0 <__aeabi_uldivmod+0x18>
 8000bda:	b94a      	cbnz	r2, 8000bf0 <__aeabi_uldivmod+0x18>
 8000bdc:	2900      	cmp	r1, #0
 8000bde:	bf08      	it	eq
 8000be0:	2800      	cmpeq	r0, #0
 8000be2:	bf1c      	itt	ne
 8000be4:	f04f 31ff 	movne.w	r1, #4294967295
 8000be8:	f04f 30ff 	movne.w	r0, #4294967295
 8000bec:	f000 b970 	b.w	8000ed0 <__aeabi_idiv0>
 8000bf0:	f1ad 0c08 	sub.w	ip, sp, #8
 8000bf4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000bf8:	f000 f806 	bl	8000c08 <__udivmoddi4>
 8000bfc:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000c00:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000c04:	b004      	add	sp, #16
 8000c06:	4770      	bx	lr

08000c08 <__udivmoddi4>:
 8000c08:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000c0c:	9e08      	ldr	r6, [sp, #32]
 8000c0e:	460d      	mov	r5, r1
 8000c10:	4604      	mov	r4, r0
 8000c12:	460f      	mov	r7, r1
 8000c14:	2b00      	cmp	r3, #0
 8000c16:	d14a      	bne.n	8000cae <__udivmoddi4+0xa6>
 8000c18:	428a      	cmp	r2, r1
 8000c1a:	4694      	mov	ip, r2
 8000c1c:	d965      	bls.n	8000cea <__udivmoddi4+0xe2>
 8000c1e:	fab2 f382 	clz	r3, r2
 8000c22:	b143      	cbz	r3, 8000c36 <__udivmoddi4+0x2e>
 8000c24:	fa02 fc03 	lsl.w	ip, r2, r3
 8000c28:	f1c3 0220 	rsb	r2, r3, #32
 8000c2c:	409f      	lsls	r7, r3
 8000c2e:	fa20 f202 	lsr.w	r2, r0, r2
 8000c32:	4317      	orrs	r7, r2
 8000c34:	409c      	lsls	r4, r3
 8000c36:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 8000c3a:	fa1f f58c 	uxth.w	r5, ip
 8000c3e:	fbb7 f1fe 	udiv	r1, r7, lr
 8000c42:	0c22      	lsrs	r2, r4, #16
 8000c44:	fb0e 7711 	mls	r7, lr, r1, r7
 8000c48:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8000c4c:	fb01 f005 	mul.w	r0, r1, r5
 8000c50:	4290      	cmp	r0, r2
 8000c52:	d90a      	bls.n	8000c6a <__udivmoddi4+0x62>
 8000c54:	eb1c 0202 	adds.w	r2, ip, r2
 8000c58:	f101 37ff 	add.w	r7, r1, #4294967295
 8000c5c:	f080 811c 	bcs.w	8000e98 <__udivmoddi4+0x290>
 8000c60:	4290      	cmp	r0, r2
 8000c62:	f240 8119 	bls.w	8000e98 <__udivmoddi4+0x290>
 8000c66:	3902      	subs	r1, #2
 8000c68:	4462      	add	r2, ip
 8000c6a:	1a12      	subs	r2, r2, r0
 8000c6c:	b2a4      	uxth	r4, r4
 8000c6e:	fbb2 f0fe 	udiv	r0, r2, lr
 8000c72:	fb0e 2210 	mls	r2, lr, r0, r2
 8000c76:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000c7a:	fb00 f505 	mul.w	r5, r0, r5
 8000c7e:	42a5      	cmp	r5, r4
 8000c80:	d90a      	bls.n	8000c98 <__udivmoddi4+0x90>
 8000c82:	eb1c 0404 	adds.w	r4, ip, r4
 8000c86:	f100 32ff 	add.w	r2, r0, #4294967295
 8000c8a:	f080 8107 	bcs.w	8000e9c <__udivmoddi4+0x294>
 8000c8e:	42a5      	cmp	r5, r4
 8000c90:	f240 8104 	bls.w	8000e9c <__udivmoddi4+0x294>
 8000c94:	4464      	add	r4, ip
 8000c96:	3802      	subs	r0, #2
 8000c98:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 8000c9c:	1b64      	subs	r4, r4, r5
 8000c9e:	2100      	movs	r1, #0
 8000ca0:	b11e      	cbz	r6, 8000caa <__udivmoddi4+0xa2>
 8000ca2:	40dc      	lsrs	r4, r3
 8000ca4:	2300      	movs	r3, #0
 8000ca6:	e9c6 4300 	strd	r4, r3, [r6]
 8000caa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000cae:	428b      	cmp	r3, r1
 8000cb0:	d908      	bls.n	8000cc4 <__udivmoddi4+0xbc>
 8000cb2:	2e00      	cmp	r6, #0
 8000cb4:	f000 80ed 	beq.w	8000e92 <__udivmoddi4+0x28a>
 8000cb8:	2100      	movs	r1, #0
 8000cba:	e9c6 0500 	strd	r0, r5, [r6]
 8000cbe:	4608      	mov	r0, r1
 8000cc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000cc4:	fab3 f183 	clz	r1, r3
 8000cc8:	2900      	cmp	r1, #0
 8000cca:	d149      	bne.n	8000d60 <__udivmoddi4+0x158>
 8000ccc:	42ab      	cmp	r3, r5
 8000cce:	d302      	bcc.n	8000cd6 <__udivmoddi4+0xce>
 8000cd0:	4282      	cmp	r2, r0
 8000cd2:	f200 80f8 	bhi.w	8000ec6 <__udivmoddi4+0x2be>
 8000cd6:	1a84      	subs	r4, r0, r2
 8000cd8:	eb65 0203 	sbc.w	r2, r5, r3
 8000cdc:	2001      	movs	r0, #1
 8000cde:	4617      	mov	r7, r2
 8000ce0:	2e00      	cmp	r6, #0
 8000ce2:	d0e2      	beq.n	8000caa <__udivmoddi4+0xa2>
 8000ce4:	e9c6 4700 	strd	r4, r7, [r6]
 8000ce8:	e7df      	b.n	8000caa <__udivmoddi4+0xa2>
 8000cea:	b902      	cbnz	r2, 8000cee <__udivmoddi4+0xe6>
 8000cec:	deff      	udf	#255	; 0xff
 8000cee:	fab2 f382 	clz	r3, r2
 8000cf2:	2b00      	cmp	r3, #0
 8000cf4:	f040 8090 	bne.w	8000e18 <__udivmoddi4+0x210>
 8000cf8:	1a8a      	subs	r2, r1, r2
 8000cfa:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000cfe:	fa1f fe8c 	uxth.w	lr, ip
 8000d02:	2101      	movs	r1, #1
 8000d04:	fbb2 f5f7 	udiv	r5, r2, r7
 8000d08:	fb07 2015 	mls	r0, r7, r5, r2
 8000d0c:	0c22      	lsrs	r2, r4, #16
 8000d0e:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8000d12:	fb0e f005 	mul.w	r0, lr, r5
 8000d16:	4290      	cmp	r0, r2
 8000d18:	d908      	bls.n	8000d2c <__udivmoddi4+0x124>
 8000d1a:	eb1c 0202 	adds.w	r2, ip, r2
 8000d1e:	f105 38ff 	add.w	r8, r5, #4294967295
 8000d22:	d202      	bcs.n	8000d2a <__udivmoddi4+0x122>
 8000d24:	4290      	cmp	r0, r2
 8000d26:	f200 80cb 	bhi.w	8000ec0 <__udivmoddi4+0x2b8>
 8000d2a:	4645      	mov	r5, r8
 8000d2c:	1a12      	subs	r2, r2, r0
 8000d2e:	b2a4      	uxth	r4, r4
 8000d30:	fbb2 f0f7 	udiv	r0, r2, r7
 8000d34:	fb07 2210 	mls	r2, r7, r0, r2
 8000d38:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 8000d3c:	fb0e fe00 	mul.w	lr, lr, r0
 8000d40:	45a6      	cmp	lr, r4
 8000d42:	d908      	bls.n	8000d56 <__udivmoddi4+0x14e>
 8000d44:	eb1c 0404 	adds.w	r4, ip, r4
 8000d48:	f100 32ff 	add.w	r2, r0, #4294967295
 8000d4c:	d202      	bcs.n	8000d54 <__udivmoddi4+0x14c>
 8000d4e:	45a6      	cmp	lr, r4
 8000d50:	f200 80bb 	bhi.w	8000eca <__udivmoddi4+0x2c2>
 8000d54:	4610      	mov	r0, r2
 8000d56:	eba4 040e 	sub.w	r4, r4, lr
 8000d5a:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 8000d5e:	e79f      	b.n	8000ca0 <__udivmoddi4+0x98>
 8000d60:	f1c1 0720 	rsb	r7, r1, #32
 8000d64:	408b      	lsls	r3, r1
 8000d66:	fa22 fc07 	lsr.w	ip, r2, r7
 8000d6a:	ea4c 0c03 	orr.w	ip, ip, r3
 8000d6e:	fa05 f401 	lsl.w	r4, r5, r1
 8000d72:	fa20 f307 	lsr.w	r3, r0, r7
 8000d76:	40fd      	lsrs	r5, r7
 8000d78:	ea4f 491c 	mov.w	r9, ip, lsr #16
 8000d7c:	4323      	orrs	r3, r4
 8000d7e:	fbb5 f8f9 	udiv	r8, r5, r9
 8000d82:	fa1f fe8c 	uxth.w	lr, ip
 8000d86:	fb09 5518 	mls	r5, r9, r8, r5
 8000d8a:	0c1c      	lsrs	r4, r3, #16
 8000d8c:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000d90:	fb08 f50e 	mul.w	r5, r8, lr
 8000d94:	42a5      	cmp	r5, r4
 8000d96:	fa02 f201 	lsl.w	r2, r2, r1
 8000d9a:	fa00 f001 	lsl.w	r0, r0, r1
 8000d9e:	d90b      	bls.n	8000db8 <__udivmoddi4+0x1b0>
 8000da0:	eb1c 0404 	adds.w	r4, ip, r4
 8000da4:	f108 3aff 	add.w	sl, r8, #4294967295
 8000da8:	f080 8088 	bcs.w	8000ebc <__udivmoddi4+0x2b4>
 8000dac:	42a5      	cmp	r5, r4
 8000dae:	f240 8085 	bls.w	8000ebc <__udivmoddi4+0x2b4>
 8000db2:	f1a8 0802 	sub.w	r8, r8, #2
 8000db6:	4464      	add	r4, ip
 8000db8:	1b64      	subs	r4, r4, r5
 8000dba:	b29d      	uxth	r5, r3
 8000dbc:	fbb4 f3f9 	udiv	r3, r4, r9
 8000dc0:	fb09 4413 	mls	r4, r9, r3, r4
 8000dc4:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 8000dc8:	fb03 fe0e 	mul.w	lr, r3, lr
 8000dcc:	45a6      	cmp	lr, r4
 8000dce:	d908      	bls.n	8000de2 <__udivmoddi4+0x1da>
 8000dd0:	eb1c 0404 	adds.w	r4, ip, r4
 8000dd4:	f103 35ff 	add.w	r5, r3, #4294967295
 8000dd8:	d26c      	bcs.n	8000eb4 <__udivmoddi4+0x2ac>
 8000dda:	45a6      	cmp	lr, r4
 8000ddc:	d96a      	bls.n	8000eb4 <__udivmoddi4+0x2ac>
 8000dde:	3b02      	subs	r3, #2
 8000de0:	4464      	add	r4, ip
 8000de2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000de6:	fba3 9502 	umull	r9, r5, r3, r2
 8000dea:	eba4 040e 	sub.w	r4, r4, lr
 8000dee:	42ac      	cmp	r4, r5
 8000df0:	46c8      	mov	r8, r9
 8000df2:	46ae      	mov	lr, r5
 8000df4:	d356      	bcc.n	8000ea4 <__udivmoddi4+0x29c>
 8000df6:	d053      	beq.n	8000ea0 <__udivmoddi4+0x298>
 8000df8:	b156      	cbz	r6, 8000e10 <__udivmoddi4+0x208>
 8000dfa:	ebb0 0208 	subs.w	r2, r0, r8
 8000dfe:	eb64 040e 	sbc.w	r4, r4, lr
 8000e02:	fa04 f707 	lsl.w	r7, r4, r7
 8000e06:	40ca      	lsrs	r2, r1
 8000e08:	40cc      	lsrs	r4, r1
 8000e0a:	4317      	orrs	r7, r2
 8000e0c:	e9c6 7400 	strd	r7, r4, [r6]
 8000e10:	4618      	mov	r0, r3
 8000e12:	2100      	movs	r1, #0
 8000e14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000e18:	f1c3 0120 	rsb	r1, r3, #32
 8000e1c:	fa02 fc03 	lsl.w	ip, r2, r3
 8000e20:	fa20 f201 	lsr.w	r2, r0, r1
 8000e24:	fa25 f101 	lsr.w	r1, r5, r1
 8000e28:	409d      	lsls	r5, r3
 8000e2a:	432a      	orrs	r2, r5
 8000e2c:	ea4f 471c 	mov.w	r7, ip, lsr #16
 8000e30:	fa1f fe8c 	uxth.w	lr, ip
 8000e34:	fbb1 f0f7 	udiv	r0, r1, r7
 8000e38:	fb07 1510 	mls	r5, r7, r0, r1
 8000e3c:	0c11      	lsrs	r1, r2, #16
 8000e3e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
 8000e42:	fb00 f50e 	mul.w	r5, r0, lr
 8000e46:	428d      	cmp	r5, r1
 8000e48:	fa04 f403 	lsl.w	r4, r4, r3
 8000e4c:	d908      	bls.n	8000e60 <__udivmoddi4+0x258>
 8000e4e:	eb1c 0101 	adds.w	r1, ip, r1
 8000e52:	f100 38ff 	add.w	r8, r0, #4294967295
 8000e56:	d22f      	bcs.n	8000eb8 <__udivmoddi4+0x2b0>
 8000e58:	428d      	cmp	r5, r1
 8000e5a:	d92d      	bls.n	8000eb8 <__udivmoddi4+0x2b0>
 8000e5c:	3802      	subs	r0, #2
 8000e5e:	4461      	add	r1, ip
 8000e60:	1b49      	subs	r1, r1, r5
 8000e62:	b292      	uxth	r2, r2
 8000e64:	fbb1 f5f7 	udiv	r5, r1, r7
 8000e68:	fb07 1115 	mls	r1, r7, r5, r1
 8000e6c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8000e70:	fb05 f10e 	mul.w	r1, r5, lr
 8000e74:	4291      	cmp	r1, r2
 8000e76:	d908      	bls.n	8000e8a <__udivmoddi4+0x282>
 8000e78:	eb1c 0202 	adds.w	r2, ip, r2
 8000e7c:	f105 38ff 	add.w	r8, r5, #4294967295
 8000e80:	d216      	bcs.n	8000eb0 <__udivmoddi4+0x2a8>
 8000e82:	4291      	cmp	r1, r2
 8000e84:	d914      	bls.n	8000eb0 <__udivmoddi4+0x2a8>
 8000e86:	3d02      	subs	r5, #2
 8000e88:	4462      	add	r2, ip
 8000e8a:	1a52      	subs	r2, r2, r1
 8000e8c:	ea45 4100 	orr.w	r1, r5, r0, lsl #16
 8000e90:	e738      	b.n	8000d04 <__udivmoddi4+0xfc>
 8000e92:	4631      	mov	r1, r6
 8000e94:	4630      	mov	r0, r6
 8000e96:	e708      	b.n	8000caa <__udivmoddi4+0xa2>
 8000e98:	4639      	mov	r1, r7
 8000e9a:	e6e6      	b.n	8000c6a <__udivmoddi4+0x62>
 8000e9c:	4610      	mov	r0, r2
 8000e9e:	e6fb      	b.n	8000c98 <__udivmoddi4+0x90>
 8000ea0:	4548      	cmp	r0, r9
 8000ea2:	d2a9      	bcs.n	8000df8 <__udivmoddi4+0x1f0>
 8000ea4:	ebb9 0802 	subs.w	r8, r9, r2
 8000ea8:	eb65 0e0c 	sbc.w	lr, r5, ip
 8000eac:	3b01      	subs	r3, #1
 8000eae:	e7a3      	b.n	8000df8 <__udivmoddi4+0x1f0>
 8000eb0:	4645      	mov	r5, r8
 8000eb2:	e7ea      	b.n	8000e8a <__udivmoddi4+0x282>
 8000eb4:	462b      	mov	r3, r5
 8000eb6:	e794      	b.n	8000de2 <__udivmoddi4+0x1da>
 8000eb8:	4640      	mov	r0, r8
 8000eba:	e7d1      	b.n	8000e60 <__udivmoddi4+0x258>
 8000ebc:	46d0      	mov	r8, sl
 8000ebe:	e77b      	b.n	8000db8 <__udivmoddi4+0x1b0>
 8000ec0:	3d02      	subs	r5, #2
 8000ec2:	4462      	add	r2, ip
 8000ec4:	e732      	b.n	8000d2c <__udivmoddi4+0x124>
 8000ec6:	4608      	mov	r0, r1
 8000ec8:	e70a      	b.n	8000ce0 <__udivmoddi4+0xd8>
 8000eca:	4464      	add	r4, ip
 8000ecc:	3802      	subs	r0, #2
 8000ece:	e742      	b.n	8000d56 <__udivmoddi4+0x14e>

08000ed0 <__aeabi_idiv0>:
 8000ed0:	4770      	bx	lr
 8000ed2:	bf00      	nop

08000ed4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Set stack pointer */
 8000ed4:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000f0c <LoopForever+0x2>

/* Call the clock system initialization function.*/
    bl  SystemInit
 8000ed8:	f006 f81e 	bl	8006f18 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8000edc:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8000ede:	e003      	b.n	8000ee8 <LoopCopyDataInit>

08000ee0 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8000ee0:	4b0b      	ldr	r3, [pc, #44]	; (8000f10 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8000ee2:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8000ee4:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8000ee6:	3104      	adds	r1, #4

08000ee8 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8000ee8:	480a      	ldr	r0, [pc, #40]	; (8000f14 <LoopForever+0xa>)
	ldr	r3, =_edata
 8000eea:	4b0b      	ldr	r3, [pc, #44]	; (8000f18 <LoopForever+0xe>)
	adds	r2, r0, r1
 8000eec:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8000eee:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8000ef0:	d3f6      	bcc.n	8000ee0 <CopyDataInit>
	ldr	r2, =_sbss
 8000ef2:	4a0a      	ldr	r2, [pc, #40]	; (8000f1c <LoopForever+0x12>)
	b	LoopFillZerobss
 8000ef4:	e002      	b.n	8000efc <LoopFillZerobss>

08000ef6 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8000ef6:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8000ef8:	f842 3b04 	str.w	r3, [r2], #4

08000efc <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8000efc:	4b08      	ldr	r3, [pc, #32]	; (8000f20 <LoopForever+0x16>)
	cmp	r2, r3
 8000efe:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8000f00:	d3f9      	bcc.n	8000ef6 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8000f02:	f025 fdc1 	bl	8026a88 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8000f06:	f000 fa29 	bl	800135c <main>

08000f0a <LoopForever>:

LoopForever:
    b LoopForever
 8000f0a:	e7fe      	b.n	8000f0a <LoopForever>
  ldr   sp, =_estack    /* Set stack pointer */
 8000f0c:	20028000 	.word	0x20028000
	ldr	r3, =_sidata
 8000f10:	080377e4 	.word	0x080377e4
	ldr	r0, =_sdata
 8000f14:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8000f18:	20000904 	.word	0x20000904
	ldr	r2, =_sbss
 8000f1c:	20000904 	.word	0x20000904
	ldr	r3, = _ebss
 8000f20:	200120a8 	.word	0x200120a8

08000f24 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8000f24:	e7fe      	b.n	8000f24 <ADC1_IRQHandler>
	...

08000f28 <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 8000f28:	b500      	push	{lr}
 8000f2a:	b087      	sub	sp, #28
  ADC_ChannelConfTypeDef sConfig = {0};
 8000f2c:	2300      	movs	r3, #0
 8000f2e:	9300      	str	r3, [sp, #0]
 8000f30:	9301      	str	r3, [sp, #4]
 8000f32:	9302      	str	r3, [sp, #8]
 8000f34:	9303      	str	r3, [sp, #12]
 8000f36:	9304      	str	r3, [sp, #16]
 8000f38:	9305      	str	r3, [sp, #20]

  /** Common config 
  */
  hadc1.Instance = ADC1;
 8000f3a:	4819      	ldr	r0, [pc, #100]	; (8000fa0 <MX_ADC1_Init+0x78>)
 8000f3c:	4a19      	ldr	r2, [pc, #100]	; (8000fa4 <MX_ADC1_Init+0x7c>)
 8000f3e:	6002      	str	r2, [r0, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8000f40:	6043      	str	r3, [r0, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8000f42:	6083      	str	r3, [r0, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000f44:	60c3      	str	r3, [r0, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000f46:	6103      	str	r3, [r0, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000f48:	2204      	movs	r2, #4
 8000f4a:	6142      	str	r2, [r0, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000f4c:	7603      	strb	r3, [r0, #24]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000f4e:	7643      	strb	r3, [r0, #25]
  hadc1.Init.NbrOfConversion = 1;
 8000f50:	2201      	movs	r2, #1
 8000f52:	61c2      	str	r2, [r0, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000f54:	f880 3020 	strb.w	r3, [r0, #32]
  hadc1.Init.NbrOfDiscConversion = 1;
 8000f58:	6242      	str	r2, [r0, #36]	; 0x24
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000f5a:	6283      	str	r3, [r0, #40]	; 0x28
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000f5c:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8000f5e:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000f62:	6343      	str	r3, [r0, #52]	; 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 8000f64:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000f68:	f006 f830 	bl	8006fcc <HAL_ADC_Init>
 8000f6c:	b990      	cbnz	r0, 8000f94 <MX_ADC1_Init+0x6c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_1;
 8000f6e:	4b0e      	ldr	r3, [pc, #56]	; (8000fa8 <MX_ADC1_Init+0x80>)
 8000f70:	9300      	str	r3, [sp, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000f72:	2306      	movs	r3, #6
 8000f74:	9301      	str	r3, [sp, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 8000f76:	2300      	movs	r3, #0
 8000f78:	9302      	str	r3, [sp, #8]
  sConfig.SingleDiff = ADC_DIFFERENTIAL_ENDED;
 8000f7a:	4a0c      	ldr	r2, [pc, #48]	; (8000fac <MX_ADC1_Init+0x84>)
 8000f7c:	9203      	str	r2, [sp, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000f7e:	2204      	movs	r2, #4
 8000f80:	9204      	str	r2, [sp, #16]
  sConfig.Offset = 0;
 8000f82:	9305      	str	r3, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000f84:	4669      	mov	r1, sp
 8000f86:	4806      	ldr	r0, [pc, #24]	; (8000fa0 <MX_ADC1_Init+0x78>)
 8000f88:	f006 f90e 	bl	80071a8 <HAL_ADC_ConfigChannel>
 8000f8c:	b928      	cbnz	r0, 8000f9a <MX_ADC1_Init+0x72>
  {
    Error_Handler();
  }

}
 8000f8e:	b007      	add	sp, #28
 8000f90:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8000f94:	f000 f950 	bl	8001238 <Error_Handler>
 8000f98:	e7e9      	b.n	8000f6e <MX_ADC1_Init+0x46>
    Error_Handler();
 8000f9a:	f000 f94d 	bl	8001238 <Error_Handler>
}
 8000f9e:	e7f6      	b.n	8000f8e <MX_ADC1_Init+0x66>
 8000fa0:	20000920 	.word	0x20000920
 8000fa4:	50040000 	.word	0x50040000
 8000fa8:	04300002 	.word	0x04300002
 8000fac:	407f0000 	.word	0x407f0000

08000fb0 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8000fb0:	b500      	push	{lr}
 8000fb2:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000fb4:	2300      	movs	r3, #0
 8000fb6:	9301      	str	r3, [sp, #4]
 8000fb8:	9302      	str	r3, [sp, #8]
 8000fba:	9303      	str	r3, [sp, #12]
 8000fbc:	9304      	str	r3, [sp, #16]
 8000fbe:	9305      	str	r3, [sp, #20]
  if(adcHandle->Instance==ADC1)
 8000fc0:	6802      	ldr	r2, [r0, #0]
 8000fc2:	4b0e      	ldr	r3, [pc, #56]	; (8000ffc <HAL_ADC_MspInit+0x4c>)
 8000fc4:	429a      	cmp	r2, r3
 8000fc6:	d002      	beq.n	8000fce <HAL_ADC_MspInit+0x1e>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8000fc8:	b007      	add	sp, #28
 8000fca:	f85d fb04 	ldr.w	pc, [sp], #4
    __HAL_RCC_ADC_CLK_ENABLE();
 8000fce:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 8000fd2:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
 8000fd6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000fd8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8000fdc:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fde:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000fe0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8000fe4:	9300      	str	r3, [sp, #0]
 8000fe6:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = ARD_A4_Pin|ARD_A2_Pin|ARD_A5_Pin|ARD_A3_Pin;
 8000fe8:	230f      	movs	r3, #15
 8000fea:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 8000fec:	230b      	movs	r3, #11
 8000fee:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ff0:	a901      	add	r1, sp, #4
 8000ff2:	4803      	ldr	r0, [pc, #12]	; (8001000 <HAL_ADC_MspInit+0x50>)
 8000ff4:	f006 fbf8 	bl	80077e8 <HAL_GPIO_Init>
}
 8000ff8:	e7e6      	b.n	8000fc8 <HAL_ADC_MspInit+0x18>
 8000ffa:	bf00      	nop
 8000ffc:	50040000 	.word	0x50040000
 8001000:	48000800 	.word	0x48000800

08001004 <MX_GPIO_Init>:
        * Free pins are configured automatically as Analog (this feature is enabled through 
        * the Code Generation settings)
     PA8   ------> RCC_MCO
*/
void MX_GPIO_Init(void)
{
 8001004:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001008:	b08a      	sub	sp, #40	; 0x28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800100a:	2400      	movs	r4, #0
 800100c:	9405      	str	r4, [sp, #20]
 800100e:	9406      	str	r4, [sp, #24]
 8001010:	9407      	str	r4, [sp, #28]
 8001012:	9408      	str	r4, [sp, #32]
 8001014:	9409      	str	r4, [sp, #36]	; 0x24

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001016:	4b43      	ldr	r3, [pc, #268]	; (8001124 <MX_GPIO_Init+0x120>)
 8001018:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800101a:	f042 0201 	orr.w	r2, r2, #1
 800101e:	64da      	str	r2, [r3, #76]	; 0x4c
 8001020:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001022:	f002 0201 	and.w	r2, r2, #1
 8001026:	9200      	str	r2, [sp, #0]
 8001028:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800102a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800102c:	f042 0204 	orr.w	r2, r2, #4
 8001030:	64da      	str	r2, [r3, #76]	; 0x4c
 8001032:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001034:	f002 0204 	and.w	r2, r2, #4
 8001038:	9201      	str	r2, [sp, #4]
 800103a:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800103c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800103e:	f042 0202 	orr.w	r2, r2, #2
 8001042:	64da      	str	r2, [r3, #76]	; 0x4c
 8001044:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001046:	f002 0202 	and.w	r2, r2, #2
 800104a:	9202      	str	r2, [sp, #8]
 800104c:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800104e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001050:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001054:	64da      	str	r2, [r3, #76]	; 0x4c
 8001056:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001058:	f002 0280 	and.w	r2, r2, #128	; 0x80
 800105c:	9203      	str	r2, [sp, #12]
 800105e:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8001060:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001062:	f042 0208 	orr.w	r2, r2, #8
 8001066:	64da      	str	r2, [r3, #76]	; 0x4c
 8001068:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800106a:	f003 0308 	and.w	r3, r3, #8
 800106e:	9304      	str	r3, [sp, #16]
 8001070:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, MDM_PWR_EN_OUT_Pin|MDM_RST_OUT_Pin|LED2_Pin|LED3_Pin 
 8001072:	4d2d      	ldr	r5, [pc, #180]	; (8001128 <MX_GPIO_Init+0x124>)
 8001074:	4622      	mov	r2, r4
 8001076:	f24c 01c4 	movw	r1, #49348	; 0xc0c4
 800107a:	4628      	mov	r0, r5
 800107c:	f006 fd13 	bl	8007aa6 <HAL_GPIO_WritePin>
                          |ST33_VCC_CTRL_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, LED1_Pin|MDM_DTR_OUT_Pin, GPIO_PIN_RESET);
 8001080:	4e2a      	ldr	r6, [pc, #168]	; (800112c <MX_GPIO_Init+0x128>)
 8001082:	4622      	mov	r2, r4
 8001084:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8001088:	4630      	mov	r0, r6
 800108a:	f006 fd0c 	bl	8007aa6 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin 
                           PBPin */
  GPIO_InitStruct.Pin = MDM_PWR_EN_OUT_Pin|MDM_RST_OUT_Pin|LED2_Pin|LED3_Pin 
 800108e:	f24c 03c4 	movw	r3, #49348	; 0xc0c4
 8001092:	9305      	str	r3, [sp, #20]
                          |ST33_VCC_CTRL_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001094:	2701      	movs	r7, #1
 8001096:	9706      	str	r7, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001098:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800109a:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800109c:	a905      	add	r1, sp, #20
 800109e:	4628      	mov	r0, r5
 80010a0:	f006 fba2 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PH3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 80010a4:	2308      	movs	r3, #8
 80010a6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80010a8:	f04f 0803 	mov.w	r8, #3
 80010ac:	f8cd 8018 	str.w	r8, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010b0:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80010b2:	a905      	add	r1, sp, #20
 80010b4:	481e      	ldr	r0, [pc, #120]	; (8001130 <MX_GPIO_Init+0x12c>)
 80010b6:	f006 fb97 	bl	80077e8 <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct); */

  /*Configure GPIO pin : PC7 */
  GPIO_InitStruct.Pin = GPIO_PIN_7;
 80010ba:	2380      	movs	r3, #128	; 0x80
 80010bc:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80010be:	f8cd 8018 	str.w	r8, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010c2:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80010c4:	a905      	add	r1, sp, #20
 80010c6:	4630      	mov	r0, r6
 80010c8:	f006 fb8e 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = ARD_D7_Pin;
 80010cc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80010d0:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80010d2:	2302      	movs	r3, #2
 80010d4:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010d6:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80010d8:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 80010da:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(ARD_D7_GPIO_Port, &GPIO_InitStruct);
 80010dc:	a905      	add	r1, sp, #20
 80010de:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80010e2:	f006 fb81 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PCPin PCPin */
  GPIO_InitStruct.Pin = LED1_Pin|MDM_DTR_OUT_Pin;
 80010e6:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80010ea:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80010ec:	9706      	str	r7, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80010ee:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80010f0:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80010f2:	a905      	add	r1, sp, #20
 80010f4:	4630      	mov	r0, r6
 80010f6:	f006 fb77 	bl	80077e8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = MDM_RING_Pin;
 80010fa:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80010fe:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8001100:	4b0c      	ldr	r3, [pc, #48]	; (8001134 <MX_GPIO_Init+0x130>)
 8001102:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001104:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(MDM_RING_GPIO_Port, &GPIO_InitStruct);
 8001106:	a905      	add	r1, sp, #20
 8001108:	4628      	mov	r0, r5
 800110a:	f006 fb6d 	bl	80077e8 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0);
 800110e:	4622      	mov	r2, r4
 8001110:	2105      	movs	r1, #5
 8001112:	2028      	movs	r0, #40	; 0x28
 8001114:	f006 fac4 	bl	80076a0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8001118:	2028      	movs	r0, #40	; 0x28
 800111a:	f006 faf9 	bl	8007710 <HAL_NVIC_EnableIRQ>

}
 800111e:	b00a      	add	sp, #40	; 0x28
 8001120:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001124:	40021000 	.word	0x40021000
 8001128:	48000400 	.word	0x48000400
 800112c:	48000800 	.word	0x48000800
 8001130:	48001c00 	.word	0x48001c00
 8001134:	10110000 	.word	0x10110000

08001138 <MX_I2C1_Init>:

I2C_HandleTypeDef hi2c1;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 8001138:	b508      	push	{r3, lr}

  hi2c1.Instance = I2C1;
 800113a:	4812      	ldr	r0, [pc, #72]	; (8001184 <MX_I2C1_Init+0x4c>)
 800113c:	4b12      	ldr	r3, [pc, #72]	; (8001188 <MX_I2C1_Init+0x50>)
 800113e:	6003      	str	r3, [r0, #0]
  hi2c1.Init.Timing = 0x10909CEC;
 8001140:	4b12      	ldr	r3, [pc, #72]	; (800118c <MX_I2C1_Init+0x54>)
 8001142:	6043      	str	r3, [r0, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8001144:	2300      	movs	r3, #0
 8001146:	6083      	str	r3, [r0, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8001148:	2201      	movs	r2, #1
 800114a:	60c2      	str	r2, [r0, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 800114c:	6103      	str	r3, [r0, #16]
  hi2c1.Init.OwnAddress2 = 0;
 800114e:	6143      	str	r3, [r0, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8001150:	6183      	str	r3, [r0, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8001152:	61c3      	str	r3, [r0, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8001154:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8001156:	f006 fe27 	bl	8007da8 <HAL_I2C_Init>
 800115a:	b950      	cbnz	r0, 8001172 <MX_I2C1_Init+0x3a>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 800115c:	2100      	movs	r1, #0
 800115e:	4809      	ldr	r0, [pc, #36]	; (8001184 <MX_I2C1_Init+0x4c>)
 8001160:	f007 f846 	bl	80081f0 <HAL_I2CEx_ConfigAnalogFilter>
 8001164:	b940      	cbnz	r0, 8001178 <MX_I2C1_Init+0x40>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8001166:	2100      	movs	r1, #0
 8001168:	4806      	ldr	r0, [pc, #24]	; (8001184 <MX_I2C1_Init+0x4c>)
 800116a:	f007 f86f 	bl	800824c <HAL_I2CEx_ConfigDigitalFilter>
 800116e:	b930      	cbnz	r0, 800117e <MX_I2C1_Init+0x46>
  {
    Error_Handler();
  }

}
 8001170:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001172:	f000 f861 	bl	8001238 <Error_Handler>
 8001176:	e7f1      	b.n	800115c <MX_I2C1_Init+0x24>
    Error_Handler();
 8001178:	f000 f85e 	bl	8001238 <Error_Handler>
 800117c:	e7f3      	b.n	8001166 <MX_I2C1_Init+0x2e>
    Error_Handler();
 800117e:	f000 f85b 	bl	8001238 <Error_Handler>
}
 8001182:	e7f5      	b.n	8001170 <MX_I2C1_Init+0x38>
 8001184:	20000988 	.word	0x20000988
 8001188:	40005400 	.word	0x40005400
 800118c:	10909cec 	.word	0x10909cec

08001190 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8001190:	b500      	push	{lr}
 8001192:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001194:	2300      	movs	r3, #0
 8001196:	9301      	str	r3, [sp, #4]
 8001198:	9302      	str	r3, [sp, #8]
 800119a:	9303      	str	r3, [sp, #12]
 800119c:	9304      	str	r3, [sp, #16]
 800119e:	9305      	str	r3, [sp, #20]
  if(i2cHandle->Instance==I2C1)
 80011a0:	6802      	ldr	r2, [r0, #0]
 80011a2:	4b10      	ldr	r3, [pc, #64]	; (80011e4 <HAL_I2C_MspInit+0x54>)
 80011a4:	429a      	cmp	r2, r3
 80011a6:	d002      	beq.n	80011ae <HAL_I2C_MspInit+0x1e>
    __HAL_RCC_I2C1_CLK_ENABLE();
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }
}
 80011a8:	b007      	add	sp, #28
 80011aa:	f85d fb04 	ldr.w	pc, [sp], #4
    GPIO_InitStruct.Pin = ARD_D15_Pin|ARD_D14_Pin;
 80011ae:	f44f 7340 	mov.w	r3, #768	; 0x300
 80011b2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80011b4:	2312      	movs	r3, #18
 80011b6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80011b8:	2301      	movs	r3, #1
 80011ba:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80011bc:	2303      	movs	r3, #3
 80011be:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80011c0:	2304      	movs	r3, #4
 80011c2:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80011c4:	eb0d 0103 	add.w	r1, sp, r3
 80011c8:	4807      	ldr	r0, [pc, #28]	; (80011e8 <HAL_I2C_MspInit+0x58>)
 80011ca:	f006 fb0d 	bl	80077e8 <HAL_GPIO_Init>
    __HAL_RCC_I2C1_CLK_ENABLE();
 80011ce:	4b07      	ldr	r3, [pc, #28]	; (80011ec <HAL_I2C_MspInit+0x5c>)
 80011d0:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80011d2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80011d6:	659a      	str	r2, [r3, #88]	; 0x58
 80011d8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80011da:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80011de:	9300      	str	r3, [sp, #0]
 80011e0:	9b00      	ldr	r3, [sp, #0]
}
 80011e2:	e7e1      	b.n	80011a8 <HAL_I2C_MspInit+0x18>
 80011e4:	40005400 	.word	0x40005400
 80011e8:	48000400 	.word	0x48000400
 80011ec:	40021000 	.word	0x40021000

080011f0 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{
 80011f0:	b508      	push	{r3, lr}

  if(i2cHandle->Instance==I2C1)
 80011f2:	6802      	ldr	r2, [r0, #0]
 80011f4:	4b07      	ldr	r3, [pc, #28]	; (8001214 <HAL_I2C_MspDeInit+0x24>)
 80011f6:	429a      	cmp	r2, r3
 80011f8:	d000      	beq.n	80011fc <HAL_I2C_MspDeInit+0xc>

  /* USER CODE BEGIN I2C1_MspDeInit 1 */

  /* USER CODE END I2C1_MspDeInit 1 */
  }
} 
 80011fa:	bd08      	pop	{r3, pc}
    __HAL_RCC_I2C1_CLK_DISABLE();
 80011fc:	4a06      	ldr	r2, [pc, #24]	; (8001218 <HAL_I2C_MspDeInit+0x28>)
 80011fe:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001200:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001204:	6593      	str	r3, [r2, #88]	; 0x58
    HAL_GPIO_DeInit(GPIOB, ARD_D15_Pin|ARD_D14_Pin);
 8001206:	f44f 7140 	mov.w	r1, #768	; 0x300
 800120a:	4804      	ldr	r0, [pc, #16]	; (800121c <HAL_I2C_MspDeInit+0x2c>)
 800120c:	f006 fbbe 	bl	800798c <HAL_GPIO_DeInit>
} 
 8001210:	e7f3      	b.n	80011fa <HAL_I2C_MspDeInit+0xa>
 8001212:	bf00      	nop
 8001214:	40005400 	.word	0x40005400
 8001218:	40021000 	.word	0x40021000
 800121c:	48000400 	.word	0x48000400

08001220 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8001220:	b508      	push	{r3, lr}
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 8001222:	6802      	ldr	r2, [r0, #0]
 8001224:	4b03      	ldr	r3, [pc, #12]	; (8001234 <HAL_TIM_PeriodElapsedCallback+0x14>)
 8001226:	429a      	cmp	r2, r3
 8001228:	d000      	beq.n	800122c <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 800122a:	bd08      	pop	{r3, pc}
    HAL_IncTick();
 800122c:	f005 fea8 	bl	8006f80 <HAL_IncTick>
}
 8001230:	e7fb      	b.n	800122a <HAL_TIM_PeriodElapsedCallback+0xa>
 8001232:	bf00      	nop
 8001234:	40012c00 	.word	0x40012c00

08001238 <Error_Handler>:
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  while(1)
 8001238:	e7fe      	b.n	8001238 <Error_Handler>
	...

0800123c <SystemClock_Config>:
{
 800123c:	b510      	push	{r4, lr}
 800123e:	b0b0      	sub	sp, #192	; 0xc0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8001240:	2244      	movs	r2, #68	; 0x44
 8001242:	2100      	movs	r1, #0
 8001244:	a81f      	add	r0, sp, #124	; 0x7c
 8001246:	f025 fb72 	bl	802692e <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800124a:	2400      	movs	r4, #0
 800124c:	941a      	str	r4, [sp, #104]	; 0x68
 800124e:	941b      	str	r4, [sp, #108]	; 0x6c
 8001250:	941c      	str	r4, [sp, #112]	; 0x70
 8001252:	941d      	str	r4, [sp, #116]	; 0x74
 8001254:	941e      	str	r4, [sp, #120]	; 0x78
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8001256:	2268      	movs	r2, #104	; 0x68
 8001258:	4621      	mov	r1, r4
 800125a:	4668      	mov	r0, sp
 800125c:	f025 fb67 	bl	802692e <memset>
  HAL_PWR_EnableBkUpAccess();
 8001260:	f007 f8ca 	bl	80083f8 <HAL_PWR_EnableBkUpAccess>
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8001264:	4a3a      	ldr	r2, [pc, #232]	; (8001350 <SystemClock_Config+0x114>)
 8001266:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800126a:	f023 0318 	bic.w	r3, r3, #24
 800126e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
 8001272:	2314      	movs	r3, #20
 8001274:	931f      	str	r3, [sp, #124]	; 0x7c
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8001276:	2301      	movs	r3, #1
 8001278:	9321      	str	r3, [sp, #132]	; 0x84
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 800127a:	9325      	str	r3, [sp, #148]	; 0x94
  RCC_OscInitStruct.MSICalibrationValue = 0;
 800127c:	9426      	str	r4, [sp, #152]	; 0x98
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 800127e:	2260      	movs	r2, #96	; 0x60
 8001280:	9227      	str	r2, [sp, #156]	; 0x9c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8001282:	2202      	movs	r2, #2
 8001284:	9229      	str	r2, [sp, #164]	; 0xa4
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8001286:	932a      	str	r3, [sp, #168]	; 0xa8
  RCC_OscInitStruct.PLL.PLLM = 1;
 8001288:	932b      	str	r3, [sp, #172]	; 0xac
  RCC_OscInitStruct.PLL.PLLN = 40;
 800128a:	2328      	movs	r3, #40	; 0x28
 800128c:	932c      	str	r3, [sp, #176]	; 0xb0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 800128e:	2307      	movs	r3, #7
 8001290:	932d      	str	r3, [sp, #180]	; 0xb4
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8001292:	922e      	str	r2, [sp, #184]	; 0xb8
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8001294:	922f      	str	r2, [sp, #188]	; 0xbc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8001296:	a81f      	add	r0, sp, #124	; 0x7c
 8001298:	f007 fa52 	bl	8008740 <HAL_RCC_OscConfig>
 800129c:	2800      	cmp	r0, #0
 800129e:	d14f      	bne.n	8001340 <SystemClock_Config+0x104>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80012a0:	230f      	movs	r3, #15
 80012a2:	931a      	str	r3, [sp, #104]	; 0x68
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80012a4:	2303      	movs	r3, #3
 80012a6:	931b      	str	r3, [sp, #108]	; 0x6c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80012a8:	2300      	movs	r3, #0
 80012aa:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 80012ac:	931d      	str	r3, [sp, #116]	; 0x74
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 80012ae:	931e      	str	r3, [sp, #120]	; 0x78
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 80012b0:	2104      	movs	r1, #4
 80012b2:	a81a      	add	r0, sp, #104	; 0x68
 80012b4:	f007 fd84 	bl	8008dc0 <HAL_RCC_ClockConfig>
 80012b8:	2800      	cmp	r0, #0
 80012ba:	d143      	bne.n	8001344 <SystemClock_Config+0x108>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART1
 80012bc:	4b25      	ldr	r3, [pc, #148]	; (8001354 <SystemClock_Config+0x118>)
 80012be:	9300      	str	r3, [sp, #0]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 80012c0:	2300      	movs	r3, #0
 80012c2:	9308      	str	r3, [sp, #32]
  PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 80012c4:	9309      	str	r3, [sp, #36]	; 0x24
  PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
 80012c6:	930a      	str	r3, [sp, #40]	; 0x28
  PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 80012c8:	930d      	str	r3, [sp, #52]	; 0x34
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 80012ca:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80012ce:	9317      	str	r3, [sp, #92]	; 0x5c
  PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 80012d0:	f44f 7380 	mov.w	r3, #256	; 0x100
 80012d4:	9319      	str	r3, [sp, #100]	; 0x64
  PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
 80012d6:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80012da:	9314      	str	r3, [sp, #80]	; 0x50
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
 80012dc:	9316      	str	r3, [sp, #88]	; 0x58
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
 80012de:	2301      	movs	r3, #1
 80012e0:	9301      	str	r3, [sp, #4]
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
 80012e2:	9302      	str	r3, [sp, #8]
  PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
 80012e4:	2318      	movs	r3, #24
 80012e6:	9303      	str	r3, [sp, #12]
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 80012e8:	2307      	movs	r3, #7
 80012ea:	9304      	str	r3, [sp, #16]
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 80012ec:	2302      	movs	r3, #2
 80012ee:	9305      	str	r3, [sp, #20]
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 80012f0:	9306      	str	r3, [sp, #24]
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
 80012f2:	f04f 7388 	mov.w	r3, #17825792	; 0x1100000
 80012f6:	9307      	str	r3, [sp, #28]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80012f8:	4668      	mov	r0, sp
 80012fa:	f007 ff0d 	bl	8009118 <HAL_RCCEx_PeriphCLKConfig>
 80012fe:	bb18      	cbnz	r0, 8001348 <SystemClock_Config+0x10c>
  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_SYSCLK, RCC_MCODIV_1);
 8001300:	2200      	movs	r2, #0
 8001302:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
 8001306:	4610      	mov	r0, r2
 8001308:	f007 f99a 	bl	8008640 <HAL_RCC_MCOConfig>
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 800130c:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001310:	f007 f882 	bl	8008418 <HAL_PWREx_ControlVoltageScaling>
 8001314:	b9d0      	cbnz	r0, 800134c <SystemClock_Config+0x110>
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 8001316:	f007 fe01 	bl	8008f1c <HAL_RCC_GetHCLKFreq>
 800131a:	4b0f      	ldr	r3, [pc, #60]	; (8001358 <SystemClock_Config+0x11c>)
 800131c:	fba3 3000 	umull	r3, r0, r3, r0
 8001320:	0980      	lsrs	r0, r0, #6
 8001322:	f006 fa15 	bl	8007750 <HAL_SYSTICK_Config>
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 8001326:	2004      	movs	r0, #4
 8001328:	f006 fa26 	bl	8007778 <HAL_SYSTICK_CLKSourceConfig>
  HAL_RCCEx_EnableMSIPLLMode();
 800132c:	f008 f8c0 	bl	80094b0 <HAL_RCCEx_EnableMSIPLLMode>
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8001330:	2200      	movs	r2, #0
 8001332:	210f      	movs	r1, #15
 8001334:	f04f 30ff 	mov.w	r0, #4294967295
 8001338:	f006 f9b2 	bl	80076a0 <HAL_NVIC_SetPriority>
}
 800133c:	b030      	add	sp, #192	; 0xc0
 800133e:	bd10      	pop	{r4, pc}
    Error_Handler();
 8001340:	f7ff ff7a 	bl	8001238 <Error_Handler>
    Error_Handler();
 8001344:	f7ff ff78 	bl	8001238 <Error_Handler>
    Error_Handler();
 8001348:	f7ff ff76 	bl	8001238 <Error_Handler>
    Error_Handler();
 800134c:	f7ff ff74 	bl	8001238 <Error_Handler>
 8001350:	40021000 	.word	0x40021000
 8001354:	00066047 	.word	0x00066047
 8001358:	10624dd3 	.word	0x10624dd3

0800135c <main>:
{
 800135c:	b508      	push	{r3, lr}
HAL_Init();
 800135e:	f005 fdff 	bl	8006f60 <HAL_Init>
  SystemClock_Config();
 8001362:	f7ff ff6b 	bl	800123c <SystemClock_Config>
  MX_GPIO_Init();
 8001366:	f7ff fe4d 	bl	8001004 <MX_GPIO_Init>
  MX_ADC1_Init();
 800136a:	f7ff fddd 	bl	8000f28 <MX_ADC1_Init>
  MX_I2C1_Init();
 800136e:	f7ff fee3 	bl	8001138 <MX_I2C1_Init>
  MX_QUADSPI_Init();
 8001372:	f000 f819 	bl	80013a8 <MX_QUADSPI_Init>
  MX_RTC_Init();
 8001376:	f000 f893 	bl	80014a0 <MX_RTC_Init>
  MX_SPI1_Init();
 800137a:	f000 f8bd 	bl	80014f8 <MX_SPI1_Init>
  MX_SPI3_Init();
 800137e:	f000 f8e1 	bl	8001544 <MX_SPI3_Init>
  MX_TIM2_Init();
 8001382:	f000 fad9 	bl	8001938 <MX_TIM2_Init>
  MX_TIM3_Init();
 8001386:	f000 fb15 	bl	80019b4 <MX_TIM3_Init>
  MX_USART1_UART_Init();
 800138a:	f000 fb53 	bl	8001a34 <MX_USART1_UART_Init>
  MX_USART2_UART_Init();
 800138e:	f000 fb6d 	bl	8001a6c <MX_USART2_UART_Init>
  MX_USB_PCD_Init();
 8001392:	f000 fc73 	bl	8001c7c <MX_USB_PCD_Init>
  MX_RNG_Init();
 8001396:	f000 f85b 	bl	8001450 <MX_RNG_Init>
  MX_I2C1_Init();
 800139a:	f7ff fecd 	bl	8001138 <MX_I2C1_Init>
  MX_FREERTOS_Init(); 
 800139e:	f022 fec3 	bl	8024128 <MX_FREERTOS_Init>
  osKernelStart();
 80013a2:	f022 feed 	bl	8024180 <osKernelStart>
  while (1)
 80013a6:	e7fe      	b.n	80013a6 <main+0x4a>

080013a8 <MX_QUADSPI_Init>:

QSPI_HandleTypeDef hqspi;

/* QUADSPI init function */
void MX_QUADSPI_Init(void)
{
 80013a8:	b508      	push	{r3, lr}

  hqspi.Instance = QUADSPI;
 80013aa:	480a      	ldr	r0, [pc, #40]	; (80013d4 <MX_QUADSPI_Init+0x2c>)
 80013ac:	4b0a      	ldr	r3, [pc, #40]	; (80013d8 <MX_QUADSPI_Init+0x30>)
 80013ae:	6003      	str	r3, [r0, #0]
  hqspi.Init.ClockPrescaler = 255;
 80013b0:	23ff      	movs	r3, #255	; 0xff
 80013b2:	6043      	str	r3, [r0, #4]
  hqspi.Init.FifoThreshold = 1;
 80013b4:	2201      	movs	r2, #1
 80013b6:	6082      	str	r2, [r0, #8]
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
 80013b8:	2300      	movs	r3, #0
 80013ba:	60c3      	str	r3, [r0, #12]
  hqspi.Init.FlashSize = 1;
 80013bc:	6102      	str	r2, [r0, #16]
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
 80013be:	6143      	str	r3, [r0, #20]
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
 80013c0:	6183      	str	r3, [r0, #24]
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
 80013c2:	61c3      	str	r3, [r0, #28]
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
 80013c4:	6203      	str	r3, [r0, #32]
  if (HAL_QSPI_Init(&hqspi) != HAL_OK)
 80013c6:	f007 f89b 	bl	8008500 <HAL_QSPI_Init>
 80013ca:	b900      	cbnz	r0, 80013ce <MX_QUADSPI_Init+0x26>
  {
    Error_Handler();
  }

}
 80013cc:	bd08      	pop	{r3, pc}
    Error_Handler();
 80013ce:	f7ff ff33 	bl	8001238 <Error_Handler>
}
 80013d2:	e7fb      	b.n	80013cc <MX_QUADSPI_Init+0x24>
 80013d4:	200009d4 	.word	0x200009d4
 80013d8:	a0001000 	.word	0xa0001000

080013dc <HAL_QSPI_MspInit>:

void HAL_QSPI_MspInit(QSPI_HandleTypeDef* qspiHandle)
{
 80013dc:	b570      	push	{r4, r5, r6, lr}
 80013de:	b086      	sub	sp, #24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80013e0:	2300      	movs	r3, #0
 80013e2:	9301      	str	r3, [sp, #4]
 80013e4:	9302      	str	r3, [sp, #8]
 80013e6:	9303      	str	r3, [sp, #12]
 80013e8:	9304      	str	r3, [sp, #16]
 80013ea:	9305      	str	r3, [sp, #20]
  if(qspiHandle->Instance==QUADSPI)
 80013ec:	6802      	ldr	r2, [r0, #0]
 80013ee:	4b16      	ldr	r3, [pc, #88]	; (8001448 <HAL_QSPI_MspInit+0x6c>)
 80013f0:	429a      	cmp	r2, r3
 80013f2:	d001      	beq.n	80013f8 <HAL_QSPI_MspInit+0x1c>

  /* USER CODE BEGIN QUADSPI_MspInit 1 */

  /* USER CODE END QUADSPI_MspInit 1 */
  }
}
 80013f4:	b006      	add	sp, #24
 80013f6:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_QSPI_CLK_ENABLE();
 80013f8:	f103 4320 	add.w	r3, r3, #2684354560	; 0xa0000000
 80013fc:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 8001400:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001402:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001406:	651a      	str	r2, [r3, #80]	; 0x50
 8001408:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800140a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800140e:	9300      	str	r3, [sp, #0]
 8001410:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6;
 8001412:	23c0      	movs	r3, #192	; 0xc0
 8001414:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001416:	2602      	movs	r6, #2
 8001418:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800141a:	2503      	movs	r5, #3
 800141c:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800141e:	240a      	movs	r4, #10
 8001420:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001422:	a901      	add	r1, sp, #4
 8001424:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001428:	f006 f9de 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_11|GPIO_PIN_10|GPIO_PIN_0;
 800142c:	f640 4303 	movw	r3, #3075	; 0xc03
 8001430:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001432:	9602      	str	r6, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001434:	2300      	movs	r3, #0
 8001436:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001438:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800143a:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800143c:	a901      	add	r1, sp, #4
 800143e:	4803      	ldr	r0, [pc, #12]	; (800144c <HAL_QSPI_MspInit+0x70>)
 8001440:	f006 f9d2 	bl	80077e8 <HAL_GPIO_Init>
}
 8001444:	e7d6      	b.n	80013f4 <HAL_QSPI_MspInit+0x18>
 8001446:	bf00      	nop
 8001448:	a0001000 	.word	0xa0001000
 800144c:	48000400 	.word	0x48000400

08001450 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
 8001450:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
 8001452:	4805      	ldr	r0, [pc, #20]	; (8001468 <MX_RNG_Init+0x18>)
 8001454:	4b05      	ldr	r3, [pc, #20]	; (800146c <MX_RNG_Init+0x1c>)
 8001456:	6003      	str	r3, [r0, #0]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 8001458:	f008 f832 	bl	80094c0 <HAL_RNG_Init>
 800145c:	b900      	cbnz	r0, 8001460 <MX_RNG_Init+0x10>
  {
    Error_Handler();
  }

}
 800145e:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001460:	f7ff feea 	bl	8001238 <Error_Handler>
}
 8001464:	e7fb      	b.n	800145e <MX_RNG_Init+0xe>
 8001466:	bf00      	nop
 8001468:	20000a20 	.word	0x20000a20
 800146c:	50060800 	.word	0x50060800

08001470 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
 8001470:	6802      	ldr	r2, [r0, #0]
 8001472:	4b0a      	ldr	r3, [pc, #40]	; (800149c <HAL_RNG_MspInit+0x2c>)
 8001474:	429a      	cmp	r2, r3
 8001476:	d000      	beq.n	800147a <HAL_RNG_MspInit+0xa>
 8001478:	4770      	bx	lr
{
 800147a:	b082      	sub	sp, #8
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 800147c:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 8001480:	f5a3 337e 	sub.w	r3, r3, #260096	; 0x3f800
 8001484:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001486:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800148a:	64da      	str	r2, [r3, #76]	; 0x4c
 800148c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800148e:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001492:	9301      	str	r3, [sp, #4]
 8001494:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
 8001496:	b002      	add	sp, #8
 8001498:	4770      	bx	lr
 800149a:	bf00      	nop
 800149c:	50060800 	.word	0x50060800

080014a0 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 80014a0:	b508      	push	{r3, lr}

  /** Initialize RTC Only 
  */
  hrtc.Instance = RTC;
 80014a2:	480a      	ldr	r0, [pc, #40]	; (80014cc <MX_RTC_Init+0x2c>)
 80014a4:	4b0a      	ldr	r3, [pc, #40]	; (80014d0 <MX_RTC_Init+0x30>)
 80014a6:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80014a8:	2300      	movs	r3, #0
 80014aa:	6043      	str	r3, [r0, #4]
  hrtc.Init.AsynchPrediv = 127;
 80014ac:	227f      	movs	r2, #127	; 0x7f
 80014ae:	6082      	str	r2, [r0, #8]
  hrtc.Init.SynchPrediv = 255;
 80014b0:	22ff      	movs	r2, #255	; 0xff
 80014b2:	60c2      	str	r2, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80014b4:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 80014b6:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 80014b8:	6183      	str	r3, [r0, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80014ba:	61c3      	str	r3, [r0, #28]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 80014bc:	f008 f8c6 	bl	800964c <HAL_RTC_Init>
 80014c0:	b900      	cbnz	r0, 80014c4 <MX_RTC_Init+0x24>
  {
    Error_Handler();
  }

}
 80014c2:	bd08      	pop	{r3, pc}
    Error_Handler();
 80014c4:	f7ff feb8 	bl	8001238 <Error_Handler>
}
 80014c8:	e7fb      	b.n	80014c2 <MX_RTC_Init+0x22>
 80014ca:	bf00      	nop
 80014cc:	20000a30 	.word	0x20000a30
 80014d0:	40002800 	.word	0x40002800

080014d4 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{

  if(rtcHandle->Instance==RTC)
 80014d4:	6802      	ldr	r2, [r0, #0]
 80014d6:	4b06      	ldr	r3, [pc, #24]	; (80014f0 <HAL_RTC_MspInit+0x1c>)
 80014d8:	429a      	cmp	r2, r3
 80014da:	d000      	beq.n	80014de <HAL_RTC_MspInit+0xa>
    __HAL_RCC_RTC_ENABLE();
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 80014dc:	4770      	bx	lr
    __HAL_RCC_RTC_ENABLE();
 80014de:	4a05      	ldr	r2, [pc, #20]	; (80014f4 <HAL_RTC_MspInit+0x20>)
 80014e0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80014e4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80014e8:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
}
 80014ec:	e7f6      	b.n	80014dc <HAL_RTC_MspInit+0x8>
 80014ee:	bf00      	nop
 80014f0:	40002800 	.word	0x40002800
 80014f4:	40021000 	.word	0x40021000

080014f8 <MX_SPI1_Init>:
SPI_HandleTypeDef hspi1;
SPI_HandleTypeDef hspi3;

/* SPI1 init function */
void MX_SPI1_Init(void)
{
 80014f8:	b508      	push	{r3, lr}

  hspi1.Instance = SPI1;
 80014fa:	4810      	ldr	r0, [pc, #64]	; (800153c <MX_SPI1_Init+0x44>)
 80014fc:	4b10      	ldr	r3, [pc, #64]	; (8001540 <MX_SPI1_Init+0x48>)
 80014fe:	6003      	str	r3, [r0, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8001500:	f44f 7382 	mov.w	r3, #260	; 0x104
 8001504:	6043      	str	r3, [r0, #4]
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8001506:	2300      	movs	r3, #0
 8001508:	6083      	str	r3, [r0, #8]
  hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
 800150a:	f44f 7240 	mov.w	r2, #768	; 0x300
 800150e:	60c2      	str	r2, [r0, #12]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8001510:	6103      	str	r3, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8001512:	6143      	str	r3, [r0, #20]
  hspi1.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8001514:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001518:	6182      	str	r2, [r0, #24]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 800151a:	61c3      	str	r3, [r0, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800151c:	6203      	str	r3, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 800151e:	6243      	str	r3, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8001520:	6283      	str	r3, [r0, #40]	; 0x28
  hspi1.Init.CRCPolynomial = 7;
 8001522:	2207      	movs	r2, #7
 8001524:	62c2      	str	r2, [r0, #44]	; 0x2c
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8001526:	6303      	str	r3, [r0, #48]	; 0x30
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8001528:	2308      	movs	r3, #8
 800152a:	6343      	str	r3, [r0, #52]	; 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 800152c:	f008 f8db 	bl	80096e6 <HAL_SPI_Init>
 8001530:	b900      	cbnz	r0, 8001534 <MX_SPI1_Init+0x3c>
  {
    Error_Handler();
  }

}
 8001532:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001534:	f7ff fe80 	bl	8001238 <Error_Handler>
}
 8001538:	e7fb      	b.n	8001532 <MX_SPI1_Init+0x3a>
 800153a:	bf00      	nop
 800153c:	20000a54 	.word	0x20000a54
 8001540:	40013000 	.word	0x40013000

08001544 <MX_SPI3_Init>:
/* SPI3 init function */
void MX_SPI3_Init(void)
{
 8001544:	b508      	push	{r3, lr}

  hspi3.Instance = SPI3;
 8001546:	4810      	ldr	r0, [pc, #64]	; (8001588 <MX_SPI3_Init+0x44>)
 8001548:	4b10      	ldr	r3, [pc, #64]	; (800158c <MX_SPI3_Init+0x48>)
 800154a:	6003      	str	r3, [r0, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 800154c:	f44f 7382 	mov.w	r3, #260	; 0x104
 8001550:	6043      	str	r3, [r0, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 8001552:	2300      	movs	r3, #0
 8001554:	6083      	str	r3, [r0, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_4BIT;
 8001556:	f44f 7240 	mov.w	r2, #768	; 0x300
 800155a:	60c2      	str	r2, [r0, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 800155c:	6103      	str	r3, [r0, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 800155e:	6143      	str	r3, [r0, #20]
  hspi3.Init.NSS = SPI_NSS_HARD_OUTPUT;
 8001560:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8001564:	6182      	str	r2, [r0, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8001566:	61c3      	str	r3, [r0, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8001568:	6203      	str	r3, [r0, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 800156a:	6243      	str	r3, [r0, #36]	; 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800156c:	6283      	str	r3, [r0, #40]	; 0x28
  hspi3.Init.CRCPolynomial = 7;
 800156e:	2207      	movs	r2, #7
 8001570:	62c2      	str	r2, [r0, #44]	; 0x2c
  hspi3.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8001572:	6303      	str	r3, [r0, #48]	; 0x30
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8001574:	2308      	movs	r3, #8
 8001576:	6343      	str	r3, [r0, #52]	; 0x34
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 8001578:	f008 f8b5 	bl	80096e6 <HAL_SPI_Init>
 800157c:	b900      	cbnz	r0, 8001580 <MX_SPI3_Init+0x3c>
  {
    Error_Handler();
  }

}
 800157e:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001580:	f7ff fe5a 	bl	8001238 <Error_Handler>
}
 8001584:	e7fb      	b.n	800157e <MX_SPI3_Init+0x3a>
 8001586:	bf00      	nop
 8001588:	20000ab8 	.word	0x20000ab8
 800158c:	40003c00 	.word	0x40003c00

08001590 <HAL_SPI_MspInit>:

void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
 8001590:	b570      	push	{r4, r5, r6, lr}
 8001592:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001594:	2300      	movs	r3, #0
 8001596:	9303      	str	r3, [sp, #12]
 8001598:	9304      	str	r3, [sp, #16]
 800159a:	9305      	str	r3, [sp, #20]
 800159c:	9306      	str	r3, [sp, #24]
 800159e:	9307      	str	r3, [sp, #28]
  if(spiHandle->Instance==SPI1)
 80015a0:	6803      	ldr	r3, [r0, #0]
 80015a2:	4a28      	ldr	r2, [pc, #160]	; (8001644 <HAL_SPI_MspInit+0xb4>)
 80015a4:	4293      	cmp	r3, r2
 80015a6:	d004      	beq.n	80015b2 <HAL_SPI_MspInit+0x22>

  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }
  else if(spiHandle->Instance==SPI3)
 80015a8:	4a27      	ldr	r2, [pc, #156]	; (8001648 <HAL_SPI_MspInit+0xb8>)
 80015aa:	4293      	cmp	r3, r2
 80015ac:	d025      	beq.n	80015fa <HAL_SPI_MspInit+0x6a>

  /* USER CODE BEGIN SPI3_MspInit 1 */

  /* USER CODE END SPI3_MspInit 1 */
  }
}
 80015ae:	b008      	add	sp, #32
 80015b0:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_SPI1_CLK_ENABLE();
 80015b2:	4b26      	ldr	r3, [pc, #152]	; (800164c <HAL_SPI_MspInit+0xbc>)
 80015b4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80015b6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80015ba:	661a      	str	r2, [r3, #96]	; 0x60
 80015bc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80015be:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80015c2:	9301      	str	r3, [sp, #4]
 80015c4:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = ARD_D10_Pin|ARD_D13_Pin;
 80015c6:	f248 0320 	movw	r3, #32800	; 0x8020
 80015ca:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015cc:	2602      	movs	r6, #2
 80015ce:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80015d0:	2503      	movs	r5, #3
 80015d2:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80015d4:	2405      	movs	r4, #5
 80015d6:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80015d8:	a903      	add	r1, sp, #12
 80015da:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80015de:	f006 f903 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = ARD_D12_Pin|ARD_D11_Pin;
 80015e2:	2330      	movs	r3, #48	; 0x30
 80015e4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80015e6:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80015e8:	2300      	movs	r3, #0
 80015ea:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80015ec:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80015ee:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80015f0:	a903      	add	r1, sp, #12
 80015f2:	4817      	ldr	r0, [pc, #92]	; (8001650 <HAL_SPI_MspInit+0xc0>)
 80015f4:	f006 f8f8 	bl	80077e8 <HAL_GPIO_Init>
 80015f8:	e7d9      	b.n	80015ae <HAL_SPI_MspInit+0x1e>
    __HAL_RCC_SPI3_CLK_ENABLE();
 80015fa:	4b14      	ldr	r3, [pc, #80]	; (800164c <HAL_SPI_MspInit+0xbc>)
 80015fc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80015fe:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001602:	659a      	str	r2, [r3, #88]	; 0x58
 8001604:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001606:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 800160a:	9302      	str	r3, [sp, #8]
 800160c:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = ST33_MOSI_Pin|ST33_MISO_Pin|ST33_SCK_Pin;
 800160e:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8001612:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001614:	2602      	movs	r6, #2
 8001616:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001618:	2503      	movs	r5, #3
 800161a:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 800161c:	2406      	movs	r4, #6
 800161e:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001620:	a903      	add	r1, sp, #12
 8001622:	480c      	ldr	r0, [pc, #48]	; (8001654 <HAL_SPI_MspInit+0xc4>)
 8001624:	f006 f8e0 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = ST33_CS_Pin;
 8001628:	2310      	movs	r3, #16
 800162a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800162c:	9604      	str	r6, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800162e:	2300      	movs	r3, #0
 8001630:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001632:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8001634:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(ST33_CS_GPIO_Port, &GPIO_InitStruct);
 8001636:	a903      	add	r1, sp, #12
 8001638:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800163c:	f006 f8d4 	bl	80077e8 <HAL_GPIO_Init>
}
 8001640:	e7b5      	b.n	80015ae <HAL_SPI_MspInit+0x1e>
 8001642:	bf00      	nop
 8001644:	40013000 	.word	0x40013000
 8001648:	40003c00 	.word	0x40003c00
 800164c:	40021000 	.word	0x40021000
 8001650:	48000400 	.word	0x48000400
 8001654:	48000800 	.word	0x48000800

08001658 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8001658:	b500      	push	{lr}
 800165a:	b083      	sub	sp, #12
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800165c:	4b21      	ldr	r3, [pc, #132]	; (80016e4 <HAL_MspInit+0x8c>)
 800165e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001660:	f042 0201 	orr.w	r2, r2, #1
 8001664:	661a      	str	r2, [r3, #96]	; 0x60
 8001666:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001668:	f002 0201 	and.w	r2, r2, #1
 800166c:	9200      	str	r2, [sp, #0]
 800166e:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8001670:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001672:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001676:	659a      	str	r2, [r3, #88]	; 0x58
 8001678:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800167a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800167e:	9301      	str	r3, [sp, #4]
 8001680:	9b01      	ldr	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001682:	2003      	movs	r0, #3
 8001684:	f005 fffa 	bl	800767c <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 8001688:	2200      	movs	r2, #0
 800168a:	4611      	mov	r1, r2
 800168c:	f06f 000b 	mvn.w	r0, #11
 8001690:	f006 f806 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 8001694:	2200      	movs	r2, #0
 8001696:	4611      	mov	r1, r2
 8001698:	f06f 000a 	mvn.w	r0, #10
 800169c:	f006 f800 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80016a0:	2200      	movs	r2, #0
 80016a2:	4611      	mov	r1, r2
 80016a4:	f06f 0009 	mvn.w	r0, #9
 80016a8:	f005 fffa 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80016ac:	2200      	movs	r2, #0
 80016ae:	4611      	mov	r1, r2
 80016b0:	f06f 0004 	mvn.w	r0, #4
 80016b4:	f005 fff4 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80016b8:	2200      	movs	r2, #0
 80016ba:	4611      	mov	r1, r2
 80016bc:	f06f 0003 	mvn.w	r0, #3
 80016c0:	f005 ffee 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80016c4:	2200      	movs	r2, #0
 80016c6:	210f      	movs	r1, #15
 80016c8:	f06f 0001 	mvn.w	r0, #1
 80016cc:	f005 ffe8 	bl	80076a0 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 80016d0:	2200      	movs	r2, #0
 80016d2:	210f      	movs	r1, #15
 80016d4:	f04f 30ff 	mov.w	r0, #4294967295
 80016d8:	f005 ffe2 	bl	80076a0 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80016dc:	b003      	add	sp, #12
 80016de:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e2:	bf00      	nop
 80016e4:	40021000 	.word	0x40021000

080016e8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80016e8:	b500      	push	{lr}
 80016ea:	b089      	sub	sp, #36	; 0x24
 80016ec:	4601      	mov	r1, r0
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, TickPriority ,0); 
 80016ee:	2200      	movs	r2, #0
 80016f0:	2019      	movs	r0, #25
 80016f2:	f005 ffd5 	bl	80076a0 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); 
 80016f6:	2019      	movs	r0, #25
 80016f8:	f006 f80a 	bl	8007710 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 80016fc:	4b14      	ldr	r3, [pc, #80]	; (8001750 <HAL_InitTick+0x68>)
 80016fe:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001700:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001704:	661a      	str	r2, [r3, #96]	; 0x60
 8001706:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001708:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800170c:	9301      	str	r3, [sp, #4]
 800170e:	9b01      	ldr	r3, [sp, #4]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001710:	a902      	add	r1, sp, #8
 8001712:	a803      	add	r0, sp, #12
 8001714:	f007 fc2c 	bl	8008f70 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM1 clock */
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 8001718:	f007 fc18 	bl	8008f4c <HAL_RCC_GetPCLK2Freq>
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800171c:	4b0d      	ldr	r3, [pc, #52]	; (8001754 <HAL_InitTick+0x6c>)
 800171e:	fba3 2300 	umull	r2, r3, r3, r0
 8001722:	0c9b      	lsrs	r3, r3, #18
 8001724:	3b01      	subs	r3, #1
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8001726:	480c      	ldr	r0, [pc, #48]	; (8001758 <HAL_InitTick+0x70>)
 8001728:	4a0c      	ldr	r2, [pc, #48]	; (800175c <HAL_InitTick+0x74>)
 800172a:	6002      	str	r2, [r0, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 800172c:	f240 32e7 	movw	r2, #999	; 0x3e7
 8001730:	60c2      	str	r2, [r0, #12]
  htim1.Init.Prescaler = uwPrescalerValue;
 8001732:	6043      	str	r3, [r0, #4]
  htim1.Init.ClockDivision = 0;
 8001734:	2300      	movs	r3, #0
 8001736:	6103      	str	r3, [r0, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8001738:	6083      	str	r3, [r0, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 800173a:	f008 fa91 	bl	8009c60 <HAL_TIM_Base_Init>
 800173e:	b118      	cbz	r0, 8001748 <HAL_InitTick+0x60>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
  }
  
  /* Return function status */
  return HAL_ERROR;
 8001740:	2001      	movs	r0, #1
}
 8001742:	b009      	add	sp, #36	; 0x24
 8001744:	f85d fb04 	ldr.w	pc, [sp], #4
    return HAL_TIM_Base_Start_IT(&htim1);
 8001748:	4803      	ldr	r0, [pc, #12]	; (8001758 <HAL_InitTick+0x70>)
 800174a:	f008 f93d 	bl	80099c8 <HAL_TIM_Base_Start_IT>
 800174e:	e7f8      	b.n	8001742 <HAL_InitTick+0x5a>
 8001750:	40021000 	.word	0x40021000
 8001754:	431bde83 	.word	0x431bde83
 8001758:	20000b1c 	.word	0x20000b1c
 800175c:	40012c00 	.word	0x40012c00

08001760 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8001760:	4770      	bx	lr

08001762 <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8001762:	e7fe      	b.n	8001762 <HardFault_Handler>

08001764 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8001764:	e7fe      	b.n	8001764 <MemManage_Handler>

08001766 <BusFault_Handler>:
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001766:	e7fe      	b.n	8001766 <BusFault_Handler>

08001768 <UsageFault_Handler>:
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8001768:	e7fe      	b.n	8001768 <UsageFault_Handler>

0800176a <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800176a:	4770      	bx	lr

0800176c <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 800176c:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 800176e:	f024 fbcd 	bl	8025f0c <xTaskGetSchedulerState>
 8001772:	2801      	cmp	r0, #1
 8001774:	d100      	bne.n	8001778 <SysTick_Handler+0xc>
    xPortSysTickHandler();
  }
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8001776:	bd08      	pop	{r3, pc}
    xPortSysTickHandler();
 8001778:	f023 f934 	bl	80249e4 <xPortSysTickHandler>
}
 800177c:	e7fb      	b.n	8001776 <SysTick_Handler+0xa>
	...

08001780 <TIM1_UP_TIM16_IRQHandler>:

/**
  * @brief This function handles TIM1 update interrupt and TIM16 global interrupt.
  */
void TIM1_UP_TIM16_IRQHandler(void)
{
 8001780:	b508      	push	{r3, lr}
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8001782:	4802      	ldr	r0, [pc, #8]	; (800178c <TIM1_UP_TIM16_IRQHandler+0xc>)
 8001784:	f008 f95e 	bl	8009a44 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 1 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 1 */
}
 8001788:	bd08      	pop	{r3, pc}
 800178a:	bf00      	nop
 800178c:	20000b1c 	.word	0x20000b1c

08001790 <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 8001790:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 8001792:	4802      	ldr	r0, [pc, #8]	; (800179c <USART1_IRQHandler+0xc>)
 8001794:	f008 fd58 	bl	800a248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
 8001798:	bd08      	pop	{r3, pc}
 800179a:	bf00      	nop
 800179c:	20000c04 	.word	0x20000c04

080017a0 <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 80017a0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 80017a2:	4802      	ldr	r0, [pc, #8]	; (80017ac <USART2_IRQHandler+0xc>)
 80017a4:	f008 fd50 	bl	800a248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 80017a8:	bd08      	pop	{r3, pc}
 80017aa:	bf00      	nop
 80017ac:	20000c84 	.word	0x20000c84

080017b0 <USART3_IRQHandler>:

/**
  * @brief This function handles USART3 global interrupt.
  */
void USART3_IRQHandler(void)
{
 80017b0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
 80017b2:	4802      	ldr	r0, [pc, #8]	; (80017bc <USART3_IRQHandler+0xc>)
 80017b4:	f008 fd48 	bl	800a248 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
 80017b8:	bd08      	pop	{r3, pc}
 80017ba:	bf00      	nop
 80017bc:	20000d04 	.word	0x20000d04

080017c0 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 80017c0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
 80017c2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80017c6:	f006 f973 	bl	8007ab0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 80017ca:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80017ce:	f006 f96f 	bl	8007ab0 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 80017d2:	bd08      	pop	{r3, pc}

080017d4 <_getpid>:
}

int _getpid(void)
{
	return 1;
}
 80017d4:	2001      	movs	r0, #1
 80017d6:	4770      	bx	lr

080017d8 <_kill>:

int _kill(int pid, int sig)
{
 80017d8:	b508      	push	{r3, lr}
	errno = EINVAL;
 80017da:	f025 f94f 	bl	8026a7c <__errno>
 80017de:	2316      	movs	r3, #22
 80017e0:	6003      	str	r3, [r0, #0]
	return -1;
}
 80017e2:	f04f 30ff 	mov.w	r0, #4294967295
 80017e6:	bd08      	pop	{r3, pc}

080017e8 <_exit>:

void _exit (int status)
{
 80017e8:	b508      	push	{r3, lr}
	_kill(status, -1);
 80017ea:	f04f 31ff 	mov.w	r1, #4294967295
 80017ee:	f7ff fff3 	bl	80017d8 <_kill>
	while (1) {}		/* Make sure we hang here */
 80017f2:	e7fe      	b.n	80017f2 <_exit+0xa>

080017f4 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80017f4:	b570      	push	{r4, r5, r6, lr}
 80017f6:	460c      	mov	r4, r1
 80017f8:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80017fa:	2500      	movs	r5, #0
 80017fc:	e006      	b.n	800180c <_read+0x18>
	{
		*ptr++ = __io_getchar();
 80017fe:	f3af 8000 	nop.w
 8001802:	4621      	mov	r1, r4
 8001804:	f801 0b01 	strb.w	r0, [r1], #1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001808:	3501      	adds	r5, #1
		*ptr++ = __io_getchar();
 800180a:	460c      	mov	r4, r1
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800180c:	42b5      	cmp	r5, r6
 800180e:	dbf6      	blt.n	80017fe <_read+0xa>
	}

return len;
}
 8001810:	4630      	mov	r0, r6
 8001812:	bd70      	pop	{r4, r5, r6, pc}

08001814 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 8001814:	b570      	push	{r4, r5, r6, lr}
 8001816:	460c      	mov	r4, r1
 8001818:	4616      	mov	r6, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800181a:	2500      	movs	r5, #0
 800181c:	e004      	b.n	8001828 <_write+0x14>
	{
		__io_putchar(*ptr++);
 800181e:	f814 0b01 	ldrb.w	r0, [r4], #1
 8001822:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8001826:	3501      	adds	r5, #1
 8001828:	42b5      	cmp	r5, r6
 800182a:	dbf8      	blt.n	800181e <_write+0xa>
	}
	return len;
}
 800182c:	4630      	mov	r0, r6
 800182e:	bd70      	pop	{r4, r5, r6, pc}

08001830 <_close>:

int _close(int file)
{
	return -1;
}
 8001830:	f04f 30ff 	mov.w	r0, #4294967295
 8001834:	4770      	bx	lr

08001836 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8001836:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800183a:	604b      	str	r3, [r1, #4]
	return 0;
}
 800183c:	2000      	movs	r0, #0
 800183e:	4770      	bx	lr

08001840 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8001840:	2001      	movs	r0, #1
 8001842:	4770      	bx	lr

08001844 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8001844:	2000      	movs	r0, #0
 8001846:	4770      	bx	lr

08001848 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001848:	b510      	push	{r4, lr}
 800184a:	4603      	mov	r3, r0
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 800184c:	4a0c      	ldr	r2, [pc, #48]	; (8001880 <_sbrk+0x38>)
 800184e:	490d      	ldr	r1, [pc, #52]	; (8001884 <_sbrk+0x3c>)
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initalize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001850:	480d      	ldr	r0, [pc, #52]	; (8001888 <_sbrk+0x40>)
 8001852:	6800      	ldr	r0, [r0, #0]
 8001854:	b140      	cbz	r0, 8001868 <_sbrk+0x20>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8001856:	480c      	ldr	r0, [pc, #48]	; (8001888 <_sbrk+0x40>)
 8001858:	6800      	ldr	r0, [r0, #0]
 800185a:	4403      	add	r3, r0
 800185c:	1a52      	subs	r2, r2, r1
 800185e:	4293      	cmp	r3, r2
 8001860:	d806      	bhi.n	8001870 <_sbrk+0x28>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8001862:	4a09      	ldr	r2, [pc, #36]	; (8001888 <_sbrk+0x40>)
 8001864:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
}
 8001866:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8001868:	4807      	ldr	r0, [pc, #28]	; (8001888 <_sbrk+0x40>)
 800186a:	4c08      	ldr	r4, [pc, #32]	; (800188c <_sbrk+0x44>)
 800186c:	6004      	str	r4, [r0, #0]
 800186e:	e7f2      	b.n	8001856 <_sbrk+0xe>
    errno = ENOMEM;
 8001870:	f025 f904 	bl	8026a7c <__errno>
 8001874:	230c      	movs	r3, #12
 8001876:	6003      	str	r3, [r0, #0]
    return (void *)-1;
 8001878:	f04f 30ff 	mov.w	r0, #4294967295
 800187c:	e7f3      	b.n	8001866 <_sbrk+0x1e>
 800187e:	bf00      	nop
 8001880:	20028000 	.word	0x20028000
 8001884:	00000400 	.word	0x00000400
 8001888:	20000b68 	.word	0x20000b68
 800188c:	200120a8 	.word	0x200120a8

08001890 <HAL_TIM_PWM_MspInit>:
  HAL_TIM_MspPostInit(&htim3);

}

void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* tim_pwmHandle)
{
 8001890:	b082      	sub	sp, #8

  if(tim_pwmHandle->Instance==TIM2)
 8001892:	6803      	ldr	r3, [r0, #0]
 8001894:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8001898:	d004      	beq.n	80018a4 <HAL_TIM_PWM_MspInit+0x14>
    __HAL_RCC_TIM2_CLK_ENABLE();
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }
  else if(tim_pwmHandle->Instance==TIM3)
 800189a:	4a0e      	ldr	r2, [pc, #56]	; (80018d4 <HAL_TIM_PWM_MspInit+0x44>)
 800189c:	4293      	cmp	r3, r2
 800189e:	d00d      	beq.n	80018bc <HAL_TIM_PWM_MspInit+0x2c>
    __HAL_RCC_TIM3_CLK_ENABLE();
  /* USER CODE BEGIN TIM3_MspInit 1 */

  /* USER CODE END TIM3_MspInit 1 */
  }
}
 80018a0:	b002      	add	sp, #8
 80018a2:	4770      	bx	lr
    __HAL_RCC_TIM2_CLK_ENABLE();
 80018a4:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80018a8:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80018aa:	f042 0201 	orr.w	r2, r2, #1
 80018ae:	659a      	str	r2, [r3, #88]	; 0x58
 80018b0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80018b2:	f003 0301 	and.w	r3, r3, #1
 80018b6:	9300      	str	r3, [sp, #0]
 80018b8:	9b00      	ldr	r3, [sp, #0]
 80018ba:	e7f1      	b.n	80018a0 <HAL_TIM_PWM_MspInit+0x10>
    __HAL_RCC_TIM3_CLK_ENABLE();
 80018bc:	4b06      	ldr	r3, [pc, #24]	; (80018d8 <HAL_TIM_PWM_MspInit+0x48>)
 80018be:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80018c0:	f042 0202 	orr.w	r2, r2, #2
 80018c4:	659a      	str	r2, [r3, #88]	; 0x58
 80018c6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80018c8:	f003 0302 	and.w	r3, r3, #2
 80018cc:	9301      	str	r3, [sp, #4]
 80018ce:	9b01      	ldr	r3, [sp, #4]
}
 80018d0:	e7e6      	b.n	80018a0 <HAL_TIM_PWM_MspInit+0x10>
 80018d2:	bf00      	nop
 80018d4:	40000400 	.word	0x40000400
 80018d8:	40021000 	.word	0x40021000

080018dc <HAL_TIM_MspPostInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{
 80018dc:	b500      	push	{lr}
 80018de:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80018e0:	2300      	movs	r3, #0
 80018e2:	9301      	str	r3, [sp, #4]
 80018e4:	9302      	str	r3, [sp, #8]
 80018e6:	9303      	str	r3, [sp, #12]
 80018e8:	9304      	str	r3, [sp, #16]
 80018ea:	9305      	str	r3, [sp, #20]
  if(timHandle->Instance==TIM2)
 80018ec:	6803      	ldr	r3, [r0, #0]
 80018ee:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80018f2:	d005      	beq.n	8001900 <HAL_TIM_MspPostInit+0x24>

  /* USER CODE BEGIN TIM2_MspPostInit 1 */

  /* USER CODE END TIM2_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM3)
 80018f4:	4a0d      	ldr	r2, [pc, #52]	; (800192c <HAL_TIM_MspPostInit+0x50>)
 80018f6:	4293      	cmp	r3, r2
 80018f8:	d00d      	beq.n	8001916 <HAL_TIM_MspPostInit+0x3a>
  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }

}
 80018fa:	b007      	add	sp, #28
 80018fc:	f85d fb04 	ldr.w	pc, [sp], #4
    GPIO_InitStruct.Pin = ARD_D3_Pin;
 8001900:	2308      	movs	r3, #8
 8001902:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001904:	2302      	movs	r3, #2
 8001906:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8001908:	2301      	movs	r3, #1
 800190a:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(ARD_D3_GPIO_Port, &GPIO_InitStruct);
 800190c:	a901      	add	r1, sp, #4
 800190e:	4808      	ldr	r0, [pc, #32]	; (8001930 <HAL_TIM_MspPostInit+0x54>)
 8001910:	f005 ff6a 	bl	80077e8 <HAL_GPIO_Init>
 8001914:	e7f1      	b.n	80018fa <HAL_TIM_MspPostInit+0x1e>
    GPIO_InitStruct.Pin = ARD_D6_Pin;
 8001916:	f44f 7300 	mov.w	r3, #512	; 0x200
 800191a:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800191c:	2302      	movs	r3, #2
 800191e:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8001920:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(ARD_D6_GPIO_Port, &GPIO_InitStruct);
 8001922:	a901      	add	r1, sp, #4
 8001924:	4803      	ldr	r0, [pc, #12]	; (8001934 <HAL_TIM_MspPostInit+0x58>)
 8001926:	f005 ff5f 	bl	80077e8 <HAL_GPIO_Init>
}
 800192a:	e7e6      	b.n	80018fa <HAL_TIM_MspPostInit+0x1e>
 800192c:	40000400 	.word	0x40000400
 8001930:	48000400 	.word	0x48000400
 8001934:	48000800 	.word	0x48000800

08001938 <MX_TIM2_Init>:
{
 8001938:	b500      	push	{lr}
 800193a:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800193c:	2300      	movs	r3, #0
 800193e:	9307      	str	r3, [sp, #28]
 8001940:	9308      	str	r3, [sp, #32]
 8001942:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 8001944:	9300      	str	r3, [sp, #0]
 8001946:	9301      	str	r3, [sp, #4]
 8001948:	9302      	str	r3, [sp, #8]
 800194a:	9303      	str	r3, [sp, #12]
 800194c:	9304      	str	r3, [sp, #16]
 800194e:	9305      	str	r3, [sp, #20]
 8001950:	9306      	str	r3, [sp, #24]
  htim2.Instance = TIM2;
 8001952:	4817      	ldr	r0, [pc, #92]	; (80019b0 <MX_TIM2_Init+0x78>)
 8001954:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001958:	6002      	str	r2, [r0, #0]
  htim2.Init.Prescaler = 0;
 800195a:	6043      	str	r3, [r0, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 800195c:	6083      	str	r3, [r0, #8]
  htim2.Init.Period = 0;
 800195e:	60c3      	str	r3, [r0, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8001960:	6103      	str	r3, [r0, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001962:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 8001964:	f008 f9ac 	bl	8009cc0 <HAL_TIM_PWM_Init>
 8001968:	b9c8      	cbnz	r0, 800199e <MX_TIM2_Init+0x66>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800196a:	2300      	movs	r3, #0
 800196c:	9307      	str	r3, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800196e:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8001970:	a907      	add	r1, sp, #28
 8001972:	480f      	ldr	r0, [pc, #60]	; (80019b0 <MX_TIM2_Init+0x78>)
 8001974:	f008 faa4 	bl	8009ec0 <HAL_TIMEx_MasterConfigSynchronization>
 8001978:	b9a0      	cbnz	r0, 80019a4 <MX_TIM2_Init+0x6c>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800197a:	2360      	movs	r3, #96	; 0x60
 800197c:	9300      	str	r3, [sp, #0]
  sConfigOC.Pulse = 0;
 800197e:	2300      	movs	r3, #0
 8001980:	9301      	str	r3, [sp, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8001982:	9302      	str	r3, [sp, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8001984:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 8001986:	2204      	movs	r2, #4
 8001988:	4669      	mov	r1, sp
 800198a:	4809      	ldr	r0, [pc, #36]	; (80019b0 <MX_TIM2_Init+0x78>)
 800198c:	f008 fa04 	bl	8009d98 <HAL_TIM_PWM_ConfigChannel>
 8001990:	b958      	cbnz	r0, 80019aa <MX_TIM2_Init+0x72>
  HAL_TIM_MspPostInit(&htim2);
 8001992:	4807      	ldr	r0, [pc, #28]	; (80019b0 <MX_TIM2_Init+0x78>)
 8001994:	f7ff ffa2 	bl	80018dc <HAL_TIM_MspPostInit>
}
 8001998:	b00b      	add	sp, #44	; 0x2c
 800199a:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 800199e:	f7ff fc4b 	bl	8001238 <Error_Handler>
 80019a2:	e7e2      	b.n	800196a <MX_TIM2_Init+0x32>
    Error_Handler();
 80019a4:	f7ff fc48 	bl	8001238 <Error_Handler>
 80019a8:	e7e7      	b.n	800197a <MX_TIM2_Init+0x42>
    Error_Handler();
 80019aa:	f7ff fc45 	bl	8001238 <Error_Handler>
 80019ae:	e7f0      	b.n	8001992 <MX_TIM2_Init+0x5a>
 80019b0:	20000b6c 	.word	0x20000b6c

080019b4 <MX_TIM3_Init>:
{
 80019b4:	b500      	push	{lr}
 80019b6:	b08b      	sub	sp, #44	; 0x2c
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 80019b8:	2300      	movs	r3, #0
 80019ba:	9307      	str	r3, [sp, #28]
 80019bc:	9308      	str	r3, [sp, #32]
 80019be:	9309      	str	r3, [sp, #36]	; 0x24
  TIM_OC_InitTypeDef sConfigOC = {0};
 80019c0:	9300      	str	r3, [sp, #0]
 80019c2:	9301      	str	r3, [sp, #4]
 80019c4:	9302      	str	r3, [sp, #8]
 80019c6:	9303      	str	r3, [sp, #12]
 80019c8:	9304      	str	r3, [sp, #16]
 80019ca:	9305      	str	r3, [sp, #20]
 80019cc:	9306      	str	r3, [sp, #24]
  htim3.Instance = TIM3;
 80019ce:	4817      	ldr	r0, [pc, #92]	; (8001a2c <MX_TIM3_Init+0x78>)
 80019d0:	4a17      	ldr	r2, [pc, #92]	; (8001a30 <MX_TIM3_Init+0x7c>)
 80019d2:	6002      	str	r2, [r0, #0]
  htim3.Init.Prescaler = 0;
 80019d4:	6043      	str	r3, [r0, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 80019d6:	6083      	str	r3, [r0, #8]
  htim3.Init.Period = 0;
 80019d8:	60c3      	str	r3, [r0, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 80019da:	6103      	str	r3, [r0, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 80019dc:	6183      	str	r3, [r0, #24]
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 80019de:	f008 f96f 	bl	8009cc0 <HAL_TIM_PWM_Init>
 80019e2:	b9c8      	cbnz	r0, 8001a18 <MX_TIM3_Init+0x64>
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 80019e4:	2300      	movs	r3, #0
 80019e6:	9307      	str	r3, [sp, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 80019e8:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 80019ea:	a907      	add	r1, sp, #28
 80019ec:	480f      	ldr	r0, [pc, #60]	; (8001a2c <MX_TIM3_Init+0x78>)
 80019ee:	f008 fa67 	bl	8009ec0 <HAL_TIMEx_MasterConfigSynchronization>
 80019f2:	b9a0      	cbnz	r0, 8001a1e <MX_TIM3_Init+0x6a>
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 80019f4:	2360      	movs	r3, #96	; 0x60
 80019f6:	9300      	str	r3, [sp, #0]
  sConfigOC.Pulse = 0;
 80019f8:	2300      	movs	r3, #0
 80019fa:	9301      	str	r3, [sp, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 80019fc:	9302      	str	r3, [sp, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 80019fe:	9304      	str	r3, [sp, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8001a00:	220c      	movs	r2, #12
 8001a02:	4669      	mov	r1, sp
 8001a04:	4809      	ldr	r0, [pc, #36]	; (8001a2c <MX_TIM3_Init+0x78>)
 8001a06:	f008 f9c7 	bl	8009d98 <HAL_TIM_PWM_ConfigChannel>
 8001a0a:	b958      	cbnz	r0, 8001a24 <MX_TIM3_Init+0x70>
  HAL_TIM_MspPostInit(&htim3);
 8001a0c:	4807      	ldr	r0, [pc, #28]	; (8001a2c <MX_TIM3_Init+0x78>)
 8001a0e:	f7ff ff65 	bl	80018dc <HAL_TIM_MspPostInit>
}
 8001a12:	b00b      	add	sp, #44	; 0x2c
 8001a14:	f85d fb04 	ldr.w	pc, [sp], #4
    Error_Handler();
 8001a18:	f7ff fc0e 	bl	8001238 <Error_Handler>
 8001a1c:	e7e2      	b.n	80019e4 <MX_TIM3_Init+0x30>
    Error_Handler();
 8001a1e:	f7ff fc0b 	bl	8001238 <Error_Handler>
 8001a22:	e7e7      	b.n	80019f4 <MX_TIM3_Init+0x40>
    Error_Handler();
 8001a24:	f7ff fc08 	bl	8001238 <Error_Handler>
 8001a28:	e7f0      	b.n	8001a0c <MX_TIM3_Init+0x58>
 8001a2a:	bf00      	nop
 8001a2c:	20000bb8 	.word	0x20000bb8
 8001a30:	40000400 	.word	0x40000400

08001a34 <MX_USART1_UART_Init>:
UART_HandleTypeDef huart3;

/* USART1 init function */

void MX_USART1_UART_Init(void)
{
 8001a34:	b508      	push	{r3, lr}

  huart1.Instance = USART1;
 8001a36:	480b      	ldr	r0, [pc, #44]	; (8001a64 <MX_USART1_UART_Init+0x30>)
 8001a38:	4b0b      	ldr	r3, [pc, #44]	; (8001a68 <MX_USART1_UART_Init+0x34>)
 8001a3a:	6003      	str	r3, [r0, #0]
  huart1.Init.BaudRate = 115200;
 8001a3c:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8001a40:	6043      	str	r3, [r0, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8001a42:	2300      	movs	r3, #0
 8001a44:	6083      	str	r3, [r0, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8001a46:	60c3      	str	r3, [r0, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8001a48:	6103      	str	r3, [r0, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8001a4a:	220c      	movs	r2, #12
 8001a4c:	6142      	str	r2, [r0, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001a4e:	6183      	str	r3, [r0, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8001a50:	61c3      	str	r3, [r0, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001a52:	6203      	str	r3, [r0, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001a54:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8001a56:	f008 ffc8 	bl	800a9ea <HAL_UART_Init>
 8001a5a:	b900      	cbnz	r0, 8001a5e <MX_USART1_UART_Init+0x2a>
  {
    Error_Handler();
  }

}
 8001a5c:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001a5e:	f7ff fbeb 	bl	8001238 <Error_Handler>
}
 8001a62:	e7fb      	b.n	8001a5c <MX_USART1_UART_Init+0x28>
 8001a64:	20000c04 	.word	0x20000c04
 8001a68:	40013800 	.word	0x40013800

08001a6c <MX_USART2_UART_Init>:
/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 8001a6c:	b508      	push	{r3, lr}

  huart2.Instance = USART2;
 8001a6e:	480b      	ldr	r0, [pc, #44]	; (8001a9c <MX_USART2_UART_Init+0x30>)
 8001a70:	4b0b      	ldr	r3, [pc, #44]	; (8001aa0 <MX_USART2_UART_Init+0x34>)
 8001a72:	6003      	str	r3, [r0, #0]
  huart2.Init.BaudRate = 115200;
 8001a74:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8001a78:	6043      	str	r3, [r0, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 8001a7a:	2300      	movs	r3, #0
 8001a7c:	6083      	str	r3, [r0, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8001a7e:	60c3      	str	r3, [r0, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 8001a80:	6103      	str	r3, [r0, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8001a82:	220c      	movs	r2, #12
 8001a84:	6142      	str	r2, [r0, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001a86:	6183      	str	r3, [r0, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8001a88:	61c3      	str	r3, [r0, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8001a8a:	6203      	str	r3, [r0, #32]
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8001a8c:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8001a8e:	f008 ffac 	bl	800a9ea <HAL_UART_Init>
 8001a92:	b900      	cbnz	r0, 8001a96 <MX_USART2_UART_Init+0x2a>
  {
    Error_Handler();
  }

}
 8001a94:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001a96:	f7ff fbcf 	bl	8001238 <Error_Handler>
}
 8001a9a:	e7fb      	b.n	8001a94 <MX_USART2_UART_Init+0x28>
 8001a9c:	20000c84 	.word	0x20000c84
 8001aa0:	40004400 	.word	0x40004400

08001aa4 <HAL_UART_MspInit>:
  }

}

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 8001aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001aa6:	b089      	sub	sp, #36	; 0x24

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001aa8:	2300      	movs	r3, #0
 8001aaa:	9303      	str	r3, [sp, #12]
 8001aac:	9304      	str	r3, [sp, #16]
 8001aae:	9305      	str	r3, [sp, #20]
 8001ab0:	9306      	str	r3, [sp, #24]
 8001ab2:	9307      	str	r3, [sp, #28]
  if(uartHandle->Instance==USART1)
 8001ab4:	6803      	ldr	r3, [r0, #0]
 8001ab6:	4a43      	ldr	r2, [pc, #268]	; (8001bc4 <HAL_UART_MspInit+0x120>)
 8001ab8:	4293      	cmp	r3, r2
 8001aba:	d007      	beq.n	8001acc <HAL_UART_MspInit+0x28>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
  else if(uartHandle->Instance==USART2)
 8001abc:	4a42      	ldr	r2, [pc, #264]	; (8001bc8 <HAL_UART_MspInit+0x124>)
 8001abe:	4293      	cmp	r3, r2
 8001ac0:	d025      	beq.n	8001b0e <HAL_UART_MspInit+0x6a>

    /* will be reactivated later */
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE END USART2_MspInit 1 */
  }
  else if(uartHandle->Instance==USART3)
 8001ac2:	4a42      	ldr	r2, [pc, #264]	; (8001bcc <HAL_UART_MspInit+0x128>)
 8001ac4:	4293      	cmp	r3, r2
 8001ac6:	d045      	beq.n	8001b54 <HAL_UART_MspInit+0xb0>
  /* USER CODE BEGIN USART3_MspInit 1 */
    /* disable IRQ to avoid problems with IPC - will be reactivated later */
    HAL_NVIC_DisableIRQ(USART3_IRQn);
  /* USER CODE END USART3_MspInit 1 */
  }
}
 8001ac8:	b009      	add	sp, #36	; 0x24
 8001aca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_USART1_CLK_ENABLE();
 8001acc:	4b40      	ldr	r3, [pc, #256]	; (8001bd0 <HAL_UART_MspInit+0x12c>)
 8001ace:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001ad0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001ad4:	661a      	str	r2, [r3, #96]	; 0x60
 8001ad6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001ad8:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001adc:	9300      	str	r3, [sp, #0]
 8001ade:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = ARD_D2_Pin|ARD_D8_Pin;
 8001ae0:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8001ae4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001ae6:	2302      	movs	r3, #2
 8001ae8:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001aea:	2303      	movs	r3, #3
 8001aec:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8001aee:	2307      	movs	r3, #7
 8001af0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001af2:	a903      	add	r1, sp, #12
 8001af4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001af8:	f005 fe76 	bl	80077e8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
 8001afc:	2200      	movs	r2, #0
 8001afe:	2105      	movs	r1, #5
 8001b00:	2025      	movs	r0, #37	; 0x25
 8001b02:	f005 fdcd 	bl	80076a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART1_IRQn);
 8001b06:	2025      	movs	r0, #37	; 0x25
 8001b08:	f005 fe02 	bl	8007710 <HAL_NVIC_EnableIRQ>
 8001b0c:	e7dc      	b.n	8001ac8 <HAL_UART_MspInit+0x24>
    __HAL_RCC_USART2_CLK_ENABLE();
 8001b0e:	4b30      	ldr	r3, [pc, #192]	; (8001bd0 <HAL_UART_MspInit+0x12c>)
 8001b10:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001b12:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001b16:	659a      	str	r2, [r3, #88]	; 0x58
 8001b18:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b1a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001b1e:	9301      	str	r3, [sp, #4]
 8001b20:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin = ARD_A1_Pin|ARD_D0_Pin|ARD_D1_Pin|ARD_A0_Pin;
 8001b22:	230f      	movs	r3, #15
 8001b24:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b26:	2302      	movs	r3, #2
 8001b28:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b2a:	2303      	movs	r3, #3
 8001b2c:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8001b2e:	2307      	movs	r3, #7
 8001b30:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001b32:	a903      	add	r1, sp, #12
 8001b34:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001b38:	f005 fe56 	bl	80077e8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
 8001b3c:	2200      	movs	r2, #0
 8001b3e:	2105      	movs	r1, #5
 8001b40:	2026      	movs	r0, #38	; 0x26
 8001b42:	f005 fdad 	bl	80076a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8001b46:	2026      	movs	r0, #38	; 0x26
 8001b48:	f005 fde2 	bl	8007710 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 8001b4c:	2026      	movs	r0, #38	; 0x26
 8001b4e:	f005 fded 	bl	800772c <HAL_NVIC_DisableIRQ>
 8001b52:	e7b9      	b.n	8001ac8 <HAL_UART_MspInit+0x24>
    __HAL_RCC_USART3_CLK_ENABLE();
 8001b54:	4b1e      	ldr	r3, [pc, #120]	; (8001bd0 <HAL_UART_MspInit+0x12c>)
 8001b56:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001b58:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8001b5c:	659a      	str	r2, [r3, #88]	; 0x58
 8001b5e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b60:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001b64:	9302      	str	r3, [sp, #8]
 8001b66:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = MDM_UART_RTS_Pin;
 8001b68:	2304      	movs	r3, #4
 8001b6a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b6c:	2702      	movs	r7, #2
 8001b6e:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b70:	2603      	movs	r6, #3
 8001b72:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001b74:	2507      	movs	r5, #7
 8001b76:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(MDM_UART_RTS_GPIO_Port, &GPIO_InitStruct);
 8001b78:	a903      	add	r1, sp, #12
 8001b7a:	4816      	ldr	r0, [pc, #88]	; (8001bd4 <HAL_UART_MspInit+0x130>)
 8001b7c:	f005 fe34 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = MDM_UART_TX_Pin|MDM_UART_RX_Pin;
 8001b80:	2330      	movs	r3, #48	; 0x30
 8001b82:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b84:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b86:	2400      	movs	r4, #0
 8001b88:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001b8a:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001b8c:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001b8e:	a903      	add	r1, sp, #12
 8001b90:	4811      	ldr	r0, [pc, #68]	; (8001bd8 <HAL_UART_MspInit+0x134>)
 8001b92:	f005 fe29 	bl	80077e8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = MDM_UART_CTS_Pin;
 8001b96:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001b9a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001b9c:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001b9e:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001ba0:	9606      	str	r6, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001ba2:	9507      	str	r5, [sp, #28]
    HAL_GPIO_Init(MDM_UART_CTS_GPIO_Port, &GPIO_InitStruct);
 8001ba4:	a903      	add	r1, sp, #12
 8001ba6:	480d      	ldr	r0, [pc, #52]	; (8001bdc <HAL_UART_MspInit+0x138>)
 8001ba8:	f005 fe1e 	bl	80077e8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
 8001bac:	4622      	mov	r2, r4
 8001bae:	2105      	movs	r1, #5
 8001bb0:	2027      	movs	r0, #39	; 0x27
 8001bb2:	f005 fd75 	bl	80076a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 8001bb6:	2027      	movs	r0, #39	; 0x27
 8001bb8:	f005 fdaa 	bl	8007710 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
 8001bbc:	2027      	movs	r0, #39	; 0x27
 8001bbe:	f005 fdb5 	bl	800772c <HAL_NVIC_DisableIRQ>
}
 8001bc2:	e781      	b.n	8001ac8 <HAL_UART_MspInit+0x24>
 8001bc4:	40013800 	.word	0x40013800
 8001bc8:	40004400 	.word	0x40004400
 8001bcc:	40004800 	.word	0x40004800
 8001bd0:	40021000 	.word	0x40021000
 8001bd4:	48000c00 	.word	0x48000c00
 8001bd8:	48000800 	.word	0x48000800
 8001bdc:	48000400 	.word	0x48000400

08001be0 <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{
 8001be0:	b508      	push	{r3, lr}

  if(uartHandle->Instance==USART1)
 8001be2:	6803      	ldr	r3, [r0, #0]
 8001be4:	4a1f      	ldr	r2, [pc, #124]	; (8001c64 <HAL_UART_MspDeInit+0x84>)
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d006      	beq.n	8001bf8 <HAL_UART_MspDeInit+0x18>
    HAL_NVIC_DisableIRQ(USART1_IRQn);
  /* USER CODE BEGIN USART1_MspDeInit 1 */

  /* USER CODE END USART1_MspDeInit 1 */
  }
  else if(uartHandle->Instance==USART2)
 8001bea:	4a1f      	ldr	r2, [pc, #124]	; (8001c68 <HAL_UART_MspDeInit+0x88>)
 8001bec:	4293      	cmp	r3, r2
 8001bee:	d013      	beq.n	8001c18 <HAL_UART_MspDeInit+0x38>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  /* USER CODE BEGIN USART2_MspDeInit 1 */

  /* USER CODE END USART2_MspDeInit 1 */
  }
  else if(uartHandle->Instance==USART3)
 8001bf0:	4a1e      	ldr	r2, [pc, #120]	; (8001c6c <HAL_UART_MspDeInit+0x8c>)
 8001bf2:	4293      	cmp	r3, r2
 8001bf4:	d01f      	beq.n	8001c36 <HAL_UART_MspDeInit+0x56>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
  /* USER CODE BEGIN USART3_MspDeInit 1 */

  /* USER CODE END USART3_MspDeInit 1 */
  }
} 
 8001bf6:	bd08      	pop	{r3, pc}
    __HAL_RCC_USART1_CLK_DISABLE();
 8001bf8:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
 8001bfc:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8001bfe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001c02:	6613      	str	r3, [r2, #96]	; 0x60
    HAL_GPIO_DeInit(GPIOA, ARD_D2_Pin|ARD_D8_Pin);
 8001c04:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8001c08:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001c0c:	f005 febe 	bl	800798c <HAL_GPIO_DeInit>
    HAL_NVIC_DisableIRQ(USART1_IRQn);
 8001c10:	2025      	movs	r0, #37	; 0x25
 8001c12:	f005 fd8b 	bl	800772c <HAL_NVIC_DisableIRQ>
 8001c16:	e7ee      	b.n	8001bf6 <HAL_UART_MspDeInit+0x16>
    __HAL_RCC_USART2_CLK_DISABLE();
 8001c18:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 8001c1c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001c1e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001c22:	6593      	str	r3, [r2, #88]	; 0x58
    HAL_GPIO_DeInit(GPIOA, ARD_A1_Pin|ARD_D0_Pin|ARD_D1_Pin|ARD_A0_Pin);
 8001c24:	210f      	movs	r1, #15
 8001c26:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001c2a:	f005 feaf 	bl	800798c <HAL_GPIO_DeInit>
    HAL_NVIC_DisableIRQ(USART2_IRQn);
 8001c2e:	2026      	movs	r0, #38	; 0x26
 8001c30:	f005 fd7c 	bl	800772c <HAL_NVIC_DisableIRQ>
 8001c34:	e7df      	b.n	8001bf6 <HAL_UART_MspDeInit+0x16>
    __HAL_RCC_USART3_CLK_DISABLE();
 8001c36:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 8001c3a:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8001c3c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001c40:	6593      	str	r3, [r2, #88]	; 0x58
    HAL_GPIO_DeInit(MDM_UART_RTS_GPIO_Port, MDM_UART_RTS_Pin);
 8001c42:	2104      	movs	r1, #4
 8001c44:	480a      	ldr	r0, [pc, #40]	; (8001c70 <HAL_UART_MspDeInit+0x90>)
 8001c46:	f005 fea1 	bl	800798c <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(GPIOC, MDM_UART_TX_Pin|MDM_UART_RX_Pin);
 8001c4a:	2130      	movs	r1, #48	; 0x30
 8001c4c:	4809      	ldr	r0, [pc, #36]	; (8001c74 <HAL_UART_MspDeInit+0x94>)
 8001c4e:	f005 fe9d 	bl	800798c <HAL_GPIO_DeInit>
    HAL_GPIO_DeInit(MDM_UART_CTS_GPIO_Port, MDM_UART_CTS_Pin);
 8001c52:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001c56:	4808      	ldr	r0, [pc, #32]	; (8001c78 <HAL_UART_MspDeInit+0x98>)
 8001c58:	f005 fe98 	bl	800798c <HAL_GPIO_DeInit>
    HAL_NVIC_DisableIRQ(USART3_IRQn);
 8001c5c:	2027      	movs	r0, #39	; 0x27
 8001c5e:	f005 fd65 	bl	800772c <HAL_NVIC_DisableIRQ>
} 
 8001c62:	e7c8      	b.n	8001bf6 <HAL_UART_MspDeInit+0x16>
 8001c64:	40013800 	.word	0x40013800
 8001c68:	40004400 	.word	0x40004400
 8001c6c:	40004800 	.word	0x40004800
 8001c70:	48000c00 	.word	0x48000c00
 8001c74:	48000800 	.word	0x48000800
 8001c78:	48000400 	.word	0x48000400

08001c7c <MX_USB_PCD_Init>:
PCD_HandleTypeDef hpcd_USB_FS;

/* USB init function */

void MX_USB_PCD_Init(void)
{
 8001c7c:	b508      	push	{r3, lr}

  hpcd_USB_FS.Instance = USB;
 8001c7e:	480a      	ldr	r0, [pc, #40]	; (8001ca8 <MX_USB_PCD_Init+0x2c>)
 8001c80:	4b0a      	ldr	r3, [pc, #40]	; (8001cac <MX_USB_PCD_Init+0x30>)
 8001c82:	6003      	str	r3, [r0, #0]
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8001c84:	2308      	movs	r3, #8
 8001c86:	6043      	str	r3, [r0, #4]
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8001c88:	2202      	movs	r2, #2
 8001c8a:	6082      	str	r2, [r0, #8]
  hpcd_USB_FS.Init.ep0_mps = EP_MPS_64;
 8001c8c:	2300      	movs	r3, #0
 8001c8e:	60c3      	str	r3, [r0, #12]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 8001c90:	6102      	str	r2, [r0, #16]
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
 8001c92:	6143      	str	r3, [r0, #20]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 8001c94:	6183      	str	r3, [r0, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 8001c96:	61c3      	str	r3, [r0, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8001c98:	6203      	str	r3, [r0, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8001c9a:	f006 fb03 	bl	80082a4 <HAL_PCD_Init>
 8001c9e:	b900      	cbnz	r0, 8001ca2 <MX_USB_PCD_Init+0x26>
  {
    Error_Handler();
  }

}
 8001ca0:	bd08      	pop	{r3, pc}
    Error_Handler();
 8001ca2:	f7ff fac9 	bl	8001238 <Error_Handler>
}
 8001ca6:	e7fb      	b.n	8001ca0 <MX_USB_PCD_Init+0x24>
 8001ca8:	20000d84 	.word	0x20000d84
 8001cac:	40006800 	.word	0x40006800

08001cb0 <HAL_PCD_MspInit>:

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8001cb0:	b500      	push	{lr}
 8001cb2:	b087      	sub	sp, #28

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001cb4:	2300      	movs	r3, #0
 8001cb6:	9301      	str	r3, [sp, #4]
 8001cb8:	9302      	str	r3, [sp, #8]
 8001cba:	9303      	str	r3, [sp, #12]
 8001cbc:	9304      	str	r3, [sp, #16]
 8001cbe:	9305      	str	r3, [sp, #20]
  if(pcdHandle->Instance==USB)
 8001cc0:	6802      	ldr	r2, [r0, #0]
 8001cc2:	4b0f      	ldr	r3, [pc, #60]	; (8001d00 <HAL_PCD_MspInit+0x50>)
 8001cc4:	429a      	cmp	r2, r3
 8001cc6:	d002      	beq.n	8001cce <HAL_PCD_MspInit+0x1e>
    __HAL_RCC_USB_CLK_ENABLE();
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8001cc8:	b007      	add	sp, #28
 8001cca:	f85d fb04 	ldr.w	pc, [sp], #4
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8001cce:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8001cd2:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001cd4:	2302      	movs	r3, #2
 8001cd6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001cd8:	2303      	movs	r3, #3
 8001cda:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
 8001cdc:	230a      	movs	r3, #10
 8001cde:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001ce0:	a901      	add	r1, sp, #4
 8001ce2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001ce6:	f005 fd7f 	bl	80077e8 <HAL_GPIO_Init>
    __HAL_RCC_USB_CLK_ENABLE();
 8001cea:	4b06      	ldr	r3, [pc, #24]	; (8001d04 <HAL_PCD_MspInit+0x54>)
 8001cec:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001cee:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8001cf2:	659a      	str	r2, [r3, #88]	; 0x58
 8001cf4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001cf6:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8001cfa:	9300      	str	r3, [sp, #0]
 8001cfc:	9b00      	ldr	r3, [sp, #0]
}
 8001cfe:	e7e3      	b.n	8001cc8 <HAL_PCD_MspInit+0x18>
 8001d00:	40006800 	.word	0x40006800
 8001d04:	40021000 	.word	0x40021000

08001d08 <I2Cx_Error>:
  * @param  i2c_handler : I2C handler
  * @param  Addr: I2C Address
  * @retval None
  */
static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
{
 8001d08:	b508      	push	{r3, lr}
  /* De-initialize the I2C communication bus */
  HAL_I2C_DeInit(i2c_handler);
 8001d0a:	f006 f8ab 	bl	8007e64 <HAL_I2C_DeInit>
}
 8001d0e:	bd08      	pop	{r3, pc}

08001d10 <I2Cx_WriteMultiple>:
{
 8001d10:	b570      	push	{r4, r5, r6, lr}
 8001d12:	b084      	sub	sp, #16
 8001d14:	4605      	mov	r5, r0
 8001d16:	460c      	mov	r4, r1
  status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8001d18:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001d1c:	9102      	str	r1, [sp, #8]
 8001d1e:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8001d22:	9101      	str	r1, [sp, #4]
 8001d24:	9908      	ldr	r1, [sp, #32]
 8001d26:	9100      	str	r1, [sp, #0]
 8001d28:	4621      	mov	r1, r4
 8001d2a:	f006 f8b4 	bl	8007e96 <HAL_I2C_Mem_Write>
  if (status != HAL_OK)
 8001d2e:	4606      	mov	r6, r0
 8001d30:	b910      	cbnz	r0, 8001d38 <I2Cx_WriteMultiple+0x28>
}
 8001d32:	4630      	mov	r0, r6
 8001d34:	b004      	add	sp, #16
 8001d36:	bd70      	pop	{r4, r5, r6, pc}
    I2Cx_Error(i2c_handler, Addr);
 8001d38:	4621      	mov	r1, r4
 8001d3a:	4628      	mov	r0, r5
 8001d3c:	f7ff ffe4 	bl	8001d08 <I2Cx_Error>
 8001d40:	e7f7      	b.n	8001d32 <I2Cx_WriteMultiple+0x22>

08001d42 <I2Cx_ReadMultiple>:
{
 8001d42:	b570      	push	{r4, r5, r6, lr}
 8001d44:	b084      	sub	sp, #16
 8001d46:	4605      	mov	r5, r0
 8001d48:	460c      	mov	r4, r1
  status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 8001d4a:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8001d4e:	9102      	str	r1, [sp, #8]
 8001d50:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
 8001d54:	9101      	str	r1, [sp, #4]
 8001d56:	9908      	ldr	r1, [sp, #32]
 8001d58:	9100      	str	r1, [sp, #0]
 8001d5a:	4621      	mov	r1, r4
 8001d5c:	f006 f970 	bl	8008040 <HAL_I2C_Mem_Read>
  if (status != HAL_OK)
 8001d60:	4606      	mov	r6, r0
 8001d62:	b910      	cbnz	r0, 8001d6a <I2Cx_ReadMultiple+0x28>
}
 8001d64:	4630      	mov	r0, r6
 8001d66:	b004      	add	sp, #16
 8001d68:	bd70      	pop	{r4, r5, r6, pc}
    I2Cx_Error(i2c_handler, Addr);
 8001d6a:	4621      	mov	r1, r4
 8001d6c:	4628      	mov	r0, r5
 8001d6e:	f7ff ffcb 	bl	8001d08 <I2Cx_Error>
 8001d72:	e7f7      	b.n	8001d64 <I2Cx_ReadMultiple+0x22>

08001d74 <BSP_LED_Init>:
{
 8001d74:	b570      	push	{r4, r5, r6, lr}
 8001d76:	b088      	sub	sp, #32
  LEDx_GPIO_CLK_ENABLE(Led);
 8001d78:	4604      	mov	r4, r0
 8001d7a:	bb10      	cbnz	r0, 8001dc2 <BSP_LED_Init+0x4e>
 8001d7c:	4b1e      	ldr	r3, [pc, #120]	; (8001df8 <BSP_LED_Init+0x84>)
 8001d7e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001d80:	f042 0204 	orr.w	r2, r2, #4
 8001d84:	64da      	str	r2, [r3, #76]	; 0x4c
 8001d86:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001d88:	f003 0304 	and.w	r3, r3, #4
 8001d8c:	9300      	str	r3, [sp, #0]
 8001d8e:	9b00      	ldr	r3, [sp, #0]
  gpio_init_structure.Pin   = GPIO_PIN[Led];
 8001d90:	4b1a      	ldr	r3, [pc, #104]	; (8001dfc <BSP_LED_Init+0x88>)
 8001d92:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8001d96:	9303      	str	r3, [sp, #12]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 8001d98:	2301      	movs	r3, #1
 8001d9a:	9304      	str	r3, [sp, #16]
  gpio_init_structure.Pull  = GPIO_NOPULL;
 8001d9c:	2600      	movs	r6, #0
 8001d9e:	9605      	str	r6, [sp, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8001da0:	2302      	movs	r3, #2
 8001da2:	9306      	str	r3, [sp, #24]
  HAL_GPIO_Init(GPIO_PORT[Led], &gpio_init_structure);
 8001da4:	4d16      	ldr	r5, [pc, #88]	; (8001e00 <BSP_LED_Init+0x8c>)
 8001da6:	a903      	add	r1, sp, #12
 8001da8:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8001dac:	f005 fd1c 	bl	80077e8 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(GPIO_PORT[Led], gpio_init_structure.Pin, GPIO_PIN_RESET);
 8001db0:	4632      	mov	r2, r6
 8001db2:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 8001db6:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8001dba:	f005 fe74 	bl	8007aa6 <HAL_GPIO_WritePin>
}
 8001dbe:	b008      	add	sp, #32
 8001dc0:	bd70      	pop	{r4, r5, r6, pc}
  LEDx_GPIO_CLK_ENABLE(Led);
 8001dc2:	2801      	cmp	r0, #1
 8001dc4:	d00c      	beq.n	8001de0 <BSP_LED_Init+0x6c>
 8001dc6:	2802      	cmp	r0, #2
 8001dc8:	d1e2      	bne.n	8001d90 <BSP_LED_Init+0x1c>
 8001dca:	4b0b      	ldr	r3, [pc, #44]	; (8001df8 <BSP_LED_Init+0x84>)
 8001dcc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001dce:	f042 0202 	orr.w	r2, r2, #2
 8001dd2:	64da      	str	r2, [r3, #76]	; 0x4c
 8001dd4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001dd6:	f003 0302 	and.w	r3, r3, #2
 8001dda:	9302      	str	r3, [sp, #8]
 8001ddc:	9b02      	ldr	r3, [sp, #8]
 8001dde:	e7d7      	b.n	8001d90 <BSP_LED_Init+0x1c>
 8001de0:	4b05      	ldr	r3, [pc, #20]	; (8001df8 <BSP_LED_Init+0x84>)
 8001de2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001de4:	f042 0202 	orr.w	r2, r2, #2
 8001de8:	64da      	str	r2, [r3, #76]	; 0x4c
 8001dea:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001dec:	f003 0302 	and.w	r3, r3, #2
 8001df0:	9301      	str	r3, [sp, #4]
 8001df2:	9b01      	ldr	r3, [sp, #4]
 8001df4:	e7cc      	b.n	8001d90 <BSP_LED_Init+0x1c>
 8001df6:	bf00      	nop
 8001df8:	40021000 	.word	0x40021000
 8001dfc:	0802b298 	.word	0x0802b298
 8001e00:	20000000 	.word	0x20000000

08001e04 <SENSOR_IO_Init>:
  * @brief  Initializes Sensors low level.
  * @retval None
  */
void SENSOR_IO_Init(void)
{
  __NOP();
 8001e04:	bf00      	nop
}
 8001e06:	4770      	bx	lr

08001e08 <SENSOR_IO_Write>:
  * @param  Reg: Reg address
  * @param  Value: Data to be written
  * @retval None
  */
void SENSOR_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 8001e08:	b500      	push	{lr}
 8001e0a:	b085      	sub	sp, #20
 8001e0c:	f88d 200f 	strb.w	r2, [sp, #15]
  I2Cx_WriteMultiple(&hi2c1, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t *)&Value, 1);
 8001e10:	2301      	movs	r3, #1
 8001e12:	9301      	str	r3, [sp, #4]
 8001e14:	f10d 020f 	add.w	r2, sp, #15
 8001e18:	9200      	str	r2, [sp, #0]
 8001e1a:	460a      	mov	r2, r1
 8001e1c:	4601      	mov	r1, r0
 8001e1e:	4803      	ldr	r0, [pc, #12]	; (8001e2c <SENSOR_IO_Write+0x24>)
 8001e20:	f7ff ff76 	bl	8001d10 <I2Cx_WriteMultiple>
}
 8001e24:	b005      	add	sp, #20
 8001e26:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e2a:	bf00      	nop
 8001e2c:	20000988 	.word	0x20000988

08001e30 <SENSOR_IO_Read>:
  * @param  Addr: I2C address
  * @param  Reg: Reg address
  * @retval Data to be read
  */
uint8_t SENSOR_IO_Read(uint8_t Addr, uint8_t Reg)
{
 8001e30:	b500      	push	{lr}
 8001e32:	b085      	sub	sp, #20
 8001e34:	460a      	mov	r2, r1
  uint8_t read_value = 0;
 8001e36:	2300      	movs	r3, #0
 8001e38:	f88d 300f 	strb.w	r3, [sp, #15]

  I2Cx_ReadMultiple(&hi2c1, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t *)&read_value, 1);
 8001e3c:	2301      	movs	r3, #1
 8001e3e:	9301      	str	r3, [sp, #4]
 8001e40:	f10d 010f 	add.w	r1, sp, #15
 8001e44:	9100      	str	r1, [sp, #0]
 8001e46:	4601      	mov	r1, r0
 8001e48:	4803      	ldr	r0, [pc, #12]	; (8001e58 <SENSOR_IO_Read+0x28>)
 8001e4a:	f7ff ff7a 	bl	8001d42 <I2Cx_ReadMultiple>

  return read_value;
}
 8001e4e:	f89d 000f 	ldrb.w	r0, [sp, #15]
 8001e52:	b005      	add	sp, #20
 8001e54:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e58:	20000988 	.word	0x20000988

08001e5c <SENSOR_IO_ReadMultiple>:
  * @param  Buffer: Pointer to data buffer
  * @param  Length: Length of the data
  * @retval HAL status
  */
uint16_t SENSOR_IO_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t *Buffer, uint16_t Length)
{
 8001e5c:	b500      	push	{lr}
 8001e5e:	b083      	sub	sp, #12
  return I2Cx_ReadMultiple(&hi2c1, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, Buffer, Length);
 8001e60:	9301      	str	r3, [sp, #4]
 8001e62:	9200      	str	r2, [sp, #0]
 8001e64:	2301      	movs	r3, #1
 8001e66:	460a      	mov	r2, r1
 8001e68:	4601      	mov	r1, r0
 8001e6a:	4803      	ldr	r0, [pc, #12]	; (8001e78 <SENSOR_IO_ReadMultiple+0x1c>)
 8001e6c:	f7ff ff69 	bl	8001d42 <I2Cx_ReadMultiple>
}
 8001e70:	b280      	uxth	r0, r0
 8001e72:	b003      	add	sp, #12
 8001e74:	f85d fb04 	ldr.w	pc, [sp], #4
 8001e78:	20000988 	.word	0x20000988

08001e7c <BSP_HSENSOR_Init>:
/**
  * @brief  Initializes peripherals used by the I2C Humidity Sensor driver.
  * @retval HSENSOR status
  */
uint32_t BSP_HSENSOR_Init(void)
{
 8001e7c:	b508      	push	{r3, lr}
  uint32_t ret;

  if (HTS221_H_Drv.ReadID(HTS221_I2C_ADDRESS) != HTS221_WHO_AM_I_VAL)
 8001e7e:	4b08      	ldr	r3, [pc, #32]	; (8001ea0 <BSP_HSENSOR_Init+0x24>)
 8001e80:	685b      	ldr	r3, [r3, #4]
 8001e82:	20be      	movs	r0, #190	; 0xbe
 8001e84:	4798      	blx	r3
 8001e86:	28bc      	cmp	r0, #188	; 0xbc
 8001e88:	d001      	beq.n	8001e8e <BSP_HSENSOR_Init+0x12>
  {
    ret = HSENSOR_ERROR;
 8001e8a:	2001      	movs	r0, #1
    Hsensor_drv->Init(HTS221_I2C_ADDRESS);
    ret = HSENSOR_OK;
  }

  return ret;
}
 8001e8c:	bd08      	pop	{r3, pc}
    Hsensor_drv = &HTS221_H_Drv;
 8001e8e:	4b04      	ldr	r3, [pc, #16]	; (8001ea0 <BSP_HSENSOR_Init+0x24>)
 8001e90:	4a04      	ldr	r2, [pc, #16]	; (8001ea4 <BSP_HSENSOR_Init+0x28>)
 8001e92:	6013      	str	r3, [r2, #0]
    Hsensor_drv->Init(HTS221_I2C_ADDRESS);
 8001e94:	681b      	ldr	r3, [r3, #0]
 8001e96:	20be      	movs	r0, #190	; 0xbe
 8001e98:	4798      	blx	r3
    ret = HSENSOR_OK;
 8001e9a:	2000      	movs	r0, #0
 8001e9c:	e7f6      	b.n	8001e8c <BSP_HSENSOR_Init+0x10>
 8001e9e:	bf00      	nop
 8001ea0:	2000000c 	.word	0x2000000c
 8001ea4:	20001078 	.word	0x20001078

08001ea8 <BSP_HSENSOR_ReadHumidity>:
/**
  * @brief  Read Humidity register of HTS221.
  * @retval HTS221 measured humidity value.
  */
float BSP_HSENSOR_ReadHumidity(void)
{
 8001ea8:	b508      	push	{r3, lr}
  return Hsensor_drv->ReadHumidity(HTS221_I2C_ADDRESS);
 8001eaa:	4b03      	ldr	r3, [pc, #12]	; (8001eb8 <BSP_HSENSOR_ReadHumidity+0x10>)
 8001eac:	681b      	ldr	r3, [r3, #0]
 8001eae:	689b      	ldr	r3, [r3, #8]
 8001eb0:	20be      	movs	r0, #190	; 0xbe
 8001eb2:	4798      	blx	r3
}
 8001eb4:	bd08      	pop	{r3, pc}
 8001eb6:	bf00      	nop
 8001eb8:	20001078 	.word	0x20001078

08001ebc <BSP_PSENSOR_Init>:
/**
  * @brief  Initializes peripherals used by the I2C Pressure Sensor driver.
  * @retval PSENSOR status
  */
uint32_t BSP_PSENSOR_Init(void)
{
 8001ebc:	b508      	push	{r3, lr}
  uint32_t ret;

  if (LPS22HB_P_Drv.ReadID(LPS22HB_I2C_ADDRESS) != LPS22HB_WHO_AM_I_VAL)
 8001ebe:	4b08      	ldr	r3, [pc, #32]	; (8001ee0 <BSP_PSENSOR_Init+0x24>)
 8001ec0:	685b      	ldr	r3, [r3, #4]
 8001ec2:	20ba      	movs	r0, #186	; 0xba
 8001ec4:	4798      	blx	r3
 8001ec6:	28b1      	cmp	r0, #177	; 0xb1
 8001ec8:	d001      	beq.n	8001ece <BSP_PSENSOR_Init+0x12>
  {
    ret = PSENSOR_ERROR;
 8001eca:	2001      	movs	r0, #1
    Psensor_drv->Init(LPS22HB_I2C_ADDRESS);
    ret = PSENSOR_OK;
  }

  return ret;
}
 8001ecc:	bd08      	pop	{r3, pc}
    Psensor_drv = &LPS22HB_P_Drv;
 8001ece:	4b04      	ldr	r3, [pc, #16]	; (8001ee0 <BSP_PSENSOR_Init+0x24>)
 8001ed0:	4a04      	ldr	r2, [pc, #16]	; (8001ee4 <BSP_PSENSOR_Init+0x28>)
 8001ed2:	6013      	str	r3, [r2, #0]
    Psensor_drv->Init(LPS22HB_I2C_ADDRESS);
 8001ed4:	681b      	ldr	r3, [r3, #0]
 8001ed6:	20ba      	movs	r0, #186	; 0xba
 8001ed8:	4798      	blx	r3
    ret = PSENSOR_OK;
 8001eda:	2000      	movs	r0, #0
 8001edc:	e7f6      	b.n	8001ecc <BSP_PSENSOR_Init+0x10>
 8001ede:	bf00      	nop
 8001ee0:	20000028 	.word	0x20000028
 8001ee4:	2000107c 	.word	0x2000107c

08001ee8 <BSP_PSENSOR_ReadPressure>:
/**
  * @brief  Read Pressure register of LPS22HB.
  * @retval LPS22HB measured pressure value.
  */
float BSP_PSENSOR_ReadPressure(void)
{
 8001ee8:	b508      	push	{r3, lr}
  return Psensor_drv->ReadPressure(LPS22HB_I2C_ADDRESS);
 8001eea:	4b03      	ldr	r3, [pc, #12]	; (8001ef8 <BSP_PSENSOR_ReadPressure+0x10>)
 8001eec:	681b      	ldr	r3, [r3, #0]
 8001eee:	689b      	ldr	r3, [r3, #8]
 8001ef0:	20ba      	movs	r0, #186	; 0xba
 8001ef2:	4798      	blx	r3
}
 8001ef4:	bd08      	pop	{r3, pc}
 8001ef6:	bf00      	nop
 8001ef8:	2000107c 	.word	0x2000107c

08001efc <BSP_TSENSOR_Init>:
/**
  * @brief  Initializes peripherals used by the I2C Temperature Sensor driver.
  * @retval TSENSOR status
  */
uint32_t BSP_TSENSOR_Init(void)
{
 8001efc:	b510      	push	{r4, lr}
  uint8_t ret = TSENSOR_ERROR;

#ifdef USE_LPS22HB_TEMP
  tsensor_drv = &LPS22HB_T_Drv;
#else  /* USE_HTS221_TEMP */
  tsensor_drv = &HTS221_T_Drv;
 8001efe:	4c06      	ldr	r4, [pc, #24]	; (8001f18 <BSP_TSENSOR_Init+0x1c>)
 8001f00:	4b06      	ldr	r3, [pc, #24]	; (8001f1c <BSP_TSENSOR_Init+0x20>)
 8001f02:	6023      	str	r3, [r4, #0]
#endif /* USE_LPS22HB_TEMP */

  /* Low level init */
  SENSOR_IO_Init();
 8001f04:	f7ff ff7e 	bl	8001e04 <SENSOR_IO_Init>

  /* TSENSOR Init */
  tsensor_drv->Init(TSENSOR_I2C_ADDRESS, NULL);
 8001f08:	6823      	ldr	r3, [r4, #0]
 8001f0a:	681b      	ldr	r3, [r3, #0]
 8001f0c:	2100      	movs	r1, #0
 8001f0e:	20be      	movs	r0, #190	; 0xbe
 8001f10:	4798      	blx	r3

  ret = TSENSOR_OK;

  return ret;
}
 8001f12:	2000      	movs	r0, #0
 8001f14:	bd10      	pop	{r4, pc}
 8001f16:	bf00      	nop
 8001f18:	20001080 	.word	0x20001080
 8001f1c:	20000018 	.word	0x20000018

08001f20 <BSP_TSENSOR_ReadTemp>:
/**
  * @brief  Read Temperature register of TS751.
  * @retval STTS751 measured temperature value.
  */
float BSP_TSENSOR_ReadTemp(void)
{
 8001f20:	b508      	push	{r3, lr}
  return tsensor_drv->ReadTemp(TSENSOR_I2C_ADDRESS);
 8001f22:	4b03      	ldr	r3, [pc, #12]	; (8001f30 <BSP_TSENSOR_ReadTemp+0x10>)
 8001f24:	681b      	ldr	r3, [r3, #0]
 8001f26:	68db      	ldr	r3, [r3, #12]
 8001f28:	20be      	movs	r0, #190	; 0xbe
 8001f2a:	4798      	blx	r3
}
 8001f2c:	bd08      	pop	{r3, pc}
 8001f2e:	bf00      	nop
 8001f30:	20001080 	.word	0x20001080

08001f34 <HTS221_H_Init>:
  */
/**
  * @brief  Set HTS221 humidity sensor Initialization.
  */
void HTS221_H_Init(uint16_t DeviceAddr)
{
 8001f34:	b510      	push	{r4, lr}
  uint8_t tmp;
  
  /* Read CTRL_REG1 */
  tmp = SENSOR_IO_Read(DeviceAddr, HTS221_CTRL_REG1);
 8001f36:	b2c4      	uxtb	r4, r0
 8001f38:	2120      	movs	r1, #32
 8001f3a:	4620      	mov	r0, r4
 8001f3c:	f7ff ff78 	bl	8001e30 <SENSOR_IO_Read>
  /* Enable BDU */
  tmp &= ~HTS221_BDU_MASK;
  tmp |= (1 << HTS221_BDU_BIT);
  
  /* Set default ODR */
  tmp &= ~HTS221_ODR_MASK;
 8001f40:	f000 02f8 	and.w	r2, r0, #248	; 0xf8
  
  /* Activate the device */
  tmp |= HTS221_PD_MASK;
  
  /* Apply settings to CTRL_REG1 */
  SENSOR_IO_Write(DeviceAddr, HTS221_CTRL_REG1, tmp);
 8001f44:	f042 0285 	orr.w	r2, r2, #133	; 0x85
 8001f48:	2120      	movs	r1, #32
 8001f4a:	4620      	mov	r0, r4
 8001f4c:	f7ff ff5c 	bl	8001e08 <SENSOR_IO_Write>
}
 8001f50:	bd10      	pop	{r4, pc}

08001f52 <HTS221_T_Init>:
  * @param  DeviceAddr: I2C device address
  * @param  InitStruct: pointer to a TSENSOR_InitTypeDef structure 
  *         that contains the configuration setting for the HTS221.
  */
void HTS221_T_Init(uint16_t DeviceAddr, TSENSOR_InitTypeDef *pInitStruct)
{  
 8001f52:	b510      	push	{r4, lr}
  uint8_t tmp;
  
  /* Read CTRL_REG1 */
  tmp = SENSOR_IO_Read(DeviceAddr, HTS221_CTRL_REG1);
 8001f54:	b2c4      	uxtb	r4, r0
 8001f56:	2120      	movs	r1, #32
 8001f58:	4620      	mov	r0, r4
 8001f5a:	f7ff ff69 	bl	8001e30 <SENSOR_IO_Read>
  /* Enable BDU */
  tmp &= ~HTS221_BDU_MASK;
  tmp |= (1 << HTS221_BDU_BIT);
  
  /* Set default ODR */
  tmp &= ~HTS221_ODR_MASK;
 8001f5e:	f000 02f8 	and.w	r2, r0, #248	; 0xf8
  
  /* Activate the device */
  tmp |= HTS221_PD_MASK;
  
  /* Apply settings to CTRL_REG1 */
  SENSOR_IO_Write(DeviceAddr, HTS221_CTRL_REG1, tmp);
 8001f62:	f042 0285 	orr.w	r2, r2, #133	; 0x85
 8001f66:	2120      	movs	r1, #32
 8001f68:	4620      	mov	r0, r4
 8001f6a:	f7ff ff4d 	bl	8001e08 <SENSOR_IO_Write>
}
 8001f6e:	bd10      	pop	{r4, pc}

08001f70 <HTS221_H_ReadID>:
{  
 8001f70:	b510      	push	{r4, lr}
 8001f72:	4604      	mov	r4, r0
  SENSOR_IO_Init(); 
 8001f74:	f7ff ff46 	bl	8001e04 <SENSOR_IO_Init>
  ctrl = SENSOR_IO_Read(DeviceAddr, HTS221_WHO_AM_I_REG);
 8001f78:	210f      	movs	r1, #15
 8001f7a:	b2e0      	uxtb	r0, r4
 8001f7c:	f7ff ff58 	bl	8001e30 <SENSOR_IO_Read>
}
 8001f80:	bd10      	pop	{r4, pc}
	...

08001f84 <HTS221_H_ReadHumidity>:
{
 8001f84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001f88:	b083      	sub	sp, #12
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_H0_RH_X2 | 0x80), buffer, 2);
 8001f8a:	fa5f f980 	uxtb.w	r9, r0
 8001f8e:	2302      	movs	r3, #2
 8001f90:	aa01      	add	r2, sp, #4
 8001f92:	21b0      	movs	r1, #176	; 0xb0
 8001f94:	4648      	mov	r0, r9
 8001f96:	f7ff ff61 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H0_rh = buffer[0] >> 1;
 8001f9a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001f9e:	085f      	lsrs	r7, r3, #1
  H1_rh = buffer[1] >> 1;
 8001fa0:	f89d 6005 	ldrb.w	r6, [sp, #5]
 8001fa4:	0876      	lsrs	r6, r6, #1
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_H0_T0_OUT_L | 0x80), buffer, 2);
 8001fa6:	2302      	movs	r3, #2
 8001fa8:	aa01      	add	r2, sp, #4
 8001faa:	21b6      	movs	r1, #182	; 0xb6
 8001fac:	4648      	mov	r0, r9
 8001fae:	f7ff ff55 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H0_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8001fb2:	f89d 5005 	ldrb.w	r5, [sp, #5]
 8001fb6:	022d      	lsls	r5, r5, #8
 8001fb8:	b22d      	sxth	r5, r5
 8001fba:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001fbe:	431d      	orrs	r5, r3
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_H1_T0_OUT_L | 0x80), buffer, 2);
 8001fc0:	2302      	movs	r3, #2
 8001fc2:	aa01      	add	r2, sp, #4
 8001fc4:	21ba      	movs	r1, #186	; 0xba
 8001fc6:	4648      	mov	r0, r9
 8001fc8:	f7ff ff48 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H1_T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8001fcc:	f89d 4005 	ldrb.w	r4, [sp, #5]
 8001fd0:	0224      	lsls	r4, r4, #8
 8001fd2:	b224      	sxth	r4, r4
 8001fd4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8001fd8:	431c      	orrs	r4, r3
  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_HR_OUT_L_REG | 0x80), buffer, 2);
 8001fda:	2302      	movs	r3, #2
 8001fdc:	aa01      	add	r2, sp, #4
 8001fde:	21a8      	movs	r1, #168	; 0xa8
 8001fe0:	4648      	mov	r0, r9
 8001fe2:	f7ff ff3b 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  H_T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 8001fe6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8001fea:	021b      	lsls	r3, r3, #8
 8001fec:	b21b      	sxth	r3, r3
 8001fee:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8001ff2:	4313      	orrs	r3, r2
  tmp_f = (float)(H_T_out - H0_T0_out) * (float)(H1_rh - H0_rh) / (float)(H1_T0_out - H0_T0_out)  +  H0_rh;
 8001ff4:	1b5b      	subs	r3, r3, r5
 8001ff6:	ee07 3a90 	vmov	s15, r3
 8001ffa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8001ffe:	1bf6      	subs	r6, r6, r7
 8002000:	ee07 6a10 	vmov	s14, r6
 8002004:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002008:	ee67 7a87 	vmul.f32	s15, s15, s14
 800200c:	1b64      	subs	r4, r4, r5
 800200e:	ee07 4a10 	vmov	s14, r4
 8002012:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002016:	ee87 0a87 	vdiv.f32	s0, s15, s14
 800201a:	ee07 7a90 	vmov	s15, r7
 800201e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8002022:	ee70 7a27 	vadd.f32	s15, s0, s15
  tmp_f *= 10.0f;
 8002026:	eeb2 7a04 	vmov.f32	s14, #36	; 0x41200000  10.0
 800202a:	ee67 7a87 	vmul.f32	s15, s15, s14
        : ( tmp_f <    0.0f ) ?    0.0f
 800202e:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 8002060 <HTS221_H_ReadHumidity+0xdc>
 8002032:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002036:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800203a:	dc07      	bgt.n	800204c <HTS221_H_ReadHumidity+0xc8>
        : tmp_f;
 800203c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8002040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002044:	d504      	bpl.n	8002050 <HTS221_H_ReadHumidity+0xcc>
 8002046:	eddf 7a07 	vldr	s15, [pc, #28]	; 8002064 <HTS221_H_ReadHumidity+0xe0>
 800204a:	e001      	b.n	8002050 <HTS221_H_ReadHumidity+0xcc>
        : ( tmp_f <    0.0f ) ?    0.0f
 800204c:	eddf 7a04 	vldr	s15, [pc, #16]	; 8002060 <HTS221_H_ReadHumidity+0xdc>
}
 8002050:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8002054:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8002058:	b003      	add	sp, #12
 800205a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800205e:	bf00      	nop
 8002060:	447a0000 	.word	0x447a0000
 8002064:	00000000 	.word	0x00000000

08002068 <HTS221_T_ReadTemp>:
  * @brief  Read temperature value of HTS221
  * @param  DeviceAddr: I2C device address
  * @retval temperature value
  */
float HTS221_T_ReadTemp(uint16_t DeviceAddr)
{
 8002068:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800206c:	b082      	sub	sp, #8
  int16_t T0_out, T1_out, T_out, T0_degC_x8_u16, T1_degC_x8_u16;
  int16_t T0_degC, T1_degC;
  uint8_t buffer[4], tmp;
  float tmp_f;

  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_T0_DEGC_X8 | 0x80), buffer, 2);
 800206e:	fa5f f880 	uxtb.w	r8, r0
 8002072:	2302      	movs	r3, #2
 8002074:	aa01      	add	r2, sp, #4
 8002076:	21b2      	movs	r1, #178	; 0xb2
 8002078:	4640      	mov	r0, r8
 800207a:	f7ff feef 	bl	8001e5c <SENSOR_IO_ReadMultiple>
  tmp = SENSOR_IO_Read(DeviceAddr, HTS221_T0_T1_DEGC_H2);
 800207e:	2135      	movs	r1, #53	; 0x35
 8002080:	4640      	mov	r0, r8
 8002082:	f7ff fed5 	bl	8001e30 <SENSOR_IO_Read>

  T0_degC_x8_u16 = (((uint16_t)(tmp & 0x03)) << 8) | ((uint16_t)buffer[0]);
 8002086:	0207      	lsls	r7, r0, #8
 8002088:	f407 7740 	and.w	r7, r7, #768	; 0x300
 800208c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8002090:	431f      	orrs	r7, r3
  T1_degC_x8_u16 = (((uint16_t)(tmp & 0x0C)) << 6) | ((uint16_t)buffer[1]);
 8002092:	0184      	lsls	r4, r0, #6
 8002094:	f404 7440 	and.w	r4, r4, #768	; 0x300
 8002098:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800209c:	431c      	orrs	r4, r3
  T0_degC = T0_degC_x8_u16 >> 3;
 800209e:	08ff      	lsrs	r7, r7, #3
  T1_degC = T1_degC_x8_u16 >> 3;
 80020a0:	08e4      	lsrs	r4, r4, #3

  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_T0_OUT_L | 0x80), buffer, 4);
 80020a2:	2304      	movs	r3, #4
 80020a4:	eb0d 0203 	add.w	r2, sp, r3
 80020a8:	21bc      	movs	r1, #188	; 0xbc
 80020aa:	4640      	mov	r0, r8
 80020ac:	f7ff fed6 	bl	8001e5c <SENSOR_IO_ReadMultiple>

  T0_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 80020b0:	f89d 6005 	ldrb.w	r6, [sp, #5]
 80020b4:	0236      	lsls	r6, r6, #8
 80020b6:	b236      	sxth	r6, r6
 80020b8:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80020bc:	431e      	orrs	r6, r3
  T1_out = (((uint16_t)buffer[3]) << 8) | (uint16_t)buffer[2];
 80020be:	f89d 5007 	ldrb.w	r5, [sp, #7]
 80020c2:	022d      	lsls	r5, r5, #8
 80020c4:	b22d      	sxth	r5, r5
 80020c6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80020ca:	431d      	orrs	r5, r3

  SENSOR_IO_ReadMultiple(DeviceAddr, (HTS221_TEMP_OUT_L_REG | 0x80), buffer, 2);
 80020cc:	2302      	movs	r3, #2
 80020ce:	aa01      	add	r2, sp, #4
 80020d0:	21aa      	movs	r1, #170	; 0xaa
 80020d2:	4640      	mov	r0, r8
 80020d4:	f7ff fec2 	bl	8001e5c <SENSOR_IO_ReadMultiple>

  T_out = (((uint16_t)buffer[1]) << 8) | (uint16_t)buffer[0];
 80020d8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80020dc:	021b      	lsls	r3, r3, #8
 80020de:	b21b      	sxth	r3, r3
 80020e0:	f89d 2004 	ldrb.w	r2, [sp, #4]
 80020e4:	4313      	orrs	r3, r2

  tmp_f = (float)(T_out - T0_out) * (float)(T1_degC - T0_degC) / (float)(T1_out - T0_out)  +  T0_degC;
 80020e6:	1b9b      	subs	r3, r3, r6
 80020e8:	ee07 3a90 	vmov	s15, r3
 80020ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80020f0:	1be4      	subs	r4, r4, r7
 80020f2:	ee07 4a10 	vmov	s14, r4
 80020f6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80020fa:	ee67 7a87 	vmul.f32	s15, s15, s14
 80020fe:	1bad      	subs	r5, r5, r6
 8002100:	ee07 5a10 	vmov	s14, r5
 8002104:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002108:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800210c:	ee07 7a90 	vmov	s15, r7
 8002110:	eeb8 0ae7 	vcvt.f32.s32	s0, s15

  return tmp_f;
}
 8002114:	ee36 0a80 	vadd.f32	s0, s13, s0
 8002118:	b002      	add	sp, #8
 800211a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08002120 <LPS22HB_P_ReadPressure>:
/**
  * @brief  Read pressure value of LPS22HB
  * @retval pressure value
  */
float LPS22HB_P_ReadPressure(uint16_t DeviceAddr)
{
 8002120:	b530      	push	{r4, r5, lr}
 8002122:	b083      	sub	sp, #12
 8002124:	4605      	mov	r5, r0
  int32_t raw_press;
  uint8_t buffer[3];
  uint32_t tmp = 0;
  uint8_t i;

  for(i = 0; i < 3; i++)
 8002126:	2400      	movs	r4, #0
 8002128:	e00c      	b.n	8002144 <LPS22HB_P_ReadPressure+0x24>
  {
    buffer[i] = SENSOR_IO_Read(DeviceAddr, (LPS22HB_PRESS_OUT_XL_REG + i));
 800212a:	f104 0128 	add.w	r1, r4, #40	; 0x28
 800212e:	b2c9      	uxtb	r1, r1
 8002130:	b2e8      	uxtb	r0, r5
 8002132:	f7ff fe7d 	bl	8001e30 <SENSOR_IO_Read>
 8002136:	f104 0308 	add.w	r3, r4, #8
 800213a:	446b      	add	r3, sp
 800213c:	f803 0c04 	strb.w	r0, [r3, #-4]
  for(i = 0; i < 3; i++)
 8002140:	3401      	adds	r4, #1
 8002142:	b2e4      	uxtb	r4, r4
 8002144:	2c02      	cmp	r4, #2
 8002146:	d9f0      	bls.n	800212a <LPS22HB_P_ReadPressure+0xa>
  }

  /* Build the raw data */
  for(i = 0; i < 3; i++)
 8002148:	2300      	movs	r3, #0
  uint32_t tmp = 0;
 800214a:	461a      	mov	r2, r3
 800214c:	e009      	b.n	8002162 <LPS22HB_P_ReadPressure+0x42>
    tmp |= (((uint32_t)buffer[i]) << (8 * i));
 800214e:	f103 0108 	add.w	r1, r3, #8
 8002152:	4469      	add	r1, sp
 8002154:	f811 1c04 	ldrb.w	r1, [r1, #-4]
 8002158:	00d8      	lsls	r0, r3, #3
 800215a:	4081      	lsls	r1, r0
 800215c:	430a      	orrs	r2, r1
  for(i = 0; i < 3; i++)
 800215e:	3301      	adds	r3, #1
 8002160:	b2db      	uxtb	r3, r3
 8002162:	2b02      	cmp	r3, #2
 8002164:	d9f3      	bls.n	800214e <LPS22HB_P_ReadPressure+0x2e>

  /* convert the 2's complement 24 bit to 2's complement 32 bit */
  if(tmp & 0x00800000)
 8002166:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
 800216a:	d001      	beq.n	8002170 <LPS22HB_P_ReadPressure+0x50>
    tmp |= 0xFF000000;
 800216c:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000

  raw_press = ((int32_t)tmp);

  raw_press = (raw_press * 100) / 4096;
 8002170:	2364      	movs	r3, #100	; 0x64
 8002172:	fb03 f202 	mul.w	r2, r3, r2
 8002176:	2a00      	cmp	r2, #0
 8002178:	db0a      	blt.n	8002190 <LPS22HB_P_ReadPressure+0x70>
 800217a:	1312      	asrs	r2, r2, #12

  return (float)((float)raw_press / 100.0f);
 800217c:	ee07 2a90 	vmov	s15, r2
 8002180:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
}
 8002184:	eddf 7a04 	vldr	s15, [pc, #16]	; 8002198 <LPS22HB_P_ReadPressure+0x78>
 8002188:	ee80 0a27 	vdiv.f32	s0, s0, s15
 800218c:	b003      	add	sp, #12
 800218e:	bd30      	pop	{r4, r5, pc}
  raw_press = (raw_press * 100) / 4096;
 8002190:	f602 72ff 	addw	r2, r2, #4095	; 0xfff
 8002194:	e7f1      	b.n	800217a <LPS22HB_P_ReadPressure+0x5a>
 8002196:	bf00      	nop
 8002198:	42c80000 	.word	0x42c80000

0800219c <LPS22HB_Init>:
  * @brief  Set LPS22HB Initialization.
  * @param  DeviceAddr: I2C device address
  * @retval None
  */
static void LPS22HB_Init(uint16_t DeviceAddr)
{
 800219c:	b510      	push	{r4, lr}
  uint8_t tmp;

  /* Set Power mode */
  tmp = SENSOR_IO_Read(DeviceAddr, LPS22HB_RES_CONF_REG);
 800219e:	b2c4      	uxtb	r4, r0
 80021a0:	211a      	movs	r1, #26
 80021a2:	4620      	mov	r0, r4
 80021a4:	f7ff fe44 	bl	8001e30 <SENSOR_IO_Read>

  tmp &= ~LPS22HB_LCEN_MASK;
 80021a8:	f000 02fe 	and.w	r2, r0, #254	; 0xfe
  tmp |= (uint8_t)0x01; /* Set low current mode */

  SENSOR_IO_Write(DeviceAddr, LPS22HB_RES_CONF_REG, tmp);
 80021ac:	f042 0201 	orr.w	r2, r2, #1
 80021b0:	211a      	movs	r1, #26
 80021b2:	4620      	mov	r0, r4
 80021b4:	f7ff fe28 	bl	8001e08 <SENSOR_IO_Write>

  /* Read CTRL_REG1 */
  tmp = SENSOR_IO_Read(DeviceAddr, LPS22HB_CTRL_REG1);
 80021b8:	2110      	movs	r1, #16
 80021ba:	4620      	mov	r0, r4
 80021bc:	f7ff fe38 	bl	8001e30 <SENSOR_IO_Read>
  /* Set default ODR */
  tmp &= ~LPS22HB_ODR_MASK;
  tmp |= (uint8_t)0x30; /* Set ODR to 25Hz */

  /* Enable BDU */
  tmp &= ~LPS22HB_BDU_MASK;
 80021c0:	f000 028d 	and.w	r2, r0, #141	; 0x8d
  tmp |= ((uint8_t)0x02);

  /* Apply settings to CTRL_REG1 */
  SENSOR_IO_Write(DeviceAddr, LPS22HB_CTRL_REG1, tmp);
 80021c4:	f042 0232 	orr.w	r2, r2, #50	; 0x32
 80021c8:	2110      	movs	r1, #16
 80021ca:	4620      	mov	r0, r4
 80021cc:	f7ff fe1c 	bl	8001e08 <SENSOR_IO_Write>
}  
 80021d0:	bd10      	pop	{r4, pc}

080021d2 <LPS22HB_P_Init>:
{
 80021d2:	b508      	push	{r3, lr}
  LPS22HB_Init(DeviceAddr);
 80021d4:	f7ff ffe2 	bl	800219c <LPS22HB_Init>
}
 80021d8:	bd08      	pop	{r3, pc}

080021da <LPS22HB_P_ReadID>:
{  
 80021da:	b510      	push	{r4, lr}
 80021dc:	4604      	mov	r4, r0
  SENSOR_IO_Init();  
 80021de:	f7ff fe11 	bl	8001e04 <SENSOR_IO_Init>
  ctrl = SENSOR_IO_Read(DeviceAddr, LPS22HB_WHO_AM_I_REG);
 80021e2:	210f      	movs	r1, #15
 80021e4:	b2e0      	uxtb	r0, r4
 80021e6:	f7ff fe23 	bl	8001e30 <SENSOR_IO_Read>
}
 80021ea:	bd10      	pop	{r4, pc}

080021ec <atcma_init_at_func_ptrs>:
/* Functions Definition ------------------------------------------------------*/
void atcma_init_at_func_ptrs(atcustom_funcPtrs_t *funcPtrs)
{
#if defined(USE_MODEM_TYPE1SC)
  /* init function pointers with TYPE1SC functions */
  funcPtrs->f_init = ATCustom_TYPE1SC_init;
 80021ec:	4b0b      	ldr	r3, [pc, #44]	; (800221c <atcma_init_at_func_ptrs+0x30>)
 80021ee:	6043      	str	r3, [r0, #4]
  funcPtrs->f_checkEndOfMsgCallback = ATCustom_TYPE1SC_checkEndOfMsgCallback;
 80021f0:	4b0b      	ldr	r3, [pc, #44]	; (8002220 <atcma_init_at_func_ptrs+0x34>)
 80021f2:	6083      	str	r3, [r0, #8]
  funcPtrs->f_getCmd = ATCustom_TYPE1SC_getCmd;
 80021f4:	4b0b      	ldr	r3, [pc, #44]	; (8002224 <atcma_init_at_func_ptrs+0x38>)
 80021f6:	60c3      	str	r3, [r0, #12]
  funcPtrs->f_extractElement = ATCustom_TYPE1SC_extractElement;
 80021f8:	4b0b      	ldr	r3, [pc, #44]	; (8002228 <atcma_init_at_func_ptrs+0x3c>)
 80021fa:	6103      	str	r3, [r0, #16]
  funcPtrs->f_analyzeCmd = ATCustom_TYPE1SC_analyzeCmd;
 80021fc:	4b0b      	ldr	r3, [pc, #44]	; (800222c <atcma_init_at_func_ptrs+0x40>)
 80021fe:	6143      	str	r3, [r0, #20]
  funcPtrs->f_analyzeParam = ATCustom_TYPE1SC_analyzeParam;
 8002200:	4b0b      	ldr	r3, [pc, #44]	; (8002230 <atcma_init_at_func_ptrs+0x44>)
 8002202:	6183      	str	r3, [r0, #24]
  funcPtrs->f_terminateCmd = ATCustom_TYPE1SC_terminateCmd;
 8002204:	4b0b      	ldr	r3, [pc, #44]	; (8002234 <atcma_init_at_func_ptrs+0x48>)
 8002206:	61c3      	str	r3, [r0, #28]
  funcPtrs->f_get_rsp = ATCustom_TYPE1SC_get_rsp;
 8002208:	4b0b      	ldr	r3, [pc, #44]	; (8002238 <atcma_init_at_func_ptrs+0x4c>)
 800220a:	6203      	str	r3, [r0, #32]
  funcPtrs->f_get_urc = ATCustom_TYPE1SC_get_urc;
 800220c:	4b0b      	ldr	r3, [pc, #44]	; (800223c <atcma_init_at_func_ptrs+0x50>)
 800220e:	6243      	str	r3, [r0, #36]	; 0x24
  funcPtrs->f_get_error = ATCustom_TYPE1SC_get_error;
 8002210:	4b0b      	ldr	r3, [pc, #44]	; (8002240 <atcma_init_at_func_ptrs+0x54>)
 8002212:	6283      	str	r3, [r0, #40]	; 0x28
  funcPtrs->f_hw_event = ATCustom_TYPE1SC_hw_event;
 8002214:	4b0b      	ldr	r3, [pc, #44]	; (8002244 <atcma_init_at_func_ptrs+0x58>)
 8002216:	62c3      	str	r3, [r0, #44]	; 0x2c
#else
#error AT custom does not match with selected modem
#endif /* USE_MODEM_TYPE1SC */
}
 8002218:	4770      	bx	lr
 800221a:	bf00      	nop
 800221c:	080046ad 	.word	0x080046ad
 8002220:	080046d9 	.word	0x080046d9
 8002224:	08004739 	.word	0x08004739
 8002228:	08005759 	.word	0x08005759
 800222c:	080058c5 	.word	0x080058c5
 8002230:	08005d31 	.word	0x08005d31
 8002234:	08005dad 	.word	0x08005dad
 8002238:	08005ed1 	.word	0x08005ed1
 800223c:	08005ff9 	.word	0x08005ff9
 8002240:	0800606d 	.word	0x0800606d
 8002244:	080060d5 	.word	0x080060d5

08002248 <atcma_init_sysctrl_func_ptrs>:

void atcma_init_sysctrl_func_ptrs(sysctrl_funcPtrs_t *funcPtrs)
{
#if defined(USE_MODEM_TYPE1SC)
  /* init function pointers with TYPE1SC functions */
  funcPtrs->f_getDeviceDescriptor = SysCtrl_TYPE1SC_getDeviceDescriptor;
 8002248:	4b07      	ldr	r3, [pc, #28]	; (8002268 <atcma_init_sysctrl_func_ptrs+0x20>)
 800224a:	6043      	str	r3, [r0, #4]
  funcPtrs->f_open_channel =  SysCtrl_TYPE1SC_open_channel;
 800224c:	4b07      	ldr	r3, [pc, #28]	; (800226c <atcma_init_sysctrl_func_ptrs+0x24>)
 800224e:	6083      	str	r3, [r0, #8]
  funcPtrs->f_close_channel =  SysCtrl_TYPE1SC_close_channel;
 8002250:	4b07      	ldr	r3, [pc, #28]	; (8002270 <atcma_init_sysctrl_func_ptrs+0x28>)
 8002252:	60c3      	str	r3, [r0, #12]
  funcPtrs->f_power_on =  SysCtrl_TYPE1SC_power_on;
 8002254:	4b07      	ldr	r3, [pc, #28]	; (8002274 <atcma_init_sysctrl_func_ptrs+0x2c>)
 8002256:	6103      	str	r3, [r0, #16]
  funcPtrs->f_power_off = SysCtrl_TYPE1SC_power_off;
 8002258:	4b07      	ldr	r3, [pc, #28]	; (8002278 <atcma_init_sysctrl_func_ptrs+0x30>)
 800225a:	6143      	str	r3, [r0, #20]
  funcPtrs->f_reset_device = SysCtrl_TYPE1SC_reset;
 800225c:	4b07      	ldr	r3, [pc, #28]	; (800227c <atcma_init_sysctrl_func_ptrs+0x34>)
 800225e:	6183      	str	r3, [r0, #24]
  funcPtrs->f_sim_select = SysCtrl_TYPE1SC_sim_select;
 8002260:	4b07      	ldr	r3, [pc, #28]	; (8002280 <atcma_init_sysctrl_func_ptrs+0x38>)
 8002262:	61c3      	str	r3, [r0, #28]
#else
#error SysCtrl does not match with selected modem
#endif /* USE_MODEM_TYPE1SC */
}
 8002264:	4770      	bx	lr
 8002266:	bf00      	nop
 8002268:	080063b1 	.word	0x080063b1
 800226c:	08006b81 	.word	0x08006b81
 8002270:	080063e1 	.word	0x080063e1
 8002274:	0800652d 	.word	0x0800652d
 8002278:	08006609 	.word	0x08006609
 800227c:	080066dd 	.word	0x080066dd
 8002280:	08006761 	.word	0x08006761

08002284 <fCmdBuild_ATD_TYPE1SC>:
/* Private function prototypes -----------------------------------------------*/

/* Functions Definition ------------------------------------------------------*/
/* Build command functions ---------------------------------------------------*/
at_status_t fCmdBuild_ATD_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 8002284:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002288:	4606      	mov	r6, r0
 800228a:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATD_TYPE1SC()")
 800228c:	4c2a      	ldr	r4, [pc, #168]	; (8002338 <fCmdBuild_ATD_TYPE1SC+0xb4>)
 800228e:	4d2b      	ldr	r5, [pc, #172]	; (800233c <fCmdBuild_ATD_TYPE1SC+0xb8>)
 8002290:	f104 0e20 	add.w	lr, r4, #32
 8002294:	46a4      	mov	ip, r4
 8002296:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800229a:	6028      	str	r0, [r5, #0]
 800229c:	6069      	str	r1, [r5, #4]
 800229e:	60aa      	str	r2, [r5, #8]
 80022a0:	60eb      	str	r3, [r5, #12]
 80022a2:	4664      	mov	r4, ip
 80022a4:	3510      	adds	r5, #16
 80022a6:	45f4      	cmp	ip, lr
 80022a8:	d1f4      	bne.n	8002294 <fCmdBuild_ATD_TYPE1SC+0x10>
 80022aa:	cc07      	ldmia	r4!, {r0, r1, r2}
 80022ac:	6028      	str	r0, [r5, #0]
 80022ae:	6069      	str	r1, [r5, #4]
 80022b0:	60aa      	str	r2, [r5, #8]
 80022b2:	4c22      	ldr	r4, [pc, #136]	; (800233c <fCmdBuild_ATD_TYPE1SC+0xb8>)
 80022b4:	4620      	mov	r0, r4
 80022b6:	f01d f838 	bl	801f32a <crs_strlen>
 80022ba:	b283      	uxth	r3, r0
 80022bc:	4622      	mov	r2, r4
 80022be:	2104      	movs	r1, #4
 80022c0:	2002      	movs	r0, #2
 80022c2:	f01d f875 	bl	801f3b0 <traceIF_itmPrint>
 80022c6:	4620      	mov	r0, r4
 80022c8:	f01d f82f 	bl	801f32a <crs_strlen>
 80022cc:	b283      	uxth	r3, r0
 80022ce:	4622      	mov	r2, r4
 80022d0:	2104      	movs	r1, #4
 80022d2:	2002      	movs	r0, #2
 80022d4:	f01d f88e 	bl	801f3f4 <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 80022d8:	8933      	ldrh	r3, [r6, #8]
 80022da:	2b04      	cmp	r3, #4
 80022dc:	d002      	beq.n	80022e4 <fCmdBuild_ATD_TYPE1SC+0x60>
    PRINT_INFO("Activate PDN (user cid = %d, modem cid = %d)", (uint8_t)current_conf_id, modem_cid)

    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "*99***%d#", modem_cid);
  }
  return (retval);
}
 80022de:	2000      	movs	r0, #0
 80022e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 80022e4:	4638      	mov	r0, r7
 80022e6:	f00a fae5 	bl	800c8b4 <atcm_get_cid_current_SID>
 80022ea:	4680      	mov	r8, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 80022ec:	4601      	mov	r1, r0
 80022ee:	f107 000c 	add.w	r0, r7, #12
 80022f2:	f00b fb67 	bl	800d9c4 <atcm_get_affected_modem_cid>
 80022f6:	4605      	mov	r5, r0
    PRINT_INFO("Activate PDN (user cid = %d, modem cid = %d)", (uint8_t)current_conf_id, modem_cid)
 80022f8:	4603      	mov	r3, r0
 80022fa:	4642      	mov	r2, r8
 80022fc:	4910      	ldr	r1, [pc, #64]	; (8002340 <fCmdBuild_ATD_TYPE1SC+0xbc>)
 80022fe:	4620      	mov	r0, r4
 8002300:	f024 faa2 	bl	8026848 <sprintf>
 8002304:	4620      	mov	r0, r4
 8002306:	f01d f810 	bl	801f32a <crs_strlen>
 800230a:	b283      	uxth	r3, r0
 800230c:	4622      	mov	r2, r4
 800230e:	2101      	movs	r1, #1
 8002310:	2002      	movs	r0, #2
 8002312:	f01d f84d 	bl	801f3b0 <traceIF_itmPrint>
 8002316:	4620      	mov	r0, r4
 8002318:	f01d f807 	bl	801f32a <crs_strlen>
 800231c:	b283      	uxth	r3, r0
 800231e:	4622      	mov	r2, r4
 8002320:	2101      	movs	r1, #1
 8002322:	2002      	movs	r0, #2
 8002324:	f01d f866 	bl	801f3f4 <traceIF_uartPrint>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "*99***%d#", modem_cid);
 8002328:	462a      	mov	r2, r5
 800232a:	4906      	ldr	r1, [pc, #24]	; (8002344 <fCmdBuild_ATD_TYPE1SC+0xc0>)
 800232c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8002330:	f024 fa8a 	bl	8026848 <sprintf>
 8002334:	e7d3      	b.n	80022de <fCmdBuild_ATD_TYPE1SC+0x5a>
 8002336:	bf00      	nop
 8002338:	0802b2a4 	.word	0x0802b2a4
 800233c:	200048dc 	.word	0x200048dc
 8002340:	0802b2d0 	.word	0x0802b2d0
 8002344:	0802b308 	.word	0x0802b308

08002348 <fCmdBuild_SETCFG_TYPE1SC>:

at_status_t fCmdBuild_SETCFG_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 8002348:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800234a:	4606      	mov	r6, r0
 800234c:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_SETCFG_TYPE1SC()")
 800234e:	4c68      	ldr	r4, [pc, #416]	; (80024f0 <fCmdBuild_SETCFG_TYPE1SC+0x1a8>)
 8002350:	4d68      	ldr	r5, [pc, #416]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002352:	f104 0e20 	add.w	lr, r4, #32
 8002356:	46a4      	mov	ip, r4
 8002358:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800235c:	6028      	str	r0, [r5, #0]
 800235e:	6069      	str	r1, [r5, #4]
 8002360:	60aa      	str	r2, [r5, #8]
 8002362:	60eb      	str	r3, [r5, #12]
 8002364:	4664      	mov	r4, ip
 8002366:	3510      	adds	r5, #16
 8002368:	45f4      	cmp	ip, lr
 800236a:	d1f4      	bne.n	8002356 <fCmdBuild_SETCFG_TYPE1SC+0xe>
 800236c:	4663      	mov	r3, ip
 800236e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8002370:	6028      	str	r0, [r5, #0]
 8002372:	6069      	str	r1, [r5, #4]
 8002374:	60aa      	str	r2, [r5, #8]
 8002376:	881a      	ldrh	r2, [r3, #0]
 8002378:	789b      	ldrb	r3, [r3, #2]
 800237a:	81aa      	strh	r2, [r5, #12]
 800237c:	73ab      	strb	r3, [r5, #14]
 800237e:	4c5d      	ldr	r4, [pc, #372]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002380:	4620      	mov	r0, r4
 8002382:	f01c ffd2 	bl	801f32a <crs_strlen>
 8002386:	b283      	uxth	r3, r0
 8002388:	4622      	mov	r2, r4
 800238a:	2104      	movs	r1, #4
 800238c:	2002      	movs	r0, #2
 800238e:	f01d f80f 	bl	801f3b0 <traceIF_itmPrint>
 8002392:	4620      	mov	r0, r4
 8002394:	f01c ffc9 	bl	801f32a <crs_strlen>
 8002398:	b283      	uxth	r3, r0
 800239a:	4622      	mov	r2, r4
 800239c:	2104      	movs	r1, #4
 800239e:	2002      	movs	r0, #2
 80023a0:	f01d f828 	bl	801f3f4 <traceIF_uartPrint>

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80023a4:	8933      	ldrh	r3, [r6, #8]
 80023a6:	2b03      	cmp	r3, #3
 80023a8:	d002      	beq.n	80023b0 <fCmdBuild_SETCFG_TYPE1SC+0x68>
  at_status_t retval = ATSTATUS_OK;
 80023aa:	2400      	movs	r4, #0
      retval = ATSTATUS_ERROR;
    }
  }

  return (retval);
}
 80023ac:	4620      	mov	r0, r4
 80023ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (type1sc_shared.setcfg_function == SETGETCFG_SIM_POLICY)
 80023b0:	4b51      	ldr	r3, [pc, #324]	; (80024f8 <fCmdBuild_SETCFG_TYPE1SC+0x1b0>)
 80023b2:	f893 4042 	ldrb.w	r4, [r3, #66]	; 0x42
 80023b6:	2c01      	cmp	r4, #1
 80023b8:	d031      	beq.n	800241e <fCmdBuild_SETCFG_TYPE1SC+0xd6>
    else if (type1sc_shared.setcfg_function == SETGETCFG_HIFC_MODE)
 80023ba:	2c04      	cmp	r4, #4
 80023bc:	d066      	beq.n	800248c <fCmdBuild_SETCFG_TYPE1SC+0x144>
    else if (type1sc_shared.setcfg_function == SETGETCFG_BOOT_EVENT_TRUE)
 80023be:	2c07      	cmp	r4, #7
 80023c0:	d06f      	beq.n	80024a2 <fCmdBuild_SETCFG_TYPE1SC+0x15a>
    else if (type1sc_shared.setcfg_function == SETGETCFG_BOOT_EVENT_FALSE)
 80023c2:	2c08      	cmp	r4, #8
 80023c4:	f000 8081 	beq.w	80024ca <fCmdBuild_SETCFG_TYPE1SC+0x182>
      PRINT_ERR("setcfg value not implemented !")
 80023c8:	4d4c      	ldr	r5, [pc, #304]	; (80024fc <fCmdBuild_SETCFG_TYPE1SC+0x1b4>)
 80023ca:	4c4a      	ldr	r4, [pc, #296]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 80023cc:	f105 0720 	add.w	r7, r5, #32
 80023d0:	462e      	mov	r6, r5
 80023d2:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80023d4:	6020      	str	r0, [r4, #0]
 80023d6:	6061      	str	r1, [r4, #4]
 80023d8:	60a2      	str	r2, [r4, #8]
 80023da:	60e3      	str	r3, [r4, #12]
 80023dc:	4635      	mov	r5, r6
 80023de:	3410      	adds	r4, #16
 80023e0:	42be      	cmp	r6, r7
 80023e2:	d1f5      	bne.n	80023d0 <fCmdBuild_SETCFG_TYPE1SC+0x88>
 80023e4:	cd07      	ldmia	r5!, {r0, r1, r2}
 80023e6:	6020      	str	r0, [r4, #0]
 80023e8:	6061      	str	r1, [r4, #4]
 80023ea:	60a2      	str	r2, [r4, #8]
 80023ec:	882a      	ldrh	r2, [r5, #0]
 80023ee:	78ab      	ldrb	r3, [r5, #2]
 80023f0:	81a2      	strh	r2, [r4, #12]
 80023f2:	73a3      	strb	r3, [r4, #14]
 80023f4:	4c3f      	ldr	r4, [pc, #252]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 80023f6:	4620      	mov	r0, r4
 80023f8:	f01c ff97 	bl	801f32a <crs_strlen>
 80023fc:	b283      	uxth	r3, r0
 80023fe:	4622      	mov	r2, r4
 8002400:	2110      	movs	r1, #16
 8002402:	2002      	movs	r0, #2
 8002404:	f01c ffd4 	bl	801f3b0 <traceIF_itmPrint>
 8002408:	4620      	mov	r0, r4
 800240a:	f01c ff8e 	bl	801f32a <crs_strlen>
 800240e:	b283      	uxth	r3, r0
 8002410:	4622      	mov	r2, r4
 8002412:	2110      	movs	r1, #16
 8002414:	2002      	movs	r0, #2
 8002416:	f01c ffed 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800241a:	2401      	movs	r4, #1
 800241c:	e7c6      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      switch (p_modem_ctxt->persist.sim_selected)
 800241e:	f897 3512 	ldrb.w	r3, [r7, #1298]	; 0x512
 8002422:	2b01      	cmp	r3, #1
 8002424:	d030      	beq.n	8002488 <fCmdBuild_SETCFG_TYPE1SC+0x140>
 8002426:	2b02      	cmp	r3, #2
 8002428:	d00a      	beq.n	8002440 <fCmdBuild_SETCFG_TYPE1SC+0xf8>
 800242a:	b103      	cbz	r3, 800242e <fCmdBuild_SETCFG_TYPE1SC+0xe6>
          asim_selected = 0;
 800242c:	2400      	movs	r4, #0
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",\"%d\"",
 800242e:	4623      	mov	r3, r4
 8002430:	4a33      	ldr	r2, [pc, #204]	; (8002500 <fCmdBuild_SETCFG_TYPE1SC+0x1b8>)
 8002432:	4934      	ldr	r1, [pc, #208]	; (8002504 <fCmdBuild_SETCFG_TYPE1SC+0x1bc>)
 8002434:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8002438:	f024 fa06 	bl	8026848 <sprintf>
 800243c:	2400      	movs	r4, #0
 800243e:	e7b5      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
          PRINT_ERR("not supported yet");
 8002440:	4f31      	ldr	r7, [pc, #196]	; (8002508 <fCmdBuild_SETCFG_TYPE1SC+0x1c0>)
 8002442:	4e2c      	ldr	r6, [pc, #176]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002444:	f107 0c20 	add.w	ip, r7, #32
 8002448:	463d      	mov	r5, r7
 800244a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800244c:	6030      	str	r0, [r6, #0]
 800244e:	6071      	str	r1, [r6, #4]
 8002450:	60b2      	str	r2, [r6, #8]
 8002452:	60f3      	str	r3, [r6, #12]
 8002454:	462f      	mov	r7, r5
 8002456:	3610      	adds	r6, #16
 8002458:	4565      	cmp	r5, ip
 800245a:	d1f5      	bne.n	8002448 <fCmdBuild_SETCFG_TYPE1SC+0x100>
 800245c:	882b      	ldrh	r3, [r5, #0]
 800245e:	8033      	strh	r3, [r6, #0]
 8002460:	4d24      	ldr	r5, [pc, #144]	; (80024f4 <fCmdBuild_SETCFG_TYPE1SC+0x1ac>)
 8002462:	4628      	mov	r0, r5
 8002464:	f01c ff61 	bl	801f32a <crs_strlen>
 8002468:	b283      	uxth	r3, r0
 800246a:	462a      	mov	r2, r5
 800246c:	2110      	movs	r1, #16
 800246e:	2002      	movs	r0, #2
 8002470:	f01c ff9e 	bl	801f3b0 <traceIF_itmPrint>
 8002474:	4628      	mov	r0, r5
 8002476:	f01c ff58 	bl	801f32a <crs_strlen>
 800247a:	b283      	uxth	r3, r0
 800247c:	462a      	mov	r2, r5
 800247e:	2110      	movs	r1, #16
 8002480:	2002      	movs	r0, #2
 8002482:	f01c ffb7 	bl	801f3f4 <traceIF_uartPrint>
      if (retval != ATSTATUS_ERROR)
 8002486:	e791      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      switch (p_modem_ctxt->persist.sim_selected)
 8002488:	2402      	movs	r4, #2
 800248a:	e7d0      	b.n	800242e <fCmdBuild_SETCFG_TYPE1SC+0xe6>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.hifc.mode,A\"");
 800248c:	4c1f      	ldr	r4, [pc, #124]	; (800250c <fCmdBuild_SETCFG_TYPE1SC+0x1c4>)
 800248e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002490:	6330      	str	r0, [r6, #48]	; 0x30
 8002492:	6371      	str	r1, [r6, #52]	; 0x34
 8002494:	63b2      	str	r2, [r6, #56]	; 0x38
 8002496:	63f3      	str	r3, [r6, #60]	; 0x3c
 8002498:	7823      	ldrb	r3, [r4, #0]
 800249a:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
  at_status_t retval = ATSTATUS_OK;
 800249e:	2400      	movs	r4, #0
 80024a0:	e784      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"manager.urcBootEv.enabled\",\"true\"");
 80024a2:	4d1b      	ldr	r5, [pc, #108]	; (8002510 <fCmdBuild_SETCFG_TYPE1SC+0x1c8>)
 80024a4:	3630      	adds	r6, #48	; 0x30
 80024a6:	f105 0720 	add.w	r7, r5, #32
 80024aa:	462c      	mov	r4, r5
 80024ac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80024ae:	6030      	str	r0, [r6, #0]
 80024b0:	6071      	str	r1, [r6, #4]
 80024b2:	60b2      	str	r2, [r6, #8]
 80024b4:	60f3      	str	r3, [r6, #12]
 80024b6:	4625      	mov	r5, r4
 80024b8:	3610      	adds	r6, #16
 80024ba:	42bc      	cmp	r4, r7
 80024bc:	d1f5      	bne.n	80024aa <fCmdBuild_SETCFG_TYPE1SC+0x162>
 80024be:	8822      	ldrh	r2, [r4, #0]
 80024c0:	78a3      	ldrb	r3, [r4, #2]
 80024c2:	8032      	strh	r2, [r6, #0]
 80024c4:	70b3      	strb	r3, [r6, #2]
  at_status_t retval = ATSTATUS_OK;
 80024c6:	2400      	movs	r4, #0
 80024c8:	e770      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"manager.urcBootEv.enabled\",\"false\"");
 80024ca:	4d12      	ldr	r5, [pc, #72]	; (8002514 <fCmdBuild_SETCFG_TYPE1SC+0x1cc>)
 80024cc:	3630      	adds	r6, #48	; 0x30
 80024ce:	f105 0720 	add.w	r7, r5, #32
 80024d2:	462c      	mov	r4, r5
 80024d4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80024d6:	6030      	str	r0, [r6, #0]
 80024d8:	6071      	str	r1, [r6, #4]
 80024da:	60b2      	str	r2, [r6, #8]
 80024dc:	60f3      	str	r3, [r6, #12]
 80024de:	4625      	mov	r5, r4
 80024e0:	3610      	adds	r6, #16
 80024e2:	42bc      	cmp	r4, r7
 80024e4:	d1f5      	bne.n	80024d2 <fCmdBuild_SETCFG_TYPE1SC+0x18a>
 80024e6:	6820      	ldr	r0, [r4, #0]
 80024e8:	6030      	str	r0, [r6, #0]
  at_status_t retval = ATSTATUS_OK;
 80024ea:	2400      	movs	r4, #0
 80024ec:	e75e      	b.n	80023ac <fCmdBuild_SETCFG_TYPE1SC+0x64>
 80024ee:	bf00      	nop
 80024f0:	0802b314 	.word	0x0802b314
 80024f4:	200048dc 	.word	0x200048dc
 80024f8:	20001838 	.word	0x20001838
 80024fc:	0802b3d4 	.word	0x0802b3d4
 8002500:	0802b368 	.word	0x0802b368
 8002504:	0802b380 	.word	0x0802b380
 8002508:	0802b344 	.word	0x0802b344
 800250c:	08033954 	.word	0x08033954
 8002510:	0802b38c 	.word	0x0802b38c
 8002514:	0802b3b0 	.word	0x0802b3b0

08002518 <fCmdBuild_GETCFG_TYPE1SC>:

at_status_t fCmdBuild_GETCFG_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 8002518:	b570      	push	{r4, r5, r6, lr}
 800251a:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_GETCFG_TYPE1SC()")
 800251c:	4c42      	ldr	r4, [pc, #264]	; (8002628 <fCmdBuild_GETCFG_TYPE1SC+0x110>)
 800251e:	4d43      	ldr	r5, [pc, #268]	; (800262c <fCmdBuild_GETCFG_TYPE1SC+0x114>)
 8002520:	f104 0e20 	add.w	lr, r4, #32
 8002524:	46a4      	mov	ip, r4
 8002526:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800252a:	6028      	str	r0, [r5, #0]
 800252c:	6069      	str	r1, [r5, #4]
 800252e:	60aa      	str	r2, [r5, #8]
 8002530:	60eb      	str	r3, [r5, #12]
 8002532:	4664      	mov	r4, ip
 8002534:	3510      	adds	r5, #16
 8002536:	45f4      	cmp	ip, lr
 8002538:	d1f4      	bne.n	8002524 <fCmdBuild_GETCFG_TYPE1SC+0xc>
 800253a:	4663      	mov	r3, ip
 800253c:	cb07      	ldmia	r3!, {r0, r1, r2}
 800253e:	6028      	str	r0, [r5, #0]
 8002540:	6069      	str	r1, [r5, #4]
 8002542:	60aa      	str	r2, [r5, #8]
 8002544:	881a      	ldrh	r2, [r3, #0]
 8002546:	789b      	ldrb	r3, [r3, #2]
 8002548:	81aa      	strh	r2, [r5, #12]
 800254a:	73ab      	strb	r3, [r5, #14]
 800254c:	4c37      	ldr	r4, [pc, #220]	; (800262c <fCmdBuild_GETCFG_TYPE1SC+0x114>)
 800254e:	4620      	mov	r0, r4
 8002550:	f01c feeb 	bl	801f32a <crs_strlen>
 8002554:	b283      	uxth	r3, r0
 8002556:	4622      	mov	r2, r4
 8002558:	2104      	movs	r1, #4
 800255a:	2002      	movs	r0, #2
 800255c:	f01c ff28 	bl	801f3b0 <traceIF_itmPrint>
 8002560:	4620      	mov	r0, r4
 8002562:	f01c fee2 	bl	801f32a <crs_strlen>
 8002566:	b283      	uxth	r3, r0
 8002568:	4622      	mov	r2, r4
 800256a:	2104      	movs	r1, #4
 800256c:	2002      	movs	r0, #2
 800256e:	f01c ff41 	bl	801f3f4 <traceIF_uartPrint>

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002572:	8933      	ldrh	r3, [r6, #8]
 8002574:	2b03      	cmp	r3, #3
 8002576:	d001      	beq.n	800257c <fCmdBuild_GETCFG_TYPE1SC+0x64>
  at_status_t retval = ATSTATUS_OK;
 8002578:	2000      	movs	r0, #0
        break;
    }
  }

  return (retval);
}
 800257a:	bd70      	pop	{r4, r5, r6, pc}
    switch (type1sc_shared.getcfg_function)
 800257c:	4b2c      	ldr	r3, [pc, #176]	; (8002630 <fCmdBuild_GETCFG_TYPE1SC+0x118>)
 800257e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002582:	3b02      	subs	r3, #2
 8002584:	2b07      	cmp	r3, #7
 8002586:	d84d      	bhi.n	8002624 <fCmdBuild_GETCFG_TYPE1SC+0x10c>
 8002588:	e8df f003 	tbb	[pc, r3]
 800258c:	24180e04 	.word	0x24180e04
 8002590:	404c4c31 	.word	0x404c4c31
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"BAND\"");
 8002594:	4b27      	ldr	r3, [pc, #156]	; (8002634 <fCmdBuild_GETCFG_TYPE1SC+0x11c>)
 8002596:	6818      	ldr	r0, [r3, #0]
 8002598:	6330      	str	r0, [r6, #48]	; 0x30
 800259a:	889a      	ldrh	r2, [r3, #4]
 800259c:	799b      	ldrb	r3, [r3, #6]
 800259e:	86b2      	strh	r2, [r6, #52]	; 0x34
 80025a0:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
  at_status_t retval = ATSTATUS_OK;
 80025a4:	2000      	movs	r0, #0
        break;
 80025a6:	e7e8      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"OPER\"");
 80025a8:	4b23      	ldr	r3, [pc, #140]	; (8002638 <fCmdBuild_GETCFG_TYPE1SC+0x120>)
 80025aa:	6818      	ldr	r0, [r3, #0]
 80025ac:	6330      	str	r0, [r6, #48]	; 0x30
 80025ae:	889a      	ldrh	r2, [r3, #4]
 80025b0:	799b      	ldrb	r3, [r3, #6]
 80025b2:	86b2      	strh	r2, [r6, #52]	; 0x34
 80025b4:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
  at_status_t retval = ATSTATUS_OK;
 80025b8:	2000      	movs	r0, #0
        break;
 80025ba:	e7de      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.hifc.mode\"");
 80025bc:	4b1f      	ldr	r3, [pc, #124]	; (800263c <fCmdBuild_GETCFG_TYPE1SC+0x124>)
 80025be:	cb07      	ldmia	r3!, {r0, r1, r2}
 80025c0:	6330      	str	r0, [r6, #48]	; 0x30
 80025c2:	6371      	str	r1, [r6, #52]	; 0x34
 80025c4:	63b2      	str	r2, [r6, #56]	; 0x38
 80025c6:	881a      	ldrh	r2, [r3, #0]
 80025c8:	789b      	ldrb	r3, [r3, #2]
 80025ca:	87b2      	strh	r2, [r6, #60]	; 0x3c
 80025cc:	f886 303e 	strb.w	r3, [r6, #62]	; 0x3e
  at_status_t retval = ATSTATUS_OK;
 80025d0:	2000      	movs	r0, #0
        break;
 80025d2:	e7d2      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.conf.sleep_mode\"");
 80025d4:	4c1a      	ldr	r4, [pc, #104]	; (8002640 <fCmdBuild_GETCFG_TYPE1SC+0x128>)
 80025d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80025d8:	6330      	str	r0, [r6, #48]	; 0x30
 80025da:	6371      	str	r1, [r6, #52]	; 0x34
 80025dc:	63b2      	str	r2, [r6, #56]	; 0x38
 80025de:	63f3      	str	r3, [r6, #60]	; 0x3c
 80025e0:	6820      	ldr	r0, [r4, #0]
 80025e2:	6430      	str	r0, [r6, #64]	; 0x40
 80025e4:	7923      	ldrb	r3, [r4, #4]
 80025e6:	f886 3044 	strb.w	r3, [r6, #68]	; 0x44
  at_status_t retval = ATSTATUS_OK;
 80025ea:	2000      	movs	r0, #0
        break;
 80025ec:	e7c5      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"pm.conf.max_allowed_pm_mode\"");
 80025ee:	4c15      	ldr	r4, [pc, #84]	; (8002644 <fCmdBuild_GETCFG_TYPE1SC+0x12c>)
 80025f0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80025f2:	6330      	str	r0, [r6, #48]	; 0x30
 80025f4:	6371      	str	r1, [r6, #52]	; 0x34
 80025f6:	63b2      	str	r2, [r6, #56]	; 0x38
 80025f8:	63f3      	str	r3, [r6, #60]	; 0x3c
 80025fa:	cc07      	ldmia	r4!, {r0, r1, r2}
 80025fc:	6430      	str	r0, [r6, #64]	; 0x40
 80025fe:	6471      	str	r1, [r6, #68]	; 0x44
 8002600:	64b2      	str	r2, [r6, #72]	; 0x48
 8002602:	8823      	ldrh	r3, [r4, #0]
 8002604:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
  at_status_t retval = ATSTATUS_OK;
 8002608:	2000      	movs	r0, #0
        break;
 800260a:	e7b6      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"manager.uartB.flowcontrol\"");
 800260c:	4c0e      	ldr	r4, [pc, #56]	; (8002648 <fCmdBuild_GETCFG_TYPE1SC+0x130>)
 800260e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8002610:	6330      	str	r0, [r6, #48]	; 0x30
 8002612:	6371      	str	r1, [r6, #52]	; 0x34
 8002614:	63b2      	str	r2, [r6, #56]	; 0x38
 8002616:	63f3      	str	r3, [r6, #60]	; 0x3c
 8002618:	cc07      	ldmia	r4!, {r0, r1, r2}
 800261a:	6430      	str	r0, [r6, #64]	; 0x40
 800261c:	6471      	str	r1, [r6, #68]	; 0x44
 800261e:	64b2      	str	r2, [r6, #72]	; 0x48
  at_status_t retval = ATSTATUS_OK;
 8002620:	2000      	movs	r0, #0
        break;
 8002622:	e7aa      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
    switch (type1sc_shared.getcfg_function)
 8002624:	2001      	movs	r0, #1
 8002626:	e7a8      	b.n	800257a <fCmdBuild_GETCFG_TYPE1SC+0x62>
 8002628:	0802b404 	.word	0x0802b404
 800262c:	200048dc 	.word	0x200048dc
 8002630:	20001838 	.word	0x20001838
 8002634:	0802b434 	.word	0x0802b434
 8002638:	0802b43c 	.word	0x0802b43c
 800263c:	0802b444 	.word	0x0802b444
 8002640:	0802b454 	.word	0x0802b454
 8002644:	0802b46c 	.word	0x0802b46c
 8002648:	0802b48c 	.word	0x0802b48c

0800264c <fCmdBuild_SETBDELAY_TYPE1SC>:

at_status_t fCmdBuild_SETBDELAY_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800264c:	b570      	push	{r4, r5, r6, lr}
 800264e:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_SETBDELAY_TYPE1SC()")
 8002650:	4d14      	ldr	r5, [pc, #80]	; (80026a4 <fCmdBuild_SETBDELAY_TYPE1SC+0x58>)
 8002652:	4c15      	ldr	r4, [pc, #84]	; (80026a8 <fCmdBuild_SETBDELAY_TYPE1SC+0x5c>)
 8002654:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002658:	46ac      	mov	ip, r5
 800265a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800265e:	6020      	str	r0, [r4, #0]
 8002660:	6061      	str	r1, [r4, #4]
 8002662:	60a2      	str	r2, [r4, #8]
 8002664:	60e3      	str	r3, [r4, #12]
 8002666:	4665      	mov	r5, ip
 8002668:	3410      	adds	r4, #16
 800266a:	45f4      	cmp	ip, lr
 800266c:	d1f4      	bne.n	8002658 <fCmdBuild_SETBDELAY_TYPE1SC+0xc>
 800266e:	f8bc 3000 	ldrh.w	r3, [ip]
 8002672:	8023      	strh	r3, [r4, #0]
 8002674:	4c0c      	ldr	r4, [pc, #48]	; (80026a8 <fCmdBuild_SETBDELAY_TYPE1SC+0x5c>)
 8002676:	4620      	mov	r0, r4
 8002678:	f01c fe57 	bl	801f32a <crs_strlen>
 800267c:	b283      	uxth	r3, r0
 800267e:	4622      	mov	r2, r4
 8002680:	2104      	movs	r1, #4
 8002682:	2002      	movs	r0, #2
 8002684:	f01c fe94 	bl	801f3b0 <traceIF_itmPrint>
 8002688:	4620      	mov	r0, r4
 800268a:	f01c fe4e 	bl	801f32a <crs_strlen>
 800268e:	b283      	uxth	r3, r0
 8002690:	4622      	mov	r2, r4
 8002692:	2104      	movs	r1, #4
 8002694:	2002      	movs	r0, #2
 8002696:	f01c fead 	bl	801f3f4 <traceIF_uartPrint>

  (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800269a:	4b04      	ldr	r3, [pc, #16]	; (80026ac <fCmdBuild_SETBDELAY_TYPE1SC+0x60>)
 800269c:	881b      	ldrh	r3, [r3, #0]
 800269e:	8633      	strh	r3, [r6, #48]	; 0x30

  return (retval);
}
 80026a0:	2000      	movs	r0, #0
 80026a2:	bd70      	pop	{r4, r5, r6, pc}
 80026a4:	0802b4a8 	.word	0x0802b4a8
 80026a8:	200048dc 	.word	0x200048dc
 80026ac:	080342b8 	.word	0x080342b8

080026b0 <fCmdBuild_PDNSET_TYPE1SC>:


at_status_t fCmdBuild_PDNSET_TYPE1SC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 80026b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80026b4:	b085      	sub	sp, #20
 80026b6:	4607      	mov	r7, r0
 80026b8:	460e      	mov	r6, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_PDNSET_TYPE1SC()")
 80026ba:	4c5f      	ldr	r4, [pc, #380]	; (8002838 <fCmdBuild_PDNSET_TYPE1SC+0x188>)
 80026bc:	4d5f      	ldr	r5, [pc, #380]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 80026be:	f104 0e20 	add.w	lr, r4, #32
 80026c2:	46a4      	mov	ip, r4
 80026c4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80026c8:	6028      	str	r0, [r5, #0]
 80026ca:	6069      	str	r1, [r5, #4]
 80026cc:	60aa      	str	r2, [r5, #8]
 80026ce:	60eb      	str	r3, [r5, #12]
 80026d0:	4664      	mov	r4, ip
 80026d2:	3510      	adds	r5, #16
 80026d4:	45f4      	cmp	ip, lr
 80026d6:	d1f4      	bne.n	80026c2 <fCmdBuild_PDNSET_TYPE1SC+0x12>
 80026d8:	4663      	mov	r3, ip
 80026da:	cb07      	ldmia	r3!, {r0, r1, r2}
 80026dc:	6028      	str	r0, [r5, #0]
 80026de:	6069      	str	r1, [r5, #4]
 80026e0:	60aa      	str	r2, [r5, #8]
 80026e2:	881a      	ldrh	r2, [r3, #0]
 80026e4:	789b      	ldrb	r3, [r3, #2]
 80026e6:	81aa      	strh	r2, [r5, #12]
 80026e8:	73ab      	strb	r3, [r5, #14]
 80026ea:	4c54      	ldr	r4, [pc, #336]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 80026ec:	4620      	mov	r0, r4
 80026ee:	f01c fe1c 	bl	801f32a <crs_strlen>
 80026f2:	b283      	uxth	r3, r0
 80026f4:	4622      	mov	r2, r4
 80026f6:	2104      	movs	r1, #4
 80026f8:	2002      	movs	r0, #2
 80026fa:	f01c fe59 	bl	801f3b0 <traceIF_itmPrint>
 80026fe:	4620      	mov	r0, r4
 8002700:	f01c fe13 	bl	801f32a <crs_strlen>
 8002704:	b283      	uxth	r3, r0
 8002706:	4622      	mov	r2, r4
 8002708:	2104      	movs	r1, #4
 800270a:	2002      	movs	r0, #2
 800270c:	f01c fe72 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002710:	893b      	ldrh	r3, [r7, #8]
 8002712:	2b03      	cmp	r3, #3
 8002714:	d004      	beq.n	8002720 <fCmdBuild_PDNSET_TYPE1SC+0x70>
  at_status_t retval = ATSTATUS_OK;
 8002716:	2500      	movs	r5, #0
      PRINT_ERR("PDP context not defined for conf_id %d", current_conf_id)
      retval = ATSTATUS_ERROR;
    }
  }
  return (retval);
}
 8002718:	4628      	mov	r0, r5
 800271a:	b005      	add	sp, #20
 800271c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 8002720:	4630      	mov	r0, r6
 8002722:	f00a f8c7 	bl	800c8b4 <atcm_get_cid_current_SID>
 8002726:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 8002728:	4601      	mov	r1, r0
 800272a:	f106 000c 	add.w	r0, r6, #12
 800272e:	f00b f949 	bl	800d9c4 <atcm_get_affected_modem_cid>
 8002732:	4680      	mov	r8, r0
    PRINT_INFO("user cid = %d, modem cid = %d", (uint8_t)current_conf_id, modem_cid)
 8002734:	4d41      	ldr	r5, [pc, #260]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 8002736:	4603      	mov	r3, r0
 8002738:	4622      	mov	r2, r4
 800273a:	4941      	ldr	r1, [pc, #260]	; (8002840 <fCmdBuild_PDNSET_TYPE1SC+0x190>)
 800273c:	4628      	mov	r0, r5
 800273e:	f024 f883 	bl	8026848 <sprintf>
 8002742:	4628      	mov	r0, r5
 8002744:	f01c fdf1 	bl	801f32a <crs_strlen>
 8002748:	b283      	uxth	r3, r0
 800274a:	462a      	mov	r2, r5
 800274c:	2101      	movs	r1, #1
 800274e:	2002      	movs	r0, #2
 8002750:	f01c fe2e 	bl	801f3b0 <traceIF_itmPrint>
 8002754:	4628      	mov	r0, r5
 8002756:	f01c fde8 	bl	801f32a <crs_strlen>
 800275a:	b283      	uxth	r3, r0
 800275c:	462a      	mov	r2, r5
 800275e:	2101      	movs	r1, #1
 8002760:	2002      	movs	r0, #2
 8002762:	f01c fe47 	bl	801f3f4 <traceIF_uartPrint>
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id != CS_PDN_NOT_DEFINED)
 8002766:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800276a:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800276e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8002772:	2b0c      	cmp	r3, #12
 8002774:	d045      	beq.n	8002802 <fCmdBuild_PDNSET_TYPE1SC+0x152>
      if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].pdn_conf.username[0] == 0U)
 8002776:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800277a:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800277e:	f893 5092 	ldrb.w	r5, [r3, #146]	; 0x92
 8002782:	b9ad      	cbnz	r5, 80027b0 <fCmdBuild_PDNSET_TYPE1SC+0x100>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 8002784:	3730      	adds	r7, #48	; 0x30
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].apn,
 8002786:	eb04 1984 	add.w	r9, r4, r4, lsl #6
 800278a:	ea4f 0949 	mov.w	r9, r9, lsl #1
 800278e:	f109 0948 	add.w	r9, r9, #72	; 0x48
 8002792:	44b1      	add	r9, r6
 8002794:	f109 0909 	add.w	r9, r9, #9
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 8002798:	f893 0091 	ldrb.w	r0, [r3, #145]	; 0x91
 800279c:	f00a f938 	bl	800ca10 <atcm_get_PDPtypeStr>
 80027a0:	9000      	str	r0, [sp, #0]
 80027a2:	464b      	mov	r3, r9
 80027a4:	4642      	mov	r2, r8
 80027a6:	4927      	ldr	r1, [pc, #156]	; (8002844 <fCmdBuild_PDNSET_TYPE1SC+0x194>)
 80027a8:	4638      	mov	r0, r7
 80027aa:	f024 f84d 	bl	8026848 <sprintf>
 80027ae:	e7b3      	b.n	8002718 <fCmdBuild_PDNSET_TYPE1SC+0x68>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\",\"PAP\",\"%s\",\"%s\"",
 80027b0:	3730      	adds	r7, #48	; 0x30
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].apn,
 80027b2:	ea4f 1984 	mov.w	r9, r4, lsl #6
 80027b6:	eb04 1584 	add.w	r5, r4, r4, lsl #6
 80027ba:	006d      	lsls	r5, r5, #1
 80027bc:	3548      	adds	r5, #72	; 0x48
 80027be:	4435      	add	r5, r6
 80027c0:	3509      	adds	r5, #9
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\",\"PAP\",\"%s\",\"%s\"",
 80027c2:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 80027c6:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 80027ca:	f893 0091 	ldrb.w	r0, [r3, #145]	; 0x91
 80027ce:	f00a f91f 	bl	800ca10 <atcm_get_PDPtypeStr>
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].pdn_conf.username,
 80027d2:	eb09 0304 	add.w	r3, r9, r4
 80027d6:	005b      	lsls	r3, r3, #1
 80027d8:	3388      	adds	r3, #136	; 0x88
 80027da:	4433      	add	r3, r6
 80027dc:	330a      	adds	r3, #10
                       p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].pdn_conf.password);
 80027de:	44a1      	add	r9, r4
 80027e0:	ea4f 0949 	mov.w	r9, r9, lsl #1
 80027e4:	f109 09a8 	add.w	r9, r9, #168	; 0xa8
 80027e8:	444e      	add	r6, r9
 80027ea:	360a      	adds	r6, #10
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\",\"PAP\",\"%s\",\"%s\"",
 80027ec:	9602      	str	r6, [sp, #8]
 80027ee:	9301      	str	r3, [sp, #4]
 80027f0:	9000      	str	r0, [sp, #0]
 80027f2:	462b      	mov	r3, r5
 80027f4:	4642      	mov	r2, r8
 80027f6:	4914      	ldr	r1, [pc, #80]	; (8002848 <fCmdBuild_PDNSET_TYPE1SC+0x198>)
 80027f8:	4638      	mov	r0, r7
 80027fa:	f024 f825 	bl	8026848 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 80027fe:	2500      	movs	r5, #0
 8002800:	e78a      	b.n	8002718 <fCmdBuild_PDNSET_TYPE1SC+0x68>
      PRINT_ERR("PDP context not defined for conf_id %d", current_conf_id)
 8002802:	4d0e      	ldr	r5, [pc, #56]	; (800283c <fCmdBuild_PDNSET_TYPE1SC+0x18c>)
 8002804:	4622      	mov	r2, r4
 8002806:	4911      	ldr	r1, [pc, #68]	; (800284c <fCmdBuild_PDNSET_TYPE1SC+0x19c>)
 8002808:	4628      	mov	r0, r5
 800280a:	f024 f81d 	bl	8026848 <sprintf>
 800280e:	4628      	mov	r0, r5
 8002810:	f01c fd8b 	bl	801f32a <crs_strlen>
 8002814:	b283      	uxth	r3, r0
 8002816:	462a      	mov	r2, r5
 8002818:	2110      	movs	r1, #16
 800281a:	2002      	movs	r0, #2
 800281c:	f01c fdc8 	bl	801f3b0 <traceIF_itmPrint>
 8002820:	4628      	mov	r0, r5
 8002822:	f01c fd82 	bl	801f32a <crs_strlen>
 8002826:	b283      	uxth	r3, r0
 8002828:	462a      	mov	r2, r5
 800282a:	2110      	movs	r1, #16
 800282c:	2002      	movs	r0, #2
 800282e:	f01c fde1 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 8002832:	2501      	movs	r5, #1
 8002834:	e770      	b.n	8002718 <fCmdBuild_PDNSET_TYPE1SC+0x68>
 8002836:	bf00      	nop
 8002838:	0802b4dc 	.word	0x0802b4dc
 800283c:	200048dc 	.word	0x200048dc
 8002840:	0802b50c 	.word	0x0802b50c
 8002844:	0802b534 	.word	0x0802b534
 8002848:	0802b544 	.word	0x0802b544
 800284c:	0802b564 	.word	0x0802b564

08002850 <fRspAnalyze_Error_TYPE1SC>:


/* Analyze command functions -------------------------------------------------*/
at_action_rsp_t fRspAnalyze_Error_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                          const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002850:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002854:	4605      	mov	r5, r0
 8002856:	460e      	mov	r6, r1
 8002858:	4617      	mov	r7, r2
 800285a:	4698      	mov	r8, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval;
  PRINT_API("enter fRspAnalyze_Error_TYPE1SC()")
 800285c:	f8df e08c 	ldr.w	lr, [pc, #140]	; 80028ec <fRspAnalyze_Error_TYPE1SC+0x9c>
 8002860:	4c21      	ldr	r4, [pc, #132]	; (80028e8 <fRspAnalyze_Error_TYPE1SC+0x98>)
 8002862:	f10e 0930 	add.w	r9, lr, #48	; 0x30
 8002866:	46f4      	mov	ip, lr
 8002868:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800286c:	6020      	str	r0, [r4, #0]
 800286e:	6061      	str	r1, [r4, #4]
 8002870:	60a2      	str	r2, [r4, #8]
 8002872:	60e3      	str	r3, [r4, #12]
 8002874:	46e6      	mov	lr, ip
 8002876:	3410      	adds	r4, #16
 8002878:	45cc      	cmp	ip, r9
 800287a:	d1f4      	bne.n	8002866 <fRspAnalyze_Error_TYPE1SC+0x16>
 800287c:	4c1a      	ldr	r4, [pc, #104]	; (80028e8 <fRspAnalyze_Error_TYPE1SC+0x98>)
 800287e:	4620      	mov	r0, r4
 8002880:	f01c fd53 	bl	801f32a <crs_strlen>
 8002884:	b283      	uxth	r3, r0
 8002886:	4622      	mov	r2, r4
 8002888:	2104      	movs	r1, #4
 800288a:	2002      	movs	r0, #2
 800288c:	f01c fd90 	bl	801f3b0 <traceIF_itmPrint>
 8002890:	4620      	mov	r0, r4
 8002892:	f01c fd4a 	bl	801f32a <crs_strlen>
 8002896:	b283      	uxth	r3, r0
 8002898:	4622      	mov	r2, r4
 800289a:	2104      	movs	r1, #4
 800289c:	2002      	movs	r0, #2
 800289e:	f01c fda9 	bl	801f3f4 <traceIF_uartPrint>

  switch (p_atp_ctxt->current_SID)
 80028a2:	8a2b      	ldrh	r3, [r5, #16]
 80028a4:	2b79      	cmp	r3, #121	; 0x79
 80028a6:	d009      	beq.n	80028bc <fRspAnalyze_Error_TYPE1SC+0x6c>
      /* nothing to do */
      break;
  }

  /* analyze Error for TYPE1SC */
  switch (p_atp_ctxt->current_atcmd.id)
 80028a8:	69ec      	ldr	r4, [r5, #28]
 80028aa:	2c32      	cmp	r4, #50	; 0x32
 80028ac:	d019      	beq.n	80028e2 <fRspAnalyze_Error_TYPE1SC+0x92>
 80028ae:	d80c      	bhi.n	80028ca <fRspAnalyze_Error_TYPE1SC+0x7a>
 80028b0:	3c17      	subs	r4, #23
 80028b2:	2c02      	cmp	r4, #2
 80028b4:	d80e      	bhi.n	80028d4 <fRspAnalyze_Error_TYPE1SC+0x84>
 80028b6:	2001      	movs	r0, #1
      retval = fRspAnalyze_Error(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
      break;
  }

  return (retval);
}
 80028b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      (void) atcm_socket_release_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 80028bc:	f8d6 3740 	ldr.w	r3, [r6, #1856]	; 0x740
 80028c0:	6819      	ldr	r1, [r3, #0]
 80028c2:	4630      	mov	r0, r6
 80028c4:	f011 fbf6 	bl	80140b4 <atcm_socket_release_modem_cid>
      break;
 80028c8:	e7ee      	b.n	80028a8 <fRspAnalyze_Error_TYPE1SC+0x58>
  switch (p_atp_ctxt->current_atcmd.id)
 80028ca:	3c3a      	subs	r4, #58	; 0x3a
 80028cc:	2c04      	cmp	r4, #4
 80028ce:	d801      	bhi.n	80028d4 <fRspAnalyze_Error_TYPE1SC+0x84>
 80028d0:	2001      	movs	r0, #1
 80028d2:	e7f1      	b.n	80028b8 <fRspAnalyze_Error_TYPE1SC+0x68>
      retval = fRspAnalyze_Error(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 80028d4:	4643      	mov	r3, r8
 80028d6:	463a      	mov	r2, r7
 80028d8:	4631      	mov	r1, r6
 80028da:	4628      	mov	r0, r5
 80028dc:	f00d fe8e 	bl	80105fc <fRspAnalyze_Error>
      break;
 80028e0:	e7ea      	b.n	80028b8 <fRspAnalyze_Error_TYPE1SC+0x68>
  switch (p_atp_ctxt->current_atcmd.id)
 80028e2:	2001      	movs	r0, #1
 80028e4:	e7e8      	b.n	80028b8 <fRspAnalyze_Error_TYPE1SC+0x68>
 80028e6:	bf00      	nop
 80028e8:	200048dc 	.word	0x200048dc
 80028ec:	0802b59c 	.word	0x0802b59c

080028f0 <fRspAnalyze_CPIN_TYPE1SC>:

at_action_rsp_t fRspAnalyze_CPIN_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                         const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80028f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80028f4:	4605      	mov	r5, r0
 80028f6:	4688      	mov	r8, r1
 80028f8:	4617      	mov	r7, r2
 80028fa:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CPIN_TYPE1SC()")
 80028fc:	f8df c100 	ldr.w	ip, [pc, #256]	; 8002a00 <fRspAnalyze_CPIN_TYPE1SC+0x110>
 8002900:	4c3e      	ldr	r4, [pc, #248]	; (80029fc <fRspAnalyze_CPIN_TYPE1SC+0x10c>)
 8002902:	f10c 0920 	add.w	r9, ip, #32
 8002906:	46e6      	mov	lr, ip
 8002908:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800290c:	6020      	str	r0, [r4, #0]
 800290e:	6061      	str	r1, [r4, #4]
 8002910:	60a2      	str	r2, [r4, #8]
 8002912:	60e3      	str	r3, [r4, #12]
 8002914:	46f4      	mov	ip, lr
 8002916:	3410      	adds	r4, #16
 8002918:	45ce      	cmp	lr, r9
 800291a:	d1f4      	bne.n	8002906 <fRspAnalyze_CPIN_TYPE1SC+0x16>
 800291c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8002920:	6020      	str	r0, [r4, #0]
 8002922:	6061      	str	r1, [r4, #4]
 8002924:	60a2      	str	r2, [r4, #8]
 8002926:	f8bc 2000 	ldrh.w	r2, [ip]
 800292a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800292e:	81a2      	strh	r2, [r4, #12]
 8002930:	73a3      	strb	r3, [r4, #14]
 8002932:	4c32      	ldr	r4, [pc, #200]	; (80029fc <fRspAnalyze_CPIN_TYPE1SC+0x10c>)
 8002934:	4620      	mov	r0, r4
 8002936:	f01c fcf8 	bl	801f32a <crs_strlen>
 800293a:	b283      	uxth	r3, r0
 800293c:	4622      	mov	r2, r4
 800293e:	2104      	movs	r1, #4
 8002940:	2002      	movs	r0, #2
 8002942:	f01c fd35 	bl	801f3b0 <traceIF_itmPrint>
 8002946:	4620      	mov	r0, r4
 8002948:	f01c fcef 	bl	801f32a <crs_strlen>
 800294c:	b283      	uxth	r3, r0
 800294e:	4622      	mov	r2, r4
 8002950:	2104      	movs	r1, #4
 8002952:	2002      	movs	r0, #2
 8002954:	f01c fd4e 	bl	801f3f4 <traceIF_uartPrint>
  /*
  *   analyze parameters for +CPIN
  *
  *   if +CPIN is not received after AT+CPIN request, it's an URC
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CPIN)
 8002958:	69eb      	ldr	r3, [r5, #28]
 800295a:	2b12      	cmp	r3, #18
 800295c:	d107      	bne.n	800296e <fRspAnalyze_CPIN_TYPE1SC+0x7e>
  {
    retval = fRspAnalyze_CPIN(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 800295e:	4633      	mov	r3, r6
 8002960:	463a      	mov	r2, r7
 8002962:	4641      	mov	r1, r8
 8002964:	4628      	mov	r0, r5
 8002966:	f00e f9bb 	bl	8010ce0 <fRspAnalyze_CPIN>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 800296a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 800296e:	2400      	movs	r4, #0
 8002970:	4632      	mov	r2, r6
 8002972:	4639      	mov	r1, r7
 8002974:	4628      	mov	r0, r5
 8002976:	f009 fd67 	bl	800c448 <atcc_extractElement>
 800297a:	2801      	cmp	r0, #1
 800297c:	d000      	beq.n	8002980 <fRspAnalyze_CPIN_TYPE1SC+0x90>
 800297e:	2401      	movs	r4, #1
 8002980:	89f3      	ldrh	r3, [r6, #14]
 8002982:	b113      	cbz	r3, 800298a <fRspAnalyze_CPIN_TYPE1SC+0x9a>
    if (element_infos->param_rank == 2U)
 8002984:	8933      	ldrh	r3, [r6, #8]
 8002986:	2b02      	cmp	r3, #2
 8002988:	d003      	beq.n	8002992 <fRspAnalyze_CPIN_TYPE1SC+0xa2>
    END_PARAM_LOOP()
 800298a:	2c00      	cmp	r4, #0
 800298c:	d0f0      	beq.n	8002970 <fRspAnalyze_CPIN_TYPE1SC+0x80>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 800298e:	2010      	movs	r0, #16
 8002990:	e7eb      	b.n	800296a <fRspAnalyze_CPIN_TYPE1SC+0x7a>
      PRINT_DBG("URC +CPIN received")
 8002992:	f8df 8068 	ldr.w	r8, [pc, #104]	; 80029fc <fRspAnalyze_CPIN_TYPE1SC+0x10c>
 8002996:	f8df c06c 	ldr.w	ip, [pc, #108]	; 8002a04 <fRspAnalyze_CPIN_TYPE1SC+0x114>
 800299a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800299e:	f8c8 0000 	str.w	r0, [r8]
 80029a2:	f8c8 1004 	str.w	r1, [r8, #4]
 80029a6:	f8c8 2008 	str.w	r2, [r8, #8]
 80029aa:	f8c8 300c 	str.w	r3, [r8, #12]
 80029ae:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80029b2:	f8c8 0010 	str.w	r0, [r8, #16]
 80029b6:	f8c8 1014 	str.w	r1, [r8, #20]
 80029ba:	f8c8 2018 	str.w	r2, [r8, #24]
 80029be:	f89c 3000 	ldrb.w	r3, [ip]
 80029c2:	f888 301c 	strb.w	r3, [r8, #28]
 80029c6:	4640      	mov	r0, r8
 80029c8:	f01c fcaf 	bl	801f32a <crs_strlen>
 80029cc:	b283      	uxth	r3, r0
 80029ce:	4642      	mov	r2, r8
 80029d0:	2102      	movs	r1, #2
 80029d2:	4608      	mov	r0, r1
 80029d4:	f01c fcec 	bl	801f3b0 <traceIF_itmPrint>
 80029d8:	4640      	mov	r0, r8
 80029da:	f01c fca6 	bl	801f32a <crs_strlen>
 80029de:	b283      	uxth	r3, r0
 80029e0:	4642      	mov	r2, r8
 80029e2:	2102      	movs	r1, #2
 80029e4:	4608      	mov	r0, r1
 80029e6:	f01c fd05 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 80029ea:	8972      	ldrh	r2, [r6, #10]
 80029ec:	89f3      	ldrh	r3, [r6, #14]
 80029ee:	443a      	add	r2, r7
 80029f0:	2102      	movs	r1, #2
 80029f2:	4608      	mov	r0, r1
 80029f4:	f01c ffca 	bl	801f98c <traceIF_BufCharPrint>
 80029f8:	e7c7      	b.n	800298a <fRspAnalyze_CPIN_TYPE1SC+0x9a>
 80029fa:	bf00      	nop
 80029fc:	200048dc 	.word	0x200048dc
 8002a00:	0802b5cc 	.word	0x0802b5cc
 8002a04:	0802b5fc 	.word	0x0802b5fc

08002a08 <fRspAnalyze_CFUN_TYPE1SC>:

at_action_rsp_t fRspAnalyze_CFUN_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                         const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002a08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002a0c:	4680      	mov	r8, r0
 8002a0e:	4617      	mov	r7, r2
 8002a10:	461e      	mov	r6, r3
  UNUSED(p_at_ctxt);
  UNUSED(p_modem_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CFUN_TYPE1SC()")
 8002a12:	4c34      	ldr	r4, [pc, #208]	; (8002ae4 <fRspAnalyze_CFUN_TYPE1SC+0xdc>)
 8002a14:	4d34      	ldr	r5, [pc, #208]	; (8002ae8 <fRspAnalyze_CFUN_TYPE1SC+0xe0>)
 8002a16:	f104 0e20 	add.w	lr, r4, #32
 8002a1a:	46a4      	mov	ip, r4
 8002a1c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002a20:	6028      	str	r0, [r5, #0]
 8002a22:	6069      	str	r1, [r5, #4]
 8002a24:	60aa      	str	r2, [r5, #8]
 8002a26:	60eb      	str	r3, [r5, #12]
 8002a28:	4664      	mov	r4, ip
 8002a2a:	3510      	adds	r5, #16
 8002a2c:	45f4      	cmp	ip, lr
 8002a2e:	d1f4      	bne.n	8002a1a <fRspAnalyze_CFUN_TYPE1SC+0x12>
 8002a30:	cc07      	ldmia	r4!, {r0, r1, r2}
 8002a32:	6028      	str	r0, [r5, #0]
 8002a34:	6069      	str	r1, [r5, #4]
 8002a36:	60aa      	str	r2, [r5, #8]
 8002a38:	8822      	ldrh	r2, [r4, #0]
 8002a3a:	78a3      	ldrb	r3, [r4, #2]
 8002a3c:	81aa      	strh	r2, [r5, #12]
 8002a3e:	73ab      	strb	r3, [r5, #14]
 8002a40:	4c29      	ldr	r4, [pc, #164]	; (8002ae8 <fRspAnalyze_CFUN_TYPE1SC+0xe0>)
 8002a42:	4620      	mov	r0, r4
 8002a44:	f01c fc71 	bl	801f32a <crs_strlen>
 8002a48:	b283      	uxth	r3, r0
 8002a4a:	4622      	mov	r2, r4
 8002a4c:	2104      	movs	r1, #4
 8002a4e:	2002      	movs	r0, #2
 8002a50:	f01c fcae 	bl	801f3b0 <traceIF_itmPrint>
 8002a54:	4620      	mov	r0, r4
 8002a56:	f01c fc68 	bl	801f32a <crs_strlen>
 8002a5a:	b283      	uxth	r3, r0
 8002a5c:	4622      	mov	r2, r4
 8002a5e:	2104      	movs	r1, #4
 8002a60:	2002      	movs	r0, #2
 8002a62:	f01c fcc7 	bl	801f3f4 <traceIF_uartPrint>

  /* this is an URC */
  START_PARAM_LOOP()
 8002a66:	2400      	movs	r4, #0
 8002a68:	4632      	mov	r2, r6
 8002a6a:	4639      	mov	r1, r7
 8002a6c:	4640      	mov	r0, r8
 8002a6e:	f009 fceb 	bl	800c448 <atcc_extractElement>
 8002a72:	2801      	cmp	r0, #1
 8002a74:	d000      	beq.n	8002a78 <fRspAnalyze_CFUN_TYPE1SC+0x70>
 8002a76:	2401      	movs	r4, #1
 8002a78:	89f3      	ldrh	r3, [r6, #14]
 8002a7a:	b113      	cbz	r3, 8002a82 <fRspAnalyze_CFUN_TYPE1SC+0x7a>
  if (element_infos->param_rank == 2U)
 8002a7c:	8933      	ldrh	r3, [r6, #8]
 8002a7e:	2b02      	cmp	r3, #2
 8002a80:	d004      	beq.n	8002a8c <fRspAnalyze_CFUN_TYPE1SC+0x84>
  {
    PRINT_DBG("URC +CFUN received")
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
  }
  END_PARAM_LOOP()
 8002a82:	2c00      	cmp	r4, #0
 8002a84:	d0f0      	beq.n	8002a68 <fRspAnalyze_CFUN_TYPE1SC+0x60>

  return (retval);
}
 8002a86:	2010      	movs	r0, #16
 8002a88:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    PRINT_DBG("URC +CFUN received")
 8002a8c:	4d16      	ldr	r5, [pc, #88]	; (8002ae8 <fRspAnalyze_CFUN_TYPE1SC+0xe0>)
 8002a8e:	f8df c05c 	ldr.w	ip, [pc, #92]	; 8002aec <fRspAnalyze_CFUN_TYPE1SC+0xe4>
 8002a92:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002a96:	6028      	str	r0, [r5, #0]
 8002a98:	6069      	str	r1, [r5, #4]
 8002a9a:	60aa      	str	r2, [r5, #8]
 8002a9c:	60eb      	str	r3, [r5, #12]
 8002a9e:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8002aa2:	6128      	str	r0, [r5, #16]
 8002aa4:	6169      	str	r1, [r5, #20]
 8002aa6:	61aa      	str	r2, [r5, #24]
 8002aa8:	f89c 3000 	ldrb.w	r3, [ip]
 8002aac:	772b      	strb	r3, [r5, #28]
 8002aae:	4628      	mov	r0, r5
 8002ab0:	f01c fc3b 	bl	801f32a <crs_strlen>
 8002ab4:	b283      	uxth	r3, r0
 8002ab6:	462a      	mov	r2, r5
 8002ab8:	2102      	movs	r1, #2
 8002aba:	4608      	mov	r0, r1
 8002abc:	f01c fc78 	bl	801f3b0 <traceIF_itmPrint>
 8002ac0:	4628      	mov	r0, r5
 8002ac2:	f01c fc32 	bl	801f32a <crs_strlen>
 8002ac6:	b283      	uxth	r3, r0
 8002ac8:	462a      	mov	r2, r5
 8002aca:	2102      	movs	r1, #2
 8002acc:	4608      	mov	r0, r1
 8002ace:	f01c fc91 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8002ad2:	8972      	ldrh	r2, [r6, #10]
 8002ad4:	89f3      	ldrh	r3, [r6, #14]
 8002ad6:	443a      	add	r2, r7
 8002ad8:	2102      	movs	r1, #2
 8002ada:	4608      	mov	r0, r1
 8002adc:	f01c ff56 	bl	801f98c <traceIF_BufCharPrint>
 8002ae0:	e7cf      	b.n	8002a82 <fRspAnalyze_CFUN_TYPE1SC+0x7a>
 8002ae2:	bf00      	nop
 8002ae4:	0802b61c 	.word	0x0802b61c
 8002ae8:	200048dc 	.word	0x200048dc
 8002aec:	0802b64c 	.word	0x0802b64c

08002af0 <fRspAnalyze_CCID_TYPE1SC>:

at_action_rsp_t fRspAnalyze_CCID_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                         const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002af0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002af4:	4680      	mov	r8, r0
 8002af6:	4689      	mov	r9, r1
 8002af8:	4617      	mov	r7, r2
 8002afa:	461e      	mov	r6, r3
  UNUSED(p_at_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_INTERMEDIATE; /* received a valid intermediate answer */
  PRINT_API("enter fRspAnalyze_QCCID_TYPE1SC()")
 8002afc:	4d35      	ldr	r5, [pc, #212]	; (8002bd4 <fRspAnalyze_CCID_TYPE1SC+0xe4>)
 8002afe:	4c36      	ldr	r4, [pc, #216]	; (8002bd8 <fRspAnalyze_CCID_TYPE1SC+0xe8>)
 8002b00:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002b04:	46ac      	mov	ip, r5
 8002b06:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002b0a:	6020      	str	r0, [r4, #0]
 8002b0c:	6061      	str	r1, [r4, #4]
 8002b0e:	60a2      	str	r2, [r4, #8]
 8002b10:	60e3      	str	r3, [r4, #12]
 8002b12:	4665      	mov	r5, ip
 8002b14:	3410      	adds	r4, #16
 8002b16:	45f4      	cmp	ip, lr
 8002b18:	d1f4      	bne.n	8002b04 <fRspAnalyze_CCID_TYPE1SC+0x14>
 8002b1a:	4c2f      	ldr	r4, [pc, #188]	; (8002bd8 <fRspAnalyze_CCID_TYPE1SC+0xe8>)
 8002b1c:	4620      	mov	r0, r4
 8002b1e:	f01c fc04 	bl	801f32a <crs_strlen>
 8002b22:	b283      	uxth	r3, r0
 8002b24:	4622      	mov	r2, r4
 8002b26:	2104      	movs	r1, #4
 8002b28:	2002      	movs	r0, #2
 8002b2a:	f01c fc41 	bl	801f3b0 <traceIF_itmPrint>
 8002b2e:	4620      	mov	r0, r4
 8002b30:	f01c fbfb 	bl	801f32a <crs_strlen>
 8002b34:	b283      	uxth	r3, r0
 8002b36:	4622      	mov	r2, r4
 8002b38:	2104      	movs	r1, #4
 8002b3a:	2002      	movs	r0, #2
 8002b3c:	f01c fc5a 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +QCCID */
  START_PARAM_LOOP()
 8002b40:	2400      	movs	r4, #0
 8002b42:	4632      	mov	r2, r6
 8002b44:	4639      	mov	r1, r7
 8002b46:	4640      	mov	r0, r8
 8002b48:	f009 fc7e 	bl	800c448 <atcc_extractElement>
 8002b4c:	2801      	cmp	r0, #1
 8002b4e:	d000      	beq.n	8002b52 <fRspAnalyze_CCID_TYPE1SC+0x62>
 8002b50:	2401      	movs	r4, #1
 8002b52:	89f3      	ldrh	r3, [r6, #14]
 8002b54:	b113      	cbz	r3, 8002b5c <fRspAnalyze_CCID_TYPE1SC+0x6c>
  if (element_infos->param_rank == 2U)
 8002b56:	8933      	ldrh	r3, [r6, #8]
 8002b58:	2b02      	cmp	r3, #2
 8002b5a:	d004      	beq.n	8002b66 <fRspAnalyze_CCID_TYPE1SC+0x76>
  }
  else
  {
    /* other parameters ignored */
  }
  END_PARAM_LOOP()
 8002b5c:	2c00      	cmp	r4, #0
 8002b5e:	d0f0      	beq.n	8002b42 <fRspAnalyze_CCID_TYPE1SC+0x52>

  return (retval);
}
 8002b60:	2008      	movs	r0, #8
 8002b62:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("ICCID:")
 8002b66:	4d1c      	ldr	r5, [pc, #112]	; (8002bd8 <fRspAnalyze_CCID_TYPE1SC+0xe8>)
 8002b68:	f8df c070 	ldr.w	ip, [pc, #112]	; 8002bdc <fRspAnalyze_CCID_TYPE1SC+0xec>
 8002b6c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002b70:	6028      	str	r0, [r5, #0]
 8002b72:	6069      	str	r1, [r5, #4]
 8002b74:	60aa      	str	r2, [r5, #8]
 8002b76:	60eb      	str	r3, [r5, #12]
 8002b78:	f89c 3000 	ldrb.w	r3, [ip]
 8002b7c:	742b      	strb	r3, [r5, #16]
 8002b7e:	4628      	mov	r0, r5
 8002b80:	f01c fbd3 	bl	801f32a <crs_strlen>
 8002b84:	b283      	uxth	r3, r0
 8002b86:	462a      	mov	r2, r5
 8002b88:	2102      	movs	r1, #2
 8002b8a:	4608      	mov	r0, r1
 8002b8c:	f01c fc10 	bl	801f3b0 <traceIF_itmPrint>
 8002b90:	4628      	mov	r0, r5
 8002b92:	f01c fbca 	bl	801f32a <crs_strlen>
 8002b96:	b283      	uxth	r3, r0
 8002b98:	462a      	mov	r2, r5
 8002b9a:	2102      	movs	r1, #2
 8002b9c:	4608      	mov	r0, r1
 8002b9e:	f01c fc29 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8002ba2:	8972      	ldrh	r2, [r6, #10]
 8002ba4:	89f3      	ldrh	r3, [r6, #14]
 8002ba6:	443a      	add	r2, r7
 8002ba8:	2102      	movs	r1, #2
 8002baa:	4608      	mov	r0, r1
 8002bac:	f01c feee 	bl	801f98c <traceIF_BufCharPrint>
    uint16_t src_idx = element_infos->str_start_idx;
 8002bb0:	8971      	ldrh	r1, [r6, #10]
    size_t ccid_size = element_infos->str_size;
 8002bb2:	89f2      	ldrh	r2, [r6, #14]
    if ((p_msg_in->buffer[src_idx] == 0x20U) &&
 8002bb4:	5c7b      	ldrb	r3, [r7, r1]
 8002bb6:	2b20      	cmp	r3, #32
 8002bb8:	d006      	beq.n	8002bc8 <fRspAnalyze_CCID_TYPE1SC+0xd8>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.iccid),
 8002bba:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
 8002bbe:	4439      	add	r1, r7
 8002bc0:	3002      	adds	r0, #2
 8002bc2:	f023 ff91 	bl	8026ae8 <memcpy>
 8002bc6:	e7c9      	b.n	8002b5c <fRspAnalyze_CCID_TYPE1SC+0x6c>
    if ((p_msg_in->buffer[src_idx] == 0x20U) &&
 8002bc8:	2a01      	cmp	r2, #1
 8002bca:	d9f6      	bls.n	8002bba <fRspAnalyze_CCID_TYPE1SC+0xca>
      ccid_size -= 1U;
 8002bcc:	3a01      	subs	r2, #1
      src_idx += 1U;
 8002bce:	3101      	adds	r1, #1
 8002bd0:	b289      	uxth	r1, r1
 8002bd2:	e7f2      	b.n	8002bba <fRspAnalyze_CCID_TYPE1SC+0xca>
 8002bd4:	0802b66c 	.word	0x0802b66c
 8002bd8:	200048dc 	.word	0x200048dc
 8002bdc:	0802b69c 	.word	0x0802b69c

08002be0 <fCmdpAnalyze_GETCFG_TYPE1SC>:

at_action_rsp_t fCmdpAnalyze_GETCFG_TYPE1SC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                            const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8002be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002be4:	460e      	mov	r6, r1
 8002be6:	4690      	mov	r8, r2
 8002be8:	461f      	mov	r7, r3
  UNUSED(p_at_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_INTERMEDIATE; /* received a valid intermediate answer */
  PRINT_API("enter fCmdpAnalyze_GETCFG_TYPE1SC()")
 8002bea:	4d50      	ldr	r5, [pc, #320]	; (8002d2c <fCmdpAnalyze_GETCFG_TYPE1SC+0x14c>)
 8002bec:	4c50      	ldr	r4, [pc, #320]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002bee:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002bf2:	46ac      	mov	ip, r5
 8002bf4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002bf8:	6020      	str	r0, [r4, #0]
 8002bfa:	6061      	str	r1, [r4, #4]
 8002bfc:	60a2      	str	r2, [r4, #8]
 8002bfe:	60e3      	str	r3, [r4, #12]
 8002c00:	4665      	mov	r5, ip
 8002c02:	3410      	adds	r4, #16
 8002c04:	45f4      	cmp	ip, lr
 8002c06:	d1f4      	bne.n	8002bf2 <fCmdpAnalyze_GETCFG_TYPE1SC+0x12>
 8002c08:	f8bc 3000 	ldrh.w	r3, [ip]
 8002c0c:	8023      	strh	r3, [r4, #0]
 8002c0e:	4c48      	ldr	r4, [pc, #288]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002c10:	4620      	mov	r0, r4
 8002c12:	f01c fb8a 	bl	801f32a <crs_strlen>
 8002c16:	b283      	uxth	r3, r0
 8002c18:	4622      	mov	r2, r4
 8002c1a:	2104      	movs	r1, #4
 8002c1c:	2002      	movs	r0, #2
 8002c1e:	f01c fbc7 	bl	801f3b0 <traceIF_itmPrint>
 8002c22:	4620      	mov	r0, r4
 8002c24:	f01c fb81 	bl	801f32a <crs_strlen>
 8002c28:	b283      	uxth	r3, r0
 8002c2a:	4622      	mov	r2, r4
 8002c2c:	2104      	movs	r1, #4
 8002c2e:	2002      	movs	r0, #2
 8002c30:	f01c fbe0 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for GETCFG or GETACFG */
  if (type1sc_shared.getcfg_function == SETGETCFG_UART_FLOW_CONTROL)
 8002c34:	4b3f      	ldr	r3, [pc, #252]	; (8002d34 <fCmdpAnalyze_GETCFG_TYPE1SC+0x154>)
 8002c36:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8002c3a:	2b09      	cmp	r3, #9
 8002c3c:	d002      	beq.n	8002c44 <fCmdpAnalyze_GETCFG_TYPE1SC+0x64>
      p_modem_ctxt->persist.flowCtrl_CTS = 0U;
    }
  }

  return (retval);
}
 8002c3e:	2008      	movs	r0, #8
 8002c40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32_t hwFC_status = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8002c44:	8978      	ldrh	r0, [r7, #10]
 8002c46:	89f9      	ldrh	r1, [r7, #14]
 8002c48:	4440      	add	r0, r8
 8002c4a:	f012 f873 	bl	8014d34 <ATutil_convertStringToInt>
 8002c4e:	4605      	mov	r5, r0
    PRINT_DBG("GETCFG/GETACFG: Hw Flow Control setting = %ld", hwFC_status)
 8002c50:	4602      	mov	r2, r0
 8002c52:	4939      	ldr	r1, [pc, #228]	; (8002d38 <fCmdpAnalyze_GETCFG_TYPE1SC+0x158>)
 8002c54:	4620      	mov	r0, r4
 8002c56:	f023 fdf7 	bl	8026848 <sprintf>
 8002c5a:	4620      	mov	r0, r4
 8002c5c:	f01c fb65 	bl	801f32a <crs_strlen>
 8002c60:	b283      	uxth	r3, r0
 8002c62:	4622      	mov	r2, r4
 8002c64:	2102      	movs	r1, #2
 8002c66:	4608      	mov	r0, r1
 8002c68:	f01c fba2 	bl	801f3b0 <traceIF_itmPrint>
 8002c6c:	4620      	mov	r0, r4
 8002c6e:	f01c fb5c 	bl	801f32a <crs_strlen>
 8002c72:	b283      	uxth	r3, r0
 8002c74:	4622      	mov	r2, r4
 8002c76:	2102      	movs	r1, #2
 8002c78:	4608      	mov	r0, r1
 8002c7a:	f01c fbbb 	bl	801f3f4 <traceIF_uartPrint>
    if (hwFC_status == 1U)
 8002c7e:	2d01      	cmp	r5, #1
 8002c80:	d02b      	beq.n	8002cda <fCmdpAnalyze_GETCFG_TYPE1SC+0xfa>
      PRINT_DBG("Hw Flow Control setting is OFF")
 8002c82:	4d2e      	ldr	r5, [pc, #184]	; (8002d3c <fCmdpAnalyze_GETCFG_TYPE1SC+0x15c>)
 8002c84:	4c2a      	ldr	r4, [pc, #168]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002c86:	f105 0c20 	add.w	ip, r5, #32
 8002c8a:	462f      	mov	r7, r5
 8002c8c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8002c8e:	6020      	str	r0, [r4, #0]
 8002c90:	6061      	str	r1, [r4, #4]
 8002c92:	60a2      	str	r2, [r4, #8]
 8002c94:	60e3      	str	r3, [r4, #12]
 8002c96:	463d      	mov	r5, r7
 8002c98:	3410      	adds	r4, #16
 8002c9a:	4567      	cmp	r7, ip
 8002c9c:	d1f5      	bne.n	8002c8a <fCmdpAnalyze_GETCFG_TYPE1SC+0xaa>
 8002c9e:	cd03      	ldmia	r5!, {r0, r1}
 8002ca0:	6020      	str	r0, [r4, #0]
 8002ca2:	6061      	str	r1, [r4, #4]
 8002ca4:	782b      	ldrb	r3, [r5, #0]
 8002ca6:	7223      	strb	r3, [r4, #8]
 8002ca8:	4c21      	ldr	r4, [pc, #132]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002caa:	4620      	mov	r0, r4
 8002cac:	f01c fb3d 	bl	801f32a <crs_strlen>
 8002cb0:	b283      	uxth	r3, r0
 8002cb2:	4622      	mov	r2, r4
 8002cb4:	2102      	movs	r1, #2
 8002cb6:	4608      	mov	r0, r1
 8002cb8:	f01c fb7a 	bl	801f3b0 <traceIF_itmPrint>
 8002cbc:	4620      	mov	r0, r4
 8002cbe:	f01c fb34 	bl	801f32a <crs_strlen>
 8002cc2:	b283      	uxth	r3, r0
 8002cc4:	4622      	mov	r2, r4
 8002cc6:	2102      	movs	r1, #2
 8002cc8:	4608      	mov	r0, r1
 8002cca:	f01c fb93 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->persist.flowCtrl_RTS = 0U;
 8002cce:	2300      	movs	r3, #0
 8002cd0:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
      p_modem_ctxt->persist.flowCtrl_CTS = 0U;
 8002cd4:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 8002cd8:	e7b1      	b.n	8002c3e <fCmdpAnalyze_GETCFG_TYPE1SC+0x5e>
      PRINT_DBG("Hw Flow Control setting is ON")
 8002cda:	4f19      	ldr	r7, [pc, #100]	; (8002d40 <fCmdpAnalyze_GETCFG_TYPE1SC+0x160>)
 8002cdc:	f107 0c20 	add.w	ip, r7, #32
 8002ce0:	463d      	mov	r5, r7
 8002ce2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002ce4:	6020      	str	r0, [r4, #0]
 8002ce6:	6061      	str	r1, [r4, #4]
 8002ce8:	60a2      	str	r2, [r4, #8]
 8002cea:	60e3      	str	r3, [r4, #12]
 8002cec:	462f      	mov	r7, r5
 8002cee:	3410      	adds	r4, #16
 8002cf0:	4565      	cmp	r5, ip
 8002cf2:	d1f5      	bne.n	8002ce0 <fCmdpAnalyze_GETCFG_TYPE1SC+0x100>
 8002cf4:	cf03      	ldmia	r7!, {r0, r1}
 8002cf6:	6020      	str	r0, [r4, #0]
 8002cf8:	6061      	str	r1, [r4, #4]
 8002cfa:	4c0d      	ldr	r4, [pc, #52]	; (8002d30 <fCmdpAnalyze_GETCFG_TYPE1SC+0x150>)
 8002cfc:	4620      	mov	r0, r4
 8002cfe:	f01c fb14 	bl	801f32a <crs_strlen>
 8002d02:	b283      	uxth	r3, r0
 8002d04:	4622      	mov	r2, r4
 8002d06:	2102      	movs	r1, #2
 8002d08:	4608      	mov	r0, r1
 8002d0a:	f01c fb51 	bl	801f3b0 <traceIF_itmPrint>
 8002d0e:	4620      	mov	r0, r4
 8002d10:	f01c fb0b 	bl	801f32a <crs_strlen>
 8002d14:	b283      	uxth	r3, r0
 8002d16:	4622      	mov	r2, r4
 8002d18:	2102      	movs	r1, #2
 8002d1a:	4608      	mov	r0, r1
 8002d1c:	f01c fb6a 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->persist.flowCtrl_RTS = 2U;
 8002d20:	2302      	movs	r3, #2
 8002d22:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
      p_modem_ctxt->persist.flowCtrl_CTS = 2U;
 8002d26:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 8002d2a:	e788      	b.n	8002c3e <fCmdpAnalyze_GETCFG_TYPE1SC+0x5e>
 8002d2c:	0802b6b0 	.word	0x0802b6b0
 8002d30:	200048dc 	.word	0x200048dc
 8002d34:	20001838 	.word	0x20001838
 8002d38:	0802b6e4 	.word	0x0802b6e4
 8002d3c:	0802b744 	.word	0x0802b744
 8002d40:	0802b71c 	.word	0x0802b71c

08002d44 <convertToASCII>:
  */
static uint8_t convertToASCII(uint8_t nbr)
{
  uint8_t ascii;

  if (nbr <= 9U)
 8002d44:	2809      	cmp	r0, #9
 8002d46:	d802      	bhi.n	8002d4e <convertToASCII+0xa>
  {
    ascii = nbr + 48U;
 8002d48:	3030      	adds	r0, #48	; 0x30
 8002d4a:	b2c0      	uxtb	r0, r0
 8002d4c:	4770      	bx	lr
  }
  else
  {
    ascii = nbr + 87U; /* 87 = 97 -10 (where 97 correspond to 'a') */
 8002d4e:	3057      	adds	r0, #87	; 0x57
 8002d50:	b2c0      	uxtb	r0, r0
  }
  return (ascii);
}
 8002d52:	4770      	bx	lr

08002d54 <convertCharToHEX>:
  * @param  p_msb ptr to Most significant Digit of HEX value
  * @param  p_lsb ptr to Less significant Digit of HEX value
  * @retval none.
  */
static void convertCharToHEX(uint8_t val, uint8_t *p_msd, uint8_t *p_lsd)
{
 8002d54:	b570      	push	{r4, r5, r6, lr}
 8002d56:	4604      	mov	r4, r0
 8002d58:	460e      	mov	r6, r1
 8002d5a:	4615      	mov	r5, r2
  *p_msd = convertToASCII(val / 16U);
 8002d5c:	0900      	lsrs	r0, r0, #4
 8002d5e:	f7ff fff1 	bl	8002d44 <convertToASCII>
 8002d62:	7030      	strb	r0, [r6, #0]
  *p_lsd = convertToASCII(val % 16U);
 8002d64:	f004 000f 	and.w	r0, r4, #15
 8002d68:	f7ff ffec 	bl	8002d44 <convertToASCII>
 8002d6c:	7028      	strb	r0, [r5, #0]
}
 8002d6e:	bd70      	pop	{r4, r5, r6, pc}

08002d70 <convertDigitToValue>:
  */
static at_status_t convertDigitToValue(uint8_t digit, uint8_t *p_res)
{
  at_status_t retval = ATSTATUS_OK;

  if ((digit >= 48U) && (digit <= 57U))
 8002d70:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 8002d74:	b2db      	uxtb	r3, r3
 8002d76:	2b09      	cmp	r3, #9
 8002d78:	d802      	bhi.n	8002d80 <convertDigitToValue+0x10>
  {
    /* 0 to 9 */
    *p_res = digit - 48U;
 8002d7a:	700b      	strb	r3, [r1, #0]
  at_status_t retval = ATSTATUS_OK;
 8002d7c:	2000      	movs	r0, #0
 8002d7e:	4770      	bx	lr
  }
  else if ((digit >= 97U) && (digit <= 102U))
 8002d80:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 8002d84:	b2db      	uxtb	r3, r3
 8002d86:	2b05      	cmp	r3, #5
 8002d88:	d803      	bhi.n	8002d92 <convertDigitToValue+0x22>
  {
    /* a to f */
    *p_res = digit - 87U; /* 87 = -97+10 */
 8002d8a:	3857      	subs	r0, #87	; 0x57
 8002d8c:	7008      	strb	r0, [r1, #0]
  at_status_t retval = ATSTATUS_OK;
 8002d8e:	2000      	movs	r0, #0
 8002d90:	4770      	bx	lr
  }
  else if ((digit >= 65U) && (digit <= 70U))
 8002d92:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 8002d96:	b2db      	uxtb	r3, r3
 8002d98:	2b05      	cmp	r3, #5
 8002d9a:	d803      	bhi.n	8002da4 <convertDigitToValue+0x34>
  {
    /* A to F */
    *p_res = digit - 55U; /* 55 = -65+10*/
 8002d9c:	3837      	subs	r0, #55	; 0x37
 8002d9e:	7008      	strb	r0, [r1, #0]
  at_status_t retval = ATSTATUS_OK;
 8002da0:	2000      	movs	r0, #0
 8002da2:	4770      	bx	lr
  }
  else
  {
    *p_res = 0;
 8002da4:	2300      	movs	r3, #0
 8002da6:	700b      	strb	r3, [r1, #0]
    retval = ATSTATUS_ERROR;
 8002da8:	2001      	movs	r0, #1
  }
  return (retval);
}
 8002daa:	4770      	bx	lr

08002dac <convertHEXToChar>:
  * @param  lsd Less significant Digit of HEX value.
  * @param  p_conv ptr to converted Character value.
  * @retval at_status_t.
  */
static at_status_t convertHEXToChar(uint8_t msd, uint8_t lsd, uint8_t *p_conv)
{
 8002dac:	b530      	push	{r4, r5, lr}
 8002dae:	b083      	sub	sp, #12
 8002db0:	460c      	mov	r4, r1
 8002db2:	4615      	mov	r5, r2
  at_status_t retval = ATSTATUS_OK;
  uint8_t convMSD;
  uint8_t convLSD;

  /* convert Most significant digit */
  if (convertDigitToValue(msd, &convMSD) == ATSTATUS_OK)
 8002db4:	f10d 0107 	add.w	r1, sp, #7
 8002db8:	f7ff ffda 	bl	8002d70 <convertDigitToValue>
 8002dbc:	b110      	cbz	r0, 8002dc4 <convertHEXToChar+0x18>
      retval = ATSTATUS_ERROR;
    }
  }
  else
  {
    retval = ATSTATUS_ERROR;
 8002dbe:	2001      	movs	r0, #1
  }
  return (retval);
}
 8002dc0:	b003      	add	sp, #12
 8002dc2:	bd30      	pop	{r4, r5, pc}
    if (convertDigitToValue(lsd, &convLSD) == ATSTATUS_OK)
 8002dc4:	f10d 0106 	add.w	r1, sp, #6
 8002dc8:	4620      	mov	r0, r4
 8002dca:	f7ff ffd1 	bl	8002d70 <convertDigitToValue>
 8002dce:	b940      	cbnz	r0, 8002de2 <convertHEXToChar+0x36>
      *p_conv = (convMSD << 4) + convLSD;
 8002dd0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002dd4:	011b      	lsls	r3, r3, #4
 8002dd6:	b2db      	uxtb	r3, r3
 8002dd8:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8002ddc:	4413      	add	r3, r2
 8002dde:	702b      	strb	r3, [r5, #0]
 8002de0:	e7ee      	b.n	8002dc0 <convertHEXToChar+0x14>
      retval = ATSTATUS_ERROR;
 8002de2:	2001      	movs	r0, #1
 8002de4:	e7ec      	b.n	8002dc0 <convertHEXToChar+0x14>
	...

08002de8 <fCmdBuild_PDNACT>:
{
 8002de8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002dec:	4606      	mov	r6, r0
 8002dee:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_PDNACT()")
 8002df0:	4d34      	ldr	r5, [pc, #208]	; (8002ec4 <fCmdBuild_PDNACT+0xdc>)
 8002df2:	4c35      	ldr	r4, [pc, #212]	; (8002ec8 <fCmdBuild_PDNACT+0xe0>)
 8002df4:	f105 0e20 	add.w	lr, r5, #32
 8002df8:	46ac      	mov	ip, r5
 8002dfa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002dfe:	6020      	str	r0, [r4, #0]
 8002e00:	6061      	str	r1, [r4, #4]
 8002e02:	60a2      	str	r2, [r4, #8]
 8002e04:	60e3      	str	r3, [r4, #12]
 8002e06:	4665      	mov	r5, ip
 8002e08:	3410      	adds	r4, #16
 8002e0a:	45f4      	cmp	ip, lr
 8002e0c:	d1f4      	bne.n	8002df8 <fCmdBuild_PDNACT+0x10>
 8002e0e:	f8dc 0000 	ldr.w	r0, [ip]
 8002e12:	6020      	str	r0, [r4, #0]
 8002e14:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8002e18:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8002e1c:	80a2      	strh	r2, [r4, #4]
 8002e1e:	71a3      	strb	r3, [r4, #6]
 8002e20:	4c29      	ldr	r4, [pc, #164]	; (8002ec8 <fCmdBuild_PDNACT+0xe0>)
 8002e22:	4620      	mov	r0, r4
 8002e24:	f01c fa81 	bl	801f32a <crs_strlen>
 8002e28:	b283      	uxth	r3, r0
 8002e2a:	4622      	mov	r2, r4
 8002e2c:	2104      	movs	r1, #4
 8002e2e:	2002      	movs	r0, #2
 8002e30:	f01c fabe 	bl	801f3b0 <traceIF_itmPrint>
 8002e34:	4620      	mov	r0, r4
 8002e36:	f01c fa78 	bl	801f32a <crs_strlen>
 8002e3a:	b283      	uxth	r3, r0
 8002e3c:	4622      	mov	r2, r4
 8002e3e:	2104      	movs	r1, #4
 8002e40:	2002      	movs	r0, #2
 8002e42:	f01c fad7 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002e46:	8933      	ldrh	r3, [r6, #8]
 8002e48:	2b03      	cmp	r3, #3
 8002e4a:	d002      	beq.n	8002e52 <fCmdBuild_PDNACT+0x6a>
}
 8002e4c:	2000      	movs	r0, #0
 8002e4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 8002e52:	4638      	mov	r0, r7
 8002e54:	f009 fd2e 	bl	800c8b4 <atcm_get_cid_current_SID>
 8002e58:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 8002e5a:	4601      	mov	r1, r0
 8002e5c:	f107 000c 	add.w	r0, r7, #12
 8002e60:	f00a fdb0 	bl	800d9c4 <atcm_get_affected_modem_cid>
 8002e64:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 8002e66:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 8002e6a:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 8002e6e:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 8002e72:	2b0c      	cmp	r3, #12
 8002e74:	d00c      	beq.n	8002e90 <fCmdBuild_PDNACT+0xa8>
                   ((p_modem_ctxt->CMD_ctxt.pdn_state == PDN_STATE_ACTIVATE) ? 1 : 0),
 8002e76:	f897 2731 	ldrb.w	r2, [r7, #1841]	; 0x731
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d",
 8002e7a:	462b      	mov	r3, r5
 8002e7c:	2a01      	cmp	r2, #1
 8002e7e:	bf14      	ite	ne
 8002e80:	2200      	movne	r2, #0
 8002e82:	2201      	moveq	r2, #1
 8002e84:	4911      	ldr	r1, [pc, #68]	; (8002ecc <fCmdBuild_PDNACT+0xe4>)
 8002e86:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8002e8a:	f023 fcdd 	bl	8026848 <sprintf>
 8002e8e:	e7dd      	b.n	8002e4c <fCmdBuild_PDNACT+0x64>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 8002e90:	f8df 8034 	ldr.w	r8, [pc, #52]	; 8002ec8 <fCmdBuild_PDNACT+0xe0>
 8002e94:	4622      	mov	r2, r4
 8002e96:	490e      	ldr	r1, [pc, #56]	; (8002ed0 <fCmdBuild_PDNACT+0xe8>)
 8002e98:	4640      	mov	r0, r8
 8002e9a:	f023 fcd5 	bl	8026848 <sprintf>
 8002e9e:	4640      	mov	r0, r8
 8002ea0:	f01c fa43 	bl	801f32a <crs_strlen>
 8002ea4:	b283      	uxth	r3, r0
 8002ea6:	4642      	mov	r2, r8
 8002ea8:	2101      	movs	r1, #1
 8002eaa:	2002      	movs	r0, #2
 8002eac:	f01c fa80 	bl	801f3b0 <traceIF_itmPrint>
 8002eb0:	4640      	mov	r0, r8
 8002eb2:	f01c fa3a 	bl	801f32a <crs_strlen>
 8002eb6:	b283      	uxth	r3, r0
 8002eb8:	4642      	mov	r2, r8
 8002eba:	2101      	movs	r1, #1
 8002ebc:	2002      	movs	r0, #2
 8002ebe:	f01c fa99 	bl	801f3f4 <traceIF_uartPrint>
 8002ec2:	e7d8      	b.n	8002e76 <fCmdBuild_PDNACT+0x8e>
 8002ec4:	0802b770 	.word	0x0802b770
 8002ec8:	200048dc 	.word	0x200048dc
 8002ecc:	0802b7ec 	.word	0x0802b7ec
 8002ed0:	0802b798 	.word	0x0802b798

08002ed4 <fCmdBuild_SOCKETCMD_ALLOCATE>:
{
 8002ed4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ed6:	b087      	sub	sp, #28
 8002ed8:	4606      	mov	r6, r0
 8002eda:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_ALLOCATE()")
 8002edc:	4d5a      	ldr	r5, [pc, #360]	; (8003048 <fCmdBuild_SOCKETCMD_ALLOCATE+0x174>)
 8002ede:	4c5b      	ldr	r4, [pc, #364]	; (800304c <fCmdBuild_SOCKETCMD_ALLOCATE+0x178>)
 8002ee0:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8002ee4:	46ac      	mov	ip, r5
 8002ee6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8002eea:	6020      	str	r0, [r4, #0]
 8002eec:	6061      	str	r1, [r4, #4]
 8002eee:	60a2      	str	r2, [r4, #8]
 8002ef0:	60e3      	str	r3, [r4, #12]
 8002ef2:	4665      	mov	r5, ip
 8002ef4:	3410      	adds	r4, #16
 8002ef6:	45f4      	cmp	ip, lr
 8002ef8:	d1f4      	bne.n	8002ee4 <fCmdBuild_SOCKETCMD_ALLOCATE+0x10>
 8002efa:	f8bc 2000 	ldrh.w	r2, [ip]
 8002efe:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8002f02:	8022      	strh	r2, [r4, #0]
 8002f04:	70a3      	strb	r3, [r4, #2]
 8002f06:	4c51      	ldr	r4, [pc, #324]	; (800304c <fCmdBuild_SOCKETCMD_ALLOCATE+0x178>)
 8002f08:	4620      	mov	r0, r4
 8002f0a:	f01c fa0e 	bl	801f32a <crs_strlen>
 8002f0e:	b283      	uxth	r3, r0
 8002f10:	4622      	mov	r2, r4
 8002f12:	2104      	movs	r1, #4
 8002f14:	2002      	movs	r0, #2
 8002f16:	f01c fa4b 	bl	801f3b0 <traceIF_itmPrint>
 8002f1a:	4620      	mov	r0, r4
 8002f1c:	f01c fa05 	bl	801f32a <crs_strlen>
 8002f20:	b283      	uxth	r3, r0
 8002f22:	4622      	mov	r2, r4
 8002f24:	2104      	movs	r1, #4
 8002f26:	2002      	movs	r0, #2
 8002f28:	f01c fa64 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8002f2c:	8933      	ldrh	r3, [r6, #8]
 8002f2e:	2b03      	cmp	r3, #3
 8002f30:	d002      	beq.n	8002f38 <fCmdBuild_SOCKETCMD_ALLOCATE+0x64>
}
 8002f32:	2000      	movs	r0, #0
 8002f34:	b007      	add	sp, #28
 8002f36:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 8002f38:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 8002f3c:	2b00      	cmp	r3, #0
 8002f3e:	d06a      	beq.n	8003016 <fCmdBuild_SOCKETCMD_ALLOCATE+0x142>
      uint8_t pdp_modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist,
 8002f40:	7b19      	ldrb	r1, [r3, #12]
 8002f42:	f107 000c 	add.w	r0, r7, #12
 8002f46:	f00a fd3d 	bl	800d9c4 <atcm_get_affected_modem_cid>
 8002f4a:	4605      	mov	r5, r0
      PRINT_INFO("user cid = %d, PDP modem cid = %d", (uint8_t)p_modem_ctxt->socket_ctxt.socket_info->conf_id,
 8002f4c:	f8d7 2740 	ldr.w	r2, [r7, #1856]	; 0x740
 8002f50:	4603      	mov	r3, r0
 8002f52:	7b12      	ldrb	r2, [r2, #12]
 8002f54:	493e      	ldr	r1, [pc, #248]	; (8003050 <fCmdBuild_SOCKETCMD_ALLOCATE+0x17c>)
 8002f56:	4620      	mov	r0, r4
 8002f58:	f023 fc76 	bl	8026848 <sprintf>
 8002f5c:	4620      	mov	r0, r4
 8002f5e:	f01c f9e4 	bl	801f32a <crs_strlen>
 8002f62:	b283      	uxth	r3, r0
 8002f64:	4622      	mov	r2, r4
 8002f66:	2101      	movs	r1, #1
 8002f68:	2002      	movs	r0, #2
 8002f6a:	f01c fa21 	bl	801f3b0 <traceIF_itmPrint>
 8002f6e:	4620      	mov	r0, r4
 8002f70:	f01c f9db 	bl	801f32a <crs_strlen>
 8002f74:	b283      	uxth	r3, r0
 8002f76:	4622      	mov	r2, r4
 8002f78:	2101      	movs	r1, #1
 8002f7a:	2002      	movs	r0, #2
 8002f7c:	f01c fa3a 	bl	801f3f4 <traceIF_uartPrint>
      if (strcmp((CRC_CHAR_t const *)p_modem_ctxt->socket_ctxt.socket_info->ip_addr_value,
 8002f80:	f8d7 4740 	ldr.w	r4, [r7, #1856]	; 0x740
 8002f84:	f104 070e 	add.w	r7, r4, #14
 8002f88:	4932      	ldr	r1, [pc, #200]	; (8003054 <fCmdBuild_SOCKETCMD_ALLOCATE+0x180>)
 8002f8a:	4638      	mov	r0, r7
 8002f8c:	f7fd f928 	bl	80001e0 <strcmp>
 8002f90:	b918      	cbnz	r0, 8002f9a <fCmdBuild_SOCKETCMD_ALLOCATE+0xc6>
        service_type_index = ((p_modem_ctxt->socket_ctxt.socket_info->protocol) == CS_TCP_PROTOCOL) ? \
 8002f92:	7a63      	ldrb	r3, [r4, #9]
 8002f94:	bb1b      	cbnz	r3, 8002fde <fCmdBuild_SOCKETCMD_ALLOCATE+0x10a>
 8002f96:	2202      	movs	r2, #2
 8002f98:	e003      	b.n	8002fa2 <fCmdBuild_SOCKETCMD_ALLOCATE+0xce>
        service_type_index = ((p_modem_ctxt->socket_ctxt.socket_info->protocol) == CS_TCP_PROTOCOL) ? \
 8002f9a:	7a62      	ldrb	r2, [r4, #9]
                             ATSOCKET_SERVICETYPE_TCP_CLIENT : ATSOCKET_SERVICETYPE_UDP_CLIENT;
 8002f9c:	3a00      	subs	r2, #0
 8002f9e:	bf18      	it	ne
 8002fa0:	2201      	movne	r2, #1
          || (service_type_index == ATSOCKET_SERVICETYPE_UDP_SERVICE))
 8002fa2:	1e93      	subs	r3, r2, #2
 8002fa4:	b2db      	uxtb	r3, r3
      if ((service_type_index == ATSOCKET_SERVICETYPE_TCP_SERVER)
 8002fa6:	2b01      	cmp	r3, #1
 8002fa8:	d91b      	bls.n	8002fe2 <fCmdBuild_SOCKETCMD_ALLOCATE+0x10e>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8002faa:	f106 0030 	add.w	r0, r6, #48	; 0x30
                       ((p_modem_ctxt->socket_ctxt.socket_info->protocol == CS_TCP_PROTOCOL) ? "TCP" : "UDP"),
 8002fae:	7a63      	ldrb	r3, [r4, #9]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8002fb0:	2b00      	cmp	r3, #0
 8002fb2:	d12e      	bne.n	8003012 <fCmdBuild_SOCKETCMD_ALLOCATE+0x13e>
 8002fb4:	4b28      	ldr	r3, [pc, #160]	; (8003058 <fCmdBuild_SOCKETCMD_ALLOCATE+0x184>)
                       type1sc_array_ALLOCATE_service_type[service_type_index],
 8002fb6:	4929      	ldr	r1, [pc, #164]	; (800305c <fCmdBuild_SOCKETCMD_ALLOCATE+0x188>)
 8002fb8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
                       p_modem_ctxt->socket_ctxt.socket_info->remote_port,
 8002fbc:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
                       p_modem_ctxt->socket_ctxt.socket_info->local_port,
 8002fc0:	8964      	ldrh	r4, [r4, #10]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8002fc2:	f240 26c6 	movw	r6, #710	; 0x2c6
 8002fc6:	9605      	str	r6, [sp, #20]
 8002fc8:	9404      	str	r4, [sp, #16]
 8002fca:	9103      	str	r1, [sp, #12]
 8002fcc:	9702      	str	r7, [sp, #8]
 8002fce:	9201      	str	r2, [sp, #4]
 8002fd0:	9300      	str	r3, [sp, #0]
 8002fd2:	462b      	mov	r3, r5
 8002fd4:	4a22      	ldr	r2, [pc, #136]	; (8003060 <fCmdBuild_SOCKETCMD_ALLOCATE+0x18c>)
 8002fd6:	4923      	ldr	r1, [pc, #140]	; (8003064 <fCmdBuild_SOCKETCMD_ALLOCATE+0x190>)
 8002fd8:	f023 fc36 	bl	8026848 <sprintf>
 8002fdc:	e7a9      	b.n	8002f32 <fCmdBuild_SOCKETCMD_ALLOCATE+0x5e>
        service_type_index = ((p_modem_ctxt->socket_ctxt.socket_info->protocol) == CS_TCP_PROTOCOL) ? \
 8002fde:	2203      	movs	r2, #3
 8002fe0:	e7df      	b.n	8002fa2 <fCmdBuild_SOCKETCMD_ALLOCATE+0xce>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",,%d,%ld",
 8002fe2:	f106 0030 	add.w	r0, r6, #48	; 0x30
                       ((p_modem_ctxt->socket_ctxt.socket_info->protocol == CS_TCP_PROTOCOL) ? "TCP" : "UDP"),
 8002fe6:	7a63      	ldrb	r3, [r4, #9]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",,%d,%ld",
 8002fe8:	b98b      	cbnz	r3, 800300e <fCmdBuild_SOCKETCMD_ALLOCATE+0x13a>
 8002fea:	4e1b      	ldr	r6, [pc, #108]	; (8003058 <fCmdBuild_SOCKETCMD_ALLOCATE+0x184>)
                       type1sc_array_ALLOCATE_service_type[service_type_index],
 8002fec:	4b1b      	ldr	r3, [pc, #108]	; (800305c <fCmdBuild_SOCKETCMD_ALLOCATE+0x188>)
 8002fee:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
                       p_modem_ctxt->socket_ctxt.socket_info->local_port,
 8002ff2:	8962      	ldrh	r2, [r4, #10]
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",,%d,%ld",
 8002ff4:	f240 21c6 	movw	r1, #710	; 0x2c6
 8002ff8:	9104      	str	r1, [sp, #16]
 8002ffa:	9203      	str	r2, [sp, #12]
 8002ffc:	9702      	str	r7, [sp, #8]
 8002ffe:	9301      	str	r3, [sp, #4]
 8003000:	9600      	str	r6, [sp, #0]
 8003002:	462b      	mov	r3, r5
 8003004:	4a16      	ldr	r2, [pc, #88]	; (8003060 <fCmdBuild_SOCKETCMD_ALLOCATE+0x18c>)
 8003006:	4918      	ldr	r1, [pc, #96]	; (8003068 <fCmdBuild_SOCKETCMD_ALLOCATE+0x194>)
 8003008:	f023 fc1e 	bl	8026848 <sprintf>
 800300c:	e791      	b.n	8002f32 <fCmdBuild_SOCKETCMD_ALLOCATE+0x5e>
 800300e:	4e17      	ldr	r6, [pc, #92]	; (800306c <fCmdBuild_SOCKETCMD_ALLOCATE+0x198>)
 8003010:	e7ec      	b.n	8002fec <fCmdBuild_SOCKETCMD_ALLOCATE+0x118>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%d,\"%s\",\"%s\",\"%s\",%d,%d,%ld",
 8003012:	4b16      	ldr	r3, [pc, #88]	; (800306c <fCmdBuild_SOCKETCMD_ALLOCATE+0x198>)
 8003014:	e7cf      	b.n	8002fb6 <fCmdBuild_SOCKETCMD_ALLOCATE+0xe2>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_ALLOCATE")
 8003016:	4c0d      	ldr	r4, [pc, #52]	; (800304c <fCmdBuild_SOCKETCMD_ALLOCATE+0x178>)
 8003018:	2243      	movs	r2, #67	; 0x43
 800301a:	4915      	ldr	r1, [pc, #84]	; (8003070 <fCmdBuild_SOCKETCMD_ALLOCATE+0x19c>)
 800301c:	4620      	mov	r0, r4
 800301e:	f023 fd63 	bl	8026ae8 <memcpy>
 8003022:	4620      	mov	r0, r4
 8003024:	f01c f981 	bl	801f32a <crs_strlen>
 8003028:	b283      	uxth	r3, r0
 800302a:	4622      	mov	r2, r4
 800302c:	2110      	movs	r1, #16
 800302e:	2002      	movs	r0, #2
 8003030:	f01c f9be 	bl	801f3b0 <traceIF_itmPrint>
 8003034:	4620      	mov	r0, r4
 8003036:	f01c f978 	bl	801f32a <crs_strlen>
 800303a:	b283      	uxth	r3, r0
 800303c:	4622      	mov	r2, r4
 800303e:	2110      	movs	r1, #16
 8003040:	2002      	movs	r0, #2
 8003042:	f01c f9d7 	bl	801f3f4 <traceIF_uartPrint>
 8003046:	e774      	b.n	8002f32 <fCmdBuild_SOCKETCMD_ALLOCATE+0x5e>
 8003048:	0802b7fc 	.word	0x0802b7fc
 800304c:	200048dc 	.word	0x200048dc
 8003050:	0802b830 	.word	0x0802b830
 8003054:	0802b85c 	.word	0x0802b85c
 8003058:	0802b7f4 	.word	0x0802b7f4
 800305c:	0802c388 	.word	0x0802c388
 8003060:	0802b864 	.word	0x0802b864
 8003064:	0802b890 	.word	0x0802b890
 8003068:	0802b870 	.word	0x0802b870
 800306c:	0802b7f8 	.word	0x0802b7f8
 8003070:	0802b8b4 	.word	0x0802b8b4

08003074 <fCmdBuild_SOCKETCMD_ACTIVATE>:
{
 8003074:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003076:	4606      	mov	r6, r0
 8003078:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_ACTIVATE()")
 800307a:	4d2a      	ldr	r5, [pc, #168]	; (8003124 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb0>)
 800307c:	4c2a      	ldr	r4, [pc, #168]	; (8003128 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb4>)
 800307e:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8003082:	46ac      	mov	ip, r5
 8003084:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003088:	6020      	str	r0, [r4, #0]
 800308a:	6061      	str	r1, [r4, #4]
 800308c:	60a2      	str	r2, [r4, #8]
 800308e:	60e3      	str	r3, [r4, #12]
 8003090:	4665      	mov	r5, ip
 8003092:	3410      	adds	r4, #16
 8003094:	45f4      	cmp	ip, lr
 8003096:	d1f4      	bne.n	8003082 <fCmdBuild_SOCKETCMD_ACTIVATE+0xe>
 8003098:	f8bc 2000 	ldrh.w	r2, [ip]
 800309c:	f89c 3002 	ldrb.w	r3, [ip, #2]
 80030a0:	8022      	strh	r2, [r4, #0]
 80030a2:	70a3      	strb	r3, [r4, #2]
 80030a4:	4c20      	ldr	r4, [pc, #128]	; (8003128 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb4>)
 80030a6:	4620      	mov	r0, r4
 80030a8:	f01c f93f 	bl	801f32a <crs_strlen>
 80030ac:	b283      	uxth	r3, r0
 80030ae:	4622      	mov	r2, r4
 80030b0:	2104      	movs	r1, #4
 80030b2:	2002      	movs	r0, #2
 80030b4:	f01c f97c 	bl	801f3b0 <traceIF_itmPrint>
 80030b8:	4620      	mov	r0, r4
 80030ba:	f01c f936 	bl	801f32a <crs_strlen>
 80030be:	b283      	uxth	r3, r0
 80030c0:	4622      	mov	r2, r4
 80030c2:	2104      	movs	r1, #4
 80030c4:	2002      	movs	r0, #2
 80030c6:	f01c f995 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80030ca:	8933      	ldrh	r3, [r6, #8]
 80030cc:	2b03      	cmp	r3, #3
 80030ce:	d001      	beq.n	80030d4 <fCmdBuild_SOCKETCMD_ACTIVATE+0x60>
}
 80030d0:	2000      	movs	r0, #0
 80030d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 80030d4:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 80030d8:	b15b      	cbz	r3, 80030f2 <fCmdBuild_SOCKETCMD_ACTIVATE+0x7e>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 80030da:	6819      	ldr	r1, [r3, #0]
 80030dc:	4638      	mov	r0, r7
 80030de:	f011 f845 	bl	801416c <atcm_socket_get_modem_cid>
 80030e2:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 80030e4:	4a11      	ldr	r2, [pc, #68]	; (800312c <fCmdBuild_SOCKETCMD_ACTIVATE+0xb8>)
 80030e6:	4912      	ldr	r1, [pc, #72]	; (8003130 <fCmdBuild_SOCKETCMD_ACTIVATE+0xbc>)
 80030e8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80030ec:	f023 fbac 	bl	8026848 <sprintf>
 80030f0:	e7ee      	b.n	80030d0 <fCmdBuild_SOCKETCMD_ACTIVATE+0x5c>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_ACTIVATE")
 80030f2:	4c0d      	ldr	r4, [pc, #52]	; (8003128 <fCmdBuild_SOCKETCMD_ACTIVATE+0xb4>)
 80030f4:	2243      	movs	r2, #67	; 0x43
 80030f6:	490f      	ldr	r1, [pc, #60]	; (8003134 <fCmdBuild_SOCKETCMD_ACTIVATE+0xc0>)
 80030f8:	4620      	mov	r0, r4
 80030fa:	f023 fcf5 	bl	8026ae8 <memcpy>
 80030fe:	4620      	mov	r0, r4
 8003100:	f01c f913 	bl	801f32a <crs_strlen>
 8003104:	b283      	uxth	r3, r0
 8003106:	4622      	mov	r2, r4
 8003108:	2110      	movs	r1, #16
 800310a:	2002      	movs	r0, #2
 800310c:	f01c f950 	bl	801f3b0 <traceIF_itmPrint>
 8003110:	4620      	mov	r0, r4
 8003112:	f01c f90a 	bl	801f32a <crs_strlen>
 8003116:	b283      	uxth	r3, r0
 8003118:	4622      	mov	r2, r4
 800311a:	2110      	movs	r1, #16
 800311c:	2002      	movs	r0, #2
 800311e:	f01c f969 	bl	801f3f4 <traceIF_uartPrint>
 8003122:	e7d5      	b.n	80030d0 <fCmdBuild_SOCKETCMD_ACTIVATE+0x5c>
 8003124:	0802b8f8 	.word	0x0802b8f8
 8003128:	200048dc 	.word	0x200048dc
 800312c:	0802b92c 	.word	0x0802b92c
 8003130:	0802b938 	.word	0x0802b938
 8003134:	0802b944 	.word	0x0802b944

08003138 <fCmdBuild_SOCKETCMD_INFO>:
{
 8003138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800313a:	4606      	mov	r6, r0
 800313c:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_INFO()")
 800313e:	4c35      	ldr	r4, [pc, #212]	; (8003214 <fCmdBuild_SOCKETCMD_INFO+0xdc>)
 8003140:	4d35      	ldr	r5, [pc, #212]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 8003142:	f104 0e20 	add.w	lr, r4, #32
 8003146:	46a4      	mov	ip, r4
 8003148:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800314c:	6028      	str	r0, [r5, #0]
 800314e:	6069      	str	r1, [r5, #4]
 8003150:	60aa      	str	r2, [r5, #8]
 8003152:	60eb      	str	r3, [r5, #12]
 8003154:	4664      	mov	r4, ip
 8003156:	3510      	adds	r5, #16
 8003158:	45f4      	cmp	ip, lr
 800315a:	d1f4      	bne.n	8003146 <fCmdBuild_SOCKETCMD_INFO+0xe>
 800315c:	4663      	mov	r3, ip
 800315e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8003160:	6028      	str	r0, [r5, #0]
 8003162:	6069      	str	r1, [r5, #4]
 8003164:	60aa      	str	r2, [r5, #8]
 8003166:	881a      	ldrh	r2, [r3, #0]
 8003168:	789b      	ldrb	r3, [r3, #2]
 800316a:	81aa      	strh	r2, [r5, #12]
 800316c:	73ab      	strb	r3, [r5, #14]
 800316e:	4c2a      	ldr	r4, [pc, #168]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 8003170:	4620      	mov	r0, r4
 8003172:	f01c f8da 	bl	801f32a <crs_strlen>
 8003176:	b283      	uxth	r3, r0
 8003178:	4622      	mov	r2, r4
 800317a:	2104      	movs	r1, #4
 800317c:	2002      	movs	r0, #2
 800317e:	f01c f917 	bl	801f3b0 <traceIF_itmPrint>
 8003182:	4620      	mov	r0, r4
 8003184:	f01c f8d1 	bl	801f32a <crs_strlen>
 8003188:	b283      	uxth	r3, r0
 800318a:	4622      	mov	r2, r4
 800318c:	2104      	movs	r1, #4
 800318e:	2002      	movs	r0, #2
 8003190:	f01c f930 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8003194:	8933      	ldrh	r3, [r6, #8]
 8003196:	2b03      	cmp	r3, #3
 8003198:	d001      	beq.n	800319e <fCmdBuild_SOCKETCMD_INFO+0x66>
}
 800319a:	2000      	movs	r0, #0
 800319c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 800319e:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 80031a2:	b16b      	cbz	r3, 80031c0 <fCmdBuild_SOCKETCMD_INFO+0x88>
                                                    p_modem_ctxt->socket_ctxt.socket_cnx_infos->socket_handle);
 80031a4:	f8d7 37a8 	ldr.w	r3, [r7, #1960]	; 0x7a8
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 80031a8:	6819      	ldr	r1, [r3, #0]
 80031aa:	4638      	mov	r0, r7
 80031ac:	f010 ffde 	bl	801416c <atcm_socket_get_modem_cid>
 80031b0:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 80031b2:	4a1a      	ldr	r2, [pc, #104]	; (800321c <fCmdBuild_SOCKETCMD_INFO+0xe4>)
 80031b4:	491a      	ldr	r1, [pc, #104]	; (8003220 <fCmdBuild_SOCKETCMD_INFO+0xe8>)
 80031b6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80031ba:	f023 fb45 	bl	8026848 <sprintf>
 80031be:	e7ec      	b.n	800319a <fCmdBuild_SOCKETCMD_INFO+0x62>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_INFO")
 80031c0:	4d18      	ldr	r5, [pc, #96]	; (8003224 <fCmdBuild_SOCKETCMD_INFO+0xec>)
 80031c2:	4c15      	ldr	r4, [pc, #84]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 80031c4:	f105 0730 	add.w	r7, r5, #48	; 0x30
 80031c8:	462e      	mov	r6, r5
 80031ca:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80031cc:	6020      	str	r0, [r4, #0]
 80031ce:	6061      	str	r1, [r4, #4]
 80031d0:	60a2      	str	r2, [r4, #8]
 80031d2:	60e3      	str	r3, [r4, #12]
 80031d4:	4635      	mov	r5, r6
 80031d6:	3410      	adds	r4, #16
 80031d8:	42be      	cmp	r6, r7
 80031da:	d1f5      	bne.n	80031c8 <fCmdBuild_SOCKETCMD_INFO+0x90>
 80031dc:	cd07      	ldmia	r5!, {r0, r1, r2}
 80031de:	6020      	str	r0, [r4, #0]
 80031e0:	6061      	str	r1, [r4, #4]
 80031e2:	60a2      	str	r2, [r4, #8]
 80031e4:	882a      	ldrh	r2, [r5, #0]
 80031e6:	78ab      	ldrb	r3, [r5, #2]
 80031e8:	81a2      	strh	r2, [r4, #12]
 80031ea:	73a3      	strb	r3, [r4, #14]
 80031ec:	4c0a      	ldr	r4, [pc, #40]	; (8003218 <fCmdBuild_SOCKETCMD_INFO+0xe0>)
 80031ee:	4620      	mov	r0, r4
 80031f0:	f01c f89b 	bl	801f32a <crs_strlen>
 80031f4:	b283      	uxth	r3, r0
 80031f6:	4622      	mov	r2, r4
 80031f8:	2110      	movs	r1, #16
 80031fa:	2002      	movs	r0, #2
 80031fc:	f01c f8d8 	bl	801f3b0 <traceIF_itmPrint>
 8003200:	4620      	mov	r0, r4
 8003202:	f01c f892 	bl	801f32a <crs_strlen>
 8003206:	b283      	uxth	r3, r0
 8003208:	4622      	mov	r2, r4
 800320a:	2110      	movs	r1, #16
 800320c:	2002      	movs	r0, #2
 800320e:	f01c f8f1 	bl	801f3f4 <traceIF_uartPrint>
 8003212:	e7c2      	b.n	800319a <fCmdBuild_SOCKETCMD_INFO+0x62>
 8003214:	0802b988 	.word	0x0802b988
 8003218:	200048dc 	.word	0x200048dc
 800321c:	0802b9b8 	.word	0x0802b9b8
 8003220:	0802b938 	.word	0x0802b938
 8003224:	0802b9c0 	.word	0x0802b9c0

08003228 <fCmdBuild_SOCKETCMD_DEACTIVATE>:
{
 8003228:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800322a:	4606      	mov	r6, r0
 800322c:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_DEACTIVATE()")
 800322e:	4d2a      	ldr	r5, [pc, #168]	; (80032d8 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb0>)
 8003230:	4c2a      	ldr	r4, [pc, #168]	; (80032dc <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb4>)
 8003232:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8003236:	46ac      	mov	ip, r5
 8003238:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800323c:	6020      	str	r0, [r4, #0]
 800323e:	6061      	str	r1, [r4, #4]
 8003240:	60a2      	str	r2, [r4, #8]
 8003242:	60e3      	str	r3, [r4, #12]
 8003244:	4665      	mov	r5, ip
 8003246:	3410      	adds	r4, #16
 8003248:	45f4      	cmp	ip, lr
 800324a:	d1f4      	bne.n	8003236 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xe>
 800324c:	f8dc 0000 	ldr.w	r0, [ip]
 8003250:	6020      	str	r0, [r4, #0]
 8003252:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8003256:	7123      	strb	r3, [r4, #4]
 8003258:	4c20      	ldr	r4, [pc, #128]	; (80032dc <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb4>)
 800325a:	4620      	mov	r0, r4
 800325c:	f01c f865 	bl	801f32a <crs_strlen>
 8003260:	b283      	uxth	r3, r0
 8003262:	4622      	mov	r2, r4
 8003264:	2104      	movs	r1, #4
 8003266:	2002      	movs	r0, #2
 8003268:	f01c f8a2 	bl	801f3b0 <traceIF_itmPrint>
 800326c:	4620      	mov	r0, r4
 800326e:	f01c f85c 	bl	801f32a <crs_strlen>
 8003272:	b283      	uxth	r3, r0
 8003274:	4622      	mov	r2, r4
 8003276:	2104      	movs	r1, #4
 8003278:	2002      	movs	r0, #2
 800327a:	f01c f8bb 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800327e:	8933      	ldrh	r3, [r6, #8]
 8003280:	2b03      	cmp	r3, #3
 8003282:	d001      	beq.n	8003288 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x60>
}
 8003284:	2000      	movs	r0, #0
 8003286:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 8003288:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 800328c:	b15b      	cbz	r3, 80032a6 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x7e>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 800328e:	6819      	ldr	r1, [r3, #0]
 8003290:	4638      	mov	r0, r7
 8003292:	f010 ff6b 	bl	801416c <atcm_socket_get_modem_cid>
 8003296:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 8003298:	4a11      	ldr	r2, [pc, #68]	; (80032e0 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb8>)
 800329a:	4912      	ldr	r1, [pc, #72]	; (80032e4 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xbc>)
 800329c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80032a0:	f023 fad2 	bl	8026848 <sprintf>
 80032a4:	e7ee      	b.n	8003284 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x5c>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_DEACTIVATE")
 80032a6:	4c0d      	ldr	r4, [pc, #52]	; (80032dc <fCmdBuild_SOCKETCMD_DEACTIVATE+0xb4>)
 80032a8:	2245      	movs	r2, #69	; 0x45
 80032aa:	490f      	ldr	r1, [pc, #60]	; (80032e8 <fCmdBuild_SOCKETCMD_DEACTIVATE+0xc0>)
 80032ac:	4620      	mov	r0, r4
 80032ae:	f023 fc1b 	bl	8026ae8 <memcpy>
 80032b2:	4620      	mov	r0, r4
 80032b4:	f01c f839 	bl	801f32a <crs_strlen>
 80032b8:	b283      	uxth	r3, r0
 80032ba:	4622      	mov	r2, r4
 80032bc:	2110      	movs	r1, #16
 80032be:	2002      	movs	r0, #2
 80032c0:	f01c f876 	bl	801f3b0 <traceIF_itmPrint>
 80032c4:	4620      	mov	r0, r4
 80032c6:	f01c f830 	bl	801f32a <crs_strlen>
 80032ca:	b283      	uxth	r3, r0
 80032cc:	4622      	mov	r2, r4
 80032ce:	2110      	movs	r1, #16
 80032d0:	2002      	movs	r0, #2
 80032d2:	f01c f88f 	bl	801f3f4 <traceIF_uartPrint>
 80032d6:	e7d5      	b.n	8003284 <fCmdBuild_SOCKETCMD_DEACTIVATE+0x5c>
 80032d8:	0802ba00 	.word	0x0802ba00
 80032dc:	200048dc 	.word	0x200048dc
 80032e0:	0802ba38 	.word	0x0802ba38
 80032e4:	0802b938 	.word	0x0802b938
 80032e8:	0802ba44 	.word	0x0802ba44

080032ec <fCmdBuild_SOCKETCMD_DELETE>:
{
 80032ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80032ee:	4606      	mov	r6, r0
 80032f0:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETCMD_DELETE()")
 80032f2:	4d29      	ldr	r5, [pc, #164]	; (8003398 <fCmdBuild_SOCKETCMD_DELETE+0xac>)
 80032f4:	4c29      	ldr	r4, [pc, #164]	; (800339c <fCmdBuild_SOCKETCMD_DELETE+0xb0>)
 80032f6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80032fa:	46ac      	mov	ip, r5
 80032fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003300:	6020      	str	r0, [r4, #0]
 8003302:	6061      	str	r1, [r4, #4]
 8003304:	60a2      	str	r2, [r4, #8]
 8003306:	60e3      	str	r3, [r4, #12]
 8003308:	4665      	mov	r5, ip
 800330a:	3410      	adds	r4, #16
 800330c:	45f4      	cmp	ip, lr
 800330e:	d1f4      	bne.n	80032fa <fCmdBuild_SOCKETCMD_DELETE+0xe>
 8003310:	f89c 3000 	ldrb.w	r3, [ip]
 8003314:	7023      	strb	r3, [r4, #0]
 8003316:	4c21      	ldr	r4, [pc, #132]	; (800339c <fCmdBuild_SOCKETCMD_DELETE+0xb0>)
 8003318:	4620      	mov	r0, r4
 800331a:	f01c f806 	bl	801f32a <crs_strlen>
 800331e:	b283      	uxth	r3, r0
 8003320:	4622      	mov	r2, r4
 8003322:	2104      	movs	r1, #4
 8003324:	2002      	movs	r0, #2
 8003326:	f01c f843 	bl	801f3b0 <traceIF_itmPrint>
 800332a:	4620      	mov	r0, r4
 800332c:	f01b fffd 	bl	801f32a <crs_strlen>
 8003330:	b283      	uxth	r3, r0
 8003332:	4622      	mov	r2, r4
 8003334:	2104      	movs	r1, #4
 8003336:	2002      	movs	r0, #2
 8003338:	f01c f85c 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800333c:	8933      	ldrh	r3, [r6, #8]
 800333e:	2b03      	cmp	r3, #3
 8003340:	d001      	beq.n	8003346 <fCmdBuild_SOCKETCMD_DELETE+0x5a>
}
 8003342:	2000      	movs	r0, #0
 8003344:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->socket_ctxt.socket_info != NULL)
 8003346:	f8d7 3740 	ldr.w	r3, [r7, #1856]	; 0x740
 800334a:	b15b      	cbz	r3, 8003364 <fCmdBuild_SOCKETCMD_DELETE+0x78>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle);
 800334c:	6819      	ldr	r1, [r3, #0]
 800334e:	4638      	mov	r0, r7
 8003350:	f010 ff0c 	bl	801416c <atcm_socket_get_modem_cid>
 8003354:	4603      	mov	r3, r0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\",%ld",
 8003356:	4a12      	ldr	r2, [pc, #72]	; (80033a0 <fCmdBuild_SOCKETCMD_DELETE+0xb4>)
 8003358:	4912      	ldr	r1, [pc, #72]	; (80033a4 <fCmdBuild_SOCKETCMD_DELETE+0xb8>)
 800335a:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800335e:	f023 fa73 	bl	8026848 <sprintf>
 8003362:	e7ee      	b.n	8003342 <fCmdBuild_SOCKETCMD_DELETE+0x56>
      PRINT_ERR("No socket context for fCmdBuild_SOCKETCMD_DELETE")
 8003364:	4c0d      	ldr	r4, [pc, #52]	; (800339c <fCmdBuild_SOCKETCMD_DELETE+0xb0>)
 8003366:	2241      	movs	r2, #65	; 0x41
 8003368:	490f      	ldr	r1, [pc, #60]	; (80033a8 <fCmdBuild_SOCKETCMD_DELETE+0xbc>)
 800336a:	4620      	mov	r0, r4
 800336c:	f023 fbbc 	bl	8026ae8 <memcpy>
 8003370:	4620      	mov	r0, r4
 8003372:	f01b ffda 	bl	801f32a <crs_strlen>
 8003376:	b283      	uxth	r3, r0
 8003378:	4622      	mov	r2, r4
 800337a:	2110      	movs	r1, #16
 800337c:	2002      	movs	r0, #2
 800337e:	f01c f817 	bl	801f3b0 <traceIF_itmPrint>
 8003382:	4620      	mov	r0, r4
 8003384:	f01b ffd1 	bl	801f32a <crs_strlen>
 8003388:	b283      	uxth	r3, r0
 800338a:	4622      	mov	r2, r4
 800338c:	2110      	movs	r1, #16
 800338e:	2002      	movs	r0, #2
 8003390:	f01c f830 	bl	801f3f4 <traceIF_uartPrint>
 8003394:	e7d5      	b.n	8003342 <fCmdBuild_SOCKETCMD_DELETE+0x56>
 8003396:	bf00      	nop
 8003398:	0802ba8c 	.word	0x0802ba8c
 800339c:	200048dc 	.word	0x200048dc
 80033a0:	0802bac0 	.word	0x0802bac0
 80033a4:	0802b938 	.word	0x0802b938
 80033a8:	0802bac8 	.word	0x0802bac8

080033ac <fCmdBuild_SOCKETDATA_SEND>:
{
 80033ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80033b0:	b085      	sub	sp, #20
 80033b2:	4605      	mov	r5, r0
 80033b4:	460e      	mov	r6, r1
  PRINT_API("enter fCmdBuild_SOCKETDATA_SEND()")
 80033b6:	f8df c18c 	ldr.w	ip, [pc, #396]	; 8003544 <fCmdBuild_SOCKETDATA_SEND+0x198>
 80033ba:	4f5d      	ldr	r7, [pc, #372]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 80033bc:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 80033c0:	4664      	mov	r4, ip
 80033c2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80033c4:	6038      	str	r0, [r7, #0]
 80033c6:	6079      	str	r1, [r7, #4]
 80033c8:	60ba      	str	r2, [r7, #8]
 80033ca:	60fb      	str	r3, [r7, #12]
 80033cc:	46a4      	mov	ip, r4
 80033ce:	3710      	adds	r7, #16
 80033d0:	4574      	cmp	r4, lr
 80033d2:	d1f5      	bne.n	80033c0 <fCmdBuild_SOCKETDATA_SEND+0x14>
 80033d4:	4c56      	ldr	r4, [pc, #344]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 80033d6:	4620      	mov	r0, r4
 80033d8:	f01b ffa7 	bl	801f32a <crs_strlen>
 80033dc:	b283      	uxth	r3, r0
 80033de:	4622      	mov	r2, r4
 80033e0:	2104      	movs	r1, #4
 80033e2:	2002      	movs	r0, #2
 80033e4:	f01b ffe4 	bl	801f3b0 <traceIF_itmPrint>
 80033e8:	4620      	mov	r0, r4
 80033ea:	f01b ff9e 	bl	801f32a <crs_strlen>
 80033ee:	b283      	uxth	r3, r0
 80033f0:	4622      	mov	r2, r4
 80033f2:	2104      	movs	r1, #4
 80033f4:	2002      	movs	r0, #2
 80033f6:	f01b fffd 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80033fa:	892b      	ldrh	r3, [r5, #8]
 80033fc:	2b03      	cmp	r3, #3
 80033fe:	d003      	beq.n	8003408 <fCmdBuild_SOCKETDATA_SEND+0x5c>
  at_status_t retval = ATSTATUS_OK;
 8003400:	2000      	movs	r0, #0
}
 8003402:	b005      	add	sp, #20
 8003404:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p_modem_ctxt->SID_ctxt.socketSendData_struct.p_buffer_addr_send != NULL)
 8003408:	f8d6 3674 	ldr.w	r3, [r6, #1652]	; 0x674
 800340c:	2b00      	cmp	r3, #0
 800340e:	d067      	beq.n	80034e0 <fCmdBuild_SOCKETDATA_SEND+0x134>
      uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 8003410:	f8d6 1670 	ldr.w	r1, [r6, #1648]	; 0x670
 8003414:	4630      	mov	r0, r6
 8003416:	f010 fea9 	bl	801416c <atcm_socket_get_modem_cid>
 800341a:	4602      	mov	r2, r0
      uint16_t str_size = (uint16_t) p_modem_ctxt->SID_ctxt.socketSendData_struct.buffer_size;
 800341c:	f8b6 767c 	ldrh.w	r7, [r6, #1660]	; 0x67c
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"SEND\",%ld,%d,\"",
 8003420:	f105 0430 	add.w	r4, r5, #48	; 0x30
 8003424:	463b      	mov	r3, r7
 8003426:	4943      	ldr	r1, [pc, #268]	; (8003534 <fCmdBuild_SOCKETDATA_SEND+0x188>)
 8003428:	4620      	mov	r0, r4
 800342a:	f023 fa0d 	bl	8026848 <sprintf>
      uint16_t cmd_params_size = (uint16_t) strlen((CRC_CHAR_t *)&p_atp_ctxt->current_atcmd.params);
 800342e:	4620      	mov	r0, r4
 8003430:	f7fc fee0 	bl	80001f4 <strlen>
 8003434:	4680      	mov	r8, r0
 8003436:	fa1f f980 	uxth.w	r9, r0
      for (uint16_t idx = 0U; idx < str_size; idx++)
 800343a:	2400      	movs	r4, #0
 800343c:	e037      	b.n	80034ae <fCmdBuild_SOCKETDATA_SEND+0x102>
        uint8_t onechar = p_modem_ctxt->SID_ctxt.socketSendData_struct.p_buffer_addr_send[idx];
 800343e:	f8d6 3674 	ldr.w	r3, [r6, #1652]	; 0x674
 8003442:	f813 b004 	ldrb.w	fp, [r3, r4]
        PRINT_DBG("[ %c -> HEX= %2x / DEC= %2d]", onechar, onechar, onechar)
 8003446:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>
 800344a:	f8cd b000 	str.w	fp, [sp]
 800344e:	465b      	mov	r3, fp
 8003450:	465a      	mov	r2, fp
 8003452:	4939      	ldr	r1, [pc, #228]	; (8003538 <fCmdBuild_SOCKETDATA_SEND+0x18c>)
 8003454:	4650      	mov	r0, sl
 8003456:	f023 f9f7 	bl	8026848 <sprintf>
 800345a:	4650      	mov	r0, sl
 800345c:	f01b ff65 	bl	801f32a <crs_strlen>
 8003460:	b283      	uxth	r3, r0
 8003462:	4652      	mov	r2, sl
 8003464:	2102      	movs	r1, #2
 8003466:	4608      	mov	r0, r1
 8003468:	f01b ffa2 	bl	801f3b0 <traceIF_itmPrint>
 800346c:	4650      	mov	r0, sl
 800346e:	f01b ff5c 	bl	801f32a <crs_strlen>
 8003472:	b283      	uxth	r3, r0
 8003474:	4652      	mov	r2, sl
 8003476:	2102      	movs	r1, #2
 8003478:	4608      	mov	r0, r1
 800347a:	f01b ffbb 	bl	801f3f4 <traceIF_uartPrint>
        convertCharToHEX(onechar, &ms, &ls);
 800347e:	f10d 020f 	add.w	r2, sp, #15
 8003482:	f10d 010e 	add.w	r1, sp, #14
 8003486:	4658      	mov	r0, fp
 8003488:	f7ff fc64 	bl	8002d54 <convertCharToHEX>
        (void) memcpy((void *) &p_atp_ctxt->current_atcmd.params[cmd_params_size + (2U * idx)],
 800348c:	fa1f f388 	uxth.w	r3, r8
 8003490:	eb03 0344 	add.w	r3, r3, r4, lsl #1
 8003494:	18ea      	adds	r2, r5, r3
 8003496:	f89d 100e 	ldrb.w	r1, [sp, #14]
 800349a:	f882 1030 	strb.w	r1, [r2, #48]	; 0x30
        (void) memcpy((void *) &p_atp_ctxt->current_atcmd.params[cmd_params_size + (1U + (2U * idx))],
 800349e:	3301      	adds	r3, #1
 80034a0:	442b      	add	r3, r5
 80034a2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80034a6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      for (uint16_t idx = 0U; idx < str_size; idx++)
 80034aa:	3401      	adds	r4, #1
 80034ac:	b2a4      	uxth	r4, r4
 80034ae:	42bc      	cmp	r4, r7
 80034b0:	d3c5      	bcc.n	800343e <fCmdBuild_SOCKETDATA_SEND+0x92>
      cmd_params_size += (2U * str_size);
 80034b2:	007b      	lsls	r3, r7, #1
 80034b4:	b29b      	uxth	r3, r3
 80034b6:	444b      	add	r3, r9
 80034b8:	b29b      	uxth	r3, r3
      if (p_modem_ctxt->SID_ctxt.socketSendData_struct.ip_addr_type != CS_IPAT_INVALID)
 80034ba:	f896 0684 	ldrb.w	r0, [r6, #1668]	; 0x684
 80034be:	b158      	cbz	r0, 80034d8 <fCmdBuild_SOCKETDATA_SEND+0x12c>
        (void) sprintf((CRC_CHAR_t *)(&(p_atp_ctxt->current_atcmd.params[cmd_params_size])),
 80034c0:	f103 0030 	add.w	r0, r3, #48	; 0x30
 80034c4:	f8b6 36c6 	ldrh.w	r3, [r6, #1734]	; 0x6c6
 80034c8:	f206 6285 	addw	r2, r6, #1669	; 0x685
 80034cc:	491b      	ldr	r1, [pc, #108]	; (800353c <fCmdBuild_SOCKETDATA_SEND+0x190>)
 80034ce:	4428      	add	r0, r5
 80034d0:	f023 f9ba 	bl	8026848 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 80034d4:	2000      	movs	r0, #0
 80034d6:	e794      	b.n	8003402 <fCmdBuild_SOCKETDATA_SEND+0x56>
        (void) memcpy((void *) &p_atp_ctxt->current_atcmd.params[cmd_params_size],
 80034d8:	3330      	adds	r3, #48	; 0x30
 80034da:	2222      	movs	r2, #34	; 0x22
 80034dc:	54ea      	strb	r2, [r5, r3]
 80034de:	e790      	b.n	8003402 <fCmdBuild_SOCKETDATA_SEND+0x56>
      PRINT_ERR("ERROR, send buffer is a NULL ptr !!!")
 80034e0:	4e17      	ldr	r6, [pc, #92]	; (8003540 <fCmdBuild_SOCKETDATA_SEND+0x194>)
 80034e2:	4c13      	ldr	r4, [pc, #76]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 80034e4:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80034e8:	4635      	mov	r5, r6
 80034ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80034ec:	6020      	str	r0, [r4, #0]
 80034ee:	6061      	str	r1, [r4, #4]
 80034f0:	60a2      	str	r2, [r4, #8]
 80034f2:	60e3      	str	r3, [r4, #12]
 80034f4:	462e      	mov	r6, r5
 80034f6:	3410      	adds	r4, #16
 80034f8:	42bd      	cmp	r5, r7
 80034fa:	d1f5      	bne.n	80034e8 <fCmdBuild_SOCKETDATA_SEND+0x13c>
 80034fc:	6828      	ldr	r0, [r5, #0]
 80034fe:	6020      	str	r0, [r4, #0]
 8003500:	792b      	ldrb	r3, [r5, #4]
 8003502:	7123      	strb	r3, [r4, #4]
 8003504:	4c0a      	ldr	r4, [pc, #40]	; (8003530 <fCmdBuild_SOCKETDATA_SEND+0x184>)
 8003506:	4620      	mov	r0, r4
 8003508:	f01b ff0f 	bl	801f32a <crs_strlen>
 800350c:	b283      	uxth	r3, r0
 800350e:	4622      	mov	r2, r4
 8003510:	2110      	movs	r1, #16
 8003512:	2002      	movs	r0, #2
 8003514:	f01b ff4c 	bl	801f3b0 <traceIF_itmPrint>
 8003518:	4620      	mov	r0, r4
 800351a:	f01b ff06 	bl	801f32a <crs_strlen>
 800351e:	b283      	uxth	r3, r0
 8003520:	4622      	mov	r2, r4
 8003522:	2110      	movs	r1, #16
 8003524:	2002      	movs	r0, #2
 8003526:	f01b ff65 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800352a:	2001      	movs	r0, #1
 800352c:	e769      	b.n	8003402 <fCmdBuild_SOCKETDATA_SEND+0x56>
 800352e:	bf00      	nop
 8003530:	200048dc 	.word	0x200048dc
 8003534:	0802bb3c 	.word	0x0802bb3c
 8003538:	0802bb4c 	.word	0x0802bb4c
 800353c:	0802bb74 	.word	0x0802bb74
 8003540:	0802bb80 	.word	0x0802bb80
 8003544:	0802bb0c 	.word	0x0802bb0c

08003548 <fCmdBuild_SOCKETDATA_RECEIVE>:
{
 8003548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800354a:	4606      	mov	r6, r0
 800354c:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_SOCKETDATA_RECEIVE()")
 800354e:	4d1d      	ldr	r5, [pc, #116]	; (80035c4 <fCmdBuild_SOCKETDATA_RECEIVE+0x7c>)
 8003550:	4c1d      	ldr	r4, [pc, #116]	; (80035c8 <fCmdBuild_SOCKETDATA_RECEIVE+0x80>)
 8003552:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8003556:	46ac      	mov	ip, r5
 8003558:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800355c:	6020      	str	r0, [r4, #0]
 800355e:	6061      	str	r1, [r4, #4]
 8003560:	60a2      	str	r2, [r4, #8]
 8003562:	60e3      	str	r3, [r4, #12]
 8003564:	4665      	mov	r5, ip
 8003566:	3410      	adds	r4, #16
 8003568:	45f4      	cmp	ip, lr
 800356a:	d1f4      	bne.n	8003556 <fCmdBuild_SOCKETDATA_RECEIVE+0xe>
 800356c:	f8bc 2000 	ldrh.w	r2, [ip]
 8003570:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8003574:	8022      	strh	r2, [r4, #0]
 8003576:	70a3      	strb	r3, [r4, #2]
 8003578:	4c13      	ldr	r4, [pc, #76]	; (80035c8 <fCmdBuild_SOCKETDATA_RECEIVE+0x80>)
 800357a:	4620      	mov	r0, r4
 800357c:	f01b fed5 	bl	801f32a <crs_strlen>
 8003580:	b283      	uxth	r3, r0
 8003582:	4622      	mov	r2, r4
 8003584:	2104      	movs	r1, #4
 8003586:	2002      	movs	r0, #2
 8003588:	f01b ff12 	bl	801f3b0 <traceIF_itmPrint>
 800358c:	4620      	mov	r0, r4
 800358e:	f01b fecc 	bl	801f32a <crs_strlen>
 8003592:	b283      	uxth	r3, r0
 8003594:	4622      	mov	r2, r4
 8003596:	2104      	movs	r1, #4
 8003598:	2002      	movs	r0, #2
 800359a:	f01b ff2b 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800359e:	8933      	ldrh	r3, [r6, #8]
 80035a0:	2b03      	cmp	r3, #3
 80035a2:	d001      	beq.n	80035a8 <fCmdBuild_SOCKETDATA_RECEIVE+0x60>
}
 80035a4:	2000      	movs	r0, #0
 80035a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    uint32_t socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 80035a8:	f8d7 1744 	ldr.w	r1, [r7, #1860]	; 0x744
 80035ac:	4638      	mov	r0, r7
 80035ae:	f010 fddd 	bl	801416c <atcm_socket_get_modem_cid>
 80035b2:	4602      	mov	r2, r0
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"RECEIVE\",%ld,%ld",
 80035b4:	f8d7 3754 	ldr.w	r3, [r7, #1876]	; 0x754
 80035b8:	4904      	ldr	r1, [pc, #16]	; (80035cc <fCmdBuild_SOCKETDATA_RECEIVE+0x84>)
 80035ba:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80035be:	f023 f943 	bl	8026848 <sprintf>
 80035c2:	e7ef      	b.n	80035a4 <fCmdBuild_SOCKETDATA_RECEIVE+0x5c>
 80035c4:	0802bbb8 	.word	0x0802bbb8
 80035c8:	200048dc 	.word	0x200048dc
 80035cc:	0802bbec 	.word	0x0802bbec

080035d0 <fCmdBuild_DNSRSLV>:
{
 80035d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80035d2:	4606      	mov	r6, r0
 80035d4:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_DNSRSLV()")
 80035d6:	4c1e      	ldr	r4, [pc, #120]	; (8003650 <fCmdBuild_DNSRSLV+0x80>)
 80035d8:	4d1e      	ldr	r5, [pc, #120]	; (8003654 <fCmdBuild_DNSRSLV+0x84>)
 80035da:	f104 0e20 	add.w	lr, r4, #32
 80035de:	46a4      	mov	ip, r4
 80035e0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80035e4:	6028      	str	r0, [r5, #0]
 80035e6:	6069      	str	r1, [r5, #4]
 80035e8:	60aa      	str	r2, [r5, #8]
 80035ea:	60eb      	str	r3, [r5, #12]
 80035ec:	4664      	mov	r4, ip
 80035ee:	3510      	adds	r5, #16
 80035f0:	45f4      	cmp	ip, lr
 80035f2:	d1f4      	bne.n	80035de <fCmdBuild_DNSRSLV+0xe>
 80035f4:	cc03      	ldmia	r4!, {r0, r1}
 80035f6:	6028      	str	r0, [r5, #0]
 80035f8:	6069      	str	r1, [r5, #4]
 80035fa:	4c16      	ldr	r4, [pc, #88]	; (8003654 <fCmdBuild_DNSRSLV+0x84>)
 80035fc:	4620      	mov	r0, r4
 80035fe:	f01b fe94 	bl	801f32a <crs_strlen>
 8003602:	b283      	uxth	r3, r0
 8003604:	4622      	mov	r2, r4
 8003606:	2104      	movs	r1, #4
 8003608:	2002      	movs	r0, #2
 800360a:	f01b fed1 	bl	801f3b0 <traceIF_itmPrint>
 800360e:	4620      	mov	r0, r4
 8003610:	f01b fe8b 	bl	801f32a <crs_strlen>
 8003614:	b283      	uxth	r3, r0
 8003616:	4622      	mov	r2, r4
 8003618:	2104      	movs	r1, #4
 800361a:	2002      	movs	r0, #2
 800361c:	f01b feea 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8003620:	8933      	ldrh	r3, [r6, #8]
 8003622:	2b03      	cmp	r3, #3
 8003624:	d001      	beq.n	800362a <fCmdBuild_DNSRSLV+0x5a>
}
 8003626:	2000      	movs	r0, #0
 8003628:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800362a:	4638      	mov	r0, r7
 800362c:	f009 f942 	bl	800c8b4 <atcm_get_cid_current_SID>
 8003630:	4601      	mov	r1, r0
    uint8_t pdp_modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 8003632:	f107 000c 	add.w	r0, r7, #12
 8003636:	f00a f9c5 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800363a:	4602      	mov	r2, r0
                   p_modem_ctxt->SID_ctxt.dns_request_infos->dns_req.host_name);
 800363c:	f8d7 36cc 	ldr.w	r3, [r7, #1740]	; 0x6cc
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\"",
 8003640:	3341      	adds	r3, #65	; 0x41
 8003642:	4905      	ldr	r1, [pc, #20]	; (8003658 <fCmdBuild_DNSRSLV+0x88>)
 8003644:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8003648:	f023 f8fe 	bl	8026848 <sprintf>
 800364c:	e7eb      	b.n	8003626 <fCmdBuild_DNSRSLV+0x56>
 800364e:	bf00      	nop
 8003650:	0802bc00 	.word	0x0802bc00
 8003654:	200048dc 	.word	0x200048dc
 8003658:	0802bc28 	.word	0x0802bc28

0800365c <fCmdBuild_PINGCMD>:
{
 800365c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800365e:	b085      	sub	sp, #20
 8003660:	4606      	mov	r6, r0
 8003662:	460f      	mov	r7, r1
  PRINT_API("enter fCmdBuild_PINGCMD()")
 8003664:	4c1f      	ldr	r4, [pc, #124]	; (80036e4 <fCmdBuild_PINGCMD+0x88>)
 8003666:	4d20      	ldr	r5, [pc, #128]	; (80036e8 <fCmdBuild_PINGCMD+0x8c>)
 8003668:	f104 0e20 	add.w	lr, r4, #32
 800366c:	46a4      	mov	ip, r4
 800366e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003672:	6028      	str	r0, [r5, #0]
 8003674:	6069      	str	r1, [r5, #4]
 8003676:	60aa      	str	r2, [r5, #8]
 8003678:	60eb      	str	r3, [r5, #12]
 800367a:	4664      	mov	r4, ip
 800367c:	3510      	adds	r5, #16
 800367e:	45f4      	cmp	ip, lr
 8003680:	d1f4      	bne.n	800366c <fCmdBuild_PINGCMD+0x10>
 8003682:	cc03      	ldmia	r4!, {r0, r1}
 8003684:	6028      	str	r0, [r5, #0]
 8003686:	6069      	str	r1, [r5, #4]
 8003688:	4c17      	ldr	r4, [pc, #92]	; (80036e8 <fCmdBuild_PINGCMD+0x8c>)
 800368a:	4620      	mov	r0, r4
 800368c:	f01b fe4d 	bl	801f32a <crs_strlen>
 8003690:	b283      	uxth	r3, r0
 8003692:	4622      	mov	r2, r4
 8003694:	2104      	movs	r1, #4
 8003696:	2002      	movs	r0, #2
 8003698:	f01b fe8a 	bl	801f3b0 <traceIF_itmPrint>
 800369c:	4620      	mov	r0, r4
 800369e:	f01b fe44 	bl	801f32a <crs_strlen>
 80036a2:	b283      	uxth	r3, r0
 80036a4:	4622      	mov	r2, r4
 80036a6:	2104      	movs	r1, #4
 80036a8:	2002      	movs	r0, #2
 80036aa:	f01b fea3 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80036ae:	8933      	ldrh	r3, [r6, #8]
 80036b0:	2b03      	cmp	r3, #3
 80036b2:	d002      	beq.n	80036ba <fCmdBuild_PINGCMD+0x5e>
}
 80036b4:	2000      	movs	r0, #0
 80036b6:	b005      	add	sp, #20
 80036b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    atcm_validate_ping_request(p_modem_ctxt);
 80036ba:	4638      	mov	r0, r7
 80036bc:	f009 fd6f 	bl	800d19e <atcm_validate_ping_request>
                   p_modem_ctxt->SID_ctxt.ping_infos.ping_params.pingnum,
 80036c0:	f897 3712 	ldrb.w	r3, [r7, #1810]	; 0x712
                   p_modem_ctxt->SID_ctxt.ping_infos.ping_params.timeout);
 80036c4:	f897 2711 	ldrb.w	r2, [r7, #1809]	; 0x711
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",%d,%d,%d",
 80036c8:	9202      	str	r2, [sp, #8]
 80036ca:	2238      	movs	r2, #56	; 0x38
 80036cc:	9201      	str	r2, [sp, #4]
 80036ce:	9300      	str	r3, [sp, #0]
 80036d0:	f207 63d1 	addw	r3, r7, #1745	; 0x6d1
 80036d4:	2200      	movs	r2, #0
 80036d6:	4905      	ldr	r1, [pc, #20]	; (80036ec <fCmdBuild_PINGCMD+0x90>)
 80036d8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 80036dc:	f023 f8b4 	bl	8026848 <sprintf>
 80036e0:	e7e8      	b.n	80036b4 <fCmdBuild_PINGCMD+0x58>
 80036e2:	bf00      	nop
 80036e4:	0802bc30 	.word	0x0802bc30
 80036e8:	200048dc 	.word	0x200048dc
 80036ec:	0802bc58 	.word	0x0802bc58

080036f0 <fRspAnalyze_PDNACT>:
{
 80036f0:	b538      	push	{r3, r4, r5, lr}
  PRINT_API("enter fRspAnalyze_PDNACT()")
 80036f2:	4c14      	ldr	r4, [pc, #80]	; (8003744 <fRspAnalyze_PDNACT+0x54>)
 80036f4:	4d14      	ldr	r5, [pc, #80]	; (8003748 <fRspAnalyze_PDNACT+0x58>)
 80036f6:	f104 0e20 	add.w	lr, r4, #32
 80036fa:	46a4      	mov	ip, r4
 80036fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003700:	6028      	str	r0, [r5, #0]
 8003702:	6069      	str	r1, [r5, #4]
 8003704:	60aa      	str	r2, [r5, #8]
 8003706:	60eb      	str	r3, [r5, #12]
 8003708:	4664      	mov	r4, ip
 800370a:	3510      	adds	r5, #16
 800370c:	45f4      	cmp	ip, lr
 800370e:	d1f4      	bne.n	80036fa <fRspAnalyze_PDNACT+0xa>
 8003710:	cc03      	ldmia	r4!, {r0, r1}
 8003712:	6028      	str	r0, [r5, #0]
 8003714:	6069      	str	r1, [r5, #4]
 8003716:	7823      	ldrb	r3, [r4, #0]
 8003718:	722b      	strb	r3, [r5, #8]
 800371a:	4c0b      	ldr	r4, [pc, #44]	; (8003748 <fRspAnalyze_PDNACT+0x58>)
 800371c:	4620      	mov	r0, r4
 800371e:	f01b fe04 	bl	801f32a <crs_strlen>
 8003722:	b283      	uxth	r3, r0
 8003724:	4622      	mov	r2, r4
 8003726:	2104      	movs	r1, #4
 8003728:	2002      	movs	r0, #2
 800372a:	f01b fe41 	bl	801f3b0 <traceIF_itmPrint>
 800372e:	4620      	mov	r0, r4
 8003730:	f01b fdfb 	bl	801f32a <crs_strlen>
 8003734:	b283      	uxth	r3, r0
 8003736:	4622      	mov	r2, r4
 8003738:	2104      	movs	r1, #4
 800373a:	2002      	movs	r0, #2
 800373c:	f01b fe5a 	bl	801f3f4 <traceIF_uartPrint>
}
 8003740:	2010      	movs	r0, #16
 8003742:	bd38      	pop	{r3, r4, r5, pc}
 8003744:	0802bc6c 	.word	0x0802bc6c
 8003748:	200048dc 	.word	0x200048dc

0800374c <fRspAnalyze_SOCKETCMD>:
{
 800374c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003750:	4607      	mov	r7, r0
 8003752:	4689      	mov	r9, r1
 8003754:	4690      	mov	r8, r2
 8003756:	461e      	mov	r6, r3
  PRINT_API("enter fRspAnalyze_SOCKETCMD()")
 8003758:	4cb6      	ldr	r4, [pc, #728]	; (8003a34 <fRspAnalyze_SOCKETCMD+0x2e8>)
 800375a:	4db7      	ldr	r5, [pc, #732]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 800375c:	f104 0e20 	add.w	lr, r4, #32
 8003760:	46a4      	mov	ip, r4
 8003762:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003766:	6028      	str	r0, [r5, #0]
 8003768:	6069      	str	r1, [r5, #4]
 800376a:	60aa      	str	r2, [r5, #8]
 800376c:	60eb      	str	r3, [r5, #12]
 800376e:	4664      	mov	r4, ip
 8003770:	3510      	adds	r5, #16
 8003772:	45f4      	cmp	ip, lr
 8003774:	d1f4      	bne.n	8003760 <fRspAnalyze_SOCKETCMD+0x14>
 8003776:	cc07      	ldmia	r4!, {r0, r1, r2}
 8003778:	6028      	str	r0, [r5, #0]
 800377a:	6069      	str	r1, [r5, #4]
 800377c:	60aa      	str	r2, [r5, #8]
 800377e:	4cae      	ldr	r4, [pc, #696]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 8003780:	4620      	mov	r0, r4
 8003782:	f01b fdd2 	bl	801f32a <crs_strlen>
 8003786:	b283      	uxth	r3, r0
 8003788:	4622      	mov	r2, r4
 800378a:	2104      	movs	r1, #4
 800378c:	2002      	movs	r0, #2
 800378e:	f01b fe0f 	bl	801f3b0 <traceIF_itmPrint>
 8003792:	4620      	mov	r0, r4
 8003794:	f01b fdc9 	bl	801f32a <crs_strlen>
 8003798:	b283      	uxth	r3, r0
 800379a:	4622      	mov	r2, r4
 800379c:	2104      	movs	r1, #4
 800379e:	2002      	movs	r0, #2
 80037a0:	f01b fe28 	bl	801f3f4 <traceIF_uartPrint>
  START_PARAM_LOOP()
 80037a4:	2400      	movs	r4, #0
 80037a6:	4632      	mov	r2, r6
 80037a8:	4641      	mov	r1, r8
 80037aa:	4638      	mov	r0, r7
 80037ac:	f008 fe4c 	bl	800c448 <atcc_extractElement>
 80037b0:	2801      	cmp	r0, #1
 80037b2:	d000      	beq.n	80037b6 <fRspAnalyze_SOCKETCMD+0x6a>
 80037b4:	2401      	movs	r4, #1
 80037b6:	89f1      	ldrh	r1, [r6, #14]
 80037b8:	b191      	cbz	r1, 80037e0 <fRspAnalyze_SOCKETCMD+0x94>
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETCMD_ALLOCATE)
 80037ba:	69fb      	ldr	r3, [r7, #28]
 80037bc:	2b42      	cmp	r3, #66	; 0x42
 80037be:	d00c      	beq.n	80037da <fRspAnalyze_SOCKETCMD+0x8e>
  else if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETCMD_INFO)
 80037c0:	3b44      	subs	r3, #68	; 0x44
 80037c2:	2b06      	cmp	r3, #6
 80037c4:	f200 8111 	bhi.w	80039ea <fRspAnalyze_SOCKETCMD+0x29e>
 80037c8:	e8df f013 	tbh	[pc, r3, lsl #1]
 80037cc:	010f0038 	.word	0x010f0038
 80037d0:	010f00e3 	.word	0x010f00e3
 80037d4:	00e30099 	.word	0x00e30099
 80037d8:	00e3      	.short	0x00e3
    if (element_infos->param_rank == 2U)
 80037da:	8933      	ldrh	r3, [r6, #8]
 80037dc:	2b02      	cmp	r3, #2
 80037de:	d004      	beq.n	80037ea <fRspAnalyze_SOCKETCMD+0x9e>
  END_PARAM_LOOP()
 80037e0:	2c00      	cmp	r4, #0
 80037e2:	d0e0      	beq.n	80037a6 <fRspAnalyze_SOCKETCMD+0x5a>
}
 80037e4:	2010      	movs	r0, #16
 80037e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      uint32_t affected_socket_ID = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80037ea:	8970      	ldrh	r0, [r6, #10]
 80037ec:	4440      	add	r0, r8
 80037ee:	f011 faa1 	bl	8014d34 <ATutil_convertStringToInt>
 80037f2:	4682      	mov	sl, r0
      PRINT_INFO("<affected socket_id> = %ld", affected_socket_ID)
 80037f4:	4d90      	ldr	r5, [pc, #576]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80037f6:	4602      	mov	r2, r0
 80037f8:	4990      	ldr	r1, [pc, #576]	; (8003a3c <fRspAnalyze_SOCKETCMD+0x2f0>)
 80037fa:	4628      	mov	r0, r5
 80037fc:	f023 f824 	bl	8026848 <sprintf>
 8003800:	4628      	mov	r0, r5
 8003802:	f01b fd92 	bl	801f32a <crs_strlen>
 8003806:	b283      	uxth	r3, r0
 8003808:	462a      	mov	r2, r5
 800380a:	2101      	movs	r1, #1
 800380c:	2002      	movs	r0, #2
 800380e:	f01b fdcf 	bl	801f3b0 <traceIF_itmPrint>
 8003812:	4628      	mov	r0, r5
 8003814:	f01b fd89 	bl	801f32a <crs_strlen>
 8003818:	b283      	uxth	r3, r0
 800381a:	462a      	mov	r2, r5
 800381c:	2101      	movs	r1, #1
 800381e:	2002      	movs	r0, #2
 8003820:	f01b fde8 	bl	801f3f4 <traceIF_uartPrint>
      type1sc_shared.SocketCmd_Allocated_SocketID = AT_TRUE;
 8003824:	4b86      	ldr	r3, [pc, #536]	; (8003a40 <fRspAnalyze_SOCKETCMD+0x2f4>)
 8003826:	2201      	movs	r2, #1
 8003828:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      (void) atcm_socket_set_modem_cid(p_modem_ctxt, p_modem_ctxt->socket_ctxt.socket_info->socket_handle,
 800382c:	f8d9 3740 	ldr.w	r3, [r9, #1856]	; 0x740
 8003830:	4652      	mov	r2, sl
 8003832:	6819      	ldr	r1, [r3, #0]
 8003834:	4648      	mov	r0, r9
 8003836:	f010 fcc1 	bl	80141bc <atcm_socket_set_modem_cid>
 800383a:	e7d1      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    if (element_infos->param_rank == 2U)
 800383c:	8933      	ldrh	r3, [r6, #8]
 800383e:	2b02      	cmp	r3, #2
 8003840:	d0ce      	beq.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    else if (element_infos->param_rank == 3U)
 8003842:	3b04      	subs	r3, #4
 8003844:	2b03      	cmp	r3, #3
 8003846:	d8cb      	bhi.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
 8003848:	e8df f003 	tbb	[pc, r3]
 800384c:	36130a02 	.word	0x36130a02
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003850:	8970      	ldrh	r0, [r6, #10]
                              (uint8_t *)p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->loc_ip_addr_value);
 8003852:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003856:	685a      	ldr	r2, [r3, #4]
 8003858:	4440      	add	r0, r8
 800385a:	f009 f80a 	bl	800c872 <atcm_extract_IP_address>
 800385e:	e7bf      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003860:	8970      	ldrh	r0, [r6, #10]
                              (uint8_t *)p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->rem_ip_addr_value);
 8003862:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
 8003866:	685a      	ldr	r2, [r3, #4]
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003868:	3242      	adds	r2, #66	; 0x42
 800386a:	4440      	add	r0, r8
 800386c:	f009 f801 	bl	800c872 <atcm_extract_IP_address>
 8003870:	e7b6      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      uint32_t src_port = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003872:	8970      	ldrh	r0, [r6, #10]
 8003874:	4440      	add	r0, r8
 8003876:	f011 fa5d 	bl	8014d34 <ATutil_convertStringToInt>
 800387a:	4682      	mov	sl, r0
      PRINT_DBG("<src_port>=%ld", src_port)
 800387c:	4d6e      	ldr	r5, [pc, #440]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 800387e:	4602      	mov	r2, r0
 8003880:	4970      	ldr	r1, [pc, #448]	; (8003a44 <fRspAnalyze_SOCKETCMD+0x2f8>)
 8003882:	4628      	mov	r0, r5
 8003884:	f022 ffe0 	bl	8026848 <sprintf>
 8003888:	4628      	mov	r0, r5
 800388a:	f01b fd4e 	bl	801f32a <crs_strlen>
 800388e:	b283      	uxth	r3, r0
 8003890:	462a      	mov	r2, r5
 8003892:	2102      	movs	r1, #2
 8003894:	4608      	mov	r0, r1
 8003896:	f01b fd8b 	bl	801f3b0 <traceIF_itmPrint>
 800389a:	4628      	mov	r0, r5
 800389c:	f01b fd45 	bl	801f32a <crs_strlen>
 80038a0:	b283      	uxth	r3, r0
 80038a2:	462a      	mov	r2, r5
 80038a4:	2102      	movs	r1, #2
 80038a6:	4608      	mov	r0, r1
 80038a8:	f01b fda4 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->loc_port = (uint16_t) src_port;
 80038ac:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
 80038b0:	685b      	ldr	r3, [r3, #4]
 80038b2:	f8a3 a040 	strh.w	sl, [r3, #64]	; 0x40
 80038b6:	e793      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      uint32_t dst_port = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80038b8:	8970      	ldrh	r0, [r6, #10]
 80038ba:	4440      	add	r0, r8
 80038bc:	f011 fa3a 	bl	8014d34 <ATutil_convertStringToInt>
 80038c0:	4682      	mov	sl, r0
      PRINT_DBG("<dst_port>=%ld", dst_port)
 80038c2:	4d5d      	ldr	r5, [pc, #372]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80038c4:	4602      	mov	r2, r0
 80038c6:	4960      	ldr	r1, [pc, #384]	; (8003a48 <fRspAnalyze_SOCKETCMD+0x2fc>)
 80038c8:	4628      	mov	r0, r5
 80038ca:	f022 ffbd 	bl	8026848 <sprintf>
 80038ce:	4628      	mov	r0, r5
 80038d0:	f01b fd2b 	bl	801f32a <crs_strlen>
 80038d4:	b283      	uxth	r3, r0
 80038d6:	462a      	mov	r2, r5
 80038d8:	2102      	movs	r1, #2
 80038da:	4608      	mov	r0, r1
 80038dc:	f01b fd68 	bl	801f3b0 <traceIF_itmPrint>
 80038e0:	4628      	mov	r0, r5
 80038e2:	f01b fd22 	bl	801f32a <crs_strlen>
 80038e6:	b283      	uxth	r3, r0
 80038e8:	462a      	mov	r2, r5
 80038ea:	2102      	movs	r1, #2
 80038ec:	4608      	mov	r0, r1
 80038ee:	f01b fd81 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->socket_ctxt.socket_cnx_infos->infos->rem_port = (uint16_t) dst_port;
 80038f2:	f8d9 37a8 	ldr.w	r3, [r9, #1960]	; 0x7a8
 80038f6:	685b      	ldr	r3, [r3, #4]
 80038f8:	f8a3 a082 	strh.w	sl, [r3, #130]	; 0x82
 80038fc:	e770      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    PRINT_INFO("CMD_AT_SOCKETCMD_LASTERROR")
 80038fe:	f8df e150 	ldr.w	lr, [pc, #336]	; 8003a50 <fRspAnalyze_SOCKETCMD+0x304>
 8003902:	4d4d      	ldr	r5, [pc, #308]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 8003904:	f10e 0a20 	add.w	sl, lr, #32
 8003908:	46f4      	mov	ip, lr
 800390a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800390e:	6028      	str	r0, [r5, #0]
 8003910:	6069      	str	r1, [r5, #4]
 8003912:	60aa      	str	r2, [r5, #8]
 8003914:	60eb      	str	r3, [r5, #12]
 8003916:	46e6      	mov	lr, ip
 8003918:	3510      	adds	r5, #16
 800391a:	45d4      	cmp	ip, sl
 800391c:	d1f4      	bne.n	8003908 <fRspAnalyze_SOCKETCMD+0x1bc>
 800391e:	f8dc 0000 	ldr.w	r0, [ip]
 8003922:	6028      	str	r0, [r5, #0]
 8003924:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8003928:	712b      	strb	r3, [r5, #4]
 800392a:	4d43      	ldr	r5, [pc, #268]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 800392c:	4628      	mov	r0, r5
 800392e:	f01b fcfc 	bl	801f32a <crs_strlen>
 8003932:	b283      	uxth	r3, r0
 8003934:	462a      	mov	r2, r5
 8003936:	2101      	movs	r1, #1
 8003938:	2002      	movs	r0, #2
 800393a:	f01b fd39 	bl	801f3b0 <traceIF_itmPrint>
 800393e:	4628      	mov	r0, r5
 8003940:	f01b fcf3 	bl	801f32a <crs_strlen>
 8003944:	b283      	uxth	r3, r0
 8003946:	462a      	mov	r2, r5
 8003948:	2101      	movs	r1, #1
 800394a:	2002      	movs	r0, #2
 800394c:	f01b fd52 	bl	801f3f4 <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 8003950:	8933      	ldrh	r3, [r6, #8]
 8003952:	2b02      	cmp	r3, #2
 8003954:	f47f af44 	bne.w	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
      PRINT_INFO("<last socket_err> = %ld", ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003958:	8970      	ldrh	r0, [r6, #10]
 800395a:	89f1      	ldrh	r1, [r6, #14]
 800395c:	4440      	add	r0, r8
 800395e:	f011 f9e9 	bl	8014d34 <ATutil_convertStringToInt>
 8003962:	4602      	mov	r2, r0
 8003964:	4939      	ldr	r1, [pc, #228]	; (8003a4c <fRspAnalyze_SOCKETCMD+0x300>)
 8003966:	4628      	mov	r0, r5
 8003968:	f022 ff6e 	bl	8026848 <sprintf>
 800396c:	4628      	mov	r0, r5
 800396e:	f01b fcdc 	bl	801f32a <crs_strlen>
 8003972:	b283      	uxth	r3, r0
 8003974:	462a      	mov	r2, r5
 8003976:	2101      	movs	r1, #1
 8003978:	2002      	movs	r0, #2
 800397a:	f01b fd19 	bl	801f3b0 <traceIF_itmPrint>
 800397e:	4628      	mov	r0, r5
 8003980:	f01b fcd3 	bl	801f32a <crs_strlen>
 8003984:	b283      	uxth	r3, r0
 8003986:	462a      	mov	r2, r5
 8003988:	2101      	movs	r1, #1
 800398a:	2002      	movs	r0, #2
 800398c:	f01b fd32 	bl	801f3f4 <traceIF_uartPrint>
 8003990:	e726      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    PRINT_INFO("analyze of this command not implemented")
 8003992:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 8003a54 <fRspAnalyze_SOCKETCMD+0x308>
 8003996:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>
 800399a:	f10e 0a30 	add.w	sl, lr, #48	; 0x30
 800399e:	4675      	mov	r5, lr
 80039a0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80039a2:	f8cc 0000 	str.w	r0, [ip]
 80039a6:	f8cc 1004 	str.w	r1, [ip, #4]
 80039aa:	f8cc 2008 	str.w	r2, [ip, #8]
 80039ae:	f8cc 300c 	str.w	r3, [ip, #12]
 80039b2:	46ae      	mov	lr, r5
 80039b4:	f10c 0c10 	add.w	ip, ip, #16
 80039b8:	4555      	cmp	r5, sl
 80039ba:	d1f0      	bne.n	800399e <fRspAnalyze_SOCKETCMD+0x252>
 80039bc:	882b      	ldrh	r3, [r5, #0]
 80039be:	f8ac 3000 	strh.w	r3, [ip]
 80039c2:	4d1d      	ldr	r5, [pc, #116]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80039c4:	4628      	mov	r0, r5
 80039c6:	f01b fcb0 	bl	801f32a <crs_strlen>
 80039ca:	b283      	uxth	r3, r0
 80039cc:	462a      	mov	r2, r5
 80039ce:	2101      	movs	r1, #1
 80039d0:	2002      	movs	r0, #2
 80039d2:	f01b fced 	bl	801f3b0 <traceIF_itmPrint>
 80039d6:	4628      	mov	r0, r5
 80039d8:	f01b fca7 	bl	801f32a <crs_strlen>
 80039dc:	b283      	uxth	r3, r0
 80039de:	462a      	mov	r2, r5
 80039e0:	2101      	movs	r1, #1
 80039e2:	2002      	movs	r0, #2
 80039e4:	f01b fd06 	bl	801f3f4 <traceIF_uartPrint>
 80039e8:	e6fa      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
    PRINT_INFO("unexpected command")
 80039ea:	4d13      	ldr	r5, [pc, #76]	; (8003a38 <fRspAnalyze_SOCKETCMD+0x2ec>)
 80039ec:	f8df c068 	ldr.w	ip, [pc, #104]	; 8003a58 <fRspAnalyze_SOCKETCMD+0x30c>
 80039f0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80039f4:	6028      	str	r0, [r5, #0]
 80039f6:	6069      	str	r1, [r5, #4]
 80039f8:	60aa      	str	r2, [r5, #8]
 80039fa:	60eb      	str	r3, [r5, #12]
 80039fc:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8003a00:	6128      	str	r0, [r5, #16]
 8003a02:	6169      	str	r1, [r5, #20]
 8003a04:	61aa      	str	r2, [r5, #24]
 8003a06:	f89c 3000 	ldrb.w	r3, [ip]
 8003a0a:	772b      	strb	r3, [r5, #28]
 8003a0c:	4628      	mov	r0, r5
 8003a0e:	f01b fc8c 	bl	801f32a <crs_strlen>
 8003a12:	b283      	uxth	r3, r0
 8003a14:	462a      	mov	r2, r5
 8003a16:	2101      	movs	r1, #1
 8003a18:	2002      	movs	r0, #2
 8003a1a:	f01b fcc9 	bl	801f3b0 <traceIF_itmPrint>
 8003a1e:	4628      	mov	r0, r5
 8003a20:	f01b fc83 	bl	801f32a <crs_strlen>
 8003a24:	b283      	uxth	r3, r0
 8003a26:	462a      	mov	r2, r5
 8003a28:	2101      	movs	r1, #1
 8003a2a:	2002      	movs	r0, #2
 8003a2c:	f01b fce2 	bl	801f3f4 <traceIF_uartPrint>
 8003a30:	e6d6      	b.n	80037e0 <fRspAnalyze_SOCKETCMD+0x94>
 8003a32:	bf00      	nop
 8003a34:	0802bc98 	.word	0x0802bc98
 8003a38:	200048dc 	.word	0x200048dc
 8003a3c:	0802bcc4 	.word	0x0802bcc4
 8003a40:	20001838 	.word	0x20001838
 8003a44:	0802bcec 	.word	0x0802bcec
 8003a48:	0802bd08 	.word	0x0802bd08
 8003a4c:	0802bd4c 	.word	0x0802bd4c
 8003a50:	0802bd24 	.word	0x0802bd24
 8003a54:	0802bd70 	.word	0x0802bd70
 8003a58:	0802bda4 	.word	0x0802bda4

08003a5c <fRspAnalyze_SOCKETDATA>:
{
 8003a5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003a60:	b085      	sub	sp, #20
 8003a62:	4606      	mov	r6, r0
 8003a64:	468a      	mov	sl, r1
 8003a66:	4615      	mov	r5, r2
 8003a68:	461c      	mov	r4, r3
  PRINT_API("enter fRspAnalyze_SOCKETDATA()")
 8003a6a:	4fc1      	ldr	r7, [pc, #772]	; (8003d70 <fRspAnalyze_SOCKETDATA+0x314>)
 8003a6c:	f8df c304 	ldr.w	ip, [pc, #772]	; 8003d74 <fRspAnalyze_SOCKETDATA+0x318>
 8003a70:	f107 0820 	add.w	r8, r7, #32
 8003a74:	46be      	mov	lr, r7
 8003a76:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8003a7a:	f8cc 0000 	str.w	r0, [ip]
 8003a7e:	f8cc 1004 	str.w	r1, [ip, #4]
 8003a82:	f8cc 2008 	str.w	r2, [ip, #8]
 8003a86:	f8cc 300c 	str.w	r3, [ip, #12]
 8003a8a:	4677      	mov	r7, lr
 8003a8c:	f10c 0c10 	add.w	ip, ip, #16
 8003a90:	45c6      	cmp	lr, r8
 8003a92:	d1ef      	bne.n	8003a74 <fRspAnalyze_SOCKETDATA+0x18>
 8003a94:	cf07      	ldmia	r7!, {r0, r1, r2}
 8003a96:	f8cc 0000 	str.w	r0, [ip]
 8003a9a:	f8cc 1004 	str.w	r1, [ip, #4]
 8003a9e:	f8cc 2008 	str.w	r2, [ip, #8]
 8003aa2:	783b      	ldrb	r3, [r7, #0]
 8003aa4:	f88c 300c 	strb.w	r3, [ip, #12]
 8003aa8:	4fb2      	ldr	r7, [pc, #712]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003aaa:	4638      	mov	r0, r7
 8003aac:	f01b fc3d 	bl	801f32a <crs_strlen>
 8003ab0:	b283      	uxth	r3, r0
 8003ab2:	463a      	mov	r2, r7
 8003ab4:	2104      	movs	r1, #4
 8003ab6:	2002      	movs	r0, #2
 8003ab8:	f01b fc7a 	bl	801f3b0 <traceIF_itmPrint>
 8003abc:	4638      	mov	r0, r7
 8003abe:	f01b fc34 	bl	801f32a <crs_strlen>
 8003ac2:	b283      	uxth	r3, r0
 8003ac4:	463a      	mov	r2, r7
 8003ac6:	2104      	movs	r1, #4
 8003ac8:	2002      	movs	r0, #2
 8003aca:	f01b fc93 	bl	801f3f4 <traceIF_uartPrint>
  START_PARAM_LOOP()
 8003ace:	f04f 0800 	mov.w	r8, #0
  uint32_t rlength = 0U;
 8003ad2:	f8cd 8004 	str.w	r8, [sp, #4]
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8003ad6:	f04f 0910 	mov.w	r9, #16
  START_PARAM_LOOP()
 8003ada:	4622      	mov	r2, r4
 8003adc:	4629      	mov	r1, r5
 8003ade:	4630      	mov	r0, r6
 8003ae0:	f008 fcb2 	bl	800c448 <atcc_extractElement>
 8003ae4:	2801      	cmp	r0, #1
 8003ae6:	d001      	beq.n	8003aec <fRspAnalyze_SOCKETDATA+0x90>
 8003ae8:	f04f 0801 	mov.w	r8, #1
 8003aec:	89e1      	ldrh	r1, [r4, #14]
 8003aee:	2900      	cmp	r1, #0
 8003af0:	f000 81e5 	beq.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETDATA_SEND)
 8003af4:	69f3      	ldr	r3, [r6, #28]
 8003af6:	2b4b      	cmp	r3, #75	; 0x4b
 8003af8:	d010      	beq.n	8003b1c <fRspAnalyze_SOCKETDATA+0xc0>
  else if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_SOCKETDATA_RECEIVE)
 8003afa:	2b4c      	cmp	r3, #76	; 0x4c
 8003afc:	f040 81b6 	bne.w	8003e6c <fRspAnalyze_SOCKETDATA+0x410>
    if (element_infos->param_rank == 2U)
 8003b00:	8923      	ldrh	r3, [r4, #8]
 8003b02:	2b02      	cmp	r3, #2
 8003b04:	d04a      	beq.n	8003b9c <fRspAnalyze_SOCKETDATA+0x140>
    else if (element_infos->param_rank == 3U)
 8003b06:	3b03      	subs	r3, #3
 8003b08:	2b04      	cmp	r3, #4
 8003b0a:	f200 81d8 	bhi.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
 8003b0e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8003b12:	0086      	.short	0x0086
 8003b14:	00c100a4 	.word	0x00c100a4
 8003b18:	01a60190 	.word	0x01a60190
    if (element_infos->param_rank == 2U)
 8003b1c:	8923      	ldrh	r3, [r4, #8]
 8003b1e:	2b02      	cmp	r3, #2
 8003b20:	d01f      	beq.n	8003b62 <fRspAnalyze_SOCKETDATA+0x106>
    else if (element_infos->param_rank == 3U)
 8003b22:	2b03      	cmp	r3, #3
 8003b24:	f040 81cb 	bne.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      PRINT_DBG("<SOCKETDATA_SEND: wlength> = %ld",
 8003b28:	8960      	ldrh	r0, [r4, #10]
 8003b2a:	4428      	add	r0, r5
 8003b2c:	f011 f902 	bl	8014d34 <ATutil_convertStringToInt>
 8003b30:	4602      	mov	r2, r0
 8003b32:	4f90      	ldr	r7, [pc, #576]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003b34:	4990      	ldr	r1, [pc, #576]	; (8003d78 <fRspAnalyze_SOCKETDATA+0x31c>)
 8003b36:	4638      	mov	r0, r7
 8003b38:	f022 fe86 	bl	8026848 <sprintf>
 8003b3c:	4638      	mov	r0, r7
 8003b3e:	f01b fbf4 	bl	801f32a <crs_strlen>
 8003b42:	b283      	uxth	r3, r0
 8003b44:	463a      	mov	r2, r7
 8003b46:	2102      	movs	r1, #2
 8003b48:	4608      	mov	r0, r1
 8003b4a:	f01b fc31 	bl	801f3b0 <traceIF_itmPrint>
 8003b4e:	4638      	mov	r0, r7
 8003b50:	f01b fbeb 	bl	801f32a <crs_strlen>
 8003b54:	b283      	uxth	r3, r0
 8003b56:	463a      	mov	r2, r7
 8003b58:	2102      	movs	r1, #2
 8003b5a:	4608      	mov	r0, r1
 8003b5c:	f01b fc4a 	bl	801f3f4 <traceIF_uartPrint>
 8003b60:	e1ad      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      PRINT_DBG("<SOCKETDATA_SEND: socket_id> = %ld",
 8003b62:	8960      	ldrh	r0, [r4, #10]
 8003b64:	4428      	add	r0, r5
 8003b66:	f011 f8e5 	bl	8014d34 <ATutil_convertStringToInt>
 8003b6a:	4602      	mov	r2, r0
 8003b6c:	4f81      	ldr	r7, [pc, #516]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003b6e:	4983      	ldr	r1, [pc, #524]	; (8003d7c <fRspAnalyze_SOCKETDATA+0x320>)
 8003b70:	4638      	mov	r0, r7
 8003b72:	f022 fe69 	bl	8026848 <sprintf>
 8003b76:	4638      	mov	r0, r7
 8003b78:	f01b fbd7 	bl	801f32a <crs_strlen>
 8003b7c:	b283      	uxth	r3, r0
 8003b7e:	463a      	mov	r2, r7
 8003b80:	2102      	movs	r1, #2
 8003b82:	4608      	mov	r0, r1
 8003b84:	f01b fc14 	bl	801f3b0 <traceIF_itmPrint>
 8003b88:	4638      	mov	r0, r7
 8003b8a:	f01b fbce 	bl	801f32a <crs_strlen>
 8003b8e:	b283      	uxth	r3, r0
 8003b90:	463a      	mov	r2, r7
 8003b92:	2102      	movs	r1, #2
 8003b94:	4608      	mov	r0, r1
 8003b96:	f01b fc2d 	bl	801f3f4 <traceIF_uartPrint>
 8003b9a:	e190      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      uint32_t socketId =  ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003b9c:	8960      	ldrh	r0, [r4, #10]
 8003b9e:	4428      	add	r0, r5
 8003ba0:	f011 f8c8 	bl	8014d34 <ATutil_convertStringToInt>
 8003ba4:	4683      	mov	fp, r0
      PRINT_DBG("<SOCKETDATA_RECEIVE: socket_id> = %ld", socketId)
 8003ba6:	4f73      	ldr	r7, [pc, #460]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003ba8:	4602      	mov	r2, r0
 8003baa:	4975      	ldr	r1, [pc, #468]	; (8003d80 <fRspAnalyze_SOCKETDATA+0x324>)
 8003bac:	4638      	mov	r0, r7
 8003bae:	f022 fe4b 	bl	8026848 <sprintf>
 8003bb2:	4638      	mov	r0, r7
 8003bb4:	f01b fbb9 	bl	801f32a <crs_strlen>
 8003bb8:	b283      	uxth	r3, r0
 8003bba:	463a      	mov	r2, r7
 8003bbc:	2102      	movs	r1, #2
 8003bbe:	4608      	mov	r0, r1
 8003bc0:	f01b fbf6 	bl	801f3b0 <traceIF_itmPrint>
 8003bc4:	4638      	mov	r0, r7
 8003bc6:	f01b fbb0 	bl	801f32a <crs_strlen>
 8003bca:	b283      	uxth	r3, r0
 8003bcc:	463a      	mov	r2, r7
 8003bce:	2102      	movs	r1, #2
 8003bd0:	4608      	mov	r0, r1
 8003bd2:	f01b fc0f 	bl	801f3f4 <traceIF_uartPrint>
      uint32_t expected_socketID = atcm_socket_get_modem_cid(p_modem_ctxt,
 8003bd6:	f8da 1744 	ldr.w	r1, [sl, #1860]	; 0x744
 8003bda:	4650      	mov	r0, sl
 8003bdc:	f010 fac6 	bl	801416c <atcm_socket_get_modem_cid>
      if (socketId != expected_socketID)
 8003be0:	4583      	cmp	fp, r0
 8003be2:	f000 816c 	beq.w	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
        PRINT_ERR("<SOCKETDATA_RECEIVE> on socket_id= %ld whereas expected socket_id= %ld",
 8003be6:	f8da 3744 	ldr.w	r3, [sl, #1860]	; 0x744
 8003bea:	465a      	mov	r2, fp
 8003bec:	4965      	ldr	r1, [pc, #404]	; (8003d84 <fRspAnalyze_SOCKETDATA+0x328>)
 8003bee:	4638      	mov	r0, r7
 8003bf0:	f022 fe2a 	bl	8026848 <sprintf>
 8003bf4:	4638      	mov	r0, r7
 8003bf6:	f01b fb98 	bl	801f32a <crs_strlen>
 8003bfa:	b283      	uxth	r3, r0
 8003bfc:	463a      	mov	r2, r7
 8003bfe:	2110      	movs	r1, #16
 8003c00:	2002      	movs	r0, #2
 8003c02:	f01b fbd5 	bl	801f3b0 <traceIF_itmPrint>
 8003c06:	4638      	mov	r0, r7
 8003c08:	f01b fb8f 	bl	801f32a <crs_strlen>
 8003c0c:	b283      	uxth	r3, r0
 8003c0e:	463a      	mov	r2, r7
 8003c10:	2110      	movs	r1, #16
 8003c12:	2002      	movs	r0, #2
 8003c14:	f01b fbee 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATACTION_RSP_ERROR;
 8003c18:	f04f 0904 	mov.w	r9, #4
 8003c1c:	e156      	b.n	8003ecc <fRspAnalyze_SOCKETDATA+0x470>
      rlength = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 8003c1e:	8960      	ldrh	r0, [r4, #10]
 8003c20:	4428      	add	r0, r5
 8003c22:	f011 f887 	bl	8014d34 <ATutil_convertStringToInt>
 8003c26:	4602      	mov	r2, r0
 8003c28:	9001      	str	r0, [sp, #4]
      PRINT_DBG("<SOCKETDATA_RECEIVE: rlength> = %ld", rlength)
 8003c2a:	4f52      	ldr	r7, [pc, #328]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003c2c:	4956      	ldr	r1, [pc, #344]	; (8003d88 <fRspAnalyze_SOCKETDATA+0x32c>)
 8003c2e:	4638      	mov	r0, r7
 8003c30:	f022 fe0a 	bl	8026848 <sprintf>
 8003c34:	4638      	mov	r0, r7
 8003c36:	f01b fb78 	bl	801f32a <crs_strlen>
 8003c3a:	b283      	uxth	r3, r0
 8003c3c:	463a      	mov	r2, r7
 8003c3e:	2102      	movs	r1, #2
 8003c40:	4608      	mov	r0, r1
 8003c42:	f01b fbb5 	bl	801f3b0 <traceIF_itmPrint>
 8003c46:	4638      	mov	r0, r7
 8003c48:	f01b fb6f 	bl	801f32a <crs_strlen>
 8003c4c:	b283      	uxth	r3, r0
 8003c4e:	463a      	mov	r2, r7
 8003c50:	2102      	movs	r1, #2
 8003c52:	4608      	mov	r0, r1
 8003c54:	f01b fbce 	bl	801f3f4 <traceIF_uartPrint>
 8003c58:	e131      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      PRINT_DBG("<SOCKETDATA_RECEIVE: moreData> = %ld",
 8003c5a:	8960      	ldrh	r0, [r4, #10]
 8003c5c:	4428      	add	r0, r5
 8003c5e:	f011 f869 	bl	8014d34 <ATutil_convertStringToInt>
 8003c62:	4602      	mov	r2, r0
 8003c64:	4f43      	ldr	r7, [pc, #268]	; (8003d74 <fRspAnalyze_SOCKETDATA+0x318>)
 8003c66:	4949      	ldr	r1, [pc, #292]	; (8003d8c <fRspAnalyze_SOCKETDATA+0x330>)
 8003c68:	4638      	mov	r0, r7
 8003c6a:	f022 fded 	bl	8026848 <sprintf>
 8003c6e:	4638      	mov	r0, r7
 8003c70:	f01b fb5b 	bl	801f32a <crs_strlen>
 8003c74:	b283      	uxth	r3, r0
 8003c76:	463a      	mov	r2, r7
 8003c78:	2102      	movs	r1, #2
 8003c7a:	4608      	mov	r0, r1
 8003c7c:	f01b fb98 	bl	801f3b0 <traceIF_itmPrint>
 8003c80:	4638      	mov	r0, r7
 8003c82:	f01b fb52 	bl	801f32a <crs_strlen>
 8003c86:	b283      	uxth	r3, r0
 8003c88:	463a      	mov	r2, r7
 8003c8a:	2102      	movs	r1, #2
 8003c8c:	4608      	mov	r0, r1
 8003c8e:	f01b fbb1 	bl	801f3f4 <traceIF_uartPrint>
 8003c92:	e114      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
      uint16_t data_size = (element_infos->str_size - 2U) >> 1; /* remove first and last quote (-2) then divide by 2 */
 8003c94:	3902      	subs	r1, #2
 8003c96:	f3c1 074f 	ubfx	r7, r1, #1, #16
      if (rlength != data_size)
 8003c9a:	9b01      	ldr	r3, [sp, #4]
 8003c9c:	42bb      	cmp	r3, r7
 8003c9e:	d120      	bne.n	8003ce2 <fRspAnalyze_SOCKETDATA+0x286>
      PRINT_DBG("<SOCKETDATA_RECEIVE: rdata> computed data_size = %d", data_size)
 8003ca0:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8003d74 <fRspAnalyze_SOCKETDATA+0x318>
 8003ca4:	463a      	mov	r2, r7
 8003ca6:	493a      	ldr	r1, [pc, #232]	; (8003d90 <fRspAnalyze_SOCKETDATA+0x334>)
 8003ca8:	4658      	mov	r0, fp
 8003caa:	f022 fdcd 	bl	8026848 <sprintf>
 8003cae:	4658      	mov	r0, fp
 8003cb0:	f01b fb3b 	bl	801f32a <crs_strlen>
 8003cb4:	b283      	uxth	r3, r0
 8003cb6:	465a      	mov	r2, fp
 8003cb8:	2102      	movs	r1, #2
 8003cba:	4608      	mov	r0, r1
 8003cbc:	f01b fb78 	bl	801f3b0 <traceIF_itmPrint>
 8003cc0:	4658      	mov	r0, fp
 8003cc2:	f01b fb32 	bl	801f32a <crs_strlen>
 8003cc6:	b283      	uxth	r3, r0
 8003cc8:	465a      	mov	r2, fp
 8003cca:	2102      	movs	r1, #2
 8003ccc:	4608      	mov	r0, r1
 8003cce:	f01b fb91 	bl	801f3f4 <traceIF_uartPrint>
      if (data_size <= p_modem_ctxt->socket_ctxt.socketReceivedata.max_buffer_size)
 8003cd2:	f8da 3754 	ldr.w	r3, [sl, #1876]	; 0x754
 8003cd6:	42bb      	cmp	r3, r7
 8003cd8:	f0c0 8090 	bcc.w	8003dfc <fRspAnalyze_SOCKETDATA+0x3a0>
        for (idx = 0U; ((idx < data_size) && (retval != ATACTION_RSP_ERROR)); idx++)
 8003cdc:	f04f 0b00 	mov.w	fp, #0
 8003ce0:	e01f      	b.n	8003d22 <fRspAnalyze_SOCKETDATA+0x2c6>
        PRINT_ERR("Buffer size received (%d) does not match expected size (%ld)", data_size, rlength)
 8003ce2:	f8df b090 	ldr.w	fp, [pc, #144]	; 8003d74 <fRspAnalyze_SOCKETDATA+0x318>
 8003ce6:	463a      	mov	r2, r7
 8003ce8:	492a      	ldr	r1, [pc, #168]	; (8003d94 <fRspAnalyze_SOCKETDATA+0x338>)
 8003cea:	4658      	mov	r0, fp
 8003cec:	f022 fdac 	bl	8026848 <sprintf>
 8003cf0:	4658      	mov	r0, fp
 8003cf2:	f01b fb1a 	bl	801f32a <crs_strlen>
 8003cf6:	b283      	uxth	r3, r0
 8003cf8:	465a      	mov	r2, fp
 8003cfa:	2110      	movs	r1, #16
 8003cfc:	2002      	movs	r0, #2
 8003cfe:	f01b fb57 	bl	801f3b0 <traceIF_itmPrint>
 8003d02:	4658      	mov	r0, fp
 8003d04:	f01b fb11 	bl	801f32a <crs_strlen>
 8003d08:	b283      	uxth	r3, r0
 8003d0a:	465a      	mov	r2, fp
 8003d0c:	2110      	movs	r1, #16
 8003d0e:	2002      	movs	r0, #2
 8003d10:	f01b fb70 	bl	801f3f4 <traceIF_uartPrint>
 8003d14:	e7c4      	b.n	8003ca0 <fRspAnalyze_SOCKETDATA+0x244>
            retval = ATACTION_RSP_ERROR;
 8003d16:	f04f 0904 	mov.w	r9, #4
        for (idx = 0U; ((idx < data_size) && (retval != ATACTION_RSP_ERROR)); idx++)
 8003d1a:	f10b 0b01 	add.w	fp, fp, #1
 8003d1e:	fa1f fb8b 	uxth.w	fp, fp
 8003d22:	45bb      	cmp	fp, r7
 8003d24:	d216      	bcs.n	8003d54 <fRspAnalyze_SOCKETDATA+0x2f8>
 8003d26:	f1b9 0f04 	cmp.w	r9, #4
 8003d2a:	d013      	beq.n	8003d54 <fRspAnalyze_SOCKETDATA+0x2f8>
          if (convertHEXToChar((uint8_t)p_msg_in->buffer[element_infos->str_start_idx + 1U + (idx * 2U)],
 8003d2c:	8963      	ldrh	r3, [r4, #10]
 8003d2e:	eb03 034b 	add.w	r3, r3, fp, lsl #1
 8003d32:	1c58      	adds	r0, r3, #1
                               (uint8_t)p_msg_in->buffer[element_infos->str_start_idx + 2U + (idx * 2U)],
 8003d34:	3302      	adds	r3, #2
          if (convertHEXToChar((uint8_t)p_msg_in->buffer[element_infos->str_start_idx + 1U + (idx * 2U)],
 8003d36:	f10d 020f 	add.w	r2, sp, #15
 8003d3a:	5ce9      	ldrb	r1, [r5, r3]
 8003d3c:	5c28      	ldrb	r0, [r5, r0]
 8003d3e:	f7ff f835 	bl	8002dac <convertHEXToChar>
 8003d42:	2800      	cmp	r0, #0
 8003d44:	d1e7      	bne.n	8003d16 <fRspAnalyze_SOCKETDATA+0x2ba>
            p_modem_ctxt->socket_ctxt.socketReceivedata.p_buffer_addr_rcv[idx] = conVal;
 8003d46:	f8da 374c 	ldr.w	r3, [sl, #1868]	; 0x74c
 8003d4a:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8003d4e:	f803 200b 	strb.w	r2, [r3, fp]
 8003d52:	e7e2      	b.n	8003d1a <fRspAnalyze_SOCKETDATA+0x2be>
        if (retval != ATACTION_RSP_ERROR)
 8003d54:	f1b9 0f04 	cmp.w	r9, #4
 8003d58:	d01e      	beq.n	8003d98 <fRspAnalyze_SOCKETDATA+0x33c>
          p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size = data_size;
 8003d5a:	f8ca 7750 	str.w	r7, [sl, #1872]	; 0x750
          PRINT_BUF((const uint8_t *)&p_modem_ctxt->socket_ctxt.socketReceivedata.p_buffer_addr_rcv[0], data_size)
 8003d5e:	463b      	mov	r3, r7
 8003d60:	f8da 274c 	ldr.w	r2, [sl, #1868]	; 0x74c
 8003d64:	2102      	movs	r1, #2
 8003d66:	4608      	mov	r0, r1
 8003d68:	f01b fe10 	bl	801f98c <traceIF_BufCharPrint>
 8003d6c:	e0a7      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
 8003d6e:	bf00      	nop
 8003d70:	0802bdc4 	.word	0x0802bdc4
 8003d74:	200048dc 	.word	0x200048dc
 8003d78:	0802be24 	.word	0x0802be24
 8003d7c:	0802bdf4 	.word	0x0802bdf4
 8003d80:	0802be50 	.word	0x0802be50
 8003d84:	0802be80 	.word	0x0802be80
 8003d88:	0802bed8 	.word	0x0802bed8
 8003d8c:	0802bf08 	.word	0x0802bf08
 8003d90:	0802bf88 	.word	0x0802bf88
 8003d94:	0802bf38 	.word	0x0802bf38
          PRINT_ERR("error occurred during string conversion")
 8003d98:	f8df e140 	ldr.w	lr, [pc, #320]	; 8003edc <fRspAnalyze_SOCKETDATA+0x480>
 8003d9c:	f8df c134 	ldr.w	ip, [pc, #308]	; 8003ed4 <fRspAnalyze_SOCKETDATA+0x478>
 8003da0:	f10e 0b30 	add.w	fp, lr, #48	; 0x30
 8003da4:	4677      	mov	r7, lr
 8003da6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8003da8:	f8cc 0000 	str.w	r0, [ip]
 8003dac:	f8cc 1004 	str.w	r1, [ip, #4]
 8003db0:	f8cc 2008 	str.w	r2, [ip, #8]
 8003db4:	f8cc 300c 	str.w	r3, [ip, #12]
 8003db8:	46be      	mov	lr, r7
 8003dba:	f10c 0c10 	add.w	ip, ip, #16
 8003dbe:	455f      	cmp	r7, fp
 8003dc0:	d1f0      	bne.n	8003da4 <fRspAnalyze_SOCKETDATA+0x348>
 8003dc2:	e8be 0003 	ldmia.w	lr!, {r0, r1}
 8003dc6:	f8cc 0000 	str.w	r0, [ip]
 8003dca:	f8cc 1004 	str.w	r1, [ip, #4]
 8003dce:	4f41      	ldr	r7, [pc, #260]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003dd0:	4638      	mov	r0, r7
 8003dd2:	f01b faaa 	bl	801f32a <crs_strlen>
 8003dd6:	b283      	uxth	r3, r0
 8003dd8:	463a      	mov	r2, r7
 8003dda:	2110      	movs	r1, #16
 8003ddc:	2002      	movs	r0, #2
 8003dde:	f01b fae7 	bl	801f3b0 <traceIF_itmPrint>
 8003de2:	4638      	mov	r0, r7
 8003de4:	f01b faa1 	bl	801f32a <crs_strlen>
 8003de8:	b283      	uxth	r3, r0
 8003dea:	463a      	mov	r2, r7
 8003dec:	2110      	movs	r1, #16
 8003dee:	2002      	movs	r0, #2
 8003df0:	f01b fb00 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size = 0;
 8003df4:	2300      	movs	r3, #0
 8003df6:	f8ca 3750 	str.w	r3, [sl, #1872]	; 0x750
 8003dfa:	e060      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
        PRINT_ERR("Size of received buffer (%d) exceed client buffer size (%ld)", data_size,
 8003dfc:	4c35      	ldr	r4, [pc, #212]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003dfe:	463a      	mov	r2, r7
 8003e00:	4935      	ldr	r1, [pc, #212]	; (8003ed8 <fRspAnalyze_SOCKETDATA+0x47c>)
 8003e02:	4620      	mov	r0, r4
 8003e04:	f022 fd20 	bl	8026848 <sprintf>
 8003e08:	4620      	mov	r0, r4
 8003e0a:	f01b fa8e 	bl	801f32a <crs_strlen>
 8003e0e:	b283      	uxth	r3, r0
 8003e10:	4622      	mov	r2, r4
 8003e12:	2110      	movs	r1, #16
 8003e14:	2002      	movs	r0, #2
 8003e16:	f01b facb 	bl	801f3b0 <traceIF_itmPrint>
 8003e1a:	4620      	mov	r0, r4
 8003e1c:	f01b fa85 	bl	801f32a <crs_strlen>
 8003e20:	b283      	uxth	r3, r0
 8003e22:	4622      	mov	r2, r4
 8003e24:	2110      	movs	r1, #16
 8003e26:	2002      	movs	r0, #2
 8003e28:	f01b fae4 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATACTION_RSP_ERROR;
 8003e2c:	f04f 0904 	mov.w	r9, #4
 8003e30:	e04c      	b.n	8003ecc <fRspAnalyze_SOCKETDATA+0x470>
      (void) memset((void *)&p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value[0],
 8003e32:	f20a 7759 	addw	r7, sl, #1881	; 0x759
 8003e36:	2240      	movs	r2, #64	; 0x40
 8003e38:	2100      	movs	r1, #0
 8003e3a:	4638      	mov	r0, r7
 8003e3c:	f022 fd77 	bl	802692e <memset>
      p_modem_ctxt->socket_ctxt.socketReceivedata.remote_port = 0U;
 8003e40:	2300      	movs	r3, #0
 8003e42:	f8aa 379a 	strh.w	r3, [sl, #1946]	; 0x79a
      atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8003e46:	8960      	ldrh	r0, [r4, #10]
 8003e48:	463a      	mov	r2, r7
 8003e4a:	89e1      	ldrh	r1, [r4, #14]
 8003e4c:	4428      	add	r0, r5
 8003e4e:	f008 fd10 	bl	800c872 <atcm_extract_IP_address>
        atcm_get_ip_address_type((AT_CHAR_t *)&p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value);
 8003e52:	4638      	mov	r0, r7
 8003e54:	f008 fce0 	bl	800c818 <atcm_get_ip_address_type>
      p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_type =
 8003e58:	f88a 0758 	strb.w	r0, [sl, #1880]	; 0x758
 8003e5c:	e02f      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
        (uint16_t) ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003e5e:	8960      	ldrh	r0, [r4, #10]
 8003e60:	4428      	add	r0, r5
 8003e62:	f010 ff67 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->socket_ctxt.socketReceivedata.remote_port =
 8003e66:	f8aa 079a 	strh.w	r0, [sl, #1946]	; 0x79a
 8003e6a:	e028      	b.n	8003ebe <fRspAnalyze_SOCKETDATA+0x462>
    PRINT_ERR("unexpected command")
 8003e6c:	f8df e070 	ldr.w	lr, [pc, #112]	; 8003ee0 <fRspAnalyze_SOCKETDATA+0x484>
 8003e70:	4f18      	ldr	r7, [pc, #96]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003e72:	f10e 0b20 	add.w	fp, lr, #32
 8003e76:	46f4      	mov	ip, lr
 8003e78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8003e7c:	6038      	str	r0, [r7, #0]
 8003e7e:	6079      	str	r1, [r7, #4]
 8003e80:	60ba      	str	r2, [r7, #8]
 8003e82:	60fb      	str	r3, [r7, #12]
 8003e84:	46e6      	mov	lr, ip
 8003e86:	3710      	adds	r7, #16
 8003e88:	45dc      	cmp	ip, fp
 8003e8a:	d1f4      	bne.n	8003e76 <fRspAnalyze_SOCKETDATA+0x41a>
 8003e8c:	f8bc 2000 	ldrh.w	r2, [ip]
 8003e90:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8003e94:	803a      	strh	r2, [r7, #0]
 8003e96:	70bb      	strb	r3, [r7, #2]
 8003e98:	4f0e      	ldr	r7, [pc, #56]	; (8003ed4 <fRspAnalyze_SOCKETDATA+0x478>)
 8003e9a:	4638      	mov	r0, r7
 8003e9c:	f01b fa45 	bl	801f32a <crs_strlen>
 8003ea0:	b283      	uxth	r3, r0
 8003ea2:	463a      	mov	r2, r7
 8003ea4:	2110      	movs	r1, #16
 8003ea6:	2002      	movs	r0, #2
 8003ea8:	f01b fa82 	bl	801f3b0 <traceIF_itmPrint>
 8003eac:	4638      	mov	r0, r7
 8003eae:	f01b fa3c 	bl	801f32a <crs_strlen>
 8003eb2:	b283      	uxth	r3, r0
 8003eb4:	463a      	mov	r2, r7
 8003eb6:	2110      	movs	r1, #16
 8003eb8:	2002      	movs	r0, #2
 8003eba:	f01b fa9b 	bl	801f3f4 <traceIF_uartPrint>
  END_PARAM_LOOP()
 8003ebe:	f1b9 0f04 	cmp.w	r9, #4
 8003ec2:	d003      	beq.n	8003ecc <fRspAnalyze_SOCKETDATA+0x470>
 8003ec4:	f1b8 0f00 	cmp.w	r8, #0
 8003ec8:	f43f ae07 	beq.w	8003ada <fRspAnalyze_SOCKETDATA+0x7e>
}
 8003ecc:	4648      	mov	r0, r9
 8003ece:	b005      	add	sp, #20
 8003ed0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003ed4:	200048dc 	.word	0x200048dc
 8003ed8:	0802c000 	.word	0x0802c000
 8003edc:	0802bfc8 	.word	0x0802bfc8
 8003ee0:	0802c050 	.word	0x0802c050

08003ee4 <fRspAnalyze_SOCKETEV>:
{
 8003ee4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003ee8:	b083      	sub	sp, #12
 8003eea:	4604      	mov	r4, r0
 8003eec:	9101      	str	r1, [sp, #4]
 8003eee:	4616      	mov	r6, r2
 8003ef0:	461d      	mov	r5, r3
  PRINT_API("enter fRspAnalyze_SOCKETEV()")
 8003ef2:	f8df c224 	ldr.w	ip, [pc, #548]	; 8004118 <fRspAnalyze_SOCKETEV+0x234>
 8003ef6:	4f7f      	ldr	r7, [pc, #508]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8003ef8:	f10c 0920 	add.w	r9, ip, #32
 8003efc:	46e0      	mov	r8, ip
 8003efe:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 8003f02:	6038      	str	r0, [r7, #0]
 8003f04:	6079      	str	r1, [r7, #4]
 8003f06:	60ba      	str	r2, [r7, #8]
 8003f08:	60fb      	str	r3, [r7, #12]
 8003f0a:	46c4      	mov	ip, r8
 8003f0c:	3710      	adds	r7, #16
 8003f0e:	45c8      	cmp	r8, r9
 8003f10:	d1f4      	bne.n	8003efc <fRspAnalyze_SOCKETEV+0x18>
 8003f12:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 8003f16:	6038      	str	r0, [r7, #0]
 8003f18:	6079      	str	r1, [r7, #4]
 8003f1a:	f8bc 2000 	ldrh.w	r2, [ip]
 8003f1e:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8003f22:	813a      	strh	r2, [r7, #8]
 8003f24:	72bb      	strb	r3, [r7, #10]
 8003f26:	4f73      	ldr	r7, [pc, #460]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8003f28:	4638      	mov	r0, r7
 8003f2a:	f01b f9fe 	bl	801f32a <crs_strlen>
 8003f2e:	b283      	uxth	r3, r0
 8003f30:	463a      	mov	r2, r7
 8003f32:	2104      	movs	r1, #4
 8003f34:	2002      	movs	r0, #2
 8003f36:	f01b fa3b 	bl	801f3b0 <traceIF_itmPrint>
 8003f3a:	4638      	mov	r0, r7
 8003f3c:	f01b f9f5 	bl	801f32a <crs_strlen>
 8003f40:	b283      	uxth	r3, r0
 8003f42:	463a      	mov	r2, r7
 8003f44:	2104      	movs	r1, #4
 8003f46:	2002      	movs	r0, #2
 8003f48:	f01b fa54 	bl	801f3f4 <traceIF_uartPrint>
  if (p_atp_ctxt->current_atcmd.id != (CMD_ID_t) CMD_AT_SOCKETEV)
 8003f4c:	69e3      	ldr	r3, [r4, #28]
 8003f4e:	2b4d      	cmp	r3, #77	; 0x4d
 8003f50:	d105      	bne.n	8003f5e <fRspAnalyze_SOCKETEV+0x7a>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8003f52:	f04f 0810 	mov.w	r8, #16
}
 8003f56:	4640      	mov	r0, r8
 8003f58:	b003      	add	sp, #12
 8003f5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    START_PARAM_LOOP()
 8003f5e:	f04f 0900 	mov.w	r9, #0
  uint32_t event_id = 0U; /* initialize to a invalid value */
 8003f62:	46ca      	mov	sl, r9
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8003f64:	f04f 0810 	mov.w	r8, #16
    START_PARAM_LOOP()
 8003f68:	462a      	mov	r2, r5
 8003f6a:	4631      	mov	r1, r6
 8003f6c:	4620      	mov	r0, r4
 8003f6e:	f008 fa6b 	bl	800c448 <atcc_extractElement>
 8003f72:	2801      	cmp	r0, #1
 8003f74:	d001      	beq.n	8003f7a <fRspAnalyze_SOCKETEV+0x96>
 8003f76:	f04f 0901 	mov.w	r9, #1
 8003f7a:	89e9      	ldrh	r1, [r5, #14]
 8003f7c:	b139      	cbz	r1, 8003f8e <fRspAnalyze_SOCKETEV+0xaa>
    if (element_infos->param_rank == 2U)
 8003f7e:	892b      	ldrh	r3, [r5, #8]
 8003f80:	2b02      	cmp	r3, #2
 8003f82:	d008      	beq.n	8003f96 <fRspAnalyze_SOCKETEV+0xb2>
    else if (element_infos->param_rank == 3U)
 8003f84:	2b03      	cmp	r3, #3
 8003f86:	d02d      	beq.n	8003fe4 <fRspAnalyze_SOCKETEV+0x100>
    else if (element_infos->param_rank == 4U)
 8003f88:	2b04      	cmp	r3, #4
 8003f8a:	f000 8096 	beq.w	80040ba <fRspAnalyze_SOCKETEV+0x1d6>
    END_PARAM_LOOP()
 8003f8e:	f1b9 0f00 	cmp.w	r9, #0
 8003f92:	d1e0      	bne.n	8003f56 <fRspAnalyze_SOCKETEV+0x72>
 8003f94:	e7e8      	b.n	8003f68 <fRspAnalyze_SOCKETEV+0x84>
      event_id = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 8003f96:	8968      	ldrh	r0, [r5, #10]
 8003f98:	4430      	add	r0, r6
 8003f9a:	f010 fecb 	bl	8014d34 <ATutil_convertStringToInt>
 8003f9e:	4682      	mov	sl, r0
      PRINT_DBG("SOCKET_EVENT <event_id> = %ld : %s", event_id,
 8003fa0:	2801      	cmp	r0, #1
 8003fa2:	d01d      	beq.n	8003fe0 <fRspAnalyze_SOCKETEV+0xfc>
 8003fa4:	2802      	cmp	r0, #2
 8003fa6:	d019      	beq.n	8003fdc <fRspAnalyze_SOCKETEV+0xf8>
 8003fa8:	4b53      	ldr	r3, [pc, #332]	; (80040f8 <fRspAnalyze_SOCKETEV+0x214>)
 8003faa:	4f52      	ldr	r7, [pc, #328]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8003fac:	4652      	mov	r2, sl
 8003fae:	4953      	ldr	r1, [pc, #332]	; (80040fc <fRspAnalyze_SOCKETEV+0x218>)
 8003fb0:	4638      	mov	r0, r7
 8003fb2:	f022 fc49 	bl	8026848 <sprintf>
 8003fb6:	4638      	mov	r0, r7
 8003fb8:	f01b f9b7 	bl	801f32a <crs_strlen>
 8003fbc:	b283      	uxth	r3, r0
 8003fbe:	463a      	mov	r2, r7
 8003fc0:	2102      	movs	r1, #2
 8003fc2:	4608      	mov	r0, r1
 8003fc4:	f01b f9f4 	bl	801f3b0 <traceIF_itmPrint>
 8003fc8:	4638      	mov	r0, r7
 8003fca:	f01b f9ae 	bl	801f32a <crs_strlen>
 8003fce:	b283      	uxth	r3, r0
 8003fd0:	463a      	mov	r2, r7
 8003fd2:	2102      	movs	r1, #2
 8003fd4:	4608      	mov	r0, r1
 8003fd6:	f01b fa0d 	bl	801f3f4 <traceIF_uartPrint>
 8003fda:	e7d8      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
 8003fdc:	4b48      	ldr	r3, [pc, #288]	; (8004100 <fRspAnalyze_SOCKETEV+0x21c>)
 8003fde:	e7e4      	b.n	8003faa <fRspAnalyze_SOCKETEV+0xc6>
 8003fe0:	4b48      	ldr	r3, [pc, #288]	; (8004104 <fRspAnalyze_SOCKETEV+0x220>)
 8003fe2:	e7e2      	b.n	8003faa <fRspAnalyze_SOCKETEV+0xc6>
      uint32_t socket_id = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8003fe4:	8968      	ldrh	r0, [r5, #10]
 8003fe6:	4430      	add	r0, r6
 8003fe8:	f010 fea4 	bl	8014d34 <ATutil_convertStringToInt>
 8003fec:	4683      	mov	fp, r0
      socket_handle_t sockHandle = atcm_socket_get_socket_handle(p_modem_ctxt, socket_id);
 8003fee:	4601      	mov	r1, r0
 8003ff0:	9801      	ldr	r0, [sp, #4]
 8003ff2:	f010 f90d 	bl	8014210 <atcm_socket_get_socket_handle>
 8003ff6:	4603      	mov	r3, r0
      if (event_id == 1U)
 8003ff8:	f1ba 0f01 	cmp.w	sl, #1
 8003ffc:	d01b      	beq.n	8004036 <fRspAnalyze_SOCKETEV+0x152>
      else if (event_id == 3U)
 8003ffe:	f1ba 0f03 	cmp.w	sl, #3
 8004002:	d039      	beq.n	8004078 <fRspAnalyze_SOCKETEV+0x194>
        PRINT_DBG("SOCKET_EVENT: on socket %ld (handle=%ld) ignored", socket_id, sockHandle)
 8004004:	4f3b      	ldr	r7, [pc, #236]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8004006:	465a      	mov	r2, fp
 8004008:	493f      	ldr	r1, [pc, #252]	; (8004108 <fRspAnalyze_SOCKETEV+0x224>)
 800400a:	4638      	mov	r0, r7
 800400c:	f022 fc1c 	bl	8026848 <sprintf>
 8004010:	4638      	mov	r0, r7
 8004012:	f01b f98a 	bl	801f32a <crs_strlen>
 8004016:	b283      	uxth	r3, r0
 8004018:	463a      	mov	r2, r7
 800401a:	2102      	movs	r1, #2
 800401c:	4608      	mov	r0, r1
 800401e:	f01b f9c7 	bl	801f3b0 <traceIF_itmPrint>
 8004022:	4638      	mov	r0, r7
 8004024:	f01b f981 	bl	801f32a <crs_strlen>
 8004028:	b283      	uxth	r3, r0
 800402a:	463a      	mov	r2, r7
 800402c:	2102      	movs	r1, #2
 800402e:	4608      	mov	r0, r1
 8004030:	f01b f9e0 	bl	801f3f4 <traceIF_uartPrint>
 8004034:	e7ab      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
        (void) atcm_socket_set_urc_data_pending(p_modem_ctxt, sockHandle);
 8004036:	4680      	mov	r8, r0
 8004038:	4601      	mov	r1, r0
 800403a:	9801      	ldr	r0, [sp, #4]
 800403c:	f010 f91e 	bl	801427c <atcm_socket_set_urc_data_pending>
        PRINT_INFO("SOCKET_EVENT: RX data available on socket %ld (handle=%ld) ", socket_id, sockHandle)
 8004040:	4f2c      	ldr	r7, [pc, #176]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8004042:	4643      	mov	r3, r8
 8004044:	465a      	mov	r2, fp
 8004046:	4931      	ldr	r1, [pc, #196]	; (800410c <fRspAnalyze_SOCKETEV+0x228>)
 8004048:	4638      	mov	r0, r7
 800404a:	f022 fbfd 	bl	8026848 <sprintf>
 800404e:	4638      	mov	r0, r7
 8004050:	f01b f96b 	bl	801f32a <crs_strlen>
 8004054:	b283      	uxth	r3, r0
 8004056:	463a      	mov	r2, r7
 8004058:	2101      	movs	r1, #1
 800405a:	2002      	movs	r0, #2
 800405c:	f01b f9a8 	bl	801f3b0 <traceIF_itmPrint>
 8004060:	4638      	mov	r0, r7
 8004062:	f01b f962 	bl	801f32a <crs_strlen>
 8004066:	b283      	uxth	r3, r0
 8004068:	463a      	mov	r2, r7
 800406a:	2101      	movs	r1, #1
 800406c:	2002      	movs	r0, #2
 800406e:	f01b f9c1 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATACTION_RSP_URC_FORWARDED;
 8004072:	f04f 0840 	mov.w	r8, #64	; 0x40
 8004076:	e78a      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
        (void) atcm_socket_set_urc_closed_by_remote(p_modem_ctxt, sockHandle);
 8004078:	4680      	mov	r8, r0
 800407a:	4601      	mov	r1, r0
 800407c:	9801      	ldr	r0, [sp, #4]
 800407e:	f010 f92b 	bl	80142d8 <atcm_socket_set_urc_closed_by_remote>
        PRINT_INFO("SOCKET_EVENT: socket %ld (handle=%ld) closed by remote", socket_id, sockHandle)
 8004082:	4f1c      	ldr	r7, [pc, #112]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 8004084:	4643      	mov	r3, r8
 8004086:	465a      	mov	r2, fp
 8004088:	4921      	ldr	r1, [pc, #132]	; (8004110 <fRspAnalyze_SOCKETEV+0x22c>)
 800408a:	4638      	mov	r0, r7
 800408c:	f022 fbdc 	bl	8026848 <sprintf>
 8004090:	4638      	mov	r0, r7
 8004092:	f01b f94a 	bl	801f32a <crs_strlen>
 8004096:	b283      	uxth	r3, r0
 8004098:	463a      	mov	r2, r7
 800409a:	2101      	movs	r1, #1
 800409c:	2002      	movs	r0, #2
 800409e:	f01b f987 	bl	801f3b0 <traceIF_itmPrint>
 80040a2:	4638      	mov	r0, r7
 80040a4:	f01b f941 	bl	801f32a <crs_strlen>
 80040a8:	b283      	uxth	r3, r0
 80040aa:	463a      	mov	r2, r7
 80040ac:	2101      	movs	r1, #1
 80040ae:	2002      	movs	r0, #2
 80040b0:	f01b f9a0 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATACTION_RSP_URC_FORWARDED;
 80040b4:	f04f 0840 	mov.w	r8, #64	; 0x40
 80040b8:	e769      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
      PRINT_INFO("SOCKET_EVENT <connected_socket_id> = %ld",
 80040ba:	8968      	ldrh	r0, [r5, #10]
 80040bc:	4430      	add	r0, r6
 80040be:	f010 fe39 	bl	8014d34 <ATutil_convertStringToInt>
 80040c2:	4602      	mov	r2, r0
 80040c4:	4f0b      	ldr	r7, [pc, #44]	; (80040f4 <fRspAnalyze_SOCKETEV+0x210>)
 80040c6:	4913      	ldr	r1, [pc, #76]	; (8004114 <fRspAnalyze_SOCKETEV+0x230>)
 80040c8:	4638      	mov	r0, r7
 80040ca:	f022 fbbd 	bl	8026848 <sprintf>
 80040ce:	4638      	mov	r0, r7
 80040d0:	f01b f92b 	bl	801f32a <crs_strlen>
 80040d4:	b283      	uxth	r3, r0
 80040d6:	463a      	mov	r2, r7
 80040d8:	2101      	movs	r1, #1
 80040da:	2002      	movs	r0, #2
 80040dc:	f01b f968 	bl	801f3b0 <traceIF_itmPrint>
 80040e0:	4638      	mov	r0, r7
 80040e2:	f01b f922 	bl	801f32a <crs_strlen>
 80040e6:	b283      	uxth	r3, r0
 80040e8:	463a      	mov	r2, r7
 80040ea:	2101      	movs	r1, #1
 80040ec:	2002      	movs	r0, #2
 80040ee:	f01b f981 	bl	801f3f4 <traceIF_uartPrint>
    END_PARAM_LOOP()
 80040f2:	e74c      	b.n	8003f8e <fRspAnalyze_SOCKETEV+0xaa>
 80040f4:	200048dc 	.word	0x200048dc
 80040f8:	0802c074 	.word	0x0802c074
 80040fc:	0802c0f0 	.word	0x0802c0f0
 8004100:	0802c0a8 	.word	0x0802c0a8
 8004104:	0802c084 	.word	0x0802c084
 8004108:	0802c1ac 	.word	0x0802c1ac
 800410c:	0802c120 	.word	0x0802c120
 8004110:	0802c168 	.word	0x0802c168
 8004114:	0802c1e8 	.word	0x0802c1e8
 8004118:	0802c0c4 	.word	0x0802c0c4

0800411c <fRspAnalyze_DNSRSLV>:
{
 800411c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004120:	b092      	sub	sp, #72	; 0x48
 8004122:	4680      	mov	r8, r0
 8004124:	4617      	mov	r7, r2
 8004126:	461e      	mov	r6, r3
  PRINT_API("enter fRspAnalyze_DNSRSLV()")
 8004128:	4c66      	ldr	r4, [pc, #408]	; (80042c4 <fRspAnalyze_DNSRSLV+0x1a8>)
 800412a:	4d67      	ldr	r5, [pc, #412]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 800412c:	f104 0e20 	add.w	lr, r4, #32
 8004130:	46a4      	mov	ip, r4
 8004132:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004136:	6028      	str	r0, [r5, #0]
 8004138:	6069      	str	r1, [r5, #4]
 800413a:	60aa      	str	r2, [r5, #8]
 800413c:	60eb      	str	r3, [r5, #12]
 800413e:	4664      	mov	r4, ip
 8004140:	3510      	adds	r5, #16
 8004142:	45f4      	cmp	ip, lr
 8004144:	d1f4      	bne.n	8004130 <fRspAnalyze_DNSRSLV+0x14>
 8004146:	cc03      	ldmia	r4!, {r0, r1}
 8004148:	6028      	str	r0, [r5, #0]
 800414a:	6069      	str	r1, [r5, #4]
 800414c:	8823      	ldrh	r3, [r4, #0]
 800414e:	812b      	strh	r3, [r5, #8]
 8004150:	4c5d      	ldr	r4, [pc, #372]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004152:	4620      	mov	r0, r4
 8004154:	f01b f8e9 	bl	801f32a <crs_strlen>
 8004158:	b283      	uxth	r3, r0
 800415a:	4622      	mov	r2, r4
 800415c:	2104      	movs	r1, #4
 800415e:	2002      	movs	r0, #2
 8004160:	f01b f926 	bl	801f3b0 <traceIF_itmPrint>
 8004164:	4620      	mov	r0, r4
 8004166:	f01b f8e0 	bl	801f32a <crs_strlen>
 800416a:	b283      	uxth	r3, r0
 800416c:	4622      	mov	r2, r4
 800416e:	2104      	movs	r1, #4
 8004170:	2002      	movs	r0, #2
 8004172:	f01b f93f 	bl	801f3f4 <traceIF_uartPrint>
  START_PARAM_LOOP()
 8004176:	2400      	movs	r4, #0
  uint32_t ip_type = 0U;
 8004178:	46a1      	mov	r9, r4
  START_PARAM_LOOP()
 800417a:	4632      	mov	r2, r6
 800417c:	4639      	mov	r1, r7
 800417e:	4640      	mov	r0, r8
 8004180:	f008 f962 	bl	800c448 <atcc_extractElement>
 8004184:	2801      	cmp	r0, #1
 8004186:	d000      	beq.n	800418a <fRspAnalyze_DNSRSLV+0x6e>
 8004188:	2401      	movs	r4, #1
 800418a:	89f1      	ldrh	r1, [r6, #14]
 800418c:	b121      	cbz	r1, 8004198 <fRspAnalyze_DNSRSLV+0x7c>
  if (element_infos->param_rank == 2U)
 800418e:	8933      	ldrh	r3, [r6, #8]
 8004190:	2b02      	cmp	r3, #2
 8004192:	d007      	beq.n	80041a4 <fRspAnalyze_DNSRSLV+0x88>
  else if (element_infos->param_rank == 3U)
 8004194:	2b03      	cmp	r3, #3
 8004196:	d023      	beq.n	80041e0 <fRspAnalyze_DNSRSLV+0xc4>
  END_PARAM_LOOP()
 8004198:	2c00      	cmp	r4, #0
 800419a:	d0ee      	beq.n	800417a <fRspAnalyze_DNSRSLV+0x5e>
}
 800419c:	2010      	movs	r0, #16
 800419e:	b012      	add	sp, #72	; 0x48
 80041a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ip_type = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 80041a4:	8970      	ldrh	r0, [r6, #10]
 80041a6:	4438      	add	r0, r7
 80041a8:	f010 fdc4 	bl	8014d34 <ATutil_convertStringToInt>
 80041ac:	4681      	mov	r9, r0
    PRINT_INFO("<ip_type> = %ld", ip_type);
 80041ae:	4d46      	ldr	r5, [pc, #280]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 80041b0:	4602      	mov	r2, r0
 80041b2:	4946      	ldr	r1, [pc, #280]	; (80042cc <fRspAnalyze_DNSRSLV+0x1b0>)
 80041b4:	4628      	mov	r0, r5
 80041b6:	f022 fb47 	bl	8026848 <sprintf>
 80041ba:	4628      	mov	r0, r5
 80041bc:	f01b f8b5 	bl	801f32a <crs_strlen>
 80041c0:	b283      	uxth	r3, r0
 80041c2:	462a      	mov	r2, r5
 80041c4:	2101      	movs	r1, #1
 80041c6:	2002      	movs	r0, #2
 80041c8:	f01b f8f2 	bl	801f3b0 <traceIF_itmPrint>
 80041cc:	4628      	mov	r0, r5
 80041ce:	f01b f8ac 	bl	801f32a <crs_strlen>
 80041d2:	b283      	uxth	r3, r0
 80041d4:	462a      	mov	r2, r5
 80041d6:	2101      	movs	r1, #1
 80041d8:	2002      	movs	r0, #2
 80041da:	f01b f90b 	bl	801f3f4 <traceIF_uartPrint>
 80041de:	e7db      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
    if (ip_type == 0U)
 80041e0:	f1b9 0f00 	cmp.w	r9, #0
 80041e4:	d142      	bne.n	800426c <fRspAnalyze_DNSRSLV+0x150>
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 80041e6:	2241      	movs	r2, #65	; 0x41
 80041e8:	2100      	movs	r1, #0
 80041ea:	a801      	add	r0, sp, #4
 80041ec:	f022 fb9f 	bl	802692e <memset>
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 80041f0:	8971      	ldrh	r1, [r6, #10]
      (void) memcpy((void *) & (ip_addr_info.ip_addr_value),
 80041f2:	89f2      	ldrh	r2, [r6, #14]
 80041f4:	4439      	add	r1, r7
 80041f6:	f10d 0005 	add.w	r0, sp, #5
 80041fa:	f022 fc75 	bl	8026ae8 <memcpy>
      if (atcm_get_ip_address_type((AT_CHAR_t *)&ip_addr_info.ip_addr_value) == CS_IPAT_IPV4)
 80041fe:	f10d 0005 	add.w	r0, sp, #5
 8004202:	f008 fb09 	bl	800c818 <atcm_get_ip_address_type>
 8004206:	2801      	cmp	r0, #1
 8004208:	d029      	beq.n	800425e <fRspAnalyze_DNSRSLV+0x142>
        PRINT_ERR("error, invalid IPv4 address format")
 800420a:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 80042d4 <fRspAnalyze_DNSRSLV+0x1b8>
 800420e:	4d2e      	ldr	r5, [pc, #184]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004210:	f10e 0a30 	add.w	sl, lr, #48	; 0x30
 8004214:	46f4      	mov	ip, lr
 8004216:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800421a:	6028      	str	r0, [r5, #0]
 800421c:	6069      	str	r1, [r5, #4]
 800421e:	60aa      	str	r2, [r5, #8]
 8004220:	60eb      	str	r3, [r5, #12]
 8004222:	46e6      	mov	lr, ip
 8004224:	3510      	adds	r5, #16
 8004226:	45d4      	cmp	ip, sl
 8004228:	d1f4      	bne.n	8004214 <fRspAnalyze_DNSRSLV+0xf8>
 800422a:	f8bc 2000 	ldrh.w	r2, [ip]
 800422e:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8004232:	802a      	strh	r2, [r5, #0]
 8004234:	70ab      	strb	r3, [r5, #2]
 8004236:	4d24      	ldr	r5, [pc, #144]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004238:	4628      	mov	r0, r5
 800423a:	f01b f876 	bl	801f32a <crs_strlen>
 800423e:	b283      	uxth	r3, r0
 8004240:	462a      	mov	r2, r5
 8004242:	2110      	movs	r1, #16
 8004244:	2002      	movs	r0, #2
 8004246:	f01b f8b3 	bl	801f3b0 <traceIF_itmPrint>
 800424a:	4628      	mov	r0, r5
 800424c:	f01b f86d 	bl	801f32a <crs_strlen>
 8004250:	b283      	uxth	r3, r0
 8004252:	462a      	mov	r2, r5
 8004254:	2110      	movs	r1, #16
 8004256:	2002      	movs	r0, #2
 8004258:	f01b f8cc 	bl	801f3f4 <traceIF_uartPrint>
 800425c:	e79c      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
                      (const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 800425e:	8971      	ldrh	r1, [r6, #10]
        (void) memcpy((void *)type1sc_shared.DNSRSLV_dns_info.hostIPaddr,
 8004260:	89f2      	ldrh	r2, [r6, #14]
 8004262:	4439      	add	r1, r7
 8004264:	481a      	ldr	r0, [pc, #104]	; (80042d0 <fRspAnalyze_DNSRSLV+0x1b4>)
 8004266:	f022 fc3f 	bl	8026ae8 <memcpy>
 800426a:	e795      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
      PRINT_ERR("error, IPv6 address format not supported yet")
 800426c:	f8df c068 	ldr.w	ip, [pc, #104]	; 80042d8 <fRspAnalyze_DNSRSLV+0x1bc>
 8004270:	4d15      	ldr	r5, [pc, #84]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 8004272:	f10c 0a30 	add.w	sl, ip, #48	; 0x30
 8004276:	46e6      	mov	lr, ip
 8004278:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800427c:	6028      	str	r0, [r5, #0]
 800427e:	6069      	str	r1, [r5, #4]
 8004280:	60aa      	str	r2, [r5, #8]
 8004282:	60eb      	str	r3, [r5, #12]
 8004284:	46f4      	mov	ip, lr
 8004286:	3510      	adds	r5, #16
 8004288:	45d6      	cmp	lr, sl
 800428a:	d1f4      	bne.n	8004276 <fRspAnalyze_DNSRSLV+0x15a>
 800428c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8004290:	6028      	str	r0, [r5, #0]
 8004292:	6069      	str	r1, [r5, #4]
 8004294:	60aa      	str	r2, [r5, #8]
 8004296:	f89c 3000 	ldrb.w	r3, [ip]
 800429a:	732b      	strb	r3, [r5, #12]
 800429c:	4d0a      	ldr	r5, [pc, #40]	; (80042c8 <fRspAnalyze_DNSRSLV+0x1ac>)
 800429e:	4628      	mov	r0, r5
 80042a0:	f01b f843 	bl	801f32a <crs_strlen>
 80042a4:	b283      	uxth	r3, r0
 80042a6:	462a      	mov	r2, r5
 80042a8:	2110      	movs	r1, #16
 80042aa:	2002      	movs	r0, #2
 80042ac:	f01b f880 	bl	801f3b0 <traceIF_itmPrint>
 80042b0:	4628      	mov	r0, r5
 80042b2:	f01b f83a 	bl	801f32a <crs_strlen>
 80042b6:	b283      	uxth	r3, r0
 80042b8:	462a      	mov	r2, r5
 80042ba:	2110      	movs	r1, #16
 80042bc:	2002      	movs	r0, #2
 80042be:	f01b f899 	bl	801f3f4 <traceIF_uartPrint>
 80042c2:	e769      	b.n	8004198 <fRspAnalyze_DNSRSLV+0x7c>
 80042c4:	0802c21c 	.word	0x0802c21c
 80042c8:	200048dc 	.word	0x200048dc
 80042cc:	0802c248 	.word	0x0802c248
 80042d0:	20001838 	.word	0x20001838
 80042d4:	0802c264 	.word	0x0802c264
 80042d8:	0802c298 	.word	0x0802c298

080042dc <clear_ping_resp_struct>:
{
 80042dc:	b538      	push	{r3, r4, r5, lr}
 80042de:	4604      	mov	r4, r0
  p_modem_ctxt->persist.ping_resp_urc.ping_status = CELLULAR_ERROR;
 80042e0:	2301      	movs	r3, #1
 80042e2:	f880 355d 	strb.w	r3, [r0, #1373]	; 0x55d
  p_modem_ctxt->persist.ping_resp_urc.is_final_report = CELLULAR_FALSE;
 80042e6:	2500      	movs	r5, #0
 80042e8:	f880 555e 	strb.w	r5, [r0, #1374]	; 0x55e
  (void) memset((void *)&p_modem_ctxt->persist.ping_resp_urc.ping_addr[0], 0U, MAX_SIZE_IPADDR);
 80042ec:	2240      	movs	r2, #64	; 0x40
 80042ee:	4629      	mov	r1, r5
 80042f0:	f200 505f 	addw	r0, r0, #1375	; 0x55f
 80042f4:	f022 fb1b 	bl	802692e <memset>
  p_modem_ctxt->persist.ping_resp_urc.ping_size = 0U;
 80042f8:	f8a4 55a0 	strh.w	r5, [r4, #1440]	; 0x5a0
  p_modem_ctxt->persist.ping_resp_urc.time = 0U;
 80042fc:	f8c4 55a4 	str.w	r5, [r4, #1444]	; 0x5a4
  p_modem_ctxt->persist.ping_resp_urc.ttl = 0U;
 8004300:	f884 55a8 	strb.w	r5, [r4, #1448]	; 0x5a8
}
 8004304:	bd38      	pop	{r3, r4, r5, pc}
	...

08004308 <fRspAnalyze_PINGCMD>:
{
 8004308:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800430c:	4680      	mov	r8, r0
 800430e:	4689      	mov	r9, r1
 8004310:	4617      	mov	r7, r2
 8004312:	461e      	mov	r6, r3
  PRINT_API("enter fRspAnalyze_PINGCMD()")
 8004314:	4c71      	ldr	r4, [pc, #452]	; (80044dc <fRspAnalyze_PINGCMD+0x1d4>)
 8004316:	4d72      	ldr	r5, [pc, #456]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 8004318:	f104 0e20 	add.w	lr, r4, #32
 800431c:	46a4      	mov	ip, r4
 800431e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004322:	6028      	str	r0, [r5, #0]
 8004324:	6069      	str	r1, [r5, #4]
 8004326:	60aa      	str	r2, [r5, #8]
 8004328:	60eb      	str	r3, [r5, #12]
 800432a:	4664      	mov	r4, ip
 800432c:	3510      	adds	r5, #16
 800432e:	45f4      	cmp	ip, lr
 8004330:	d1f4      	bne.n	800431c <fRspAnalyze_PINGCMD+0x14>
 8004332:	cc03      	ldmia	r4!, {r0, r1}
 8004334:	6028      	str	r0, [r5, #0]
 8004336:	6069      	str	r1, [r5, #4]
 8004338:	8823      	ldrh	r3, [r4, #0]
 800433a:	812b      	strh	r3, [r5, #8]
 800433c:	4c68      	ldr	r4, [pc, #416]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 800433e:	4620      	mov	r0, r4
 8004340:	f01a fff3 	bl	801f32a <crs_strlen>
 8004344:	b283      	uxth	r3, r0
 8004346:	4622      	mov	r2, r4
 8004348:	2104      	movs	r1, #4
 800434a:	2002      	movs	r0, #2
 800434c:	f01b f830 	bl	801f3b0 <traceIF_itmPrint>
 8004350:	4620      	mov	r0, r4
 8004352:	f01a ffea 	bl	801f32a <crs_strlen>
 8004356:	b283      	uxth	r3, r0
 8004358:	4622      	mov	r2, r4
 800435a:	2104      	movs	r1, #4
 800435c:	2002      	movs	r0, #2
 800435e:	f01b f849 	bl	801f3f4 <traceIF_uartPrint>
  START_PARAM_LOOP()
 8004362:	2500      	movs	r5, #0
 8004364:	4632      	mov	r2, r6
 8004366:	4639      	mov	r1, r7
 8004368:	4640      	mov	r0, r8
 800436a:	f008 f86d 	bl	800c448 <atcc_extractElement>
 800436e:	2801      	cmp	r0, #1
 8004370:	d000      	beq.n	8004374 <fRspAnalyze_PINGCMD+0x6c>
 8004372:	2501      	movs	r5, #1
 8004374:	89f1      	ldrh	r1, [r6, #14]
 8004376:	b149      	cbz	r1, 800438c <fRspAnalyze_PINGCMD+0x84>
  if (element_infos->param_rank == 2U)
 8004378:	8933      	ldrh	r3, [r6, #8]
 800437a:	2b02      	cmp	r3, #2
 800437c:	d00b      	beq.n	8004396 <fRspAnalyze_PINGCMD+0x8e>
  else if (element_infos->param_rank == 3U)
 800437e:	2b03      	cmp	r3, #3
 8004380:	d061      	beq.n	8004446 <fRspAnalyze_PINGCMD+0x13e>
  else if (element_infos->param_rank == 4U)
 8004382:	2b04      	cmp	r3, #4
 8004384:	d066      	beq.n	8004454 <fRspAnalyze_PINGCMD+0x14c>
  else if (element_infos->param_rank == 5U)
 8004386:	2b05      	cmp	r3, #5
 8004388:	f000 8084 	beq.w	8004494 <fRspAnalyze_PINGCMD+0x18c>
  END_PARAM_LOOP()
 800438c:	2d00      	cmp	r5, #0
 800438e:	d0e9      	beq.n	8004364 <fRspAnalyze_PINGCMD+0x5c>
}
 8004390:	2040      	movs	r0, #64	; 0x40
 8004392:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    clear_ping_resp_struct(p_modem_ctxt);
 8004396:	4648      	mov	r0, r9
 8004398:	f7ff ffa0 	bl	80042dc <clear_ping_resp_struct>
    p_modem_ctxt->persist.ping_resp_urc.ping_status = CELLULAR_ERROR; /* will be updated if all params are correct */
 800439c:	f04f 0b01 	mov.w	fp, #1
 80043a0:	f889 b55d 	strb.w	fp, [r9, #1373]	; 0x55d
    uint32_t ping_id = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80043a4:	8970      	ldrh	r0, [r6, #10]
 80043a6:	89f1      	ldrh	r1, [r6, #14]
 80043a8:	4438      	add	r0, r7
 80043aa:	f010 fcc3 	bl	8014d34 <ATutil_convertStringToInt>
 80043ae:	4682      	mov	sl, r0
    PRINT_DBG("<id> = %ld", ping_id)
 80043b0:	4c4b      	ldr	r4, [pc, #300]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 80043b2:	4602      	mov	r2, r0
 80043b4:	494b      	ldr	r1, [pc, #300]	; (80044e4 <fRspAnalyze_PINGCMD+0x1dc>)
 80043b6:	4620      	mov	r0, r4
 80043b8:	f022 fa46 	bl	8026848 <sprintf>
 80043bc:	4620      	mov	r0, r4
 80043be:	f01a ffb4 	bl	801f32a <crs_strlen>
 80043c2:	b283      	uxth	r3, r0
 80043c4:	4622      	mov	r2, r4
 80043c6:	2102      	movs	r1, #2
 80043c8:	4608      	mov	r0, r1
 80043ca:	f01a fff1 	bl	801f3b0 <traceIF_itmPrint>
 80043ce:	4620      	mov	r0, r4
 80043d0:	f01a ffab 	bl	801f32a <crs_strlen>
 80043d4:	b283      	uxth	r3, r0
 80043d6:	4622      	mov	r2, r4
 80043d8:	2102      	movs	r1, #2
 80043da:	4608      	mov	r0, r1
 80043dc:	f01b f80a 	bl	801f3f4 <traceIF_uartPrint>
    p_modem_ctxt->persist.urc_avail_ping_rsp = AT_TRUE;
 80043e0:	f889 b5ac 	strb.w	fp, [r9, #1452]	; 0x5ac
    p_modem_ctxt->persist.ping_resp_urc.index = (uint8_t)ping_id;
 80043e4:	f889 a55c 	strb.w	sl, [r9, #1372]	; 0x55c
    PRINT_DBG("intermediate ping report")
 80043e8:	f8df e104 	ldr.w	lr, [pc, #260]	; 80044f0 <fRspAnalyze_PINGCMD+0x1e8>
 80043ec:	f10e 0a20 	add.w	sl, lr, #32
 80043f0:	46f4      	mov	ip, lr
 80043f2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80043f6:	6020      	str	r0, [r4, #0]
 80043f8:	6061      	str	r1, [r4, #4]
 80043fa:	60a2      	str	r2, [r4, #8]
 80043fc:	60e3      	str	r3, [r4, #12]
 80043fe:	46e6      	mov	lr, ip
 8004400:	3410      	adds	r4, #16
 8004402:	45d4      	cmp	ip, sl
 8004404:	d1f4      	bne.n	80043f0 <fRspAnalyze_PINGCMD+0xe8>
 8004406:	f8bc 2000 	ldrh.w	r2, [ip]
 800440a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800440e:	8022      	strh	r2, [r4, #0]
 8004410:	70a3      	strb	r3, [r4, #2]
 8004412:	4c33      	ldr	r4, [pc, #204]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 8004414:	4620      	mov	r0, r4
 8004416:	f01a ff88 	bl	801f32a <crs_strlen>
 800441a:	b283      	uxth	r3, r0
 800441c:	4622      	mov	r2, r4
 800441e:	2102      	movs	r1, #2
 8004420:	4608      	mov	r0, r1
 8004422:	f01a ffc5 	bl	801f3b0 <traceIF_itmPrint>
 8004426:	4620      	mov	r0, r4
 8004428:	f01a ff7f 	bl	801f32a <crs_strlen>
 800442c:	b283      	uxth	r3, r0
 800442e:	4622      	mov	r2, r4
 8004430:	2102      	movs	r1, #2
 8004432:	4608      	mov	r0, r1
 8004434:	f01a ffde 	bl	801f3f4 <traceIF_uartPrint>
    p_modem_ctxt->persist.ping_resp_urc.is_final_report = CELLULAR_FALSE;
 8004438:	2300      	movs	r3, #0
 800443a:	f889 355e 	strb.w	r3, [r9, #1374]	; 0x55e
    p_modem_ctxt->persist.ping_resp_urc.ping_size = TYPE1SC_PING_LENGTH;
 800443e:	2338      	movs	r3, #56	; 0x38
 8004440:	f8a9 35a0 	strh.w	r3, [r9, #1440]	; 0x5a0
 8004444:	e7a2      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
    atcm_extract_IP_address((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8004446:	8970      	ldrh	r0, [r6, #10]
 8004448:	f209 525f 	addw	r2, r9, #1375	; 0x55f
 800444c:	4438      	add	r0, r7
 800444e:	f008 fa10 	bl	800c872 <atcm_extract_IP_address>
 8004452:	e79b      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
    uint32_t rtt = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8004454:	8970      	ldrh	r0, [r6, #10]
 8004456:	4438      	add	r0, r7
 8004458:	f010 fc6c 	bl	8014d34 <ATutil_convertStringToInt>
 800445c:	4682      	mov	sl, r0
    PRINT_DBG("<rtt> = %ld", rtt);
 800445e:	4c20      	ldr	r4, [pc, #128]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 8004460:	4602      	mov	r2, r0
 8004462:	4921      	ldr	r1, [pc, #132]	; (80044e8 <fRspAnalyze_PINGCMD+0x1e0>)
 8004464:	4620      	mov	r0, r4
 8004466:	f022 f9ef 	bl	8026848 <sprintf>
 800446a:	4620      	mov	r0, r4
 800446c:	f01a ff5d 	bl	801f32a <crs_strlen>
 8004470:	b283      	uxth	r3, r0
 8004472:	4622      	mov	r2, r4
 8004474:	2102      	movs	r1, #2
 8004476:	4608      	mov	r0, r1
 8004478:	f01a ff9a 	bl	801f3b0 <traceIF_itmPrint>
 800447c:	4620      	mov	r0, r4
 800447e:	f01a ff54 	bl	801f32a <crs_strlen>
 8004482:	b283      	uxth	r3, r0
 8004484:	4622      	mov	r2, r4
 8004486:	2102      	movs	r1, #2
 8004488:	4608      	mov	r0, r1
 800448a:	f01a ffb3 	bl	801f3f4 <traceIF_uartPrint>
    p_modem_ctxt->persist.ping_resp_urc.time = (uint32_t)rtt;
 800448e:	f8c9 a5a4 	str.w	sl, [r9, #1444]	; 0x5a4
 8004492:	e77b      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
    uint32_t ttl = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8004494:	8970      	ldrh	r0, [r6, #10]
 8004496:	4438      	add	r0, r7
 8004498:	f010 fc4c 	bl	8014d34 <ATutil_convertStringToInt>
 800449c:	4682      	mov	sl, r0
    PRINT_INFO("<ttl> = %ld", ttl);
 800449e:	4c10      	ldr	r4, [pc, #64]	; (80044e0 <fRspAnalyze_PINGCMD+0x1d8>)
 80044a0:	4602      	mov	r2, r0
 80044a2:	4912      	ldr	r1, [pc, #72]	; (80044ec <fRspAnalyze_PINGCMD+0x1e4>)
 80044a4:	4620      	mov	r0, r4
 80044a6:	f022 f9cf 	bl	8026848 <sprintf>
 80044aa:	4620      	mov	r0, r4
 80044ac:	f01a ff3d 	bl	801f32a <crs_strlen>
 80044b0:	b283      	uxth	r3, r0
 80044b2:	4622      	mov	r2, r4
 80044b4:	2101      	movs	r1, #1
 80044b6:	2002      	movs	r0, #2
 80044b8:	f01a ff7a 	bl	801f3b0 <traceIF_itmPrint>
 80044bc:	4620      	mov	r0, r4
 80044be:	f01a ff34 	bl	801f32a <crs_strlen>
 80044c2:	b283      	uxth	r3, r0
 80044c4:	4622      	mov	r2, r4
 80044c6:	2101      	movs	r1, #1
 80044c8:	2002      	movs	r0, #2
 80044ca:	f01a ff93 	bl	801f3f4 <traceIF_uartPrint>
    p_modem_ctxt->persist.ping_resp_urc.ttl = (uint8_t)ttl;
 80044ce:	f889 a5a8 	strb.w	sl, [r9, #1448]	; 0x5a8
    p_modem_ctxt->persist.ping_resp_urc.ping_status = CELLULAR_OK;
 80044d2:	2300      	movs	r3, #0
 80044d4:	f889 355d 	strb.w	r3, [r9, #1373]	; 0x55d
 80044d8:	e758      	b.n	800438c <fRspAnalyze_PINGCMD+0x84>
 80044da:	bf00      	nop
 80044dc:	0802c2d8 	.word	0x0802c2d8
 80044e0:	200048dc 	.word	0x200048dc
 80044e4:	0802c304 	.word	0x0802c304
 80044e8:	0802c340 	.word	0x0802c340
 80044ec:	0802c358 	.word	0x0802c358
 80044f0:	0802c31c 	.word	0x0802c31c

080044f4 <reinitSyntaxAutomaton_TYPE1SC>:
}

/* Private function Definition -----------------------------------------------*/
static void reinitSyntaxAutomaton_TYPE1SC(void)
{
  TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_INIT_CR;
 80044f4:	4b01      	ldr	r3, [pc, #4]	; (80044fc <reinitSyntaxAutomaton_TYPE1SC+0x8>)
 80044f6:	2200      	movs	r2, #0
 80044f8:	721a      	strb	r2, [r3, #8]
}
 80044fa:	4770      	bx	lr
 80044fc:	20001084 	.word	0x20001084

08004500 <reset_variables_TYPE1SC>:

static void reset_variables_TYPE1SC(void)
{
  /* Set default values of TYPE1SC specific variables after SWITCH ON or RESET */
  type1sc_shared.wait_for_modem_low_power_ack = false;
 8004500:	4b05      	ldr	r3, [pc, #20]	; (8004518 <reset_variables_TYPE1SC+0x18>)
 8004502:	2200      	movs	r2, #0
 8004504:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  type1sc_shared.modem_in_low_power_state = false;
 8004508:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  type1sc_shared.modem_waiting_for_bootev = false;
 800450c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  type1sc_shared.modem_bootev_received = false;
 8004510:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
}
 8004514:	4770      	bx	lr
 8004516:	bf00      	nop
 8004518:	20001838 	.word	0x20001838

0800451c <init_type1sc_low_power>:

static at_bool_t init_type1sc_low_power(void)
{
  at_bool_t lp_enabled;

  if (TYPE1SC_ctxt.SID_ctxt.init_power_config.low_power_enable == CELLULAR_TRUE)
 800451c:	4b0f      	ldr	r3, [pc, #60]	; (800455c <init_type1sc_low_power+0x40>)
 800451e:	f893 3718 	ldrb.w	r3, [r3, #1816]	; 0x718
 8004522:	2b01      	cmp	r3, #1
 8004524:	d004      	beq.n	8004530 <init_type1sc_low_power+0x14>

  }
  else
  {
    /* this parameter is used in CGREG/CEREG to not enable PSM (value = 2) */
    TYPE1SC_ctxt.persist.psm_urc_requested = AT_FALSE;
 8004526:	2000      	movs	r0, #0
 8004528:	4b0c      	ldr	r3, [pc, #48]	; (800455c <init_type1sc_low_power+0x40>)
 800452a:	f883 050d 	strb.w	r0, [r3, #1293]	; 0x50d
    /* do not send PSM and EDRX commands */
    lp_enabled = AT_FALSE;
  }

  return (lp_enabled);
}
 800452e:	4770      	bx	lr
    TYPE1SC_ctxt.persist.psm_urc_requested = AT_TRUE;
 8004530:	4b0a      	ldr	r3, [pc, #40]	; (800455c <init_type1sc_low_power+0x40>)
 8004532:	2001      	movs	r0, #1
 8004534:	f883 050d 	strb.w	r0, [r3, #1293]	; 0x50d
    TYPE1SC_ctxt.SID_ctxt.set_power_config.psm_present = CELLULAR_TRUE;
 8004538:	f883 071f 	strb.w	r0, [r3, #1823]	; 0x71f
    TYPE1SC_ctxt.SID_ctxt.set_power_config.psm_mode = PSM_MODE_ENABLE;
 800453c:	f883 0721 	strb.w	r0, [r3, #1825]	; 0x721
    (void) memcpy((void *) &TYPE1SC_ctxt.SID_ctxt.set_power_config.psm,
 8004540:	f8d3 2719 	ldr.w	r2, [r3, #1817]	; 0x719
 8004544:	f8c3 2722 	str.w	r2, [r3, #1826]	; 0x722
    TYPE1SC_ctxt.SID_ctxt.set_power_config.edrx_present = CELLULAR_TRUE;
 8004548:	f883 0720 	strb.w	r0, [r3, #1824]	; 0x720
    TYPE1SC_ctxt.SID_ctxt.set_power_config.edrx_mode = EDRX_MODE_DISABLE;
 800454c:	2200      	movs	r2, #0
 800454e:	f883 2726 	strb.w	r2, [r3, #1830]	; 0x726
    (void) memcpy((void *) &TYPE1SC_ctxt.SID_ctxt.set_power_config.edrx,
 8004552:	f8b3 271d 	ldrh.w	r2, [r3, #1821]	; 0x71d
 8004556:	f8a3 2727 	strh.w	r2, [r3, #1831]	; 0x727
    lp_enabled = AT_TRUE;
 800455a:	4770      	bx	lr
 800455c:	20001084 	.word	0x20001084

08004560 <low_power_state_requested>:

static void low_power_state_requested(void)
{
  /* activate interrupt detection for RING */
  type1sc_shared.wait_for_modem_low_power_ack = true;
 8004560:	4b02      	ldr	r3, [pc, #8]	; (800456c <low_power_state_requested+0xc>)
 8004562:	2201      	movs	r2, #1
 8004564:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
}
 8004568:	4770      	bx	lr
 800456a:	bf00      	nop
 800456c:	20001838 	.word	0x20001838

08004570 <low_power_state_enter>:

static void low_power_state_enter(void)
{
  type1sc_shared.modem_in_low_power_state = true;
 8004570:	4b03      	ldr	r3, [pc, #12]	; (8004580 <low_power_state_enter+0x10>)
 8004572:	2201      	movs	r2, #1
 8004574:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  type1sc_shared.wait_for_modem_low_power_ack = false;
 8004578:	2200      	movs	r2, #0
 800457a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
}
 800457e:	4770      	bx	lr
 8004580:	20001838 	.word	0x20001838

08004584 <low_power_state_cancel>:

static void low_power_state_cancel(void)
{
  type1sc_shared.modem_in_low_power_state = false;
 8004584:	4b03      	ldr	r3, [pc, #12]	; (8004594 <low_power_state_cancel+0x10>)
 8004586:	2200      	movs	r2, #0
 8004588:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  type1sc_shared.wait_for_modem_low_power_ack = false;
 800458c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
}
 8004590:	4770      	bx	lr
 8004592:	bf00      	nop
 8004594:	20001838 	.word	0x20001838

08004598 <is_waiting_modem_low_power_ack>:

static bool is_waiting_modem_low_power_ack(void)
{
  return (type1sc_shared.wait_for_modem_low_power_ack == true);
}
 8004598:	4b01      	ldr	r3, [pc, #4]	; (80045a0 <is_waiting_modem_low_power_ack+0x8>)
 800459a:	f893 0043 	ldrb.w	r0, [r3, #67]	; 0x43
 800459e:	4770      	bx	lr
 80045a0:	20001838 	.word	0x20001838

080045a4 <is_modem_in_low_power_state>:

static bool is_modem_in_low_power_state(void)
{
  return (type1sc_shared.modem_in_low_power_state == true);
}
 80045a4:	4b01      	ldr	r3, [pc, #4]	; (80045ac <is_modem_in_low_power_state+0x8>)
 80045a6:	f893 0044 	ldrb.w	r0, [r3, #68]	; 0x44
 80045aa:	4770      	bx	lr
 80045ac:	20001838 	.word	0x20001838

080045b0 <type1sc_modem_init>:
{
 80045b0:	b570      	push	{r4, r5, r6, lr}
 80045b2:	4606      	mov	r6, r0
  PRINT_API("enter type1sc_modem_init")
 80045b4:	4d1d      	ldr	r5, [pc, #116]	; (800462c <type1sc_modem_init+0x7c>)
 80045b6:	4c1e      	ldr	r4, [pc, #120]	; (8004630 <type1sc_modem_init+0x80>)
 80045b8:	f105 0e20 	add.w	lr, r5, #32
 80045bc:	46ac      	mov	ip, r5
 80045be:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80045c2:	6020      	str	r0, [r4, #0]
 80045c4:	6061      	str	r1, [r4, #4]
 80045c6:	60a2      	str	r2, [r4, #8]
 80045c8:	60e3      	str	r3, [r4, #12]
 80045ca:	4665      	mov	r5, ip
 80045cc:	3410      	adds	r4, #16
 80045ce:	45f4      	cmp	ip, lr
 80045d0:	d1f4      	bne.n	80045bc <type1sc_modem_init+0xc>
 80045d2:	f8dc 0000 	ldr.w	r0, [ip]
 80045d6:	6020      	str	r0, [r4, #0]
 80045d8:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 80045dc:	f89c 3006 	ldrb.w	r3, [ip, #6]
 80045e0:	80a2      	strh	r2, [r4, #4]
 80045e2:	71a3      	strb	r3, [r4, #6]
 80045e4:	4c12      	ldr	r4, [pc, #72]	; (8004630 <type1sc_modem_init+0x80>)
 80045e6:	4620      	mov	r0, r4
 80045e8:	f01a fe9f 	bl	801f32a <crs_strlen>
 80045ec:	b283      	uxth	r3, r0
 80045ee:	4622      	mov	r2, r4
 80045f0:	2104      	movs	r1, #4
 80045f2:	2002      	movs	r0, #2
 80045f4:	f01a fedc 	bl	801f3b0 <traceIF_itmPrint>
 80045f8:	4620      	mov	r0, r4
 80045fa:	f01a fe96 	bl	801f32a <crs_strlen>
 80045fe:	b283      	uxth	r3, r0
 8004600:	4622      	mov	r2, r4
 8004602:	2104      	movs	r1, #4
 8004604:	2002      	movs	r0, #2
 8004606:	f01a fef5 	bl	801f3f4 <traceIF_uartPrint>
  atcm_modem_init(p_modem_ctxt);
 800460a:	4630      	mov	r0, r6
 800460c:	f009 ff38 	bl	800e480 <atcm_modem_init>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004610:	2300      	movs	r3, #0
 8004612:	e007      	b.n	8004624 <type1sc_modem_init+0x74>
    p_tmp->socket_connId_value = ((uint8_t)UNDEFINED_MODEM_SOCKET_ID);
 8004614:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8004618:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 800461c:	21ff      	movs	r1, #255	; 0xff
 800461e:	7151      	strb	r1, [r2, #5]
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004620:	3301      	adds	r3, #1
 8004622:	b2db      	uxtb	r3, r3
 8004624:	2b05      	cmp	r3, #5
 8004626:	d9f5      	bls.n	8004614 <type1sc_modem_init+0x64>
}
 8004628:	bd70      	pop	{r4, r5, r6, pc}
 800462a:	bf00      	nop
 800462c:	0802c398 	.word	0x0802c398
 8004630:	200048dc 	.word	0x200048dc

08004634 <type1sc_modem_reset>:
{
 8004634:	b570      	push	{r4, r5, r6, lr}
 8004636:	4606      	mov	r6, r0
  PRINT_API("enter type1sc_modem_reset")
 8004638:	4d1a      	ldr	r5, [pc, #104]	; (80046a4 <type1sc_modem_reset+0x70>)
 800463a:	4c1b      	ldr	r4, [pc, #108]	; (80046a8 <type1sc_modem_reset+0x74>)
 800463c:	f105 0e20 	add.w	lr, r5, #32
 8004640:	46ac      	mov	ip, r5
 8004642:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004646:	6020      	str	r0, [r4, #0]
 8004648:	6061      	str	r1, [r4, #4]
 800464a:	60a2      	str	r2, [r4, #8]
 800464c:	60e3      	str	r3, [r4, #12]
 800464e:	4665      	mov	r5, ip
 8004650:	3410      	adds	r4, #16
 8004652:	45f4      	cmp	ip, lr
 8004654:	d1f4      	bne.n	8004640 <type1sc_modem_reset+0xc>
 8004656:	cd03      	ldmia	r5!, {r0, r1}
 8004658:	6020      	str	r0, [r4, #0]
 800465a:	6061      	str	r1, [r4, #4]
 800465c:	4c12      	ldr	r4, [pc, #72]	; (80046a8 <type1sc_modem_reset+0x74>)
 800465e:	4620      	mov	r0, r4
 8004660:	f01a fe63 	bl	801f32a <crs_strlen>
 8004664:	b283      	uxth	r3, r0
 8004666:	4622      	mov	r2, r4
 8004668:	2104      	movs	r1, #4
 800466a:	2002      	movs	r0, #2
 800466c:	f01a fea0 	bl	801f3b0 <traceIF_itmPrint>
 8004670:	4620      	mov	r0, r4
 8004672:	f01a fe5a 	bl	801f32a <crs_strlen>
 8004676:	b283      	uxth	r3, r0
 8004678:	4622      	mov	r2, r4
 800467a:	2104      	movs	r1, #4
 800467c:	2002      	movs	r0, #2
 800467e:	f01a feb9 	bl	801f3f4 <traceIF_uartPrint>
  atcm_modem_reset(p_modem_ctxt);
 8004682:	4630      	mov	r0, r6
 8004684:	f009 ff3c 	bl	800e500 <atcm_modem_reset>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004688:	2300      	movs	r3, #0
 800468a:	e007      	b.n	800469c <type1sc_modem_reset+0x68>
    p_tmp->socket_connId_value = ((uint8_t)UNDEFINED_MODEM_SOCKET_ID);
 800468c:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8004690:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8004694:	21ff      	movs	r1, #255	; 0xff
 8004696:	7151      	strb	r1, [r2, #5]
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8004698:	3301      	adds	r3, #1
 800469a:	b2db      	uxtb	r3, r3
 800469c:	2b05      	cmp	r3, #5
 800469e:	d9f5      	bls.n	800468c <type1sc_modem_reset+0x58>
}
 80046a0:	bd70      	pop	{r4, r5, r6, pc}
 80046a2:	bf00      	nop
 80046a4:	0802c3c0 	.word	0x0802c3c0
 80046a8:	200048dc 	.word	0x200048dc

080046ac <ATCustom_TYPE1SC_init>:
{
 80046ac:	b538      	push	{r3, r4, r5, lr}
 80046ae:	4604      	mov	r4, r0
  type1sc_modem_init(&TYPE1SC_ctxt);
 80046b0:	4d06      	ldr	r5, [pc, #24]	; (80046cc <ATCustom_TYPE1SC_init+0x20>)
 80046b2:	4628      	mov	r0, r5
 80046b4:	f7ff ff7c 	bl	80045b0 <type1sc_modem_init>
  TYPE1SC_ctxt.modem_LUT_size = SIZE_ATCMD_TYPE1SC_LUT;
 80046b8:	2349      	movs	r3, #73	; 0x49
 80046ba:	602b      	str	r3, [r5, #0]
  TYPE1SC_ctxt.p_modem_LUT = (const atcustom_LUT_t *)ATCMD_TYPE1SC_LUT;
 80046bc:	4b04      	ldr	r3, [pc, #16]	; (80046d0 <ATCustom_TYPE1SC_init+0x24>)
 80046be:	606b      	str	r3, [r5, #4]
  (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->endstr, "\r");
 80046c0:	4b04      	ldr	r3, [pc, #16]	; (80046d4 <ATCustom_TYPE1SC_init+0x28>)
 80046c2:	881b      	ldrh	r3, [r3, #0]
 80046c4:	f8a4 3674 	strh.w	r3, [r4, #1652]	; 0x674
}
 80046c8:	bd38      	pop	{r3, r4, r5, pc}
 80046ca:	bf00      	nop
 80046cc:	20001084 	.word	0x20001084
 80046d0:	0802ca64 	.word	0x0802ca64
 80046d4:	08033828 	.word	0x08033828

080046d8 <ATCustom_TYPE1SC_checkEndOfMsgCallback>:
{
 80046d8:	4603      	mov	r3, r0
  if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_INIT_CR)
 80046da:	4a16      	ldr	r2, [pc, #88]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 80046dc:	7a10      	ldrb	r0, [r2, #8]
 80046de:	b930      	cbnz	r0, 80046ee <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x16>
    if ((AT_CHAR_t)('\r') == rxChar)
 80046e0:	2b0d      	cmp	r3, #13
 80046e2:	d000      	beq.n	80046e6 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0xe>
}
 80046e4:	4770      	bx	lr
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_LF;
 80046e6:	4613      	mov	r3, r2
 80046e8:	2203      	movs	r2, #3
 80046ea:	721a      	strb	r2, [r3, #8]
 80046ec:	4770      	bx	lr
  else if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_CR)
 80046ee:	2802      	cmp	r0, #2
 80046f0:	d006      	beq.n	8004700 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x28>
  else if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_LF)
 80046f2:	2803      	cmp	r0, #3
 80046f4:	d00d      	beq.n	8004712 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x3a>
  else if (TYPE1SC_ctxt.state_SyntaxAutomaton == WAITING_FOR_FIRST_CHAR)
 80046f6:	2801      	cmp	r0, #1
 80046f8:	d013      	beq.n	8004722 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x4a>
    __NOP();
 80046fa:	bf00      	nop
  uint8_t last_char = 0U;
 80046fc:	2000      	movs	r0, #0
 80046fe:	4770      	bx	lr
    if ((AT_CHAR_t)('\r') == rxChar)
 8004700:	2b0d      	cmp	r3, #13
 8004702:	d001      	beq.n	8004708 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x30>
  uint8_t last_char = 0U;
 8004704:	2000      	movs	r0, #0
 8004706:	4770      	bx	lr
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_LF;
 8004708:	4b0a      	ldr	r3, [pc, #40]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 800470a:	2203      	movs	r2, #3
 800470c:	721a      	strb	r2, [r3, #8]
  uint8_t last_char = 0U;
 800470e:	2000      	movs	r0, #0
 8004710:	4770      	bx	lr
    if ((AT_CHAR_t)('\n') == rxChar)
 8004712:	2b0a      	cmp	r3, #10
 8004714:	d001      	beq.n	800471a <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x42>
  uint8_t last_char = 0U;
 8004716:	2000      	movs	r0, #0
 8004718:	4770      	bx	lr
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_FIRST_CHAR;
 800471a:	2001      	movs	r0, #1
 800471c:	4b05      	ldr	r3, [pc, #20]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 800471e:	7218      	strb	r0, [r3, #8]
      last_char = 1U;
 8004720:	4770      	bx	lr
    if ((AT_CHAR_t)('\r') == rxChar)
 8004722:	2b0d      	cmp	r3, #13
 8004724:	d001      	beq.n	800472a <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x52>
  uint8_t last_char = 0U;
 8004726:	2000      	movs	r0, #0
 8004728:	e7dc      	b.n	80046e4 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0xc>
      TYPE1SC_ctxt.state_SyntaxAutomaton = WAITING_FOR_LF;
 800472a:	4b02      	ldr	r3, [pc, #8]	; (8004734 <ATCustom_TYPE1SC_checkEndOfMsgCallback+0x5c>)
 800472c:	2203      	movs	r2, #3
 800472e:	721a      	strb	r2, [r3, #8]
  uint8_t last_char = 0U;
 8004730:	2000      	movs	r0, #0
 8004732:	4770      	bx	lr
 8004734:	20001084 	.word	0x20001084

08004738 <ATCustom_TYPE1SC_getCmd>:
{
 8004738:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800473c:	b083      	sub	sp, #12
 800473e:	4605      	mov	r5, r0
 8004740:	460e      	mov	r6, r1
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
 8004742:	f100 0810 	add.w	r8, r0, #16
  at_msg_t curSID = p_atp_ctxt->current_SID;
 8004746:	8a07      	ldrh	r7, [r0, #16]
  PRINT_API("enter ATCustom_TYPE1SC_getCmd() for SID %d", curSID)
 8004748:	4ca7      	ldr	r4, [pc, #668]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 800474a:	463a      	mov	r2, r7
 800474c:	49a7      	ldr	r1, [pc, #668]	; (80049ec <ATCustom_TYPE1SC_getCmd+0x2b4>)
 800474e:	4620      	mov	r0, r4
 8004750:	f022 f87a 	bl	8026848 <sprintf>
 8004754:	4620      	mov	r0, r4
 8004756:	f01a fde8 	bl	801f32a <crs_strlen>
 800475a:	b283      	uxth	r3, r0
 800475c:	4622      	mov	r2, r4
 800475e:	2104      	movs	r1, #4
 8004760:	2002      	movs	r0, #2
 8004762:	f01a fe25 	bl	801f3b0 <traceIF_itmPrint>
 8004766:	4620      	mov	r0, r4
 8004768:	f01a fddf 	bl	801f32a <crs_strlen>
 800476c:	b283      	uxth	r3, r0
 800476e:	4622      	mov	r2, r4
 8004770:	2104      	movs	r1, #4
 8004772:	2002      	movs	r0, #2
 8004774:	f01a fe3e 	bl	801f3f4 <traceIF_uartPrint>
  if (atcm_retrieve_SID_parameters(&TYPE1SC_ctxt, p_atp_ctxt) != ATSTATUS_OK)
 8004778:	4641      	mov	r1, r8
 800477a:	489d      	ldr	r0, [pc, #628]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 800477c:	f008 fef2 	bl	800d564 <atcm_retrieve_SID_parameters>
 8004780:	b120      	cbz	r0, 800478c <ATCustom_TYPE1SC_getCmd+0x54>
    retval = ATSTATUS_ERROR;
 8004782:	2401      	movs	r4, #1
}
 8004784:	4620      	mov	r0, r4
 8004786:	b003      	add	sp, #12
 8004788:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800478c:	4604      	mov	r4, r0
  atcm_reset_CMD_context(&TYPE1SC_ctxt.CMD_ctxt);
 800478e:	4899      	ldr	r0, [pc, #612]	; (80049f4 <ATCustom_TYPE1SC_getCmd+0x2bc>)
 8004790:	f008 fda4 	bl	800d2dc <atcm_reset_CMD_context>
  if (curSID == (at_msg_t) SID_CS_CHECK_CNX)
 8004794:	2f64      	cmp	r7, #100	; 0x64
 8004796:	d030      	beq.n	80047fa <ATCustom_TYPE1SC_getCmd+0xc2>
  else if (curSID == (at_msg_t) SID_CS_MODEM_CONFIG)
 8004798:	f1a7 0365 	sub.w	r3, r7, #101	; 0x65
 800479c:	2b29      	cmp	r3, #41	; 0x29
 800479e:	f200 8799 	bhi.w	80056d4 <ATCustom_TYPE1SC_getCmd+0xf9c>
 80047a2:	e8df f013 	tbh	[pc, r3, lsl #1]
 80047a6:	004c      	.short	0x004c
 80047a8:	02cf02b4 	.word	0x02cf02b4
 80047ac:	04140373 	.word	0x04140373
 80047b0:	04a6047e 	.word	0x04a6047e
 80047b4:	04070456 	.word	0x04070456
 80047b8:	052203fa 	.word	0x052203fa
 80047bc:	051004ff 	.word	0x051004ff
 80047c0:	04ce0533 	.word	0x04ce0533
 80047c4:	057004e6 	.word	0x057004e6
 80047c8:	056b0545 	.word	0x056b0545
 80047cc:	057f0797 	.word	0x057f0797
 80047d0:	060505d3 	.word	0x060505d3
 80047d4:	06140605 	.word	0x06140605
 80047d8:	0665063f 	.word	0x0665063f
 80047dc:	0630004c 	.word	0x0630004c
 80047e0:	0736003f 	.word	0x0736003f
 80047e4:	0745074a 	.word	0x0745074a
 80047e8:	0776075f 	.word	0x0776075f
 80047ec:	06740788 	.word	0x06740788
 80047f0:	06ea06bb 	.word	0x06ea06bb
 80047f4:	07100702 	.word	0x07100702
 80047f8:	0721      	.short	0x0721
    if (p_atp_ctxt->step == 0U)
 80047fa:	7cac      	ldrb	r4, [r5, #18]
 80047fc:	b14c      	cbz	r4, 8004812 <ATCustom_TYPE1SC_getCmd+0xda>
      retval = ATSTATUS_ERROR;
 80047fe:	2401      	movs	r4, #1
  if (retval == ATSTATUS_OK)
 8004800:	2c00      	cmp	r4, #0
 8004802:	d1bf      	bne.n	8004784 <ATCustom_TYPE1SC_getCmd+0x4c>
    retval = atcm_modem_build_cmd(&TYPE1SC_ctxt, p_atp_ctxt, p_ATcmdTimeout);
 8004804:	4632      	mov	r2, r6
 8004806:	4641      	mov	r1, r8
 8004808:	4879      	ldr	r0, [pc, #484]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 800480a:	f008 f995 	bl	800cb38 <atcm_modem_build_cmd>
 800480e:	4604      	mov	r4, r0
 8004810:	e7b8      	b.n	8004784 <ATCustom_TYPE1SC_getCmd+0x4c>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT, FINAL_CMD);
 8004812:	2301      	movs	r3, #1
 8004814:	9300      	str	r3, [sp, #0]
 8004816:	2300      	movs	r3, #0
 8004818:	2204      	movs	r2, #4
 800481a:	4641      	mov	r1, r8
 800481c:	4874      	ldr	r0, [pc, #464]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 800481e:	f008 f917 	bl	800ca50 <atcm_program_AT_CMD>
 8004822:	e7ed      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004824:	7cac      	ldrb	r4, [r5, #18]
 8004826:	b10c      	cbz	r4, 800482c <ATCustom_TYPE1SC_getCmd+0xf4>
      retval = ATSTATUS_ERROR;
 8004828:	2401      	movs	r4, #1
 800482a:	e7e9      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT, FINAL_CMD);
 800482c:	2301      	movs	r3, #1
 800482e:	9300      	str	r3, [sp, #0]
 8004830:	2300      	movs	r3, #0
 8004832:	2204      	movs	r2, #4
 8004834:	4641      	mov	r1, r8
 8004836:	486e      	ldr	r0, [pc, #440]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 8004838:	f008 f90a 	bl	800ca50 <atcm_program_AT_CMD>
 800483c:	e7e0      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if ((curSID == (at_msg_t) SID_CS_RESET) && (TYPE1SC_ctxt.SID_ctxt.reset_type != CS_RESET_HW))
 800483e:	2f80      	cmp	r7, #128	; 0x80
 8004840:	d034      	beq.n	80048ac <ATCustom_TYPE1SC_getCmd+0x174>
      if (p_atp_ctxt->step == 0U)
 8004842:	f895 9012 	ldrb.w	r9, [r5, #18]
 8004846:	f1b9 0f00 	cmp.w	r9, #0
 800484a:	d04d      	beq.n	80048e8 <ATCustom_TYPE1SC_getCmd+0x1b0>
      else if ((p_atp_ctxt->step >= 1U) && (p_atp_ctxt->step < TYPE1SC_MODEM_SYNCHRO_AT_MAX_RETRIES))
 800484c:	f109 33ff 	add.w	r3, r9, #4294967295
 8004850:	b2db      	uxtb	r3, r3
 8004852:	2b1c      	cmp	r3, #28
 8004854:	d87b      	bhi.n	800494e <ATCustom_TYPE1SC_getCmd+0x216>
        if (p_atp_ctxt->step >= 11U)
 8004856:	f1b9 0f0a 	cmp.w	r9, #10
 800485a:	d902      	bls.n	8004862 <ATCustom_TYPE1SC_getCmd+0x12a>
          reprogram_bdelay = true;
 800485c:	4b66      	ldr	r3, [pc, #408]	; (80049f8 <ATCustom_TYPE1SC_getCmd+0x2c0>)
 800485e:	2201      	movs	r2, #1
 8004860:	701a      	strb	r2, [r3, #0]
        if (TYPE1SC_ctxt.persist.modem_at_ready == AT_FALSE)
 8004862:	4b63      	ldr	r3, [pc, #396]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 8004864:	f893 350e 	ldrb.w	r3, [r3, #1294]	; 0x50e
 8004868:	2b00      	cmp	r3, #0
 800486a:	d152      	bne.n	8004912 <ATCustom_TYPE1SC_getCmd+0x1da>
          PRINT_DBG("test connection [try number %d] ", p_atp_ctxt->step)
 800486c:	4d5e      	ldr	r5, [pc, #376]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 800486e:	464a      	mov	r2, r9
 8004870:	4962      	ldr	r1, [pc, #392]	; (80049fc <ATCustom_TYPE1SC_getCmd+0x2c4>)
 8004872:	4628      	mov	r0, r5
 8004874:	f021 ffe8 	bl	8026848 <sprintf>
 8004878:	4628      	mov	r0, r5
 800487a:	f01a fd56 	bl	801f32a <crs_strlen>
 800487e:	b283      	uxth	r3, r0
 8004880:	462a      	mov	r2, r5
 8004882:	2102      	movs	r1, #2
 8004884:	4608      	mov	r0, r1
 8004886:	f01a fd93 	bl	801f3b0 <traceIF_itmPrint>
 800488a:	4628      	mov	r0, r5
 800488c:	f01a fd4d 	bl	801f32a <crs_strlen>
 8004890:	b283      	uxth	r3, r0
 8004892:	462a      	mov	r2, r5
 8004894:	2102      	movs	r1, #2
 8004896:	4608      	mov	r0, r1
 8004898:	f01a fdac 	bl	801f3f4 <traceIF_uartPrint>
          atcm_program_AT_CMD_ANSWER_OPTIONAL(&TYPE1SC_ctxt, p_atp_ctxt,
 800489c:	2300      	movs	r3, #0
 800489e:	9300      	str	r3, [sp, #0]
 80048a0:	2204      	movs	r2, #4
 80048a2:	4641      	mov	r1, r8
 80048a4:	4852      	ldr	r0, [pc, #328]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 80048a6:	f008 f8e5 	bl	800ca74 <atcm_program_AT_CMD_ANSWER_OPTIONAL>
 80048aa:	e7a9      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if ((curSID == (at_msg_t) SID_CS_RESET) && (TYPE1SC_ctxt.SID_ctxt.reset_type != CS_RESET_HW))
 80048ac:	4b50      	ldr	r3, [pc, #320]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 80048ae:	f893 26c8 	ldrb.w	r2, [r3, #1736]	; 0x6c8
 80048b2:	2a01      	cmp	r2, #1
 80048b4:	d0c5      	beq.n	8004842 <ATCustom_TYPE1SC_getCmd+0x10a>
      PRINT_ERR("Reset type (%d) not supported", TYPE1SC_ctxt.SID_ctxt.reset_type)
 80048b6:	4c4c      	ldr	r4, [pc, #304]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 80048b8:	4951      	ldr	r1, [pc, #324]	; (8004a00 <ATCustom_TYPE1SC_getCmd+0x2c8>)
 80048ba:	4620      	mov	r0, r4
 80048bc:	f021 ffc4 	bl	8026848 <sprintf>
 80048c0:	4620      	mov	r0, r4
 80048c2:	f01a fd32 	bl	801f32a <crs_strlen>
 80048c6:	b283      	uxth	r3, r0
 80048c8:	4622      	mov	r2, r4
 80048ca:	2110      	movs	r1, #16
 80048cc:	2002      	movs	r0, #2
 80048ce:	f01a fd6f 	bl	801f3b0 <traceIF_itmPrint>
 80048d2:	4620      	mov	r0, r4
 80048d4:	f01a fd29 	bl	801f32a <crs_strlen>
 80048d8:	b283      	uxth	r3, r0
 80048da:	4622      	mov	r2, r4
 80048dc:	2110      	movs	r1, #16
 80048de:	2002      	movs	r0, #2
 80048e0:	f01a fd88 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 80048e4:	2401      	movs	r4, #1
 80048e6:	e78b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        reset_variables_TYPE1SC();
 80048e8:	f7ff fe0a 	bl	8004500 <reset_variables_TYPE1SC>
        TYPE1SC_ctxt.persist.modem_at_ready = AT_FALSE;
 80048ec:	4b40      	ldr	r3, [pc, #256]	; (80049f0 <ATCustom_TYPE1SC_getCmd+0x2b8>)
 80048ee:	2200      	movs	r2, #0
 80048f0:	f883 250e 	strb.w	r2, [r3, #1294]	; 0x50e
        if (curSID == (at_msg_t) SID_CS_RESET)
 80048f4:	2f80      	cmp	r7, #128	; 0x80
 80048f6:	d008      	beq.n	800490a <ATCustom_TYPE1SC_getCmd+0x1d2>
        (void) SysCtrl_TYPE1SC_reinit_channel(p_at_ctxt->ipc_handle, SYSCTRL_HW_FLOW_CONTROL_NONE);
 80048f8:	2100      	movs	r1, #0
 80048fa:	6868      	ldr	r0, [r5, #4]
 80048fc:	f002 fad4 	bl	8006ea8 <SysCtrl_TYPE1SC_reinit_channel>
        atcm_program_SKIP_CMD(p_atp_ctxt);
 8004900:	4640      	mov	r0, r8
 8004902:	f008 f90d 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004906:	464c      	mov	r4, r9
 8004908:	e77a      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          type1sc_modem_reset(&TYPE1SC_ctxt);
 800490a:	4618      	mov	r0, r3
 800490c:	f7ff fe92 	bl	8004634 <type1sc_modem_reset>
 8004910:	e7f2      	b.n	80048f8 <ATCustom_TYPE1SC_getCmd+0x1c0>
          PRINT_INFO("modem synchro established, proceed to normal power sequence")
 8004912:	4f35      	ldr	r7, [pc, #212]	; (80049e8 <ATCustom_TYPE1SC_getCmd+0x2b0>)
 8004914:	2246      	movs	r2, #70	; 0x46
 8004916:	493b      	ldr	r1, [pc, #236]	; (8004a04 <ATCustom_TYPE1SC_getCmd+0x2cc>)
 8004918:	4638      	mov	r0, r7
 800491a:	f022 f8e5 	bl	8026ae8 <memcpy>
 800491e:	4638      	mov	r0, r7
 8004920:	f01a fd03 	bl	801f32a <crs_strlen>
 8004924:	b283      	uxth	r3, r0
 8004926:	463a      	mov	r2, r7
 8004928:	2101      	movs	r1, #1
 800492a:	2002      	movs	r0, #2
 800492c:	f01a fd40 	bl	801f3b0 <traceIF_itmPrint>
 8004930:	4638      	mov	r0, r7
 8004932:	f01a fcfa 	bl	801f32a <crs_strlen>
 8004936:	b283      	uxth	r3, r0
 8004938:	463a      	mov	r2, r7
 800493a:	2101      	movs	r1, #1
 800493c:	2002      	movs	r0, #2
 800493e:	f01a fd59 	bl	801f3f4 <traceIF_uartPrint>
          p_atp_ctxt->step = common_start_sequence_step - 1U;
 8004942:	231e      	movs	r3, #30
 8004944:	74ab      	strb	r3, [r5, #18]
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004946:	4640      	mov	r0, r8
 8004948:	f008 f8ea 	bl	800cb20 <atcm_program_SKIP_CMD>
 800494c:	e758      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      else if (p_atp_ctxt->step == TYPE1SC_MODEM_SYNCHRO_AT_MAX_RETRIES)
 800494e:	f1b9 0f1e 	cmp.w	r9, #30
 8004952:	d059      	beq.n	8004a08 <ATCustom_TYPE1SC_getCmd+0x2d0>
      else if (p_atp_ctxt->step == (common_start_sequence_step))
 8004954:	f1b9 0f1f 	cmp.w	r9, #31
 8004958:	f000 8087 	beq.w	8004a6a <ATCustom_TYPE1SC_getCmd+0x332>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 1U))
 800495c:	f1b9 0f20 	cmp.w	r9, #32
 8004960:	f000 808e 	beq.w	8004a80 <ATCustom_TYPE1SC_getCmd+0x348>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 2U))
 8004964:	f1b9 0f21 	cmp.w	r9, #33	; 0x21
 8004968:	f000 8095 	beq.w	8004a96 <ATCustom_TYPE1SC_getCmd+0x35e>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 3U))
 800496c:	f1b9 0f22 	cmp.w	r9, #34	; 0x22
 8004970:	f000 809a 	beq.w	8004aa8 <ATCustom_TYPE1SC_getCmd+0x370>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 4U))
 8004974:	f1b9 0f23 	cmp.w	r9, #35	; 0x23
 8004978:	f000 80a2 	beq.w	8004ac0 <ATCustom_TYPE1SC_getCmd+0x388>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 5U))
 800497c:	f1b9 0f24 	cmp.w	r9, #36	; 0x24
 8004980:	f000 80a7 	beq.w	8004ad2 <ATCustom_TYPE1SC_getCmd+0x39a>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 6U))
 8004984:	f1b9 0f25 	cmp.w	r9, #37	; 0x25
 8004988:	f000 80b0 	beq.w	8004aec <ATCustom_TYPE1SC_getCmd+0x3b4>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 7U))
 800498c:	f1b9 0f26 	cmp.w	r9, #38	; 0x26
 8004990:	f000 80b9 	beq.w	8004b06 <ATCustom_TYPE1SC_getCmd+0x3ce>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 8U))
 8004994:	f1b9 0f27 	cmp.w	r9, #39	; 0x27
 8004998:	f000 80c2 	beq.w	8004b20 <ATCustom_TYPE1SC_getCmd+0x3e8>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 9U))
 800499c:	f1b9 0f28 	cmp.w	r9, #40	; 0x28
 80049a0:	f000 80cb 	beq.w	8004b3a <ATCustom_TYPE1SC_getCmd+0x402>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 10U))
 80049a4:	f1b9 0f29 	cmp.w	r9, #41	; 0x29
 80049a8:	f000 8125 	beq.w	8004bf6 <ATCustom_TYPE1SC_getCmd+0x4be>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 11U))
 80049ac:	f1b9 0f2a 	cmp.w	r9, #42	; 0x2a
 80049b0:	f000 8125 	beq.w	8004bfe <ATCustom_TYPE1SC_getCmd+0x4c6>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 12U))
 80049b4:	f1b9 0f2b 	cmp.w	r9, #43	; 0x2b
 80049b8:	f000 812a 	beq.w	8004c10 <ATCustom_TYPE1SC_getCmd+0x4d8>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 13U))
 80049bc:	f1b9 0f2c 	cmp.w	r9, #44	; 0x2c
 80049c0:	f000 8131 	beq.w	8004c26 <ATCustom_TYPE1SC_getCmd+0x4ee>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 14U))
 80049c4:	f1b9 0f2d 	cmp.w	r9, #45	; 0x2d
 80049c8:	f000 8135 	beq.w	8004c36 <ATCustom_TYPE1SC_getCmd+0x4fe>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 15U))
 80049cc:	f1b9 0f2e 	cmp.w	r9, #46	; 0x2e
 80049d0:	f000 813e 	beq.w	8004c50 <ATCustom_TYPE1SC_getCmd+0x518>
      else if (p_atp_ctxt->step == (common_start_sequence_step + 16U))
 80049d4:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
 80049d8:	f000 8190 	beq.w	8004cfc <ATCustom_TYPE1SC_getCmd+0x5c4>
      else if (p_atp_ctxt->step >= (common_start_sequence_step + 17U))
 80049dc:	f1b9 0f2f 	cmp.w	r9, #47	; 0x2f
 80049e0:	f67f af0e 	bls.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        retval = ATSTATUS_ERROR;
 80049e4:	2401      	movs	r4, #1
 80049e6:	e70b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 80049e8:	200048dc 	.word	0x200048dc
 80049ec:	0802c3e8 	.word	0x0802c3e8
 80049f0:	20001084 	.word	0x20001084
 80049f4:	200017b0 	.word	0x200017b0
 80049f8:	20001834 	.word	0x20001834
 80049fc:	0802c454 	.word	0x0802c454
 8004a00:	0802c424 	.word	0x0802c424
 8004a04:	0802c480 	.word	0x0802c480
        if (TYPE1SC_ctxt.persist.modem_at_ready == AT_FALSE)
 8004a08:	4bc5      	ldr	r3, [pc, #788]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004a0a:	f893 350e 	ldrb.w	r3, [r3, #1294]	; 0x50e
 8004a0e:	bb43      	cbnz	r3, 8004a62 <ATCustom_TYPE1SC_getCmd+0x32a>
          PRINT_ERR("Impossible to sync with modem")
 8004a10:	4cc4      	ldr	r4, [pc, #784]	; (8004d24 <ATCustom_TYPE1SC_getCmd+0x5ec>)
 8004a12:	4dc5      	ldr	r5, [pc, #788]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004a14:	f104 0c20 	add.w	ip, r4, #32
 8004a18:	4627      	mov	r7, r4
 8004a1a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004a1c:	6028      	str	r0, [r5, #0]
 8004a1e:	6069      	str	r1, [r5, #4]
 8004a20:	60aa      	str	r2, [r5, #8]
 8004a22:	60eb      	str	r3, [r5, #12]
 8004a24:	463c      	mov	r4, r7
 8004a26:	3510      	adds	r5, #16
 8004a28:	4567      	cmp	r7, ip
 8004a2a:	d1f5      	bne.n	8004a18 <ATCustom_TYPE1SC_getCmd+0x2e0>
 8004a2c:	cc07      	ldmia	r4!, {r0, r1, r2}
 8004a2e:	6028      	str	r0, [r5, #0]
 8004a30:	6069      	str	r1, [r5, #4]
 8004a32:	60aa      	str	r2, [r5, #8]
 8004a34:	8823      	ldrh	r3, [r4, #0]
 8004a36:	81ab      	strh	r3, [r5, #12]
 8004a38:	4cbb      	ldr	r4, [pc, #748]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004a3a:	4620      	mov	r0, r4
 8004a3c:	f01a fc75 	bl	801f32a <crs_strlen>
 8004a40:	b283      	uxth	r3, r0
 8004a42:	4622      	mov	r2, r4
 8004a44:	2110      	movs	r1, #16
 8004a46:	2002      	movs	r0, #2
 8004a48:	f01a fcb2 	bl	801f3b0 <traceIF_itmPrint>
 8004a4c:	4620      	mov	r0, r4
 8004a4e:	f01a fc6c 	bl	801f32a <crs_strlen>
 8004a52:	b283      	uxth	r3, r0
 8004a54:	4622      	mov	r2, r4
 8004a56:	2110      	movs	r1, #16
 8004a58:	2002      	movs	r0, #2
 8004a5a:	f01a fccb 	bl	801f3f4 <traceIF_uartPrint>
          retval = ATSTATUS_ERROR;
 8004a5e:	2401      	movs	r4, #1
 8004a60:	e6ce      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004a62:	4640      	mov	r0, r8
 8004a64:	f008 f85c 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004a68:	e6ca      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.CMD_ctxt.cfun_value = 0U;
 8004a6a:	48ad      	ldr	r0, [pc, #692]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004a6c:	2300      	movs	r3, #0
 8004a6e:	f880 373d 	strb.w	r3, [r0, #1853]	; 0x73d
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CFUN, INTERMEDIATE_CMD);
 8004a72:	9300      	str	r3, [sp, #0]
 8004a74:	2313      	movs	r3, #19
 8004a76:	2203      	movs	r2, #3
 8004a78:	4641      	mov	r1, r8
 8004a7a:	f007 ffe9 	bl	800ca50 <atcm_program_AT_CMD>
 8004a7e:	e6bf      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.CMD_ctxt.command_echo = AT_FALSE;
 8004a80:	48a7      	ldr	r0, [pc, #668]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004a82:	2300      	movs	r3, #0
 8004a84:	f880 372f 	strb.w	r3, [r0, #1839]	; 0x72f
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_ATE, INTERMEDIATE_CMD);
 8004a88:	9300      	str	r3, [sp, #0]
 8004a8a:	2328      	movs	r3, #40	; 0x28
 8004a8c:	2204      	movs	r2, #4
 8004a8e:	4641      	mov	r1, r8
 8004a90:	f007 ffde 	bl	800ca50 <atcm_program_AT_CMD>
 8004a94:	e6b4      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CMEE, INTERMEDIATE_CMD);
 8004a96:	2300      	movs	r3, #0
 8004a98:	9300      	str	r3, [sp, #0]
 8004a9a:	2311      	movs	r3, #17
 8004a9c:	2203      	movs	r2, #3
 8004a9e:	4641      	mov	r1, r8
 8004aa0:	489f      	ldr	r0, [pc, #636]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004aa2:	f007 ffd5 	bl	800ca50 <atcm_program_AT_CMD>
 8004aa6:	e6ab      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.CMD_ctxt.dce_full_resp_format = AT_TRUE;
 8004aa8:	489d      	ldr	r0, [pc, #628]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004aaa:	2301      	movs	r3, #1
 8004aac:	f880 3730 	strb.w	r3, [r0, #1840]	; 0x730
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_ATV, INTERMEDIATE_CMD);
 8004ab0:	2300      	movs	r3, #0
 8004ab2:	9300      	str	r3, [sp, #0]
 8004ab4:	232b      	movs	r3, #43	; 0x2b
 8004ab6:	2204      	movs	r2, #4
 8004ab8:	4641      	mov	r1, r8
 8004aba:	f007 ffc9 	bl	800ca50 <atcm_program_AT_CMD>
 8004abe:	e69f      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMR, INTERMEDIATE_CMD);
 8004ac0:	2300      	movs	r3, #0
 8004ac2:	9300      	str	r3, [sp, #0]
 8004ac4:	230d      	movs	r3, #13
 8004ac6:	2204      	movs	r2, #4
 8004ac8:	4641      	mov	r1, r8
 8004aca:	4895      	ldr	r0, [pc, #596]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004acc:	f007 ffc0 	bl	800ca50 <atcm_program_AT_CMD>
 8004ad0:	e696      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_BAND;
 8004ad2:	4b96      	ldr	r3, [pc, #600]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004ad4:	2202      	movs	r2, #2
 8004ad6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETCFG, INTERMEDIATE_CMD);
 8004ada:	2300      	movs	r3, #0
 8004adc:	9300      	str	r3, [sp, #0]
 8004ade:	233b      	movs	r3, #59	; 0x3b
 8004ae0:	2203      	movs	r2, #3
 8004ae2:	4641      	mov	r1, r8
 8004ae4:	488e      	ldr	r0, [pc, #568]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004ae6:	f007 ffb3 	bl	800ca50 <atcm_program_AT_CMD>
 8004aea:	e689      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_HIFC_MODE;
 8004aec:	4b8f      	ldr	r3, [pc, #572]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004aee:	2204      	movs	r2, #4
 8004af0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETACFG, INTERMEDIATE_CMD);
 8004af4:	2300      	movs	r3, #0
 8004af6:	9300      	str	r3, [sp, #0]
 8004af8:	233d      	movs	r3, #61	; 0x3d
 8004afa:	2203      	movs	r2, #3
 8004afc:	4641      	mov	r1, r8
 8004afe:	4888      	ldr	r0, [pc, #544]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b00:	f007 ffa6 	bl	800ca50 <atcm_program_AT_CMD>
 8004b04:	e67c      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_PMCONF_SLEEP_MODE;
 8004b06:	4b89      	ldr	r3, [pc, #548]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004b08:	2205      	movs	r2, #5
 8004b0a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETACFG, INTERMEDIATE_CMD);
 8004b0e:	2300      	movs	r3, #0
 8004b10:	9300      	str	r3, [sp, #0]
 8004b12:	233d      	movs	r3, #61	; 0x3d
 8004b14:	2203      	movs	r2, #3
 8004b16:	4641      	mov	r1, r8
 8004b18:	4881      	ldr	r0, [pc, #516]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b1a:	f007 ff99 	bl	800ca50 <atcm_program_AT_CMD>
 8004b1e:	e66f      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.getcfg_function = SETGETCFG_PMCONF_MAX_ALLOWED;
 8004b20:	4b82      	ldr	r3, [pc, #520]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004b22:	2206      	movs	r2, #6
 8004b24:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_GETACFG, INTERMEDIATE_CMD);
 8004b28:	2300      	movs	r3, #0
 8004b2a:	9300      	str	r3, [sp, #0]
 8004b2c:	233d      	movs	r3, #61	; 0x3d
 8004b2e:	2203      	movs	r2, #3
 8004b30:	4641      	mov	r1, r8
 8004b32:	487b      	ldr	r0, [pc, #492]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b34:	f007 ff8c 	bl	800ca50 <atcm_program_AT_CMD>
 8004b38:	e662      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        if (reprogram_bdelay == true)
 8004b3a:	4b7d      	ldr	r3, [pc, #500]	; (8004d30 <ATCustom_TYPE1SC_getCmd+0x5f8>)
 8004b3c:	781b      	ldrb	r3, [r3, #0]
 8004b3e:	b383      	cbz	r3, 8004ba2 <ATCustom_TYPE1SC_getCmd+0x46a>
          PRINT_INFO("Reprogram modem boot delay")
 8004b40:	4f7c      	ldr	r7, [pc, #496]	; (8004d34 <ATCustom_TYPE1SC_getCmd+0x5fc>)
 8004b42:	4d79      	ldr	r5, [pc, #484]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004b44:	f107 0e20 	add.w	lr, r7, #32
 8004b48:	46bc      	mov	ip, r7
 8004b4a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004b4e:	6028      	str	r0, [r5, #0]
 8004b50:	6069      	str	r1, [r5, #4]
 8004b52:	60aa      	str	r2, [r5, #8]
 8004b54:	60eb      	str	r3, [r5, #12]
 8004b56:	4667      	mov	r7, ip
 8004b58:	3510      	adds	r5, #16
 8004b5a:	45f4      	cmp	ip, lr
 8004b5c:	d1f4      	bne.n	8004b48 <ATCustom_TYPE1SC_getCmd+0x410>
 8004b5e:	f8dc 0000 	ldr.w	r0, [ip]
 8004b62:	6028      	str	r0, [r5, #0]
 8004b64:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8004b68:	712b      	strb	r3, [r5, #4]
 8004b6a:	4d6f      	ldr	r5, [pc, #444]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004b6c:	4628      	mov	r0, r5
 8004b6e:	f01a fbdc 	bl	801f32a <crs_strlen>
 8004b72:	b283      	uxth	r3, r0
 8004b74:	462a      	mov	r2, r5
 8004b76:	2101      	movs	r1, #1
 8004b78:	2002      	movs	r0, #2
 8004b7a:	f01a fc19 	bl	801f3b0 <traceIF_itmPrint>
 8004b7e:	4628      	mov	r0, r5
 8004b80:	f01a fbd3 	bl	801f32a <crs_strlen>
 8004b84:	b283      	uxth	r3, r0
 8004b86:	462a      	mov	r2, r5
 8004b88:	2101      	movs	r1, #1
 8004b8a:	2002      	movs	r0, #2
 8004b8c:	f01a fc32 	bl	801f3f4 <traceIF_uartPrint>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt,
 8004b90:	2300      	movs	r3, #0
 8004b92:	9300      	str	r3, [sp, #0]
 8004b94:	233e      	movs	r3, #62	; 0x3e
 8004b96:	2203      	movs	r2, #3
 8004b98:	4641      	mov	r1, r8
 8004b9a:	4861      	ldr	r0, [pc, #388]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004b9c:	f007 ff58 	bl	800ca50 <atcm_program_AT_CMD>
 8004ba0:	e62e      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          PRINT_INFO("Do not reprogram modem boot delay")
 8004ba2:	4d65      	ldr	r5, [pc, #404]	; (8004d38 <ATCustom_TYPE1SC_getCmd+0x600>)
 8004ba4:	4f60      	ldr	r7, [pc, #384]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004ba6:	f105 0e20 	add.w	lr, r5, #32
 8004baa:	46ac      	mov	ip, r5
 8004bac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004bb0:	6038      	str	r0, [r7, #0]
 8004bb2:	6079      	str	r1, [r7, #4]
 8004bb4:	60ba      	str	r2, [r7, #8]
 8004bb6:	60fb      	str	r3, [r7, #12]
 8004bb8:	4665      	mov	r5, ip
 8004bba:	3710      	adds	r7, #16
 8004bbc:	45f4      	cmp	ip, lr
 8004bbe:	d1f4      	bne.n	8004baa <ATCustom_TYPE1SC_getCmd+0x472>
 8004bc0:	cd07      	ldmia	r5!, {r0, r1, r2}
 8004bc2:	6038      	str	r0, [r7, #0]
 8004bc4:	6079      	str	r1, [r7, #4]
 8004bc6:	60ba      	str	r2, [r7, #8]
 8004bc8:	4d57      	ldr	r5, [pc, #348]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004bca:	4628      	mov	r0, r5
 8004bcc:	f01a fbad 	bl	801f32a <crs_strlen>
 8004bd0:	b283      	uxth	r3, r0
 8004bd2:	462a      	mov	r2, r5
 8004bd4:	2101      	movs	r1, #1
 8004bd6:	2002      	movs	r0, #2
 8004bd8:	f01a fbea 	bl	801f3b0 <traceIF_itmPrint>
 8004bdc:	4628      	mov	r0, r5
 8004bde:	f01a fba4 	bl	801f32a <crs_strlen>
 8004be2:	b283      	uxth	r3, r0
 8004be4:	462a      	mov	r2, r5
 8004be6:	2101      	movs	r1, #1
 8004be8:	2002      	movs	r0, #2
 8004bea:	f01a fc03 	bl	801f3f4 <traceIF_uartPrint>
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004bee:	4640      	mov	r0, r8
 8004bf0:	f007 ff96 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004bf4:	e604      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_SKIP_CMD(p_atp_ctxt);
 8004bf6:	4640      	mov	r0, r8
 8004bf8:	f007 ff92 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004bfc:	e600      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_IFC, INTERMEDIATE_CMD);
 8004bfe:	2300      	movs	r3, #0
 8004c00:	9300      	str	r3, [sp, #0]
 8004c02:	2332      	movs	r3, #50	; 0x32
 8004c04:	2203      	movs	r2, #3
 8004c06:	4641      	mov	r1, r8
 8004c08:	4845      	ldr	r0, [pc, #276]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004c0a:	f007 ff21 	bl	800ca50 <atcm_program_AT_CMD>
 8004c0e:	e5f7      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        (void) SysCtrl_TYPE1SC_reinit_channel(p_at_ctxt->ipc_handle, SYSCTRL_HW_FLOW_CONTROL_RTS_CTS);
 8004c10:	2101      	movs	r1, #1
 8004c12:	6868      	ldr	r0, [r5, #4]
 8004c14:	f002 f948 	bl	8006ea8 <SysCtrl_TYPE1SC_reinit_channel>
        atcm_program_TEMPO(p_atp_ctxt, 3000U, INTERMEDIATE_CMD);
 8004c18:	2200      	movs	r2, #0
 8004c1a:	f640 31b8 	movw	r1, #3000	; 0xbb8
 8004c1e:	4640      	mov	r0, r8
 8004c20:	f007 ff46 	bl	800cab0 <atcm_program_TEMPO>
 8004c24:	e5ec      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD_ANSWER_OPTIONAL(&TYPE1SC_ctxt, p_atp_ctxt,
 8004c26:	2300      	movs	r3, #0
 8004c28:	9300      	str	r3, [sp, #0]
 8004c2a:	2204      	movs	r2, #4
 8004c2c:	4641      	mov	r1, r8
 8004c2e:	483c      	ldr	r0, [pc, #240]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004c30:	f007 ff20 	bl	800ca74 <atcm_program_AT_CMD_ANSWER_OPTIONAL>
 8004c34:	e5e4      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        type1sc_shared.setcfg_function = SETGETCFG_BOOT_EVENT_TRUE;
 8004c36:	4b3d      	ldr	r3, [pc, #244]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004c38:	2207      	movs	r2, #7
 8004c3a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SETACFG, INTERMEDIATE_CMD);
 8004c3e:	2300      	movs	r3, #0
 8004c40:	9300      	str	r3, [sp, #0]
 8004c42:	233c      	movs	r3, #60	; 0x3c
 8004c44:	2203      	movs	r2, #3
 8004c46:	4641      	mov	r1, r8
 8004c48:	4835      	ldr	r0, [pc, #212]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004c4a:	f007 ff01 	bl	800ca50 <atcm_program_AT_CMD>
 8004c4e:	e5d7      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        if (type1sc_shared.modem_bootev_received == true)
 8004c50:	4b36      	ldr	r3, [pc, #216]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004c52:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8004c56:	b1db      	cbz	r3, 8004c90 <ATCustom_TYPE1SC_getCmd+0x558>
          PRINT_INFO("***** BOOTEV already received, continue init sequence *****")
 8004c58:	4d33      	ldr	r5, [pc, #204]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004c5a:	2246      	movs	r2, #70	; 0x46
 8004c5c:	4937      	ldr	r1, [pc, #220]	; (8004d3c <ATCustom_TYPE1SC_getCmd+0x604>)
 8004c5e:	4628      	mov	r0, r5
 8004c60:	f021 ff42 	bl	8026ae8 <memcpy>
 8004c64:	4628      	mov	r0, r5
 8004c66:	f01a fb60 	bl	801f32a <crs_strlen>
 8004c6a:	b283      	uxth	r3, r0
 8004c6c:	462a      	mov	r2, r5
 8004c6e:	2101      	movs	r1, #1
 8004c70:	2002      	movs	r0, #2
 8004c72:	f01a fb9d 	bl	801f3b0 <traceIF_itmPrint>
 8004c76:	4628      	mov	r0, r5
 8004c78:	f01a fb57 	bl	801f32a <crs_strlen>
 8004c7c:	b283      	uxth	r3, r0
 8004c7e:	462a      	mov	r2, r5
 8004c80:	2101      	movs	r1, #1
 8004c82:	2002      	movs	r0, #2
 8004c84:	f01a fbb6 	bl	801f3f4 <traceIF_uartPrint>
          atcm_program_SKIP_CMD(p_atp_ctxt);
 8004c88:	4640      	mov	r0, r8
 8004c8a:	f007 ff49 	bl	800cb20 <atcm_program_SKIP_CMD>
 8004c8e:	e5b7      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          type1sc_shared.modem_waiting_for_bootev = true;
 8004c90:	4b26      	ldr	r3, [pc, #152]	; (8004d2c <ATCustom_TYPE1SC_getCmd+0x5f4>)
 8004c92:	2201      	movs	r2, #1
 8004c94:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
          PRINT_INFO("***** wait for optional BOOTEV *****")
 8004c98:	4d29      	ldr	r5, [pc, #164]	; (8004d40 <ATCustom_TYPE1SC_getCmd+0x608>)
 8004c9a:	4f23      	ldr	r7, [pc, #140]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004c9c:	f105 0e20 	add.w	lr, r5, #32
 8004ca0:	46ac      	mov	ip, r5
 8004ca2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004ca6:	6038      	str	r0, [r7, #0]
 8004ca8:	6079      	str	r1, [r7, #4]
 8004caa:	60ba      	str	r2, [r7, #8]
 8004cac:	60fb      	str	r3, [r7, #12]
 8004cae:	4665      	mov	r5, ip
 8004cb0:	3710      	adds	r7, #16
 8004cb2:	45f4      	cmp	ip, lr
 8004cb4:	d1f4      	bne.n	8004ca0 <ATCustom_TYPE1SC_getCmd+0x568>
 8004cb6:	4663      	mov	r3, ip
 8004cb8:	cb07      	ldmia	r3!, {r0, r1, r2}
 8004cba:	6038      	str	r0, [r7, #0]
 8004cbc:	6079      	str	r1, [r7, #4]
 8004cbe:	60ba      	str	r2, [r7, #8]
 8004cc0:	881a      	ldrh	r2, [r3, #0]
 8004cc2:	789b      	ldrb	r3, [r3, #2]
 8004cc4:	81ba      	strh	r2, [r7, #12]
 8004cc6:	73bb      	strb	r3, [r7, #14]
 8004cc8:	4d17      	ldr	r5, [pc, #92]	; (8004d28 <ATCustom_TYPE1SC_getCmd+0x5f0>)
 8004cca:	4628      	mov	r0, r5
 8004ccc:	f01a fb2d 	bl	801f32a <crs_strlen>
 8004cd0:	b283      	uxth	r3, r0
 8004cd2:	462a      	mov	r2, r5
 8004cd4:	2101      	movs	r1, #1
 8004cd6:	2002      	movs	r0, #2
 8004cd8:	f01a fb6a 	bl	801f3b0 <traceIF_itmPrint>
 8004cdc:	4628      	mov	r0, r5
 8004cde:	f01a fb24 	bl	801f32a <crs_strlen>
 8004ce2:	b283      	uxth	r3, r0
 8004ce4:	462a      	mov	r2, r5
 8004ce6:	2101      	movs	r1, #1
 8004ce8:	2002      	movs	r0, #2
 8004cea:	f01a fb83 	bl	801f3f4 <traceIF_uartPrint>
          atcm_program_TEMPO(p_atp_ctxt, TYPE1SC_BOOTEV_TIMEOUT, INTERMEDIATE_CMD);
 8004cee:	2200      	movs	r2, #0
 8004cf0:	f241 3188 	movw	r1, #5000	; 0x1388
 8004cf4:	4640      	mov	r0, r8
 8004cf6:	f007 fedb 	bl	800cab0 <atcm_program_TEMPO>
 8004cfa:	e581      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT, FINAL_CMD);
 8004cfc:	2301      	movs	r3, #1
 8004cfe:	9300      	str	r3, [sp, #0]
 8004d00:	2300      	movs	r3, #0
 8004d02:	2204      	movs	r2, #4
 8004d04:	4641      	mov	r1, r8
 8004d06:	4806      	ldr	r0, [pc, #24]	; (8004d20 <ATCustom_TYPE1SC_getCmd+0x5e8>)
 8004d08:	f007 fea2 	bl	800ca50 <atcm_program_AT_CMD>
 8004d0c:	e578      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004d0e:	7cac      	ldrb	r4, [r5, #18]
 8004d10:	b10c      	cbz	r4, 8004d16 <ATCustom_TYPE1SC_getCmd+0x5de>
      retval = ATSTATUS_ERROR;
 8004d12:	2401      	movs	r4, #1
 8004d14:	e574      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8004d16:	4640      	mov	r0, r8
 8004d18:	f007 fef6 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8004d1c:	e570      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8004d1e:	bf00      	nop
 8004d20:	20001084 	.word	0x20001084
 8004d24:	0802c4c8 	.word	0x0802c4c8
 8004d28:	200048dc 	.word	0x200048dc
 8004d2c:	20001838 	.word	0x20001838
 8004d30:	20001834 	.word	0x20001834
 8004d34:	0802c4f8 	.word	0x0802c4f8
 8004d38:	0802c520 	.word	0x0802c520
 8004d3c:	0802c54c 	.word	0x0802c54c
 8004d40:	0802c594 	.word	0x0802c594
    if (p_atp_ctxt->step == 0U)
 8004d44:	7cad      	ldrb	r5, [r5, #18]
 8004d46:	b12d      	cbz	r5, 8004d54 <ATCustom_TYPE1SC_getCmd+0x61c>
    else if (p_atp_ctxt->step == 1U)
 8004d48:	2d01      	cmp	r5, #1
 8004d4a:	d00d      	beq.n	8004d68 <ATCustom_TYPE1SC_getCmd+0x630>
    else if (p_atp_ctxt->step == 2U)
 8004d4c:	2d02      	cmp	r5, #2
 8004d4e:	d01d      	beq.n	8004d8c <ATCustom_TYPE1SC_getCmd+0x654>
      retval = ATSTATUS_ERROR;
 8004d50:	2401      	movs	r4, #1
 8004d52:	e555      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CFUN, INTERMEDIATE_CMD);
 8004d54:	2300      	movs	r3, #0
 8004d56:	9300      	str	r3, [sp, #0]
 8004d58:	2313      	movs	r3, #19
 8004d5a:	2203      	movs	r2, #3
 8004d5c:	4641      	mov	r1, r8
 8004d5e:	48b0      	ldr	r0, [pc, #704]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d60:	f007 fe76 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004d64:	462c      	mov	r4, r5
 8004d66:	e54b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if (TYPE1SC_ctxt.SID_ctxt.modem_init.init == CS_CMI_MINI)
 8004d68:	4bad      	ldr	r3, [pc, #692]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d6a:	f893 55b1 	ldrb.w	r5, [r3, #1457]	; 0x5b1
 8004d6e:	b925      	cbnz	r5, 8004d7a <ATCustom_TYPE1SC_getCmd+0x642>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8004d70:	4640      	mov	r0, r8
 8004d72:	f007 fec9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004d76:	462c      	mov	r4, r5
 8004d78:	e542      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CPIN, INTERMEDIATE_CMD);
 8004d7a:	2300      	movs	r3, #0
 8004d7c:	9300      	str	r3, [sp, #0]
 8004d7e:	2312      	movs	r3, #18
 8004d80:	2202      	movs	r2, #2
 8004d82:	4641      	mov	r1, r8
 8004d84:	48a6      	ldr	r0, [pc, #664]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d86:	f007 fe63 	bl	800ca50 <atcm_program_AT_CMD>
 8004d8a:	e539      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if (TYPE1SC_ctxt.persist.sim_pin_code_ready == AT_FALSE)
 8004d8c:	4ba4      	ldr	r3, [pc, #656]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d8e:	f893 3510 	ldrb.w	r3, [r3, #1296]	; 0x510
 8004d92:	2b00      	cmp	r3, #0
 8004d94:	d159      	bne.n	8004e4a <ATCustom_TYPE1SC_getCmd+0x712>
        if (strlen((const CRC_CHAR_t *)&TYPE1SC_ctxt.SID_ctxt.modem_init.pincode.pincode) != 0U)
 8004d96:	4ba2      	ldr	r3, [pc, #648]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004d98:	f893 35b3 	ldrb.w	r3, [r3, #1459]	; 0x5b3
 8004d9c:	b383      	cbz	r3, 8004e00 <ATCustom_TYPE1SC_getCmd+0x6c8>
          PRINT_INFO("CPIN required, we send user value to modem")
 8004d9e:	4fa1      	ldr	r7, [pc, #644]	; (8005024 <ATCustom_TYPE1SC_getCmd+0x8ec>)
 8004da0:	4da1      	ldr	r5, [pc, #644]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004da2:	f107 0e30 	add.w	lr, r7, #48	; 0x30
 8004da6:	46bc      	mov	ip, r7
 8004da8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8004dac:	6028      	str	r0, [r5, #0]
 8004dae:	6069      	str	r1, [r5, #4]
 8004db0:	60aa      	str	r2, [r5, #8]
 8004db2:	60eb      	str	r3, [r5, #12]
 8004db4:	4667      	mov	r7, ip
 8004db6:	3510      	adds	r5, #16
 8004db8:	45f4      	cmp	ip, lr
 8004dba:	d1f4      	bne.n	8004da6 <ATCustom_TYPE1SC_getCmd+0x66e>
 8004dbc:	f8dc 0000 	ldr.w	r0, [ip]
 8004dc0:	6028      	str	r0, [r5, #0]
 8004dc2:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8004dc6:	712b      	strb	r3, [r5, #4]
 8004dc8:	4d97      	ldr	r5, [pc, #604]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004dca:	4628      	mov	r0, r5
 8004dcc:	f01a faad 	bl	801f32a <crs_strlen>
 8004dd0:	b283      	uxth	r3, r0
 8004dd2:	462a      	mov	r2, r5
 8004dd4:	2101      	movs	r1, #1
 8004dd6:	2002      	movs	r0, #2
 8004dd8:	f01a faea 	bl	801f3b0 <traceIF_itmPrint>
 8004ddc:	4628      	mov	r0, r5
 8004dde:	f01a faa4 	bl	801f32a <crs_strlen>
 8004de2:	b283      	uxth	r3, r0
 8004de4:	462a      	mov	r2, r5
 8004de6:	2101      	movs	r1, #1
 8004de8:	2002      	movs	r0, #2
 8004dea:	f01a fb03 	bl	801f3f4 <traceIF_uartPrint>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CPIN, FINAL_CMD);
 8004dee:	2301      	movs	r3, #1
 8004df0:	9300      	str	r3, [sp, #0]
 8004df2:	2312      	movs	r3, #18
 8004df4:	2203      	movs	r2, #3
 8004df6:	4641      	mov	r1, r8
 8004df8:	4889      	ldr	r0, [pc, #548]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004dfa:	f007 fe29 	bl	800ca50 <atcm_program_AT_CMD>
 8004dfe:	e4ff      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          PRINT_INFO("CPIN required but not provided by user")
 8004e00:	4d8a      	ldr	r5, [pc, #552]	; (800502c <ATCustom_TYPE1SC_getCmd+0x8f4>)
 8004e02:	4c89      	ldr	r4, [pc, #548]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004e04:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8004e08:	462f      	mov	r7, r5
 8004e0a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004e0c:	6020      	str	r0, [r4, #0]
 8004e0e:	6061      	str	r1, [r4, #4]
 8004e10:	60a2      	str	r2, [r4, #8]
 8004e12:	60e3      	str	r3, [r4, #12]
 8004e14:	463d      	mov	r5, r7
 8004e16:	3410      	adds	r4, #16
 8004e18:	4567      	cmp	r7, ip
 8004e1a:	d1f5      	bne.n	8004e08 <ATCustom_TYPE1SC_getCmd+0x6d0>
 8004e1c:	783b      	ldrb	r3, [r7, #0]
 8004e1e:	7023      	strb	r3, [r4, #0]
 8004e20:	4c81      	ldr	r4, [pc, #516]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004e22:	4620      	mov	r0, r4
 8004e24:	f01a fa81 	bl	801f32a <crs_strlen>
 8004e28:	b283      	uxth	r3, r0
 8004e2a:	4622      	mov	r2, r4
 8004e2c:	2101      	movs	r1, #1
 8004e2e:	2002      	movs	r0, #2
 8004e30:	f01a fabe 	bl	801f3b0 <traceIF_itmPrint>
 8004e34:	4620      	mov	r0, r4
 8004e36:	f01a fa78 	bl	801f32a <crs_strlen>
 8004e3a:	b283      	uxth	r3, r0
 8004e3c:	4622      	mov	r2, r4
 8004e3e:	2101      	movs	r1, #1
 8004e40:	2002      	movs	r0, #2
 8004e42:	f01a fad7 	bl	801f3f4 <traceIF_uartPrint>
          retval = ATSTATUS_ERROR;
 8004e46:	2401      	movs	r4, #1
 8004e48:	e4da      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        PRINT_INFO("CPIN not required")
 8004e4a:	4d77      	ldr	r5, [pc, #476]	; (8005028 <ATCustom_TYPE1SC_getCmd+0x8f0>)
 8004e4c:	4f78      	ldr	r7, [pc, #480]	; (8005030 <ATCustom_TYPE1SC_getCmd+0x8f8>)
 8004e4e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8004e50:	6028      	str	r0, [r5, #0]
 8004e52:	6069      	str	r1, [r5, #4]
 8004e54:	60aa      	str	r2, [r5, #8]
 8004e56:	60eb      	str	r3, [r5, #12]
 8004e58:	cf07      	ldmia	r7!, {r0, r1, r2}
 8004e5a:	6128      	str	r0, [r5, #16]
 8004e5c:	6169      	str	r1, [r5, #20]
 8004e5e:	61aa      	str	r2, [r5, #24]
 8004e60:	4628      	mov	r0, r5
 8004e62:	f01a fa62 	bl	801f32a <crs_strlen>
 8004e66:	b283      	uxth	r3, r0
 8004e68:	462a      	mov	r2, r5
 8004e6a:	2101      	movs	r1, #1
 8004e6c:	2002      	movs	r0, #2
 8004e6e:	f01a fa9f 	bl	801f3b0 <traceIF_itmPrint>
 8004e72:	4628      	mov	r0, r5
 8004e74:	f01a fa59 	bl	801f32a <crs_strlen>
 8004e78:	b283      	uxth	r3, r0
 8004e7a:	462a      	mov	r2, r5
 8004e7c:	2101      	movs	r1, #1
 8004e7e:	2002      	movs	r0, #2
 8004e80:	f01a fab8 	bl	801f3f4 <traceIF_uartPrint>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8004e84:	4640      	mov	r0, r8
 8004e86:	f007 fe3f 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8004e8a:	e4b9      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004e8c:	7cac      	ldrb	r4, [r5, #18]
 8004e8e:	2c00      	cmp	r4, #0
 8004e90:	f040 843b 	bne.w	800570a <ATCustom_TYPE1SC_getCmd+0xfd2>
      switch (TYPE1SC_ctxt.SID_ctxt.device_info->field_requested)
 8004e94:	4b62      	ldr	r3, [pc, #392]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004e96:	f8d3 35c4 	ldr.w	r3, [r3, #1476]	; 0x5c4
 8004e9a:	881b      	ldrh	r3, [r3, #0]
 8004e9c:	2b20      	cmp	r3, #32
 8004e9e:	d829      	bhi.n	8004ef4 <ATCustom_TYPE1SC_getCmd+0x7bc>
 8004ea0:	b21a      	sxth	r2, r3
 8004ea2:	2a00      	cmp	r2, #0
 8004ea4:	f000 8434 	beq.w	8005710 <ATCustom_TYPE1SC_getCmd+0xfd8>
 8004ea8:	3b01      	subs	r3, #1
 8004eaa:	2b1f      	cmp	r3, #31
 8004eac:	f200 8433 	bhi.w	8005716 <ATCustom_TYPE1SC_getCmd+0xfde>
 8004eb0:	e8df f013 	tbh	[pc, r3, lsl #1]
 8004eb4:	002f0056 	.word	0x002f0056
 8004eb8:	00380431 	.word	0x00380431
 8004ebc:	04310431 	.word	0x04310431
 8004ec0:	00410431 	.word	0x00410431
 8004ec4:	04310431 	.word	0x04310431
 8004ec8:	04310431 	.word	0x04310431
 8004ecc:	04310431 	.word	0x04310431
 8004ed0:	004a0431 	.word	0x004a0431
 8004ed4:	04310431 	.word	0x04310431
 8004ed8:	04310431 	.word	0x04310431
 8004edc:	04310431 	.word	0x04310431
 8004ee0:	04310431 	.word	0x04310431
 8004ee4:	04310431 	.word	0x04310431
 8004ee8:	04310431 	.word	0x04310431
 8004eec:	04310431 	.word	0x04310431
 8004ef0:	00610431 	.word	0x00610431
 8004ef4:	2b40      	cmp	r3, #64	; 0x40
 8004ef6:	d047      	beq.n	8004f88 <ATCustom_TYPE1SC_getCmd+0x850>
 8004ef8:	2b80      	cmp	r3, #128	; 0x80
 8004efa:	d108      	bne.n	8004f0e <ATCustom_TYPE1SC_getCmd+0x7d6>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CCID, FINAL_CMD);
 8004efc:	2301      	movs	r3, #1
 8004efe:	9300      	str	r3, [sp, #0]
 8004f00:	2337      	movs	r3, #55	; 0x37
 8004f02:	2204      	movs	r2, #4
 8004f04:	4641      	mov	r1, r8
 8004f06:	4846      	ldr	r0, [pc, #280]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f08:	f007 fda2 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f0c:	e478      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      switch (TYPE1SC_ctxt.SID_ctxt.device_info->field_requested)
 8004f0e:	2401      	movs	r4, #1
 8004f10:	e476      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMI, FINAL_CMD);
 8004f12:	2301      	movs	r3, #1
 8004f14:	9300      	str	r3, [sp, #0]
 8004f16:	230b      	movs	r3, #11
 8004f18:	2204      	movs	r2, #4
 8004f1a:	4641      	mov	r1, r8
 8004f1c:	4840      	ldr	r0, [pc, #256]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f1e:	f007 fd97 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f22:	e46d      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMM, FINAL_CMD);
 8004f24:	2301      	movs	r3, #1
 8004f26:	9300      	str	r3, [sp, #0]
 8004f28:	230c      	movs	r3, #12
 8004f2a:	2204      	movs	r2, #4
 8004f2c:	4641      	mov	r1, r8
 8004f2e:	483c      	ldr	r0, [pc, #240]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f30:	f007 fd8e 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f34:	e464      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGMR, FINAL_CMD);
 8004f36:	2301      	movs	r3, #1
 8004f38:	9300      	str	r3, [sp, #0]
 8004f3a:	230d      	movs	r3, #13
 8004f3c:	2204      	movs	r2, #4
 8004f3e:	4641      	mov	r1, r8
 8004f40:	4837      	ldr	r0, [pc, #220]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f42:	f007 fd85 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f46:	e45b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          TYPE1SC_ctxt.CMD_ctxt.cgsn_write_cmd_param = CGSN_SN;
 8004f48:	4835      	ldr	r0, [pc, #212]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f4a:	2300      	movs	r3, #0
 8004f4c:	f880 372c 	strb.w	r3, [r0, #1836]	; 0x72c
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CGSN, FINAL_CMD);
 8004f50:	2301      	movs	r3, #1
 8004f52:	9300      	str	r3, [sp, #0]
 8004f54:	230e      	movs	r3, #14
 8004f56:	2204      	movs	r2, #4
 8004f58:	4641      	mov	r1, r8
 8004f5a:	f007 fd79 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f5e:	e44f      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          TYPE1SC_ctxt.CMD_ctxt.cgsn_write_cmd_param = CGSN_IMEI;
 8004f60:	482f      	ldr	r0, [pc, #188]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f62:	2301      	movs	r3, #1
 8004f64:	f880 372c 	strb.w	r3, [r0, #1836]	; 0x72c
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGSN, FINAL_CMD);
 8004f68:	9300      	str	r3, [sp, #0]
 8004f6a:	230e      	movs	r3, #14
 8004f6c:	2203      	movs	r2, #3
 8004f6e:	4641      	mov	r1, r8
 8004f70:	f007 fd6e 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f74:	e444      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CIMI, FINAL_CMD);
 8004f76:	2301      	movs	r3, #1
 8004f78:	9300      	str	r3, [sp, #0]
 8004f7a:	230f      	movs	r3, #15
 8004f7c:	2204      	movs	r2, #4
 8004f7e:	4641      	mov	r1, r8
 8004f80:	4827      	ldr	r0, [pc, #156]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f82:	f007 fd65 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f86:	e43b      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
          atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CNUM, FINAL_CMD);
 8004f88:	2301      	movs	r3, #1
 8004f8a:	9300      	str	r3, [sp, #0]
 8004f8c:	2315      	movs	r3, #21
 8004f8e:	2204      	movs	r2, #4
 8004f90:	4641      	mov	r1, r8
 8004f92:	4823      	ldr	r0, [pc, #140]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004f94:	f007 fd5c 	bl	800ca50 <atcm_program_AT_CMD>
          break;
 8004f98:	e432      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004f9a:	7cac      	ldrb	r4, [r5, #18]
 8004f9c:	b10c      	cbz	r4, 8004fa2 <ATCustom_TYPE1SC_getCmd+0x86a>
      retval = ATSTATUS_ERROR;
 8004f9e:	2401      	movs	r4, #1
 8004fa0:	e42e      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_AT_CSQ, FINAL_CMD);
 8004fa2:	2301      	movs	r3, #1
 8004fa4:	9300      	str	r3, [sp, #0]
 8004fa6:	231c      	movs	r3, #28
 8004fa8:	2204      	movs	r2, #4
 8004faa:	4641      	mov	r1, r8
 8004fac:	481c      	ldr	r0, [pc, #112]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004fae:	f007 fd4f 	bl	800ca50 <atcm_program_AT_CMD>
 8004fb2:	e425      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004fb4:	7cac      	ldrb	r4, [r5, #18]
 8004fb6:	b10c      	cbz	r4, 8004fbc <ATCustom_TYPE1SC_getCmd+0x884>
      retval = ATSTATUS_ERROR;
 8004fb8:	2401      	movs	r4, #1
 8004fba:	e421      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CGATT, FINAL_CMD);
 8004fbc:	2301      	movs	r3, #1
 8004fbe:	9300      	str	r3, [sp, #0]
 8004fc0:	2316      	movs	r3, #22
 8004fc2:	2202      	movs	r2, #2
 8004fc4:	4641      	mov	r1, r8
 8004fc6:	4816      	ldr	r0, [pc, #88]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004fc8:	f007 fd42 	bl	800ca50 <atcm_program_AT_CMD>
 8004fcc:	e418      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8004fce:	7cad      	ldrb	r5, [r5, #18]
 8004fd0:	b12d      	cbz	r5, 8004fde <ATCustom_TYPE1SC_getCmd+0x8a6>
    else if (p_atp_ctxt->step == 1U)
 8004fd2:	2d01      	cmp	r5, #1
 8004fd4:	d00d      	beq.n	8004ff2 <ATCustom_TYPE1SC_getCmd+0x8ba>
    else if (p_atp_ctxt->step == 2U)
 8004fd6:	2d02      	cmp	r5, #2
 8004fd8:	d031      	beq.n	800503e <ATCustom_TYPE1SC_getCmd+0x906>
      retval = ATSTATUS_ERROR;
 8004fda:	2401      	movs	r4, #1
 8004fdc:	e410      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_COPS, INTERMEDIATE_CMD);
 8004fde:	2300      	movs	r3, #0
 8004fe0:	9300      	str	r3, [sp, #0]
 8004fe2:	2314      	movs	r3, #20
 8004fe4:	2202      	movs	r2, #2
 8004fe6:	4641      	mov	r1, r8
 8004fe8:	480d      	ldr	r0, [pc, #52]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004fea:	f007 fd31 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8004fee:	462c      	mov	r4, r5
 8004ff0:	e406      	b.n	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if ((TYPE1SC_ctxt.SID_ctxt.read_operator_infos.mode != operatorSelect->mode) ||
 8004ff2:	4b0b      	ldr	r3, [pc, #44]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8004ff4:	f8b3 2610 	ldrh.w	r2, [r3, #1552]	; 0x610
 8004ff8:	f8b3 35c8 	ldrh.w	r3, [r3, #1480]	; 0x5c8
 8004ffc:	429a      	cmp	r2, r3
 8004ffe:	d104      	bne.n	800500a <ATCustom_TYPE1SC_getCmd+0x8d2>
          (operatorSelect->AcT_present == CELLULAR_TRUE))
 8005000:	4b07      	ldr	r3, [pc, #28]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8005002:	f893 360c 	ldrb.w	r3, [r3, #1548]	; 0x60c
      if ((TYPE1SC_ctxt.SID_ctxt.read_operator_infos.mode != operatorSelect->mode) ||
 8005006:	2b01      	cmp	r3, #1
 8005008:	d114      	bne.n	8005034 <ATCustom_TYPE1SC_getCmd+0x8fc>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_COPS, INTERMEDIATE_CMD);
 800500a:	2300      	movs	r3, #0
 800500c:	9300      	str	r3, [sp, #0]
 800500e:	2314      	movs	r3, #20
 8005010:	2203      	movs	r2, #3
 8005012:	4641      	mov	r1, r8
 8005014:	4802      	ldr	r0, [pc, #8]	; (8005020 <ATCustom_TYPE1SC_getCmd+0x8e8>)
 8005016:	f007 fd1b 	bl	800ca50 <atcm_program_AT_CMD>
 800501a:	f7ff bbf1 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 800501e:	bf00      	nop
 8005020:	20001084 	.word	0x20001084
 8005024:	0802c5c4 	.word	0x0802c5c4
 8005028:	200048dc 	.word	0x200048dc
 800502c:	0802c5fc 	.word	0x0802c5fc
 8005030:	0802c630 	.word	0x0802c630
        atcm_program_SKIP_CMD(p_atp_ctxt);
 8005034:	4640      	mov	r0, r8
 8005036:	f007 fd73 	bl	800cb20 <atcm_program_SKIP_CMD>
 800503a:	f7ff bbe1 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CEREG, FINAL_CMD);
 800503e:	2301      	movs	r3, #1
 8005040:	9300      	str	r3, [sp, #0]
 8005042:	2319      	movs	r3, #25
 8005044:	2202      	movs	r2, #2
 8005046:	4641      	mov	r1, r8
 8005048:	48bc      	ldr	r0, [pc, #752]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800504a:	f007 fd01 	bl	800ca50 <atcm_program_AT_CMD>
 800504e:	f7ff bbd7 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005052:	7cad      	ldrb	r5, [r5, #18]
 8005054:	b135      	cbz	r5, 8005064 <ATCustom_TYPE1SC_getCmd+0x92c>
    else if (p_atp_ctxt->step == 1U)
 8005056:	2d01      	cmp	r5, #1
 8005058:	d00f      	beq.n	800507a <ATCustom_TYPE1SC_getCmd+0x942>
    else if (p_atp_ctxt->step == 2U)
 800505a:	2d02      	cmp	r5, #2
 800505c:	d017      	beq.n	800508e <ATCustom_TYPE1SC_getCmd+0x956>
      retval = ATSTATUS_ERROR;
 800505e:	2401      	movs	r4, #1
 8005060:	f7ff bbce 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CEREG, INTERMEDIATE_CMD);
 8005064:	2300      	movs	r3, #0
 8005066:	9300      	str	r3, [sp, #0]
 8005068:	2319      	movs	r3, #25
 800506a:	2202      	movs	r2, #2
 800506c:	4641      	mov	r1, r8
 800506e:	48b3      	ldr	r0, [pc, #716]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005070:	f007 fcee 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005074:	462c      	mov	r4, r5
 8005076:	f7ff bbc3 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CREG, INTERMEDIATE_CMD);
 800507a:	2300      	movs	r3, #0
 800507c:	9300      	str	r3, [sp, #0]
 800507e:	2317      	movs	r3, #23
 8005080:	2202      	movs	r2, #2
 8005082:	4641      	mov	r1, r8
 8005084:	48ad      	ldr	r0, [pc, #692]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005086:	f007 fce3 	bl	800ca50 <atcm_program_AT_CMD>
 800508a:	f7ff bbb9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_COPS, FINAL_CMD);
 800508e:	2301      	movs	r3, #1
 8005090:	9300      	str	r3, [sp, #0]
 8005092:	2314      	movs	r3, #20
 8005094:	2202      	movs	r2, #2
 8005096:	4641      	mov	r1, r8
 8005098:	48a8      	ldr	r0, [pc, #672]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800509a:	f007 fcd9 	bl	800ca50 <atcm_program_AT_CMD>
 800509e:	f7ff bbaf 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80050a2:	7cac      	ldrb	r4, [r5, #18]
 80050a4:	2c00      	cmp	r4, #0
 80050a6:	f040 8339 	bne.w	800571c <ATCustom_TYPE1SC_getCmd+0xfe4>
      CS_UrcEvent_t urcEvent = TYPE1SC_ctxt.SID_ctxt.urcEvent;
 80050aa:	4ba4      	ldr	r3, [pc, #656]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80050ac:	f893 2664 	ldrb.w	r2, [r3, #1636]	; 0x664
      if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO) ||
 80050b0:	1e53      	subs	r3, r2, #1
 80050b2:	b2db      	uxtb	r3, r3
 80050b4:	2b01      	cmp	r3, #1
 80050b6:	d90c      	bls.n	80050d2 <ATCustom_TYPE1SC_getCmd+0x99a>
 80050b8:	2a05      	cmp	r2, #5
 80050ba:	d00a      	beq.n	80050d2 <ATCustom_TYPE1SC_getCmd+0x99a>
          (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 80050bc:	2a06      	cmp	r2, #6
 80050be:	d008      	beq.n	80050d2 <ATCustom_TYPE1SC_getCmd+0x99a>
      else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 80050c0:	1ed3      	subs	r3, r2, #3
 80050c2:	b2db      	uxtb	r3, r3
 80050c4:	2b01      	cmp	r3, #1
 80050c6:	d90a      	bls.n	80050de <ATCustom_TYPE1SC_getCmd+0x9a6>
      else if (urcEvent == CS_URCEVENT_SIGNAL_QUALITY)
 80050c8:	2a07      	cmp	r2, #7
 80050ca:	d10d      	bne.n	80050e8 <ATCustom_TYPE1SC_getCmd+0x9b0>
        retval = ATSTATUS_ERROR;
 80050cc:	2401      	movs	r4, #1
 80050ce:	f7ff bb97 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        (void) atcm_subscribe_net_event(&TYPE1SC_ctxt, p_atp_ctxt);
 80050d2:	4641      	mov	r1, r8
 80050d4:	4899      	ldr	r0, [pc, #612]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80050d6:	f007 ff93 	bl	800d000 <atcm_subscribe_net_event>
 80050da:	f7ff bb91 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80050de:	4640      	mov	r0, r8
 80050e0:	f007 fd12 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80050e4:	f7ff bb8c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80050e8:	4640      	mov	r0, r8
 80050ea:	f007 fd0d 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80050ee:	f7ff bb87 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80050f2:	7cac      	ldrb	r4, [r5, #18]
 80050f4:	2c00      	cmp	r4, #0
 80050f6:	f040 8314 	bne.w	8005722 <ATCustom_TYPE1SC_getCmd+0xfea>
      CS_UrcEvent_t urcEvent = TYPE1SC_ctxt.SID_ctxt.urcEvent;
 80050fa:	4b90      	ldr	r3, [pc, #576]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80050fc:	f893 2664 	ldrb.w	r2, [r3, #1636]	; 0x664
      if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO) ||
 8005100:	1e53      	subs	r3, r2, #1
 8005102:	b2db      	uxtb	r3, r3
 8005104:	2b01      	cmp	r3, #1
 8005106:	d90c      	bls.n	8005122 <ATCustom_TYPE1SC_getCmd+0x9ea>
 8005108:	2a05      	cmp	r2, #5
 800510a:	d00a      	beq.n	8005122 <ATCustom_TYPE1SC_getCmd+0x9ea>
          (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 800510c:	2a06      	cmp	r2, #6
 800510e:	d008      	beq.n	8005122 <ATCustom_TYPE1SC_getCmd+0x9ea>
      else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 8005110:	1ed3      	subs	r3, r2, #3
 8005112:	b2db      	uxtb	r3, r3
 8005114:	2b01      	cmp	r3, #1
 8005116:	d90a      	bls.n	800512e <ATCustom_TYPE1SC_getCmd+0x9f6>
      else if (urcEvent == CS_URCEVENT_SIGNAL_QUALITY)
 8005118:	2a07      	cmp	r2, #7
 800511a:	d10d      	bne.n	8005138 <ATCustom_TYPE1SC_getCmd+0xa00>
        retval = ATSTATUS_ERROR;
 800511c:	2401      	movs	r4, #1
 800511e:	f7ff bb6f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        (void) atcm_unsubscribe_net_event(&TYPE1SC_ctxt, p_atp_ctxt);
 8005122:	4641      	mov	r1, r8
 8005124:	4885      	ldr	r0, [pc, #532]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005126:	f007 ffdb 	bl	800d0e0 <atcm_unsubscribe_net_event>
 800512a:	f7ff bb69 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800512e:	4640      	mov	r0, r8
 8005130:	f007 fcea 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005134:	f7ff bb64 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005138:	4640      	mov	r0, r8
 800513a:	f007 fce5 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800513e:	f7ff bb5f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005142:	7cac      	ldrb	r4, [r5, #18]
 8005144:	2c00      	cmp	r4, #0
 8005146:	f040 82ef 	bne.w	8005728 <ATCustom_TYPE1SC_getCmd+0xff0>
      if (TYPE1SC_ctxt.persist.urc_subscript_pdn_event == CELLULAR_FALSE)
 800514a:	4b7c      	ldr	r3, [pc, #496]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800514c:	7cdd      	ldrb	r5, [r3, #19]
 800514e:	b95d      	cbnz	r5, 8005168 <ATCustom_TYPE1SC_getCmd+0xa30>
        TYPE1SC_ctxt.persist.urc_subscript_pdn_event = CELLULAR_TRUE;
 8005150:	4618      	mov	r0, r3
 8005152:	2301      	movs	r3, #1
 8005154:	74c3      	strb	r3, [r0, #19]
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGEREP, FINAL_CMD);
 8005156:	9300      	str	r3, [sp, #0]
 8005158:	231a      	movs	r3, #26
 800515a:	2203      	movs	r2, #3
 800515c:	4641      	mov	r1, r8
 800515e:	f007 fc77 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005162:	462c      	mov	r4, r5
 8005164:	f7ff bb4c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005168:	4640      	mov	r0, r8
 800516a:	f007 fccd 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800516e:	f7ff bb47 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005172:	7cac      	ldrb	r4, [r5, #18]
 8005174:	2c00      	cmp	r4, #0
 8005176:	f040 82da 	bne.w	800572e <ATCustom_TYPE1SC_getCmd+0xff6>
      if (TYPE1SC_ctxt.persist.urc_subscript_pdn_event == CELLULAR_TRUE)
 800517a:	4b70      	ldr	r3, [pc, #448]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800517c:	7cdb      	ldrb	r3, [r3, #19]
 800517e:	2b01      	cmp	r3, #1
 8005180:	d004      	beq.n	800518c <ATCustom_TYPE1SC_getCmd+0xa54>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005182:	4640      	mov	r0, r8
 8005184:	f007 fcc0 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005188:	f7ff bb3a 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        TYPE1SC_ctxt.persist.urc_subscript_pdn_event = CELLULAR_FALSE;
 800518c:	486b      	ldr	r0, [pc, #428]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800518e:	2300      	movs	r3, #0
 8005190:	74c3      	strb	r3, [r0, #19]
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGEREP, FINAL_CMD);
 8005192:	2301      	movs	r3, #1
 8005194:	9300      	str	r3, [sp, #0]
 8005196:	231a      	movs	r3, #26
 8005198:	2203      	movs	r2, #3
 800519a:	4641      	mov	r1, r8
 800519c:	f007 fc58 	bl	800ca50 <atcm_program_AT_CMD>
 80051a0:	f7ff bb2e 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80051a4:	7cac      	ldrb	r4, [r5, #18]
 80051a6:	b114      	cbz	r4, 80051ae <ATCustom_TYPE1SC_getCmd+0xa76>
      retval = ATSTATUS_ERROR;
 80051a8:	2401      	movs	r4, #1
 80051aa:	f7ff bb29 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.cgatt_write_cmd_param = CGATT_ATTACHED;
 80051ae:	4863      	ldr	r0, [pc, #396]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80051b0:	2301      	movs	r3, #1
 80051b2:	f880 372d 	strb.w	r3, [r0, #1837]	; 0x72d
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGATT, FINAL_CMD);
 80051b6:	9300      	str	r3, [sp, #0]
 80051b8:	2316      	movs	r3, #22
 80051ba:	2203      	movs	r2, #3
 80051bc:	4641      	mov	r1, r8
 80051be:	f007 fc47 	bl	800ca50 <atcm_program_AT_CMD>
 80051c2:	f7ff bb1d 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80051c6:	7cac      	ldrb	r4, [r5, #18]
 80051c8:	b114      	cbz	r4, 80051d0 <ATCustom_TYPE1SC_getCmd+0xa98>
      retval = ATSTATUS_ERROR;
 80051ca:	2401      	movs	r4, #1
 80051cc:	f7ff bb18 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.cgatt_write_cmd_param = CGATT_DETACHED;
 80051d0:	485a      	ldr	r0, [pc, #360]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80051d2:	2300      	movs	r3, #0
 80051d4:	f880 372d 	strb.w	r3, [r0, #1837]	; 0x72d
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGATT, FINAL_CMD);
 80051d8:	2301      	movs	r3, #1
 80051da:	9300      	str	r3, [sp, #0]
 80051dc:	2316      	movs	r3, #22
 80051de:	2203      	movs	r2, #3
 80051e0:	4641      	mov	r1, r8
 80051e2:	f007 fc35 	bl	800ca50 <atcm_program_AT_CMD>
 80051e6:	f7ff bb0b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80051ea:	7cac      	ldrb	r4, [r5, #18]
 80051ec:	b114      	cbz	r4, 80051f4 <ATCustom_TYPE1SC_getCmd+0xabc>
      retval = ATSTATUS_ERROR;
 80051ee:	2401      	movs	r4, #1
 80051f0:	f7ff bb06 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.pdn_state = PDN_STATE_ACTIVATE;
 80051f4:	4851      	ldr	r0, [pc, #324]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80051f6:	2301      	movs	r3, #1
 80051f8:	f880 3731 	strb.w	r3, [r0, #1841]	; 0x731
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PDNACT, FINAL_CMD);
 80051fc:	9300      	str	r3, [sp, #0]
 80051fe:	2341      	movs	r3, #65	; 0x41
 8005200:	2203      	movs	r2, #3
 8005202:	4641      	mov	r1, r8
 8005204:	f007 fc24 	bl	800ca50 <atcm_program_AT_CMD>
 8005208:	f7ff bafa 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800520c:	7cac      	ldrb	r4, [r5, #18]
 800520e:	b114      	cbz	r4, 8005216 <ATCustom_TYPE1SC_getCmd+0xade>
      retval = ATSTATUS_ERROR;
 8005210:	2401      	movs	r4, #1
 8005212:	f7ff baf5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      TYPE1SC_ctxt.CMD_ctxt.pdn_state = PDN_STATE_DEACTIVATE;
 8005216:	4849      	ldr	r0, [pc, #292]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005218:	2300      	movs	r3, #0
 800521a:	f880 3731 	strb.w	r3, [r0, #1841]	; 0x731
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PDNACT, FINAL_CMD);
 800521e:	2301      	movs	r3, #1
 8005220:	9300      	str	r3, [sp, #0]
 8005222:	2341      	movs	r3, #65	; 0x41
 8005224:	2203      	movs	r2, #3
 8005226:	4641      	mov	r1, r8
 8005228:	f007 fc12 	bl	800ca50 <atcm_program_AT_CMD>
 800522c:	f7ff bae8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005230:	7cad      	ldrb	r5, [r5, #18]
 8005232:	b135      	cbz	r5, 8005242 <ATCustom_TYPE1SC_getCmd+0xb0a>
    else if (p_atp_ctxt->step == 1U)
 8005234:	2d01      	cmp	r5, #1
 8005236:	d00f      	beq.n	8005258 <ATCustom_TYPE1SC_getCmd+0xb20>
    else if (p_atp_ctxt->step == 2U)
 8005238:	2d02      	cmp	r5, #2
 800523a:	d015      	beq.n	8005268 <ATCustom_TYPE1SC_getCmd+0xb30>
      retval = ATSTATUS_ERROR;
 800523c:	2401      	movs	r4, #1
 800523e:	f7ff badf 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PDNSET, INTERMEDIATE_CMD);
 8005242:	2300      	movs	r3, #0
 8005244:	9300      	str	r3, [sp, #0]
 8005246:	2336      	movs	r3, #54	; 0x36
 8005248:	2203      	movs	r2, #3
 800524a:	4641      	mov	r1, r8
 800524c:	483b      	ldr	r0, [pc, #236]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800524e:	f007 fbff 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005252:	462c      	mov	r4, r5
 8005254:	f7ff bad4 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_TEMPO(p_atp_ctxt, 2000U, INTERMEDIATE_CMD);
 8005258:	2200      	movs	r2, #0
 800525a:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 800525e:	4640      	mov	r0, r8
 8005260:	f007 fc26 	bl	800cab0 <atcm_program_TEMPO>
 8005264:	f7ff bacc 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_PDNSET, FINAL_CMD);
 8005268:	2301      	movs	r3, #1
 800526a:	9300      	str	r3, [sp, #0]
 800526c:	2336      	movs	r3, #54	; 0x36
 800526e:	2202      	movs	r2, #2
 8005270:	4641      	mov	r1, r8
 8005272:	4832      	ldr	r0, [pc, #200]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005274:	f007 fbec 	bl	800ca50 <atcm_program_AT_CMD>
 8005278:	f7ff bac2 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800527c:	4640      	mov	r0, r8
 800527e:	f007 fc43 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005282:	f7ff babd 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005286:	7cac      	ldrb	r4, [r5, #18]
 8005288:	b114      	cbz	r4, 8005290 <ATCustom_TYPE1SC_getCmd+0xb58>
      retval = ATSTATUS_ERROR;
 800528a:	2401      	movs	r4, #1
 800528c:	f7ff bab8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGPADDR, FINAL_CMD);
 8005290:	2301      	movs	r3, #1
 8005292:	9300      	str	r3, [sp, #0]
 8005294:	2321      	movs	r3, #33	; 0x21
 8005296:	2203      	movs	r2, #3
 8005298:	4641      	mov	r1, r8
 800529a:	4828      	ldr	r0, [pc, #160]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 800529c:	f007 fbd8 	bl	800ca50 <atcm_program_AT_CMD>
 80052a0:	f7ff baae 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80052a4:	7cad      	ldrb	r5, [r5, #18]
 80052a6:	b135      	cbz	r5, 80052b6 <ATCustom_TYPE1SC_getCmd+0xb7e>
    else if (p_atp_ctxt->step == 1U)
 80052a8:	2d01      	cmp	r5, #1
 80052aa:	d012      	beq.n	80052d2 <ATCustom_TYPE1SC_getCmd+0xb9a>
    else if (p_atp_ctxt->step == 2U)
 80052ac:	2d02      	cmp	r5, #2
 80052ae:	d039      	beq.n	8005324 <ATCustom_TYPE1SC_getCmd+0xbec>
      retval = ATSTATUS_ERROR;
 80052b0:	2401      	movs	r4, #1
 80052b2:	f7ff baa5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      type1sc_shared.SocketCmd_Allocated_SocketID = AT_FALSE;
 80052b6:	2300      	movs	r3, #0
 80052b8:	4a21      	ldr	r2, [pc, #132]	; (8005340 <ATCustom_TYPE1SC_getCmd+0xc08>)
 80052ba:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_ALLOCATE,
 80052be:	9300      	str	r3, [sp, #0]
 80052c0:	2342      	movs	r3, #66	; 0x42
 80052c2:	2203      	movs	r2, #3
 80052c4:	4641      	mov	r1, r8
 80052c6:	481d      	ldr	r0, [pc, #116]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80052c8:	f007 fbc2 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 80052cc:	462c      	mov	r4, r5
 80052ce:	f7ff ba97 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      if (type1sc_shared.SocketCmd_Allocated_SocketID == AT_TRUE)
 80052d2:	4b1b      	ldr	r3, [pc, #108]	; (8005340 <ATCustom_TYPE1SC_getCmd+0xc08>)
 80052d4:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80052d8:	b14b      	cbz	r3, 80052ee <ATCustom_TYPE1SC_getCmd+0xbb6>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_ACTIVATE,
 80052da:	2300      	movs	r3, #0
 80052dc:	9300      	str	r3, [sp, #0]
 80052de:	2343      	movs	r3, #67	; 0x43
 80052e0:	2203      	movs	r2, #3
 80052e2:	4641      	mov	r1, r8
 80052e4:	4815      	ldr	r0, [pc, #84]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 80052e6:	f007 fbb3 	bl	800ca50 <atcm_program_AT_CMD>
 80052ea:	f7ff ba89 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        PRINT_ERR("No valid socket_id affected by the modem has been reecived")
 80052ee:	4c15      	ldr	r4, [pc, #84]	; (8005344 <ATCustom_TYPE1SC_getCmd+0xc0c>)
 80052f0:	224b      	movs	r2, #75	; 0x4b
 80052f2:	4915      	ldr	r1, [pc, #84]	; (8005348 <ATCustom_TYPE1SC_getCmd+0xc10>)
 80052f4:	4620      	mov	r0, r4
 80052f6:	f021 fbf7 	bl	8026ae8 <memcpy>
 80052fa:	4620      	mov	r0, r4
 80052fc:	f01a f815 	bl	801f32a <crs_strlen>
 8005300:	b283      	uxth	r3, r0
 8005302:	4622      	mov	r2, r4
 8005304:	2110      	movs	r1, #16
 8005306:	2002      	movs	r0, #2
 8005308:	f01a f852 	bl	801f3b0 <traceIF_itmPrint>
 800530c:	4620      	mov	r0, r4
 800530e:	f01a f80c 	bl	801f32a <crs_strlen>
 8005312:	b283      	uxth	r3, r0
 8005314:	4622      	mov	r2, r4
 8005316:	2110      	movs	r1, #16
 8005318:	2002      	movs	r0, #2
 800531a:	f01a f86b 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800531e:	462c      	mov	r4, r5
 8005320:	f7ff ba6e 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      (void) atcm_socket_set_connected(&TYPE1SC_ctxt, TYPE1SC_ctxt.socket_ctxt.socket_info->socket_handle);
 8005324:	4805      	ldr	r0, [pc, #20]	; (800533c <ATCustom_TYPE1SC_getCmd+0xc04>)
 8005326:	f8d0 3740 	ldr.w	r3, [r0, #1856]	; 0x740
 800532a:	6819      	ldr	r1, [r3, #0]
 800532c:	f00f f900 	bl	8014530 <atcm_socket_set_connected>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005330:	4640      	mov	r0, r8
 8005332:	f007 fbe9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005336:	f7ff ba63 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 800533a:	bf00      	nop
 800533c:	20001084 	.word	0x20001084
 8005340:	20001838 	.word	0x20001838
 8005344:	200048dc 	.word	0x200048dc
 8005348:	0802c64c 	.word	0x0802c64c
    if (p_atp_ctxt->step == 0U)
 800534c:	7cac      	ldrb	r4, [r5, #18]
 800534e:	2c00      	cmp	r4, #0
 8005350:	f040 81f0 	bne.w	8005734 <ATCustom_TYPE1SC_getCmd+0xffc>
      if (TYPE1SC_ctxt.SID_ctxt.socketSendData_struct.buffer_size > MODEM_MAX_SOCKET_TX_DATA_SIZE)
 8005354:	4bbb      	ldr	r3, [pc, #748]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005356:	f8d3 267c 	ldr.w	r2, [r3, #1660]	; 0x67c
 800535a:	f240 23c6 	movw	r3, #710	; 0x2c6
 800535e:	429a      	cmp	r2, r3
 8005360:	d91c      	bls.n	800539c <ATCustom_TYPE1SC_getCmd+0xc64>
        PRINT_ERR("Data size to send %ld exceed maximum size %ld",
 8005362:	4cb9      	ldr	r4, [pc, #740]	; (8005648 <ATCustom_TYPE1SC_getCmd+0xf10>)
 8005364:	49b9      	ldr	r1, [pc, #740]	; (800564c <ATCustom_TYPE1SC_getCmd+0xf14>)
 8005366:	4620      	mov	r0, r4
 8005368:	f021 fa6e 	bl	8026848 <sprintf>
 800536c:	4620      	mov	r0, r4
 800536e:	f019 ffdc 	bl	801f32a <crs_strlen>
 8005372:	b283      	uxth	r3, r0
 8005374:	4622      	mov	r2, r4
 8005376:	2110      	movs	r1, #16
 8005378:	2002      	movs	r0, #2
 800537a:	f01a f819 	bl	801f3b0 <traceIF_itmPrint>
 800537e:	4620      	mov	r0, r4
 8005380:	f019 ffd3 	bl	801f32a <crs_strlen>
 8005384:	b283      	uxth	r3, r0
 8005386:	4622      	mov	r2, r4
 8005388:	2110      	movs	r1, #16
 800538a:	2002      	movs	r0, #2
 800538c:	f01a f832 	bl	801f3f4 <traceIF_uartPrint>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005390:	4640      	mov	r0, r8
 8005392:	f007 fbb9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
        retval = ATSTATUS_ERROR;
 8005396:	2401      	movs	r4, #1
 8005398:	f7ff ba32 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETDATA_SEND, FINAL_CMD);
 800539c:	2301      	movs	r3, #1
 800539e:	9300      	str	r3, [sp, #0]
 80053a0:	234b      	movs	r3, #75	; 0x4b
 80053a2:	2203      	movs	r2, #3
 80053a4:	4641      	mov	r1, r8
 80053a6:	48a7      	ldr	r0, [pc, #668]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053a8:	f007 fb52 	bl	800ca50 <atcm_program_AT_CMD>
 80053ac:	f7ff ba28 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80053b0:	7cac      	ldrb	r4, [r5, #18]
 80053b2:	b114      	cbz	r4, 80053ba <ATCustom_TYPE1SC_getCmd+0xc82>
      retval = ATSTATUS_ERROR;
 80053b4:	2401      	movs	r4, #1
 80053b6:	f7ff ba23 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETDATA_RECEIVE, FINAL_CMD);
 80053ba:	2301      	movs	r3, #1
 80053bc:	9300      	str	r3, [sp, #0]
 80053be:	234c      	movs	r3, #76	; 0x4c
 80053c0:	2203      	movs	r2, #3
 80053c2:	4641      	mov	r1, r8
 80053c4:	489f      	ldr	r0, [pc, #636]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053c6:	f007 fb43 	bl	800ca50 <atcm_program_AT_CMD>
 80053ca:	f7ff ba19 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80053ce:	7cad      	ldrb	r5, [r5, #18]
 80053d0:	b125      	cbz	r5, 80053dc <ATCustom_TYPE1SC_getCmd+0xca4>
    else if (p_atp_ctxt->step == 1U)
 80053d2:	2d01      	cmp	r5, #1
 80053d4:	d00d      	beq.n	80053f2 <ATCustom_TYPE1SC_getCmd+0xcba>
      retval = ATSTATUS_ERROR;
 80053d6:	2401      	movs	r4, #1
 80053d8:	f7ff ba12 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_DEACTIVATE,
 80053dc:	2300      	movs	r3, #0
 80053de:	9300      	str	r3, [sp, #0]
 80053e0:	2345      	movs	r3, #69	; 0x45
 80053e2:	2203      	movs	r2, #3
 80053e4:	4641      	mov	r1, r8
 80053e6:	4897      	ldr	r0, [pc, #604]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053e8:	f007 fb32 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 80053ec:	462c      	mov	r4, r5
 80053ee:	f7ff ba07 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_DELETE, FINAL_CMD);
 80053f2:	2301      	movs	r3, #1
 80053f4:	9300      	str	r3, [sp, #0]
 80053f6:	2347      	movs	r3, #71	; 0x47
 80053f8:	2203      	movs	r2, #3
 80053fa:	4641      	mov	r1, r8
 80053fc:	4891      	ldr	r0, [pc, #580]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80053fe:	f007 fb27 	bl	800ca50 <atcm_program_AT_CMD>
 8005402:	f7ff b9fd 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005406:	7cac      	ldrb	r4, [r5, #18]
 8005408:	b114      	cbz	r4, 8005410 <ATCustom_TYPE1SC_getCmd+0xcd8>
      retval = ATSTATUS_ERROR;
 800540a:	2401      	movs	r4, #1
 800540c:	f7ff b9f8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SOCKETCMD_INFO, FINAL_CMD);
 8005410:	2301      	movs	r3, #1
 8005412:	9300      	str	r3, [sp, #0]
 8005414:	2344      	movs	r3, #68	; 0x44
 8005416:	2203      	movs	r2, #3
 8005418:	4641      	mov	r1, r8
 800541a:	488a      	ldr	r0, [pc, #552]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 800541c:	f007 fb18 	bl	800ca50 <atcm_program_AT_CMD>
 8005420:	f7ff b9ee 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005424:	7cad      	ldrb	r5, [r5, #18]
 8005426:	b135      	cbz	r5, 8005436 <ATCustom_TYPE1SC_getCmd+0xcfe>
    else if (p_atp_ctxt->step == 1U)
 8005428:	2d01      	cmp	r5, #1
 800542a:	d00d      	beq.n	8005448 <ATCustom_TYPE1SC_getCmd+0xd10>
    else if (p_atp_ctxt->step == 2U)
 800542c:	2d02      	cmp	r5, #2
 800542e:	d017      	beq.n	8005460 <ATCustom_TYPE1SC_getCmd+0xd28>
      retval = ATSTATUS_ERROR;
 8005430:	2401      	movs	r4, #1
 8005432:	f7ff b9e5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_TEMPO(p_atp_ctxt, 1000U, INTERMEDIATE_CMD);
 8005436:	2200      	movs	r2, #0
 8005438:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800543c:	4640      	mov	r0, r8
 800543e:	f007 fb37 	bl	800cab0 <atcm_program_TEMPO>
  at_status_t retval = ATSTATUS_OK;
 8005442:	462c      	mov	r4, r5
 8005444:	f7ff b9dc 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_RAW_CMD, (CMD_ID_t) CMD_AT_ESC_CMD, INTERMEDIATE_CMD);
 8005448:	2300      	movs	r3, #0
 800544a:	9300      	str	r3, [sp, #0]
 800544c:	2333      	movs	r3, #51	; 0x33
 800544e:	2206      	movs	r2, #6
 8005450:	4641      	mov	r1, r8
 8005452:	487c      	ldr	r0, [pc, #496]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005454:	f007 fafc 	bl	800ca50 <atcm_program_AT_CMD>
      reinitSyntaxAutomaton_TYPE1SC();
 8005458:	f7ff f84c 	bl	80044f4 <reinitSyntaxAutomaton_TYPE1SC>
 800545c:	f7ff b9d0 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_TEMPO(p_atp_ctxt, 2000U, FINAL_CMD);
 8005460:	2201      	movs	r2, #1
 8005462:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 8005466:	4640      	mov	r0, r8
 8005468:	f007 fb22 	bl	800cab0 <atcm_program_TEMPO>
 800546c:	f7ff b9c8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005470:	7cac      	ldrb	r4, [r5, #18]
 8005472:	b114      	cbz	r4, 800547a <ATCustom_TYPE1SC_getCmd+0xd42>
      retval = ATSTATUS_ERROR;
 8005474:	2401      	movs	r4, #1
 8005476:	f7ff b9c3 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_EXECUTION_CMD, (CMD_ID_t) CMD_ATO, FINAL_CMD);
 800547a:	2301      	movs	r3, #1
 800547c:	9300      	str	r3, [sp, #0]
 800547e:	232a      	movs	r3, #42	; 0x2a
 8005480:	2204      	movs	r2, #4
 8005482:	4641      	mov	r1, r8
 8005484:	486f      	ldr	r0, [pc, #444]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005486:	f007 fae3 	bl	800ca50 <atcm_program_AT_CMD>
 800548a:	f7ff b9b9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800548e:	7cad      	ldrb	r5, [r5, #18]
 8005490:	b145      	cbz	r5, 80054a4 <ATCustom_TYPE1SC_getCmd+0xd6c>
    else if (p_atp_ctxt->step == 1U)
 8005492:	3d01      	subs	r5, #1
 8005494:	2d04      	cmp	r5, #4
 8005496:	f200 8150 	bhi.w	800573a <ATCustom_TYPE1SC_getCmd+0x1002>
 800549a:	e8df f005 	tbb	[pc, r5]
 800549e:	1c12      	.short	0x1c12
 80054a0:	3026      	.short	0x3026
 80054a2:	3a          	.byte	0x3a
 80054a3:	00          	.byte	0x00
      if (init_type1sc_low_power() == AT_FALSE)
 80054a4:	f7ff f83a 	bl	800451c <init_type1sc_low_power>
 80054a8:	b928      	cbnz	r0, 80054b6 <ATCustom_TYPE1SC_getCmd+0xd7e>
        atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80054aa:	4640      	mov	r0, r8
 80054ac:	f007 fb2c 	bl	800cb08 <atcm_program_NO_MORE_CMD>
  at_status_t retval = ATSTATUS_OK;
 80054b0:	462c      	mov	r4, r5
 80054b2:	f7ff b9a5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
        atcm_program_SKIP_CMD(p_atp_ctxt);
 80054b6:	4640      	mov	r0, r8
 80054b8:	f007 fb32 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 80054bc:	462c      	mov	r4, r5
 80054be:	f7ff b99f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CEDRXS, INTERMEDIATE_CMD);
 80054c2:	2300      	movs	r3, #0
 80054c4:	9300      	str	r3, [sp, #0]
 80054c6:	2323      	movs	r3, #35	; 0x23
 80054c8:	2202      	movs	r2, #2
 80054ca:	4641      	mov	r1, r8
 80054cc:	485d      	ldr	r0, [pc, #372]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80054ce:	f007 fabf 	bl	800ca50 <atcm_program_AT_CMD>
 80054d2:	f7ff b995 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_READ_CMD, (CMD_ID_t) CMD_AT_CPSMS, INTERMEDIATE_CMD);
 80054d6:	2300      	movs	r3, #0
 80054d8:	9300      	str	r3, [sp, #0]
 80054da:	2322      	movs	r3, #34	; 0x22
 80054dc:	2202      	movs	r2, #2
 80054de:	4641      	mov	r1, r8
 80054e0:	4858      	ldr	r0, [pc, #352]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80054e2:	f007 fab5 	bl	800ca50 <atcm_program_AT_CMD>
 80054e6:	f7ff b98b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEDRXS, INTERMEDIATE_CMD);
 80054ea:	2300      	movs	r3, #0
 80054ec:	9300      	str	r3, [sp, #0]
 80054ee:	2323      	movs	r3, #35	; 0x23
 80054f0:	2203      	movs	r2, #3
 80054f2:	4641      	mov	r1, r8
 80054f4:	4853      	ldr	r0, [pc, #332]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80054f6:	f007 faab 	bl	800ca50 <atcm_program_AT_CMD>
 80054fa:	f7ff b981 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CPSMS, INTERMEDIATE_CMD);
 80054fe:	2300      	movs	r3, #0
 8005500:	9300      	str	r3, [sp, #0]
 8005502:	2322      	movs	r3, #34	; 0x22
 8005504:	2203      	movs	r2, #3
 8005506:	4641      	mov	r1, r8
 8005508:	484e      	ldr	r0, [pc, #312]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 800550a:	f007 faa1 	bl	800ca50 <atcm_program_AT_CMD>
 800550e:	f7ff b977 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005512:	4640      	mov	r0, r8
 8005514:	f007 faf8 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005518:	f7ff b972 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800551c:	7cad      	ldrb	r5, [r5, #18]
 800551e:	b145      	cbz	r5, 8005532 <ATCustom_TYPE1SC_getCmd+0xdfa>
    else if (p_atp_ctxt->step == 1U)
 8005520:	2d01      	cmp	r5, #1
 8005522:	d011      	beq.n	8005548 <ATCustom_TYPE1SC_getCmd+0xe10>
    else if (p_atp_ctxt->step == 2U)
 8005524:	2d02      	cmp	r5, #2
 8005526:	d019      	beq.n	800555c <ATCustom_TYPE1SC_getCmd+0xe24>
    else if (p_atp_ctxt->step == 3U)
 8005528:	2d03      	cmp	r5, #3
 800552a:	d021      	beq.n	8005570 <ATCustom_TYPE1SC_getCmd+0xe38>
      retval = ATSTATUS_ERROR;
 800552c:	2401      	movs	r4, #1
 800552e:	f7ff b967 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEDRXS, INTERMEDIATE_CMD);
 8005532:	2300      	movs	r3, #0
 8005534:	9300      	str	r3, [sp, #0]
 8005536:	2323      	movs	r3, #35	; 0x23
 8005538:	2203      	movs	r2, #3
 800553a:	4641      	mov	r1, r8
 800553c:	4841      	ldr	r0, [pc, #260]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 800553e:	f007 fa87 	bl	800ca50 <atcm_program_AT_CMD>
  at_status_t retval = ATSTATUS_OK;
 8005542:	462c      	mov	r4, r5
 8005544:	f7ff b95c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CPSMS, INTERMEDIATE_CMD);
 8005548:	2300      	movs	r3, #0
 800554a:	9300      	str	r3, [sp, #0]
 800554c:	2322      	movs	r3, #34	; 0x22
 800554e:	2203      	movs	r2, #3
 8005550:	4641      	mov	r1, r8
 8005552:	483c      	ldr	r0, [pc, #240]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005554:	f007 fa7c 	bl	800ca50 <atcm_program_AT_CMD>
 8005558:	f7ff b952 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt,
 800555c:	2300      	movs	r3, #0
 800555e:	9300      	str	r3, [sp, #0]
 8005560:	2325      	movs	r3, #37	; 0x25
 8005562:	2204      	movs	r2, #4
 8005564:	4641      	mov	r1, r8
 8005566:	4837      	ldr	r0, [pc, #220]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005568:	f007 fa72 	bl	800ca50 <atcm_program_AT_CMD>
 800556c:	f7ff b948 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005570:	4640      	mov	r0, r8
 8005572:	f007 fac9 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005576:	f7ff b943 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800557a:	7caf      	ldrb	r7, [r5, #18]
 800557c:	b127      	cbz	r7, 8005588 <ATCustom_TYPE1SC_getCmd+0xe50>
    else if (p_atp_ctxt->step == 1U)
 800557e:	2f01      	cmp	r7, #1
 8005580:	d00e      	beq.n	80055a0 <ATCustom_TYPE1SC_getCmd+0xe68>
      retval = ATSTATUS_ERROR;
 8005582:	2401      	movs	r4, #1
 8005584:	f7ff b93c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      low_power_state_requested();
 8005588:	f7fe ffea 	bl	8004560 <low_power_state_requested>
      (void) SysCtrl_TYPE1SC_request_suspend_channel(p_at_ctxt->ipc_handle, DEVTYPE_MODEM_CELLULAR);
 800558c:	2100      	movs	r1, #0
 800558e:	6868      	ldr	r0, [r5, #4]
 8005590:	f001 f8e8 	bl	8006764 <SysCtrl_TYPE1SC_request_suspend_channel>
      atcm_program_SKIP_CMD(p_atp_ctxt);
 8005594:	4640      	mov	r0, r8
 8005596:	f007 fac3 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 800559a:	463c      	mov	r4, r7
 800559c:	f7ff b930 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80055a0:	4640      	mov	r0, r8
 80055a2:	f007 fab1 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80055a6:	f7ff b92b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80055aa:	7cac      	ldrb	r4, [r5, #18]
 80055ac:	b114      	cbz	r4, 80055b4 <ATCustom_TYPE1SC_getCmd+0xe7c>
      retval = ATSTATUS_ERROR;
 80055ae:	2401      	movs	r4, #1
 80055b0:	f7ff b926 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      (void) SysCtrl_TYPE1SC_complete_suspend_channel(p_at_ctxt->ipc_handle, DEVTYPE_MODEM_CELLULAR);
 80055b4:	2100      	movs	r1, #0
 80055b6:	6868      	ldr	r0, [r5, #4]
 80055b8:	f001 f924 	bl	8006804 <SysCtrl_TYPE1SC_complete_suspend_channel>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80055bc:	4640      	mov	r0, r8
 80055be:	f007 faa3 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80055c2:	f7ff b91d 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80055c6:	7cac      	ldrb	r4, [r5, #18]
 80055c8:	b114      	cbz	r4, 80055d0 <ATCustom_TYPE1SC_getCmd+0xe98>
      retval = ATSTATUS_ERROR;
 80055ca:	2401      	movs	r4, #1
 80055cc:	f7ff b918 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      low_power_state_cancel();
 80055d0:	f7fe ffd8 	bl	8004584 <low_power_state_cancel>
      (void) SysCtrl_TYPE1SC_resume_channel(p_at_ctxt->ipc_handle,
 80055d4:	2200      	movs	r2, #0
 80055d6:	4611      	mov	r1, r2
 80055d8:	6868      	ldr	r0, [r5, #4]
 80055da:	f001 fb97 	bl	8006d0c <SysCtrl_TYPE1SC_resume_channel>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 80055de:	4640      	mov	r0, r8
 80055e0:	f007 fa92 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 80055e4:	f7ff b90c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80055e8:	7cac      	ldrb	r4, [r5, #18]
 80055ea:	2c00      	cmp	r4, #0
 80055ec:	f040 80a8 	bne.w	8005740 <ATCustom_TYPE1SC_getCmd+0x1008>
      uint8_t modem_originated = (TYPE1SC_ctxt.SID_ctxt.wakeup_origin == MODEM_WAKEUP) ? 1U : 0U;
 80055f0:	4b14      	ldr	r3, [pc, #80]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 80055f2:	f893 3729 	ldrb.w	r3, [r3, #1833]	; 0x729
 80055f6:	2b02      	cmp	r3, #2
 80055f8:	d009      	beq.n	800560e <ATCustom_TYPE1SC_getCmd+0xed6>
 80055fa:	4622      	mov	r2, r4
      (void) SysCtrl_TYPE1SC_resume_channel(p_at_ctxt->ipc_handle,
 80055fc:	2100      	movs	r1, #0
 80055fe:	6868      	ldr	r0, [r5, #4]
 8005600:	f001 fb84 	bl	8006d0c <SysCtrl_TYPE1SC_resume_channel>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005604:	4640      	mov	r0, r8
 8005606:	f007 fa7f 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800560a:	f7ff b8f9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      uint8_t modem_originated = (TYPE1SC_ctxt.SID_ctxt.wakeup_origin == MODEM_WAKEUP) ? 1U : 0U;
 800560e:	2201      	movs	r2, #1
 8005610:	e7f4      	b.n	80055fc <ATCustom_TYPE1SC_getCmd+0xec4>
    if (p_atp_ctxt->step == 0U)
 8005612:	7cac      	ldrb	r4, [r5, #18]
 8005614:	b114      	cbz	r4, 800561c <ATCustom_TYPE1SC_getCmd+0xee4>
      retval = ATSTATUS_ERROR;
 8005616:	2401      	movs	r4, #1
 8005618:	f7ff b8f2 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_DNSRSLV, FINAL_CMD);
 800561c:	2301      	movs	r3, #1
 800561e:	9300      	str	r3, [sp, #0]
 8005620:	233f      	movs	r3, #63	; 0x3f
 8005622:	2203      	movs	r2, #3
 8005624:	4641      	mov	r1, r8
 8005626:	4807      	ldr	r0, [pc, #28]	; (8005644 <ATCustom_TYPE1SC_getCmd+0xf0c>)
 8005628:	f007 fa12 	bl	800ca50 <atcm_program_AT_CMD>
 800562c:	f7ff b8e8 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    atcm_program_NO_MORE_CMD(p_atp_ctxt);
 8005630:	4640      	mov	r0, r8
 8005632:	f007 fa69 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 8005636:	f7ff b8e3 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800563a:	7cac      	ldrb	r4, [r5, #18]
 800563c:	b144      	cbz	r4, 8005650 <ATCustom_TYPE1SC_getCmd+0xf18>
      retval = ATSTATUS_ERROR;
 800563e:	2401      	movs	r4, #1
 8005640:	f7ff b8de 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8005644:	20001084 	.word	0x20001084
 8005648:	200048dc 	.word	0x200048dc
 800564c:	0802c698 	.word	0x0802c698
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_PINGCMD, FINAL_CMD);
 8005650:	2301      	movs	r3, #1
 8005652:	9300      	str	r3, [sp, #0]
 8005654:	2340      	movs	r3, #64	; 0x40
 8005656:	2203      	movs	r2, #3
 8005658:	4641      	mov	r1, r8
 800565a:	483b      	ldr	r0, [pc, #236]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 800565c:	f007 f9f8 	bl	800ca50 <atcm_program_AT_CMD>
 8005660:	f7ff b8ce 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005664:	7cac      	ldrb	r4, [r5, #18]
 8005666:	b114      	cbz	r4, 800566e <ATCustom_TYPE1SC_getCmd+0xf36>
      retval = ATSTATUS_ERROR;
 8005668:	2401      	movs	r4, #1
 800566a:	f7ff b8c9 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_RAW_CMD, (CMD_ID_t) CMD_AT_DIRECT_CMD, FINAL_CMD);
 800566e:	4d36      	ldr	r5, [pc, #216]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 8005670:	2301      	movs	r3, #1
 8005672:	9300      	str	r3, [sp, #0]
 8005674:	2334      	movs	r3, #52	; 0x34
 8005676:	2206      	movs	r2, #6
 8005678:	4641      	mov	r1, r8
 800567a:	4628      	mov	r0, r5
 800567c:	f007 f9e8 	bl	800ca50 <atcm_program_AT_CMD>
      atcm_program_CMD_TIMEOUT(&TYPE1SC_ctxt, p_atp_ctxt, TYPE1SC_ctxt.SID_ctxt.direct_cmd_tx->cmd_timeout);
 8005680:	f8d5 3714 	ldr.w	r3, [r5, #1812]	; 0x714
 8005684:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8005686:	4641      	mov	r1, r8
 8005688:	4628      	mov	r0, r5
 800568a:	f007 fa05 	bl	800ca98 <atcm_program_CMD_TIMEOUT>
 800568e:	f7ff b8b7 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 8005692:	7cac      	ldrb	r4, [r5, #18]
 8005694:	b114      	cbz	r4, 800569c <ATCustom_TYPE1SC_getCmd+0xf64>
      retval = ATSTATUS_ERROR;
 8005696:	2401      	movs	r4, #1
 8005698:	f7ff b8b2 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      type1sc_shared.setcfg_function = SETGETCFG_SIM_POLICY;
 800569c:	2301      	movs	r3, #1
 800569e:	4a2b      	ldr	r2, [pc, #172]	; (800574c <ATCustom_TYPE1SC_getCmd+0x1014>)
 80056a0:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_SETCFG, FINAL_CMD);
 80056a4:	9300      	str	r3, [sp, #0]
 80056a6:	233a      	movs	r3, #58	; 0x3a
 80056a8:	2203      	movs	r2, #3
 80056aa:	4641      	mov	r1, r8
 80056ac:	4826      	ldr	r0, [pc, #152]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 80056ae:	f007 f9cf 	bl	800ca50 <atcm_program_AT_CMD>
 80056b2:	f7ff b8a5 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 80056b6:	7cac      	ldrb	r4, [r5, #18]
 80056b8:	b114      	cbz	r4, 80056c0 <ATCustom_TYPE1SC_getCmd+0xf88>
      retval = ATSTATUS_ERROR;
 80056ba:	2401      	movs	r4, #1
 80056bc:	f7ff b8a0 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      atcm_program_AT_CMD(&TYPE1SC_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CSIM, FINAL_CMD);
 80056c0:	2301      	movs	r3, #1
 80056c2:	9300      	str	r3, [sp, #0]
 80056c4:	2326      	movs	r3, #38	; 0x26
 80056c6:	2203      	movs	r2, #3
 80056c8:	4641      	mov	r1, r8
 80056ca:	481f      	ldr	r0, [pc, #124]	; (8005748 <ATCustom_TYPE1SC_getCmd+0x1010>)
 80056cc:	f007 f9c0 	bl	800ca50 <atcm_program_AT_CMD>
 80056d0:	f7ff b896 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    PRINT_ERR("Error, invalid command ID %d", curSID)
 80056d4:	4c1e      	ldr	r4, [pc, #120]	; (8005750 <ATCustom_TYPE1SC_getCmd+0x1018>)
 80056d6:	463a      	mov	r2, r7
 80056d8:	491e      	ldr	r1, [pc, #120]	; (8005754 <ATCustom_TYPE1SC_getCmd+0x101c>)
 80056da:	4620      	mov	r0, r4
 80056dc:	f021 f8b4 	bl	8026848 <sprintf>
 80056e0:	4620      	mov	r0, r4
 80056e2:	f019 fe22 	bl	801f32a <crs_strlen>
 80056e6:	b283      	uxth	r3, r0
 80056e8:	4622      	mov	r2, r4
 80056ea:	2110      	movs	r1, #16
 80056ec:	2002      	movs	r0, #2
 80056ee:	f019 fe5f 	bl	801f3b0 <traceIF_itmPrint>
 80056f2:	4620      	mov	r0, r4
 80056f4:	f019 fe19 	bl	801f32a <crs_strlen>
 80056f8:	b283      	uxth	r3, r0
 80056fa:	4622      	mov	r2, r4
 80056fc:	2110      	movs	r1, #16
 80056fe:	2002      	movs	r0, #2
 8005700:	f019 fe78 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 8005704:	2401      	movs	r4, #1
 8005706:	f7ff b87b 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 800570a:	2401      	movs	r4, #1
 800570c:	f7ff b878 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      switch (TYPE1SC_ctxt.SID_ctxt.device_info->field_requested)
 8005710:	2401      	movs	r4, #1
 8005712:	f7ff b875 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8005716:	2401      	movs	r4, #1
 8005718:	f7ff b872 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 800571c:	2401      	movs	r4, #1
 800571e:	f7ff b86f 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005722:	2401      	movs	r4, #1
 8005724:	f7ff b86c 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005728:	2401      	movs	r4, #1
 800572a:	f7ff b869 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 800572e:	2401      	movs	r4, #1
 8005730:	f7ff b866 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005734:	2401      	movs	r4, #1
 8005736:	f7ff b863 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
    if (p_atp_ctxt->step == 0U)
 800573a:	2401      	movs	r4, #1
 800573c:	f7ff b860 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
      retval = ATSTATUS_ERROR;
 8005740:	2401      	movs	r4, #1
 8005742:	f7ff b85d 	b.w	8004800 <ATCustom_TYPE1SC_getCmd+0xc8>
 8005746:	bf00      	nop
 8005748:	20001084 	.word	0x20001084
 800574c:	20001838 	.word	0x20001838
 8005750:	200048dc 	.word	0x200048dc
 8005754:	0802c6d8 	.word	0x0802c6d8

08005758 <ATCustom_TYPE1SC_extractElement>:
{
 8005758:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800575c:	4680      	mov	r8, r0
 800575e:	460f      	mov	r7, r1
 8005760:	4614      	mov	r4, r2
  PRINT_API("enter ATCustom_TYPE1SC_extractElement()")
 8005762:	4e54      	ldr	r6, [pc, #336]	; (80058b4 <ATCustom_TYPE1SC_extractElement+0x15c>)
 8005764:	4d54      	ldr	r5, [pc, #336]	; (80058b8 <ATCustom_TYPE1SC_extractElement+0x160>)
 8005766:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 800576a:	46b4      	mov	ip, r6
 800576c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005770:	6028      	str	r0, [r5, #0]
 8005772:	6069      	str	r1, [r5, #4]
 8005774:	60aa      	str	r2, [r5, #8]
 8005776:	60eb      	str	r3, [r5, #12]
 8005778:	4666      	mov	r6, ip
 800577a:	3510      	adds	r5, #16
 800577c:	45f4      	cmp	ip, lr
 800577e:	d1f4      	bne.n	800576a <ATCustom_TYPE1SC_extractElement+0x12>
 8005780:	f8dc 0000 	ldr.w	r0, [ip]
 8005784:	6028      	str	r0, [r5, #0]
 8005786:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800578a:	80ab      	strh	r3, [r5, #4]
 800578c:	4d4a      	ldr	r5, [pc, #296]	; (80058b8 <ATCustom_TYPE1SC_extractElement+0x160>)
 800578e:	4628      	mov	r0, r5
 8005790:	f019 fdcb 	bl	801f32a <crs_strlen>
 8005794:	b283      	uxth	r3, r0
 8005796:	462a      	mov	r2, r5
 8005798:	2104      	movs	r1, #4
 800579a:	2002      	movs	r0, #2
 800579c:	f019 fe08 	bl	801f3b0 <traceIF_itmPrint>
 80057a0:	4628      	mov	r0, r5
 80057a2:	f019 fdc2 	bl	801f32a <crs_strlen>
 80057a6:	b283      	uxth	r3, r0
 80057a8:	462a      	mov	r2, r5
 80057aa:	2104      	movs	r1, #4
 80057ac:	2002      	movs	r0, #2
 80057ae:	f019 fe21 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("input message: size=%d ", p_msg_in->size)
 80057b2:	f8b7 27d0 	ldrh.w	r2, [r7, #2000]	; 0x7d0
 80057b6:	4941      	ldr	r1, [pc, #260]	; (80058bc <ATCustom_TYPE1SC_extractElement+0x164>)
 80057b8:	4628      	mov	r0, r5
 80057ba:	f021 f845 	bl	8026848 <sprintf>
 80057be:	4628      	mov	r0, r5
 80057c0:	f019 fdb3 	bl	801f32a <crs_strlen>
 80057c4:	b283      	uxth	r3, r0
 80057c6:	462a      	mov	r2, r5
 80057c8:	2102      	movs	r1, #2
 80057ca:	4608      	mov	r0, r1
 80057cc:	f019 fdf0 	bl	801f3b0 <traceIF_itmPrint>
 80057d0:	4628      	mov	r0, r5
 80057d2:	f019 fdaa 	bl	801f32a <crs_strlen>
 80057d6:	b283      	uxth	r3, r0
 80057d8:	462a      	mov	r2, r5
 80057da:	2102      	movs	r1, #2
 80057dc:	4608      	mov	r0, r1
 80057de:	f019 fe09 	bl	801f3f4 <traceIF_uartPrint>
  if (*p_parseIndex == 0U)
 80057e2:	8823      	ldrh	r3, [r4, #0]
 80057e4:	b923      	cbnz	r3, 80057f0 <ATCustom_TYPE1SC_extractElement+0x98>
    if ((p_msg_in->buffer[0] == (AT_CHAR_t)('\r')) && (p_msg_in->buffer[1] == (AT_CHAR_t)('\n')))
 80057e6:	883a      	ldrh	r2, [r7, #0]
 80057e8:	f640 230d 	movw	r3, #2573	; 0xa0d
 80057ec:	429a      	cmp	r2, r3
 80057ee:	d00b      	beq.n	8005808 <ATCustom_TYPE1SC_extractElement+0xb0>
  element_infos->str_start_idx = *p_parseIndex;
 80057f0:	8823      	ldrh	r3, [r4, #0]
 80057f2:	8163      	strh	r3, [r4, #10]
  element_infos->str_end_idx = *p_parseIndex;
 80057f4:	81a3      	strh	r3, [r4, #12]
  element_infos->str_size = 0U;
 80057f6:	2200      	movs	r2, #0
 80057f8:	81e2      	strh	r2, [r4, #14]
  if (*p_parseIndex >= p_msg_in->size)
 80057fa:	f8b7 27d0 	ldrh.w	r2, [r7, #2000]	; 0x7d0
 80057fe:	4293      	cmp	r3, r2
 8005800:	d32a      	bcc.n	8005858 <ATCustom_TYPE1SC_extractElement+0x100>
    retval_msg_end_detected = ATENDMSG_YES;
 8005802:	2000      	movs	r0, #0
}
 8005804:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      PRINT_DBG("cmd init sequence <CR><LF> found - break")
 8005808:	f8df c0b4 	ldr.w	ip, [pc, #180]	; 80058c0 <ATCustom_TYPE1SC_extractElement+0x168>
 800580c:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 8005810:	4666      	mov	r6, ip
 8005812:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005814:	6028      	str	r0, [r5, #0]
 8005816:	6069      	str	r1, [r5, #4]
 8005818:	60aa      	str	r2, [r5, #8]
 800581a:	60eb      	str	r3, [r5, #12]
 800581c:	46b4      	mov	ip, r6
 800581e:	3510      	adds	r5, #16
 8005820:	4576      	cmp	r6, lr
 8005822:	d1f5      	bne.n	8005810 <ATCustom_TYPE1SC_extractElement+0xb8>
 8005824:	8832      	ldrh	r2, [r6, #0]
 8005826:	78b3      	ldrb	r3, [r6, #2]
 8005828:	802a      	strh	r2, [r5, #0]
 800582a:	70ab      	strb	r3, [r5, #2]
 800582c:	4d22      	ldr	r5, [pc, #136]	; (80058b8 <ATCustom_TYPE1SC_extractElement+0x160>)
 800582e:	4628      	mov	r0, r5
 8005830:	f019 fd7b 	bl	801f32a <crs_strlen>
 8005834:	b283      	uxth	r3, r0
 8005836:	462a      	mov	r2, r5
 8005838:	2102      	movs	r1, #2
 800583a:	4608      	mov	r0, r1
 800583c:	f019 fdb8 	bl	801f3b0 <traceIF_itmPrint>
 8005840:	4628      	mov	r0, r5
 8005842:	f019 fd72 	bl	801f32a <crs_strlen>
 8005846:	b283      	uxth	r3, r0
 8005848:	462a      	mov	r2, r5
 800584a:	2102      	movs	r1, #2
 800584c:	4608      	mov	r0, r1
 800584e:	f019 fdd1 	bl	801f3f4 <traceIF_uartPrint>
      *p_parseIndex = 2U;
 8005852:	2302      	movs	r3, #2
 8005854:	8023      	strh	r3, [r4, #0]
 8005856:	e7cb      	b.n	80057f0 <ATCustom_TYPE1SC_extractElement+0x98>
  exit_loop = false;
 8005858:	2100      	movs	r1, #0
  at_endmsg_t retval_msg_end_detected = ATENDMSG_NO;
 800585a:	2001      	movs	r0, #1
    switch (p_msg_in->buffer[*p_parseIndex])
 800585c:	8823      	ldrh	r3, [r4, #0]
 800585e:	5cfa      	ldrb	r2, [r7, r3]
 8005860:	2a3a      	cmp	r2, #58	; 0x3a
 8005862:	d021      	beq.n	80058a8 <ATCustom_TYPE1SC_extractElement+0x150>
 8005864:	d813      	bhi.n	800588e <ATCustom_TYPE1SC_extractElement+0x136>
 8005866:	2a0d      	cmp	r2, #13
 8005868:	d020      	beq.n	80058ac <ATCustom_TYPE1SC_extractElement+0x154>
 800586a:	2a2c      	cmp	r2, #44	; 0x2c
 800586c:	d117      	bne.n	800589e <ATCustom_TYPE1SC_extractElement+0x146>
 800586e:	2101      	movs	r1, #1
    (*p_parseIndex)++;
 8005870:	3301      	adds	r3, #1
 8005872:	b29b      	uxth	r3, r3
 8005874:	8023      	strh	r3, [r4, #0]
    if (*p_parseIndex >= p_msg_in->size)
 8005876:	f8b7 27d0 	ldrh.w	r2, [r7, #2000]	; 0x7d0
 800587a:	4293      	cmp	r3, r2
 800587c:	d301      	bcc.n	8005882 <ATCustom_TYPE1SC_extractElement+0x12a>
      exit_loop = true;
 800587e:	2101      	movs	r1, #1
      retval_msg_end_detected = ATENDMSG_YES;
 8005880:	2000      	movs	r0, #0
  } while (exit_loop == false);
 8005882:	2900      	cmp	r1, #0
 8005884:	d0ea      	beq.n	800585c <ATCustom_TYPE1SC_extractElement+0x104>
  element_infos->param_rank = (element_infos->param_rank + 1U);
 8005886:	8923      	ldrh	r3, [r4, #8]
 8005888:	3301      	adds	r3, #1
 800588a:	8123      	strh	r3, [r4, #8]
 800588c:	e7ba      	b.n	8005804 <ATCustom_TYPE1SC_extractElement+0xac>
    switch (p_msg_in->buffer[*p_parseIndex])
 800588e:	2a3d      	cmp	r2, #61	; 0x3d
 8005890:	d105      	bne.n	800589e <ATCustom_TYPE1SC_extractElement+0x146>
        if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t)CMD_AT_IFC)
 8005892:	f8d8 200c 	ldr.w	r2, [r8, #12]
 8005896:	2a32      	cmp	r2, #50	; 0x32
 8005898:	d1ea      	bne.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
          exit_loop = true;
 800589a:	2101      	movs	r1, #1
 800589c:	e7e8      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
        element_infos->str_end_idx = *p_parseIndex;
 800589e:	81a3      	strh	r3, [r4, #12]
        element_infos->str_size++;
 80058a0:	89e2      	ldrh	r2, [r4, #14]
 80058a2:	3201      	adds	r2, #1
 80058a4:	81e2      	strh	r2, [r4, #14]
        break;
 80058a6:	e7e3      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
    switch (p_msg_in->buffer[*p_parseIndex])
 80058a8:	2101      	movs	r1, #1
 80058aa:	e7e1      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
        exit_loop = true;
 80058ac:	2101      	movs	r1, #1
        retval_msg_end_detected = ATENDMSG_YES;
 80058ae:	2000      	movs	r0, #0
 80058b0:	e7de      	b.n	8005870 <ATCustom_TYPE1SC_extractElement+0x118>
 80058b2:	bf00      	nop
 80058b4:	0802c708 	.word	0x0802c708
 80058b8:	200048dc 	.word	0x200048dc
 80058bc:	0802c740 	.word	0x0802c740
 80058c0:	0802c764 	.word	0x0802c764

080058c4 <ATCustom_TYPE1SC_analyzeCmd>:
{
 80058c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80058c8:	4607      	mov	r7, r0
 80058ca:	4688      	mov	r8, r1
 80058cc:	4616      	mov	r6, r2
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
 80058ce:	f100 0910 	add.w	r9, r0, #16
  PRINT_API("enter ATCustom_TYPE1SC_analyzeCmd()")
 80058d2:	4d9a      	ldr	r5, [pc, #616]	; (8005b3c <ATCustom_TYPE1SC_analyzeCmd+0x278>)
 80058d4:	4c9a      	ldr	r4, [pc, #616]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 80058d6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80058da:	46ac      	mov	ip, r5
 80058dc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80058e0:	6020      	str	r0, [r4, #0]
 80058e2:	6061      	str	r1, [r4, #4]
 80058e4:	60a2      	str	r2, [r4, #8]
 80058e6:	60e3      	str	r3, [r4, #12]
 80058e8:	4665      	mov	r5, ip
 80058ea:	3410      	adds	r4, #16
 80058ec:	45f4      	cmp	ip, lr
 80058ee:	d1f4      	bne.n	80058da <ATCustom_TYPE1SC_analyzeCmd+0x16>
 80058f0:	f8bc 3000 	ldrh.w	r3, [ip]
 80058f4:	8023      	strh	r3, [r4, #0]
 80058f6:	4c92      	ldr	r4, [pc, #584]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 80058f8:	4620      	mov	r0, r4
 80058fa:	f019 fd16 	bl	801f32a <crs_strlen>
 80058fe:	b283      	uxth	r3, r0
 8005900:	4622      	mov	r2, r4
 8005902:	2104      	movs	r1, #4
 8005904:	2002      	movs	r0, #2
 8005906:	f019 fd53 	bl	801f3b0 <traceIF_itmPrint>
 800590a:	4620      	mov	r0, r4
 800590c:	f019 fd0d 	bl	801f32a <crs_strlen>
 8005910:	b283      	uxth	r3, r0
 8005912:	4622      	mov	r2, r4
 8005914:	2104      	movs	r1, #4
 8005916:	2002      	movs	r0, #2
 8005918:	f019 fd6c 	bl	801f3f4 <traceIF_uartPrint>
  if (ATSTATUS_OK != atcm_searchCmdInLUT(&TYPE1SC_ctxt, p_atp_ctxt, p_msg_in, element_infos))
 800591c:	4633      	mov	r3, r6
 800591e:	4642      	mov	r2, r8
 8005920:	4649      	mov	r1, r9
 8005922:	4888      	ldr	r0, [pc, #544]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 8005924:	f007 fd58 	bl	800d3d8 <atcm_searchCmdInLUT>
 8005928:	2800      	cmp	r0, #0
 800592a:	d157      	bne.n	80059dc <ATCustom_TYPE1SC_analyzeCmd+0x118>
    switch (element_infos->cmd_id_received)
 800592c:	6873      	ldr	r3, [r6, #4]
 800592e:	2b4e      	cmp	r3, #78	; 0x4e
 8005930:	f200 8092 	bhi.w	8005a58 <ATCustom_TYPE1SC_analyzeCmd+0x194>
 8005934:	2b4e      	cmp	r3, #78	; 0x4e
 8005936:	f200 8093 	bhi.w	8005a60 <ATCustom_TYPE1SC_analyzeCmd+0x19c>
 800593a:	e8df f013 	tbh	[pc, r3, lsl #1]
 800593e:	01aa      	.short	0x01aa
 8005940:	010b009b 	.word	0x010b009b
 8005944:	008b008b 	.word	0x008b008b
 8005948:	008b01ac 	.word	0x008b01ac
 800594c:	008b008b 	.word	0x008b008b
 8005950:	01b301b3 	.word	0x01b301b3
 8005954:	00910091 	.word	0x00910091
 8005958:	00910091 	.word	0x00910091
 800595c:	00910091 	.word	0x00910091
 8005960:	01e10091 	.word	0x01e10091
 8005964:	009101e1 	.word	0x009101e1
 8005968:	00910091 	.word	0x00910091
 800596c:	01e10133 	.word	0x01e10133
 8005970:	00910133 	.word	0x00910133
 8005974:	0091013a 	.word	0x0091013a
 8005978:	00910091 	.word	0x00910091
 800597c:	00910091 	.word	0x00910091
 8005980:	00910091 	.word	0x00910091
 8005984:	00910091 	.word	0x00910091
 8005988:	00910091 	.word	0x00910091
 800598c:	00910091 	.word	0x00910091
 8005990:	00910091 	.word	0x00910091
 8005994:	00910091 	.word	0x00910091
 8005998:	00910091 	.word	0x00910091
 800599c:	00910091 	.word	0x00910091
 80059a0:	00910091 	.word	0x00910091
 80059a4:	00910091 	.word	0x00910091
 80059a8:	00910091 	.word	0x00910091
 80059ac:	00910091 	.word	0x00910091
 80059b0:	00910091 	.word	0x00910091
 80059b4:	00910091 	.word	0x00910091
 80059b8:	00910091 	.word	0x00910091
 80059bc:	0140013e 	.word	0x0140013e
 80059c0:	00910091 	.word	0x00910091
 80059c4:	00910091 	.word	0x00910091
 80059c8:	00910091 	.word	0x00910091
 80059cc:	00910091 	.word	0x00910091
 80059d0:	00910091 	.word	0x00910091
 80059d4:	013c013c 	.word	0x013c013c
 80059d8:	014201e1 	.word	0x014201e1
    retval = atcm_check_text_line_cmd(&TYPE1SC_ctxt, p_at_ctxt, p_msg_in, element_infos);
 80059dc:	4633      	mov	r3, r6
 80059de:	4642      	mov	r2, r8
 80059e0:	4639      	mov	r1, r7
 80059e2:	4858      	ldr	r0, [pc, #352]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 80059e4:	f007 fd5e 	bl	800d4a4 <atcm_check_text_line_cmd>
    if (retval == ATACTION_RSP_NO_ACTION)
 80059e8:	2800      	cmp	r0, #0
 80059ea:	f040 818c 	bne.w	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
      switch (p_atp_ctxt->current_atcmd.id)
 80059ee:	69fb      	ldr	r3, [r7, #28]
 80059f0:	2b3d      	cmp	r3, #61	; 0x3d
 80059f2:	d028      	beq.n	8005a46 <ATCustom_TYPE1SC_analyzeCmd+0x182>
          PRINT_DBG("receive an un-expected line... is it a text line ?")
 80059f4:	4d54      	ldr	r5, [pc, #336]	; (8005b48 <ATCustom_TYPE1SC_analyzeCmd+0x284>)
 80059f6:	4c52      	ldr	r4, [pc, #328]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 80059f8:	f105 0730 	add.w	r7, r5, #48	; 0x30
 80059fc:	462e      	mov	r6, r5
 80059fe:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005a00:	6020      	str	r0, [r4, #0]
 8005a02:	6061      	str	r1, [r4, #4]
 8005a04:	60a2      	str	r2, [r4, #8]
 8005a06:	60e3      	str	r3, [r4, #12]
 8005a08:	4635      	mov	r5, r6
 8005a0a:	3410      	adds	r4, #16
 8005a0c:	42be      	cmp	r6, r7
 8005a0e:	d1f5      	bne.n	80059fc <ATCustom_TYPE1SC_analyzeCmd+0x138>
 8005a10:	cd07      	ldmia	r5!, {r0, r1, r2}
 8005a12:	6020      	str	r0, [r4, #0]
 8005a14:	6061      	str	r1, [r4, #4]
 8005a16:	60a2      	str	r2, [r4, #8]
 8005a18:	782b      	ldrb	r3, [r5, #0]
 8005a1a:	7323      	strb	r3, [r4, #12]
 8005a1c:	4c48      	ldr	r4, [pc, #288]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005a1e:	4620      	mov	r0, r4
 8005a20:	f019 fc83 	bl	801f32a <crs_strlen>
 8005a24:	b283      	uxth	r3, r0
 8005a26:	4622      	mov	r2, r4
 8005a28:	2102      	movs	r1, #2
 8005a2a:	4608      	mov	r0, r1
 8005a2c:	f019 fcc0 	bl	801f3b0 <traceIF_itmPrint>
 8005a30:	4620      	mov	r0, r4
 8005a32:	f019 fc7a 	bl	801f32a <crs_strlen>
 8005a36:	b283      	uxth	r3, r0
 8005a38:	4622      	mov	r2, r4
 8005a3a:	2102      	movs	r1, #2
 8005a3c:	4608      	mov	r0, r1
 8005a3e:	f019 fcd9 	bl	801f3f4 <traceIF_uartPrint>
          retval = ATACTION_RSP_IGNORED;
 8005a42:	2010      	movs	r0, #16
          break;
 8005a44:	e15f      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          retval = fCmdpAnalyze_GETCFG_TYPE1SC(p_at_ctxt, &TYPE1SC_ctxt, p_msg_in, element_infos);
 8005a46:	4633      	mov	r3, r6
 8005a48:	4642      	mov	r2, r8
 8005a4a:	493e      	ldr	r1, [pc, #248]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 8005a4c:	4638      	mov	r0, r7
 8005a4e:	f7fd f8c7 	bl	8002be0 <fCmdpAnalyze_GETCFG_TYPE1SC>
          break;
 8005a52:	e158      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
    switch (element_infos->cmd_id_received)
 8005a54:	2004      	movs	r0, #4
 8005a56:	e156      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
 8005a58:	f1b3 3fff 	cmp.w	r3, #4294967295
 8005a5c:	f000 8152 	beq.w	8005d04 <ATCustom_TYPE1SC_analyzeCmd+0x440>
        if (element_infos->cmd_id_received == p_atp_ctxt->current_atcmd.id)
 8005a60:	69fa      	ldr	r2, [r7, #28]
 8005a62:	4293      	cmp	r3, r2
 8005a64:	f000 8153 	beq.w	8005d0e <ATCustom_TYPE1SC_analyzeCmd+0x44a>
        else if (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD)
 8005a68:	8b3b      	ldrh	r3, [r7, #24]
 8005a6a:	2b06      	cmp	r3, #6
 8005a6c:	f040 8121 	bne.w	8005cb2 <ATCustom_TYPE1SC_analyzeCmd+0x3ee>
          retval = ATACTION_RSP_IGNORED;
 8005a70:	2010      	movs	r0, #16
 8005a72:	e148      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_DATA_SUSPEND)
 8005a74:	8a3b      	ldrh	r3, [r7, #16]
 8005a76:	2b7e      	cmp	r3, #126	; 0x7e
 8005a78:	d006      	beq.n	8005a88 <ATCustom_TYPE1SC_analyzeCmd+0x1c4>
        if ((p_atp_ctxt->current_SID == (at_msg_t) SID_CS_POWER_ON) ||
 8005a7a:	8a3b      	ldrh	r3, [r7, #16]
 8005a7c:	2b65      	cmp	r3, #101	; 0x65
 8005a7e:	d02a      	beq.n	8005ad6 <ATCustom_TYPE1SC_analyzeCmd+0x212>
 8005a80:	2b80      	cmp	r3, #128	; 0x80
 8005a82:	d028      	beq.n	8005ad6 <ATCustom_TYPE1SC_analyzeCmd+0x212>
        retval = ATACTION_RSP_FRC_END;
 8005a84:	2001      	movs	r0, #1
 8005a86:	e13e      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          PRINT_INFO("MODEM SWITCHES TO COMMAND MODE")
 8005a88:	4d30      	ldr	r5, [pc, #192]	; (8005b4c <ATCustom_TYPE1SC_analyzeCmd+0x288>)
 8005a8a:	4c2d      	ldr	r4, [pc, #180]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005a8c:	f105 0c20 	add.w	ip, r5, #32
 8005a90:	462e      	mov	r6, r5
 8005a92:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005a94:	6020      	str	r0, [r4, #0]
 8005a96:	6061      	str	r1, [r4, #4]
 8005a98:	60a2      	str	r2, [r4, #8]
 8005a9a:	60e3      	str	r3, [r4, #12]
 8005a9c:	4635      	mov	r5, r6
 8005a9e:	3410      	adds	r4, #16
 8005aa0:	4566      	cmp	r6, ip
 8005aa2:	d1f5      	bne.n	8005a90 <ATCustom_TYPE1SC_analyzeCmd+0x1cc>
 8005aa4:	cd03      	ldmia	r5!, {r0, r1}
 8005aa6:	6020      	str	r0, [r4, #0]
 8005aa8:	6061      	str	r1, [r4, #4]
 8005aaa:	782b      	ldrb	r3, [r5, #0]
 8005aac:	7223      	strb	r3, [r4, #8]
 8005aae:	4c24      	ldr	r4, [pc, #144]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005ab0:	4620      	mov	r0, r4
 8005ab2:	f019 fc3a 	bl	801f32a <crs_strlen>
 8005ab6:	b283      	uxth	r3, r0
 8005ab8:	4622      	mov	r2, r4
 8005aba:	2101      	movs	r1, #1
 8005abc:	2002      	movs	r0, #2
 8005abe:	f019 fc77 	bl	801f3b0 <traceIF_itmPrint>
 8005ac2:	4620      	mov	r0, r4
 8005ac4:	f019 fc31 	bl	801f32a <crs_strlen>
 8005ac8:	b283      	uxth	r3, r0
 8005aca:	4622      	mov	r2, r4
 8005acc:	2101      	movs	r1, #1
 8005ace:	2002      	movs	r0, #2
 8005ad0:	f019 fc90 	bl	801f3f4 <traceIF_uartPrint>
 8005ad4:	e7d1      	b.n	8005a7a <ATCustom_TYPE1SC_analyzeCmd+0x1b6>
          if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT)
 8005ad6:	69fb      	ldr	r3, [r7, #28]
 8005ad8:	b91b      	cbnz	r3, 8005ae2 <ATCustom_TYPE1SC_analyzeCmd+0x21e>
            TYPE1SC_ctxt.persist.modem_at_ready = AT_TRUE;
 8005ada:	4b1a      	ldr	r3, [pc, #104]	; (8005b44 <ATCustom_TYPE1SC_analyzeCmd+0x280>)
 8005adc:	2201      	movs	r2, #1
 8005ade:	f883 250e 	strb.w	r2, [r3, #1294]	; 0x50e
          if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_ATE)
 8005ae2:	69fb      	ldr	r3, [r7, #28]
 8005ae4:	2b28      	cmp	r3, #40	; 0x28
 8005ae6:	d001      	beq.n	8005aec <ATCustom_TYPE1SC_analyzeCmd+0x228>
        retval = ATACTION_RSP_FRC_END;
 8005ae8:	2001      	movs	r0, #1
 8005aea:	e10c      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
            PRINT_DBG("Echo successfully disabled")
 8005aec:	4e18      	ldr	r6, [pc, #96]	; (8005b50 <ATCustom_TYPE1SC_analyzeCmd+0x28c>)
 8005aee:	4d14      	ldr	r5, [pc, #80]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005af0:	f106 0720 	add.w	r7, r6, #32
 8005af4:	4634      	mov	r4, r6
 8005af6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005af8:	6028      	str	r0, [r5, #0]
 8005afa:	6069      	str	r1, [r5, #4]
 8005afc:	60aa      	str	r2, [r5, #8]
 8005afe:	60eb      	str	r3, [r5, #12]
 8005b00:	4626      	mov	r6, r4
 8005b02:	3510      	adds	r5, #16
 8005b04:	42bc      	cmp	r4, r7
 8005b06:	d1f5      	bne.n	8005af4 <ATCustom_TYPE1SC_analyzeCmd+0x230>
 8005b08:	6820      	ldr	r0, [r4, #0]
 8005b0a:	6028      	str	r0, [r5, #0]
 8005b0c:	7923      	ldrb	r3, [r4, #4]
 8005b0e:	712b      	strb	r3, [r5, #4]
 8005b10:	4c0b      	ldr	r4, [pc, #44]	; (8005b40 <ATCustom_TYPE1SC_analyzeCmd+0x27c>)
 8005b12:	4620      	mov	r0, r4
 8005b14:	f019 fc09 	bl	801f32a <crs_strlen>
 8005b18:	b283      	uxth	r3, r0
 8005b1a:	4622      	mov	r2, r4
 8005b1c:	2102      	movs	r1, #2
 8005b1e:	4608      	mov	r0, r1
 8005b20:	f019 fc46 	bl	801f3b0 <traceIF_itmPrint>
 8005b24:	4620      	mov	r0, r4
 8005b26:	f019 fc00 	bl	801f32a <crs_strlen>
 8005b2a:	b283      	uxth	r3, r0
 8005b2c:	4622      	mov	r2, r4
 8005b2e:	2102      	movs	r1, #2
 8005b30:	4608      	mov	r0, r1
 8005b32:	f019 fc5f 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATACTION_RSP_FRC_END;
 8005b36:	2001      	movs	r0, #1
 8005b38:	e0e5      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
 8005b3a:	bf00      	nop
 8005b3c:	0802c798 	.word	0x0802c798
 8005b40:	200048dc 	.word	0x200048dc
 8005b44:	20001084 	.word	0x20001084
 8005b48:	0802c7cc 	.word	0x0802c7cc
 8005b4c:	0802c80c 	.word	0x0802c80c
 8005b50:	0802c838 	.word	0x0802c838
        PRINT_INFO("MODEM SWITCHES TO DATA MODE")
 8005b54:	4e6f      	ldr	r6, [pc, #444]	; (8005d14 <ATCustom_TYPE1SC_analyzeCmd+0x450>)
 8005b56:	4c70      	ldr	r4, [pc, #448]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005b58:	f106 0720 	add.w	r7, r6, #32
 8005b5c:	4635      	mov	r5, r6
 8005b5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005b60:	6020      	str	r0, [r4, #0]
 8005b62:	6061      	str	r1, [r4, #4]
 8005b64:	60a2      	str	r2, [r4, #8]
 8005b66:	60e3      	str	r3, [r4, #12]
 8005b68:	462e      	mov	r6, r5
 8005b6a:	3410      	adds	r4, #16
 8005b6c:	42bd      	cmp	r5, r7
 8005b6e:	d1f5      	bne.n	8005b5c <ATCustom_TYPE1SC_analyzeCmd+0x298>
 8005b70:	6828      	ldr	r0, [r5, #0]
 8005b72:	6020      	str	r0, [r4, #0]
 8005b74:	88ab      	ldrh	r3, [r5, #4]
 8005b76:	80a3      	strh	r3, [r4, #4]
 8005b78:	4c67      	ldr	r4, [pc, #412]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005b7a:	4620      	mov	r0, r4
 8005b7c:	f019 fbd5 	bl	801f32a <crs_strlen>
 8005b80:	b283      	uxth	r3, r0
 8005b82:	4622      	mov	r2, r4
 8005b84:	2101      	movs	r1, #1
 8005b86:	2002      	movs	r0, #2
 8005b88:	f019 fc12 	bl	801f3b0 <traceIF_itmPrint>
 8005b8c:	4620      	mov	r0, r4
 8005b8e:	f019 fbcc 	bl	801f32a <crs_strlen>
 8005b92:	b283      	uxth	r3, r0
 8005b94:	4622      	mov	r2, r4
 8005b96:	2101      	movs	r1, #1
 8005b98:	2002      	movs	r0, #2
 8005b9a:	f019 fc2b 	bl	801f3f4 <traceIF_uartPrint>
        retval = (at_action_rsp_t)(ATACTION_RSP_FLAG_DATA_MODE | ATACTION_RSP_FRC_END);
 8005b9e:	f248 0001 	movw	r0, #32769	; 0x8001
        break;
 8005ba2:	e0b0      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        if (element_infos->cmd_id_received == p_atp_ctxt->current_atcmd.id)
 8005ba4:	69fa      	ldr	r2, [r7, #28]
 8005ba6:	4293      	cmp	r3, r2
 8005ba8:	d001      	beq.n	8005bae <ATCustom_TYPE1SC_analyzeCmd+0x2ea>
          retval = ATACTION_RSP_URC_FORWARDED;
 8005baa:	2040      	movs	r0, #64	; 0x40
 8005bac:	e0ab      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          retval = ATACTION_RSP_INTERMEDIATE;
 8005bae:	2008      	movs	r0, #8
 8005bb0:	e0a9      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_URC_FORWARDED;
 8005bb2:	2040      	movs	r0, #64	; 0x40
        break;
 8005bb4:	e0a7      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_INTERMEDIATE;
 8005bb6:	2008      	movs	r0, #8
        break;
 8005bb8:	e0a5      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_INTERMEDIATE;
 8005bba:	2008      	movs	r0, #8
        break;
 8005bbc:	e0a3      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_INTERMEDIATE;
 8005bbe:	2008      	movs	r0, #8
        break;
 8005bc0:	e0a1      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        if ((p_atp_ctxt->current_SID == (at_msg_t) SID_CS_POWER_ON) ||
 8005bc2:	8a3b      	ldrh	r3, [r7, #16]
 8005bc4:	2b65      	cmp	r3, #101	; 0x65
 8005bc6:	d001      	beq.n	8005bcc <ATCustom_TYPE1SC_analyzeCmd+0x308>
 8005bc8:	2b80      	cmp	r3, #128	; 0x80
 8005bca:	d15a      	bne.n	8005c82 <ATCustom_TYPE1SC_analyzeCmd+0x3be>
          type1sc_shared.modem_bootev_received = true;
 8005bcc:	4b53      	ldr	r3, [pc, #332]	; (8005d1c <ATCustom_TYPE1SC_analyzeCmd+0x458>)
 8005bce:	2201      	movs	r2, #1
 8005bd0:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
          if (type1sc_shared.modem_waiting_for_bootev == true)
 8005bd4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8005bd8:	b363      	cbz	r3, 8005c34 <ATCustom_TYPE1SC_analyzeCmd+0x370>
            type1sc_shared.modem_waiting_for_bootev = false;
 8005bda:	4b50      	ldr	r3, [pc, #320]	; (8005d1c <ATCustom_TYPE1SC_analyzeCmd+0x458>)
 8005bdc:	2200      	movs	r2, #0
 8005bde:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
            PRINT_INFO("continue INIT modem sequence")
 8005be2:	4e4f      	ldr	r6, [pc, #316]	; (8005d20 <ATCustom_TYPE1SC_analyzeCmd+0x45c>)
 8005be4:	4c4c      	ldr	r4, [pc, #304]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005be6:	f106 0720 	add.w	r7, r6, #32
 8005bea:	4635      	mov	r5, r6
 8005bec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005bee:	6020      	str	r0, [r4, #0]
 8005bf0:	6061      	str	r1, [r4, #4]
 8005bf2:	60a2      	str	r2, [r4, #8]
 8005bf4:	60e3      	str	r3, [r4, #12]
 8005bf6:	462e      	mov	r6, r5
 8005bf8:	3410      	adds	r4, #16
 8005bfa:	42bd      	cmp	r5, r7
 8005bfc:	d1f5      	bne.n	8005bea <ATCustom_TYPE1SC_analyzeCmd+0x326>
 8005bfe:	6828      	ldr	r0, [r5, #0]
 8005c00:	6020      	str	r0, [r4, #0]
 8005c02:	88aa      	ldrh	r2, [r5, #4]
 8005c04:	79ab      	ldrb	r3, [r5, #6]
 8005c06:	80a2      	strh	r2, [r4, #4]
 8005c08:	71a3      	strb	r3, [r4, #6]
 8005c0a:	4c43      	ldr	r4, [pc, #268]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005c0c:	4620      	mov	r0, r4
 8005c0e:	f019 fb8c 	bl	801f32a <crs_strlen>
 8005c12:	b283      	uxth	r3, r0
 8005c14:	4622      	mov	r2, r4
 8005c16:	2101      	movs	r1, #1
 8005c18:	2002      	movs	r0, #2
 8005c1a:	f019 fbc9 	bl	801f3b0 <traceIF_itmPrint>
 8005c1e:	4620      	mov	r0, r4
 8005c20:	f019 fb83 	bl	801f32a <crs_strlen>
 8005c24:	b283      	uxth	r3, r0
 8005c26:	4622      	mov	r2, r4
 8005c28:	2101      	movs	r1, #1
 8005c2a:	2002      	movs	r0, #2
 8005c2c:	f019 fbe2 	bl	801f3f4 <traceIF_uartPrint>
            retval = ATACTION_RSP_FRC_END;
 8005c30:	2001      	movs	r0, #1
 8005c32:	e068      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
            PRINT_DBG("memorize BOOTEV received")
 8005c34:	4e3b      	ldr	r6, [pc, #236]	; (8005d24 <ATCustom_TYPE1SC_analyzeCmd+0x460>)
 8005c36:	4d38      	ldr	r5, [pc, #224]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005c38:	f106 0720 	add.w	r7, r6, #32
 8005c3c:	4634      	mov	r4, r6
 8005c3e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005c40:	6028      	str	r0, [r5, #0]
 8005c42:	6069      	str	r1, [r5, #4]
 8005c44:	60aa      	str	r2, [r5, #8]
 8005c46:	60eb      	str	r3, [r5, #12]
 8005c48:	4626      	mov	r6, r4
 8005c4a:	3510      	adds	r5, #16
 8005c4c:	42bc      	cmp	r4, r7
 8005c4e:	d1f5      	bne.n	8005c3c <ATCustom_TYPE1SC_analyzeCmd+0x378>
 8005c50:	8822      	ldrh	r2, [r4, #0]
 8005c52:	78a3      	ldrb	r3, [r4, #2]
 8005c54:	802a      	strh	r2, [r5, #0]
 8005c56:	70ab      	strb	r3, [r5, #2]
 8005c58:	4c2f      	ldr	r4, [pc, #188]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005c5a:	4620      	mov	r0, r4
 8005c5c:	f019 fb65 	bl	801f32a <crs_strlen>
 8005c60:	b283      	uxth	r3, r0
 8005c62:	4622      	mov	r2, r4
 8005c64:	2102      	movs	r1, #2
 8005c66:	4608      	mov	r0, r1
 8005c68:	f019 fba2 	bl	801f3b0 <traceIF_itmPrint>
 8005c6c:	4620      	mov	r0, r4
 8005c6e:	f019 fb5c 	bl	801f32a <crs_strlen>
 8005c72:	b283      	uxth	r3, r0
 8005c74:	4622      	mov	r2, r4
 8005c76:	2102      	movs	r1, #2
 8005c78:	4608      	mov	r0, r1
 8005c7a:	f019 fbbb 	bl	801f3f4 <traceIF_uartPrint>
            retval = ATACTION_RSP_URC_IGNORED;
 8005c7e:	2020      	movs	r0, #32
 8005c80:	e041      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          if (atcm_modem_event_received(&TYPE1SC_ctxt, CS_MDMEVENT_BOOT) == AT_TRUE)
 8005c82:	2101      	movs	r1, #1
 8005c84:	4828      	ldr	r0, [pc, #160]	; (8005d28 <ATCustom_TYPE1SC_analyzeCmd+0x464>)
 8005c86:	f007 faa7 	bl	800d1d8 <atcm_modem_event_received>
 8005c8a:	2800      	cmp	r0, #0
 8005c8c:	d03d      	beq.n	8005d0a <ATCustom_TYPE1SC_analyzeCmd+0x446>
            retval = ATACTION_RSP_URC_FORWARDED;
 8005c8e:	2040      	movs	r0, #64	; 0x40
 8005c90:	e039      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_IGNORED;
 8005c92:	2010      	movs	r0, #16
        break;
 8005c94:	e037      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = fRspAnalyze_Error_TYPE1SC(p_at_ctxt, &TYPE1SC_ctxt, p_msg_in, element_infos);
 8005c96:	4633      	mov	r3, r6
 8005c98:	4642      	mov	r2, r8
 8005c9a:	4923      	ldr	r1, [pc, #140]	; (8005d28 <ATCustom_TYPE1SC_analyzeCmd+0x464>)
 8005c9c:	4638      	mov	r0, r7
 8005c9e:	f7fc fdd7 	bl	8002850 <fRspAnalyze_Error_TYPE1SC>
        break;
 8005ca2:	e030      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = fRspAnalyze_Error_TYPE1SC(p_at_ctxt, &TYPE1SC_ctxt, p_msg_in, element_infos);
 8005ca4:	4633      	mov	r3, r6
 8005ca6:	4642      	mov	r2, r8
 8005ca8:	491f      	ldr	r1, [pc, #124]	; (8005d28 <ATCustom_TYPE1SC_analyzeCmd+0x464>)
 8005caa:	4638      	mov	r0, r7
 8005cac:	f7fc fdd0 	bl	8002850 <fRspAnalyze_Error_TYPE1SC>
        break;
 8005cb0:	e029      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          PRINT_INFO("UNEXPECTED MESSAGE RECEIVED")
 8005cb2:	4e1e      	ldr	r6, [pc, #120]	; (8005d2c <ATCustom_TYPE1SC_analyzeCmd+0x468>)
 8005cb4:	4c18      	ldr	r4, [pc, #96]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005cb6:	f106 0720 	add.w	r7, r6, #32
 8005cba:	4635      	mov	r5, r6
 8005cbc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005cbe:	6020      	str	r0, [r4, #0]
 8005cc0:	6061      	str	r1, [r4, #4]
 8005cc2:	60a2      	str	r2, [r4, #8]
 8005cc4:	60e3      	str	r3, [r4, #12]
 8005cc6:	462e      	mov	r6, r5
 8005cc8:	3410      	adds	r4, #16
 8005cca:	42bd      	cmp	r5, r7
 8005ccc:	d1f5      	bne.n	8005cba <ATCustom_TYPE1SC_analyzeCmd+0x3f6>
 8005cce:	6828      	ldr	r0, [r5, #0]
 8005cd0:	6020      	str	r0, [r4, #0]
 8005cd2:	88ab      	ldrh	r3, [r5, #4]
 8005cd4:	80a3      	strh	r3, [r4, #4]
 8005cd6:	4c10      	ldr	r4, [pc, #64]	; (8005d18 <ATCustom_TYPE1SC_analyzeCmd+0x454>)
 8005cd8:	4620      	mov	r0, r4
 8005cda:	f019 fb26 	bl	801f32a <crs_strlen>
 8005cde:	b283      	uxth	r3, r0
 8005ce0:	4622      	mov	r2, r4
 8005ce2:	2101      	movs	r1, #1
 8005ce4:	2002      	movs	r0, #2
 8005ce6:	f019 fb63 	bl	801f3b0 <traceIF_itmPrint>
 8005cea:	4620      	mov	r0, r4
 8005cec:	f019 fb1d 	bl	801f32a <crs_strlen>
 8005cf0:	b283      	uxth	r3, r0
 8005cf2:	4622      	mov	r2, r4
 8005cf4:	2101      	movs	r1, #1
 8005cf6:	2002      	movs	r0, #2
 8005cf8:	f019 fb7c 	bl	801f3f4 <traceIF_uartPrint>
          retval = ATACTION_RSP_IGNORED;
 8005cfc:	2010      	movs	r0, #16
 8005cfe:	e002      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
        retval = ATACTION_RSP_URC_IGNORED;
 8005d00:	2020      	movs	r0, #32
 8005d02:	e000      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
    switch (element_infos->cmd_id_received)
 8005d04:	2004      	movs	r0, #4
}
 8005d06:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            retval = ATACTION_RSP_URC_IGNORED;
 8005d0a:	2020      	movs	r0, #32
 8005d0c:	e7fb      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
          retval = ATACTION_RSP_INTERMEDIATE;
 8005d0e:	2008      	movs	r0, #8
 8005d10:	e7f9      	b.n	8005d06 <ATCustom_TYPE1SC_analyzeCmd+0x442>
 8005d12:	bf00      	nop
 8005d14:	0802c860 	.word	0x0802c860
 8005d18:	200048dc 	.word	0x200048dc
 8005d1c:	20001838 	.word	0x20001838
 8005d20:	0802c888 	.word	0x0802c888
 8005d24:	0802c8b0 	.word	0x0802c8b0
 8005d28:	20001084 	.word	0x20001084
 8005d2c:	0802c8d4 	.word	0x0802c8d4

08005d30 <ATCustom_TYPE1SC_analyzeParam>:
{
 8005d30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005d34:	4607      	mov	r7, r0
 8005d36:	4688      	mov	r8, r1
 8005d38:	4616      	mov	r6, r2
  PRINT_API("enter ATCustom_TYPE1SC_analyzeParam()")
 8005d3a:	4d19      	ldr	r5, [pc, #100]	; (8005da0 <ATCustom_TYPE1SC_analyzeParam+0x70>)
 8005d3c:	4c19      	ldr	r4, [pc, #100]	; (8005da4 <ATCustom_TYPE1SC_analyzeParam+0x74>)
 8005d3e:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8005d42:	46ac      	mov	ip, r5
 8005d44:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005d48:	6020      	str	r0, [r4, #0]
 8005d4a:	6061      	str	r1, [r4, #4]
 8005d4c:	60a2      	str	r2, [r4, #8]
 8005d4e:	60e3      	str	r3, [r4, #12]
 8005d50:	4665      	mov	r5, ip
 8005d52:	3410      	adds	r4, #16
 8005d54:	45f4      	cmp	ip, lr
 8005d56:	d1f4      	bne.n	8005d42 <ATCustom_TYPE1SC_analyzeParam+0x12>
 8005d58:	f8dc 0000 	ldr.w	r0, [ip]
 8005d5c:	6020      	str	r0, [r4, #0]
 8005d5e:	4c11      	ldr	r4, [pc, #68]	; (8005da4 <ATCustom_TYPE1SC_analyzeParam+0x74>)
 8005d60:	4620      	mov	r0, r4
 8005d62:	f019 fae2 	bl	801f32a <crs_strlen>
 8005d66:	b283      	uxth	r3, r0
 8005d68:	4622      	mov	r2, r4
 8005d6a:	2104      	movs	r1, #4
 8005d6c:	2002      	movs	r0, #2
 8005d6e:	f019 fb1f 	bl	801f3b0 <traceIF_itmPrint>
 8005d72:	4620      	mov	r0, r4
 8005d74:	f019 fad9 	bl	801f32a <crs_strlen>
 8005d78:	b283      	uxth	r3, r0
 8005d7a:	4622      	mov	r2, r4
 8005d7c:	2104      	movs	r1, #4
 8005d7e:	2002      	movs	r0, #2
 8005d80:	f019 fb38 	bl	801f3f4 <traceIF_uartPrint>
  retval = (atcm_get_CmdAnalyzeFunc(&TYPE1SC_ctxt, element_infos->cmd_id_received))(p_at_ctxt,
 8005d84:	4c08      	ldr	r4, [pc, #32]	; (8005da8 <ATCustom_TYPE1SC_analyzeParam+0x78>)
 8005d86:	6871      	ldr	r1, [r6, #4]
 8005d88:	4620      	mov	r0, r4
 8005d8a:	f006 fe1f 	bl	800c9cc <atcm_get_CmdAnalyzeFunc>
 8005d8e:	4605      	mov	r5, r0
 8005d90:	4633      	mov	r3, r6
 8005d92:	4642      	mov	r2, r8
 8005d94:	4621      	mov	r1, r4
 8005d96:	4638      	mov	r0, r7
 8005d98:	47a8      	blx	r5
}
 8005d9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005d9e:	bf00      	nop
 8005da0:	0802c8fc 	.word	0x0802c8fc
 8005da4:	200048dc 	.word	0x200048dc
 8005da8:	20001084 	.word	0x20001084

08005dac <ATCustom_TYPE1SC_terminateCmd>:
{
 8005dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005dae:	4606      	mov	r6, r0
 8005db0:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_terminateCmd()")
 8005db2:	4d42      	ldr	r5, [pc, #264]	; (8005ebc <ATCustom_TYPE1SC_terminateCmd+0x110>)
 8005db4:	4c42      	ldr	r4, [pc, #264]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005db6:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8005dba:	46ac      	mov	ip, r5
 8005dbc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005dc0:	6020      	str	r0, [r4, #0]
 8005dc2:	6061      	str	r1, [r4, #4]
 8005dc4:	60a2      	str	r2, [r4, #8]
 8005dc6:	60e3      	str	r3, [r4, #12]
 8005dc8:	4665      	mov	r5, ip
 8005dca:	3410      	adds	r4, #16
 8005dcc:	45f4      	cmp	ip, lr
 8005dce:	d1f4      	bne.n	8005dba <ATCustom_TYPE1SC_terminateCmd+0xe>
 8005dd0:	f8dc 0000 	ldr.w	r0, [ip]
 8005dd4:	6020      	str	r0, [r4, #0]
 8005dd6:	4c3a      	ldr	r4, [pc, #232]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005dd8:	4620      	mov	r0, r4
 8005dda:	f019 faa6 	bl	801f32a <crs_strlen>
 8005dde:	b283      	uxth	r3, r0
 8005de0:	4622      	mov	r2, r4
 8005de2:	2104      	movs	r1, #4
 8005de4:	2002      	movs	r0, #2
 8005de6:	f019 fae3 	bl	801f3b0 <traceIF_itmPrint>
 8005dea:	4620      	mov	r0, r4
 8005dec:	f019 fa9d 	bl	801f32a <crs_strlen>
 8005df0:	b283      	uxth	r3, r0
 8005df2:	4622      	mov	r2, r4
 8005df4:	2104      	movs	r1, #4
 8005df6:	2002      	movs	r0, #2
 8005df8:	f019 fafc 	bl	801f3f4 <traceIF_uartPrint>
  if (TYPE1SC_ctxt.socket_ctxt.socket_send_state != SocketSendState_No_Activity)
 8005dfc:	4b31      	ldr	r3, [pc, #196]	; (8005ec4 <ATCustom_TYPE1SC_terminateCmd+0x118>)
 8005dfe:	f893 37ac 	ldrb.w	r3, [r3, #1964]	; 0x7ac
 8005e02:	b133      	cbz	r3, 8005e12 <ATCustom_TYPE1SC_terminateCmd+0x66>
    if (p_atp_ctxt->current_SID != (at_msg_t) SID_CS_SEND_DATA)
 8005e04:	8833      	ldrh	r3, [r6, #0]
 8005e06:	2b7a      	cmp	r3, #122	; 0x7a
 8005e08:	d003      	beq.n	8005e12 <ATCustom_TYPE1SC_terminateCmd+0x66>
      TYPE1SC_ctxt.socket_ctxt.socket_send_state = SocketSendState_No_Activity;
 8005e0a:	4b2e      	ldr	r3, [pc, #184]	; (8005ec4 <ATCustom_TYPE1SC_terminateCmd+0x118>)
 8005e0c:	2200      	movs	r2, #0
 8005e0e:	f883 27ac 	strb.w	r2, [r3, #1964]	; 0x7ac
  if ((p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_ATD) ||
 8005e12:	68f3      	ldr	r3, [r6, #12]
 8005e14:	2b27      	cmp	r3, #39	; 0x27
 8005e16:	d005      	beq.n	8005e24 <ATCustom_TYPE1SC_terminateCmd+0x78>
 8005e18:	2b2a      	cmp	r3, #42	; 0x2a
 8005e1a:	d003      	beq.n	8005e24 <ATCustom_TYPE1SC_terminateCmd+0x78>
      (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_ATO) ||
 8005e1c:	2b1f      	cmp	r3, #31
 8005e1e:	d001      	beq.n	8005e24 <ATCustom_TYPE1SC_terminateCmd+0x78>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8005e20:	2010      	movs	r0, #16
 8005e22:	e026      	b.n	8005e72 <ATCustom_TYPE1SC_terminateCmd+0xc6>
    if (element_infos->cmd_id_received == (CMD_ID_t) CMD_AT_CONNECT)
 8005e24:	687b      	ldr	r3, [r7, #4]
 8005e26:	2b02      	cmp	r3, #2
 8005e28:	d024      	beq.n	8005e74 <ATCustom_TYPE1SC_terminateCmd+0xc8>
      PRINT_ERR("expected CONNECT not received !!!")
 8005e2a:	4e27      	ldr	r6, [pc, #156]	; (8005ec8 <ATCustom_TYPE1SC_terminateCmd+0x11c>)
 8005e2c:	4d24      	ldr	r5, [pc, #144]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005e2e:	f106 0730 	add.w	r7, r6, #48	; 0x30
 8005e32:	4634      	mov	r4, r6
 8005e34:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8005e36:	6028      	str	r0, [r5, #0]
 8005e38:	6069      	str	r1, [r5, #4]
 8005e3a:	60aa      	str	r2, [r5, #8]
 8005e3c:	60eb      	str	r3, [r5, #12]
 8005e3e:	4626      	mov	r6, r4
 8005e40:	3510      	adds	r5, #16
 8005e42:	42bc      	cmp	r4, r7
 8005e44:	d1f5      	bne.n	8005e32 <ATCustom_TYPE1SC_terminateCmd+0x86>
 8005e46:	8823      	ldrh	r3, [r4, #0]
 8005e48:	802b      	strh	r3, [r5, #0]
 8005e4a:	4c1d      	ldr	r4, [pc, #116]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005e4c:	4620      	mov	r0, r4
 8005e4e:	f019 fa6c 	bl	801f32a <crs_strlen>
 8005e52:	b283      	uxth	r3, r0
 8005e54:	4622      	mov	r2, r4
 8005e56:	2110      	movs	r1, #16
 8005e58:	2002      	movs	r0, #2
 8005e5a:	f019 faa9 	bl	801f3b0 <traceIF_itmPrint>
 8005e5e:	4620      	mov	r0, r4
 8005e60:	f019 fa63 	bl	801f32a <crs_strlen>
 8005e64:	b283      	uxth	r3, r0
 8005e66:	4622      	mov	r2, r4
 8005e68:	2110      	movs	r1, #16
 8005e6a:	2002      	movs	r0, #2
 8005e6c:	f019 fac2 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATACTION_RSP_ERROR;
 8005e70:	2004      	movs	r0, #4
}
 8005e72:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      p_atp_ctxt->is_final_cmd = 1U;
 8005e74:	2301      	movs	r3, #1
 8005e76:	7133      	strb	r3, [r6, #4]
      PRINT_DBG("CONNECT received")
 8005e78:	4c11      	ldr	r4, [pc, #68]	; (8005ec0 <ATCustom_TYPE1SC_terminateCmd+0x114>)
 8005e7a:	4d14      	ldr	r5, [pc, #80]	; (8005ecc <ATCustom_TYPE1SC_terminateCmd+0x120>)
 8005e7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8005e7e:	6020      	str	r0, [r4, #0]
 8005e80:	6061      	str	r1, [r4, #4]
 8005e82:	60a2      	str	r2, [r4, #8]
 8005e84:	60e3      	str	r3, [r4, #12]
 8005e86:	cd03      	ldmia	r5!, {r0, r1}
 8005e88:	6120      	str	r0, [r4, #16]
 8005e8a:	6161      	str	r1, [r4, #20]
 8005e8c:	882a      	ldrh	r2, [r5, #0]
 8005e8e:	78ab      	ldrb	r3, [r5, #2]
 8005e90:	8322      	strh	r2, [r4, #24]
 8005e92:	76a3      	strb	r3, [r4, #26]
 8005e94:	4620      	mov	r0, r4
 8005e96:	f019 fa48 	bl	801f32a <crs_strlen>
 8005e9a:	b283      	uxth	r3, r0
 8005e9c:	4622      	mov	r2, r4
 8005e9e:	2102      	movs	r1, #2
 8005ea0:	4608      	mov	r0, r1
 8005ea2:	f019 fa85 	bl	801f3b0 <traceIF_itmPrint>
 8005ea6:	4620      	mov	r0, r4
 8005ea8:	f019 fa3f 	bl	801f32a <crs_strlen>
 8005eac:	b283      	uxth	r3, r0
 8005eae:	4622      	mov	r2, r4
 8005eb0:	2102      	movs	r1, #2
 8005eb2:	4608      	mov	r0, r1
 8005eb4:	f019 fa9e 	bl	801f3f4 <traceIF_uartPrint>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8005eb8:	2010      	movs	r0, #16
 8005eba:	e7da      	b.n	8005e72 <ATCustom_TYPE1SC_terminateCmd+0xc6>
 8005ebc:	0802c930 	.word	0x0802c930
 8005ec0:	200048dc 	.word	0x200048dc
 8005ec4:	20001084 	.word	0x20001084
 8005ec8:	0802c980 	.word	0x0802c980
 8005ecc:	0802c964 	.word	0x0802c964

08005ed0 <ATCustom_TYPE1SC_get_rsp>:
{
 8005ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ed2:	4606      	mov	r6, r0
 8005ed4:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_get_rsp()")
 8005ed6:	4c43      	ldr	r4, [pc, #268]	; (8005fe4 <ATCustom_TYPE1SC_get_rsp+0x114>)
 8005ed8:	4d43      	ldr	r5, [pc, #268]	; (8005fe8 <ATCustom_TYPE1SC_get_rsp+0x118>)
 8005eda:	f104 0e20 	add.w	lr, r4, #32
 8005ede:	46a4      	mov	ip, r4
 8005ee0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8005ee4:	6028      	str	r0, [r5, #0]
 8005ee6:	6069      	str	r1, [r5, #4]
 8005ee8:	60aa      	str	r2, [r5, #8]
 8005eea:	60eb      	str	r3, [r5, #12]
 8005eec:	4664      	mov	r4, ip
 8005eee:	3510      	adds	r5, #16
 8005ef0:	45f4      	cmp	ip, lr
 8005ef2:	d1f4      	bne.n	8005ede <ATCustom_TYPE1SC_get_rsp+0xe>
 8005ef4:	4663      	mov	r3, ip
 8005ef6:	cb07      	ldmia	r3!, {r0, r1, r2}
 8005ef8:	6028      	str	r0, [r5, #0]
 8005efa:	6069      	str	r1, [r5, #4]
 8005efc:	60aa      	str	r2, [r5, #8]
 8005efe:	881a      	ldrh	r2, [r3, #0]
 8005f00:	789b      	ldrb	r3, [r3, #2]
 8005f02:	81aa      	strh	r2, [r5, #12]
 8005f04:	73ab      	strb	r3, [r5, #14]
 8005f06:	4c38      	ldr	r4, [pc, #224]	; (8005fe8 <ATCustom_TYPE1SC_get_rsp+0x118>)
 8005f08:	4620      	mov	r0, r4
 8005f0a:	f019 fa0e 	bl	801f32a <crs_strlen>
 8005f0e:	b283      	uxth	r3, r0
 8005f10:	4622      	mov	r2, r4
 8005f12:	2104      	movs	r1, #4
 8005f14:	2002      	movs	r0, #2
 8005f16:	f019 fa4b 	bl	801f3b0 <traceIF_itmPrint>
 8005f1a:	4620      	mov	r0, r4
 8005f1c:	f019 fa05 	bl	801f32a <crs_strlen>
 8005f20:	b283      	uxth	r3, r0
 8005f22:	4622      	mov	r2, r4
 8005f24:	2104      	movs	r1, #4
 8005f26:	2002      	movs	r0, #2
 8005f28:	f019 fa64 	bl	801f3f4 <traceIF_uartPrint>
  retval = atcm_modem_get_rsp(&TYPE1SC_ctxt, p_atp_ctxt, p_rsp_buf);
 8005f2c:	463a      	mov	r2, r7
 8005f2e:	4631      	mov	r1, r6
 8005f30:	482e      	ldr	r0, [pc, #184]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005f32:	f006 fe83 	bl	800cc3c <atcm_modem_get_rsp>
 8005f36:	4604      	mov	r4, r0
  switch (p_atp_ctxt->current_SID)
 8005f38:	8833      	ldrh	r3, [r6, #0]
 8005f3a:	2b83      	cmp	r3, #131	; 0x83
 8005f3c:	d00d      	beq.n	8005f5a <ATCustom_TYPE1SC_get_rsp+0x8a>
 8005f3e:	2b84      	cmp	r3, #132	; 0x84
 8005f40:	d019      	beq.n	8005f76 <ATCustom_TYPE1SC_get_rsp+0xa6>
 8005f42:	2b66      	cmp	r3, #102	; 0x66
 8005f44:	d013      	beq.n	8005f6e <ATCustom_TYPE1SC_get_rsp+0x9e>
  atcm_reset_SID_context(&TYPE1SC_ctxt.SID_ctxt);
 8005f46:	4d29      	ldr	r5, [pc, #164]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005f48:	f505 60b6 	add.w	r0, r5, #1456	; 0x5b0
 8005f4c:	f007 f94e 	bl	800d1ec <atcm_reset_SID_context>
  atcm_reset_SOCKET_context(&TYPE1SC_ctxt);
 8005f50:	4628      	mov	r0, r5
 8005f52:	f007 f9ff 	bl	800d354 <atcm_reset_SOCKET_context>
}
 8005f56:	4620      	mov	r0, r4
 8005f58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (DATAPACK_writeStruct(p_rsp_buf,
 8005f5a:	4b25      	ldr	r3, [pc, #148]	; (8005ff0 <ATCustom_TYPE1SC_get_rsp+0x120>)
 8005f5c:	2240      	movs	r2, #64	; 0x40
 8005f5e:	2127      	movs	r1, #39	; 0x27
 8005f60:	4638      	mov	r0, r7
 8005f62:	f006 f8a7 	bl	800c0b4 <DATAPACK_writeStruct>
 8005f66:	2800      	cmp	r0, #0
 8005f68:	d0ed      	beq.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
        retval = ATSTATUS_OK;
 8005f6a:	2400      	movs	r4, #0
 8005f6c:	e7eb      	b.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
      type1sc_modem_reset(&TYPE1SC_ctxt);
 8005f6e:	481f      	ldr	r0, [pc, #124]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005f70:	f7fe fb60 	bl	8004634 <type1sc_modem_reset>
      break;
 8005f74:	e7e7      	b.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
      PRINT_INFO("Ping final report")
 8005f76:	4d1c      	ldr	r5, [pc, #112]	; (8005fe8 <ATCustom_TYPE1SC_get_rsp+0x118>)
 8005f78:	4e1e      	ldr	r6, [pc, #120]	; (8005ff4 <ATCustom_TYPE1SC_get_rsp+0x124>)
 8005f7a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8005f7c:	6028      	str	r0, [r5, #0]
 8005f7e:	6069      	str	r1, [r5, #4]
 8005f80:	60aa      	str	r2, [r5, #8]
 8005f82:	60eb      	str	r3, [r5, #12]
 8005f84:	ce07      	ldmia	r6!, {r0, r1, r2}
 8005f86:	6128      	str	r0, [r5, #16]
 8005f88:	6169      	str	r1, [r5, #20]
 8005f8a:	61aa      	str	r2, [r5, #24]
 8005f8c:	4628      	mov	r0, r5
 8005f8e:	f019 f9cc 	bl	801f32a <crs_strlen>
 8005f92:	b283      	uxth	r3, r0
 8005f94:	462a      	mov	r2, r5
 8005f96:	2101      	movs	r1, #1
 8005f98:	2002      	movs	r0, #2
 8005f9a:	f019 fa09 	bl	801f3b0 <traceIF_itmPrint>
 8005f9e:	4628      	mov	r0, r5
 8005fa0:	f019 f9c3 	bl	801f32a <crs_strlen>
 8005fa4:	b283      	uxth	r3, r0
 8005fa6:	462a      	mov	r2, r5
 8005fa8:	2101      	movs	r1, #1
 8005faa:	2002      	movs	r0, #2
 8005fac:	f019 fa22 	bl	801f3f4 <traceIF_uartPrint>
      clear_ping_resp_struct(&TYPE1SC_ctxt);
 8005fb0:	4d0e      	ldr	r5, [pc, #56]	; (8005fec <ATCustom_TYPE1SC_get_rsp+0x11c>)
 8005fb2:	4628      	mov	r0, r5
 8005fb4:	f7fe f992 	bl	80042dc <clear_ping_resp_struct>
      TYPE1SC_ctxt.persist.ping_resp_urc.ping_status = CELLULAR_OK;
 8005fb8:	2300      	movs	r3, #0
 8005fba:	f885 355d 	strb.w	r3, [r5, #1373]	; 0x55d
      TYPE1SC_ctxt.persist.ping_resp_urc.is_final_report = CELLULAR_TRUE;
 8005fbe:	2301      	movs	r3, #1
 8005fc0:	f885 355e 	strb.w	r3, [r5, #1374]	; 0x55e
      TYPE1SC_ctxt.persist.ping_resp_urc.index = TYPE1SC_ctxt.persist.ping_infos.ping_params.pingnum + 1U;
 8005fc4:	f895 3558 	ldrb.w	r3, [r5, #1368]	; 0x558
 8005fc8:	3301      	adds	r3, #1
 8005fca:	f885 355c 	strb.w	r3, [r5, #1372]	; 0x55c
      if (DATAPACK_writeStruct(p_rsp_buf,
 8005fce:	f205 535c 	addw	r3, r5, #1372	; 0x55c
 8005fd2:	2250      	movs	r2, #80	; 0x50
 8005fd4:	2110      	movs	r1, #16
 8005fd6:	4638      	mov	r0, r7
 8005fd8:	f006 f86c 	bl	800c0b4 <DATAPACK_writeStruct>
 8005fdc:	2800      	cmp	r0, #0
 8005fde:	d0b2      	beq.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
        retval = ATSTATUS_OK;
 8005fe0:	2400      	movs	r4, #0
 8005fe2:	e7b0      	b.n	8005f46 <ATCustom_TYPE1SC_get_rsp+0x76>
 8005fe4:	0802c9b4 	.word	0x0802c9b4
 8005fe8:	200048dc 	.word	0x200048dc
 8005fec:	20001084 	.word	0x20001084
 8005ff0:	20001838 	.word	0x20001838
 8005ff4:	0802c9e4 	.word	0x0802c9e4

08005ff8 <ATCustom_TYPE1SC_get_urc>:
{
 8005ff8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005ffa:	4606      	mov	r6, r0
 8005ffc:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_get_urc()")
 8005ffe:	4c18      	ldr	r4, [pc, #96]	; (8006060 <ATCustom_TYPE1SC_get_urc+0x68>)
 8006000:	4d18      	ldr	r5, [pc, #96]	; (8006064 <ATCustom_TYPE1SC_get_urc+0x6c>)
 8006002:	f104 0e20 	add.w	lr, r4, #32
 8006006:	46a4      	mov	ip, r4
 8006008:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800600c:	6028      	str	r0, [r5, #0]
 800600e:	6069      	str	r1, [r5, #4]
 8006010:	60aa      	str	r2, [r5, #8]
 8006012:	60eb      	str	r3, [r5, #12]
 8006014:	4664      	mov	r4, ip
 8006016:	3510      	adds	r5, #16
 8006018:	45f4      	cmp	ip, lr
 800601a:	d1f4      	bne.n	8006006 <ATCustom_TYPE1SC_get_urc+0xe>
 800601c:	4663      	mov	r3, ip
 800601e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8006020:	6028      	str	r0, [r5, #0]
 8006022:	6069      	str	r1, [r5, #4]
 8006024:	60aa      	str	r2, [r5, #8]
 8006026:	881a      	ldrh	r2, [r3, #0]
 8006028:	789b      	ldrb	r3, [r3, #2]
 800602a:	81aa      	strh	r2, [r5, #12]
 800602c:	73ab      	strb	r3, [r5, #14]
 800602e:	4c0d      	ldr	r4, [pc, #52]	; (8006064 <ATCustom_TYPE1SC_get_urc+0x6c>)
 8006030:	4620      	mov	r0, r4
 8006032:	f019 f97a 	bl	801f32a <crs_strlen>
 8006036:	b283      	uxth	r3, r0
 8006038:	4622      	mov	r2, r4
 800603a:	2104      	movs	r1, #4
 800603c:	2002      	movs	r0, #2
 800603e:	f019 f9b7 	bl	801f3b0 <traceIF_itmPrint>
 8006042:	4620      	mov	r0, r4
 8006044:	f019 f971 	bl	801f32a <crs_strlen>
 8006048:	b283      	uxth	r3, r0
 800604a:	4622      	mov	r2, r4
 800604c:	2104      	movs	r1, #4
 800604e:	2002      	movs	r0, #2
 8006050:	f019 f9d0 	bl	801f3f4 <traceIF_uartPrint>
  retval = atcm_modem_get_urc(&TYPE1SC_ctxt, p_atp_ctxt, p_rsp_buf);
 8006054:	463a      	mov	r2, r7
 8006056:	4631      	mov	r1, r6
 8006058:	4803      	ldr	r0, [pc, #12]	; (8006068 <ATCustom_TYPE1SC_get_urc+0x70>)
 800605a:	f007 fd73 	bl	800db44 <atcm_modem_get_urc>
}
 800605e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006060:	0802ca00 	.word	0x0802ca00
 8006064:	200048dc 	.word	0x200048dc
 8006068:	20001084 	.word	0x20001084

0800606c <ATCustom_TYPE1SC_get_error>:
{
 800606c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800606e:	4606      	mov	r6, r0
 8006070:	460f      	mov	r7, r1
  PRINT_API("enter ATCustom_TYPE1SC_get_error()")
 8006072:	4d15      	ldr	r5, [pc, #84]	; (80060c8 <ATCustom_TYPE1SC_get_error+0x5c>)
 8006074:	4c15      	ldr	r4, [pc, #84]	; (80060cc <ATCustom_TYPE1SC_get_error+0x60>)
 8006076:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 800607a:	46ac      	mov	ip, r5
 800607c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006080:	6020      	str	r0, [r4, #0]
 8006082:	6061      	str	r1, [r4, #4]
 8006084:	60a2      	str	r2, [r4, #8]
 8006086:	60e3      	str	r3, [r4, #12]
 8006088:	4665      	mov	r5, ip
 800608a:	3410      	adds	r4, #16
 800608c:	45f4      	cmp	ip, lr
 800608e:	d1f4      	bne.n	800607a <ATCustom_TYPE1SC_get_error+0xe>
 8006090:	f89c 3000 	ldrb.w	r3, [ip]
 8006094:	7023      	strb	r3, [r4, #0]
 8006096:	4c0d      	ldr	r4, [pc, #52]	; (80060cc <ATCustom_TYPE1SC_get_error+0x60>)
 8006098:	4620      	mov	r0, r4
 800609a:	f019 f946 	bl	801f32a <crs_strlen>
 800609e:	b283      	uxth	r3, r0
 80060a0:	4622      	mov	r2, r4
 80060a2:	2104      	movs	r1, #4
 80060a4:	2002      	movs	r0, #2
 80060a6:	f019 f983 	bl	801f3b0 <traceIF_itmPrint>
 80060aa:	4620      	mov	r0, r4
 80060ac:	f019 f93d 	bl	801f32a <crs_strlen>
 80060b0:	b283      	uxth	r3, r0
 80060b2:	4622      	mov	r2, r4
 80060b4:	2104      	movs	r1, #4
 80060b6:	2002      	movs	r0, #2
 80060b8:	f019 f99c 	bl	801f3f4 <traceIF_uartPrint>
  retval = atcm_modem_get_error(&TYPE1SC_ctxt, p_atp_ctxt, p_rsp_buf);
 80060bc:	463a      	mov	r2, r7
 80060be:	4631      	mov	r1, r6
 80060c0:	4803      	ldr	r0, [pc, #12]	; (80060d0 <ATCustom_TYPE1SC_get_error+0x64>)
 80060c2:	f006 ff63 	bl	800cf8c <atcm_modem_get_error>
}
 80060c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80060c8:	0802ca30 	.word	0x0802ca30
 80060cc:	200048dc 	.word	0x200048dc
 80060d0:	20001084 	.word	0x20001084

080060d4 <ATCustom_TYPE1SC_hw_event>:
  if (hwEvent == HWEVT_MODEM_RING)
 80060d4:	2901      	cmp	r1, #1
 80060d6:	d001      	beq.n	80060dc <ATCustom_TYPE1SC_hw_event+0x8>
  at_status_t retval = ATSTATUS_ERROR;
 80060d8:	2001      	movs	r0, #1
}
 80060da:	4770      	bx	lr
{
 80060dc:	b510      	push	{r4, lr}
 80060de:	4604      	mov	r4, r0
    if (is_waiting_modem_low_power_ack() == true)
 80060e0:	f7fe fa5a 	bl	8004598 <is_waiting_modem_low_power_ack>
 80060e4:	b920      	cbnz	r0, 80060f0 <ATCustom_TYPE1SC_hw_event+0x1c>
    else if (is_modem_in_low_power_state() == true)
 80060e6:	f7fe fa5d 	bl	80045a4 <is_modem_in_low_power_state>
 80060ea:	b978      	cbnz	r0, 800610c <ATCustom_TYPE1SC_hw_event+0x38>
  at_status_t retval = ATSTATUS_ERROR;
 80060ec:	2001      	movs	r0, #1
}
 80060ee:	bd10      	pop	{r4, pc}
      if (atcm_modem_event_received(&TYPE1SC_ctxt, CS_MDMEVENT_LP_ENTER) == AT_TRUE)
 80060f0:	2110      	movs	r1, #16
 80060f2:	480c      	ldr	r0, [pc, #48]	; (8006124 <ATCustom_TYPE1SC_hw_event+0x50>)
 80060f4:	f007 f870 	bl	800d1d8 <atcm_modem_event_received>
 80060f8:	b908      	cbnz	r0, 80060fe <ATCustom_TYPE1SC_hw_event+0x2a>
  at_status_t retval = ATSTATUS_ERROR;
 80060fa:	2001      	movs	r0, #1
 80060fc:	e7f7      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
        low_power_state_enter();
 80060fe:	f7fe fa37 	bl	8004570 <low_power_state_enter>
        AT_internalEvent(deviceType);
 8006102:	4620      	mov	r0, r4
 8006104:	f005 feb2 	bl	800be6c <AT_internalEvent>
        retval = ATSTATUS_OK;
 8006108:	2000      	movs	r0, #0
 800610a:	e7f0      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
      if (atcm_modem_event_received(&TYPE1SC_ctxt, CS_MDMEVENT_WAKEUP_REQ) == AT_TRUE)
 800610c:	2140      	movs	r1, #64	; 0x40
 800610e:	4805      	ldr	r0, [pc, #20]	; (8006124 <ATCustom_TYPE1SC_hw_event+0x50>)
 8006110:	f007 f862 	bl	800d1d8 <atcm_modem_event_received>
 8006114:	b908      	cbnz	r0, 800611a <ATCustom_TYPE1SC_hw_event+0x46>
  at_status_t retval = ATSTATUS_ERROR;
 8006116:	2001      	movs	r0, #1
 8006118:	e7e9      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
        AT_internalEvent(deviceType);
 800611a:	4620      	mov	r0, r4
 800611c:	f005 fea6 	bl	800be6c <AT_internalEvent>
        retval = ATSTATUS_OK;
 8006120:	2000      	movs	r0, #0
 8006122:	e7e4      	b.n	80060ee <ATCustom_TYPE1SC_hw_event+0x1a>
 8006124:	20001084 	.word	0x20001084

08006128 <TYPE1SC_setup>:
  return (retval);
}

/* Private function Definition -----------------------------------------------*/
static sysctrl_status_t TYPE1SC_setup(void)
{
 8006128:	b5f0      	push	{r4, r5, r6, r7, lr}
 800612a:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO config
   * Initial pins state
   */
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_RESET);
 800612c:	4f20      	ldr	r7, [pc, #128]	; (80061b0 <TYPE1SC_setup+0x88>)
 800612e:	2200      	movs	r2, #0
 8006130:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006134:	4638      	mov	r0, r7
 8006136:	f001 fcb6 	bl	8007aa6 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 800613a:	4c1e      	ldr	r4, [pc, #120]	; (80061b4 <TYPE1SC_setup+0x8c>)
 800613c:	2200      	movs	r2, #0
 800613e:	2180      	movs	r1, #128	; 0x80
 8006140:	4620      	mov	r0, r4
 8006142:	f001 fcb0 	bl	8007aa6 <HAL_GPIO_WritePin>

  /* Init GPIOs - common parameters */
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006146:	2601      	movs	r6, #1
 8006148:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800614a:	2500      	movs	r5, #0
 800614c:	9503      	str	r5, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800614e:	9504      	str	r5, [sp, #16]

  /* Init GPIOs - RESET pin */
  GPIO_InitStruct.Pin = MODEM_RST_PIN;
 8006150:	2340      	movs	r3, #64	; 0x40
 8006152:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_RST_GPIO_PORT, &GPIO_InitStruct);
 8006154:	a901      	add	r1, sp, #4
 8006156:	4620      	mov	r0, r4
 8006158:	f001 fb46 	bl	80077e8 <HAL_GPIO_Init>

  /* Init GPIOs - DTR pin */
  GPIO_InitStruct.Pin = MODEM_DTR_PIN;
 800615c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8006160:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_DTR_GPIO_PORT, &GPIO_InitStruct);
 8006162:	a901      	add	r1, sp, #4
 8006164:	4638      	mov	r0, r7
 8006166:	f001 fb3f 	bl	80077e8 <HAL_GPIO_Init>

  /* Init GPIOs - PWR_EN pin */
  GPIO_InitStruct.Pin = MODEM_PWR_EN_PIN;
 800616a:	2380      	movs	r3, #128	; 0x80
 800616c:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_PWR_EN_GPIO_PORT, &GPIO_InitStruct);
 800616e:	a901      	add	r1, sp, #4
 8006170:	4620      	mov	r0, r4
 8006172:	f001 fb39 	bl	80077e8 <HAL_GPIO_Init>
  /* NOTE: do not activate RING interrupt at this point, it's too early and can result
   *       in a crash in NVIC handler
   */

  /* Print current modem UART setup */
  PRINT_FORCE("TYPE1SC UART config: BaudRate=%d / HW flow ctrl=%d", MODEM_UART_BAUDRATE,
 8006176:	4c10      	ldr	r4, [pc, #64]	; (80061b8 <TYPE1SC_setup+0x90>)
 8006178:	4633      	mov	r3, r6
 800617a:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800617e:	490f      	ldr	r1, [pc, #60]	; (80061bc <TYPE1SC_setup+0x94>)
 8006180:	4620      	mov	r0, r4
 8006182:	f020 fb61 	bl	8026848 <sprintf>
 8006186:	4620      	mov	r0, r4
 8006188:	f019 f8cf 	bl	801f32a <crs_strlen>
 800618c:	b283      	uxth	r3, r0
 800618e:	4622      	mov	r2, r4
 8006190:	4631      	mov	r1, r6
 8006192:	2002      	movs	r0, #2
 8006194:	f019 f90c 	bl	801f3b0 <traceIF_itmPrint>
 8006198:	4620      	mov	r0, r4
 800619a:	f019 f8c6 	bl	801f32a <crs_strlen>
 800619e:	b282      	uxth	r2, r0
 80061a0:	4621      	mov	r1, r4
 80061a2:	2002      	movs	r0, #2
 80061a4:	f019 f93e 	bl	801f424 <traceIF_uartPrintForce>
              ((MODEM_UART_HWFLOWCTRL == UART_HWCONTROL_NONE) ? 0 : 1))

  return (retval);
}
 80061a8:	4628      	mov	r0, r5
 80061aa:	b007      	add	sp, #28
 80061ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80061ae:	bf00      	nop
 80061b0:	48000800 	.word	0x48000800
 80061b4:	48000400 	.word	0x48000400
 80061b8:	200048dc 	.word	0x200048dc
 80061bc:	0802d814 	.word	0x0802d814

080061c0 <TYPE1SC_LP_disable_modem_uart>:

static void TYPE1SC_LP_disable_modem_uart(void)
{
 80061c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80061c4:	b086      	sub	sp, #24
  /* Note:
  *  Not needed for TYPE1SC_LP_enable_modem_uart because it is
  *  already done in HAL_UART_Init() which call MSP_Init
  */
  PRINT_DBG("enter TYPE1SC_LP_disable_modem_uart")
 80061c6:	4d4c      	ldr	r5, [pc, #304]	; (80062f8 <TYPE1SC_LP_disable_modem_uart+0x138>)
 80061c8:	4c4c      	ldr	r4, [pc, #304]	; (80062fc <TYPE1SC_LP_disable_modem_uart+0x13c>)
 80061ca:	f105 0630 	add.w	r6, r5, #48	; 0x30
 80061ce:	46ac      	mov	ip, r5
 80061d0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80061d4:	6020      	str	r0, [r4, #0]
 80061d6:	6061      	str	r1, [r4, #4]
 80061d8:	60a2      	str	r2, [r4, #8]
 80061da:	60e3      	str	r3, [r4, #12]
 80061dc:	4665      	mov	r5, ip
 80061de:	3410      	adds	r4, #16
 80061e0:	45b4      	cmp	ip, r6
 80061e2:	d1f4      	bne.n	80061ce <TYPE1SC_LP_disable_modem_uart+0xe>
 80061e4:	f8dc 0000 	ldr.w	r0, [ip]
 80061e8:	6020      	str	r0, [r4, #0]
 80061ea:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80061ee:	80a3      	strh	r3, [r4, #4]
 80061f0:	4c42      	ldr	r4, [pc, #264]	; (80062fc <TYPE1SC_LP_disable_modem_uart+0x13c>)
 80061f2:	4620      	mov	r0, r4
 80061f4:	f019 f899 	bl	801f32a <crs_strlen>
 80061f8:	b283      	uxth	r3, r0
 80061fa:	4622      	mov	r2, r4
 80061fc:	2102      	movs	r1, #2
 80061fe:	4608      	mov	r0, r1
 8006200:	f019 f8d6 	bl	801f3b0 <traceIF_itmPrint>
 8006204:	4620      	mov	r0, r4
 8006206:	f019 f890 	bl	801f32a <crs_strlen>
 800620a:	b283      	uxth	r3, r0
 800620c:	4622      	mov	r2, r4
 800620e:	2102      	movs	r1, #2
 8006210:	4608      	mov	r0, r1
 8006212:	f019 f8ef 	bl	801f3f4 <traceIF_uartPrint>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006216:	2400      	movs	r4, #0
 8006218:	9401      	str	r4, [sp, #4]
 800621a:	9402      	str	r4, [sp, #8]
 800621c:	9403      	str	r4, [sp, #12]
 800621e:	9404      	str	r4, [sp, #16]
 8006220:	9405      	str	r4, [sp, #20]

  /* Configure CTS and RTS pins
   *   Do this even if HwFlowControl is not activated because
   *   pins are reserved in the current project
   */
  GPIO_InitStruct.Pin = MODEM_CTS_PIN;
 8006222:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006226:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8006228:	2502      	movs	r5, #2
 800622a:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(MODEM_CTS_GPIO_PORT, &GPIO_InitStruct);
 800622c:	a901      	add	r1, sp, #4
 800622e:	4834      	ldr	r0, [pc, #208]	; (8006300 <TYPE1SC_LP_disable_modem_uart+0x140>)
 8006230:	f001 fada 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_RTS_PIN;
 8006234:	f04f 0804 	mov.w	r8, #4
 8006238:	f8cd 8004 	str.w	r8, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800623c:	2601      	movs	r6, #1
 800623e:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006240:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_RTS_GPIO_PORT, &GPIO_InitStruct);
 8006242:	4f30      	ldr	r7, [pc, #192]	; (8006304 <TYPE1SC_LP_disable_modem_uart+0x144>)
 8006244:	eb0d 0108 	add.w	r1, sp, r8
 8006248:	4638      	mov	r0, r7
 800624a:	f001 facd 	bl	80077e8 <HAL_GPIO_Init>

#if (DEBUG_LOW_POWER == 1)
  PRINT_INFO(">>> set RTS pin to LOW)")
#endif /* (DEBUG_LOW_POWER == 1) */
  HAL_GPIO_WritePin(MODEM_RTS_GPIO_PORT, MODEM_RTS_PIN, GPIO_PIN_RESET);
 800624e:	4622      	mov	r2, r4
 8006250:	4641      	mov	r1, r8
 8006252:	4638      	mov	r0, r7
 8006254:	f001 fc27 	bl	8007aa6 <HAL_GPIO_WritePin>

  /* Re-configure HOST_RX pin to monitor it */
  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 8006258:	2320      	movs	r3, #32
 800625a:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800625c:	9402      	str	r4, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 800625e:	9503      	str	r5, [sp, #12]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 8006260:	4d29      	ldr	r5, [pc, #164]	; (8006308 <TYPE1SC_LP_disable_modem_uart+0x148>)
 8006262:	eb0d 0108 	add.w	r1, sp, r8
 8006266:	4628      	mov	r0, r5
 8006268:	f001 fabe 	bl	80077e8 <HAL_GPIO_Init>

  /* Re-configure HOST_TX pin to allow to trigger Low Power */
  GPIO_InitStruct.Pin = MODEM_TX_PIN;
 800626c:	2710      	movs	r7, #16
 800626e:	9701      	str	r7, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006270:	9602      	str	r6, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006272:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8006274:	9604      	str	r6, [sp, #16]
  HAL_GPIO_Init(MODEM_TX_GPIO_PORT, &GPIO_InitStruct);
 8006276:	eb0d 0108 	add.w	r1, sp, r8
 800627a:	4628      	mov	r0, r5
 800627c:	f001 fab4 	bl	80077e8 <HAL_GPIO_Init>

#if (DEBUG_LOW_POWER == 1)
  PRINT_INFO(">>> Request modem to enter Low Power (set HOST-TX pin to LOW)")
#endif /* (DEBUG_LOW_POWER == 1) */
  HAL_GPIO_WritePin(MODEM_TX_GPIO_PORT, MODEM_TX_PIN, GPIO_PIN_RESET);
 8006280:	4622      	mov	r2, r4
 8006282:	4639      	mov	r1, r7
 8006284:	4628      	mov	r0, r5
 8006286:	f001 fc0e 	bl	8007aa6 <HAL_GPIO_WritePin>
  PRINT_INFO(">>> Waiting for HOST-RX pin set to LOW by modem")
#endif /* (DEBUG_LOW_POWER == 1) */
  uint32_t count = 0U;
  uint32_t count_delay = 10U;
  uint32_t count_max = 500U;
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_SET) &&
 800628a:	2120      	movs	r1, #32
 800628c:	481e      	ldr	r0, [pc, #120]	; (8006308 <TYPE1SC_LP_disable_modem_uart+0x148>)
 800628e:	f001 fc03 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006292:	2801      	cmp	r0, #1
 8006294:	d107      	bne.n	80062a6 <TYPE1SC_LP_disable_modem_uart+0xe6>
 8006296:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 800629a:	d204      	bcs.n	80062a6 <TYPE1SC_LP_disable_modem_uart+0xe6>
         (count < count_max))
  {
    SysCtrl_delay(count_delay);
 800629c:	200a      	movs	r0, #10
 800629e:	f00e fefd 	bl	801509c <SysCtrl_delay>
    count++;
 80062a2:	3401      	adds	r4, #1
 80062a4:	e7f1      	b.n	800628a <TYPE1SC_LP_disable_modem_uart+0xca>
    PRINT_INFO(">>> HOST-RX LOW after %ld ms", count * count_delay)
  }
#endif /* (DEBUG_LOW_POWER == 1) */

  /* Set modem UART GPIO pins to ANALOG to optimize power consumption */
  GPIO_InitStruct.Pin = MODEM_TX_PIN;
 80062a6:	2310      	movs	r3, #16
 80062a8:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062aa:	2503      	movs	r5, #3
 80062ac:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062ae:	2400      	movs	r4, #0
 80062b0:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_TX_GPIO_PORT, &GPIO_InitStruct);
 80062b2:	4e15      	ldr	r6, [pc, #84]	; (8006308 <TYPE1SC_LP_disable_modem_uart+0x148>)
 80062b4:	a901      	add	r1, sp, #4
 80062b6:	4630      	mov	r0, r6
 80062b8:	f001 fa96 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 80062bc:	2320      	movs	r3, #32
 80062be:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062c0:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062c2:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 80062c4:	a901      	add	r1, sp, #4
 80062c6:	4630      	mov	r0, r6
 80062c8:	f001 fa8e 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_CTS_PIN;
 80062cc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80062d0:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062d2:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062d4:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_CTS_GPIO_PORT, &GPIO_InitStruct);
 80062d6:	a901      	add	r1, sp, #4
 80062d8:	4809      	ldr	r0, [pc, #36]	; (8006300 <TYPE1SC_LP_disable_modem_uart+0x140>)
 80062da:	f001 fa85 	bl	80077e8 <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = MODEM_RTS_PIN;
 80062de:	2304      	movs	r3, #4
 80062e0:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80062e2:	9502      	str	r5, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80062e4:	9403      	str	r4, [sp, #12]
  HAL_GPIO_Init(MODEM_RTS_GPIO_PORT, &GPIO_InitStruct);
 80062e6:	eb0d 0103 	add.w	r1, sp, r3
 80062ea:	4806      	ldr	r0, [pc, #24]	; (8006304 <TYPE1SC_LP_disable_modem_uart+0x144>)
 80062ec:	f001 fa7c 	bl	80077e8 <HAL_GPIO_Init>
}
 80062f0:	b006      	add	sp, #24
 80062f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80062f6:	bf00      	nop
 80062f8:	0802d84c 	.word	0x0802d84c
 80062fc:	200048dc 	.word	0x200048dc
 8006300:	48000400 	.word	0x48000400
 8006304:	48000c00 	.word	0x48000c00
 8006308:	48000800 	.word	0x48000800

0800630c <disable_RING>:
{
 800630c:	b500      	push	{lr}
 800630e:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006310:	2300      	movs	r3, #0
 8006312:	9301      	str	r3, [sp, #4]
 8006314:	9302      	str	r3, [sp, #8]
 8006316:	9303      	str	r3, [sp, #12]
 8006318:	9304      	str	r3, [sp, #16]
 800631a:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 800631c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006320:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006322:	2303      	movs	r3, #3
 8006324:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 8006326:	a901      	add	r1, sp, #4
 8006328:	4804      	ldr	r0, [pc, #16]	; (800633c <disable_RING+0x30>)
 800632a:	f001 fa5d 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_DisableIRQ(MODEM_RING_IRQN);
 800632e:	2028      	movs	r0, #40	; 0x28
 8006330:	f001 f9fc 	bl	800772c <HAL_NVIC_DisableIRQ>
}
 8006334:	b007      	add	sp, #28
 8006336:	f85d fb04 	ldr.w	pc, [sp], #4
 800633a:	bf00      	nop
 800633c:	48000400 	.word	0x48000400

08006340 <enable_RING_wait_for_falling>:
{
 8006340:	b500      	push	{lr}
 8006342:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006344:	2300      	movs	r3, #0
 8006346:	9301      	str	r3, [sp, #4]
 8006348:	9302      	str	r3, [sp, #8]
 800634a:	9303      	str	r3, [sp, #12]
 800634c:	9304      	str	r3, [sp, #16]
 800634e:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 8006350:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006354:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8006356:	4b06      	ldr	r3, [pc, #24]	; (8006370 <enable_RING_wait_for_falling+0x30>)
 8006358:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 800635a:	a901      	add	r1, sp, #4
 800635c:	4805      	ldr	r0, [pc, #20]	; (8006374 <enable_RING_wait_for_falling+0x34>)
 800635e:	f001 fa43 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_EnableIRQ(MODEM_RING_IRQN);
 8006362:	2028      	movs	r0, #40	; 0x28
 8006364:	f001 f9d4 	bl	8007710 <HAL_NVIC_EnableIRQ>
}
 8006368:	b007      	add	sp, #28
 800636a:	f85d fb04 	ldr.w	pc, [sp], #4
 800636e:	bf00      	nop
 8006370:	10210000 	.word	0x10210000
 8006374:	48000400 	.word	0x48000400

08006378 <enable_RING_wait_for_rising>:
{
 8006378:	b500      	push	{lr}
 800637a:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800637c:	2300      	movs	r3, #0
 800637e:	9301      	str	r3, [sp, #4]
 8006380:	9302      	str	r3, [sp, #8]
 8006382:	9303      	str	r3, [sp, #12]
 8006384:	9304      	str	r3, [sp, #16]
 8006386:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 8006388:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800638c:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 800638e:	4b06      	ldr	r3, [pc, #24]	; (80063a8 <enable_RING_wait_for_rising+0x30>)
 8006390:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 8006392:	a901      	add	r1, sp, #4
 8006394:	4805      	ldr	r0, [pc, #20]	; (80063ac <enable_RING_wait_for_rising+0x34>)
 8006396:	f001 fa27 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_EnableIRQ(MODEM_RING_IRQN);
 800639a:	2028      	movs	r0, #40	; 0x28
 800639c:	f001 f9b8 	bl	8007710 <HAL_NVIC_EnableIRQ>
}
 80063a0:	b007      	add	sp, #28
 80063a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80063a6:	bf00      	nop
 80063a8:	10110000 	.word	0x10110000
 80063ac:	48000400 	.word	0x48000400

080063b0 <SysCtrl_TYPE1SC_getDeviceDescriptor>:
  if (p_devices_list == NULL)
 80063b0:	b189      	cbz	r1, 80063d6 <SysCtrl_TYPE1SC_getDeviceDescriptor+0x26>
{
 80063b2:	b510      	push	{r4, lr}
 80063b4:	4604      	mov	r4, r0
 80063b6:	460b      	mov	r3, r1
    if (type == DEVTYPE_MODEM_CELLULAR)
 80063b8:	b108      	cbz	r0, 80063be <SysCtrl_TYPE1SC_getDeviceDescriptor+0xe>
      retval = SCSTATUS_ERROR;
 80063ba:	2001      	movs	r0, #1
}
 80063bc:	bd10      	pop	{r4, pc}
      p_devices_list->type          = DEVTYPE_MODEM_CELLULAR;
 80063be:	2000      	movs	r0, #0
 80063c0:	7008      	strb	r0, [r1, #0]
      p_devices_list->ipc_device    = USER_DEFINED_IPC_DEVICE_MODEM;
 80063c2:	7048      	strb	r0, [r1, #1]
      p_devices_list->ipc_interface = IPC_INTERFACE_UART;
 80063c4:	2101      	movs	r1, #1
 80063c6:	7099      	strb	r1, [r3, #2]
      (void) IPC_init(p_devices_list->ipc_device, p_devices_list->ipc_interface, &MODEM_UART_HANDLE);
 80063c8:	4a04      	ldr	r2, [pc, #16]	; (80063dc <SysCtrl_TYPE1SC_getDeviceDescriptor+0x2c>)
 80063ca:	f018 f883 	bl	801e4d4 <IPC_init>
    (void) TYPE1SC_setup();
 80063ce:	f7ff feab 	bl	8006128 <TYPE1SC_setup>
      retval = SCSTATUS_OK;
 80063d2:	4620      	mov	r0, r4
 80063d4:	e7f2      	b.n	80063bc <SysCtrl_TYPE1SC_getDeviceDescriptor+0xc>
    retval = SCSTATUS_ERROR;
 80063d6:	2001      	movs	r0, #1
}
 80063d8:	4770      	bx	lr
 80063da:	bf00      	nop
 80063dc:	20000d04 	.word	0x20000d04

080063e0 <SysCtrl_TYPE1SC_close_channel>:
{
 80063e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  PRINT_DBG("SysCtrl_TYPE1SC_close_channel")
 80063e2:	4e4b      	ldr	r6, [pc, #300]	; (8006510 <SysCtrl_TYPE1SC_close_channel+0x130>)
 80063e4:	4d4b      	ldr	r5, [pc, #300]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 80063e6:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80063ea:	4634      	mov	r4, r6
 80063ec:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80063ee:	6028      	str	r0, [r5, #0]
 80063f0:	6069      	str	r1, [r5, #4]
 80063f2:	60aa      	str	r2, [r5, #8]
 80063f4:	60eb      	str	r3, [r5, #12]
 80063f6:	4626      	mov	r6, r4
 80063f8:	3510      	adds	r5, #16
 80063fa:	4564      	cmp	r4, ip
 80063fc:	d1f5      	bne.n	80063ea <SysCtrl_TYPE1SC_close_channel+0xa>
 80063fe:	4c45      	ldr	r4, [pc, #276]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 8006400:	4620      	mov	r0, r4
 8006402:	f018 ff92 	bl	801f32a <crs_strlen>
 8006406:	b283      	uxth	r3, r0
 8006408:	4622      	mov	r2, r4
 800640a:	2102      	movs	r1, #2
 800640c:	4608      	mov	r0, r1
 800640e:	f018 ffcf 	bl	801f3b0 <traceIF_itmPrint>
 8006412:	4620      	mov	r0, r4
 8006414:	f018 ff89 	bl	801f32a <crs_strlen>
 8006418:	b283      	uxth	r3, r0
 800641a:	4622      	mov	r2, r4
 800641c:	2102      	movs	r1, #2
 800641e:	4608      	mov	r0, r1
 8006420:	f018 ffe8 	bl	801f3f4 <traceIF_uartPrint>
  HAL_NVIC_DisableIRQ(MODEM_UART_IRQN);
 8006424:	2027      	movs	r0, #39	; 0x27
 8006426:	f001 f981 	bl	800772c <HAL_NVIC_DisableIRQ>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_RESET);
 800642a:	2200      	movs	r2, #0
 800642c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006430:	4839      	ldr	r0, [pc, #228]	; (8006518 <SysCtrl_TYPE1SC_close_channel+0x138>)
 8006432:	f001 fb38 	bl	8007aa6 <HAL_GPIO_WritePin>
  uint32_t count = 0U;
 8006436:	2400      	movs	r4, #0
  while ((HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN) == GPIO_PIN_SET) &&
 8006438:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800643c:	4837      	ldr	r0, [pc, #220]	; (800651c <SysCtrl_TYPE1SC_close_channel+0x13c>)
 800643e:	f001 fb2b 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006442:	2801      	cmp	r0, #1
 8006444:	d107      	bne.n	8006456 <SysCtrl_TYPE1SC_close_channel+0x76>
 8006446:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 800644a:	d204      	bcs.n	8006456 <SysCtrl_TYPE1SC_close_channel+0x76>
    SysCtrl_delay(count_delay);
 800644c:	200a      	movs	r0, #10
 800644e:	f00e fe25 	bl	801509c <SysCtrl_delay>
    count++;
 8006452:	3401      	adds	r4, #1
 8006454:	e7f0      	b.n	8006438 <SysCtrl_TYPE1SC_close_channel+0x58>
  if (HAL_UART_DeInit(&MODEM_UART_HANDLE) != HAL_OK)
 8006456:	4832      	ldr	r0, [pc, #200]	; (8006520 <SysCtrl_TYPE1SC_close_channel+0x140>)
 8006458:	f003 fdc6 	bl	8009fe8 <HAL_UART_DeInit>
 800645c:	4607      	mov	r7, r0
 800645e:	b348      	cbz	r0, 80064b4 <SysCtrl_TYPE1SC_close_channel+0xd4>
    PRINT_ERR("HAL_UART_DeInit error")
 8006460:	4d30      	ldr	r5, [pc, #192]	; (8006524 <SysCtrl_TYPE1SC_close_channel+0x144>)
 8006462:	4c2c      	ldr	r4, [pc, #176]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 8006464:	f105 0720 	add.w	r7, r5, #32
 8006468:	462e      	mov	r6, r5
 800646a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800646c:	6020      	str	r0, [r4, #0]
 800646e:	6061      	str	r1, [r4, #4]
 8006470:	60a2      	str	r2, [r4, #8]
 8006472:	60e3      	str	r3, [r4, #12]
 8006474:	4635      	mov	r5, r6
 8006476:	3410      	adds	r4, #16
 8006478:	42be      	cmp	r6, r7
 800647a:	d1f5      	bne.n	8006468 <SysCtrl_TYPE1SC_close_channel+0x88>
 800647c:	cd07      	ldmia	r5!, {r0, r1, r2}
 800647e:	6020      	str	r0, [r4, #0]
 8006480:	6061      	str	r1, [r4, #4]
 8006482:	60a2      	str	r2, [r4, #8]
 8006484:	882b      	ldrh	r3, [r5, #0]
 8006486:	81a3      	strh	r3, [r4, #12]
 8006488:	4c22      	ldr	r4, [pc, #136]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 800648a:	4620      	mov	r0, r4
 800648c:	f018 ff4d 	bl	801f32a <crs_strlen>
 8006490:	b283      	uxth	r3, r0
 8006492:	4622      	mov	r2, r4
 8006494:	2110      	movs	r1, #16
 8006496:	2002      	movs	r0, #2
 8006498:	f018 ff8a 	bl	801f3b0 <traceIF_itmPrint>
 800649c:	4620      	mov	r0, r4
 800649e:	f018 ff44 	bl	801f32a <crs_strlen>
 80064a2:	b283      	uxth	r3, r0
 80064a4:	4622      	mov	r2, r4
 80064a6:	2110      	movs	r1, #16
 80064a8:	2002      	movs	r0, #2
 80064aa:	f018 ffa3 	bl	801f3f4 <traceIF_uartPrint>
    retval = SCSTATUS_ERROR;
 80064ae:	2701      	movs	r7, #1
}
 80064b0:	4638      	mov	r0, r7
 80064b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    TYPE1SC_LP_disable_modem_uart();
 80064b4:	f7ff fe84 	bl	80061c0 <TYPE1SC_LP_disable_modem_uart>
    SysCtrl_delay(150U);
 80064b8:	2096      	movs	r0, #150	; 0x96
 80064ba:	f00e fdef 	bl	801509c <SysCtrl_delay>
    PRINT_INFO("modem channel closed")
 80064be:	4e1a      	ldr	r6, [pc, #104]	; (8006528 <SysCtrl_TYPE1SC_close_channel+0x148>)
 80064c0:	4c14      	ldr	r4, [pc, #80]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 80064c2:	f106 0c20 	add.w	ip, r6, #32
 80064c6:	4635      	mov	r5, r6
 80064c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80064ca:	6020      	str	r0, [r4, #0]
 80064cc:	6061      	str	r1, [r4, #4]
 80064ce:	60a2      	str	r2, [r4, #8]
 80064d0:	60e3      	str	r3, [r4, #12]
 80064d2:	462e      	mov	r6, r5
 80064d4:	3410      	adds	r4, #16
 80064d6:	4565      	cmp	r5, ip
 80064d8:	d1f5      	bne.n	80064c6 <SysCtrl_TYPE1SC_close_channel+0xe6>
 80064da:	6828      	ldr	r0, [r5, #0]
 80064dc:	6020      	str	r0, [r4, #0]
 80064de:	88aa      	ldrh	r2, [r5, #4]
 80064e0:	79ab      	ldrb	r3, [r5, #6]
 80064e2:	80a2      	strh	r2, [r4, #4]
 80064e4:	71a3      	strb	r3, [r4, #6]
 80064e6:	4c0b      	ldr	r4, [pc, #44]	; (8006514 <SysCtrl_TYPE1SC_close_channel+0x134>)
 80064e8:	4620      	mov	r0, r4
 80064ea:	f018 ff1e 	bl	801f32a <crs_strlen>
 80064ee:	b283      	uxth	r3, r0
 80064f0:	4622      	mov	r2, r4
 80064f2:	2101      	movs	r1, #1
 80064f4:	2002      	movs	r0, #2
 80064f6:	f018 ff5b 	bl	801f3b0 <traceIF_itmPrint>
 80064fa:	4620      	mov	r0, r4
 80064fc:	f018 ff15 	bl	801f32a <crs_strlen>
 8006500:	b283      	uxth	r3, r0
 8006502:	4622      	mov	r2, r4
 8006504:	2101      	movs	r1, #1
 8006506:	2002      	movs	r0, #2
 8006508:	f018 ff74 	bl	801f3f4 <traceIF_uartPrint>
 800650c:	e7d0      	b.n	80064b0 <SysCtrl_TYPE1SC_close_channel+0xd0>
 800650e:	bf00      	nop
 8006510:	0802d884 	.word	0x0802d884
 8006514:	200048dc 	.word	0x200048dc
 8006518:	48000800 	.word	0x48000800
 800651c:	48000400 	.word	0x48000400
 8006520:	20000d04 	.word	0x20000d04
 8006524:	0802d8b4 	.word	0x0802d8b4
 8006528:	0802d8e4 	.word	0x0802d8e4

0800652c <SysCtrl_TYPE1SC_power_on>:
{
 800652c:	b538      	push	{r3, r4, r5, lr}
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 800652e:	2200      	movs	r2, #0
 8006530:	2180      	movs	r1, #128	; 0x80
 8006532:	4831      	ldr	r0, [pc, #196]	; (80065f8 <SysCtrl_TYPE1SC_power_on+0xcc>)
 8006534:	f001 fab7 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 8006538:	2096      	movs	r0, #150	; 0x96
 800653a:	f00e fdaf 	bl	801509c <SysCtrl_delay>
  PRINT_INFO("MODEM POWER ON")
 800653e:	4d2f      	ldr	r5, [pc, #188]	; (80065fc <SysCtrl_TYPE1SC_power_on+0xd0>)
 8006540:	4c2f      	ldr	r4, [pc, #188]	; (8006600 <SysCtrl_TYPE1SC_power_on+0xd4>)
 8006542:	f105 0e20 	add.w	lr, r5, #32
 8006546:	46ac      	mov	ip, r5
 8006548:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800654c:	6020      	str	r0, [r4, #0]
 800654e:	6061      	str	r1, [r4, #4]
 8006550:	60a2      	str	r2, [r4, #8]
 8006552:	60e3      	str	r3, [r4, #12]
 8006554:	4665      	mov	r5, ip
 8006556:	3410      	adds	r4, #16
 8006558:	45f4      	cmp	ip, lr
 800655a:	d1f4      	bne.n	8006546 <SysCtrl_TYPE1SC_power_on+0x1a>
 800655c:	f89c 3000 	ldrb.w	r3, [ip]
 8006560:	7023      	strb	r3, [r4, #0]
 8006562:	4c27      	ldr	r4, [pc, #156]	; (8006600 <SysCtrl_TYPE1SC_power_on+0xd4>)
 8006564:	4620      	mov	r0, r4
 8006566:	f018 fee0 	bl	801f32a <crs_strlen>
 800656a:	b283      	uxth	r3, r0
 800656c:	4622      	mov	r2, r4
 800656e:	2101      	movs	r1, #1
 8006570:	2002      	movs	r0, #2
 8006572:	f018 ff1d 	bl	801f3b0 <traceIF_itmPrint>
 8006576:	4620      	mov	r0, r4
 8006578:	f018 fed7 	bl	801f32a <crs_strlen>
 800657c:	b283      	uxth	r3, r0
 800657e:	4622      	mov	r2, r4
 8006580:	2101      	movs	r1, #1
 8006582:	2002      	movs	r0, #2
 8006584:	f018 ff36 	bl	801f3f4 <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_SET);
 8006588:	2201      	movs	r2, #1
 800658a:	2180      	movs	r1, #128	; 0x80
 800658c:	481a      	ldr	r0, [pc, #104]	; (80065f8 <SysCtrl_TYPE1SC_power_on+0xcc>)
 800658e:	f001 fa8a 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 8006592:	2096      	movs	r0, #150	; 0x96
 8006594:	f00e fd82 	bl	801509c <SysCtrl_delay>
  enable_RING_wait_for_falling();
 8006598:	f7ff fed2 	bl	8006340 <enable_RING_wait_for_falling>
  PRINT_DBG("MODEM POWER ON done")
 800659c:	4d19      	ldr	r5, [pc, #100]	; (8006604 <SysCtrl_TYPE1SC_power_on+0xd8>)
 800659e:	46a4      	mov	ip, r4
 80065a0:	f105 0e20 	add.w	lr, r5, #32
 80065a4:	462c      	mov	r4, r5
 80065a6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80065a8:	f8cc 0000 	str.w	r0, [ip]
 80065ac:	f8cc 1004 	str.w	r1, [ip, #4]
 80065b0:	f8cc 2008 	str.w	r2, [ip, #8]
 80065b4:	f8cc 300c 	str.w	r3, [ip, #12]
 80065b8:	4625      	mov	r5, r4
 80065ba:	f10c 0c10 	add.w	ip, ip, #16
 80065be:	4574      	cmp	r4, lr
 80065c0:	d1f0      	bne.n	80065a4 <SysCtrl_TYPE1SC_power_on+0x78>
 80065c2:	6820      	ldr	r0, [r4, #0]
 80065c4:	f8cc 0000 	str.w	r0, [ip]
 80065c8:	88a3      	ldrh	r3, [r4, #4]
 80065ca:	f8ac 3004 	strh.w	r3, [ip, #4]
 80065ce:	4c0c      	ldr	r4, [pc, #48]	; (8006600 <SysCtrl_TYPE1SC_power_on+0xd4>)
 80065d0:	4620      	mov	r0, r4
 80065d2:	f018 feaa 	bl	801f32a <crs_strlen>
 80065d6:	b283      	uxth	r3, r0
 80065d8:	4622      	mov	r2, r4
 80065da:	2102      	movs	r1, #2
 80065dc:	4608      	mov	r0, r1
 80065de:	f018 fee7 	bl	801f3b0 <traceIF_itmPrint>
 80065e2:	4620      	mov	r0, r4
 80065e4:	f018 fea1 	bl	801f32a <crs_strlen>
 80065e8:	b283      	uxth	r3, r0
 80065ea:	4622      	mov	r2, r4
 80065ec:	2102      	movs	r1, #2
 80065ee:	4608      	mov	r0, r1
 80065f0:	f018 ff00 	bl	801f3f4 <traceIF_uartPrint>
}
 80065f4:	2000      	movs	r0, #0
 80065f6:	bd38      	pop	{r3, r4, r5, pc}
 80065f8:	48000400 	.word	0x48000400
 80065fc:	0802d90c 	.word	0x0802d90c
 8006600:	200048dc 	.word	0x200048dc
 8006604:	0802d930 	.word	0x0802d930

08006608 <SysCtrl_TYPE1SC_power_off>:
{
 8006608:	b538      	push	{r3, r4, r5, lr}
  PRINT_INFO("MODEM POWER OFF")
 800660a:	4d30      	ldr	r5, [pc, #192]	; (80066cc <SysCtrl_TYPE1SC_power_off+0xc4>)
 800660c:	4c30      	ldr	r4, [pc, #192]	; (80066d0 <SysCtrl_TYPE1SC_power_off+0xc8>)
 800660e:	f105 0e20 	add.w	lr, r5, #32
 8006612:	46ac      	mov	ip, r5
 8006614:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006618:	6020      	str	r0, [r4, #0]
 800661a:	6061      	str	r1, [r4, #4]
 800661c:	60a2      	str	r2, [r4, #8]
 800661e:	60e3      	str	r3, [r4, #12]
 8006620:	4665      	mov	r5, ip
 8006622:	3410      	adds	r4, #16
 8006624:	45f4      	cmp	ip, lr
 8006626:	d1f4      	bne.n	8006612 <SysCtrl_TYPE1SC_power_off+0xa>
 8006628:	f8bc 3000 	ldrh.w	r3, [ip]
 800662c:	8023      	strh	r3, [r4, #0]
 800662e:	4c28      	ldr	r4, [pc, #160]	; (80066d0 <SysCtrl_TYPE1SC_power_off+0xc8>)
 8006630:	4620      	mov	r0, r4
 8006632:	f018 fe7a 	bl	801f32a <crs_strlen>
 8006636:	b283      	uxth	r3, r0
 8006638:	4622      	mov	r2, r4
 800663a:	2101      	movs	r1, #1
 800663c:	2002      	movs	r0, #2
 800663e:	f018 feb7 	bl	801f3b0 <traceIF_itmPrint>
 8006642:	4620      	mov	r0, r4
 8006644:	f018 fe71 	bl	801f32a <crs_strlen>
 8006648:	b283      	uxth	r3, r0
 800664a:	4622      	mov	r2, r4
 800664c:	2101      	movs	r1, #1
 800664e:	2002      	movs	r0, #2
 8006650:	f018 fed0 	bl	801f3f4 <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 8006654:	2200      	movs	r2, #0
 8006656:	2180      	movs	r1, #128	; 0x80
 8006658:	481e      	ldr	r0, [pc, #120]	; (80066d4 <SysCtrl_TYPE1SC_power_off+0xcc>)
 800665a:	f001 fa24 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 800665e:	2096      	movs	r0, #150	; 0x96
 8006660:	f00e fd1c 	bl	801509c <SysCtrl_delay>
  disable_RING();
 8006664:	f7ff fe52 	bl	800630c <disable_RING>
  PRINT_DBG("MODEM POWER OFF done")
 8006668:	4d1b      	ldr	r5, [pc, #108]	; (80066d8 <SysCtrl_TYPE1SC_power_off+0xd0>)
 800666a:	46a4      	mov	ip, r4
 800666c:	f105 0e20 	add.w	lr, r5, #32
 8006670:	462c      	mov	r4, r5
 8006672:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006674:	f8cc 0000 	str.w	r0, [ip]
 8006678:	f8cc 1004 	str.w	r1, [ip, #4]
 800667c:	f8cc 2008 	str.w	r2, [ip, #8]
 8006680:	f8cc 300c 	str.w	r3, [ip, #12]
 8006684:	4625      	mov	r5, r4
 8006686:	f10c 0c10 	add.w	ip, ip, #16
 800668a:	4574      	cmp	r4, lr
 800668c:	d1f0      	bne.n	8006670 <SysCtrl_TYPE1SC_power_off+0x68>
 800668e:	6820      	ldr	r0, [r4, #0]
 8006690:	f8cc 0000 	str.w	r0, [ip]
 8006694:	88a2      	ldrh	r2, [r4, #4]
 8006696:	79a3      	ldrb	r3, [r4, #6]
 8006698:	f8ac 2004 	strh.w	r2, [ip, #4]
 800669c:	f88c 3006 	strb.w	r3, [ip, #6]
 80066a0:	4c0b      	ldr	r4, [pc, #44]	; (80066d0 <SysCtrl_TYPE1SC_power_off+0xc8>)
 80066a2:	4620      	mov	r0, r4
 80066a4:	f018 fe41 	bl	801f32a <crs_strlen>
 80066a8:	b283      	uxth	r3, r0
 80066aa:	4622      	mov	r2, r4
 80066ac:	2102      	movs	r1, #2
 80066ae:	4608      	mov	r0, r1
 80066b0:	f018 fe7e 	bl	801f3b0 <traceIF_itmPrint>
 80066b4:	4620      	mov	r0, r4
 80066b6:	f018 fe38 	bl	801f32a <crs_strlen>
 80066ba:	b283      	uxth	r3, r0
 80066bc:	4622      	mov	r2, r4
 80066be:	2102      	movs	r1, #2
 80066c0:	4608      	mov	r0, r1
 80066c2:	f018 fe97 	bl	801f3f4 <traceIF_uartPrint>
}
 80066c6:	2000      	movs	r0, #0
 80066c8:	bd38      	pop	{r3, r4, r5, pc}
 80066ca:	bf00      	nop
 80066cc:	0802d958 	.word	0x0802d958
 80066d0:	200048dc 	.word	0x200048dc
 80066d4:	48000400 	.word	0x48000400
 80066d8:	0802d97c 	.word	0x0802d97c

080066dc <SysCtrl_TYPE1SC_reset>:
{
 80066dc:	b538      	push	{r3, r4, r5, lr}
  PRINT_INFO("!!! Modem hardware reset triggered !!!")
 80066de:	4c1d      	ldr	r4, [pc, #116]	; (8006754 <SysCtrl_TYPE1SC_reset+0x78>)
 80066e0:	4d1d      	ldr	r5, [pc, #116]	; (8006758 <SysCtrl_TYPE1SC_reset+0x7c>)
 80066e2:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 80066e6:	46a4      	mov	ip, r4
 80066e8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80066ec:	6028      	str	r0, [r5, #0]
 80066ee:	6069      	str	r1, [r5, #4]
 80066f0:	60aa      	str	r2, [r5, #8]
 80066f2:	60eb      	str	r3, [r5, #12]
 80066f4:	4664      	mov	r4, ip
 80066f6:	3510      	adds	r5, #16
 80066f8:	45f4      	cmp	ip, lr
 80066fa:	d1f4      	bne.n	80066e6 <SysCtrl_TYPE1SC_reset+0xa>
 80066fc:	cc03      	ldmia	r4!, {r0, r1}
 80066fe:	6028      	str	r0, [r5, #0]
 8006700:	6069      	str	r1, [r5, #4]
 8006702:	7823      	ldrb	r3, [r4, #0]
 8006704:	722b      	strb	r3, [r5, #8]
 8006706:	4c14      	ldr	r4, [pc, #80]	; (8006758 <SysCtrl_TYPE1SC_reset+0x7c>)
 8006708:	4620      	mov	r0, r4
 800670a:	f018 fe0e 	bl	801f32a <crs_strlen>
 800670e:	b283      	uxth	r3, r0
 8006710:	4622      	mov	r2, r4
 8006712:	2101      	movs	r1, #1
 8006714:	2002      	movs	r0, #2
 8006716:	f018 fe4b 	bl	801f3b0 <traceIF_itmPrint>
 800671a:	4620      	mov	r0, r4
 800671c:	f018 fe05 	bl	801f32a <crs_strlen>
 8006720:	b283      	uxth	r3, r0
 8006722:	4622      	mov	r2, r4
 8006724:	2101      	movs	r1, #1
 8006726:	2002      	movs	r0, #2
 8006728:	f018 fe64 	bl	801f3f4 <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_RESET);
 800672c:	4c0b      	ldr	r4, [pc, #44]	; (800675c <SysCtrl_TYPE1SC_reset+0x80>)
 800672e:	2200      	movs	r2, #0
 8006730:	2180      	movs	r1, #128	; 0x80
 8006732:	4620      	mov	r0, r4
 8006734:	f001 f9b7 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(150U);
 8006738:	2096      	movs	r0, #150	; 0x96
 800673a:	f00e fcaf 	bl	801509c <SysCtrl_delay>
  HAL_GPIO_WritePin(MODEM_PWR_EN_GPIO_PORT, MODEM_PWR_EN_PIN, GPIO_PIN_SET);
 800673e:	2201      	movs	r2, #1
 8006740:	2180      	movs	r1, #128	; 0x80
 8006742:	4620      	mov	r0, r4
 8006744:	f001 f9af 	bl	8007aa6 <HAL_GPIO_WritePin>
  SysCtrl_delay(TYPE1SC_BOOT_TIME);
 8006748:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800674c:	f00e fca6 	bl	801509c <SysCtrl_delay>
}
 8006750:	2000      	movs	r0, #0
 8006752:	bd38      	pop	{r3, r4, r5, pc}
 8006754:	0802d9a4 	.word	0x0802d9a4
 8006758:	200048dc 	.word	0x200048dc
 800675c:	48000400 	.word	0x48000400

08006760 <SysCtrl_TYPE1SC_sim_select>:
}
 8006760:	2000      	movs	r0, #0
 8006762:	4770      	bx	lr

08006764 <SysCtrl_TYPE1SC_request_suspend_channel>:
{
 8006764:	b538      	push	{r3, r4, r5, lr}
  PRINT_DBG("enter modem channel suspend request")
 8006766:	4d23      	ldr	r5, [pc, #140]	; (80067f4 <SysCtrl_TYPE1SC_request_suspend_channel+0x90>)
 8006768:	4c23      	ldr	r4, [pc, #140]	; (80067f8 <SysCtrl_TYPE1SC_request_suspend_channel+0x94>)
 800676a:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 800676e:	46ac      	mov	ip, r5
 8006770:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006774:	6020      	str	r0, [r4, #0]
 8006776:	6061      	str	r1, [r4, #4]
 8006778:	60a2      	str	r2, [r4, #8]
 800677a:	60e3      	str	r3, [r4, #12]
 800677c:	4665      	mov	r5, ip
 800677e:	3410      	adds	r4, #16
 8006780:	45f4      	cmp	ip, lr
 8006782:	d1f4      	bne.n	800676e <SysCtrl_TYPE1SC_request_suspend_channel+0xa>
 8006784:	f8dc 0000 	ldr.w	r0, [ip]
 8006788:	6020      	str	r0, [r4, #0]
 800678a:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800678e:	80a3      	strh	r3, [r4, #4]
 8006790:	4c19      	ldr	r4, [pc, #100]	; (80067f8 <SysCtrl_TYPE1SC_request_suspend_channel+0x94>)
 8006792:	4620      	mov	r0, r4
 8006794:	f018 fdc9 	bl	801f32a <crs_strlen>
 8006798:	b283      	uxth	r3, r0
 800679a:	4622      	mov	r2, r4
 800679c:	2102      	movs	r1, #2
 800679e:	4608      	mov	r0, r1
 80067a0:	f018 fe06 	bl	801f3b0 <traceIF_itmPrint>
 80067a4:	4620      	mov	r0, r4
 80067a6:	f018 fdc0 	bl	801f32a <crs_strlen>
 80067aa:	b283      	uxth	r3, r0
 80067ac:	4622      	mov	r2, r4
 80067ae:	2102      	movs	r1, #2
 80067b0:	4608      	mov	r0, r1
 80067b2:	f018 fe1f 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_INFO(">>> Request modem to enter Low Power: Set HOST_TO_MODEM (=DTR) to LOW")
 80067b6:	2258      	movs	r2, #88	; 0x58
 80067b8:	4910      	ldr	r1, [pc, #64]	; (80067fc <SysCtrl_TYPE1SC_request_suspend_channel+0x98>)
 80067ba:	4620      	mov	r0, r4
 80067bc:	f020 f994 	bl	8026ae8 <memcpy>
 80067c0:	4620      	mov	r0, r4
 80067c2:	f018 fdb2 	bl	801f32a <crs_strlen>
 80067c6:	b283      	uxth	r3, r0
 80067c8:	4622      	mov	r2, r4
 80067ca:	2101      	movs	r1, #1
 80067cc:	2002      	movs	r0, #2
 80067ce:	f018 fdef 	bl	801f3b0 <traceIF_itmPrint>
 80067d2:	4620      	mov	r0, r4
 80067d4:	f018 fda9 	bl	801f32a <crs_strlen>
 80067d8:	b283      	uxth	r3, r0
 80067da:	4622      	mov	r2, r4
 80067dc:	2101      	movs	r1, #1
 80067de:	2002      	movs	r0, #2
 80067e0:	f018 fe08 	bl	801f3f4 <traceIF_uartPrint>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_RESET);
 80067e4:	2200      	movs	r2, #0
 80067e6:	f44f 7180 	mov.w	r1, #256	; 0x100
 80067ea:	4805      	ldr	r0, [pc, #20]	; (8006800 <SysCtrl_TYPE1SC_request_suspend_channel+0x9c>)
 80067ec:	f001 f95b 	bl	8007aa6 <HAL_GPIO_WritePin>
}
 80067f0:	2000      	movs	r0, #0
 80067f2:	bd38      	pop	{r3, r4, r5, pc}
 80067f4:	0802d9e0 	.word	0x0802d9e0
 80067f8:	200048dc 	.word	0x200048dc
 80067fc:	0802da18 	.word	0x0802da18
 8006800:	48000800 	.word	0x48000800

08006804 <SysCtrl_TYPE1SC_complete_suspend_channel>:
{
 8006804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  PRINT_DBG("enter modem channel suspend complete")
 8006806:	4d45      	ldr	r5, [pc, #276]	; (800691c <SysCtrl_TYPE1SC_complete_suspend_channel+0x118>)
 8006808:	4c45      	ldr	r4, [pc, #276]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 800680a:	f105 0630 	add.w	r6, r5, #48	; 0x30
 800680e:	46ac      	mov	ip, r5
 8006810:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006814:	6020      	str	r0, [r4, #0]
 8006816:	6061      	str	r1, [r4, #4]
 8006818:	60a2      	str	r2, [r4, #8]
 800681a:	60e3      	str	r3, [r4, #12]
 800681c:	4665      	mov	r5, ip
 800681e:	3410      	adds	r4, #16
 8006820:	45b4      	cmp	ip, r6
 8006822:	d1f4      	bne.n	800680e <SysCtrl_TYPE1SC_complete_suspend_channel+0xa>
 8006824:	f8dc 0000 	ldr.w	r0, [ip]
 8006828:	6020      	str	r0, [r4, #0]
 800682a:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800682e:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8006832:	80a2      	strh	r2, [r4, #4]
 8006834:	71a3      	strb	r3, [r4, #6]
 8006836:	4c3a      	ldr	r4, [pc, #232]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 8006838:	4620      	mov	r0, r4
 800683a:	f018 fd76 	bl	801f32a <crs_strlen>
 800683e:	b283      	uxth	r3, r0
 8006840:	4622      	mov	r2, r4
 8006842:	2102      	movs	r1, #2
 8006844:	4608      	mov	r0, r1
 8006846:	f018 fdb3 	bl	801f3b0 <traceIF_itmPrint>
 800684a:	4620      	mov	r0, r4
 800684c:	f018 fd6d 	bl	801f32a <crs_strlen>
 8006850:	b283      	uxth	r3, r0
 8006852:	4622      	mov	r2, r4
 8006854:	2102      	movs	r1, #2
 8006856:	4608      	mov	r0, r1
 8006858:	f018 fdcc 	bl	801f3f4 <traceIF_uartPrint>
  HAL_NVIC_DisableIRQ(MODEM_UART_IRQN);
 800685c:	2027      	movs	r0, #39	; 0x27
 800685e:	f000 ff65 	bl	800772c <HAL_NVIC_DisableIRQ>
  if (HAL_UART_DeInit(&MODEM_UART_HANDLE) != HAL_OK)
 8006862:	4830      	ldr	r0, [pc, #192]	; (8006924 <SysCtrl_TYPE1SC_complete_suspend_channel+0x120>)
 8006864:	f003 fbc0 	bl	8009fe8 <HAL_UART_DeInit>
 8006868:	4607      	mov	r7, r0
 800686a:	b370      	cbz	r0, 80068ca <SysCtrl_TYPE1SC_complete_suspend_channel+0xc6>
    PRINT_ERR("HAL_UART_DeInit error")
 800686c:	4c2e      	ldr	r4, [pc, #184]	; (8006928 <SysCtrl_TYPE1SC_complete_suspend_channel+0x124>)
 800686e:	4d2c      	ldr	r5, [pc, #176]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 8006870:	f104 0620 	add.w	r6, r4, #32
 8006874:	46a4      	mov	ip, r4
 8006876:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800687a:	6028      	str	r0, [r5, #0]
 800687c:	6069      	str	r1, [r5, #4]
 800687e:	60aa      	str	r2, [r5, #8]
 8006880:	60eb      	str	r3, [r5, #12]
 8006882:	4664      	mov	r4, ip
 8006884:	3510      	adds	r5, #16
 8006886:	45b4      	cmp	ip, r6
 8006888:	d1f4      	bne.n	8006874 <SysCtrl_TYPE1SC_complete_suspend_channel+0x70>
 800688a:	cc07      	ldmia	r4!, {r0, r1, r2}
 800688c:	6028      	str	r0, [r5, #0]
 800688e:	6069      	str	r1, [r5, #4]
 8006890:	60aa      	str	r2, [r5, #8]
 8006892:	8823      	ldrh	r3, [r4, #0]
 8006894:	81ab      	strh	r3, [r5, #12]
 8006896:	4c22      	ldr	r4, [pc, #136]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 8006898:	4620      	mov	r0, r4
 800689a:	f018 fd46 	bl	801f32a <crs_strlen>
 800689e:	b283      	uxth	r3, r0
 80068a0:	4622      	mov	r2, r4
 80068a2:	2110      	movs	r1, #16
 80068a4:	2002      	movs	r0, #2
 80068a6:	f018 fd83 	bl	801f3b0 <traceIF_itmPrint>
 80068aa:	4620      	mov	r0, r4
 80068ac:	f018 fd3d 	bl	801f32a <crs_strlen>
 80068b0:	b283      	uxth	r3, r0
 80068b2:	4622      	mov	r2, r4
 80068b4:	2110      	movs	r1, #16
 80068b6:	2002      	movs	r0, #2
 80068b8:	f018 fd9c 	bl	801f3f4 <traceIF_uartPrint>
    retval = SCSTATUS_ERROR;
 80068bc:	2701      	movs	r7, #1
  TYPE1SC_LP_disable_modem_uart();
 80068be:	f7ff fc7f 	bl	80061c0 <TYPE1SC_LP_disable_modem_uart>
  enable_RING_wait_for_rising();
 80068c2:	f7ff fd59 	bl	8006378 <enable_RING_wait_for_rising>
}
 80068c6:	4638      	mov	r0, r7
 80068c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_DBG("modem channel closed")
 80068ca:	4e18      	ldr	r6, [pc, #96]	; (800692c <SysCtrl_TYPE1SC_complete_suspend_channel+0x128>)
 80068cc:	4c14      	ldr	r4, [pc, #80]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 80068ce:	f106 0c20 	add.w	ip, r6, #32
 80068d2:	4635      	mov	r5, r6
 80068d4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80068d6:	6020      	str	r0, [r4, #0]
 80068d8:	6061      	str	r1, [r4, #4]
 80068da:	60a2      	str	r2, [r4, #8]
 80068dc:	60e3      	str	r3, [r4, #12]
 80068de:	462e      	mov	r6, r5
 80068e0:	3410      	adds	r4, #16
 80068e2:	4565      	cmp	r5, ip
 80068e4:	d1f5      	bne.n	80068d2 <SysCtrl_TYPE1SC_complete_suspend_channel+0xce>
 80068e6:	6828      	ldr	r0, [r5, #0]
 80068e8:	6020      	str	r0, [r4, #0]
 80068ea:	88aa      	ldrh	r2, [r5, #4]
 80068ec:	79ab      	ldrb	r3, [r5, #6]
 80068ee:	80a2      	strh	r2, [r4, #4]
 80068f0:	71a3      	strb	r3, [r4, #6]
 80068f2:	4c0b      	ldr	r4, [pc, #44]	; (8006920 <SysCtrl_TYPE1SC_complete_suspend_channel+0x11c>)
 80068f4:	4620      	mov	r0, r4
 80068f6:	f018 fd18 	bl	801f32a <crs_strlen>
 80068fa:	b283      	uxth	r3, r0
 80068fc:	4622      	mov	r2, r4
 80068fe:	2102      	movs	r1, #2
 8006900:	4608      	mov	r0, r1
 8006902:	f018 fd55 	bl	801f3b0 <traceIF_itmPrint>
 8006906:	4620      	mov	r0, r4
 8006908:	f018 fd0f 	bl	801f32a <crs_strlen>
 800690c:	b283      	uxth	r3, r0
 800690e:	4622      	mov	r2, r4
 8006910:	2102      	movs	r1, #2
 8006912:	4608      	mov	r0, r1
 8006914:	f018 fd6e 	bl	801f3f4 <traceIF_uartPrint>
 8006918:	e7d1      	b.n	80068be <SysCtrl_TYPE1SC_complete_suspend_channel+0xba>
 800691a:	bf00      	nop
 800691c:	0802da70 	.word	0x0802da70
 8006920:	200048dc 	.word	0x200048dc
 8006924:	20000d04 	.word	0x20000d04
 8006928:	0802d8b4 	.word	0x0802d8b4
 800692c:	0802d8e4 	.word	0x0802d8e4

08006930 <enable_UART>:

  return (retval);
}

sysctrl_status_t enable_UART(IPC_Handle_t *ipc_handle, SysCtrl_TYPE1SC_HwFlowCtrl_t hwFC_status)
{
 8006930:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006934:	b086      	sub	sp, #24
 8006936:	4607      	mov	r7, r0
 8006938:	460e      	mov	r6, r1
  sysctrl_status_t retval = SCSTATUS_OK;
  PRINT_DBG("enter enable_UART")
 800693a:	4d87      	ldr	r5, [pc, #540]	; (8006b58 <enable_UART+0x228>)
 800693c:	4c87      	ldr	r4, [pc, #540]	; (8006b5c <enable_UART+0x22c>)
 800693e:	f105 0e20 	add.w	lr, r5, #32
 8006942:	46ac      	mov	ip, r5
 8006944:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006948:	6020      	str	r0, [r4, #0]
 800694a:	6061      	str	r1, [r4, #4]
 800694c:	60a2      	str	r2, [r4, #8]
 800694e:	60e3      	str	r3, [r4, #12]
 8006950:	4665      	mov	r5, ip
 8006952:	3410      	adds	r4, #16
 8006954:	45f4      	cmp	ip, lr
 8006956:	d1f4      	bne.n	8006942 <enable_UART+0x12>
 8006958:	f8dc 0000 	ldr.w	r0, [ip]
 800695c:	6020      	str	r0, [r4, #0]
 800695e:	4c7f      	ldr	r4, [pc, #508]	; (8006b5c <enable_UART+0x22c>)
 8006960:	4620      	mov	r0, r4
 8006962:	f018 fce2 	bl	801f32a <crs_strlen>
 8006966:	b283      	uxth	r3, r0
 8006968:	4622      	mov	r2, r4
 800696a:	2102      	movs	r1, #2
 800696c:	4608      	mov	r0, r1
 800696e:	f018 fd1f 	bl	801f3b0 <traceIF_itmPrint>
 8006972:	4620      	mov	r0, r4
 8006974:	f018 fcd9 	bl	801f32a <crs_strlen>
 8006978:	b283      	uxth	r3, r0
 800697a:	4622      	mov	r2, r4
 800697c:	2102      	movs	r1, #2
 800697e:	4608      	mov	r0, r1
 8006980:	f018 fd38 	bl	801f3f4 <traceIF_uartPrint>

  /* UART deinitialization */
  if (HAL_UART_DeInit(&MODEM_UART_HANDLE) != HAL_OK)
 8006984:	4876      	ldr	r0, [pc, #472]	; (8006b60 <enable_UART+0x230>)
 8006986:	f003 fb2f 	bl	8009fe8 <HAL_UART_DeInit>
 800698a:	b368      	cbz	r0, 80069e8 <enable_UART+0xb8>
  {
    PRINT_ERR("HAL_UART_DeInit error")
 800698c:	4c75      	ldr	r4, [pc, #468]	; (8006b64 <enable_UART+0x234>)
 800698e:	4d73      	ldr	r5, [pc, #460]	; (8006b5c <enable_UART+0x22c>)
 8006990:	f104 0620 	add.w	r6, r4, #32
 8006994:	46a4      	mov	ip, r4
 8006996:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800699a:	6028      	str	r0, [r5, #0]
 800699c:	6069      	str	r1, [r5, #4]
 800699e:	60aa      	str	r2, [r5, #8]
 80069a0:	60eb      	str	r3, [r5, #12]
 80069a2:	4664      	mov	r4, ip
 80069a4:	3510      	adds	r5, #16
 80069a6:	45b4      	cmp	ip, r6
 80069a8:	d1f4      	bne.n	8006994 <enable_UART+0x64>
 80069aa:	cc07      	ldmia	r4!, {r0, r1, r2}
 80069ac:	6028      	str	r0, [r5, #0]
 80069ae:	6069      	str	r1, [r5, #4]
 80069b0:	60aa      	str	r2, [r5, #8]
 80069b2:	8823      	ldrh	r3, [r4, #0]
 80069b4:	81ab      	strh	r3, [r5, #12]
 80069b6:	4c69      	ldr	r4, [pc, #420]	; (8006b5c <enable_UART+0x22c>)
 80069b8:	4620      	mov	r0, r4
 80069ba:	f018 fcb6 	bl	801f32a <crs_strlen>
 80069be:	b283      	uxth	r3, r0
 80069c0:	4622      	mov	r2, r4
 80069c2:	2110      	movs	r1, #16
 80069c4:	2002      	movs	r0, #2
 80069c6:	f018 fcf3 	bl	801f3b0 <traceIF_itmPrint>
 80069ca:	4620      	mov	r0, r4
 80069cc:	f018 fcad 	bl	801f32a <crs_strlen>
 80069d0:	b283      	uxth	r3, r0
 80069d2:	4622      	mov	r2, r4
 80069d4:	2110      	movs	r1, #16
 80069d6:	2002      	movs	r0, #2
 80069d8:	f018 fd0c 	bl	801f3f4 <traceIF_uartPrint>
    retval = SCSTATUS_ERROR;
 80069dc:	f04f 0801 	mov.w	r8, #1
      retval = SCSTATUS_ERROR;
    }
  }

  return (retval);
}
 80069e0:	4640      	mov	r0, r8
 80069e2:	b006      	add	sp, #24
 80069e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    SysCtrl_delay(50U);
 80069e8:	2032      	movs	r0, #50	; 0x32
 80069ea:	f00e fb57 	bl	801509c <SysCtrl_delay>
    MODEM_UART_HANDLE.Instance = MODEM_UART_INSTANCE;
 80069ee:	4b5c      	ldr	r3, [pc, #368]	; (8006b60 <enable_UART+0x230>)
 80069f0:	4a5d      	ldr	r2, [pc, #372]	; (8006b68 <enable_UART+0x238>)
 80069f2:	601a      	str	r2, [r3, #0]
    MODEM_UART_HANDLE.Init.BaudRate = MODEM_UART_BAUDRATE;
 80069f4:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80069f8:	605a      	str	r2, [r3, #4]
    MODEM_UART_HANDLE.Init.WordLength = MODEM_UART_WORDLENGTH;
 80069fa:	2200      	movs	r2, #0
 80069fc:	609a      	str	r2, [r3, #8]
    MODEM_UART_HANDLE.Init.StopBits = MODEM_UART_STOPBITS;
 80069fe:	60da      	str	r2, [r3, #12]
    MODEM_UART_HANDLE.Init.Parity = MODEM_UART_PARITY;
 8006a00:	611a      	str	r2, [r3, #16]
    MODEM_UART_HANDLE.Init.Mode = MODEM_UART_MODE;
 8006a02:	220c      	movs	r2, #12
 8006a04:	615a      	str	r2, [r3, #20]
    if (hwFC_status == SYSCTRL_HW_FLOW_CONTROL_NONE)
 8006a06:	2e00      	cmp	r6, #0
 8006a08:	d155      	bne.n	8006ab6 <enable_UART+0x186>
      MODEM_UART_HANDLE.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8006a0a:	2200      	movs	r2, #0
 8006a0c:	619a      	str	r2, [r3, #24]
    PRINT_INFO("UART config: setting HW Flow Control to %d",
 8006a0e:	4c54      	ldr	r4, [pc, #336]	; (8006b60 <enable_UART+0x230>)
 8006a10:	69a2      	ldr	r2, [r4, #24]
 8006a12:	4d52      	ldr	r5, [pc, #328]	; (8006b5c <enable_UART+0x22c>)
 8006a14:	3a00      	subs	r2, #0
 8006a16:	bf18      	it	ne
 8006a18:	2201      	movne	r2, #1
 8006a1a:	4954      	ldr	r1, [pc, #336]	; (8006b6c <enable_UART+0x23c>)
 8006a1c:	4628      	mov	r0, r5
 8006a1e:	f01f ff13 	bl	8026848 <sprintf>
 8006a22:	4628      	mov	r0, r5
 8006a24:	f018 fc81 	bl	801f32a <crs_strlen>
 8006a28:	b283      	uxth	r3, r0
 8006a2a:	462a      	mov	r2, r5
 8006a2c:	2101      	movs	r1, #1
 8006a2e:	2002      	movs	r0, #2
 8006a30:	f018 fcbe 	bl	801f3b0 <traceIF_itmPrint>
 8006a34:	4628      	mov	r0, r5
 8006a36:	f018 fc78 	bl	801f32a <crs_strlen>
 8006a3a:	b283      	uxth	r3, r0
 8006a3c:	462a      	mov	r2, r5
 8006a3e:	2101      	movs	r1, #1
 8006a40:	2002      	movs	r0, #2
 8006a42:	f018 fcd7 	bl	801f3f4 <traceIF_uartPrint>
    MODEM_UART_HANDLE.Init.OverSampling = UART_OVERSAMPLING_16;
 8006a46:	2300      	movs	r3, #0
 8006a48:	61e3      	str	r3, [r4, #28]
    MODEM_UART_HANDLE.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8006a4a:	6223      	str	r3, [r4, #32]
    MODEM_UART_HANDLE.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8006a4c:	6263      	str	r3, [r4, #36]	; 0x24
    if (HAL_UART_Init(&MODEM_UART_HANDLE) == HAL_OK)
 8006a4e:	4620      	mov	r0, r4
 8006a50:	f003 ffcb 	bl	800a9ea <HAL_UART_Init>
 8006a54:	4680      	mov	r8, r0
 8006a56:	2800      	cmp	r0, #0
 8006a58:	d152      	bne.n	8006b00 <enable_UART+0x1d0>
      if (MODEM_UART_HANDLE.Init.HwFlowCtl == UART_HWCONTROL_NONE)
 8006a5a:	69a3      	ldr	r3, [r4, #24]
 8006a5c:	2b00      	cmp	r3, #0
 8006a5e:	d036      	beq.n	8006ace <enable_UART+0x19e>
      if (ipc_handle != NULL)
 8006a60:	b32f      	cbz	r7, 8006aae <enable_UART+0x17e>
        PRINT_DBG("call IPC_reset")
 8006a62:	4e43      	ldr	r6, [pc, #268]	; (8006b70 <enable_UART+0x240>)
 8006a64:	4d3d      	ldr	r5, [pc, #244]	; (8006b5c <enable_UART+0x22c>)
 8006a66:	f106 0c20 	add.w	ip, r6, #32
 8006a6a:	4634      	mov	r4, r6
 8006a6c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006a6e:	6028      	str	r0, [r5, #0]
 8006a70:	6069      	str	r1, [r5, #4]
 8006a72:	60aa      	str	r2, [r5, #8]
 8006a74:	60eb      	str	r3, [r5, #12]
 8006a76:	4626      	mov	r6, r4
 8006a78:	3510      	adds	r5, #16
 8006a7a:	4564      	cmp	r4, ip
 8006a7c:	d1f5      	bne.n	8006a6a <enable_UART+0x13a>
 8006a7e:	7823      	ldrb	r3, [r4, #0]
 8006a80:	702b      	strb	r3, [r5, #0]
 8006a82:	4c36      	ldr	r4, [pc, #216]	; (8006b5c <enable_UART+0x22c>)
 8006a84:	4620      	mov	r0, r4
 8006a86:	f018 fc50 	bl	801f32a <crs_strlen>
 8006a8a:	b283      	uxth	r3, r0
 8006a8c:	4622      	mov	r2, r4
 8006a8e:	2102      	movs	r1, #2
 8006a90:	4608      	mov	r0, r1
 8006a92:	f018 fc8d 	bl	801f3b0 <traceIF_itmPrint>
 8006a96:	4620      	mov	r0, r4
 8006a98:	f018 fc47 	bl	801f32a <crs_strlen>
 8006a9c:	b283      	uxth	r3, r0
 8006a9e:	4622      	mov	r2, r4
 8006aa0:	2102      	movs	r1, #2
 8006aa2:	4608      	mov	r0, r1
 8006aa4:	f018 fca6 	bl	801f3f4 <traceIF_uartPrint>
        (void) IPC_reset(ipc_handle);
 8006aa8:	4638      	mov	r0, r7
 8006aaa:	f017 fd56 	bl	801e55a <IPC_reset>
      HAL_NVIC_EnableIRQ(MODEM_UART_IRQN);
 8006aae:	2027      	movs	r0, #39	; 0x27
 8006ab0:	f000 fe2e 	bl	8007710 <HAL_NVIC_EnableIRQ>
 8006ab4:	e794      	b.n	80069e0 <enable_UART+0xb0>
    else if (hwFC_status == SYSCTRL_HW_FLOW_CONTROL_RTS_CTS)
 8006ab6:	2e01      	cmp	r6, #1
 8006ab8:	d004      	beq.n	8006ac4 <enable_UART+0x194>
      MODEM_UART_HANDLE.Init.HwFlowCtl = MODEM_UART_HWFLOWCTRL;
 8006aba:	4b29      	ldr	r3, [pc, #164]	; (8006b60 <enable_UART+0x230>)
 8006abc:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006ac0:	619a      	str	r2, [r3, #24]
 8006ac2:	e7a4      	b.n	8006a0e <enable_UART+0xde>
      MODEM_UART_HANDLE.Init.HwFlowCtl = UART_HWCONTROL_RTS_CTS;
 8006ac4:	4b26      	ldr	r3, [pc, #152]	; (8006b60 <enable_UART+0x230>)
 8006ac6:	f44f 7240 	mov.w	r2, #768	; 0x300
 8006aca:	619a      	str	r2, [r3, #24]
 8006acc:	e79f      	b.n	8006a0e <enable_UART+0xde>
        GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006ace:	2400      	movs	r4, #0
 8006ad0:	9401      	str	r4, [sp, #4]
 8006ad2:	9402      	str	r4, [sp, #8]
 8006ad4:	9403      	str	r4, [sp, #12]
 8006ad6:	9404      	str	r4, [sp, #16]
 8006ad8:	9405      	str	r4, [sp, #20]
        GPIO_InitStruct.Pin = MODEM_CTS_PIN;
 8006ada:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006ade:	9301      	str	r3, [sp, #4]
        GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006ae0:	2503      	movs	r5, #3
 8006ae2:	9502      	str	r5, [sp, #8]
        HAL_GPIO_Init(MODEM_CTS_GPIO_PORT, &GPIO_InitStruct);
 8006ae4:	a901      	add	r1, sp, #4
 8006ae6:	4823      	ldr	r0, [pc, #140]	; (8006b74 <enable_UART+0x244>)
 8006ae8:	f000 fe7e 	bl	80077e8 <HAL_GPIO_Init>
        GPIO_InitStruct.Pin = MODEM_RTS_PIN;
 8006aec:	2304      	movs	r3, #4
 8006aee:	9301      	str	r3, [sp, #4]
        GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8006af0:	9502      	str	r5, [sp, #8]
        GPIO_InitStruct.Pull = GPIO_NOPULL;
 8006af2:	9403      	str	r4, [sp, #12]
        HAL_GPIO_Init(MODEM_RTS_GPIO_PORT, &GPIO_InitStruct);
 8006af4:	eb0d 0103 	add.w	r1, sp, r3
 8006af8:	481f      	ldr	r0, [pc, #124]	; (8006b78 <enable_UART+0x248>)
 8006afa:	f000 fe75 	bl	80077e8 <HAL_GPIO_Init>
 8006afe:	e7af      	b.n	8006a60 <enable_UART+0x130>
      PRINT_ERR("error in HAL_UART_Init")
 8006b00:	4d1e      	ldr	r5, [pc, #120]	; (8006b7c <enable_UART+0x24c>)
 8006b02:	4c16      	ldr	r4, [pc, #88]	; (8006b5c <enable_UART+0x22c>)
 8006b04:	f105 0720 	add.w	r7, r5, #32
 8006b08:	462e      	mov	r6, r5
 8006b0a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8006b0c:	6020      	str	r0, [r4, #0]
 8006b0e:	6061      	str	r1, [r4, #4]
 8006b10:	60a2      	str	r2, [r4, #8]
 8006b12:	60e3      	str	r3, [r4, #12]
 8006b14:	4635      	mov	r5, r6
 8006b16:	3410      	adds	r4, #16
 8006b18:	42be      	cmp	r6, r7
 8006b1a:	d1f5      	bne.n	8006b08 <enable_UART+0x1d8>
 8006b1c:	cd07      	ldmia	r5!, {r0, r1, r2}
 8006b1e:	6020      	str	r0, [r4, #0]
 8006b20:	6061      	str	r1, [r4, #4]
 8006b22:	60a2      	str	r2, [r4, #8]
 8006b24:	882a      	ldrh	r2, [r5, #0]
 8006b26:	78ab      	ldrb	r3, [r5, #2]
 8006b28:	81a2      	strh	r2, [r4, #12]
 8006b2a:	73a3      	strb	r3, [r4, #14]
 8006b2c:	4c0b      	ldr	r4, [pc, #44]	; (8006b5c <enable_UART+0x22c>)
 8006b2e:	4620      	mov	r0, r4
 8006b30:	f018 fbfb 	bl	801f32a <crs_strlen>
 8006b34:	b283      	uxth	r3, r0
 8006b36:	4622      	mov	r2, r4
 8006b38:	2110      	movs	r1, #16
 8006b3a:	2002      	movs	r0, #2
 8006b3c:	f018 fc38 	bl	801f3b0 <traceIF_itmPrint>
 8006b40:	4620      	mov	r0, r4
 8006b42:	f018 fbf2 	bl	801f32a <crs_strlen>
 8006b46:	b283      	uxth	r3, r0
 8006b48:	4622      	mov	r2, r4
 8006b4a:	2110      	movs	r1, #16
 8006b4c:	2002      	movs	r0, #2
 8006b4e:	f018 fc51 	bl	801f3f4 <traceIF_uartPrint>
      retval = SCSTATUS_ERROR;
 8006b52:	f04f 0801 	mov.w	r8, #1
 8006b56:	e743      	b.n	80069e0 <enable_UART+0xb0>
 8006b58:	0802daa8 	.word	0x0802daa8
 8006b5c:	200048dc 	.word	0x200048dc
 8006b60:	20000d04 	.word	0x20000d04
 8006b64:	0802d8b4 	.word	0x0802d8b4
 8006b68:	40004800 	.word	0x40004800
 8006b6c:	0802dacc 	.word	0x0802dacc
 8006b70:	0802db0c 	.word	0x0802db0c
 8006b74:	48000400 	.word	0x48000400
 8006b78:	48000c00 	.word	0x48000c00
 8006b7c:	0802db30 	.word	0x0802db30

08006b80 <SysCtrl_TYPE1SC_open_channel>:
{
 8006b80:	b530      	push	{r4, r5, lr}
 8006b82:	b087      	sub	sp, #28
  PRINT_DBG("enter SysCtrl_TYPE1SC_open_channel")
 8006b84:	4d27      	ldr	r5, [pc, #156]	; (8006c24 <SysCtrl_TYPE1SC_open_channel+0xa4>)
 8006b86:	4c28      	ldr	r4, [pc, #160]	; (8006c28 <SysCtrl_TYPE1SC_open_channel+0xa8>)
 8006b88:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8006b8c:	46ac      	mov	ip, r5
 8006b8e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006b92:	6020      	str	r0, [r4, #0]
 8006b94:	6061      	str	r1, [r4, #4]
 8006b96:	60a2      	str	r2, [r4, #8]
 8006b98:	60e3      	str	r3, [r4, #12]
 8006b9a:	4665      	mov	r5, ip
 8006b9c:	3410      	adds	r4, #16
 8006b9e:	45f4      	cmp	ip, lr
 8006ba0:	d1f4      	bne.n	8006b8c <SysCtrl_TYPE1SC_open_channel+0xc>
 8006ba2:	f8dc 0000 	ldr.w	r0, [ip]
 8006ba6:	6020      	str	r0, [r4, #0]
 8006ba8:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8006bac:	7123      	strb	r3, [r4, #4]
 8006bae:	4c1e      	ldr	r4, [pc, #120]	; (8006c28 <SysCtrl_TYPE1SC_open_channel+0xa8>)
 8006bb0:	4620      	mov	r0, r4
 8006bb2:	f018 fbba 	bl	801f32a <crs_strlen>
 8006bb6:	b283      	uxth	r3, r0
 8006bb8:	4622      	mov	r2, r4
 8006bba:	2102      	movs	r1, #2
 8006bbc:	4608      	mov	r0, r1
 8006bbe:	f018 fbf7 	bl	801f3b0 <traceIF_itmPrint>
 8006bc2:	4620      	mov	r0, r4
 8006bc4:	f018 fbb1 	bl	801f32a <crs_strlen>
 8006bc8:	b283      	uxth	r3, r0
 8006bca:	4622      	mov	r2, r4
 8006bcc:	2102      	movs	r1, #2
 8006bce:	4608      	mov	r0, r1
 8006bd0:	f018 fc10 	bl	801f3f4 <traceIF_uartPrint>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006bd4:	2400      	movs	r4, #0
 8006bd6:	9401      	str	r4, [sp, #4]
 8006bd8:	9402      	str	r4, [sp, #8]
 8006bda:	9403      	str	r4, [sp, #12]
 8006bdc:	9404      	str	r4, [sp, #16]
 8006bde:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 8006be0:	2320      	movs	r3, #32
 8006be2:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8006be4:	2302      	movs	r3, #2
 8006be6:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 8006be8:	4d10      	ldr	r5, [pc, #64]	; (8006c2c <SysCtrl_TYPE1SC_open_channel+0xac>)
 8006bea:	a901      	add	r1, sp, #4
 8006bec:	4628      	mov	r0, r5
 8006bee:	f000 fdfb 	bl	80077e8 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_SET);
 8006bf2:	2201      	movs	r2, #1
 8006bf4:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006bf8:	4628      	mov	r0, r5
 8006bfa:	f000 ff54 	bl	8007aa6 <HAL_GPIO_WritePin>
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006bfe:	2120      	movs	r1, #32
 8006c00:	480a      	ldr	r0, [pc, #40]	; (8006c2c <SysCtrl_TYPE1SC_open_channel+0xac>)
 8006c02:	f000 ff49 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006c06:	b938      	cbnz	r0, 8006c18 <SysCtrl_TYPE1SC_open_channel+0x98>
 8006c08:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 8006c0c:	d204      	bcs.n	8006c18 <SysCtrl_TYPE1SC_open_channel+0x98>
    SysCtrl_delay(count_delay);
 8006c0e:	200a      	movs	r0, #10
 8006c10:	f00e fa44 	bl	801509c <SysCtrl_delay>
    count++;
 8006c14:	3401      	adds	r4, #1
 8006c16:	e7f2      	b.n	8006bfe <SysCtrl_TYPE1SC_open_channel+0x7e>
  retval = enable_UART(NULL, SYSCTRL_HW_FLOW_CONTROL_USER_SETTING);
 8006c18:	2102      	movs	r1, #2
 8006c1a:	2000      	movs	r0, #0
 8006c1c:	f7ff fe88 	bl	8006930 <enable_UART>
}
 8006c20:	b007      	add	sp, #28
 8006c22:	bd30      	pop	{r4, r5, pc}
 8006c24:	0802db60 	.word	0x0802db60
 8006c28:	200048dc 	.word	0x200048dc
 8006c2c:	48000800 	.word	0x48000800

08006c30 <HIFC_A_modem_resume>:
{
 8006c30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006c34:	b086      	sub	sp, #24
 8006c36:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006c38:	2400      	movs	r4, #0
 8006c3a:	9401      	str	r4, [sp, #4]
 8006c3c:	9402      	str	r4, [sp, #8]
 8006c3e:	9403      	str	r4, [sp, #12]
 8006c40:	9404      	str	r4, [sp, #16]
 8006c42:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Pin = MODEM_TX_PIN;
 8006c44:	2710      	movs	r7, #16
 8006c46:	9701      	str	r7, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8006c48:	f04f 0801 	mov.w	r8, #1
 8006c4c:	f8cd 8008 	str.w	r8, [sp, #8]
  HAL_GPIO_Init(MODEM_TX_GPIO_PORT, &GPIO_InitStruct);
 8006c50:	4e14      	ldr	r6, [pc, #80]	; (8006ca4 <HIFC_A_modem_resume+0x74>)
 8006c52:	a901      	add	r1, sp, #4
 8006c54:	4630      	mov	r0, r6
 8006c56:	f000 fdc7 	bl	80077e8 <HAL_GPIO_Init>
  HAL_GPIO_WritePin(MODEM_TX_GPIO_PORT, MODEM_TX_PIN, GPIO_PIN_SET);
 8006c5a:	4642      	mov	r2, r8
 8006c5c:	4639      	mov	r1, r7
 8006c5e:	4630      	mov	r0, r6
 8006c60:	f000 ff21 	bl	8007aa6 <HAL_GPIO_WritePin>
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006c64:	2120      	movs	r1, #32
 8006c66:	480f      	ldr	r0, [pc, #60]	; (8006ca4 <HIFC_A_modem_resume+0x74>)
 8006c68:	f000 ff16 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006c6c:	b938      	cbnz	r0, 8006c7e <HIFC_A_modem_resume+0x4e>
 8006c6e:	f5b4 7ffa 	cmp.w	r4, #500	; 0x1f4
 8006c72:	d204      	bcs.n	8006c7e <HIFC_A_modem_resume+0x4e>
    SysCtrl_delay(count_delay);
 8006c74:	200a      	movs	r0, #10
 8006c76:	f00e fa11 	bl	801509c <SysCtrl_delay>
    count++;
 8006c7a:	3401      	adds	r4, #1
 8006c7c:	e7f2      	b.n	8006c64 <HIFC_A_modem_resume+0x34>
  retval = enable_UART(ipc_handle, SYSCTRL_HW_FLOW_CONTROL_USER_SETTING);
 8006c7e:	2102      	movs	r1, #2
 8006c80:	4628      	mov	r0, r5
 8006c82:	f7ff fe55 	bl	8006930 <enable_UART>
 8006c86:	4604      	mov	r4, r0
  SysCtrl_delay(1000U);
 8006c88:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006c8c:	f00e fa06 	bl	801509c <SysCtrl_delay>
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_SET);
 8006c90:	2201      	movs	r2, #1
 8006c92:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006c96:	4803      	ldr	r0, [pc, #12]	; (8006ca4 <HIFC_A_modem_resume+0x74>)
 8006c98:	f000 ff05 	bl	8007aa6 <HAL_GPIO_WritePin>
}
 8006c9c:	4620      	mov	r0, r4
 8006c9e:	b006      	add	sp, #24
 8006ca0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006ca4:	48000800 	.word	0x48000800

08006ca8 <HIFC_A_host_resume>:
{
 8006ca8:	b538      	push	{r3, r4, r5, lr}
 8006caa:	4605      	mov	r5, r0
  HAL_GPIO_WritePin(MODEM_DTR_GPIO_PORT, MODEM_DTR_PIN, GPIO_PIN_SET);
 8006cac:	2201      	movs	r2, #1
 8006cae:	f44f 7180 	mov.w	r1, #256	; 0x100
 8006cb2:	4814      	ldr	r0, [pc, #80]	; (8006d04 <HIFC_A_host_resume+0x5c>)
 8006cb4:	f000 fef7 	bl	8007aa6 <HAL_GPIO_WritePin>
  uint32_t count = 0U;
 8006cb8:	2400      	movs	r4, #0
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006cba:	e003      	b.n	8006cc4 <HIFC_A_host_resume+0x1c>
    SysCtrl_delay(count_delay);
 8006cbc:	200a      	movs	r0, #10
 8006cbe:	f00e f9ed 	bl	801509c <SysCtrl_delay>
    count++;
 8006cc2:	3401      	adds	r4, #1
  while ((HAL_GPIO_ReadPin(MODEM_RX_GPIO_PORT, MODEM_RX_PIN) == GPIO_PIN_RESET) &&
 8006cc4:	2120      	movs	r1, #32
 8006cc6:	480f      	ldr	r0, [pc, #60]	; (8006d04 <HIFC_A_host_resume+0x5c>)
 8006cc8:	f000 fee6 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006ccc:	b910      	cbnz	r0, 8006cd4 <HIFC_A_host_resume+0x2c>
 8006cce:	f5b4 7f7a 	cmp.w	r4, #1000	; 0x3e8
 8006cd2:	d3f3      	bcc.n	8006cbc <HIFC_A_host_resume+0x14>
  retval = enable_UART(ipc_handle, SYSCTRL_HW_FLOW_CONTROL_USER_SETTING);
 8006cd4:	2102      	movs	r1, #2
 8006cd6:	4628      	mov	r0, r5
 8006cd8:	f7ff fe2a 	bl	8006930 <enable_UART>
 8006cdc:	4605      	mov	r5, r0
  count = 0U;
 8006cde:	2400      	movs	r4, #0
  while ((HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN) == GPIO_PIN_RESET) &&
 8006ce0:	e003      	b.n	8006cea <HIFC_A_host_resume+0x42>
    SysCtrl_delay(count_delay);
 8006ce2:	200a      	movs	r0, #10
 8006ce4:	f00e f9da 	bl	801509c <SysCtrl_delay>
    count++;
 8006ce8:	3401      	adds	r4, #1
  while ((HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN) == GPIO_PIN_RESET) &&
 8006cea:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8006cee:	4806      	ldr	r0, [pc, #24]	; (8006d08 <HIFC_A_host_resume+0x60>)
 8006cf0:	f000 fed2 	bl	8007a98 <HAL_GPIO_ReadPin>
 8006cf4:	b918      	cbnz	r0, 8006cfe <HIFC_A_host_resume+0x56>
 8006cf6:	f240 53db 	movw	r3, #1499	; 0x5db
 8006cfa:	429c      	cmp	r4, r3
 8006cfc:	d9f1      	bls.n	8006ce2 <HIFC_A_host_resume+0x3a>
}
 8006cfe:	4628      	mov	r0, r5
 8006d00:	bd38      	pop	{r3, r4, r5, pc}
 8006d02:	bf00      	nop
 8006d04:	48000800 	.word	0x48000800
 8006d08:	48000400 	.word	0x48000400

08006d0c <SysCtrl_TYPE1SC_resume_channel>:
{
 8006d0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8006d0e:	b087      	sub	sp, #28
 8006d10:	4606      	mov	r6, r0
 8006d12:	4617      	mov	r7, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8006d14:	2300      	movs	r3, #0
 8006d16:	9301      	str	r3, [sp, #4]
 8006d18:	9302      	str	r3, [sp, #8]
 8006d1a:	9303      	str	r3, [sp, #12]
 8006d1c:	9304      	str	r3, [sp, #16]
 8006d1e:	9305      	str	r3, [sp, #20]
  PRINT_DBG("enter SysCtrl_TYPE1SC_resume_channel")
 8006d20:	4d5a      	ldr	r5, [pc, #360]	; (8006e8c <SysCtrl_TYPE1SC_resume_channel+0x180>)
 8006d22:	4c5b      	ldr	r4, [pc, #364]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006d24:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8006d28:	46ac      	mov	ip, r5
 8006d2a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006d2e:	6020      	str	r0, [r4, #0]
 8006d30:	6061      	str	r1, [r4, #4]
 8006d32:	60a2      	str	r2, [r4, #8]
 8006d34:	60e3      	str	r3, [r4, #12]
 8006d36:	4665      	mov	r5, ip
 8006d38:	3410      	adds	r4, #16
 8006d3a:	45f4      	cmp	ip, lr
 8006d3c:	d1f4      	bne.n	8006d28 <SysCtrl_TYPE1SC_resume_channel+0x1c>
 8006d3e:	f8dc 0000 	ldr.w	r0, [ip]
 8006d42:	6020      	str	r0, [r4, #0]
 8006d44:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8006d48:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8006d4c:	80a2      	strh	r2, [r4, #4]
 8006d4e:	71a3      	strb	r3, [r4, #6]
 8006d50:	4c4f      	ldr	r4, [pc, #316]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006d52:	4620      	mov	r0, r4
 8006d54:	f018 fae9 	bl	801f32a <crs_strlen>
 8006d58:	b283      	uxth	r3, r0
 8006d5a:	4622      	mov	r2, r4
 8006d5c:	2102      	movs	r1, #2
 8006d5e:	4608      	mov	r0, r1
 8006d60:	f018 fb26 	bl	801f3b0 <traceIF_itmPrint>
 8006d64:	4620      	mov	r0, r4
 8006d66:	f018 fae0 	bl	801f32a <crs_strlen>
 8006d6a:	b283      	uxth	r3, r0
 8006d6c:	4622      	mov	r2, r4
 8006d6e:	2102      	movs	r1, #2
 8006d70:	4608      	mov	r0, r1
 8006d72:	f018 fb3f 	bl	801f3f4 <traceIF_uartPrint>
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8006d76:	2300      	movs	r3, #0
 8006d78:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8006d7a:	2302      	movs	r3, #2
 8006d7c:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Pin = MODEM_RX_PIN;
 8006d7e:	2320      	movs	r3, #32
 8006d80:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_RX_GPIO_PORT, &GPIO_InitStruct);
 8006d82:	a901      	add	r1, sp, #4
 8006d84:	4843      	ldr	r0, [pc, #268]	; (8006e94 <SysCtrl_TYPE1SC_resume_channel+0x188>)
 8006d86:	f000 fd2f 	bl	80077e8 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = MODEM_RING_PIN;
 8006d8a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8006d8e:	9301      	str	r3, [sp, #4]
  HAL_GPIO_Init(MODEM_RING_GPIO_PORT, &GPIO_InitStruct);
 8006d90:	a901      	add	r1, sp, #4
 8006d92:	4841      	ldr	r0, [pc, #260]	; (8006e98 <SysCtrl_TYPE1SC_resume_channel+0x18c>)
 8006d94:	f000 fd28 	bl	80077e8 <HAL_GPIO_Init>
  HAL_NVIC_DisableIRQ(MODEM_RING_IRQN);
 8006d98:	2028      	movs	r0, #40	; 0x28
 8006d9a:	f000 fcc7 	bl	800772c <HAL_NVIC_DisableIRQ>
  if (modem_originated == 1U)
 8006d9e:	2f01      	cmp	r7, #1
 8006da0:	d051      	beq.n	8006e46 <SysCtrl_TYPE1SC_resume_channel+0x13a>
    PRINT_FORCE("<< HOST RESUME USECASE >> ")
 8006da2:	4c3b      	ldr	r4, [pc, #236]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006da4:	4d3d      	ldr	r5, [pc, #244]	; (8006e9c <SysCtrl_TYPE1SC_resume_channel+0x190>)
 8006da6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006da8:	6020      	str	r0, [r4, #0]
 8006daa:	6061      	str	r1, [r4, #4]
 8006dac:	60a2      	str	r2, [r4, #8]
 8006dae:	60e3      	str	r3, [r4, #12]
 8006db0:	cd07      	ldmia	r5!, {r0, r1, r2}
 8006db2:	6120      	str	r0, [r4, #16]
 8006db4:	6161      	str	r1, [r4, #20]
 8006db6:	61a2      	str	r2, [r4, #24]
 8006db8:	782b      	ldrb	r3, [r5, #0]
 8006dba:	7723      	strb	r3, [r4, #28]
 8006dbc:	4620      	mov	r0, r4
 8006dbe:	f018 fab4 	bl	801f32a <crs_strlen>
 8006dc2:	b283      	uxth	r3, r0
 8006dc4:	4622      	mov	r2, r4
 8006dc6:	2101      	movs	r1, #1
 8006dc8:	2002      	movs	r0, #2
 8006dca:	f018 faf1 	bl	801f3b0 <traceIF_itmPrint>
 8006dce:	4620      	mov	r0, r4
 8006dd0:	f018 faab 	bl	801f32a <crs_strlen>
 8006dd4:	b282      	uxth	r2, r0
 8006dd6:	4621      	mov	r1, r4
 8006dd8:	2002      	movs	r0, #2
 8006dda:	f018 fb23 	bl	801f424 <traceIF_uartPrintForce>
    retval = HIFC_A_host_resume(ipc_handle);
 8006dde:	4630      	mov	r0, r6
 8006de0:	f7ff ff62 	bl	8006ca8 <HIFC_A_host_resume>
 8006de4:	4606      	mov	r6, r0
  enable_RING_wait_for_falling();
 8006de6:	f7ff faab 	bl	8006340 <enable_RING_wait_for_falling>
  SysCtrl_delay(100U);
 8006dea:	2064      	movs	r0, #100	; 0x64
 8006dec:	f00e f956 	bl	801509c <SysCtrl_delay>
  PRINT_DBG("resume channel OK ")
 8006df0:	4d2b      	ldr	r5, [pc, #172]	; (8006ea0 <SysCtrl_TYPE1SC_resume_channel+0x194>)
 8006df2:	4c27      	ldr	r4, [pc, #156]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006df4:	f105 0720 	add.w	r7, r5, #32
 8006df8:	46ac      	mov	ip, r5
 8006dfa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006dfe:	6020      	str	r0, [r4, #0]
 8006e00:	6061      	str	r1, [r4, #4]
 8006e02:	60a2      	str	r2, [r4, #8]
 8006e04:	60e3      	str	r3, [r4, #12]
 8006e06:	4665      	mov	r5, ip
 8006e08:	3410      	adds	r4, #16
 8006e0a:	45bc      	cmp	ip, r7
 8006e0c:	d1f4      	bne.n	8006df8 <SysCtrl_TYPE1SC_resume_channel+0xec>
 8006e0e:	f8dc 0000 	ldr.w	r0, [ip]
 8006e12:	6020      	str	r0, [r4, #0]
 8006e14:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8006e18:	7123      	strb	r3, [r4, #4]
 8006e1a:	4c1d      	ldr	r4, [pc, #116]	; (8006e90 <SysCtrl_TYPE1SC_resume_channel+0x184>)
 8006e1c:	4620      	mov	r0, r4
 8006e1e:	f018 fa84 	bl	801f32a <crs_strlen>
 8006e22:	b283      	uxth	r3, r0
 8006e24:	4622      	mov	r2, r4
 8006e26:	2102      	movs	r1, #2
 8006e28:	4608      	mov	r0, r1
 8006e2a:	f018 fac1 	bl	801f3b0 <traceIF_itmPrint>
 8006e2e:	4620      	mov	r0, r4
 8006e30:	f018 fa7b 	bl	801f32a <crs_strlen>
 8006e34:	b283      	uxth	r3, r0
 8006e36:	4622      	mov	r2, r4
 8006e38:	2102      	movs	r1, #2
 8006e3a:	4608      	mov	r0, r1
 8006e3c:	f018 fada 	bl	801f3f4 <traceIF_uartPrint>
}
 8006e40:	4630      	mov	r0, r6
 8006e42:	b007      	add	sp, #28
 8006e44:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINT_FORCE("<< MODEM RESUME USECASE >> ")
 8006e46:	4d17      	ldr	r5, [pc, #92]	; (8006ea4 <SysCtrl_TYPE1SC_resume_channel+0x198>)
 8006e48:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8006e4a:	6020      	str	r0, [r4, #0]
 8006e4c:	6061      	str	r1, [r4, #4]
 8006e4e:	60a2      	str	r2, [r4, #8]
 8006e50:	60e3      	str	r3, [r4, #12]
 8006e52:	cd07      	ldmia	r5!, {r0, r1, r2}
 8006e54:	6120      	str	r0, [r4, #16]
 8006e56:	6161      	str	r1, [r4, #20]
 8006e58:	61a2      	str	r2, [r4, #24]
 8006e5a:	882b      	ldrh	r3, [r5, #0]
 8006e5c:	83a3      	strh	r3, [r4, #28]
 8006e5e:	4620      	mov	r0, r4
 8006e60:	f018 fa63 	bl	801f32a <crs_strlen>
 8006e64:	b283      	uxth	r3, r0
 8006e66:	4622      	mov	r2, r4
 8006e68:	2101      	movs	r1, #1
 8006e6a:	2002      	movs	r0, #2
 8006e6c:	f018 faa0 	bl	801f3b0 <traceIF_itmPrint>
 8006e70:	4620      	mov	r0, r4
 8006e72:	f018 fa5a 	bl	801f32a <crs_strlen>
 8006e76:	b282      	uxth	r2, r0
 8006e78:	4621      	mov	r1, r4
 8006e7a:	2002      	movs	r0, #2
 8006e7c:	f018 fad2 	bl	801f424 <traceIF_uartPrintForce>
    retval = HIFC_A_modem_resume(ipc_handle);
 8006e80:	4630      	mov	r0, r6
 8006e82:	f7ff fed5 	bl	8006c30 <HIFC_A_modem_resume>
 8006e86:	4606      	mov	r6, r0
 8006e88:	e7ad      	b.n	8006de6 <SysCtrl_TYPE1SC_resume_channel+0xda>
 8006e8a:	bf00      	nop
 8006e8c:	0802db98 	.word	0x0802db98
 8006e90:	200048dc 	.word	0x200048dc
 8006e94:	48000800 	.word	0x48000800
 8006e98:	48000400 	.word	0x48000400
 8006e9c:	0802dbf0 	.word	0x0802dbf0
 8006ea0:	0802dc10 	.word	0x0802dc10
 8006ea4:	0802dbd0 	.word	0x0802dbd0

08006ea8 <SysCtrl_TYPE1SC_reinit_channel>:
{
 8006ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006eaa:	4606      	mov	r6, r0
 8006eac:	460f      	mov	r7, r1
  PRINT_DBG("enter SysCtrl_TYPE1SC_reinit_channel")
 8006eae:	4d18      	ldr	r5, [pc, #96]	; (8006f10 <SysCtrl_TYPE1SC_reinit_channel+0x68>)
 8006eb0:	4c18      	ldr	r4, [pc, #96]	; (8006f14 <SysCtrl_TYPE1SC_reinit_channel+0x6c>)
 8006eb2:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8006eb6:	46ac      	mov	ip, r5
 8006eb8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8006ebc:	6020      	str	r0, [r4, #0]
 8006ebe:	6061      	str	r1, [r4, #4]
 8006ec0:	60a2      	str	r2, [r4, #8]
 8006ec2:	60e3      	str	r3, [r4, #12]
 8006ec4:	4665      	mov	r5, ip
 8006ec6:	3410      	adds	r4, #16
 8006ec8:	45f4      	cmp	ip, lr
 8006eca:	d1f4      	bne.n	8006eb6 <SysCtrl_TYPE1SC_reinit_channel+0xe>
 8006ecc:	f8dc 0000 	ldr.w	r0, [ip]
 8006ed0:	6020      	str	r0, [r4, #0]
 8006ed2:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8006ed6:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8006eda:	80a2      	strh	r2, [r4, #4]
 8006edc:	71a3      	strb	r3, [r4, #6]
 8006ede:	4c0d      	ldr	r4, [pc, #52]	; (8006f14 <SysCtrl_TYPE1SC_reinit_channel+0x6c>)
 8006ee0:	4620      	mov	r0, r4
 8006ee2:	f018 fa22 	bl	801f32a <crs_strlen>
 8006ee6:	b283      	uxth	r3, r0
 8006ee8:	4622      	mov	r2, r4
 8006eea:	2102      	movs	r1, #2
 8006eec:	4608      	mov	r0, r1
 8006eee:	f018 fa5f 	bl	801f3b0 <traceIF_itmPrint>
 8006ef2:	4620      	mov	r0, r4
 8006ef4:	f018 fa19 	bl	801f32a <crs_strlen>
 8006ef8:	b283      	uxth	r3, r0
 8006efa:	4622      	mov	r2, r4
 8006efc:	2102      	movs	r1, #2
 8006efe:	4608      	mov	r0, r1
 8006f00:	f018 fa78 	bl	801f3f4 <traceIF_uartPrint>
  retval = enable_UART(ipc_handle, hwFC_status);
 8006f04:	4639      	mov	r1, r7
 8006f06:	4630      	mov	r0, r6
 8006f08:	f7ff fd12 	bl	8006930 <enable_UART>
}
 8006f0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006f0e:	bf00      	nop
 8006f10:	0802dc38 	.word	0x0802dc38
 8006f14:	200048dc 	.word	0x200048dc

08006f18 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8006f18:	490f      	ldr	r1, [pc, #60]	; (8006f58 <SystemInit+0x40>)
 8006f1a:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8006f1e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8006f22:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 8006f26:	4b0d      	ldr	r3, [pc, #52]	; (8006f5c <SystemInit+0x44>)
 8006f28:	681a      	ldr	r2, [r3, #0]
 8006f2a:	f042 0201 	orr.w	r2, r2, #1
 8006f2e:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 8006f30:	2000      	movs	r0, #0
 8006f32:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 8006f34:	681a      	ldr	r2, [r3, #0]
 8006f36:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 8006f3a:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8006f3e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 8006f40:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8006f44:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8006f46:	681a      	ldr	r2, [r3, #0]
 8006f48:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8006f4c:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 8006f4e:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8006f50:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8006f54:	608b      	str	r3, [r1, #8]
#endif
}
 8006f56:	4770      	bx	lr
 8006f58:	e000ed00 	.word	0xe000ed00
 8006f5c:	40021000 	.word	0x40021000

08006f60 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8006f60:	b510      	push	{r4, lr}
#if (PREFETCH_ENABLE != 0)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8006f62:	2003      	movs	r0, #3
 8006f64:	f000 fb8a 	bl	800767c <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8006f68:	2000      	movs	r0, #0
 8006f6a:	f7fa fbbd 	bl	80016e8 <HAL_InitTick>
 8006f6e:	b110      	cbz	r0, 8006f76 <HAL_Init+0x16>
  {
    status = HAL_ERROR;
 8006f70:	2401      	movs	r4, #1
    HAL_MspInit();
  }

  /* Return function status */
  return status;
}
 8006f72:	4620      	mov	r0, r4
 8006f74:	bd10      	pop	{r4, pc}
 8006f76:	4604      	mov	r4, r0
    HAL_MspInit();
 8006f78:	f7fa fb6e 	bl	8001658 <HAL_MspInit>
 8006f7c:	e7f9      	b.n	8006f72 <HAL_Init+0x12>
	...

08006f80 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8006f80:	4b03      	ldr	r3, [pc, #12]	; (8006f90 <HAL_IncTick+0x10>)
 8006f82:	781b      	ldrb	r3, [r3, #0]
 8006f84:	4a03      	ldr	r2, [pc, #12]	; (8006f94 <HAL_IncTick+0x14>)
 8006f86:	6811      	ldr	r1, [r2, #0]
 8006f88:	440b      	add	r3, r1
 8006f8a:	6013      	str	r3, [r2, #0]
}
 8006f8c:	4770      	bx	lr
 8006f8e:	bf00      	nop
 8006f90:	20000038 	.word	0x20000038
 8006f94:	20001880 	.word	0x20001880

08006f98 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8006f98:	4b01      	ldr	r3, [pc, #4]	; (8006fa0 <HAL_GetTick+0x8>)
 8006f9a:	6818      	ldr	r0, [r3, #0]
}
 8006f9c:	4770      	bx	lr
 8006f9e:	bf00      	nop
 8006fa0:	20001880 	.word	0x20001880

08006fa4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8006fa4:	b538      	push	{r3, r4, r5, lr}
 8006fa6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8006fa8:	f7ff fff6 	bl	8006f98 <HAL_GetTick>
 8006fac:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8006fae:	f1b4 3fff 	cmp.w	r4, #4294967295
 8006fb2:	d002      	beq.n	8006fba <HAL_Delay+0x16>
  {
    wait += (uint32_t)uwTickFreq;
 8006fb4:	4b04      	ldr	r3, [pc, #16]	; (8006fc8 <HAL_Delay+0x24>)
 8006fb6:	781b      	ldrb	r3, [r3, #0]
 8006fb8:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8006fba:	f7ff ffed 	bl	8006f98 <HAL_GetTick>
 8006fbe:	1b40      	subs	r0, r0, r5
 8006fc0:	42a0      	cmp	r0, r4
 8006fc2:	d3fa      	bcc.n	8006fba <HAL_Delay+0x16>
  {
  }
}
 8006fc4:	bd38      	pop	{r3, r4, r5, pc}
 8006fc6:	bf00      	nop
 8006fc8:	20000038 	.word	0x20000038

08006fcc <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8006fcc:	b530      	push	{r4, r5, lr}
 8006fce:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8006fd0:	2300      	movs	r3, #0
 8006fd2:	9301      	str	r3, [sp, #4]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8006fd4:	2800      	cmp	r0, #0
 8006fd6:	f000 80da 	beq.w	800718e <HAL_ADC_Init+0x1c2>
 8006fda:	4604      	mov	r4, r0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8006fdc:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8006fde:	b303      	cbz	r3, 8007022 <HAL_ADC_Init+0x56>
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8006fe0:	6823      	ldr	r3, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8006fe2:	689a      	ldr	r2, [r3, #8]
 8006fe4:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
 8006fe8:	d005      	beq.n	8006ff6 <HAL_ADC_Init+0x2a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8006fea:	689a      	ldr	r2, [r3, #8]
 8006fec:	f022 4220 	bic.w	r2, r2, #2684354560	; 0xa0000000
 8006ff0:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8006ff4:	609a      	str	r2, [r3, #8]
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 8006ff6:	6822      	ldr	r2, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8006ff8:	6893      	ldr	r3, [r2, #8]
 8006ffa:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8006ffe:	d11d      	bne.n	800703c <HAL_ADC_Init+0x70>
  MODIFY_REG(ADCx->CR,
 8007000:	6893      	ldr	r3, [r2, #8]
 8007002:	f023 4310 	bic.w	r3, r3, #2415919104	; 0x90000000
 8007006:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800700a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800700e:	6093      	str	r3, [r2, #8]
    LL_ADC_EnableInternalRegulator(hadc->Instance);

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8007010:	4b60      	ldr	r3, [pc, #384]	; (8007194 <HAL_ADC_Init+0x1c8>)
 8007012:	681b      	ldr	r3, [r3, #0]
 8007014:	099b      	lsrs	r3, r3, #6
 8007016:	4a60      	ldr	r2, [pc, #384]	; (8007198 <HAL_ADC_Init+0x1cc>)
 8007018:	fba2 2303 	umull	r2, r3, r2, r3
 800701c:	099b      	lsrs	r3, r3, #6
 800701e:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8007020:	e009      	b.n	8007036 <HAL_ADC_Init+0x6a>
    HAL_ADC_MspInit(hadc);
 8007022:	f7f9 ffc5 	bl	8000fb0 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8007026:	2300      	movs	r3, #0
 8007028:	65e3      	str	r3, [r4, #92]	; 0x5c
    hadc->Lock = HAL_UNLOCKED;
 800702a:	f884 3054 	strb.w	r3, [r4, #84]	; 0x54
 800702e:	e7d7      	b.n	8006fe0 <HAL_ADC_Init+0x14>
    {
      wait_loop_index--;
 8007030:	9b01      	ldr	r3, [sp, #4]
 8007032:	3b01      	subs	r3, #1
 8007034:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8007036:	9b01      	ldr	r3, [sp, #4]
 8007038:	2b00      	cmp	r3, #0
 800703a:	d1f9      	bne.n	8007030 <HAL_ADC_Init+0x64>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800703c:	6822      	ldr	r2, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 800703e:	6893      	ldr	r3, [r2, #8]
 8007040:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8007044:	d17a      	bne.n	800713c <HAL_ADC_Init+0x170>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007046:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007048:	f043 0310 	orr.w	r3, r3, #16
 800704c:	65a3      	str	r3, [r4, #88]	; 0x58

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800704e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8007050:	f043 0301 	orr.w	r3, r3, #1
 8007054:	65e3      	str	r3, [r4, #92]	; 0x5c

    tmp_hal_status = HAL_ERROR;
 8007056:	2001      	movs	r0, #1
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8007058:	6893      	ldr	r3, [r2, #8]
 800705a:	f013 0304 	ands.w	r3, r3, #4
 800705e:	d000      	beq.n	8007062 <HAL_ADC_Init+0x96>
 8007060:	2301      	movs	r3, #1
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8007062:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8007064:	f011 0f10 	tst.w	r1, #16
 8007068:	f040 808a 	bne.w	8007180 <HAL_ADC_Init+0x1b4>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 800706c:	2b00      	cmp	r3, #0
 800706e:	f040 8087 	bne.w	8007180 <HAL_ADC_Init+0x1b4>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8007072:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007074:	f423 7381 	bic.w	r3, r3, #258	; 0x102
 8007078:	f043 0302 	orr.w	r3, r3, #2
 800707c:	65a3      	str	r3, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800707e:	6893      	ldr	r3, [r2, #8]
 8007080:	f013 0f01 	tst.w	r3, #1
 8007084:	d10b      	bne.n	800709e <HAL_ADC_Init+0xd2>
 8007086:	4b45      	ldr	r3, [pc, #276]	; (800719c <HAL_ADC_Init+0x1d0>)
 8007088:	689b      	ldr	r3, [r3, #8]
 800708a:	f013 0f01 	tst.w	r3, #1
 800708e:	d106      	bne.n	800709e <HAL_ADC_Init+0xd2>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8007090:	6863      	ldr	r3, [r4, #4]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8007092:	4943      	ldr	r1, [pc, #268]	; (80071a0 <HAL_ADC_Init+0x1d4>)
 8007094:	688a      	ldr	r2, [r1, #8]
 8007096:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 800709a:	4313      	orrs	r3, r2
 800709c:	608b      	str	r3, [r1, #8]
    /*  - external trigger polarity                Init.ExternalTrigConvEdge  */
    /*  - continuous conversion mode               Init.ContinuousConvMode    */
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 800709e:	7e62      	ldrb	r2, [r4, #25]
                hadc->Init.Overrun                                                     |
 80070a0:	6b63      	ldr	r3, [r4, #52]	; 0x34
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80070a2:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
                hadc->Init.DataAlign                                                   |
 80070a6:	68e2      	ldr	r2, [r4, #12]
                hadc->Init.Overrun                                                     |
 80070a8:	4313      	orrs	r3, r2
                hadc->Init.Resolution                                                  |
 80070aa:	68a2      	ldr	r2, [r4, #8]
                hadc->Init.DataAlign                                                   |
 80070ac:	4313      	orrs	r3, r2
                ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 80070ae:	f894 2020 	ldrb.w	r2, [r4, #32]
    tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)           |
 80070b2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80070b6:	2a01      	cmp	r2, #1
 80070b8:	d042      	beq.n	8007140 <HAL_ADC_Init+0x174>
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80070ba:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80070bc:	b122      	cbz	r2, 80070c8 <HAL_ADC_Init+0xfc>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80070be:	f402 7270 	and.w	r2, r2, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 80070c2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80070c4:	430a      	orrs	r2, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 80070c6:	4313      	orrs	r3, r2
                 );
    }

    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 80070c8:	6821      	ldr	r1, [r4, #0]
 80070ca:	68cd      	ldr	r5, [r1, #12]
 80070cc:	4a35      	ldr	r2, [pc, #212]	; (80071a4 <HAL_ADC_Init+0x1d8>)
 80070ce:	402a      	ands	r2, r5
 80070d0:	431a      	orrs	r2, r3
 80070d2:	60ca      	str	r2, [r1, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 80070d4:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80070d6:	688b      	ldr	r3, [r1, #8]
 80070d8:	f013 0304 	ands.w	r3, r3, #4
 80070dc:	d000      	beq.n	80070e0 <HAL_ADC_Init+0x114>
 80070de:	2301      	movs	r3, #1
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 80070e0:	688a      	ldr	r2, [r1, #8]
 80070e2:	f012 0208 	ands.w	r2, r2, #8
 80070e6:	d000      	beq.n	80070ea <HAL_ADC_Init+0x11e>
 80070e8:	2201      	movs	r2, #1
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 80070ea:	b9c3      	cbnz	r3, 800711e <HAL_ADC_Init+0x152>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 80070ec:	b9ba      	cbnz	r2, 800711e <HAL_ADC_Init+0x152>
       )
    {
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80070ee:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80070f0:	7e22      	ldrb	r2, [r4, #24]
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80070f2:	ea43 3382 	orr.w	r3, r3, r2, lsl #14
                 ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 80070f6:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
      tmpCFGR = (ADC_CFGR_DFSDM(hadc)                                            |
 80070fa:	ea43 0242 	orr.w	r2, r3, r2, lsl #1

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80070fe:	68cb      	ldr	r3, [r1, #12]
 8007100:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007104:	f023 0306 	bic.w	r3, r3, #6
 8007108:	4313      	orrs	r3, r2
 800710a:	60cb      	str	r3, [r1, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 800710c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8007110:	2b01      	cmp	r3, #1
 8007112:	d01a      	beq.n	800714a <HAL_ADC_Init+0x17e>
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8007114:	6822      	ldr	r2, [r4, #0]
 8007116:	6913      	ldr	r3, [r2, #16]
 8007118:	f023 0301 	bic.w	r3, r3, #1
 800711c:	6113      	str	r3, [r2, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800711e:	6923      	ldr	r3, [r4, #16]
 8007120:	2b01      	cmp	r3, #1
 8007122:	d024      	beq.n	800716e <HAL_ADC_Init+0x1a2>
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8007124:	6822      	ldr	r2, [r4, #0]
 8007126:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8007128:	f023 030f 	bic.w	r3, r3, #15
 800712c:	6313      	str	r3, [r2, #48]	; 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800712e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007130:	f023 0303 	bic.w	r3, r3, #3
 8007134:	f043 0301 	orr.w	r3, r3, #1
 8007138:	65a3      	str	r3, [r4, #88]	; 0x58
 800713a:	e026      	b.n	800718a <HAL_ADC_Init+0x1be>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800713c:	2000      	movs	r0, #0
 800713e:	e78b      	b.n	8007058 <HAL_ADC_Init+0x8c>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8007140:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8007142:	3a01      	subs	r2, #1
 8007144:	ea43 4342 	orr.w	r3, r3, r2, lsl #17
 8007148:	e7b7      	b.n	80070ba <HAL_ADC_Init+0xee>
        MODIFY_REG(hadc->Instance->CFGR2,
 800714a:	6821      	ldr	r1, [r4, #0]
 800714c:	690b      	ldr	r3, [r1, #16]
 800714e:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8007152:	f023 0304 	bic.w	r3, r3, #4
 8007156:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8007158:	6c25      	ldr	r5, [r4, #64]	; 0x40
 800715a:	432a      	orrs	r2, r5
 800715c:	6c65      	ldr	r5, [r4, #68]	; 0x44
 800715e:	432a      	orrs	r2, r5
 8007160:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8007162:	432a      	orrs	r2, r5
 8007164:	4313      	orrs	r3, r2
 8007166:	f043 0301 	orr.w	r3, r3, #1
 800716a:	610b      	str	r3, [r1, #16]
 800716c:	e7d7      	b.n	800711e <HAL_ADC_Init+0x152>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800716e:	6821      	ldr	r1, [r4, #0]
 8007170:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8007172:	f023 030f 	bic.w	r3, r3, #15
 8007176:	69e2      	ldr	r2, [r4, #28]
 8007178:	3a01      	subs	r2, #1
 800717a:	4313      	orrs	r3, r2
 800717c:	630b      	str	r3, [r1, #48]	; 0x30
 800717e:	e7d6      	b.n	800712e <HAL_ADC_Init+0x162>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8007180:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8007182:	f043 0310 	orr.w	r3, r3, #16
 8007186:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8007188:	2001      	movs	r0, #1
  }

  /* Return function status */
  return tmp_hal_status;
}
 800718a:	b003      	add	sp, #12
 800718c:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 800718e:	2001      	movs	r0, #1
 8007190:	e7fb      	b.n	800718a <HAL_ADC_Init+0x1be>
 8007192:	bf00      	nop
 8007194:	20000034 	.word	0x20000034
 8007198:	053e2d63 	.word	0x053e2d63
 800719c:	50040000 	.word	0x50040000
 80071a0:	50040300 	.word	0x50040300
 80071a4:	fff0c007 	.word	0xfff0c007

080071a8 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 80071a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80071aa:	b083      	sub	sp, #12
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 80071ac:	2200      	movs	r2, #0
 80071ae:	9201      	str	r2, [sp, #4]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 80071b0:	f890 2054 	ldrb.w	r2, [r0, #84]	; 0x54
 80071b4:	2a01      	cmp	r2, #1
 80071b6:	f000 8256 	beq.w	8007666 <HAL_ADC_ConfigChannel+0x4be>
 80071ba:	4603      	mov	r3, r0
 80071bc:	2201      	movs	r2, #1
 80071be:	f880 2054 	strb.w	r2, [r0, #84]	; 0x54
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80071c2:	6802      	ldr	r2, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80071c4:	6892      	ldr	r2, [r2, #8]
 80071c6:	f012 0f04 	tst.w	r2, #4
 80071ca:	d009      	beq.n	80071e0 <HAL_ADC_ConfigChannel+0x38>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80071cc:	6d82      	ldr	r2, [r0, #88]	; 0x58
 80071ce:	f042 0220 	orr.w	r2, r2, #32
 80071d2:	6582      	str	r2, [r0, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 80071d4:	2001      	movs	r0, #1
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80071d6:	2200      	movs	r2, #0
 80071d8:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54

  /* Return function status */
  return tmp_hal_status;
}
 80071dc:	b003      	add	sp, #12
 80071de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (sConfig->Rank <= 5U)
 80071e0:	684a      	ldr	r2, [r1, #4]
 80071e2:	2a05      	cmp	r2, #5
 80071e4:	d809      	bhi.n	80071fa <HAL_ADC_ConfigChannel+0x52>
      switch (sConfig->Rank)
 80071e6:	3a02      	subs	r2, #2
 80071e8:	2a03      	cmp	r2, #3
 80071ea:	f200 809d 	bhi.w	8007328 <HAL_ADC_ConfigChannel+0x180>
 80071ee:	e8df f002 	tbb	[pc, r2]
 80071f2:	9102      	.short	0x9102
 80071f4:	9794      	.short	0x9794
          sConfig->Rank = ADC_REGULAR_RANK_2;
 80071f6:	220c      	movs	r2, #12
 80071f8:	604a      	str	r2, [r1, #4]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 80071fa:	681d      	ldr	r5, [r3, #0]
 80071fc:	684c      	ldr	r4, [r1, #4]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80071fe:	3530      	adds	r5, #48	; 0x30
 8007200:	0a22      	lsrs	r2, r4, #8
 8007202:	0092      	lsls	r2, r2, #2
 8007204:	f002 020c 	and.w	r2, r2, #12
  MODIFY_REG(*preg,
 8007208:	58a8      	ldr	r0, [r5, r2]
 800720a:	f004 0e1f 	and.w	lr, r4, #31
 800720e:	241f      	movs	r4, #31
 8007210:	fa04 f40e 	lsl.w	r4, r4, lr
 8007214:	ea20 0004 	bic.w	r0, r0, r4
 8007218:	680c      	ldr	r4, [r1, #0]
 800721a:	f3c4 6c84 	ubfx	ip, r4, #26, #5
 800721e:	fa0c fc0e 	lsl.w	ip, ip, lr
 8007222:	ea40 000c 	orr.w	r0, r0, ip
 8007226:	50a8      	str	r0, [r5, r2]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8007228:	681c      	ldr	r4, [r3, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800722a:	68a2      	ldr	r2, [r4, #8]
 800722c:	f012 0204 	ands.w	r2, r2, #4
 8007230:	d000      	beq.n	8007234 <HAL_ADC_ConfigChannel+0x8c>
 8007232:	2201      	movs	r2, #1
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8007234:	68a0      	ldr	r0, [r4, #8]
 8007236:	f010 0008 	ands.w	r0, r0, #8
 800723a:	d000      	beq.n	800723e <HAL_ADC_ConfigChannel+0x96>
 800723c:	2001      	movs	r0, #1
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 800723e:	2a00      	cmp	r2, #0
 8007240:	d134      	bne.n	80072ac <HAL_ADC_ConfigChannel+0x104>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8007242:	2800      	cmp	r0, #0
 8007244:	d132      	bne.n	80072ac <HAL_ADC_ConfigChannel+0x104>
      if (sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 8007246:	6888      	ldr	r0, [r1, #8]
 8007248:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
 800724c:	d06f      	beq.n	800732e <HAL_ADC_ConfigChannel+0x186>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800724e:	680e      	ldr	r6, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8007250:	3414      	adds	r4, #20
 8007252:	0e72      	lsrs	r2, r6, #25
 8007254:	0092      	lsls	r2, r2, #2
 8007256:	f002 0204 	and.w	r2, r2, #4
  MODIFY_REG(*preg,
 800725a:	58a5      	ldr	r5, [r4, r2]
 800725c:	f3c6 5c04 	ubfx	ip, r6, #20, #5
 8007260:	2607      	movs	r6, #7
 8007262:	fa06 f60c 	lsl.w	r6, r6, ip
 8007266:	ea25 0506 	bic.w	r5, r5, r6
 800726a:	fa00 f00c 	lsl.w	r0, r0, ip
 800726e:	4328      	orrs	r0, r5
 8007270:	50a0      	str	r0, [r4, r2]
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 8007272:	6818      	ldr	r0, [r3, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8007274:	6942      	ldr	r2, [r0, #20]
 8007276:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800727a:	6142      	str	r2, [r0, #20]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800727c:	694c      	ldr	r4, [r1, #20]
 800727e:	6818      	ldr	r0, [r3, #0]
 8007280:	68c2      	ldr	r2, [r0, #12]
 8007282:	f3c2 02c1 	ubfx	r2, r2, #3, #2
 8007286:	0052      	lsls	r2, r2, #1
 8007288:	4094      	lsls	r4, r2
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 800728a:	690d      	ldr	r5, [r1, #16]
 800728c:	2d04      	cmp	r5, #4
 800728e:	d063      	beq.n	8007358 <HAL_ADC_ConfigChannel+0x1b0>
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8007290:	680e      	ldr	r6, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8007292:	3060      	adds	r0, #96	; 0x60
  MODIFY_REG(*preg,
 8007294:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
 8007298:	4aac      	ldr	r2, [pc, #688]	; (800754c <HAL_ADC_ConfigChannel+0x3a4>)
 800729a:	403a      	ands	r2, r7
 800729c:	f006 46f8 	and.w	r6, r6, #2080374784	; 0x7c000000
 80072a0:	4334      	orrs	r4, r6
 80072a2:	4322      	orrs	r2, r4
 80072a4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 80072a8:	f840 2025 	str.w	r2, [r0, r5, lsl #2]
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80072ac:	6818      	ldr	r0, [r3, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80072ae:	6882      	ldr	r2, [r0, #8]
 80072b0:	f012 0f01 	tst.w	r2, #1
 80072b4:	d117      	bne.n	80072e6 <HAL_ADC_ConfigChannel+0x13e>
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 80072b6:	680a      	ldr	r2, [r1, #0]
 80072b8:	68cd      	ldr	r5, [r1, #12]
  MODIFY_REG(ADCx->DIFSEL,
 80072ba:	f8d0 40b0 	ldr.w	r4, [r0, #176]	; 0xb0
 80072be:	f3c2 0c12 	ubfx	ip, r2, #0, #19
 80072c2:	ea24 040c 	bic.w	r4, r4, ip
 80072c6:	f005 0c18 	and.w	ip, r5, #24
 80072ca:	4da1      	ldr	r5, [pc, #644]	; (8007550 <HAL_ADC_ConfigChannel+0x3a8>)
 80072cc:	fa25 f50c 	lsr.w	r5, r5, ip
 80072d0:	402a      	ands	r2, r5
 80072d2:	f3c2 0212 	ubfx	r2, r2, #0, #19
 80072d6:	4322      	orrs	r2, r4
 80072d8:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 80072dc:	68c8      	ldr	r0, [r1, #12]
 80072de:	4a9d      	ldr	r2, [pc, #628]	; (8007554 <HAL_ADC_ConfigChannel+0x3ac>)
 80072e0:	4290      	cmp	r0, r2
 80072e2:	f000 80a1 	beq.w	8007428 <HAL_ADC_ConfigChannel+0x280>
    if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80072e6:	680a      	ldr	r2, [r1, #0]
 80072e8:	499b      	ldr	r1, [pc, #620]	; (8007558 <HAL_ADC_ConfigChannel+0x3b0>)
 80072ea:	420a      	tst	r2, r1
 80072ec:	f000 81b7 	beq.w	800765e <HAL_ADC_ConfigChannel+0x4b6>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80072f0:	499a      	ldr	r1, [pc, #616]	; (800755c <HAL_ADC_ConfigChannel+0x3b4>)
 80072f2:	6889      	ldr	r1, [r1, #8]
 80072f4:	f001 74e0 	and.w	r4, r1, #29360128	; 0x1c00000
      if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 80072f8:	4899      	ldr	r0, [pc, #612]	; (8007560 <HAL_ADC_ConfigChannel+0x3b8>)
 80072fa:	4282      	cmp	r2, r0
 80072fc:	f000 8162 	beq.w	80075c4 <HAL_ADC_ConfigChannel+0x41c>
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8007300:	4898      	ldr	r0, [pc, #608]	; (8007564 <HAL_ADC_ConfigChannel+0x3bc>)
 8007302:	4282      	cmp	r2, r0
 8007304:	f000 8184 	beq.w	8007610 <HAL_ADC_ConfigChannel+0x468>
      else if ((sConfig->Channel == ADC_CHANNEL_VREFINT)
 8007308:	4897      	ldr	r0, [pc, #604]	; (8007568 <HAL_ADC_ConfigChannel+0x3c0>)
 800730a:	4282      	cmp	r2, r0
 800730c:	f000 8194 	beq.w	8007638 <HAL_ADC_ConfigChannel+0x490>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007310:	2000      	movs	r0, #0
 8007312:	e760      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          sConfig->Rank = ADC_REGULAR_RANK_3;
 8007314:	2212      	movs	r2, #18
 8007316:	604a      	str	r2, [r1, #4]
          break;
 8007318:	e76f      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
          sConfig->Rank = ADC_REGULAR_RANK_4;
 800731a:	2218      	movs	r2, #24
 800731c:	604a      	str	r2, [r1, #4]
          break;
 800731e:	e76c      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
          sConfig->Rank = ADC_REGULAR_RANK_5;
 8007320:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007324:	604a      	str	r2, [r1, #4]
          break;
 8007326:	e768      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
          sConfig->Rank = ADC_REGULAR_RANK_1;
 8007328:	2206      	movs	r2, #6
 800732a:	604a      	str	r2, [r1, #4]
          break;
 800732c:	e765      	b.n	80071fa <HAL_ADC_ConfigChannel+0x52>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 800732e:	6808      	ldr	r0, [r1, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8007330:	3414      	adds	r4, #20
 8007332:	0e42      	lsrs	r2, r0, #25
 8007334:	0092      	lsls	r2, r2, #2
 8007336:	f002 0204 	and.w	r2, r2, #4
  MODIFY_REG(*preg,
 800733a:	58a5      	ldr	r5, [r4, r2]
 800733c:	f3c0 5004 	ubfx	r0, r0, #20, #5
 8007340:	2607      	movs	r6, #7
 8007342:	fa06 f000 	lsl.w	r0, r6, r0
 8007346:	ea25 0000 	bic.w	r0, r5, r0
 800734a:	50a0      	str	r0, [r4, r2]
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 800734c:	6818      	ldr	r0, [r3, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 800734e:	6942      	ldr	r2, [r0, #20]
 8007350:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8007354:	6142      	str	r2, [r0, #20]
}
 8007356:	e791      	b.n	800727c <HAL_ADC_ConfigChannel+0xd4>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8007358:	6e02      	ldr	r2, [r0, #96]	; 0x60
 800735a:	6e04      	ldr	r4, [r0, #96]	; 0x60
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800735c:	f3c4 6484 	ubfx	r4, r4, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8007360:	680a      	ldr	r2, [r1, #0]
 8007362:	f3c2 0512 	ubfx	r5, r2, #0, #19
 8007366:	bb85      	cbnz	r5, 80073ca <HAL_ADC_ConfigChannel+0x222>
 8007368:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1))
 800736c:	4294      	cmp	r4, r2
 800736e:	d034      	beq.n	80073da <HAL_ADC_ConfigChannel+0x232>
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8007370:	681c      	ldr	r4, [r3, #0]
 8007372:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8007374:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8007376:	f3c0 6084 	ubfx	r0, r0, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 800737a:	680a      	ldr	r2, [r1, #0]
 800737c:	f3c2 0512 	ubfx	r5, r2, #0, #19
 8007380:	bb85      	cbnz	r5, 80073e4 <HAL_ADC_ConfigChannel+0x23c>
 8007382:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2))
 8007386:	4290      	cmp	r0, r2
 8007388:	d034      	beq.n	80073f4 <HAL_ADC_ConfigChannel+0x24c>
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 800738a:	681c      	ldr	r4, [r3, #0]
 800738c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 800738e:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8007390:	f3c0 6084 	ubfx	r0, r0, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8007394:	680a      	ldr	r2, [r1, #0]
 8007396:	f3c2 0512 	ubfx	r5, r2, #0, #19
 800739a:	bb85      	cbnz	r5, 80073fe <HAL_ADC_ConfigChannel+0x256>
 800739c:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3))
 80073a0:	4290      	cmp	r0, r2
 80073a2:	d034      	beq.n	800740e <HAL_ADC_ConfigChannel+0x266>
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80073a4:	681c      	ldr	r4, [r3, #0]
 80073a6:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80073a8:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 80073aa:	f3c0 6084 	ubfx	r0, r0, #26, #5
            == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80073ae:	680a      	ldr	r2, [r1, #0]
 80073b0:	f3c2 0512 	ubfx	r5, r2, #0, #19
 80073b4:	bb85      	cbnz	r5, 8007418 <HAL_ADC_ConfigChannel+0x270>
 80073b6:	f3c2 6284 	ubfx	r2, r2, #26, #5
        if (__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4))
 80073ba:	4290      	cmp	r0, r2
 80073bc:	f47f af76 	bne.w	80072ac <HAL_ADC_ConfigChannel+0x104>
  MODIFY_REG(*preg,
 80073c0:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 80073c2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80073c6:	66e2      	str	r2, [r4, #108]	; 0x6c
}
 80073c8:	e770      	b.n	80072ac <HAL_ADC_ConfigChannel+0x104>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80073ca:	fa92 f2a2 	rbit	r2, r2
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 80073ce:	b112      	cbz	r2, 80073d6 <HAL_ADC_ConfigChannel+0x22e>
  {
    return 32U;
  }
  return __builtin_clz(value);
 80073d0:	fab2 f282 	clz	r2, r2
 80073d4:	e7ca      	b.n	800736c <HAL_ADC_ConfigChannel+0x1c4>
    return 32U;
 80073d6:	2220      	movs	r2, #32
 80073d8:	e7c8      	b.n	800736c <HAL_ADC_ConfigChannel+0x1c4>
  MODIFY_REG(*preg,
 80073da:	6e02      	ldr	r2, [r0, #96]	; 0x60
 80073dc:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80073e0:	6602      	str	r2, [r0, #96]	; 0x60
}
 80073e2:	e7c5      	b.n	8007370 <HAL_ADC_ConfigChannel+0x1c8>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80073e4:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 80073e8:	b112      	cbz	r2, 80073f0 <HAL_ADC_ConfigChannel+0x248>
  return __builtin_clz(value);
 80073ea:	fab2 f282 	clz	r2, r2
 80073ee:	e7ca      	b.n	8007386 <HAL_ADC_ConfigChannel+0x1de>
    return 32U;
 80073f0:	2220      	movs	r2, #32
 80073f2:	e7c8      	b.n	8007386 <HAL_ADC_ConfigChannel+0x1de>
  MODIFY_REG(*preg,
 80073f4:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80073f6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80073fa:	6662      	str	r2, [r4, #100]	; 0x64
}
 80073fc:	e7c5      	b.n	800738a <HAL_ADC_ConfigChannel+0x1e2>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80073fe:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 8007402:	b112      	cbz	r2, 800740a <HAL_ADC_ConfigChannel+0x262>
  return __builtin_clz(value);
 8007404:	fab2 f282 	clz	r2, r2
 8007408:	e7ca      	b.n	80073a0 <HAL_ADC_ConfigChannel+0x1f8>
    return 32U;
 800740a:	2220      	movs	r2, #32
 800740c:	e7c8      	b.n	80073a0 <HAL_ADC_ConfigChannel+0x1f8>
  MODIFY_REG(*preg,
 800740e:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 8007410:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8007414:	66a2      	str	r2, [r4, #104]	; 0x68
}
 8007416:	e7c5      	b.n	80073a4 <HAL_ADC_ConfigChannel+0x1fc>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007418:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 800741c:	b112      	cbz	r2, 8007424 <HAL_ADC_ConfigChannel+0x27c>
  return __builtin_clz(value);
 800741e:	fab2 f282 	clz	r2, r2
 8007422:	e7ca      	b.n	80073ba <HAL_ADC_ConfigChannel+0x212>
    return 32U;
 8007424:	2220      	movs	r2, #32
 8007426:	e7c8      	b.n	80073ba <HAL_ADC_ConfigChannel+0x212>
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007428:	681c      	ldr	r4, [r3, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800742a:	680a      	ldr	r2, [r1, #0]
 800742c:	f3c2 0512 	ubfx	r5, r2, #0, #19
 8007430:	2d00      	cmp	r5, #0
 8007432:	d138      	bne.n	80074a6 <HAL_ADC_ConfigChannel+0x2fe>
 8007434:	0e90      	lsrs	r0, r2, #26
 8007436:	3001      	adds	r0, #1
 8007438:	f000 001f 	and.w	r0, r0, #31
 800743c:	2809      	cmp	r0, #9
 800743e:	bf8c      	ite	hi
 8007440:	2000      	movhi	r0, #0
 8007442:	2001      	movls	r0, #1
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007444:	2800      	cmp	r0, #0
 8007446:	d066      	beq.n	8007516 <HAL_ADC_ConfigChannel+0x36e>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8007448:	2d00      	cmp	r5, #0
 800744a:	d13b      	bne.n	80074c4 <HAL_ADC_ConfigChannel+0x31c>
 800744c:	0e90      	lsrs	r0, r2, #26
 800744e:	3001      	adds	r0, #1
 8007450:	0680      	lsls	r0, r0, #26
 8007452:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 8007456:	2d00      	cmp	r5, #0
 8007458:	d140      	bne.n	80074dc <HAL_ADC_ConfigChannel+0x334>
 800745a:	0e97      	lsrs	r7, r2, #26
 800745c:	3701      	adds	r7, #1
 800745e:	f007 071f 	and.w	r7, r7, #31
 8007462:	2601      	movs	r6, #1
 8007464:	40be      	lsls	r6, r7
 8007466:	4330      	orrs	r0, r6
 8007468:	2d00      	cmp	r5, #0
 800746a:	d146      	bne.n	80074fa <HAL_ADC_ConfigChannel+0x352>
 800746c:	0e92      	lsrs	r2, r2, #26
 800746e:	3201      	adds	r2, #1
 8007470:	f002 021f 	and.w	r2, r2, #31
 8007474:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8007478:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 800747a:	4310      	orrs	r0, r2
 800747c:	688d      	ldr	r5, [r1, #8]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800747e:	f104 0e14 	add.w	lr, r4, #20
 8007482:	0e42      	lsrs	r2, r0, #25
 8007484:	0092      	lsls	r2, r2, #2
 8007486:	f002 0204 	and.w	r2, r2, #4
  MODIFY_REG(*preg,
 800748a:	f85e 4002 	ldr.w	r4, [lr, r2]
 800748e:	f3c0 5004 	ubfx	r0, r0, #20, #5
 8007492:	2607      	movs	r6, #7
 8007494:	4086      	lsls	r6, r0
 8007496:	ea24 0c06 	bic.w	ip, r4, r6
 800749a:	4085      	lsls	r5, r0
 800749c:	ea4c 0505 	orr.w	r5, ip, r5
 80074a0:	f84e 5002 	str.w	r5, [lr, r2]
}
 80074a4:	e71f      	b.n	80072e6 <HAL_ADC_ConfigChannel+0x13e>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074a6:	fa92 f0a2 	rbit	r0, r2
  if (value == 0U)
 80074aa:	b148      	cbz	r0, 80074c0 <HAL_ADC_ConfigChannel+0x318>
  return __builtin_clz(value);
 80074ac:	fab0 f080 	clz	r0, r0
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80074b0:	3001      	adds	r0, #1
 80074b2:	f000 001f 	and.w	r0, r0, #31
 80074b6:	2809      	cmp	r0, #9
 80074b8:	bf8c      	ite	hi
 80074ba:	2000      	movhi	r0, #0
 80074bc:	2001      	movls	r0, #1
 80074be:	e7c1      	b.n	8007444 <HAL_ADC_ConfigChannel+0x29c>
    return 32U;
 80074c0:	2020      	movs	r0, #32
 80074c2:	e7f5      	b.n	80074b0 <HAL_ADC_ConfigChannel+0x308>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074c4:	fa92 f0a2 	rbit	r0, r2
  if (value == 0U)
 80074c8:	b130      	cbz	r0, 80074d8 <HAL_ADC_ConfigChannel+0x330>
  return __builtin_clz(value);
 80074ca:	fab0 f080 	clz	r0, r0
 80074ce:	3001      	adds	r0, #1
 80074d0:	0680      	lsls	r0, r0, #26
 80074d2:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 80074d6:	e7be      	b.n	8007456 <HAL_ADC_ConfigChannel+0x2ae>
    return 32U;
 80074d8:	2020      	movs	r0, #32
 80074da:	e7f8      	b.n	80074ce <HAL_ADC_ConfigChannel+0x326>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074dc:	fa92 f6a2 	rbit	r6, r2
  if (value == 0U)
 80074e0:	b14e      	cbz	r6, 80074f6 <HAL_ADC_ConfigChannel+0x34e>
  return __builtin_clz(value);
 80074e2:	fab6 f686 	clz	r6, r6
 80074e6:	3601      	adds	r6, #1
 80074e8:	f006 061f 	and.w	r6, r6, #31
 80074ec:	f04f 0c01 	mov.w	ip, #1
 80074f0:	fa0c f606 	lsl.w	r6, ip, r6
 80074f4:	e7b7      	b.n	8007466 <HAL_ADC_ConfigChannel+0x2be>
    return 32U;
 80074f6:	2620      	movs	r6, #32
 80074f8:	e7f5      	b.n	80074e6 <HAL_ADC_ConfigChannel+0x33e>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80074fa:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 80074fe:	b142      	cbz	r2, 8007512 <HAL_ADC_ConfigChannel+0x36a>
  return __builtin_clz(value);
 8007500:	fab2 f282 	clz	r2, r2
 8007504:	3201      	adds	r2, #1
 8007506:	f002 021f 	and.w	r2, r2, #31
 800750a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800750e:	0512      	lsls	r2, r2, #20
 8007510:	e7b3      	b.n	800747a <HAL_ADC_ConfigChannel+0x2d2>
    return 32U;
 8007512:	2220      	movs	r2, #32
 8007514:	e7f6      	b.n	8007504 <HAL_ADC_ConfigChannel+0x35c>
 8007516:	bb4d      	cbnz	r5, 800756c <HAL_ADC_ConfigChannel+0x3c4>
 8007518:	0e90      	lsrs	r0, r2, #26
 800751a:	3001      	adds	r0, #1
 800751c:	0680      	lsls	r0, r0, #26
 800751e:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 8007522:	bb7d      	cbnz	r5, 8007584 <HAL_ADC_ConfigChannel+0x3dc>
 8007524:	0e97      	lsrs	r7, r2, #26
 8007526:	3701      	adds	r7, #1
 8007528:	f007 071f 	and.w	r7, r7, #31
 800752c:	2601      	movs	r6, #1
 800752e:	40be      	lsls	r6, r7
 8007530:	4330      	orrs	r0, r6
 8007532:	bbb5      	cbnz	r5, 80075a2 <HAL_ADC_ConfigChannel+0x3fa>
 8007534:	0e92      	lsrs	r2, r2, #26
 8007536:	3201      	adds	r2, #1
 8007538:	f002 021f 	and.w	r2, r2, #31
 800753c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8007540:	3a1e      	subs	r2, #30
 8007542:	0512      	lsls	r2, r2, #20
 8007544:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8007548:	4310      	orrs	r0, r2
 800754a:	e797      	b.n	800747c <HAL_ADC_ConfigChannel+0x2d4>
 800754c:	03fff000 	.word	0x03fff000
 8007550:	0007ffff 	.word	0x0007ffff
 8007554:	407f0000 	.word	0x407f0000
 8007558:	80080000 	.word	0x80080000
 800755c:	50040300 	.word	0x50040300
 8007560:	c7520000 	.word	0xc7520000
 8007564:	cb840000 	.word	0xcb840000
 8007568:	80000001 	.word	0x80000001
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800756c:	fa92 f0a2 	rbit	r0, r2
  if (value == 0U)
 8007570:	b130      	cbz	r0, 8007580 <HAL_ADC_ConfigChannel+0x3d8>
  return __builtin_clz(value);
 8007572:	fab0 f080 	clz	r0, r0
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8007576:	3001      	adds	r0, #1
 8007578:	0680      	lsls	r0, r0, #26
 800757a:	f000 40f8 	and.w	r0, r0, #2080374784	; 0x7c000000
 800757e:	e7d0      	b.n	8007522 <HAL_ADC_ConfigChannel+0x37a>
    return 32U;
 8007580:	2020      	movs	r0, #32
 8007582:	e7f8      	b.n	8007576 <HAL_ADC_ConfigChannel+0x3ce>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8007584:	fa92 f6a2 	rbit	r6, r2
  if (value == 0U)
 8007588:	b14e      	cbz	r6, 800759e <HAL_ADC_ConfigChannel+0x3f6>
  return __builtin_clz(value);
 800758a:	fab6 f686 	clz	r6, r6
 800758e:	3601      	adds	r6, #1
 8007590:	f006 061f 	and.w	r6, r6, #31
 8007594:	f04f 0c01 	mov.w	ip, #1
 8007598:	fa0c f606 	lsl.w	r6, ip, r6
 800759c:	e7c8      	b.n	8007530 <HAL_ADC_ConfigChannel+0x388>
    return 32U;
 800759e:	2620      	movs	r6, #32
 80075a0:	e7f5      	b.n	800758e <HAL_ADC_ConfigChannel+0x3e6>
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80075a2:	fa92 f2a2 	rbit	r2, r2
  if (value == 0U)
 80075a6:	b15a      	cbz	r2, 80075c0 <HAL_ADC_ConfigChannel+0x418>
  return __builtin_clz(value);
 80075a8:	fab2 f282 	clz	r2, r2
 80075ac:	3201      	adds	r2, #1
 80075ae:	f002 021f 	and.w	r2, r2, #31
 80075b2:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80075b6:	3a1e      	subs	r2, #30
 80075b8:	0512      	lsls	r2, r2, #20
 80075ba:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 80075be:	e7c3      	b.n	8007548 <HAL_ADC_ConfigChannel+0x3a0>
    return 32U;
 80075c0:	2220      	movs	r2, #32
 80075c2:	e7f3      	b.n	80075ac <HAL_ADC_ConfigChannel+0x404>
          && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 80075c4:	f411 0f00 	tst.w	r1, #8388608	; 0x800000
 80075c8:	f47f ae9a 	bne.w	8007300 <HAL_ADC_ConfigChannel+0x158>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 80075cc:	6819      	ldr	r1, [r3, #0]
 80075ce:	4a27      	ldr	r2, [pc, #156]	; (800766c <HAL_ADC_ConfigChannel+0x4c4>)
 80075d0:	4291      	cmp	r1, r2
 80075d2:	d001      	beq.n	80075d8 <HAL_ADC_ConfigChannel+0x430>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80075d4:	2000      	movs	r0, #0
 80075d6:	e5fe      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 80075d8:	f444 0200 	orr.w	r2, r4, #8388608	; 0x800000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80075dc:	4824      	ldr	r0, [pc, #144]	; (8007670 <HAL_ADC_ConfigChannel+0x4c8>)
 80075de:	6881      	ldr	r1, [r0, #8]
 80075e0:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 80075e4:	430a      	orrs	r2, r1
 80075e6:	6082      	str	r2, [r0, #8]
          wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 80075e8:	4a22      	ldr	r2, [pc, #136]	; (8007674 <HAL_ADC_ConfigChannel+0x4cc>)
 80075ea:	6812      	ldr	r2, [r2, #0]
 80075ec:	0992      	lsrs	r2, r2, #6
 80075ee:	4922      	ldr	r1, [pc, #136]	; (8007678 <HAL_ADC_ConfigChannel+0x4d0>)
 80075f0:	fba1 1202 	umull	r1, r2, r1, r2
 80075f4:	0992      	lsrs	r2, r2, #6
 80075f6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80075fa:	0092      	lsls	r2, r2, #2
 80075fc:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 80075fe:	e002      	b.n	8007606 <HAL_ADC_ConfigChannel+0x45e>
            wait_loop_index--;
 8007600:	9a01      	ldr	r2, [sp, #4]
 8007602:	3a01      	subs	r2, #1
 8007604:	9201      	str	r2, [sp, #4]
          while (wait_loop_index != 0UL)
 8007606:	9a01      	ldr	r2, [sp, #4]
 8007608:	2a00      	cmp	r2, #0
 800760a:	d1f9      	bne.n	8007600 <HAL_ADC_ConfigChannel+0x458>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800760c:	2000      	movs	r0, #0
 800760e:	e5e2      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
      else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8007610:	f011 7f80 	tst.w	r1, #16777216	; 0x1000000
 8007614:	f47f ae78 	bne.w	8007308 <HAL_ADC_ConfigChannel+0x160>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8007618:	6819      	ldr	r1, [r3, #0]
 800761a:	4a14      	ldr	r2, [pc, #80]	; (800766c <HAL_ADC_ConfigChannel+0x4c4>)
 800761c:	4291      	cmp	r1, r2
 800761e:	d001      	beq.n	8007624 <HAL_ADC_ConfigChannel+0x47c>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007620:	2000      	movs	r0, #0
 8007622:	e5d8      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8007624:	f044 7280 	orr.w	r2, r4, #16777216	; 0x1000000
 8007628:	4811      	ldr	r0, [pc, #68]	; (8007670 <HAL_ADC_ConfigChannel+0x4c8>)
 800762a:	6881      	ldr	r1, [r0, #8]
 800762c:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8007630:	430a      	orrs	r2, r1
 8007632:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007634:	2000      	movs	r0, #0
}
 8007636:	e5ce      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
               && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8007638:	f411 0f80 	tst.w	r1, #4194304	; 0x400000
 800763c:	d111      	bne.n	8007662 <HAL_ADC_ConfigChannel+0x4ba>
        if (ADC_VREFINT_INSTANCE(hadc))
 800763e:	6819      	ldr	r1, [r3, #0]
 8007640:	4a0a      	ldr	r2, [pc, #40]	; (800766c <HAL_ADC_ConfigChannel+0x4c4>)
 8007642:	4291      	cmp	r1, r2
 8007644:	d001      	beq.n	800764a <HAL_ADC_ConfigChannel+0x4a2>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8007646:	2000      	movs	r0, #0
 8007648:	e5c5      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 800764a:	f444 0280 	orr.w	r2, r4, #4194304	; 0x400000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 800764e:	4808      	ldr	r0, [pc, #32]	; (8007670 <HAL_ADC_ConfigChannel+0x4c8>)
 8007650:	6881      	ldr	r1, [r0, #8]
 8007652:	f021 71e0 	bic.w	r1, r1, #29360128	; 0x1c00000
 8007656:	430a      	orrs	r2, r1
 8007658:	6082      	str	r2, [r0, #8]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800765a:	2000      	movs	r0, #0
}
 800765c:	e5bb      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
 800765e:	2000      	movs	r0, #0
 8007660:	e5b9      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
 8007662:	2000      	movs	r0, #0
 8007664:	e5b7      	b.n	80071d6 <HAL_ADC_ConfigChannel+0x2e>
  __HAL_LOCK(hadc);
 8007666:	2002      	movs	r0, #2
 8007668:	e5b8      	b.n	80071dc <HAL_ADC_ConfigChannel+0x34>
 800766a:	bf00      	nop
 800766c:	50040000 	.word	0x50040000
 8007670:	50040300 	.word	0x50040300
 8007674:	20000034 	.word	0x20000034
 8007678:	053e2d63 	.word	0x053e2d63

0800767c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800767c:	4a07      	ldr	r2, [pc, #28]	; (800769c <HAL_NVIC_SetPriorityGrouping+0x20>)
 800767e:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8007680:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8007684:	041b      	lsls	r3, r3, #16
 8007686:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8007688:	0200      	lsls	r0, r0, #8
 800768a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800768e:	4303      	orrs	r3, r0
  reg_value  =  (reg_value                                   |
 8007690:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8007694:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8007698:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800769a:	4770      	bx	lr
 800769c:	e000ed00 	.word	0xe000ed00

080076a0 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80076a0:	b500      	push	{lr}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80076a2:	4b19      	ldr	r3, [pc, #100]	; (8007708 <HAL_NVIC_SetPriority+0x68>)
 80076a4:	68db      	ldr	r3, [r3, #12]
 80076a6:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80076aa:	f1c3 0c07 	rsb	ip, r3, #7
 80076ae:	f1bc 0f04 	cmp.w	ip, #4
 80076b2:	bf28      	it	cs
 80076b4:	f04f 0c04 	movcs.w	ip, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80076b8:	f103 0e04 	add.w	lr, r3, #4
 80076bc:	f1be 0f06 	cmp.w	lr, #6
 80076c0:	d918      	bls.n	80076f4 <HAL_NVIC_SetPriority+0x54>
 80076c2:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80076c4:	f04f 3eff 	mov.w	lr, #4294967295
 80076c8:	fa0e fc0c 	lsl.w	ip, lr, ip
 80076cc:	ea21 010c 	bic.w	r1, r1, ip
 80076d0:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80076d2:	fa0e fe03 	lsl.w	lr, lr, r3
 80076d6:	ea22 020e 	bic.w	r2, r2, lr
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80076da:	430a      	orrs	r2, r1
  if ((int32_t)(IRQn) >= 0)
 80076dc:	2800      	cmp	r0, #0
 80076de:	db0b      	blt.n	80076f8 <HAL_NVIC_SetPriority+0x58>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80076e0:	0112      	lsls	r2, r2, #4
 80076e2:	b2d2      	uxtb	r2, r2
 80076e4:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 80076e8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 80076ec:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80076f0:	f85d fb04 	ldr.w	pc, [sp], #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80076f4:	2300      	movs	r3, #0
 80076f6:	e7e5      	b.n	80076c4 <HAL_NVIC_SetPriority+0x24>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80076f8:	f000 000f 	and.w	r0, r0, #15
 80076fc:	0112      	lsls	r2, r2, #4
 80076fe:	b2d2      	uxtb	r2, r2
 8007700:	4b02      	ldr	r3, [pc, #8]	; (800770c <HAL_NVIC_SetPriority+0x6c>)
 8007702:	541a      	strb	r2, [r3, r0]
 8007704:	e7f4      	b.n	80076f0 <HAL_NVIC_SetPriority+0x50>
 8007706:	bf00      	nop
 8007708:	e000ed00 	.word	0xe000ed00
 800770c:	e000ed14 	.word	0xe000ed14

08007710 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8007710:	2800      	cmp	r0, #0
 8007712:	db07      	blt.n	8007724 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8007714:	f000 021f 	and.w	r2, r0, #31
 8007718:	0940      	lsrs	r0, r0, #5
 800771a:	2301      	movs	r3, #1
 800771c:	4093      	lsls	r3, r2
 800771e:	4a02      	ldr	r2, [pc, #8]	; (8007728 <HAL_NVIC_EnableIRQ+0x18>)
 8007720:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8007724:	4770      	bx	lr
 8007726:	bf00      	nop
 8007728:	e000e100 	.word	0xe000e100

0800772c <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800772c:	2800      	cmp	r0, #0
 800772e:	db0c      	blt.n	800774a <HAL_NVIC_DisableIRQ+0x1e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8007730:	f000 021f 	and.w	r2, r0, #31
 8007734:	0940      	lsrs	r0, r0, #5
 8007736:	2301      	movs	r3, #1
 8007738:	4093      	lsls	r3, r2
 800773a:	3020      	adds	r0, #32
 800773c:	4a03      	ldr	r2, [pc, #12]	; (800774c <HAL_NVIC_DisableIRQ+0x20>)
 800773e:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 8007742:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8007746:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800774a:	4770      	bx	lr
 800774c:	e000e100 	.word	0xe000e100

08007750 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8007750:	3801      	subs	r0, #1
 8007752:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8007756:	d20b      	bcs.n	8007770 <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8007758:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800775c:	6158      	str	r0, [r3, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800775e:	4a05      	ldr	r2, [pc, #20]	; (8007774 <HAL_SYSTICK_Config+0x24>)
 8007760:	21f0      	movs	r1, #240	; 0xf0
 8007762:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8007766:	2000      	movs	r0, #0
 8007768:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 800776a:	2207      	movs	r2, #7
 800776c:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 800776e:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8007770:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8007772:	4770      	bx	lr
 8007774:	e000ed00 	.word	0xe000ed00

08007778 <HAL_SYSTICK_CLKSourceConfig>:
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8007778:	2804      	cmp	r0, #4
 800777a:	d006      	beq.n	800778a <HAL_SYSTICK_CLKSourceConfig+0x12>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 800777c:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8007780:	6913      	ldr	r3, [r2, #16]
 8007782:	f023 0304 	bic.w	r3, r3, #4
 8007786:	6113      	str	r3, [r2, #16]
  }
}
 8007788:	4770      	bx	lr
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 800778a:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 800778e:	6913      	ldr	r3, [r2, #16]
 8007790:	f043 0304 	orr.w	r3, r3, #4
 8007794:	6113      	str	r3, [r2, #16]
 8007796:	4770      	bx	lr

08007798 <HAL_DMA_Abort_IT>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8007798:	b508      	push	{r3, lr}
  HAL_StatusTypeDef status = HAL_OK;

  if(HAL_DMA_STATE_BUSY != hdma->State)
 800779a:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 800779e:	b2db      	uxtb	r3, r3
 80077a0:	2b02      	cmp	r3, #2
 80077a2:	d003      	beq.n	80077ac <HAL_DMA_Abort_IT+0x14>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80077a4:	2304      	movs	r3, #4
 80077a6:	63c3      	str	r3, [r0, #60]	; 0x3c

    status = HAL_ERROR;
 80077a8:	2001      	movs	r0, #1
    {
      hdma->XferAbortCallback(hdma);
    }
  }
  return status;
}
 80077aa:	bd08      	pop	{r3, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80077ac:	6802      	ldr	r2, [r0, #0]
 80077ae:	6813      	ldr	r3, [r2, #0]
 80077b0:	f023 030e 	bic.w	r3, r3, #14
 80077b4:	6013      	str	r3, [r2, #0]
    __HAL_DMA_DISABLE(hdma);
 80077b6:	6802      	ldr	r2, [r0, #0]
 80077b8:	6813      	ldr	r3, [r2, #0]
 80077ba:	f023 0301 	bic.w	r3, r3, #1
 80077be:	6013      	str	r3, [r2, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 80077c0:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80077c2:	f003 031c 	and.w	r3, r3, #28
 80077c6:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80077c8:	2201      	movs	r2, #1
 80077ca:	fa02 f303 	lsl.w	r3, r2, r3
 80077ce:	604b      	str	r3, [r1, #4]
    hdma->State = HAL_DMA_STATE_READY;
 80077d0:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
    __HAL_UNLOCK(hdma);
 80077d4:	2300      	movs	r3, #0
 80077d6:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    if(hdma->XferAbortCallback != NULL)
 80077da:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80077dc:	b113      	cbz	r3, 80077e4 <HAL_DMA_Abort_IT+0x4c>
      hdma->XferAbortCallback(hdma);
 80077de:	4798      	blx	r3
  HAL_StatusTypeDef status = HAL_OK;
 80077e0:	2000      	movs	r0, #0
 80077e2:	e7e2      	b.n	80077aa <HAL_DMA_Abort_IT+0x12>
 80077e4:	2000      	movs	r0, #0
 80077e6:	e7e0      	b.n	80077aa <HAL_DMA_Abort_IT+0x12>

080077e8 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80077e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80077ea:	b083      	sub	sp, #12
  uint32_t position = 0x00u;
 80077ec:	2300      	movs	r3, #0
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80077ee:	e036      	b.n	800785e <HAL_GPIO_Init+0x76>
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2u];
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80077f0:	2404      	movs	r4, #4
 80077f2:	e000      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 80077f4:	2400      	movs	r4, #0
 80077f6:	40b4      	lsls	r4, r6
 80077f8:	433c      	orrs	r4, r7
        SYSCFG->EXTICR[position >> 2u] = temp;
 80077fa:	3502      	adds	r5, #2
 80077fc:	4e5f      	ldr	r6, [pc, #380]	; (800797c <HAL_GPIO_Init+0x194>)
 80077fe:	f846 4025 	str.w	r4, [r6, r5, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8007802:	4c5f      	ldr	r4, [pc, #380]	; (8007980 <HAL_GPIO_Init+0x198>)
 8007804:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 8007806:	43d4      	mvns	r4, r2
 8007808:	ea25 0602 	bic.w	r6, r5, r2
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800780c:	684f      	ldr	r7, [r1, #4]
 800780e:	f417 3f80 	tst.w	r7, #65536	; 0x10000
 8007812:	d001      	beq.n	8007818 <HAL_GPIO_Init+0x30>
        {
          temp |= iocurrent;
 8007814:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->IMR1 = temp;
 8007818:	4d59      	ldr	r5, [pc, #356]	; (8007980 <HAL_GPIO_Init+0x198>)
 800781a:	602e      	str	r6, [r5, #0]

        temp = EXTI->EMR1;
 800781c:	686d      	ldr	r5, [r5, #4]
        temp &= ~(iocurrent);
 800781e:	ea04 0605 	and.w	r6, r4, r5
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8007822:	684f      	ldr	r7, [r1, #4]
 8007824:	f417 3f00 	tst.w	r7, #131072	; 0x20000
 8007828:	d001      	beq.n	800782e <HAL_GPIO_Init+0x46>
        {
          temp |= iocurrent;
 800782a:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->EMR1 = temp;
 800782e:	4d54      	ldr	r5, [pc, #336]	; (8007980 <HAL_GPIO_Init+0x198>)
 8007830:	606e      	str	r6, [r5, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8007832:	68ad      	ldr	r5, [r5, #8]
        temp &= ~(iocurrent);
 8007834:	ea04 0605 	and.w	r6, r4, r5
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8007838:	684f      	ldr	r7, [r1, #4]
 800783a:	f417 1f80 	tst.w	r7, #1048576	; 0x100000
 800783e:	d001      	beq.n	8007844 <HAL_GPIO_Init+0x5c>
        {
          temp |= iocurrent;
 8007840:	ea42 0605 	orr.w	r6, r2, r5
        }
        EXTI->RTSR1 = temp;
 8007844:	4d4e      	ldr	r5, [pc, #312]	; (8007980 <HAL_GPIO_Init+0x198>)
 8007846:	60ae      	str	r6, [r5, #8]

        temp = EXTI->FTSR1;
 8007848:	68ed      	ldr	r5, [r5, #12]
        temp &= ~(iocurrent);
 800784a:	402c      	ands	r4, r5
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800784c:	684e      	ldr	r6, [r1, #4]
 800784e:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
 8007852:	d001      	beq.n	8007858 <HAL_GPIO_Init+0x70>
        {
          temp |= iocurrent;
 8007854:	ea42 0405 	orr.w	r4, r2, r5
        }
        EXTI->FTSR1 = temp;
 8007858:	4a49      	ldr	r2, [pc, #292]	; (8007980 <HAL_GPIO_Init+0x198>)
 800785a:	60d4      	str	r4, [r2, #12]
      }
    }

    position++;
 800785c:	3301      	adds	r3, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800785e:	680a      	ldr	r2, [r1, #0]
 8007860:	fa32 f403 	lsrs.w	r4, r2, r3
 8007864:	f000 8087 	beq.w	8007976 <HAL_GPIO_Init+0x18e>
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8007868:	f04f 0c01 	mov.w	ip, #1
 800786c:	fa0c fc03 	lsl.w	ip, ip, r3
    if (iocurrent != 0x00u)
 8007870:	ea1c 0202 	ands.w	r2, ip, r2
 8007874:	d0f2      	beq.n	800785c <HAL_GPIO_Init+0x74>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8007876:	684c      	ldr	r4, [r1, #4]
 8007878:	1e65      	subs	r5, r4, #1
 800787a:	2d01      	cmp	r5, #1
 800787c:	d903      	bls.n	8007886 <HAL_GPIO_Init+0x9e>
 800787e:	2c11      	cmp	r4, #17
 8007880:	d001      	beq.n	8007886 <HAL_GPIO_Init+0x9e>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8007882:	2c12      	cmp	r4, #18
 8007884:	d112      	bne.n	80078ac <HAL_GPIO_Init+0xc4>
        temp = GPIOx->OSPEEDR;
 8007886:	6885      	ldr	r5, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 8007888:	005e      	lsls	r6, r3, #1
 800788a:	2403      	movs	r4, #3
 800788c:	40b4      	lsls	r4, r6
 800788e:	ea25 0504 	bic.w	r5, r5, r4
        temp |= (GPIO_Init->Speed << (position * 2u));
 8007892:	68cc      	ldr	r4, [r1, #12]
 8007894:	40b4      	lsls	r4, r6
 8007896:	432c      	orrs	r4, r5
        GPIOx->OSPEEDR = temp;
 8007898:	6084      	str	r4, [r0, #8]
        temp = GPIOx->OTYPER;
 800789a:	6845      	ldr	r5, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800789c:	ea25 050c 	bic.w	r5, r5, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 80078a0:	684c      	ldr	r4, [r1, #4]
 80078a2:	f3c4 1400 	ubfx	r4, r4, #4, #1
 80078a6:	409c      	lsls	r4, r3
 80078a8:	432c      	orrs	r4, r5
        GPIOx->OTYPER = temp;
 80078aa:	6044      	str	r4, [r0, #4]
      temp = GPIOx->PUPDR;
 80078ac:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 80078ae:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 80078b2:	2403      	movs	r4, #3
 80078b4:	fa04 f40e 	lsl.w	r4, r4, lr
 80078b8:	ea6f 0c04 	mvn.w	ip, r4
 80078bc:	ea25 0504 	bic.w	r5, r5, r4
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80078c0:	688c      	ldr	r4, [r1, #8]
 80078c2:	fa04 f40e 	lsl.w	r4, r4, lr
 80078c6:	432c      	orrs	r4, r5
      GPIOx->PUPDR = temp;
 80078c8:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80078ca:	684c      	ldr	r4, [r1, #4]
 80078cc:	2c02      	cmp	r4, #2
 80078ce:	d001      	beq.n	80078d4 <HAL_GPIO_Init+0xec>
 80078d0:	2c12      	cmp	r4, #18
 80078d2:	d10f      	bne.n	80078f4 <HAL_GPIO_Init+0x10c>
        temp = GPIOx->AFR[position >> 3u];
 80078d4:	08dd      	lsrs	r5, r3, #3
 80078d6:	3508      	adds	r5, #8
 80078d8:	f850 7025 	ldr.w	r7, [r0, r5, lsl #2]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 80078dc:	f003 0607 	and.w	r6, r3, #7
 80078e0:	00b6      	lsls	r6, r6, #2
 80078e2:	240f      	movs	r4, #15
 80078e4:	40b4      	lsls	r4, r6
 80078e6:	ea27 0704 	bic.w	r7, r7, r4
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 80078ea:	690c      	ldr	r4, [r1, #16]
 80078ec:	40b4      	lsls	r4, r6
 80078ee:	433c      	orrs	r4, r7
        GPIOx->AFR[position >> 3u] = temp;
 80078f0:	f840 4025 	str.w	r4, [r0, r5, lsl #2]
      temp = GPIOx->MODER;
 80078f4:	6804      	ldr	r4, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80078f6:	ea0c 0c04 	and.w	ip, ip, r4
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80078fa:	684c      	ldr	r4, [r1, #4]
 80078fc:	f004 0403 	and.w	r4, r4, #3
 8007900:	fa04 f40e 	lsl.w	r4, r4, lr
 8007904:	ea44 040c 	orr.w	r4, r4, ip
      GPIOx->MODER = temp;
 8007908:	6004      	str	r4, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800790a:	684c      	ldr	r4, [r1, #4]
 800790c:	f014 5f80 	tst.w	r4, #268435456	; 0x10000000
 8007910:	d0a4      	beq.n	800785c <HAL_GPIO_Init+0x74>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8007912:	4c1c      	ldr	r4, [pc, #112]	; (8007984 <HAL_GPIO_Init+0x19c>)
 8007914:	6e25      	ldr	r5, [r4, #96]	; 0x60
 8007916:	f045 0501 	orr.w	r5, r5, #1
 800791a:	6625      	str	r5, [r4, #96]	; 0x60
 800791c:	6e24      	ldr	r4, [r4, #96]	; 0x60
 800791e:	f004 0401 	and.w	r4, r4, #1
 8007922:	9401      	str	r4, [sp, #4]
 8007924:	9c01      	ldr	r4, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2u];
 8007926:	089d      	lsrs	r5, r3, #2
 8007928:	1cae      	adds	r6, r5, #2
 800792a:	4c14      	ldr	r4, [pc, #80]	; (800797c <HAL_GPIO_Init+0x194>)
 800792c:	f854 7026 	ldr.w	r7, [r4, r6, lsl #2]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 8007930:	f003 0603 	and.w	r6, r3, #3
 8007934:	00b6      	lsls	r6, r6, #2
 8007936:	240f      	movs	r4, #15
 8007938:	40b4      	lsls	r4, r6
 800793a:	ea27 0704 	bic.w	r7, r7, r4
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800793e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
 8007942:	f43f af57 	beq.w	80077f4 <HAL_GPIO_Init+0xc>
 8007946:	4c10      	ldr	r4, [pc, #64]	; (8007988 <HAL_GPIO_Init+0x1a0>)
 8007948:	42a0      	cmp	r0, r4
 800794a:	d00e      	beq.n	800796a <HAL_GPIO_Init+0x182>
 800794c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8007950:	42a0      	cmp	r0, r4
 8007952:	d00c      	beq.n	800796e <HAL_GPIO_Init+0x186>
 8007954:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8007958:	42a0      	cmp	r0, r4
 800795a:	d00a      	beq.n	8007972 <HAL_GPIO_Init+0x18a>
 800795c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8007960:	42a0      	cmp	r0, r4
 8007962:	f43f af45 	beq.w	80077f0 <HAL_GPIO_Init+0x8>
 8007966:	2407      	movs	r4, #7
 8007968:	e745      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 800796a:	2401      	movs	r4, #1
 800796c:	e743      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 800796e:	2402      	movs	r4, #2
 8007970:	e741      	b.n	80077f6 <HAL_GPIO_Init+0xe>
 8007972:	2403      	movs	r4, #3
 8007974:	e73f      	b.n	80077f6 <HAL_GPIO_Init+0xe>
  }
}
 8007976:	b003      	add	sp, #12
 8007978:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800797a:	bf00      	nop
 800797c:	40010000 	.word	0x40010000
 8007980:	40010400 	.word	0x40010400
 8007984:	40021000 	.word	0x40021000
 8007988:	48000400 	.word	0x48000400

0800798c <HAL_GPIO_DeInit>:
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
  uint32_t position = 0x00u;
 800798c:	2300      	movs	r3, #0
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00u)
 800798e:	fa31 f203 	lsrs.w	r2, r1, r3
 8007992:	d07a      	beq.n	8007a8a <HAL_GPIO_DeInit+0xfe>
{
 8007994:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007996:	e02e      	b.n	80079f6 <HAL_GPIO_DeInit+0x6a>
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */

      tmp = SYSCFG->EXTICR[position >> 2u];
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8007998:	2504      	movs	r5, #4
 800799a:	e000      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 800799c:	2500      	movs	r5, #0
 800799e:	fa05 f50c 	lsl.w	r5, r5, ip
 80079a2:	42a5      	cmp	r5, r4
 80079a4:	d055      	beq.n	8007a52 <HAL_GPIO_DeInit+0xc6>
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 80079a6:	6804      	ldr	r4, [r0, #0]
 80079a8:	005d      	lsls	r5, r3, #1
 80079aa:	f04f 0c03 	mov.w	ip, #3
 80079ae:	fa0c fc05 	lsl.w	ip, ip, r5
 80079b2:	ea44 040c 	orr.w	r4, r4, ip
 80079b6:	6004      	str	r4, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 80079b8:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 80079bc:	f10e 0e08 	add.w	lr, lr, #8
 80079c0:	f850 402e 	ldr.w	r4, [r0, lr, lsl #2]
 80079c4:	f003 0607 	and.w	r6, r3, #7
 80079c8:	00b6      	lsls	r6, r6, #2
 80079ca:	250f      	movs	r5, #15
 80079cc:	40b5      	lsls	r5, r6
 80079ce:	ea24 0405 	bic.w	r4, r4, r5
 80079d2:	f840 402e 	str.w	r4, [r0, lr, lsl #2]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 80079d6:	6884      	ldr	r4, [r0, #8]
 80079d8:	ea24 040c 	bic.w	r4, r4, ip
 80079dc:	6084      	str	r4, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80079de:	6844      	ldr	r4, [r0, #4]
 80079e0:	ea24 0202 	bic.w	r2, r4, r2
 80079e4:	6042      	str	r2, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 80079e6:	68c2      	ldr	r2, [r0, #12]
 80079e8:	ea22 020c 	bic.w	r2, r2, ip
 80079ec:	60c2      	str	r2, [r0, #12]
      /* Deactivate the Control bit of Analog mode for the current IO */
      GPIOx->ASCR &= ~(GPIO_ASCR_ASC0<< position);
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
    }

    position++;
 80079ee:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00u)
 80079f0:	fa31 f203 	lsrs.w	r2, r1, r3
 80079f4:	d048      	beq.n	8007a88 <HAL_GPIO_DeInit+0xfc>
    iocurrent = (GPIO_Pin) & (1uL << position);
 80079f6:	2201      	movs	r2, #1
 80079f8:	409a      	lsls	r2, r3
    if (iocurrent != 0x00u)
 80079fa:	ea12 0701 	ands.w	r7, r2, r1
 80079fe:	d0f6      	beq.n	80079ee <HAL_GPIO_DeInit+0x62>
      tmp = SYSCFG->EXTICR[position >> 2u];
 8007a00:	ea4f 0e93 	mov.w	lr, r3, lsr #2
 8007a04:	f10e 0502 	add.w	r5, lr, #2
 8007a08:	4c20      	ldr	r4, [pc, #128]	; (8007a8c <HAL_GPIO_DeInit+0x100>)
 8007a0a:	f854 4025 	ldr.w	r4, [r4, r5, lsl #2]
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 8007a0e:	f003 0c03 	and.w	ip, r3, #3
 8007a12:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8007a16:	250f      	movs	r5, #15
 8007a18:	fa05 f60c 	lsl.w	r6, r5, ip
 8007a1c:	4034      	ands	r4, r6
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8007a1e:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
 8007a22:	d0bb      	beq.n	800799c <HAL_GPIO_DeInit+0x10>
 8007a24:	4d1a      	ldr	r5, [pc, #104]	; (8007a90 <HAL_GPIO_DeInit+0x104>)
 8007a26:	42a8      	cmp	r0, r5
 8007a28:	d00d      	beq.n	8007a46 <HAL_GPIO_DeInit+0xba>
 8007a2a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007a2e:	42a8      	cmp	r0, r5
 8007a30:	d00b      	beq.n	8007a4a <HAL_GPIO_DeInit+0xbe>
 8007a32:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007a36:	42a8      	cmp	r0, r5
 8007a38:	d009      	beq.n	8007a4e <HAL_GPIO_DeInit+0xc2>
 8007a3a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8007a3e:	42a8      	cmp	r0, r5
 8007a40:	d0aa      	beq.n	8007998 <HAL_GPIO_DeInit+0xc>
 8007a42:	2507      	movs	r5, #7
 8007a44:	e7ab      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 8007a46:	2501      	movs	r5, #1
 8007a48:	e7a9      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 8007a4a:	2502      	movs	r5, #2
 8007a4c:	e7a7      	b.n	800799e <HAL_GPIO_DeInit+0x12>
 8007a4e:	2503      	movs	r5, #3
 8007a50:	e7a5      	b.n	800799e <HAL_GPIO_DeInit+0x12>
        EXTI->IMR1 &= ~(iocurrent);
 8007a52:	4c10      	ldr	r4, [pc, #64]	; (8007a94 <HAL_GPIO_DeInit+0x108>)
 8007a54:	6825      	ldr	r5, [r4, #0]
 8007a56:	ea25 0507 	bic.w	r5, r5, r7
 8007a5a:	6025      	str	r5, [r4, #0]
        EXTI->EMR1 &= ~(iocurrent);
 8007a5c:	6865      	ldr	r5, [r4, #4]
 8007a5e:	ea25 0507 	bic.w	r5, r5, r7
 8007a62:	6065      	str	r5, [r4, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 8007a64:	68a5      	ldr	r5, [r4, #8]
 8007a66:	ea25 0507 	bic.w	r5, r5, r7
 8007a6a:	60a5      	str	r5, [r4, #8]
        EXTI->FTSR1 &= ~(iocurrent);
 8007a6c:	68e5      	ldr	r5, [r4, #12]
 8007a6e:	ea25 0507 	bic.w	r5, r5, r7
 8007a72:	60e5      	str	r5, [r4, #12]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 8007a74:	4f05      	ldr	r7, [pc, #20]	; (8007a8c <HAL_GPIO_DeInit+0x100>)
 8007a76:	f10e 0402 	add.w	r4, lr, #2
 8007a7a:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 8007a7e:	ea25 0506 	bic.w	r5, r5, r6
 8007a82:	f847 5024 	str.w	r5, [r7, r4, lsl #2]
 8007a86:	e78e      	b.n	80079a6 <HAL_GPIO_DeInit+0x1a>
  }
}
 8007a88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007a8a:	4770      	bx	lr
 8007a8c:	40010000 	.word	0x40010000
 8007a90:	48000400 	.word	0x48000400
 8007a94:	40010400 	.word	0x40010400

08007a98 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
 8007a98:	6903      	ldr	r3, [r0, #16]
 8007a9a:	4219      	tst	r1, r3
 8007a9c:	d001      	beq.n	8007aa2 <HAL_GPIO_ReadPin+0xa>
  {
    bitstatus = GPIO_PIN_SET;
 8007a9e:	2001      	movs	r0, #1
 8007aa0:	4770      	bx	lr
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8007aa2:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8007aa4:	4770      	bx	lr

08007aa6 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8007aa6:	b10a      	cbz	r2, 8007aac <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8007aa8:	6181      	str	r1, [r0, #24]
 8007aaa:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8007aac:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 8007aae:	4770      	bx	lr

08007ab0 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8007ab0:	b508      	push	{r3, lr}
  /* EXTI line interrupt detected */
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8007ab2:	4b05      	ldr	r3, [pc, #20]	; (8007ac8 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 8007ab4:	695b      	ldr	r3, [r3, #20]
 8007ab6:	4203      	tst	r3, r0
 8007ab8:	d100      	bne.n	8007abc <HAL_GPIO_EXTI_IRQHandler+0xc>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}
 8007aba:	bd08      	pop	{r3, pc}
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8007abc:	4b02      	ldr	r3, [pc, #8]	; (8007ac8 <HAL_GPIO_EXTI_IRQHandler+0x18>)
 8007abe:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8007ac0:	f016 fcba 	bl	801e438 <HAL_GPIO_EXTI_Callback>
}
 8007ac4:	e7f9      	b.n	8007aba <HAL_GPIO_EXTI_IRQHandler+0xa>
 8007ac6:	bf00      	nop
 8007ac8:	40010400 	.word	0x40010400

08007acc <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007acc:	6803      	ldr	r3, [r0, #0]
 8007ace:	699a      	ldr	r2, [r3, #24]
 8007ad0:	f012 0f02 	tst.w	r2, #2
 8007ad4:	d001      	beq.n	8007ada <I2C_Flush_TXDR+0xe>
  {
    hi2c->Instance->TXDR = 0x00U;
 8007ad6:	2200      	movs	r2, #0
 8007ad8:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007ada:	6803      	ldr	r3, [r0, #0]
 8007adc:	699a      	ldr	r2, [r3, #24]
 8007ade:	f012 0f01 	tst.w	r2, #1
 8007ae2:	d103      	bne.n	8007aec <I2C_Flush_TXDR+0x20>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007ae4:	699a      	ldr	r2, [r3, #24]
 8007ae6:	f042 0201 	orr.w	r2, r2, #1
 8007aea:	619a      	str	r2, [r3, #24]
  }
}
 8007aec:	4770      	bx	lr

08007aee <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 8007aee:	b430      	push	{r4, r5}
 8007af0:	9d02      	ldr	r5, [sp, #8]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2,
 8007af2:	6804      	ldr	r4, [r0, #0]
 8007af4:	6860      	ldr	r0, [r4, #4]
 8007af6:	ea4f 5c55 	mov.w	ip, r5, lsr #21
 8007afa:	f40c 6c80 	and.w	ip, ip, #1024	; 0x400
 8007afe:	f04c 7c7f 	orr.w	ip, ip, #66846720	; 0x3fc0000
 8007b02:	f44c 3c58 	orr.w	ip, ip, #221184	; 0x36000
 8007b06:	f44c 7c7f 	orr.w	ip, ip, #1020	; 0x3fc
 8007b0a:	f04c 0c03 	orr.w	ip, ip, #3
 8007b0e:	ea20 000c 	bic.w	r0, r0, ip
 8007b12:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8007b16:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8007b1a:	4319      	orrs	r1, r3
 8007b1c:	4329      	orrs	r1, r5
 8007b1e:	4308      	orrs	r0, r1
 8007b20:	6060      	str	r0, [r4, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) |
                        (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 8007b22:	bc30      	pop	{r4, r5}
 8007b24:	4770      	bx	lr

08007b26 <I2C_IsAcknowledgeFailed>:
{
 8007b26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007b28:	4605      	mov	r5, r0
 8007b2a:	460e      	mov	r6, r1
 8007b2c:	4617      	mov	r7, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007b2e:	6803      	ldr	r3, [r0, #0]
 8007b30:	699b      	ldr	r3, [r3, #24]
 8007b32:	f013 0f10 	tst.w	r3, #16
 8007b36:	d101      	bne.n	8007b3c <I2C_IsAcknowledgeFailed+0x16>
  return HAL_OK;
 8007b38:	2000      	movs	r0, #0
}
 8007b3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007b3c:	682b      	ldr	r3, [r5, #0]
 8007b3e:	699c      	ldr	r4, [r3, #24]
 8007b40:	f014 0f20 	tst.w	r4, #32
 8007b44:	d117      	bne.n	8007b76 <I2C_IsAcknowledgeFailed+0x50>
      if (Timeout != HAL_MAX_DELAY)
 8007b46:	f1b6 3fff 	cmp.w	r6, #4294967295
 8007b4a:	d0f7      	beq.n	8007b3c <I2C_IsAcknowledgeFailed+0x16>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007b4c:	f7ff fa24 	bl	8006f98 <HAL_GetTick>
 8007b50:	1bc0      	subs	r0, r0, r7
 8007b52:	42b0      	cmp	r0, r6
 8007b54:	d801      	bhi.n	8007b5a <I2C_IsAcknowledgeFailed+0x34>
 8007b56:	2e00      	cmp	r6, #0
 8007b58:	d1f0      	bne.n	8007b3c <I2C_IsAcknowledgeFailed+0x16>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007b5a:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8007b5c:	f043 0320 	orr.w	r3, r3, #32
 8007b60:	646b      	str	r3, [r5, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8007b62:	2320      	movs	r3, #32
 8007b64:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8007b68:	2300      	movs	r3, #0
 8007b6a:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
          __HAL_UNLOCK(hi2c);
 8007b6e:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
          return HAL_ERROR;
 8007b72:	2001      	movs	r0, #1
 8007b74:	e7e1      	b.n	8007b3a <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007b76:	2210      	movs	r2, #16
 8007b78:	61da      	str	r2, [r3, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007b7a:	682b      	ldr	r3, [r5, #0]
 8007b7c:	2420      	movs	r4, #32
 8007b7e:	61dc      	str	r4, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8007b80:	4628      	mov	r0, r5
 8007b82:	f7ff ffa3 	bl	8007acc <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8007b86:	682a      	ldr	r2, [r5, #0]
 8007b88:	6853      	ldr	r3, [r2, #4]
 8007b8a:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8007b8e:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 8007b92:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8007b96:	f023 0301 	bic.w	r3, r3, #1
 8007b9a:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007b9c:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8007b9e:	f043 0304 	orr.w	r3, r3, #4
 8007ba2:	646b      	str	r3, [r5, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8007ba4:	f885 4041 	strb.w	r4, [r5, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ba8:	2300      	movs	r3, #0
 8007baa:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8007bae:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    return HAL_ERROR;
 8007bb2:	2001      	movs	r0, #1
 8007bb4:	e7c1      	b.n	8007b3a <I2C_IsAcknowledgeFailed+0x14>

08007bb6 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8007bb6:	b570      	push	{r4, r5, r6, lr}
 8007bb8:	4604      	mov	r4, r0
 8007bba:	460d      	mov	r5, r1
 8007bbc:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007bbe:	6823      	ldr	r3, [r4, #0]
 8007bc0:	699b      	ldr	r3, [r3, #24]
 8007bc2:	f013 0f02 	tst.w	r3, #2
 8007bc6:	d11d      	bne.n	8007c04 <I2C_WaitOnTXISFlagUntilTimeout+0x4e>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007bc8:	4632      	mov	r2, r6
 8007bca:	4629      	mov	r1, r5
 8007bcc:	4620      	mov	r0, r4
 8007bce:	f7ff ffaa 	bl	8007b26 <I2C_IsAcknowledgeFailed>
 8007bd2:	b9c8      	cbnz	r0, 8007c08 <I2C_WaitOnTXISFlagUntilTimeout+0x52>
    if (Timeout != HAL_MAX_DELAY)
 8007bd4:	f1b5 3fff 	cmp.w	r5, #4294967295
 8007bd8:	d0f1      	beq.n	8007bbe <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007bda:	f7ff f9dd 	bl	8006f98 <HAL_GetTick>
 8007bde:	1b80      	subs	r0, r0, r6
 8007be0:	42a8      	cmp	r0, r5
 8007be2:	d801      	bhi.n	8007be8 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 8007be4:	2d00      	cmp	r5, #0
 8007be6:	d1ea      	bne.n	8007bbe <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007be8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007bea:	f043 0320 	orr.w	r3, r3, #32
 8007bee:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8007bf0:	2320      	movs	r3, #32
 8007bf2:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007bf6:	2300      	movs	r3, #0
 8007bf8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8007bfc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
 8007c00:	2001      	movs	r0, #1
 8007c02:	e000      	b.n	8007c06 <I2C_WaitOnTXISFlagUntilTimeout+0x50>
  return HAL_OK;
 8007c04:	2000      	movs	r0, #0
}
 8007c06:	bd70      	pop	{r4, r5, r6, pc}
      return HAL_ERROR;
 8007c08:	2001      	movs	r0, #1
 8007c0a:	e7fc      	b.n	8007c06 <I2C_WaitOnTXISFlagUntilTimeout+0x50>

08007c0c <I2C_WaitOnFlagUntilTimeout>:
{
 8007c0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007c10:	4606      	mov	r6, r0
 8007c12:	4688      	mov	r8, r1
 8007c14:	4617      	mov	r7, r2
 8007c16:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007c18:	6834      	ldr	r4, [r6, #0]
 8007c1a:	69a4      	ldr	r4, [r4, #24]
 8007c1c:	ea38 0404 	bics.w	r4, r8, r4
 8007c20:	bf0c      	ite	eq
 8007c22:	2401      	moveq	r4, #1
 8007c24:	2400      	movne	r4, #0
 8007c26:	42bc      	cmp	r4, r7
 8007c28:	d118      	bne.n	8007c5c <I2C_WaitOnFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
 8007c2a:	f1b5 3fff 	cmp.w	r5, #4294967295
 8007c2e:	d0f3      	beq.n	8007c18 <I2C_WaitOnFlagUntilTimeout+0xc>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007c30:	f7ff f9b2 	bl	8006f98 <HAL_GetTick>
 8007c34:	9b06      	ldr	r3, [sp, #24]
 8007c36:	1ac0      	subs	r0, r0, r3
 8007c38:	42a8      	cmp	r0, r5
 8007c3a:	d801      	bhi.n	8007c40 <I2C_WaitOnFlagUntilTimeout+0x34>
 8007c3c:	2d00      	cmp	r5, #0
 8007c3e:	d1eb      	bne.n	8007c18 <I2C_WaitOnFlagUntilTimeout+0xc>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007c40:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8007c42:	f043 0320 	orr.w	r3, r3, #32
 8007c46:	6473      	str	r3, [r6, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8007c48:	2320      	movs	r3, #32
 8007c4a:	f886 3041 	strb.w	r3, [r6, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c4e:	2300      	movs	r3, #0
 8007c50:	f886 3042 	strb.w	r3, [r6, #66]	; 0x42
        __HAL_UNLOCK(hi2c);
 8007c54:	f886 3040 	strb.w	r3, [r6, #64]	; 0x40
        return HAL_ERROR;
 8007c58:	2001      	movs	r0, #1
 8007c5a:	e000      	b.n	8007c5e <I2C_WaitOnFlagUntilTimeout+0x52>
  return HAL_OK;
 8007c5c:	2000      	movs	r0, #0
}
 8007c5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	...

08007c64 <I2C_RequestMemoryWrite>:
{
 8007c64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007c68:	b082      	sub	sp, #8
 8007c6a:	4604      	mov	r4, r0
 8007c6c:	4690      	mov	r8, r2
 8007c6e:	461d      	mov	r5, r3
 8007c70:	9e08      	ldr	r6, [sp, #32]
 8007c72:	9f09      	ldr	r7, [sp, #36]	; 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8007c74:	4b19      	ldr	r3, [pc, #100]	; (8007cdc <I2C_RequestMemoryWrite+0x78>)
 8007c76:	9300      	str	r3, [sp, #0]
 8007c78:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007c7c:	b2ea      	uxtb	r2, r5
 8007c7e:	f7ff ff36 	bl	8007aee <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007c82:	463a      	mov	r2, r7
 8007c84:	4631      	mov	r1, r6
 8007c86:	4620      	mov	r0, r4
 8007c88:	f7ff ff95 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007c8c:	b9f8      	cbnz	r0, 8007cce <I2C_RequestMemoryWrite+0x6a>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007c8e:	2d01      	cmp	r5, #1
 8007c90:	d10e      	bne.n	8007cb0 <I2C_RequestMemoryWrite+0x4c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007c92:	6823      	ldr	r3, [r4, #0]
 8007c94:	fa5f f288 	uxtb.w	r2, r8
 8007c98:	629a      	str	r2, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8007c9a:	9700      	str	r7, [sp, #0]
 8007c9c:	4633      	mov	r3, r6
 8007c9e:	2200      	movs	r2, #0
 8007ca0:	2180      	movs	r1, #128	; 0x80
 8007ca2:	4620      	mov	r0, r4
 8007ca4:	f7ff ffb2 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007ca8:	b9a8      	cbnz	r0, 8007cd6 <I2C_RequestMemoryWrite+0x72>
}
 8007caa:	b002      	add	sp, #8
 8007cac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007cb0:	6823      	ldr	r3, [r4, #0]
 8007cb2:	ea4f 2218 	mov.w	r2, r8, lsr #8
 8007cb6:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007cb8:	463a      	mov	r2, r7
 8007cba:	4631      	mov	r1, r6
 8007cbc:	4620      	mov	r0, r4
 8007cbe:	f7ff ff7a 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007cc2:	b930      	cbnz	r0, 8007cd2 <I2C_RequestMemoryWrite+0x6e>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007cc4:	6823      	ldr	r3, [r4, #0]
 8007cc6:	fa5f f288 	uxtb.w	r2, r8
 8007cca:	629a      	str	r2, [r3, #40]	; 0x28
 8007ccc:	e7e5      	b.n	8007c9a <I2C_RequestMemoryWrite+0x36>
    return HAL_ERROR;
 8007cce:	2001      	movs	r0, #1
 8007cd0:	e7eb      	b.n	8007caa <I2C_RequestMemoryWrite+0x46>
      return HAL_ERROR;
 8007cd2:	2001      	movs	r0, #1
 8007cd4:	e7e9      	b.n	8007caa <I2C_RequestMemoryWrite+0x46>
    return HAL_ERROR;
 8007cd6:	2001      	movs	r0, #1
 8007cd8:	e7e7      	b.n	8007caa <I2C_RequestMemoryWrite+0x46>
 8007cda:	bf00      	nop
 8007cdc:	80002000 	.word	0x80002000

08007ce0 <I2C_RequestMemoryRead>:
{
 8007ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007ce4:	b082      	sub	sp, #8
 8007ce6:	4604      	mov	r4, r0
 8007ce8:	4690      	mov	r8, r2
 8007cea:	461d      	mov	r5, r3
 8007cec:	9e08      	ldr	r6, [sp, #32]
 8007cee:	9f09      	ldr	r7, [sp, #36]	; 0x24
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8007cf0:	4b18      	ldr	r3, [pc, #96]	; (8007d54 <I2C_RequestMemoryRead+0x74>)
 8007cf2:	9300      	str	r3, [sp, #0]
 8007cf4:	2300      	movs	r3, #0
 8007cf6:	b2ea      	uxtb	r2, r5
 8007cf8:	f7ff fef9 	bl	8007aee <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007cfc:	463a      	mov	r2, r7
 8007cfe:	4631      	mov	r1, r6
 8007d00:	4620      	mov	r0, r4
 8007d02:	f7ff ff58 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d06:	b9f8      	cbnz	r0, 8007d48 <I2C_RequestMemoryRead+0x68>
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8007d08:	2d01      	cmp	r5, #1
 8007d0a:	d10e      	bne.n	8007d2a <I2C_RequestMemoryRead+0x4a>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d0c:	6823      	ldr	r3, [r4, #0]
 8007d0e:	fa5f f288 	uxtb.w	r2, r8
 8007d12:	629a      	str	r2, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8007d14:	9700      	str	r7, [sp, #0]
 8007d16:	4633      	mov	r3, r6
 8007d18:	2200      	movs	r2, #0
 8007d1a:	2140      	movs	r1, #64	; 0x40
 8007d1c:	4620      	mov	r0, r4
 8007d1e:	f7ff ff75 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007d22:	b9a8      	cbnz	r0, 8007d50 <I2C_RequestMemoryRead+0x70>
}
 8007d24:	b002      	add	sp, #8
 8007d26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8007d2a:	6823      	ldr	r3, [r4, #0]
 8007d2c:	ea4f 2218 	mov.w	r2, r8, lsr #8
 8007d30:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d32:	463a      	mov	r2, r7
 8007d34:	4631      	mov	r1, r6
 8007d36:	4620      	mov	r0, r4
 8007d38:	f7ff ff3d 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007d3c:	b930      	cbnz	r0, 8007d4c <I2C_RequestMemoryRead+0x6c>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8007d3e:	6823      	ldr	r3, [r4, #0]
 8007d40:	fa5f f288 	uxtb.w	r2, r8
 8007d44:	629a      	str	r2, [r3, #40]	; 0x28
 8007d46:	e7e5      	b.n	8007d14 <I2C_RequestMemoryRead+0x34>
    return HAL_ERROR;
 8007d48:	2001      	movs	r0, #1
 8007d4a:	e7eb      	b.n	8007d24 <I2C_RequestMemoryRead+0x44>
      return HAL_ERROR;
 8007d4c:	2001      	movs	r0, #1
 8007d4e:	e7e9      	b.n	8007d24 <I2C_RequestMemoryRead+0x44>
    return HAL_ERROR;
 8007d50:	2001      	movs	r0, #1
 8007d52:	e7e7      	b.n	8007d24 <I2C_RequestMemoryRead+0x44>
 8007d54:	80002000 	.word	0x80002000

08007d58 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007d58:	b570      	push	{r4, r5, r6, lr}
 8007d5a:	4605      	mov	r5, r0
 8007d5c:	460c      	mov	r4, r1
 8007d5e:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007d60:	682b      	ldr	r3, [r5, #0]
 8007d62:	699b      	ldr	r3, [r3, #24]
 8007d64:	f013 0f20 	tst.w	r3, #32
 8007d68:	d11a      	bne.n	8007da0 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8007d6a:	4632      	mov	r2, r6
 8007d6c:	4621      	mov	r1, r4
 8007d6e:	4628      	mov	r0, r5
 8007d70:	f7ff fed9 	bl	8007b26 <I2C_IsAcknowledgeFailed>
 8007d74:	b9b0      	cbnz	r0, 8007da4 <I2C_WaitOnSTOPFlagUntilTimeout+0x4c>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007d76:	f7ff f90f 	bl	8006f98 <HAL_GetTick>
 8007d7a:	1b80      	subs	r0, r0, r6
 8007d7c:	42a0      	cmp	r0, r4
 8007d7e:	d801      	bhi.n	8007d84 <I2C_WaitOnSTOPFlagUntilTimeout+0x2c>
 8007d80:	2c00      	cmp	r4, #0
 8007d82:	d1ed      	bne.n	8007d60 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007d84:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8007d86:	f043 0320 	orr.w	r3, r3, #32
 8007d8a:	646b      	str	r3, [r5, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8007d8c:	2320      	movs	r3, #32
 8007d8e:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8007d92:	2300      	movs	r3, #0
 8007d94:	f885 3042 	strb.w	r3, [r5, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 8007d98:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
      return HAL_ERROR;
 8007d9c:	2001      	movs	r0, #1
}
 8007d9e:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8007da0:	2000      	movs	r0, #0
 8007da2:	e7fc      	b.n	8007d9e <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
      return HAL_ERROR;
 8007da4:	2001      	movs	r0, #1
 8007da6:	e7fa      	b.n	8007d9e <I2C_WaitOnSTOPFlagUntilTimeout+0x46>

08007da8 <HAL_I2C_Init>:
  if (hi2c == NULL)
 8007da8:	2800      	cmp	r0, #0
 8007daa:	d059      	beq.n	8007e60 <HAL_I2C_Init+0xb8>
{
 8007dac:	b510      	push	{r4, lr}
 8007dae:	4604      	mov	r4, r0
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8007db0:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8007db4:	2b00      	cmp	r3, #0
 8007db6:	d043      	beq.n	8007e40 <HAL_I2C_Init+0x98>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007db8:	2324      	movs	r3, #36	; 0x24
 8007dba:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8007dbe:	6822      	ldr	r2, [r4, #0]
 8007dc0:	6813      	ldr	r3, [r2, #0]
 8007dc2:	f023 0301 	bic.w	r3, r3, #1
 8007dc6:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8007dc8:	6863      	ldr	r3, [r4, #4]
 8007dca:	6822      	ldr	r2, [r4, #0]
 8007dcc:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8007dd0:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007dd2:	6822      	ldr	r2, [r4, #0]
 8007dd4:	6893      	ldr	r3, [r2, #8]
 8007dd6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007dda:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8007ddc:	68e3      	ldr	r3, [r4, #12]
 8007dde:	2b01      	cmp	r3, #1
 8007de0:	d033      	beq.n	8007e4a <HAL_I2C_Init+0xa2>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8007de2:	68a3      	ldr	r3, [r4, #8]
 8007de4:	6822      	ldr	r2, [r4, #0]
 8007de6:	f443 4304 	orr.w	r3, r3, #33792	; 0x8400
 8007dea:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8007dec:	68e3      	ldr	r3, [r4, #12]
 8007dee:	2b02      	cmp	r3, #2
 8007df0:	d031      	beq.n	8007e56 <HAL_I2C_Init+0xae>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8007df2:	6822      	ldr	r2, [r4, #0]
 8007df4:	6853      	ldr	r3, [r2, #4]
 8007df6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8007dfa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007dfe:	6053      	str	r3, [r2, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8007e00:	6822      	ldr	r2, [r4, #0]
 8007e02:	68d3      	ldr	r3, [r2, #12]
 8007e04:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007e08:	60d3      	str	r3, [r2, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8007e0a:	6923      	ldr	r3, [r4, #16]
 8007e0c:	6962      	ldr	r2, [r4, #20]
 8007e0e:	4313      	orrs	r3, r2
 8007e10:	69a1      	ldr	r1, [r4, #24]
 8007e12:	6822      	ldr	r2, [r4, #0]
 8007e14:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8007e18:	60d3      	str	r3, [r2, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8007e1a:	69e3      	ldr	r3, [r4, #28]
 8007e1c:	6a21      	ldr	r1, [r4, #32]
 8007e1e:	6822      	ldr	r2, [r4, #0]
 8007e20:	430b      	orrs	r3, r1
 8007e22:	6013      	str	r3, [r2, #0]
  __HAL_I2C_ENABLE(hi2c);
 8007e24:	6822      	ldr	r2, [r4, #0]
 8007e26:	6813      	ldr	r3, [r2, #0]
 8007e28:	f043 0301 	orr.w	r3, r3, #1
 8007e2c:	6013      	str	r3, [r2, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e2e:	2000      	movs	r0, #0
 8007e30:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007e32:	2320      	movs	r3, #32
 8007e34:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8007e38:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007e3a:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 8007e3e:	bd10      	pop	{r4, pc}
    hi2c->Lock = HAL_UNLOCKED;
 8007e40:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8007e44:	f7f9 f9a4 	bl	8001190 <HAL_I2C_MspInit>
 8007e48:	e7b6      	b.n	8007db8 <HAL_I2C_Init+0x10>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8007e4a:	68a3      	ldr	r3, [r4, #8]
 8007e4c:	6822      	ldr	r2, [r4, #0]
 8007e4e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8007e52:	6093      	str	r3, [r2, #8]
 8007e54:	e7ca      	b.n	8007dec <HAL_I2C_Init+0x44>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007e56:	6823      	ldr	r3, [r4, #0]
 8007e58:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8007e5c:	605a      	str	r2, [r3, #4]
 8007e5e:	e7c8      	b.n	8007df2 <HAL_I2C_Init+0x4a>
    return HAL_ERROR;
 8007e60:	2001      	movs	r0, #1
}
 8007e62:	4770      	bx	lr

08007e64 <HAL_I2C_DeInit>:
  if (hi2c == NULL)
 8007e64:	b1a8      	cbz	r0, 8007e92 <HAL_I2C_DeInit+0x2e>
{
 8007e66:	b510      	push	{r4, lr}
 8007e68:	4604      	mov	r4, r0
  hi2c->State = HAL_I2C_STATE_BUSY;
 8007e6a:	2324      	movs	r3, #36	; 0x24
 8007e6c:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8007e70:	6802      	ldr	r2, [r0, #0]
 8007e72:	6813      	ldr	r3, [r2, #0]
 8007e74:	f023 0301 	bic.w	r3, r3, #1
 8007e78:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8007e7a:	f7f9 f9b9 	bl	80011f0 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007e7e:	2000      	movs	r0, #0
 8007e80:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
 8007e82:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8007e86:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007e88:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
  __HAL_UNLOCK(hi2c);
 8007e8c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8007e90:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8007e92:	2001      	movs	r0, #1
}
 8007e94:	4770      	bx	lr

08007e96 <HAL_I2C_Mem_Write>:
{
 8007e96:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007e9a:	b083      	sub	sp, #12
 8007e9c:	460e      	mov	r6, r1
 8007e9e:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 8007ea2:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 8007ea4:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
 8007ea8:	b2c9      	uxtb	r1, r1
 8007eaa:	2920      	cmp	r1, #32
 8007eac:	f040 80bb 	bne.w	8008026 <HAL_I2C_Mem_Write+0x190>
 8007eb0:	4604      	mov	r4, r0
 8007eb2:	4690      	mov	r8, r2
 8007eb4:	4699      	mov	r9, r3
    if ((pData == NULL) || (Size == 0U))
 8007eb6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007eb8:	b1cb      	cbz	r3, 8007eee <HAL_I2C_Mem_Write+0x58>
 8007eba:	f1ba 0f00 	cmp.w	sl, #0
 8007ebe:	d016      	beq.n	8007eee <HAL_I2C_Mem_Write+0x58>
    __HAL_LOCK(hi2c);
 8007ec0:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8007ec4:	2b01      	cmp	r3, #1
 8007ec6:	f000 80b2 	beq.w	800802e <HAL_I2C_Mem_Write+0x198>
 8007eca:	f04f 0b01 	mov.w	fp, #1
 8007ece:	f880 b040 	strb.w	fp, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8007ed2:	f7ff f861 	bl	8006f98 <HAL_GetTick>
 8007ed6:	4607      	mov	r7, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8007ed8:	9000      	str	r0, [sp, #0]
 8007eda:	2319      	movs	r3, #25
 8007edc:	465a      	mov	r2, fp
 8007ede:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007ee2:	4620      	mov	r0, r4
 8007ee4:	f7ff fe92 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007ee8:	b130      	cbz	r0, 8007ef8 <HAL_I2C_Mem_Write+0x62>
      return HAL_ERROR;
 8007eea:	2001      	movs	r0, #1
 8007eec:	e09c      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8007eee:	f44f 7300 	mov.w	r3, #512	; 0x200
 8007ef2:	6463      	str	r3, [r4, #68]	; 0x44
      return  HAL_ERROR;
 8007ef4:	2001      	movs	r0, #1
 8007ef6:	e097      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007ef8:	2321      	movs	r3, #33	; 0x21
 8007efa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8007efe:	2340      	movs	r3, #64	; 0x40
 8007f00:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007f04:	2300      	movs	r3, #0
 8007f06:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 8007f08:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8007f0a:	6262      	str	r2, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 8007f0c:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8007f10:	6363      	str	r3, [r4, #52]	; 0x34
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8007f12:	9701      	str	r7, [sp, #4]
 8007f14:	9500      	str	r5, [sp, #0]
 8007f16:	464b      	mov	r3, r9
 8007f18:	4642      	mov	r2, r8
 8007f1a:	4631      	mov	r1, r6
 8007f1c:	4620      	mov	r0, r4
 8007f1e:	f7ff fea1 	bl	8007c64 <I2C_RequestMemoryWrite>
 8007f22:	b970      	cbnz	r0, 8007f42 <HAL_I2C_Mem_Write+0xac>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007f24:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f26:	b29b      	uxth	r3, r3
 8007f28:	2bff      	cmp	r3, #255	; 0xff
 8007f2a:	d90f      	bls.n	8007f4c <HAL_I2C_Mem_Write+0xb6>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8007f2c:	22ff      	movs	r2, #255	; 0xff
 8007f2e:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007f30:	2300      	movs	r3, #0
 8007f32:	9300      	str	r3, [sp, #0]
 8007f34:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007f38:	4631      	mov	r1, r6
 8007f3a:	4620      	mov	r0, r4
 8007f3c:	f7ff fdd7 	bl	8007aee <I2C_TransferConfig>
 8007f40:	e021      	b.n	8007f86 <HAL_I2C_Mem_Write+0xf0>
      __HAL_UNLOCK(hi2c);
 8007f42:	2300      	movs	r3, #0
 8007f44:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8007f48:	4658      	mov	r0, fp
 8007f4a:	e06d      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
      hi2c->XferSize = hi2c->XferCount;
 8007f4c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007f4e:	b292      	uxth	r2, r2
 8007f50:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f52:	2300      	movs	r3, #0
 8007f54:	9300      	str	r3, [sp, #0]
 8007f56:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007f5a:	b2d2      	uxtb	r2, r2
 8007f5c:	4631      	mov	r1, r6
 8007f5e:	4620      	mov	r0, r4
 8007f60:	f7ff fdc5 	bl	8007aee <I2C_TransferConfig>
 8007f64:	e00f      	b.n	8007f86 <HAL_I2C_Mem_Write+0xf0>
          hi2c->XferSize = hi2c->XferCount;
 8007f66:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007f68:	b292      	uxth	r2, r2
 8007f6a:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007f6c:	2300      	movs	r3, #0
 8007f6e:	9300      	str	r3, [sp, #0]
 8007f70:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8007f74:	b2d2      	uxtb	r2, r2
 8007f76:	4631      	mov	r1, r6
 8007f78:	4620      	mov	r0, r4
 8007f7a:	f7ff fdb8 	bl	8007aee <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
 8007f7e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007f80:	b29b      	uxth	r3, r3
 8007f82:	2b00      	cmp	r3, #0
 8007f84:	d033      	beq.n	8007fee <HAL_I2C_Mem_Write+0x158>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007f86:	463a      	mov	r2, r7
 8007f88:	4629      	mov	r1, r5
 8007f8a:	4620      	mov	r0, r4
 8007f8c:	f7ff fe13 	bl	8007bb6 <I2C_WaitOnTXISFlagUntilTimeout>
 8007f90:	2800      	cmp	r0, #0
 8007f92:	d14e      	bne.n	8008032 <HAL_I2C_Mem_Write+0x19c>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8007f94:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8007f96:	6823      	ldr	r3, [r4, #0]
 8007f98:	7812      	ldrb	r2, [r2, #0]
 8007f9a:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->pBuffPtr++;
 8007f9c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007f9e:	3301      	adds	r3, #1
 8007fa0:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8007fa2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fa4:	b29b      	uxth	r3, r3
 8007fa6:	3b01      	subs	r3, #1
 8007fa8:	b29b      	uxth	r3, r3
 8007faa:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007fac:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8007fae:	3b01      	subs	r3, #1
 8007fb0:	b29b      	uxth	r3, r3
 8007fb2:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8007fb4:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8007fb6:	b292      	uxth	r2, r2
 8007fb8:	2a00      	cmp	r2, #0
 8007fba:	d0e0      	beq.n	8007f7e <HAL_I2C_Mem_Write+0xe8>
 8007fbc:	2b00      	cmp	r3, #0
 8007fbe:	d1de      	bne.n	8007f7e <HAL_I2C_Mem_Write+0xe8>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8007fc0:	9700      	str	r7, [sp, #0]
 8007fc2:	462b      	mov	r3, r5
 8007fc4:	2200      	movs	r2, #0
 8007fc6:	2180      	movs	r1, #128	; 0x80
 8007fc8:	4620      	mov	r0, r4
 8007fca:	f7ff fe1f 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8007fce:	bb90      	cbnz	r0, 8008036 <HAL_I2C_Mem_Write+0x1a0>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8007fd0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007fd2:	b29b      	uxth	r3, r3
 8007fd4:	2bff      	cmp	r3, #255	; 0xff
 8007fd6:	d9c6      	bls.n	8007f66 <HAL_I2C_Mem_Write+0xd0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007fd8:	22ff      	movs	r2, #255	; 0xff
 8007fda:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8007fdc:	2300      	movs	r3, #0
 8007fde:	9300      	str	r3, [sp, #0]
 8007fe0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8007fe4:	4631      	mov	r1, r6
 8007fe6:	4620      	mov	r0, r4
 8007fe8:	f7ff fd81 	bl	8007aee <I2C_TransferConfig>
 8007fec:	e7c7      	b.n	8007f7e <HAL_I2C_Mem_Write+0xe8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007fee:	463a      	mov	r2, r7
 8007ff0:	4629      	mov	r1, r5
 8007ff2:	4620      	mov	r0, r4
 8007ff4:	f7ff feb0 	bl	8007d58 <I2C_WaitOnSTOPFlagUntilTimeout>
 8007ff8:	b9f8      	cbnz	r0, 800803a <HAL_I2C_Mem_Write+0x1a4>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007ffa:	6823      	ldr	r3, [r4, #0]
 8007ffc:	2220      	movs	r2, #32
 8007ffe:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8008000:	6821      	ldr	r1, [r4, #0]
 8008002:	684b      	ldr	r3, [r1, #4]
 8008004:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8008008:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 800800c:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8008010:	f023 0301 	bic.w	r3, r3, #1
 8008014:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8008016:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800801a:	2300      	movs	r3, #0
 800801c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8008020:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_OK;
 8008024:	e000      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
    return HAL_BUSY;
 8008026:	2002      	movs	r0, #2
}
 8008028:	b003      	add	sp, #12
 800802a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 800802e:	2002      	movs	r0, #2
 8008030:	e7fa      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
        return HAL_ERROR;
 8008032:	2001      	movs	r0, #1
 8008034:	e7f8      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
          return HAL_ERROR;
 8008036:	2001      	movs	r0, #1
 8008038:	e7f6      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
      return HAL_ERROR;
 800803a:	2001      	movs	r0, #1
 800803c:	e7f4      	b.n	8008028 <HAL_I2C_Mem_Write+0x192>
	...

08008040 <HAL_I2C_Mem_Read>:
{
 8008040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008044:	b083      	sub	sp, #12
 8008046:	460e      	mov	r6, r1
 8008048:	f8bd a034 	ldrh.w	sl, [sp, #52]	; 0x34
 800804c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
  if (hi2c->State == HAL_I2C_STATE_READY)
 800804e:	f890 1041 	ldrb.w	r1, [r0, #65]	; 0x41
 8008052:	b2c9      	uxtb	r1, r1
 8008054:	2920      	cmp	r1, #32
 8008056:	f040 80bc 	bne.w	80081d2 <HAL_I2C_Mem_Read+0x192>
 800805a:	4604      	mov	r4, r0
 800805c:	4690      	mov	r8, r2
 800805e:	4699      	mov	r9, r3
    if ((pData == NULL) || (Size == 0U))
 8008060:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008062:	b1cb      	cbz	r3, 8008098 <HAL_I2C_Mem_Read+0x58>
 8008064:	f1ba 0f00 	cmp.w	sl, #0
 8008068:	d016      	beq.n	8008098 <HAL_I2C_Mem_Read+0x58>
    __HAL_LOCK(hi2c);
 800806a:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800806e:	2b01      	cmp	r3, #1
 8008070:	f000 80b3 	beq.w	80081da <HAL_I2C_Mem_Read+0x19a>
 8008074:	f04f 0b01 	mov.w	fp, #1
 8008078:	f880 b040 	strb.w	fp, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 800807c:	f7fe ff8c 	bl	8006f98 <HAL_GetTick>
 8008080:	4607      	mov	r7, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8008082:	9000      	str	r0, [sp, #0]
 8008084:	2319      	movs	r3, #25
 8008086:	465a      	mov	r2, fp
 8008088:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800808c:	4620      	mov	r0, r4
 800808e:	f7ff fdbd 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 8008092:	b130      	cbz	r0, 80080a2 <HAL_I2C_Mem_Read+0x62>
      return HAL_ERROR;
 8008094:	2001      	movs	r0, #1
 8008096:	e09d      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8008098:	f44f 7300 	mov.w	r3, #512	; 0x200
 800809c:	6463      	str	r3, [r4, #68]	; 0x44
      return  HAL_ERROR;
 800809e:	2001      	movs	r0, #1
 80080a0:	e098      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80080a2:	2322      	movs	r3, #34	; 0x22
 80080a4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80080a8:	2340      	movs	r3, #64	; 0x40
 80080aa:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80080ae:	2300      	movs	r3, #0
 80080b0:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 80080b2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80080b4:	6262      	str	r2, [r4, #36]	; 0x24
    hi2c->XferCount = Size;
 80080b6:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 80080ba:	6363      	str	r3, [r4, #52]	; 0x34
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80080bc:	9701      	str	r7, [sp, #4]
 80080be:	9500      	str	r5, [sp, #0]
 80080c0:	464b      	mov	r3, r9
 80080c2:	4642      	mov	r2, r8
 80080c4:	4631      	mov	r1, r6
 80080c6:	4620      	mov	r0, r4
 80080c8:	f7ff fe0a 	bl	8007ce0 <I2C_RequestMemoryRead>
 80080cc:	b970      	cbnz	r0, 80080ec <HAL_I2C_Mem_Read+0xac>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80080ce:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80080d0:	b29b      	uxth	r3, r3
 80080d2:	2bff      	cmp	r3, #255	; 0xff
 80080d4:	d90f      	bls.n	80080f6 <HAL_I2C_Mem_Read+0xb6>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80080d6:	22ff      	movs	r2, #255	; 0xff
 80080d8:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80080da:	4b44      	ldr	r3, [pc, #272]	; (80081ec <HAL_I2C_Mem_Read+0x1ac>)
 80080dc:	9300      	str	r3, [sp, #0]
 80080de:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80080e2:	4631      	mov	r1, r6
 80080e4:	4620      	mov	r0, r4
 80080e6:	f7ff fd02 	bl	8007aee <I2C_TransferConfig>
 80080ea:	e021      	b.n	8008130 <HAL_I2C_Mem_Read+0xf0>
      __HAL_UNLOCK(hi2c);
 80080ec:	2300      	movs	r3, #0
 80080ee:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 80080f2:	4658      	mov	r0, fp
 80080f4:	e06e      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
      hi2c->XferSize = hi2c->XferCount;
 80080f6:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80080f8:	b292      	uxth	r2, r2
 80080fa:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80080fc:	4b3b      	ldr	r3, [pc, #236]	; (80081ec <HAL_I2C_Mem_Read+0x1ac>)
 80080fe:	9300      	str	r3, [sp, #0]
 8008100:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008104:	b2d2      	uxtb	r2, r2
 8008106:	4631      	mov	r1, r6
 8008108:	4620      	mov	r0, r4
 800810a:	f7ff fcf0 	bl	8007aee <I2C_TransferConfig>
 800810e:	e00f      	b.n	8008130 <HAL_I2C_Mem_Read+0xf0>
          hi2c->XferSize = hi2c->XferCount;
 8008110:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 8008112:	b292      	uxth	r2, r2
 8008114:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8008116:	2300      	movs	r3, #0
 8008118:	9300      	str	r3, [sp, #0]
 800811a:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800811e:	b2d2      	uxtb	r2, r2
 8008120:	4631      	mov	r1, r6
 8008122:	4620      	mov	r0, r4
 8008124:	f7ff fce3 	bl	8007aee <I2C_TransferConfig>
    } while (hi2c->XferCount > 0U);
 8008128:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800812a:	b29b      	uxth	r3, r3
 800812c:	2b00      	cmp	r3, #0
 800812e:	d034      	beq.n	800819a <HAL_I2C_Mem_Read+0x15a>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8008130:	9700      	str	r7, [sp, #0]
 8008132:	462b      	mov	r3, r5
 8008134:	2200      	movs	r2, #0
 8008136:	2104      	movs	r1, #4
 8008138:	4620      	mov	r0, r4
 800813a:	f7ff fd67 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 800813e:	2800      	cmp	r0, #0
 8008140:	d14d      	bne.n	80081de <HAL_I2C_Mem_Read+0x19e>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8008142:	6823      	ldr	r3, [r4, #0]
 8008144:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008146:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008148:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 800814a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800814c:	3301      	adds	r3, #1
 800814e:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8008150:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8008152:	3a01      	subs	r2, #1
 8008154:	b292      	uxth	r2, r2
 8008156:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8008158:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800815a:	b29b      	uxth	r3, r3
 800815c:	3b01      	subs	r3, #1
 800815e:	b29b      	uxth	r3, r3
 8008160:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8008162:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008164:	b29b      	uxth	r3, r3
 8008166:	2b00      	cmp	r3, #0
 8008168:	d0de      	beq.n	8008128 <HAL_I2C_Mem_Read+0xe8>
 800816a:	2a00      	cmp	r2, #0
 800816c:	d1dc      	bne.n	8008128 <HAL_I2C_Mem_Read+0xe8>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800816e:	9700      	str	r7, [sp, #0]
 8008170:	462b      	mov	r3, r5
 8008172:	2180      	movs	r1, #128	; 0x80
 8008174:	4620      	mov	r0, r4
 8008176:	f7ff fd49 	bl	8007c0c <I2C_WaitOnFlagUntilTimeout>
 800817a:	bb90      	cbnz	r0, 80081e2 <HAL_I2C_Mem_Read+0x1a2>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800817c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800817e:	b29b      	uxth	r3, r3
 8008180:	2bff      	cmp	r3, #255	; 0xff
 8008182:	d9c5      	bls.n	8008110 <HAL_I2C_Mem_Read+0xd0>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8008184:	22ff      	movs	r2, #255	; 0xff
 8008186:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8008188:	2300      	movs	r3, #0
 800818a:	9300      	str	r3, [sp, #0]
 800818c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8008190:	4631      	mov	r1, r6
 8008192:	4620      	mov	r0, r4
 8008194:	f7ff fcab 	bl	8007aee <I2C_TransferConfig>
 8008198:	e7c6      	b.n	8008128 <HAL_I2C_Mem_Read+0xe8>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800819a:	463a      	mov	r2, r7
 800819c:	4629      	mov	r1, r5
 800819e:	4620      	mov	r0, r4
 80081a0:	f7ff fdda 	bl	8007d58 <I2C_WaitOnSTOPFlagUntilTimeout>
 80081a4:	b9f8      	cbnz	r0, 80081e6 <HAL_I2C_Mem_Read+0x1a6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80081a6:	6823      	ldr	r3, [r4, #0]
 80081a8:	2220      	movs	r2, #32
 80081aa:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
 80081ac:	6821      	ldr	r1, [r4, #0]
 80081ae:	684b      	ldr	r3, [r1, #4]
 80081b0:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 80081b4:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 80081b8:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 80081bc:	f023 0301 	bic.w	r3, r3, #1
 80081c0:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80081c2:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80081c6:	2300      	movs	r3, #0
 80081c8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 80081cc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_OK;
 80081d0:	e000      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
    return HAL_BUSY;
 80081d2:	2002      	movs	r0, #2
}
 80081d4:	b003      	add	sp, #12
 80081d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 80081da:	2002      	movs	r0, #2
 80081dc:	e7fa      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
        return HAL_ERROR;
 80081de:	2001      	movs	r0, #1
 80081e0:	e7f8      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
          return HAL_ERROR;
 80081e2:	2001      	movs	r0, #1
 80081e4:	e7f6      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
      return HAL_ERROR;
 80081e6:	2001      	movs	r0, #1
 80081e8:	e7f4      	b.n	80081d4 <HAL_I2C_Mem_Read+0x194>
 80081ea:	bf00      	nop
 80081ec:	80002400 	.word	0x80002400

080081f0 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 80081f0:	4603      	mov	r3, r0
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80081f2:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 80081f6:	b2d2      	uxtb	r2, r2
 80081f8:	2a20      	cmp	r2, #32
 80081fa:	d123      	bne.n	8008244 <HAL_I2CEx_ConfigAnalogFilter+0x54>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80081fc:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 8008200:	2a01      	cmp	r2, #1
 8008202:	d021      	beq.n	8008248 <HAL_I2CEx_ConfigAnalogFilter+0x58>
 8008204:	2201      	movs	r2, #1
 8008206:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 800820a:	2224      	movs	r2, #36	; 0x24
 800820c:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8008210:	6800      	ldr	r0, [r0, #0]
 8008212:	6802      	ldr	r2, [r0, #0]
 8008214:	f022 0201 	bic.w	r2, r2, #1
 8008218:	6002      	str	r2, [r0, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800821a:	6818      	ldr	r0, [r3, #0]
 800821c:	6802      	ldr	r2, [r0, #0]
 800821e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8008222:	6002      	str	r2, [r0, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8008224:	6818      	ldr	r0, [r3, #0]
 8008226:	6802      	ldr	r2, [r0, #0]
 8008228:	4311      	orrs	r1, r2
 800822a:	6001      	str	r1, [r0, #0]

    __HAL_I2C_ENABLE(hi2c);
 800822c:	6819      	ldr	r1, [r3, #0]
 800822e:	680a      	ldr	r2, [r1, #0]
 8008230:	f042 0201 	orr.w	r2, r2, #1
 8008234:	600a      	str	r2, [r1, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8008236:	2220      	movs	r2, #32
 8008238:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800823c:	2000      	movs	r0, #0
 800823e:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40

    return HAL_OK;
 8008242:	4770      	bx	lr
  }
  else
  {
    return HAL_BUSY;
 8008244:	2002      	movs	r0, #2
 8008246:	4770      	bx	lr
    __HAL_LOCK(hi2c);
 8008248:	2002      	movs	r0, #2
  }
}
 800824a:	4770      	bx	lr

0800824c <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800824c:	4603      	mov	r3, r0

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800824e:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8008252:	b2d2      	uxtb	r2, r2
 8008254:	2a20      	cmp	r2, #32
 8008256:	d121      	bne.n	800829c <HAL_I2CEx_ConfigDigitalFilter+0x50>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8008258:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
 800825c:	2a01      	cmp	r2, #1
 800825e:	d01f      	beq.n	80082a0 <HAL_I2CEx_ConfigDigitalFilter+0x54>
 8008260:	2201      	movs	r2, #1
 8008262:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 8008266:	2224      	movs	r2, #36	; 0x24
 8008268:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800826c:	6800      	ldr	r0, [r0, #0]
 800826e:	6802      	ldr	r2, [r0, #0]
 8008270:	f022 0201 	bic.w	r2, r2, #1
 8008274:	6002      	str	r2, [r0, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8008276:	6818      	ldr	r0, [r3, #0]
 8008278:	6802      	ldr	r2, [r0, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 800827a:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800827e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8008282:	6002      	str	r2, [r0, #0]

    __HAL_I2C_ENABLE(hi2c);
 8008284:	6819      	ldr	r1, [r3, #0]
 8008286:	680a      	ldr	r2, [r1, #0]
 8008288:	f042 0201 	orr.w	r2, r2, #1
 800828c:	600a      	str	r2, [r1, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800828e:	2220      	movs	r2, #32
 8008290:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8008294:	2000      	movs	r0, #0
 8008296:	f883 0040 	strb.w	r0, [r3, #64]	; 0x40

    return HAL_OK;
 800829a:	4770      	bx	lr
  }
  else
  {
    return HAL_BUSY;
 800829c:	2002      	movs	r0, #2
 800829e:	4770      	bx	lr
    __HAL_LOCK(hi2c);
 80082a0:	2002      	movs	r0, #2
  }
}
 80082a2:	4770      	bx	lr

080082a4 <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and initialize the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{
 80082a4:	b570      	push	{r4, r5, r6, lr}
 80082a6:	b086      	sub	sp, #24
  USB_OTG_GlobalTypeDef *USBx;
#endif /* defined (USB_OTG_FS) */
  uint8_t i;

  /* Check the PCD handle allocation */
  if (hpcd == NULL)
 80082a8:	2800      	cmp	r0, #0
 80082aa:	f000 808c 	beq.w	80083c6 <HAL_PCD_Init+0x122>
 80082ae:	4604      	mov	r4, r0

#if defined (USB_OTG_FS)
  USBx = hpcd->Instance;
#endif /* defined (USB_OTG_FS) */

  if (hpcd->State == HAL_PCD_STATE_RESET)
 80082b0:	f890 32a9 	ldrb.w	r3, [r0, #681]	; 0x2a9
 80082b4:	b1eb      	cbz	r3, 80082f2 <HAL_PCD_Init+0x4e>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
#endif /* (USE_HAL_PCD_REGISTER_CALLBACKS) */
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80082b6:	2303      	movs	r3, #3
 80082b8:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
    hpcd->Init.dma_enable = 0U;
  }
#endif /* defined (USB_OTG_FS) */

  /* Disable the Interrupts */
  __HAL_PCD_DISABLE(hpcd);
 80082bc:	6820      	ldr	r0, [r4, #0]
 80082be:	f002 fbcd 	bl	800aa5c <USB_DisableGlobalInt>

  /*Init the Core (common init.) */
  if (USB_CoreInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 80082c2:	4625      	mov	r5, r4
 80082c4:	f855 6b10 	ldr.w	r6, [r5], #16
 80082c8:	46ec      	mov	ip, sp
 80082ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80082cc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80082d0:	682b      	ldr	r3, [r5, #0]
 80082d2:	f8cc 3000 	str.w	r3, [ip]
 80082d6:	1d23      	adds	r3, r4, #4
 80082d8:	cb0e      	ldmia	r3, {r1, r2, r3}
 80082da:	4630      	mov	r0, r6
 80082dc:	f002 fbb7 	bl	800aa4e <USB_CoreInit>
 80082e0:	4605      	mov	r5, r0
 80082e2:	b158      	cbz	r0, 80082fc <HAL_PCD_Init+0x58>
  {
    hpcd->State = HAL_PCD_STATE_ERROR;
 80082e4:	2302      	movs	r3, #2
 80082e6:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
    return HAL_ERROR;
 80082ea:	2501      	movs	r5, #1
  }
  
  (void)USB_DevDisconnect(hpcd->Instance);

  return HAL_OK;
}
 80082ec:	4628      	mov	r0, r5
 80082ee:	b006      	add	sp, #24
 80082f0:	bd70      	pop	{r4, r5, r6, pc}
    hpcd->Lock = HAL_UNLOCKED;
 80082f2:	f880 32a8 	strb.w	r3, [r0, #680]	; 0x2a8
    HAL_PCD_MspInit(hpcd);
 80082f6:	f7f9 fcdb 	bl	8001cb0 <HAL_PCD_MspInit>
 80082fa:	e7dc      	b.n	80082b6 <HAL_PCD_Init+0x12>
  (void)USB_SetCurrentMode(hpcd->Instance, USB_DEVICE_MODE);
 80082fc:	2100      	movs	r1, #0
 80082fe:	6820      	ldr	r0, [r4, #0]
 8008300:	f002 fbb6 	bl	800aa70 <USB_SetCurrentMode>
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8008304:	462b      	mov	r3, r5
 8008306:	e01a      	b.n	800833e <HAL_PCD_Init+0x9a>
    hpcd->IN_ep[i].is_in = 1U;
 8008308:	1c5a      	adds	r2, r3, #1
 800830a:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800830e:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8008312:	2001      	movs	r0, #1
 8008314:	7048      	strb	r0, [r1, #1]
    hpcd->IN_ep[i].num = i;
 8008316:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800831a:	f804 3031 	strb.w	r3, [r4, r1, lsl #3]
    hpcd->IN_ep[i].tx_fifo_num = i;
 800831e:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8008322:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8008326:	86cb      	strh	r3, [r1, #54]	; 0x36
    hpcd->IN_ep[i].type = EP_TYPE_CTRL;
 8008328:	eb02 0c82 	add.w	ip, r2, r2, lsl #2
 800832c:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
 8008330:	2000      	movs	r0, #0
 8008332:	f88c 0003 	strb.w	r0, [ip, #3]
    hpcd->IN_ep[i].maxpacket = 0U;
 8008336:	6388      	str	r0, [r1, #56]	; 0x38
    hpcd->IN_ep[i].xfer_buff = 0U;
 8008338:	63c8      	str	r0, [r1, #60]	; 0x3c
    hpcd->IN_ep[i].xfer_len = 0U;
 800833a:	6408      	str	r0, [r1, #64]	; 0x40
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 800833c:	b2d3      	uxtb	r3, r2
 800833e:	6861      	ldr	r1, [r4, #4]
 8008340:	428b      	cmp	r3, r1
 8008342:	d3e1      	bcc.n	8008308 <HAL_PCD_Init+0x64>
 8008344:	e016      	b.n	8008374 <HAL_PCD_Init+0xd0>
    hpcd->OUT_ep[i].is_in = 0U;
 8008346:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 800834a:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 800834e:	2200      	movs	r2, #0
 8008350:	f883 2169 	strb.w	r2, [r3, #361]	; 0x169
    hpcd->OUT_ep[i].num = i;
 8008354:	f883 5168 	strb.w	r5, [r3, #360]	; 0x168
    hpcd->OUT_ep[i].type = EP_TYPE_CTRL;
 8008358:	f883 216b 	strb.w	r2, [r3, #363]	; 0x16b
    hpcd->OUT_ep[i].maxpacket = 0U;
 800835c:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    hpcd->OUT_ep[i].xfer_buff = 0U;
 8008360:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
    hpcd->OUT_ep[i].xfer_len = 0U;
 8008364:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 8008368:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 800836c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  for (i = 0U; i < hpcd->Init.dev_endpoints; i++)
 8008370:	3501      	adds	r5, #1
 8008372:	b2ed      	uxtb	r5, r5
 8008374:	42a9      	cmp	r1, r5
 8008376:	d8e6      	bhi.n	8008346 <HAL_PCD_Init+0xa2>
  if (USB_DevInit(hpcd->Instance, hpcd->Init) != HAL_OK)
 8008378:	4625      	mov	r5, r4
 800837a:	f855 6b10 	ldr.w	r6, [r5], #16
 800837e:	46ec      	mov	ip, sp
 8008380:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8008382:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 8008386:	682b      	ldr	r3, [r5, #0]
 8008388:	f8cc 3000 	str.w	r3, [ip]
 800838c:	1d23      	adds	r3, r4, #4
 800838e:	cb0e      	ldmia	r3, {r1, r2, r3}
 8008390:	4630      	mov	r0, r6
 8008392:	f002 fb6f 	bl	800aa74 <USB_DevInit>
 8008396:	4605      	mov	r5, r0
 8008398:	b960      	cbnz	r0, 80083b4 <HAL_PCD_Init+0x110>
  hpcd->USB_Address = 0U;
 800839a:	2300      	movs	r3, #0
 800839c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  hpcd->State = HAL_PCD_STATE_READY;
 80083a0:	2301      	movs	r3, #1
 80083a2:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
  if (hpcd->Init.lpm_enable == 1U)
 80083a6:	69e3      	ldr	r3, [r4, #28]
 80083a8:	2b01      	cmp	r3, #1
 80083aa:	d008      	beq.n	80083be <HAL_PCD_Init+0x11a>
  (void)USB_DevDisconnect(hpcd->Instance);
 80083ac:	6820      	ldr	r0, [r4, #0]
 80083ae:	f002 fb72 	bl	800aa96 <USB_DevDisconnect>
  return HAL_OK;
 80083b2:	e79b      	b.n	80082ec <HAL_PCD_Init+0x48>
    hpcd->State = HAL_PCD_STATE_ERROR;
 80083b4:	2302      	movs	r3, #2
 80083b6:	f884 32a9 	strb.w	r3, [r4, #681]	; 0x2a9
    return HAL_ERROR;
 80083ba:	2501      	movs	r5, #1
 80083bc:	e796      	b.n	80082ec <HAL_PCD_Init+0x48>
    (void)HAL_PCDEx_ActivateLPM(hpcd);
 80083be:	4620      	mov	r0, r4
 80083c0:	f000 f803 	bl	80083ca <HAL_PCDEx_ActivateLPM>
 80083c4:	e7f2      	b.n	80083ac <HAL_PCD_Init+0x108>
    return HAL_ERROR;
 80083c6:	2501      	movs	r5, #1
 80083c8:	e790      	b.n	80082ec <HAL_PCD_Init+0x48>

080083ca <HAL_PCDEx_ActivateLPM>:
  * @brief  Activate LPM feature.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCDEx_ActivateLPM(PCD_HandleTypeDef *hpcd)
{
 80083ca:	4603      	mov	r3, r0

  USB_TypeDef *USBx = hpcd->Instance;
 80083cc:	6802      	ldr	r2, [r0, #0]
  hpcd->lpm_active = 1U;
 80083ce:	2101      	movs	r1, #1
 80083d0:	f8c0 12e8 	str.w	r1, [r0, #744]	; 0x2e8
  hpcd->LPM_State = LPM_L0;
 80083d4:	2000      	movs	r0, #0
 80083d6:	f883 02e0 	strb.w	r0, [r3, #736]	; 0x2e0

  USBx->LPMCSR |= USB_LPMCSR_LMPEN;
 80083da:	f8b2 3054 	ldrh.w	r3, [r2, #84]	; 0x54
 80083de:	b29b      	uxth	r3, r3
 80083e0:	430b      	orrs	r3, r1
 80083e2:	f8a2 3054 	strh.w	r3, [r2, #84]	; 0x54
  USBx->LPMCSR |= USB_LPMCSR_LPMACK;
 80083e6:	f8b2 3054 	ldrh.w	r3, [r2, #84]	; 0x54
 80083ea:	b29b      	uxth	r3, r3
 80083ec:	f043 0302 	orr.w	r3, r3, #2
 80083f0:	f8a2 3054 	strh.w	r3, [r2, #84]	; 0x54

  return HAL_OK;
}
 80083f4:	4770      	bx	lr
	...

080083f8 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80083f8:	4a02      	ldr	r2, [pc, #8]	; (8008404 <HAL_PWR_EnableBkUpAccess+0xc>)
 80083fa:	6813      	ldr	r3, [r2, #0]
 80083fc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008400:	6013      	str	r3, [r2, #0]
}
 8008402:	4770      	bx	lr
 8008404:	40007000 	.word	0x40007000

08008408 <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8008408:	4b02      	ldr	r3, [pc, #8]	; (8008414 <HAL_PWREx_GetVoltageRange+0xc>)
 800840a:	6818      	ldr	r0, [r3, #0]
#endif
}
 800840c:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8008410:	4770      	bx	lr
 8008412:	bf00      	nop
 8008414:	40007000 	.word	0x40007000

08008418 <HAL_PWREx_ControlVoltageScaling>:
  }

#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8008418:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800841c:	d00f      	beq.n	800843e <HAL_PWREx_ControlVoltageScaling+0x26>
      }
    }
  }
  else
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 800841e:	4b1f      	ldr	r3, [pc, #124]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008420:	681b      	ldr	r3, [r3, #0]
 8008422:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8008426:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800842a:	d034      	beq.n	8008496 <HAL_PWREx_ControlVoltageScaling+0x7e>
    {
      /* Set Range 2 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 800842c:	4a1b      	ldr	r2, [pc, #108]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 800842e:	6813      	ldr	r3, [r2, #0]
 8008430:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8008434:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8008438:	6013      	str	r3, [r2, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 800843a:	2000      	movs	r0, #0
 800843c:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 800843e:	4b17      	ldr	r3, [pc, #92]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008440:	681b      	ldr	r3, [r3, #0]
 8008442:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
 8008446:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800844a:	d020      	beq.n	800848e <HAL_PWREx_ControlVoltageScaling+0x76>
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800844c:	4a13      	ldr	r2, [pc, #76]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 800844e:	6813      	ldr	r3, [r2, #0]
 8008450:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8008454:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8008458:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 800845a:	4b11      	ldr	r3, [pc, #68]	; (80084a0 <HAL_PWREx_ControlVoltageScaling+0x88>)
 800845c:	681b      	ldr	r3, [r3, #0]
 800845e:	2232      	movs	r2, #50	; 0x32
 8008460:	fb02 f303 	mul.w	r3, r2, r3
 8008464:	4a0f      	ldr	r2, [pc, #60]	; (80084a4 <HAL_PWREx_ControlVoltageScaling+0x8c>)
 8008466:	fba2 2303 	umull	r2, r3, r2, r3
 800846a:	0c9b      	lsrs	r3, r3, #18
 800846c:	3301      	adds	r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800846e:	e000      	b.n	8008472 <HAL_PWREx_ControlVoltageScaling+0x5a>
        wait_loop_index--;
 8008470:	3b01      	subs	r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8008472:	4a0a      	ldr	r2, [pc, #40]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008474:	6952      	ldr	r2, [r2, #20]
 8008476:	f412 6f80 	tst.w	r2, #1024	; 0x400
 800847a:	d001      	beq.n	8008480 <HAL_PWREx_ControlVoltageScaling+0x68>
 800847c:	2b00      	cmp	r3, #0
 800847e:	d1f7      	bne.n	8008470 <HAL_PWREx_ControlVoltageScaling+0x58>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8008480:	4b06      	ldr	r3, [pc, #24]	; (800849c <HAL_PWREx_ControlVoltageScaling+0x84>)
 8008482:	695b      	ldr	r3, [r3, #20]
 8008484:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008488:	d103      	bne.n	8008492 <HAL_PWREx_ControlVoltageScaling+0x7a>
  return HAL_OK;
 800848a:	2000      	movs	r0, #0
 800848c:	4770      	bx	lr
 800848e:	2000      	movs	r0, #0
 8008490:	4770      	bx	lr
        return HAL_TIMEOUT;
 8008492:	2003      	movs	r0, #3
 8008494:	4770      	bx	lr
  return HAL_OK;
 8008496:	2000      	movs	r0, #0
}
 8008498:	4770      	bx	lr
 800849a:	bf00      	nop
 800849c:	40007000 	.word	0x40007000
 80084a0:	20000034 	.word	0x20000034
 80084a4:	431bde83 	.word	0x431bde83

080084a8 <QSPI_WaitFlagStateUntilTimeout>:
  * @param  Timeout : Duration of the timeout
  * @retval HAL status
  */
static HAL_StatusTypeDef QSPI_WaitFlagStateUntilTimeout(QSPI_HandleTypeDef *hqspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
 80084a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80084ac:	4605      	mov	r5, r0
 80084ae:	460f      	mov	r7, r1
 80084b0:	4616      	mov	r6, r2
 80084b2:	4699      	mov	r9, r3
 80084b4:	f8dd 8020 	ldr.w	r8, [sp, #32]
  /* Wait until flag is in expected state */
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 80084b8:	682c      	ldr	r4, [r5, #0]
 80084ba:	68a4      	ldr	r4, [r4, #8]
 80084bc:	423c      	tst	r4, r7
 80084be:	bf14      	ite	ne
 80084c0:	f04f 0c01 	movne.w	ip, #1
 80084c4:	f04f 0c00 	moveq.w	ip, #0
 80084c8:	45b4      	cmp	ip, r6
 80084ca:	d014      	beq.n	80084f6 <QSPI_WaitFlagStateUntilTimeout+0x4e>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 80084cc:	f1b8 3fff 	cmp.w	r8, #4294967295
 80084d0:	d0f2      	beq.n	80084b8 <QSPI_WaitFlagStateUntilTimeout+0x10>
    {
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80084d2:	f7fe fd61 	bl	8006f98 <HAL_GetTick>
 80084d6:	eba0 0009 	sub.w	r0, r0, r9
 80084da:	4540      	cmp	r0, r8
 80084dc:	d802      	bhi.n	80084e4 <QSPI_WaitFlagStateUntilTimeout+0x3c>
 80084de:	f1b8 0f00 	cmp.w	r8, #0
 80084e2:	d1e9      	bne.n	80084b8 <QSPI_WaitFlagStateUntilTimeout+0x10>
      {
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 80084e4:	2304      	movs	r3, #4
 80084e6:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 80084ea:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 80084ec:	f043 0301 	orr.w	r3, r3, #1
 80084f0:	646b      	str	r3, [r5, #68]	; 0x44

        return HAL_ERROR;
 80084f2:	2001      	movs	r0, #1
 80084f4:	e000      	b.n	80084f8 <QSPI_WaitFlagStateUntilTimeout+0x50>
      }
    }
  }
  return HAL_OK;
 80084f6:	2000      	movs	r0, #0
}
 80084f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080084fc <HAL_QSPI_SetTimeout>:
  hqspi->Timeout = Timeout;
 80084fc:	6481      	str	r1, [r0, #72]	; 0x48
}
 80084fe:	4770      	bx	lr

08008500 <HAL_QSPI_Init>:
{
 8008500:	b570      	push	{r4, r5, r6, lr}
 8008502:	b082      	sub	sp, #8
 8008504:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8008506:	f7fe fd47 	bl	8006f98 <HAL_GetTick>
  if(hqspi == NULL)
 800850a:	2c00      	cmp	r4, #0
 800850c:	d04c      	beq.n	80085a8 <HAL_QSPI_Init+0xa8>
 800850e:	4606      	mov	r6, r0
  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8008510:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008514:	2b00      	cmp	r3, #0
 8008516:	d03c      	beq.n	8008592 <HAL_QSPI_Init+0x92>
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 8008518:	6825      	ldr	r5, [r4, #0]
 800851a:	682a      	ldr	r2, [r5, #0]
 800851c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 8008520:	68a1      	ldr	r1, [r4, #8]
 8008522:	3901      	subs	r1, #1
 8008524:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8008528:	602a      	str	r2, [r5, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 800852a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800852c:	9300      	str	r3, [sp, #0]
 800852e:	4633      	mov	r3, r6
 8008530:	2200      	movs	r2, #0
 8008532:	2120      	movs	r1, #32
 8008534:	4620      	mov	r0, r4
 8008536:	f7ff ffb7 	bl	80084a8 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
 800853a:	bb28      	cbnz	r0, 8008588 <HAL_QSPI_Init+0x88>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 800853c:	6821      	ldr	r1, [r4, #0]
 800853e:	680b      	ldr	r3, [r1, #0]
 8008540:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8008544:	f023 03d0 	bic.w	r3, r3, #208	; 0xd0
 8008548:	6865      	ldr	r5, [r4, #4]
 800854a:	68e2      	ldr	r2, [r4, #12]
 800854c:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
 8008550:	69e5      	ldr	r5, [r4, #28]
 8008552:	432a      	orrs	r2, r5
 8008554:	6a25      	ldr	r5, [r4, #32]
 8008556:	432a      	orrs	r2, r5
 8008558:	4313      	orrs	r3, r2
 800855a:	600b      	str	r3, [r1, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 800855c:	6821      	ldr	r1, [r4, #0]
 800855e:	684a      	ldr	r2, [r1, #4]
 8008560:	4b12      	ldr	r3, [pc, #72]	; (80085ac <HAL_QSPI_Init+0xac>)
 8008562:	4013      	ands	r3, r2
 8008564:	6925      	ldr	r5, [r4, #16]
 8008566:	6962      	ldr	r2, [r4, #20]
 8008568:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
 800856c:	69a5      	ldr	r5, [r4, #24]
 800856e:	432a      	orrs	r2, r5
 8008570:	4313      	orrs	r3, r2
 8008572:	604b      	str	r3, [r1, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8008574:	6822      	ldr	r2, [r4, #0]
 8008576:	6813      	ldr	r3, [r2, #0]
 8008578:	f043 0301 	orr.w	r3, r3, #1
 800857c:	6013      	str	r3, [r2, #0]
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 800857e:	2300      	movs	r3, #0
 8008580:	6463      	str	r3, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 8008582:	2301      	movs	r3, #1
 8008584:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 8008588:	2300      	movs	r3, #0
 800858a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 800858e:	b002      	add	sp, #8
 8008590:	bd70      	pop	{r4, r5, r6, pc}
    hqspi->Lock = HAL_UNLOCKED;
 8008592:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_QSPI_MspInit(hqspi);
 8008596:	4620      	mov	r0, r4
 8008598:	f7f8 ff20 	bl	80013dc <HAL_QSPI_MspInit>
    HAL_QSPI_SetTimeout(hqspi, HAL_QSPI_TIMEOUT_DEFAULT_VALUE);
 800859c:	f241 3188 	movw	r1, #5000	; 0x1388
 80085a0:	4620      	mov	r0, r4
 80085a2:	f7ff ffab 	bl	80084fc <HAL_QSPI_SetTimeout>
 80085a6:	e7b7      	b.n	8008518 <HAL_QSPI_Init+0x18>
    return HAL_ERROR;
 80085a8:	2001      	movs	r0, #1
 80085aa:	e7f0      	b.n	800858e <HAL_QSPI_Init+0x8e>
 80085ac:	ffe0f8fe 	.word	0xffe0f8fe

080085b0 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80085b0:	b530      	push	{r4, r5, lr}
 80085b2:	b083      	sub	sp, #12
 80085b4:	4604      	mov	r4, r0
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80085b6:	4b20      	ldr	r3, [pc, #128]	; (8008638 <RCC_SetFlashLatencyFromMSIRange+0x88>)
 80085b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80085ba:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 80085be:	d00b      	beq.n	80085d8 <RCC_SetFlashLatencyFromMSIRange+0x28>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80085c0:	f7ff ff22 	bl	8008408 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80085c4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80085c8:	d017      	beq.n	80085fa <RCC_SetFlashLatencyFromMSIRange+0x4a>
        latency = FLASH_LATENCY_1; /* 1WS */
      }
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#else
    if(msirange > RCC_MSIRANGE_8)
 80085ca:	2c80      	cmp	r4, #128	; 0x80
 80085cc:	d81f      	bhi.n	800860e <RCC_SetFlashLatencyFromMSIRange+0x5e>
      /* MSI > 16Mhz */
      latency = FLASH_LATENCY_3; /* 3WS */
    }
    else
    {
      if(msirange == RCC_MSIRANGE_8)
 80085ce:	d02d      	beq.n	800862c <RCC_SetFlashLatencyFromMSIRange+0x7c>
      {
        /* MSI 16Mhz */
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else if(msirange == RCC_MSIRANGE_7)
 80085d0:	2c70      	cmp	r4, #112	; 0x70
 80085d2:	d02d      	beq.n	8008630 <RCC_SetFlashLatencyFromMSIRange+0x80>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 80085d4:	2100      	movs	r1, #0
 80085d6:	e01b      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
    __HAL_RCC_PWR_CLK_ENABLE();
 80085d8:	4d17      	ldr	r5, [pc, #92]	; (8008638 <RCC_SetFlashLatencyFromMSIRange+0x88>)
 80085da:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80085dc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80085e0:	65ab      	str	r3, [r5, #88]	; 0x58
 80085e2:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80085e4:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80085e8:	9301      	str	r3, [sp, #4]
 80085ea:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80085ec:	f7ff ff0c 	bl	8008408 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80085f0:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80085f2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80085f6:	65ab      	str	r3, [r5, #88]	; 0x58
 80085f8:	e7e4      	b.n	80085c4 <RCC_SetFlashLatencyFromMSIRange+0x14>
    if(msirange > RCC_MSIRANGE_8)
 80085fa:	2c80      	cmp	r4, #128	; 0x80
 80085fc:	d903      	bls.n	8008606 <RCC_SetFlashLatencyFromMSIRange+0x56>
      if(msirange > RCC_MSIRANGE_10)
 80085fe:	2ca0      	cmp	r4, #160	; 0xa0
 8008600:	d903      	bls.n	800860a <RCC_SetFlashLatencyFromMSIRange+0x5a>
        latency = FLASH_LATENCY_2; /* 2WS */
 8008602:	2102      	movs	r1, #2
 8008604:	e004      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8008606:	2100      	movs	r1, #0
 8008608:	e002      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
        latency = FLASH_LATENCY_1; /* 1WS */
 800860a:	2101      	movs	r1, #1
 800860c:	e000      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
      latency = FLASH_LATENCY_3; /* 3WS */
 800860e:	2103      	movs	r1, #3
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8008610:	4a0a      	ldr	r2, [pc, #40]	; (800863c <RCC_SetFlashLatencyFromMSIRange+0x8c>)
 8008612:	6813      	ldr	r3, [r2, #0]
 8008614:	f023 0307 	bic.w	r3, r3, #7
 8008618:	430b      	orrs	r3, r1
 800861a:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 800861c:	6813      	ldr	r3, [r2, #0]
 800861e:	f003 0307 	and.w	r3, r3, #7
 8008622:	428b      	cmp	r3, r1
 8008624:	d106      	bne.n	8008634 <RCC_SetFlashLatencyFromMSIRange+0x84>
  {
    return HAL_ERROR;
  }

  return HAL_OK;
 8008626:	2000      	movs	r0, #0
}
 8008628:	b003      	add	sp, #12
 800862a:	bd30      	pop	{r4, r5, pc}
        latency = FLASH_LATENCY_2; /* 2WS */
 800862c:	2102      	movs	r1, #2
 800862e:	e7ef      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
        latency = FLASH_LATENCY_1; /* 1WS */
 8008630:	2101      	movs	r1, #1
 8008632:	e7ed      	b.n	8008610 <RCC_SetFlashLatencyFromMSIRange+0x60>
    return HAL_ERROR;
 8008634:	2001      	movs	r0, #1
 8008636:	e7f7      	b.n	8008628 <RCC_SetFlashLatencyFromMSIRange+0x78>
 8008638:	40021000 	.word	0x40021000
 800863c:	40022000 	.word	0x40022000

08008640 <HAL_RCC_MCOConfig>:
{
 8008640:	b570      	push	{r4, r5, r6, lr}
 8008642:	b086      	sub	sp, #24
 8008644:	460d      	mov	r5, r1
 8008646:	4616      	mov	r6, r2
  __MCO1_CLK_ENABLE();
 8008648:	4c0f      	ldr	r4, [pc, #60]	; (8008688 <HAL_RCC_MCOConfig+0x48>)
 800864a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800864c:	f043 0301 	orr.w	r3, r3, #1
 8008650:	64e3      	str	r3, [r4, #76]	; 0x4c
 8008652:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8008654:	f003 0301 	and.w	r3, r3, #1
 8008658:	9300      	str	r3, [sp, #0]
 800865a:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Pin = MCO1_PIN;
 800865c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008660:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008662:	2302      	movs	r3, #2
 8008664:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008666:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008668:	2300      	movs	r3, #0
 800866a:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 800866c:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 800866e:	a901      	add	r1, sp, #4
 8008670:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8008674:	f7ff f8b8 	bl	80077e8 <HAL_GPIO_Init>
  MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCOSEL | RCC_CFGR_MCOPRE), (RCC_MCOSource | RCC_MCODiv ));
 8008678:	68a3      	ldr	r3, [r4, #8]
 800867a:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 800867e:	4335      	orrs	r5, r6
 8008680:	432b      	orrs	r3, r5
 8008682:	60a3      	str	r3, [r4, #8]
}
 8008684:	b006      	add	sp, #24
 8008686:	bd70      	pop	{r4, r5, r6, pc}
 8008688:	40021000 	.word	0x40021000

0800868c <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800868c:	4a28      	ldr	r2, [pc, #160]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 800868e:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8008690:	68d2      	ldr	r2, [r2, #12]
 8008692:	f002 0203 	and.w	r2, r2, #3
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8008696:	f013 030c 	ands.w	r3, r3, #12
 800869a:	d00a      	beq.n	80086b2 <HAL_RCC_GetSysClockFreq+0x26>
 800869c:	2b0c      	cmp	r3, #12
 800869e:	d006      	beq.n	80086ae <HAL_RCC_GetSysClockFreq+0x22>
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 80086a0:	2b04      	cmp	r3, #4
 80086a2:	d01f      	beq.n	80086e4 <HAL_RCC_GetSysClockFreq+0x58>
  else if(sysclk_source == RCC_CFGR_SWS_HSE)
 80086a4:	2b08      	cmp	r3, #8
 80086a6:	d020      	beq.n	80086ea <HAL_RCC_GetSysClockFreq+0x5e>
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086a8:	2000      	movs	r0, #0
 80086aa:	4602      	mov	r2, r0
 80086ac:	e010      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 80086ae:	2a01      	cmp	r2, #1
 80086b0:	d1f6      	bne.n	80086a0 <HAL_RCC_GetSysClockFreq+0x14>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80086b2:	4a1f      	ldr	r2, [pc, #124]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086b4:	6812      	ldr	r2, [r2, #0]
 80086b6:	f012 0f08 	tst.w	r2, #8
 80086ba:	d10c      	bne.n	80086d6 <HAL_RCC_GetSysClockFreq+0x4a>
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80086bc:	4a1c      	ldr	r2, [pc, #112]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086be:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80086c2:	f3c2 2203 	ubfx	r2, r2, #8, #4
    msirange = MSIRangeTable[msirange];
 80086c6:	491b      	ldr	r1, [pc, #108]	; (8008734 <HAL_RCC_GetSysClockFreq+0xa8>)
 80086c8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 80086cc:	b143      	cbz	r3, 80086e0 <HAL_RCC_GetSysClockFreq+0x54>
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086ce:	2000      	movs	r0, #0
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 80086d0:	2b0c      	cmp	r3, #12
 80086d2:	d00d      	beq.n	80086f0 <HAL_RCC_GetSysClockFreq+0x64>
}
 80086d4:	4770      	bx	lr
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80086d6:	4a16      	ldr	r2, [pc, #88]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086d8:	6812      	ldr	r2, [r2, #0]
 80086da:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80086de:	e7f2      	b.n	80086c6 <HAL_RCC_GetSysClockFreq+0x3a>
      sysclockfreq = msirange;
 80086e0:	4610      	mov	r0, r2
 80086e2:	e7f5      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
    sysclockfreq = HSI_VALUE;
 80086e4:	4814      	ldr	r0, [pc, #80]	; (8008738 <HAL_RCC_GetSysClockFreq+0xac>)
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086e6:	2200      	movs	r2, #0
 80086e8:	e7f2      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
    sysclockfreq = HSE_VALUE;
 80086ea:	4814      	ldr	r0, [pc, #80]	; (800873c <HAL_RCC_GetSysClockFreq+0xb0>)
  uint32_t msirange = 0U, sysclockfreq = 0U;
 80086ec:	2200      	movs	r2, #0
 80086ee:	e7ef      	b.n	80086d0 <HAL_RCC_GetSysClockFreq+0x44>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80086f0:	4b0f      	ldr	r3, [pc, #60]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 80086f2:	68db      	ldr	r3, [r3, #12]
 80086f4:	f003 0303 	and.w	r3, r3, #3
    switch (pllsource)
 80086f8:	2b02      	cmp	r3, #2
 80086fa:	d016      	beq.n	800872a <HAL_RCC_GetSysClockFreq+0x9e>
 80086fc:	2b03      	cmp	r3, #3
 80086fe:	d100      	bne.n	8008702 <HAL_RCC_GetSysClockFreq+0x76>
      pllvco = HSE_VALUE;
 8008700:	4a0e      	ldr	r2, [pc, #56]	; (800873c <HAL_RCC_GetSysClockFreq+0xb0>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8008702:	490b      	ldr	r1, [pc, #44]	; (8008730 <HAL_RCC_GetSysClockFreq+0xa4>)
 8008704:	68cb      	ldr	r3, [r1, #12]
 8008706:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800870a:	3301      	adds	r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 800870c:	68c8      	ldr	r0, [r1, #12]
 800870e:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8008712:	fb02 f000 	mul.w	r0, r2, r0
 8008716:	fbb0 f0f3 	udiv	r0, r0, r3
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800871a:	68cb      	ldr	r3, [r1, #12]
 800871c:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8008720:	3301      	adds	r3, #1
 8008722:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 8008724:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 8008728:	e7d4      	b.n	80086d4 <HAL_RCC_GetSysClockFreq+0x48>
    switch (pllsource)
 800872a:	4a03      	ldr	r2, [pc, #12]	; (8008738 <HAL_RCC_GetSysClockFreq+0xac>)
 800872c:	e7e9      	b.n	8008702 <HAL_RCC_GetSysClockFreq+0x76>
 800872e:	bf00      	nop
 8008730:	40021000 	.word	0x40021000
 8008734:	0802dc88 	.word	0x0802dc88
 8008738:	00f42400 	.word	0x00f42400
 800873c:	007a1200 	.word	0x007a1200

08008740 <HAL_RCC_OscConfig>:
  if(RCC_OscInitStruct == NULL)
 8008740:	2800      	cmp	r0, #0
 8008742:	f000 8327 	beq.w	8008d94 <HAL_RCC_OscConfig+0x654>
{
 8008746:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008748:	b083      	sub	sp, #12
 800874a:	4604      	mov	r4, r0
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 800874c:	4b96      	ldr	r3, [pc, #600]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800874e:	689d      	ldr	r5, [r3, #8]
 8008750:	f005 050c 	and.w	r5, r5, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 8008754:	68de      	ldr	r6, [r3, #12]
 8008756:	f006 0603 	and.w	r6, r6, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 800875a:	6803      	ldr	r3, [r0, #0]
 800875c:	f013 0f10 	tst.w	r3, #16
 8008760:	d05a      	beq.n	8008818 <HAL_RCC_OscConfig+0xd8>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8008762:	b1e5      	cbz	r5, 800879e <HAL_RCC_OscConfig+0x5e>
 8008764:	2d0c      	cmp	r5, #12
 8008766:	d018      	beq.n	800879a <HAL_RCC_OscConfig+0x5a>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8008768:	69a3      	ldr	r3, [r4, #24]
 800876a:	2b00      	cmp	r3, #0
 800876c:	f000 80bb 	beq.w	80088e6 <HAL_RCC_OscConfig+0x1a6>
        __HAL_RCC_MSI_ENABLE();
 8008770:	4a8d      	ldr	r2, [pc, #564]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008772:	6813      	ldr	r3, [r2, #0]
 8008774:	f043 0301 	orr.w	r3, r3, #1
 8008778:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800877a:	f7fe fc0d 	bl	8006f98 <HAL_GetTick>
 800877e:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008780:	4b89      	ldr	r3, [pc, #548]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008782:	681b      	ldr	r3, [r3, #0]
 8008784:	f013 0f02 	tst.w	r3, #2
 8008788:	f040 809a 	bne.w	80088c0 <HAL_RCC_OscConfig+0x180>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800878c:	f7fe fc04 	bl	8006f98 <HAL_GetTick>
 8008790:	1bc0      	subs	r0, r0, r7
 8008792:	2802      	cmp	r0, #2
 8008794:	d9f4      	bls.n	8008780 <HAL_RCC_OscConfig+0x40>
            return HAL_TIMEOUT;
 8008796:	2003      	movs	r0, #3
 8008798:	e307      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 800879a:	2e01      	cmp	r6, #1
 800879c:	d1e4      	bne.n	8008768 <HAL_RCC_OscConfig+0x28>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 800879e:	4b82      	ldr	r3, [pc, #520]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087a0:	681b      	ldr	r3, [r3, #0]
 80087a2:	f013 0f02 	tst.w	r3, #2
 80087a6:	d003      	beq.n	80087b0 <HAL_RCC_OscConfig+0x70>
 80087a8:	69a3      	ldr	r3, [r4, #24]
 80087aa:	2b00      	cmp	r3, #0
 80087ac:	f000 82f4 	beq.w	8008d98 <HAL_RCC_OscConfig+0x658>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80087b0:	6a20      	ldr	r0, [r4, #32]
 80087b2:	4b7d      	ldr	r3, [pc, #500]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087b4:	681b      	ldr	r3, [r3, #0]
 80087b6:	f013 0f08 	tst.w	r3, #8
 80087ba:	d05b      	beq.n	8008874 <HAL_RCC_OscConfig+0x134>
 80087bc:	4b7a      	ldr	r3, [pc, #488]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087be:	681b      	ldr	r3, [r3, #0]
 80087c0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80087c4:	4298      	cmp	r0, r3
 80087c6:	d85c      	bhi.n	8008882 <HAL_RCC_OscConfig+0x142>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80087c8:	4b77      	ldr	r3, [pc, #476]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087ca:	681a      	ldr	r2, [r3, #0]
 80087cc:	f042 0208 	orr.w	r2, r2, #8
 80087d0:	601a      	str	r2, [r3, #0]
 80087d2:	681a      	ldr	r2, [r3, #0]
 80087d4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80087d8:	6a21      	ldr	r1, [r4, #32]
 80087da:	430a      	orrs	r2, r1
 80087dc:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80087de:	685a      	ldr	r2, [r3, #4]
 80087e0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80087e4:	69e1      	ldr	r1, [r4, #28]
 80087e6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80087ea:	605a      	str	r2, [r3, #4]
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 80087ec:	2d00      	cmp	r5, #0
 80087ee:	d060      	beq.n	80088b2 <HAL_RCC_OscConfig+0x172>
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80087f0:	f7ff ff4c 	bl	800868c <HAL_RCC_GetSysClockFreq>
 80087f4:	4b6c      	ldr	r3, [pc, #432]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80087f6:	689b      	ldr	r3, [r3, #8]
 80087f8:	f3c3 1303 	ubfx	r3, r3, #4, #4
 80087fc:	4a6b      	ldr	r2, [pc, #428]	; (80089ac <HAL_RCC_OscConfig+0x26c>)
 80087fe:	5cd3      	ldrb	r3, [r2, r3]
 8008800:	f003 031f 	and.w	r3, r3, #31
 8008804:	40d8      	lsrs	r0, r3
 8008806:	4b6a      	ldr	r3, [pc, #424]	; (80089b0 <HAL_RCC_OscConfig+0x270>)
 8008808:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 800880a:	4b6a      	ldr	r3, [pc, #424]	; (80089b4 <HAL_RCC_OscConfig+0x274>)
 800880c:	6818      	ldr	r0, [r3, #0]
 800880e:	f7f8 ff6b 	bl	80016e8 <HAL_InitTick>
        if(status != HAL_OK)
 8008812:	2800      	cmp	r0, #0
 8008814:	f040 82c9 	bne.w	8008daa <HAL_RCC_OscConfig+0x66a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8008818:	6823      	ldr	r3, [r4, #0]
 800881a:	f013 0f01 	tst.w	r3, #1
 800881e:	f000 8081 	beq.w	8008924 <HAL_RCC_OscConfig+0x1e4>
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 8008822:	2d08      	cmp	r5, #8
 8008824:	d075      	beq.n	8008912 <HAL_RCC_OscConfig+0x1d2>
 8008826:	2d0c      	cmp	r5, #12
 8008828:	d071      	beq.n	800890e <HAL_RCC_OscConfig+0x1ce>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800882a:	6863      	ldr	r3, [r4, #4]
 800882c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008830:	f000 8097 	beq.w	8008962 <HAL_RCC_OscConfig+0x222>
 8008834:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8008838:	f000 8099 	beq.w	800896e <HAL_RCC_OscConfig+0x22e>
 800883c:	4b5a      	ldr	r3, [pc, #360]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800883e:	681a      	ldr	r2, [r3, #0]
 8008840:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008844:	601a      	str	r2, [r3, #0]
 8008846:	681a      	ldr	r2, [r3, #0]
 8008848:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800884c:	601a      	str	r2, [r3, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800884e:	6863      	ldr	r3, [r4, #4]
 8008850:	2b00      	cmp	r3, #0
 8008852:	f000 8099 	beq.w	8008988 <HAL_RCC_OscConfig+0x248>
        tickstart = HAL_GetTick();
 8008856:	f7fe fb9f 	bl	8006f98 <HAL_GetTick>
 800885a:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800885c:	4b52      	ldr	r3, [pc, #328]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800885e:	681b      	ldr	r3, [r3, #0]
 8008860:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8008864:	d15e      	bne.n	8008924 <HAL_RCC_OscConfig+0x1e4>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8008866:	f7fe fb97 	bl	8006f98 <HAL_GetTick>
 800886a:	1bc0      	subs	r0, r0, r7
 800886c:	2864      	cmp	r0, #100	; 0x64
 800886e:	d9f5      	bls.n	800885c <HAL_RCC_OscConfig+0x11c>
            return HAL_TIMEOUT;
 8008870:	2003      	movs	r0, #3
 8008872:	e29a      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8008874:	4b4c      	ldr	r3, [pc, #304]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008876:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800887a:	091b      	lsrs	r3, r3, #4
 800887c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8008880:	e7a0      	b.n	80087c4 <HAL_RCC_OscConfig+0x84>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8008882:	f7ff fe95 	bl	80085b0 <RCC_SetFlashLatencyFromMSIRange>
 8008886:	2800      	cmp	r0, #0
 8008888:	f040 8288 	bne.w	8008d9c <HAL_RCC_OscConfig+0x65c>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800888c:	4b46      	ldr	r3, [pc, #280]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800888e:	681a      	ldr	r2, [r3, #0]
 8008890:	f042 0208 	orr.w	r2, r2, #8
 8008894:	601a      	str	r2, [r3, #0]
 8008896:	681a      	ldr	r2, [r3, #0]
 8008898:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800889c:	6a21      	ldr	r1, [r4, #32]
 800889e:	430a      	orrs	r2, r1
 80088a0:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80088a2:	685a      	ldr	r2, [r3, #4]
 80088a4:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80088a8:	69e1      	ldr	r1, [r4, #28]
 80088aa:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80088ae:	605a      	str	r2, [r3, #4]
 80088b0:	e79e      	b.n	80087f0 <HAL_RCC_OscConfig+0xb0>
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 80088b2:	6a20      	ldr	r0, [r4, #32]
 80088b4:	f7ff fe7c 	bl	80085b0 <RCC_SetFlashLatencyFromMSIRange>
 80088b8:	2800      	cmp	r0, #0
 80088ba:	d099      	beq.n	80087f0 <HAL_RCC_OscConfig+0xb0>
              return HAL_ERROR;
 80088bc:	2001      	movs	r0, #1
 80088be:	e274      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80088c0:	4b39      	ldr	r3, [pc, #228]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80088c2:	681a      	ldr	r2, [r3, #0]
 80088c4:	f042 0208 	orr.w	r2, r2, #8
 80088c8:	601a      	str	r2, [r3, #0]
 80088ca:	681a      	ldr	r2, [r3, #0]
 80088cc:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80088d0:	6a21      	ldr	r1, [r4, #32]
 80088d2:	430a      	orrs	r2, r1
 80088d4:	601a      	str	r2, [r3, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80088d6:	685a      	ldr	r2, [r3, #4]
 80088d8:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 80088dc:	69e1      	ldr	r1, [r4, #28]
 80088de:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80088e2:	605a      	str	r2, [r3, #4]
 80088e4:	e798      	b.n	8008818 <HAL_RCC_OscConfig+0xd8>
        __HAL_RCC_MSI_DISABLE();
 80088e6:	4a30      	ldr	r2, [pc, #192]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80088e8:	6813      	ldr	r3, [r2, #0]
 80088ea:	f023 0301 	bic.w	r3, r3, #1
 80088ee:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80088f0:	f7fe fb52 	bl	8006f98 <HAL_GetTick>
 80088f4:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 80088f6:	4b2c      	ldr	r3, [pc, #176]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 80088f8:	681b      	ldr	r3, [r3, #0]
 80088fa:	f013 0f02 	tst.w	r3, #2
 80088fe:	d08b      	beq.n	8008818 <HAL_RCC_OscConfig+0xd8>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8008900:	f7fe fb4a 	bl	8006f98 <HAL_GetTick>
 8008904:	1bc0      	subs	r0, r0, r7
 8008906:	2802      	cmp	r0, #2
 8008908:	d9f5      	bls.n	80088f6 <HAL_RCC_OscConfig+0x1b6>
            return HAL_TIMEOUT;
 800890a:	2003      	movs	r0, #3
 800890c:	e24d      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 800890e:	2e03      	cmp	r6, #3
 8008910:	d18b      	bne.n	800882a <HAL_RCC_OscConfig+0xea>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8008912:	4b25      	ldr	r3, [pc, #148]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008914:	681b      	ldr	r3, [r3, #0]
 8008916:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800891a:	d003      	beq.n	8008924 <HAL_RCC_OscConfig+0x1e4>
 800891c:	6863      	ldr	r3, [r4, #4]
 800891e:	2b00      	cmp	r3, #0
 8008920:	f000 823e 	beq.w	8008da0 <HAL_RCC_OscConfig+0x660>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8008924:	6823      	ldr	r3, [r4, #0]
 8008926:	f013 0f02 	tst.w	r3, #2
 800892a:	d058      	beq.n	80089de <HAL_RCC_OscConfig+0x29e>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 800892c:	2d04      	cmp	r5, #4
 800892e:	d045      	beq.n	80089bc <HAL_RCC_OscConfig+0x27c>
 8008930:	2d0c      	cmp	r5, #12
 8008932:	d041      	beq.n	80089b8 <HAL_RCC_OscConfig+0x278>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8008934:	68e3      	ldr	r3, [r4, #12]
 8008936:	2b00      	cmp	r3, #0
 8008938:	d077      	beq.n	8008a2a <HAL_RCC_OscConfig+0x2ea>
        __HAL_RCC_HSI_ENABLE();
 800893a:	4a1b      	ldr	r2, [pc, #108]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800893c:	6813      	ldr	r3, [r2, #0]
 800893e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008942:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8008944:	f7fe fb28 	bl	8006f98 <HAL_GetTick>
 8008948:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800894a:	4b17      	ldr	r3, [pc, #92]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 800894c:	681b      	ldr	r3, [r3, #0]
 800894e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008952:	d161      	bne.n	8008a18 <HAL_RCC_OscConfig+0x2d8>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8008954:	f7fe fb20 	bl	8006f98 <HAL_GetTick>
 8008958:	1b80      	subs	r0, r0, r6
 800895a:	2802      	cmp	r0, #2
 800895c:	d9f5      	bls.n	800894a <HAL_RCC_OscConfig+0x20a>
            return HAL_TIMEOUT;
 800895e:	2003      	movs	r0, #3
 8008960:	e223      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8008962:	4a11      	ldr	r2, [pc, #68]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008964:	6813      	ldr	r3, [r2, #0]
 8008966:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800896a:	6013      	str	r3, [r2, #0]
 800896c:	e76f      	b.n	800884e <HAL_RCC_OscConfig+0x10e>
 800896e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8008972:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8008976:	681a      	ldr	r2, [r3, #0]
 8008978:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800897c:	601a      	str	r2, [r3, #0]
 800897e:	681a      	ldr	r2, [r3, #0]
 8008980:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8008984:	601a      	str	r2, [r3, #0]
 8008986:	e762      	b.n	800884e <HAL_RCC_OscConfig+0x10e>
        tickstart = HAL_GetTick();
 8008988:	f7fe fb06 	bl	8006f98 <HAL_GetTick>
 800898c:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 800898e:	4b06      	ldr	r3, [pc, #24]	; (80089a8 <HAL_RCC_OscConfig+0x268>)
 8008990:	681b      	ldr	r3, [r3, #0]
 8008992:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8008996:	d0c5      	beq.n	8008924 <HAL_RCC_OscConfig+0x1e4>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8008998:	f7fe fafe 	bl	8006f98 <HAL_GetTick>
 800899c:	1bc0      	subs	r0, r0, r7
 800899e:	2864      	cmp	r0, #100	; 0x64
 80089a0:	d9f5      	bls.n	800898e <HAL_RCC_OscConfig+0x24e>
            return HAL_TIMEOUT;
 80089a2:	2003      	movs	r0, #3
 80089a4:	e201      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 80089a6:	bf00      	nop
 80089a8:	40021000 	.word	0x40021000
 80089ac:	0802dc70 	.word	0x0802dc70
 80089b0:	20000034 	.word	0x20000034
 80089b4:	2000003c 	.word	0x2000003c
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80089b8:	2e02      	cmp	r6, #2
 80089ba:	d1bb      	bne.n	8008934 <HAL_RCC_OscConfig+0x1f4>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80089bc:	4bac      	ldr	r3, [pc, #688]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 80089be:	681b      	ldr	r3, [r3, #0]
 80089c0:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80089c4:	d003      	beq.n	80089ce <HAL_RCC_OscConfig+0x28e>
 80089c6:	68e3      	ldr	r3, [r4, #12]
 80089c8:	2b00      	cmp	r3, #0
 80089ca:	f000 81eb 	beq.w	8008da4 <HAL_RCC_OscConfig+0x664>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80089ce:	4aa8      	ldr	r2, [pc, #672]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 80089d0:	6853      	ldr	r3, [r2, #4]
 80089d2:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80089d6:	6921      	ldr	r1, [r4, #16]
 80089d8:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 80089dc:	6053      	str	r3, [r2, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80089de:	6823      	ldr	r3, [r4, #0]
 80089e0:	f013 0f08 	tst.w	r3, #8
 80089e4:	d04c      	beq.n	8008a80 <HAL_RCC_OscConfig+0x340>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 80089e6:	6963      	ldr	r3, [r4, #20]
 80089e8:	b39b      	cbz	r3, 8008a52 <HAL_RCC_OscConfig+0x312>
      __HAL_RCC_LSI_ENABLE();
 80089ea:	4aa1      	ldr	r2, [pc, #644]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 80089ec:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 80089f0:	f043 0301 	orr.w	r3, r3, #1
 80089f4:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      tickstart = HAL_GetTick();
 80089f8:	f7fe face 	bl	8006f98 <HAL_GetTick>
 80089fc:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 80089fe:	4b9c      	ldr	r3, [pc, #624]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a00:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8008a04:	f013 0f02 	tst.w	r3, #2
 8008a08:	d13a      	bne.n	8008a80 <HAL_RCC_OscConfig+0x340>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8008a0a:	f7fe fac5 	bl	8006f98 <HAL_GetTick>
 8008a0e:	1b80      	subs	r0, r0, r6
 8008a10:	2802      	cmp	r0, #2
 8008a12:	d9f4      	bls.n	80089fe <HAL_RCC_OscConfig+0x2be>
          return HAL_TIMEOUT;
 8008a14:	2003      	movs	r0, #3
 8008a16:	e1c8      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8008a18:	4a95      	ldr	r2, [pc, #596]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a1a:	6853      	ldr	r3, [r2, #4]
 8008a1c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8008a20:	6921      	ldr	r1, [r4, #16]
 8008a22:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8008a26:	6053      	str	r3, [r2, #4]
 8008a28:	e7d9      	b.n	80089de <HAL_RCC_OscConfig+0x29e>
        __HAL_RCC_HSI_DISABLE();
 8008a2a:	4a91      	ldr	r2, [pc, #580]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a2c:	6813      	ldr	r3, [r2, #0]
 8008a2e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008a32:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8008a34:	f7fe fab0 	bl	8006f98 <HAL_GetTick>
 8008a38:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8008a3a:	4b8d      	ldr	r3, [pc, #564]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a3c:	681b      	ldr	r3, [r3, #0]
 8008a3e:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8008a42:	d0cc      	beq.n	80089de <HAL_RCC_OscConfig+0x29e>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8008a44:	f7fe faa8 	bl	8006f98 <HAL_GetTick>
 8008a48:	1b80      	subs	r0, r0, r6
 8008a4a:	2802      	cmp	r0, #2
 8008a4c:	d9f5      	bls.n	8008a3a <HAL_RCC_OscConfig+0x2fa>
            return HAL_TIMEOUT;
 8008a4e:	2003      	movs	r0, #3
 8008a50:	e1ab      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      __HAL_RCC_LSI_DISABLE();
 8008a52:	4a87      	ldr	r2, [pc, #540]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a54:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8008a58:	f023 0301 	bic.w	r3, r3, #1
 8008a5c:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
      tickstart = HAL_GetTick();
 8008a60:	f7fe fa9a 	bl	8006f98 <HAL_GetTick>
 8008a64:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8008a66:	4b82      	ldr	r3, [pc, #520]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a68:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8008a6c:	f013 0f02 	tst.w	r3, #2
 8008a70:	d006      	beq.n	8008a80 <HAL_RCC_OscConfig+0x340>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8008a72:	f7fe fa91 	bl	8006f98 <HAL_GetTick>
 8008a76:	1b80      	subs	r0, r0, r6
 8008a78:	2802      	cmp	r0, #2
 8008a7a:	d9f4      	bls.n	8008a66 <HAL_RCC_OscConfig+0x326>
          return HAL_TIMEOUT;
 8008a7c:	2003      	movs	r0, #3
 8008a7e:	e194      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8008a80:	6823      	ldr	r3, [r4, #0]
 8008a82:	f013 0f04 	tst.w	r3, #4
 8008a86:	d07a      	beq.n	8008b7e <HAL_RCC_OscConfig+0x43e>
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8008a88:	4b79      	ldr	r3, [pc, #484]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a8a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008a8c:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8008a90:	d136      	bne.n	8008b00 <HAL_RCC_OscConfig+0x3c0>
      __HAL_RCC_PWR_CLK_ENABLE();
 8008a92:	4b77      	ldr	r3, [pc, #476]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008a94:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8008a96:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8008a9a:	659a      	str	r2, [r3, #88]	; 0x58
 8008a9c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8008a9e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008aa2:	9301      	str	r3, [sp, #4]
 8008aa4:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8008aa6:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8008aa8:	4b72      	ldr	r3, [pc, #456]	; (8008c74 <HAL_RCC_OscConfig+0x534>)
 8008aaa:	681b      	ldr	r3, [r3, #0]
 8008aac:	f413 7f80 	tst.w	r3, #256	; 0x100
 8008ab0:	d028      	beq.n	8008b04 <HAL_RCC_OscConfig+0x3c4>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8008ab2:	68a3      	ldr	r3, [r4, #8]
 8008ab4:	2b01      	cmp	r3, #1
 8008ab6:	d039      	beq.n	8008b2c <HAL_RCC_OscConfig+0x3ec>
 8008ab8:	2b05      	cmp	r3, #5
 8008aba:	d03f      	beq.n	8008b3c <HAL_RCC_OscConfig+0x3fc>
 8008abc:	4b6c      	ldr	r3, [pc, #432]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008abe:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008ac2:	f022 0201 	bic.w	r2, r2, #1
 8008ac6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8008aca:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008ace:	f022 0204 	bic.w	r2, r2, #4
 8008ad2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8008ad6:	68a3      	ldr	r3, [r4, #8]
 8008ad8:	2b00      	cmp	r3, #0
 8008ada:	d03d      	beq.n	8008b58 <HAL_RCC_OscConfig+0x418>
      tickstart = HAL_GetTick();
 8008adc:	f7fe fa5c 	bl	8006f98 <HAL_GetTick>
 8008ae0:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8008ae2:	4b63      	ldr	r3, [pc, #396]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008ae4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008ae8:	f013 0f02 	tst.w	r3, #2
 8008aec:	d146      	bne.n	8008b7c <HAL_RCC_OscConfig+0x43c>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008aee:	f7fe fa53 	bl	8006f98 <HAL_GetTick>
 8008af2:	1bc0      	subs	r0, r0, r7
 8008af4:	f241 3388 	movw	r3, #5000	; 0x1388
 8008af8:	4298      	cmp	r0, r3
 8008afa:	d9f2      	bls.n	8008ae2 <HAL_RCC_OscConfig+0x3a2>
          return HAL_TIMEOUT;
 8008afc:	2003      	movs	r0, #3
 8008afe:	e154      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    FlagStatus       pwrclkchanged = RESET;
 8008b00:	2600      	movs	r6, #0
 8008b02:	e7d1      	b.n	8008aa8 <HAL_RCC_OscConfig+0x368>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8008b04:	4a5b      	ldr	r2, [pc, #364]	; (8008c74 <HAL_RCC_OscConfig+0x534>)
 8008b06:	6813      	ldr	r3, [r2, #0]
 8008b08:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8008b0c:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8008b0e:	f7fe fa43 	bl	8006f98 <HAL_GetTick>
 8008b12:	4607      	mov	r7, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8008b14:	4b57      	ldr	r3, [pc, #348]	; (8008c74 <HAL_RCC_OscConfig+0x534>)
 8008b16:	681b      	ldr	r3, [r3, #0]
 8008b18:	f413 7f80 	tst.w	r3, #256	; 0x100
 8008b1c:	d1c9      	bne.n	8008ab2 <HAL_RCC_OscConfig+0x372>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8008b1e:	f7fe fa3b 	bl	8006f98 <HAL_GetTick>
 8008b22:	1bc0      	subs	r0, r0, r7
 8008b24:	2802      	cmp	r0, #2
 8008b26:	d9f5      	bls.n	8008b14 <HAL_RCC_OscConfig+0x3d4>
          return HAL_TIMEOUT;
 8008b28:	2003      	movs	r0, #3
 8008b2a:	e13e      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8008b2c:	4a50      	ldr	r2, [pc, #320]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b2e:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8008b32:	f043 0301 	orr.w	r3, r3, #1
 8008b36:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8008b3a:	e7cc      	b.n	8008ad6 <HAL_RCC_OscConfig+0x396>
 8008b3c:	4b4c      	ldr	r3, [pc, #304]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b3e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008b42:	f042 0204 	orr.w	r2, r2, #4
 8008b46:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8008b4a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 8008b4e:	f042 0201 	orr.w	r2, r2, #1
 8008b52:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
 8008b56:	e7be      	b.n	8008ad6 <HAL_RCC_OscConfig+0x396>
      tickstart = HAL_GetTick();
 8008b58:	f7fe fa1e 	bl	8006f98 <HAL_GetTick>
 8008b5c:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8008b5e:	4b44      	ldr	r3, [pc, #272]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b60:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8008b64:	f013 0f02 	tst.w	r3, #2
 8008b68:	d008      	beq.n	8008b7c <HAL_RCC_OscConfig+0x43c>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008b6a:	f7fe fa15 	bl	8006f98 <HAL_GetTick>
 8008b6e:	1bc0      	subs	r0, r0, r7
 8008b70:	f241 3388 	movw	r3, #5000	; 0x1388
 8008b74:	4298      	cmp	r0, r3
 8008b76:	d9f2      	bls.n	8008b5e <HAL_RCC_OscConfig+0x41e>
          return HAL_TIMEOUT;
 8008b78:	2003      	movs	r0, #3
 8008b7a:	e116      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    if(pwrclkchanged == SET)
 8008b7c:	b9e6      	cbnz	r6, 8008bb8 <HAL_RCC_OscConfig+0x478>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8008b7e:	6823      	ldr	r3, [r4, #0]
 8008b80:	f013 0f20 	tst.w	r3, #32
 8008b84:	d035      	beq.n	8008bf2 <HAL_RCC_OscConfig+0x4b2>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8008b86:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8008b88:	b1e3      	cbz	r3, 8008bc4 <HAL_RCC_OscConfig+0x484>
      __HAL_RCC_HSI48_ENABLE();
 8008b8a:	4a39      	ldr	r2, [pc, #228]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008b8c:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8008b90:	f043 0301 	orr.w	r3, r3, #1
 8008b94:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
      tickstart = HAL_GetTick();
 8008b98:	f7fe f9fe 	bl	8006f98 <HAL_GetTick>
 8008b9c:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8008b9e:	4b34      	ldr	r3, [pc, #208]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008ba0:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8008ba4:	f013 0f02 	tst.w	r3, #2
 8008ba8:	d123      	bne.n	8008bf2 <HAL_RCC_OscConfig+0x4b2>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8008baa:	f7fe f9f5 	bl	8006f98 <HAL_GetTick>
 8008bae:	1b80      	subs	r0, r0, r6
 8008bb0:	2802      	cmp	r0, #2
 8008bb2:	d9f4      	bls.n	8008b9e <HAL_RCC_OscConfig+0x45e>
          return HAL_TIMEOUT;
 8008bb4:	2003      	movs	r0, #3
 8008bb6:	e0f8      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      __HAL_RCC_PWR_CLK_DISABLE();
 8008bb8:	4a2d      	ldr	r2, [pc, #180]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008bba:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8008bbc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8008bc0:	6593      	str	r3, [r2, #88]	; 0x58
 8008bc2:	e7dc      	b.n	8008b7e <HAL_RCC_OscConfig+0x43e>
      __HAL_RCC_HSI48_DISABLE();
 8008bc4:	4a2a      	ldr	r2, [pc, #168]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008bc6:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
 8008bca:	f023 0301 	bic.w	r3, r3, #1
 8008bce:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
      tickstart = HAL_GetTick();
 8008bd2:	f7fe f9e1 	bl	8006f98 <HAL_GetTick>
 8008bd6:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8008bd8:	4b25      	ldr	r3, [pc, #148]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008bda:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8008bde:	f013 0f02 	tst.w	r3, #2
 8008be2:	d006      	beq.n	8008bf2 <HAL_RCC_OscConfig+0x4b2>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8008be4:	f7fe f9d8 	bl	8006f98 <HAL_GetTick>
 8008be8:	1b80      	subs	r0, r0, r6
 8008bea:	2802      	cmp	r0, #2
 8008bec:	d9f4      	bls.n	8008bd8 <HAL_RCC_OscConfig+0x498>
          return HAL_TIMEOUT;
 8008bee:	2003      	movs	r0, #3
 8008bf0:	e0db      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8008bf2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8008bf4:	2b00      	cmp	r3, #0
 8008bf6:	f000 80d7 	beq.w	8008da8 <HAL_RCC_OscConfig+0x668>
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8008bfa:	2b02      	cmp	r3, #2
 8008bfc:	d027      	beq.n	8008c4e <HAL_RCC_OscConfig+0x50e>
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 8008bfe:	2d0c      	cmp	r5, #12
 8008c00:	f000 80d7 	beq.w	8008db2 <HAL_RCC_OscConfig+0x672>
        __HAL_RCC_PLL_DISABLE();
 8008c04:	4b1a      	ldr	r3, [pc, #104]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c06:	681a      	ldr	r2, [r3, #0]
 8008c08:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8008c0c:	601a      	str	r2, [r3, #0]
        if(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8008c0e:	681b      	ldr	r3, [r3, #0]
 8008c10:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8008c14:	d104      	bne.n	8008c20 <HAL_RCC_OscConfig+0x4e0>
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8008c16:	4a16      	ldr	r2, [pc, #88]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c18:	68d3      	ldr	r3, [r2, #12]
 8008c1a:	f023 0303 	bic.w	r3, r3, #3
 8008c1e:	60d3      	str	r3, [r2, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 8008c20:	4a13      	ldr	r2, [pc, #76]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c22:	68d3      	ldr	r3, [r2, #12]
 8008c24:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8008c28:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8008c2c:	60d3      	str	r3, [r2, #12]
        tickstart = HAL_GetTick();
 8008c2e:	f7fe f9b3 	bl	8006f98 <HAL_GetTick>
 8008c32:	4604      	mov	r4, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008c34:	4b0e      	ldr	r3, [pc, #56]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c36:	681b      	ldr	r3, [r3, #0]
 8008c38:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008c3c:	f000 80a8 	beq.w	8008d90 <HAL_RCC_OscConfig+0x650>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008c40:	f7fe f9aa 	bl	8006f98 <HAL_GetTick>
 8008c44:	1b00      	subs	r0, r0, r4
 8008c46:	2802      	cmp	r0, #2
 8008c48:	d9f4      	bls.n	8008c34 <HAL_RCC_OscConfig+0x4f4>
            return HAL_TIMEOUT;
 8008c4a:	2003      	movs	r0, #3
 8008c4c:	e0ad      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
      pll_config = RCC->PLLCFGR;
 8008c4e:	4b08      	ldr	r3, [pc, #32]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c50:	68db      	ldr	r3, [r3, #12]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8008c52:	f003 0103 	and.w	r1, r3, #3
 8008c56:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8008c58:	4291      	cmp	r1, r2
 8008c5a:	d00d      	beq.n	8008c78 <HAL_RCC_OscConfig+0x538>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8008c5c:	2d0c      	cmp	r5, #12
 8008c5e:	f000 80a6 	beq.w	8008dae <HAL_RCC_OscConfig+0x66e>
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 8008c62:	4b03      	ldr	r3, [pc, #12]	; (8008c70 <HAL_RCC_OscConfig+0x530>)
 8008c64:	681b      	ldr	r3, [r3, #0]
 8008c66:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 8008c6a:	d02f      	beq.n	8008ccc <HAL_RCC_OscConfig+0x58c>
            return HAL_ERROR;
 8008c6c:	2001      	movs	r0, #1
 8008c6e:	e09c      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 8008c70:	40021000 	.word	0x40021000
 8008c74:	40007000 	.word	0x40007000
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8008c78:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8008c7c:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8008c7e:	3901      	subs	r1, #1
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 8008c80:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8008c84:	d1ea      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8008c86:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
 8008c8a:	6b61      	ldr	r1, [r4, #52]	; 0x34
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8008c8c:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8008c90:	d1e4      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8008c92:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
 8008c96:	6ba1      	ldr	r1, [r4, #56]	; 0x38
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 8008c98:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8008c9c:	d1de      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8008c9e:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 8008ca2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8008ca4:	0852      	lsrs	r2, r2, #1
 8008ca6:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8008ca8:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8008cac:	d1d6      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8008cae:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 8008cb2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8008cb4:	0852      	lsrs	r2, r2, #1
 8008cb6:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8008cb8:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 8008cbc:	d1ce      	bne.n	8008c5c <HAL_RCC_OscConfig+0x51c>
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008cbe:	4b3e      	ldr	r3, [pc, #248]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cc0:	681b      	ldr	r3, [r3, #0]
 8008cc2:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008cc6:	d049      	beq.n	8008d5c <HAL_RCC_OscConfig+0x61c>
  return HAL_OK;
 8008cc8:	2000      	movs	r0, #0
 8008cca:	e06e      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
            __HAL_RCC_PLL_DISABLE();
 8008ccc:	4a3a      	ldr	r2, [pc, #232]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cce:	6813      	ldr	r3, [r2, #0]
 8008cd0:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8008cd4:	6013      	str	r3, [r2, #0]
            tickstart = HAL_GetTick();
 8008cd6:	f7fe f95f 	bl	8006f98 <HAL_GetTick>
 8008cda:	4605      	mov	r5, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8008cdc:	4b36      	ldr	r3, [pc, #216]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cde:	681b      	ldr	r3, [r3, #0]
 8008ce0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008ce4:	d006      	beq.n	8008cf4 <HAL_RCC_OscConfig+0x5b4>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008ce6:	f7fe f957 	bl	8006f98 <HAL_GetTick>
 8008cea:	1b40      	subs	r0, r0, r5
 8008cec:	2802      	cmp	r0, #2
 8008cee:	d9f5      	bls.n	8008cdc <HAL_RCC_OscConfig+0x59c>
                return HAL_TIMEOUT;
 8008cf0:	2003      	movs	r0, #3
 8008cf2:	e05a      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8008cf4:	4a30      	ldr	r2, [pc, #192]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008cf6:	68d3      	ldr	r3, [r2, #12]
 8008cf8:	4930      	ldr	r1, [pc, #192]	; (8008dbc <HAL_RCC_OscConfig+0x67c>)
 8008cfa:	4019      	ands	r1, r3
 8008cfc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8008cfe:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8008d00:	3801      	subs	r0, #1
 8008d02:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8008d06:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8008d08:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8008d0c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8008d0e:	0840      	lsrs	r0, r0, #1
 8008d10:	3801      	subs	r0, #1
 8008d12:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 8008d16:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8008d18:	0840      	lsrs	r0, r0, #1
 8008d1a:	3801      	subs	r0, #1
 8008d1c:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
 8008d20:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8008d22:	ea43 63c0 	orr.w	r3, r3, r0, lsl #27
 8008d26:	4319      	orrs	r1, r3
 8008d28:	60d1      	str	r1, [r2, #12]
            __HAL_RCC_PLL_ENABLE();
 8008d2a:	6813      	ldr	r3, [r2, #0]
 8008d2c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008d30:	6013      	str	r3, [r2, #0]
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008d32:	68d3      	ldr	r3, [r2, #12]
 8008d34:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8008d38:	60d3      	str	r3, [r2, #12]
            tickstart = HAL_GetTick();
 8008d3a:	f7fe f92d 	bl	8006f98 <HAL_GetTick>
 8008d3e:	4604      	mov	r4, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008d40:	4b1d      	ldr	r3, [pc, #116]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008d42:	681b      	ldr	r3, [r3, #0]
 8008d44:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008d48:	d106      	bne.n	8008d58 <HAL_RCC_OscConfig+0x618>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008d4a:	f7fe f925 	bl	8006f98 <HAL_GetTick>
 8008d4e:	1b00      	subs	r0, r0, r4
 8008d50:	2802      	cmp	r0, #2
 8008d52:	d9f5      	bls.n	8008d40 <HAL_RCC_OscConfig+0x600>
                return HAL_TIMEOUT;
 8008d54:	2003      	movs	r0, #3
 8008d56:	e028      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  return HAL_OK;
 8008d58:	2000      	movs	r0, #0
 8008d5a:	e026      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
          __HAL_RCC_PLL_ENABLE();
 8008d5c:	4b16      	ldr	r3, [pc, #88]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008d5e:	681a      	ldr	r2, [r3, #0]
 8008d60:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008d64:	601a      	str	r2, [r3, #0]
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8008d66:	68da      	ldr	r2, [r3, #12]
 8008d68:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008d6c:	60da      	str	r2, [r3, #12]
          tickstart = HAL_GetTick();
 8008d6e:	f7fe f913 	bl	8006f98 <HAL_GetTick>
 8008d72:	4604      	mov	r4, r0
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008d74:	4b10      	ldr	r3, [pc, #64]	; (8008db8 <HAL_RCC_OscConfig+0x678>)
 8008d76:	681b      	ldr	r3, [r3, #0]
 8008d78:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8008d7c:	d106      	bne.n	8008d8c <HAL_RCC_OscConfig+0x64c>
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8008d7e:	f7fe f90b 	bl	8006f98 <HAL_GetTick>
 8008d82:	1b03      	subs	r3, r0, r4
 8008d84:	2b02      	cmp	r3, #2
 8008d86:	d9f5      	bls.n	8008d74 <HAL_RCC_OscConfig+0x634>
              return HAL_TIMEOUT;
 8008d88:	2003      	movs	r0, #3
 8008d8a:	e00e      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  return HAL_OK;
 8008d8c:	2000      	movs	r0, #0
 8008d8e:	e00c      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 8008d90:	2000      	movs	r0, #0
 8008d92:	e00a      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
    return HAL_ERROR;
 8008d94:	2001      	movs	r0, #1
}
 8008d96:	4770      	bx	lr
        return HAL_ERROR;
 8008d98:	2001      	movs	r0, #1
 8008d9a:	e006      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
            return HAL_ERROR;
 8008d9c:	2001      	movs	r0, #1
 8008d9e:	e004      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        return HAL_ERROR;
 8008da0:	2001      	movs	r0, #1
 8008da2:	e002      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        return HAL_ERROR;
 8008da4:	2001      	movs	r0, #1
 8008da6:	e000      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
  return HAL_OK;
 8008da8:	2000      	movs	r0, #0
}
 8008daa:	b003      	add	sp, #12
 8008dac:	bdf0      	pop	{r4, r5, r6, r7, pc}
          return HAL_ERROR;
 8008dae:	2001      	movs	r0, #1
 8008db0:	e7fb      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
        return HAL_ERROR;
 8008db2:	2001      	movs	r0, #1
 8008db4:	e7f9      	b.n	8008daa <HAL_RCC_OscConfig+0x66a>
 8008db6:	bf00      	nop
 8008db8:	40021000 	.word	0x40021000
 8008dbc:	019d808c 	.word	0x019d808c

08008dc0 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 8008dc0:	2800      	cmp	r0, #0
 8008dc2:	f000 8098 	beq.w	8008ef6 <HAL_RCC_ClockConfig+0x136>
{
 8008dc6:	b570      	push	{r4, r5, r6, lr}
 8008dc8:	460c      	mov	r4, r1
 8008dca:	4605      	mov	r5, r0
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8008dcc:	4b4e      	ldr	r3, [pc, #312]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008dce:	681b      	ldr	r3, [r3, #0]
 8008dd0:	f003 0307 	and.w	r3, r3, #7
 8008dd4:	428b      	cmp	r3, r1
 8008dd6:	d20b      	bcs.n	8008df0 <HAL_RCC_ClockConfig+0x30>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008dd8:	4a4b      	ldr	r2, [pc, #300]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008dda:	6813      	ldr	r3, [r2, #0]
 8008ddc:	f023 0307 	bic.w	r3, r3, #7
 8008de0:	430b      	orrs	r3, r1
 8008de2:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008de4:	6813      	ldr	r3, [r2, #0]
 8008de6:	f003 0307 	and.w	r3, r3, #7
 8008dea:	428b      	cmp	r3, r1
 8008dec:	f040 8085 	bne.w	8008efa <HAL_RCC_ClockConfig+0x13a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8008df0:	682b      	ldr	r3, [r5, #0]
 8008df2:	f013 0f01 	tst.w	r3, #1
 8008df6:	d039      	beq.n	8008e6c <HAL_RCC_ClockConfig+0xac>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8008df8:	686b      	ldr	r3, [r5, #4]
 8008dfa:	2b03      	cmp	r3, #3
 8008dfc:	d009      	beq.n	8008e12 <HAL_RCC_ClockConfig+0x52>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8008dfe:	2b02      	cmp	r3, #2
 8008e00:	d026      	beq.n	8008e50 <HAL_RCC_ClockConfig+0x90>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 8008e02:	bb63      	cbnz	r3, 8008e5e <HAL_RCC_ClockConfig+0x9e>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 8008e04:	4a41      	ldr	r2, [pc, #260]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e06:	6812      	ldr	r2, [r2, #0]
 8008e08:	f012 0f02 	tst.w	r2, #2
 8008e0c:	d106      	bne.n	8008e1c <HAL_RCC_ClockConfig+0x5c>
          return HAL_ERROR;
 8008e0e:	2001      	movs	r0, #1
 8008e10:	e070      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8008e12:	4a3e      	ldr	r2, [pc, #248]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e14:	6812      	ldr	r2, [r2, #0]
 8008e16:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 8008e1a:	d070      	beq.n	8008efe <HAL_RCC_ClockConfig+0x13e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8008e1c:	493b      	ldr	r1, [pc, #236]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e1e:	688a      	ldr	r2, [r1, #8]
 8008e20:	f022 0203 	bic.w	r2, r2, #3
 8008e24:	4313      	orrs	r3, r2
 8008e26:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8008e28:	f7fe f8b6 	bl	8006f98 <HAL_GetTick>
 8008e2c:	4606      	mov	r6, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8008e2e:	4b37      	ldr	r3, [pc, #220]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e30:	689b      	ldr	r3, [r3, #8]
 8008e32:	f003 030c 	and.w	r3, r3, #12
 8008e36:	686a      	ldr	r2, [r5, #4]
 8008e38:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8008e3c:	d016      	beq.n	8008e6c <HAL_RCC_ClockConfig+0xac>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8008e3e:	f7fe f8ab 	bl	8006f98 <HAL_GetTick>
 8008e42:	1b80      	subs	r0, r0, r6
 8008e44:	f241 3388 	movw	r3, #5000	; 0x1388
 8008e48:	4298      	cmp	r0, r3
 8008e4a:	d9f0      	bls.n	8008e2e <HAL_RCC_ClockConfig+0x6e>
        return HAL_TIMEOUT;
 8008e4c:	2003      	movs	r0, #3
 8008e4e:	e051      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8008e50:	4a2e      	ldr	r2, [pc, #184]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e52:	6812      	ldr	r2, [r2, #0]
 8008e54:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 8008e58:	d1e0      	bne.n	8008e1c <HAL_RCC_ClockConfig+0x5c>
          return HAL_ERROR;
 8008e5a:	2001      	movs	r0, #1
 8008e5c:	e04a      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8008e5e:	4a2b      	ldr	r2, [pc, #172]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e60:	6812      	ldr	r2, [r2, #0]
 8008e62:	f412 6f80 	tst.w	r2, #1024	; 0x400
 8008e66:	d1d9      	bne.n	8008e1c <HAL_RCC_ClockConfig+0x5c>
          return HAL_ERROR;
 8008e68:	2001      	movs	r0, #1
 8008e6a:	e043      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8008e6c:	682b      	ldr	r3, [r5, #0]
 8008e6e:	f013 0f02 	tst.w	r3, #2
 8008e72:	d006      	beq.n	8008e82 <HAL_RCC_ClockConfig+0xc2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8008e74:	4a25      	ldr	r2, [pc, #148]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008e76:	6893      	ldr	r3, [r2, #8]
 8008e78:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8008e7c:	68a9      	ldr	r1, [r5, #8]
 8008e7e:	430b      	orrs	r3, r1
 8008e80:	6093      	str	r3, [r2, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8008e82:	4b21      	ldr	r3, [pc, #132]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008e84:	681b      	ldr	r3, [r3, #0]
 8008e86:	f003 0307 	and.w	r3, r3, #7
 8008e8a:	42a3      	cmp	r3, r4
 8008e8c:	d90a      	bls.n	8008ea4 <HAL_RCC_ClockConfig+0xe4>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8008e8e:	4a1e      	ldr	r2, [pc, #120]	; (8008f08 <HAL_RCC_ClockConfig+0x148>)
 8008e90:	6813      	ldr	r3, [r2, #0]
 8008e92:	f023 0307 	bic.w	r3, r3, #7
 8008e96:	4323      	orrs	r3, r4
 8008e98:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8008e9a:	6813      	ldr	r3, [r2, #0]
 8008e9c:	f003 0307 	and.w	r3, r3, #7
 8008ea0:	42a3      	cmp	r3, r4
 8008ea2:	d12e      	bne.n	8008f02 <HAL_RCC_ClockConfig+0x142>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8008ea4:	682b      	ldr	r3, [r5, #0]
 8008ea6:	f013 0f04 	tst.w	r3, #4
 8008eaa:	d006      	beq.n	8008eba <HAL_RCC_ClockConfig+0xfa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8008eac:	4a17      	ldr	r2, [pc, #92]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008eae:	6893      	ldr	r3, [r2, #8]
 8008eb0:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8008eb4:	68e9      	ldr	r1, [r5, #12]
 8008eb6:	430b      	orrs	r3, r1
 8008eb8:	6093      	str	r3, [r2, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8008eba:	682b      	ldr	r3, [r5, #0]
 8008ebc:	f013 0f08 	tst.w	r3, #8
 8008ec0:	d007      	beq.n	8008ed2 <HAL_RCC_ClockConfig+0x112>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8008ec2:	4a12      	ldr	r2, [pc, #72]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008ec4:	6893      	ldr	r3, [r2, #8]
 8008ec6:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8008eca:	6929      	ldr	r1, [r5, #16]
 8008ecc:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 8008ed0:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8008ed2:	f7ff fbdb 	bl	800868c <HAL_RCC_GetSysClockFreq>
 8008ed6:	4b0d      	ldr	r3, [pc, #52]	; (8008f0c <HAL_RCC_ClockConfig+0x14c>)
 8008ed8:	689b      	ldr	r3, [r3, #8]
 8008eda:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8008ede:	4a0c      	ldr	r2, [pc, #48]	; (8008f10 <HAL_RCC_ClockConfig+0x150>)
 8008ee0:	5cd3      	ldrb	r3, [r2, r3]
 8008ee2:	f003 031f 	and.w	r3, r3, #31
 8008ee6:	40d8      	lsrs	r0, r3
 8008ee8:	4b0a      	ldr	r3, [pc, #40]	; (8008f14 <HAL_RCC_ClockConfig+0x154>)
 8008eea:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick(uwTickPrio);
 8008eec:	4b0a      	ldr	r3, [pc, #40]	; (8008f18 <HAL_RCC_ClockConfig+0x158>)
 8008eee:	6818      	ldr	r0, [r3, #0]
 8008ef0:	f7f8 fbfa 	bl	80016e8 <HAL_InitTick>
}
 8008ef4:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8008ef6:	2001      	movs	r0, #1
}
 8008ef8:	4770      	bx	lr
      return HAL_ERROR;
 8008efa:	2001      	movs	r0, #1
 8008efc:	e7fa      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
        return HAL_ERROR;
 8008efe:	2001      	movs	r0, #1
 8008f00:	e7f8      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
      return HAL_ERROR;
 8008f02:	2001      	movs	r0, #1
 8008f04:	e7f6      	b.n	8008ef4 <HAL_RCC_ClockConfig+0x134>
 8008f06:	bf00      	nop
 8008f08:	40022000 	.word	0x40022000
 8008f0c:	40021000 	.word	0x40021000
 8008f10:	0802dc70 	.word	0x0802dc70
 8008f14:	20000034 	.word	0x20000034
 8008f18:	2000003c 	.word	0x2000003c

08008f1c <HAL_RCC_GetHCLKFreq>:
}
 8008f1c:	4b01      	ldr	r3, [pc, #4]	; (8008f24 <HAL_RCC_GetHCLKFreq+0x8>)
 8008f1e:	6818      	ldr	r0, [r3, #0]
 8008f20:	4770      	bx	lr
 8008f22:	bf00      	nop
 8008f24:	20000034 	.word	0x20000034

08008f28 <HAL_RCC_GetPCLK1Freq>:
{
 8008f28:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8008f2a:	f7ff fff7 	bl	8008f1c <HAL_RCC_GetHCLKFreq>
 8008f2e:	4b05      	ldr	r3, [pc, #20]	; (8008f44 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8008f30:	689b      	ldr	r3, [r3, #8]
 8008f32:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8008f36:	4a04      	ldr	r2, [pc, #16]	; (8008f48 <HAL_RCC_GetPCLK1Freq+0x20>)
 8008f38:	5cd3      	ldrb	r3, [r2, r3]
 8008f3a:	f003 031f 	and.w	r3, r3, #31
}
 8008f3e:	40d8      	lsrs	r0, r3
 8008f40:	bd08      	pop	{r3, pc}
 8008f42:	bf00      	nop
 8008f44:	40021000 	.word	0x40021000
 8008f48:	0802dc80 	.word	0x0802dc80

08008f4c <HAL_RCC_GetPCLK2Freq>:
{
 8008f4c:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8008f4e:	f7ff ffe5 	bl	8008f1c <HAL_RCC_GetHCLKFreq>
 8008f52:	4b05      	ldr	r3, [pc, #20]	; (8008f68 <HAL_RCC_GetPCLK2Freq+0x1c>)
 8008f54:	689b      	ldr	r3, [r3, #8]
 8008f56:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8008f5a:	4a04      	ldr	r2, [pc, #16]	; (8008f6c <HAL_RCC_GetPCLK2Freq+0x20>)
 8008f5c:	5cd3      	ldrb	r3, [r2, r3]
 8008f5e:	f003 031f 	and.w	r3, r3, #31
}
 8008f62:	40d8      	lsrs	r0, r3
 8008f64:	bd08      	pop	{r3, pc}
 8008f66:	bf00      	nop
 8008f68:	40021000 	.word	0x40021000
 8008f6c:	0802dc80 	.word	0x0802dc80

08008f70 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8008f70:	230f      	movs	r3, #15
 8008f72:	6003      	str	r3, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = READ_BIT(RCC->CFGR, RCC_CFGR_SW);
 8008f74:	4b0b      	ldr	r3, [pc, #44]	; (8008fa4 <HAL_RCC_GetClockConfig+0x34>)
 8008f76:	689a      	ldr	r2, [r3, #8]
 8008f78:	f002 0203 	and.w	r2, r2, #3
 8008f7c:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_HPRE);
 8008f7e:	689a      	ldr	r2, [r3, #8]
 8008f80:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 8008f84:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
 8008f86:	689a      	ldr	r2, [r3, #8]
 8008f88:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8008f8c:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> 3U);
 8008f8e:	689b      	ldr	r3, [r3, #8]
 8008f90:	08db      	lsrs	r3, r3, #3
 8008f92:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8008f96:	6103      	str	r3, [r0, #16]
  *pFLatency = __HAL_FLASH_GET_LATENCY();
 8008f98:	4b03      	ldr	r3, [pc, #12]	; (8008fa8 <HAL_RCC_GetClockConfig+0x38>)
 8008f9a:	681b      	ldr	r3, [r3, #0]
 8008f9c:	f003 0307 	and.w	r3, r3, #7
 8008fa0:	600b      	str	r3, [r1, #0]
}
 8008fa2:	4770      	bx	lr
 8008fa4:	40021000 	.word	0x40021000
 8008fa8:	40022000 	.word	0x40022000

08008fac <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8008fac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008fae:	4604      	mov	r4, r0
 8008fb0:	460f      	mov	r7, r1
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8008fb2:	4b58      	ldr	r3, [pc, #352]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8008fb4:	68db      	ldr	r3, [r3, #12]
 8008fb6:	f013 0f03 	tst.w	r3, #3
 8008fba:	d018      	beq.n	8008fee <RCCEx_PLLSAI1_Config+0x42>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8008fbc:	4b55      	ldr	r3, [pc, #340]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8008fbe:	68db      	ldr	r3, [r3, #12]
 8008fc0:	f003 0303 	and.w	r3, r3, #3
 8008fc4:	6802      	ldr	r2, [r0, #0]
 8008fc6:	4293      	cmp	r3, r2
 8008fc8:	d002      	beq.n	8008fd0 <RCCEx_PLLSAI1_Config+0x24>
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
#endif
      )
    {
      status = HAL_ERROR;
 8008fca:	2501      	movs	r5, #1
      }
    }
  }

  return status;
}
 8008fcc:	4628      	mov	r0, r5
 8008fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ||
 8008fd0:	2a00      	cmp	r2, #0
 8008fd2:	f000 809d 	beq.w	8009110 <RCCEx_PLLSAI1_Config+0x164>
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 8008fd6:	4b4f      	ldr	r3, [pc, #316]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8008fd8:	68db      	ldr	r3, [r3, #12]
 8008fda:	f3c3 1302 	ubfx	r3, r3, #4, #3
 8008fde:	3301      	adds	r3, #1
 8008fe0:	6842      	ldr	r2, [r0, #4]
       ||
 8008fe2:	4293      	cmp	r3, r2
 8008fe4:	d001      	beq.n	8008fea <RCCEx_PLLSAI1_Config+0x3e>
      status = HAL_ERROR;
 8008fe6:	2501      	movs	r5, #1
 8008fe8:	e7f0      	b.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
  HAL_StatusTypeDef status = HAL_OK;
 8008fea:	2500      	movs	r5, #0
 8008fec:	e009      	b.n	8009002 <RCCEx_PLLSAI1_Config+0x56>
    switch(PllSai1->PLLSAI1Source)
 8008fee:	6803      	ldr	r3, [r0, #0]
 8008ff0:	2b02      	cmp	r3, #2
 8008ff2:	d056      	beq.n	80090a2 <RCCEx_PLLSAI1_Config+0xf6>
 8008ff4:	2b03      	cmp	r3, #3
 8008ff6:	d05b      	beq.n	80090b0 <RCCEx_PLLSAI1_Config+0x104>
 8008ff8:	2b01      	cmp	r3, #1
 8008ffa:	d041      	beq.n	8009080 <RCCEx_PLLSAI1_Config+0xd4>
 8008ffc:	2501      	movs	r5, #1
  if(status == HAL_OK)
 8008ffe:	2d00      	cmp	r5, #0
 8009000:	d1e4      	bne.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
    __HAL_RCC_PLLSAI1_DISABLE();
 8009002:	4a44      	ldr	r2, [pc, #272]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009004:	6813      	ldr	r3, [r2, #0]
 8009006:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800900a:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800900c:	f7fd ffc4 	bl	8006f98 <HAL_GetTick>
 8009010:	4606      	mov	r6, r0
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 8009012:	4b40      	ldr	r3, [pc, #256]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009014:	681b      	ldr	r3, [r3, #0]
 8009016:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 800901a:	d005      	beq.n	8009028 <RCCEx_PLLSAI1_Config+0x7c>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 800901c:	f7fd ffbc 	bl	8006f98 <HAL_GetTick>
 8009020:	1b83      	subs	r3, r0, r6
 8009022:	2b02      	cmp	r3, #2
 8009024:	d9f5      	bls.n	8009012 <RCCEx_PLLSAI1_Config+0x66>
        status = HAL_TIMEOUT;
 8009026:	2503      	movs	r5, #3
    if(status == HAL_OK)
 8009028:	2d00      	cmp	r5, #0
 800902a:	d1cf      	bne.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
      if(Divider == DIVIDER_P_UPDATE)
 800902c:	2f00      	cmp	r7, #0
 800902e:	d14d      	bne.n	80090cc <RCCEx_PLLSAI1_Config+0x120>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8009030:	4938      	ldr	r1, [pc, #224]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009032:	690b      	ldr	r3, [r1, #16]
 8009034:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8009038:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 800903c:	68a0      	ldr	r0, [r4, #8]
 800903e:	68e2      	ldr	r2, [r4, #12]
 8009040:	06d2      	lsls	r2, r2, #27
 8009042:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
 8009046:	4313      	orrs	r3, r2
 8009048:	610b      	str	r3, [r1, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 800904a:	4a32      	ldr	r2, [pc, #200]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 800904c:	6813      	ldr	r3, [r2, #0]
 800904e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8009052:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 8009054:	f7fd ffa0 	bl	8006f98 <HAL_GetTick>
 8009058:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 800905a:	4b2e      	ldr	r3, [pc, #184]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 800905c:	681b      	ldr	r3, [r3, #0]
 800905e:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8009062:	d105      	bne.n	8009070 <RCCEx_PLLSAI1_Config+0xc4>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8009064:	f7fd ff98 	bl	8006f98 <HAL_GetTick>
 8009068:	1b83      	subs	r3, r0, r6
 800906a:	2b02      	cmp	r3, #2
 800906c:	d9f5      	bls.n	800905a <RCCEx_PLLSAI1_Config+0xae>
          status = HAL_TIMEOUT;
 800906e:	2503      	movs	r5, #3
      if(status == HAL_OK)
 8009070:	2d00      	cmp	r5, #0
 8009072:	d1ab      	bne.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8009074:	4a27      	ldr	r2, [pc, #156]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009076:	6913      	ldr	r3, [r2, #16]
 8009078:	69a1      	ldr	r1, [r4, #24]
 800907a:	430b      	orrs	r3, r1
 800907c:	6113      	str	r3, [r2, #16]
 800907e:	e7a5      	b.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8009080:	4a24      	ldr	r2, [pc, #144]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 8009082:	6812      	ldr	r2, [r2, #0]
 8009084:	f012 0f02 	tst.w	r2, #2
 8009088:	d01e      	beq.n	80090c8 <RCCEx_PLLSAI1_Config+0x11c>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 800908a:	4822      	ldr	r0, [pc, #136]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 800908c:	68c2      	ldr	r2, [r0, #12]
 800908e:	f022 0273 	bic.w	r2, r2, #115	; 0x73
 8009092:	6861      	ldr	r1, [r4, #4]
 8009094:	3901      	subs	r1, #1
 8009096:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 800909a:	4313      	orrs	r3, r2
 800909c:	60c3      	str	r3, [r0, #12]
 800909e:	2500      	movs	r5, #0
 80090a0:	e7ad      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80090a2:	4a1c      	ldr	r2, [pc, #112]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090a4:	6812      	ldr	r2, [r2, #0]
 80090a6:	f412 6f80 	tst.w	r2, #1024	; 0x400
 80090aa:	d1ee      	bne.n	800908a <RCCEx_PLLSAI1_Config+0xde>
        status = HAL_ERROR;
 80090ac:	2501      	movs	r5, #1
 80090ae:	e7a6      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 80090b0:	4a18      	ldr	r2, [pc, #96]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090b2:	6812      	ldr	r2, [r2, #0]
 80090b4:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80090b8:	d1e7      	bne.n	800908a <RCCEx_PLLSAI1_Config+0xde>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80090ba:	4a16      	ldr	r2, [pc, #88]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090bc:	6812      	ldr	r2, [r2, #0]
 80090be:	f412 2f80 	tst.w	r2, #262144	; 0x40000
 80090c2:	d1e2      	bne.n	800908a <RCCEx_PLLSAI1_Config+0xde>
          status = HAL_ERROR;
 80090c4:	2501      	movs	r5, #1
 80090c6:	e79a      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
        status = HAL_ERROR;
 80090c8:	2501      	movs	r5, #1
 80090ca:	e798      	b.n	8008ffe <RCCEx_PLLSAI1_Config+0x52>
      else if(Divider == DIVIDER_Q_UPDATE)
 80090cc:	2f01      	cmp	r7, #1
 80090ce:	d00f      	beq.n	80090f0 <RCCEx_PLLSAI1_Config+0x144>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80090d0:	4810      	ldr	r0, [pc, #64]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090d2:	6902      	ldr	r2, [r0, #16]
 80090d4:	f022 62c0 	bic.w	r2, r2, #100663296	; 0x6000000
 80090d8:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80090dc:	68a1      	ldr	r1, [r4, #8]
 80090de:	6963      	ldr	r3, [r4, #20]
 80090e0:	085b      	lsrs	r3, r3, #1
 80090e2:	3b01      	subs	r3, #1
 80090e4:	065b      	lsls	r3, r3, #25
 80090e6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 80090ea:	431a      	orrs	r2, r3
 80090ec:	6102      	str	r2, [r0, #16]
 80090ee:	e7ac      	b.n	800904a <RCCEx_PLLSAI1_Config+0x9e>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80090f0:	4808      	ldr	r0, [pc, #32]	; (8009114 <RCCEx_PLLSAI1_Config+0x168>)
 80090f2:	6902      	ldr	r2, [r0, #16]
 80090f4:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80090f8:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80090fc:	68a1      	ldr	r1, [r4, #8]
 80090fe:	6923      	ldr	r3, [r4, #16]
 8009100:	085b      	lsrs	r3, r3, #1
 8009102:	3b01      	subs	r3, #1
 8009104:	055b      	lsls	r3, r3, #21
 8009106:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800910a:	431a      	orrs	r2, r3
 800910c:	6102      	str	r2, [r0, #16]
 800910e:	e79c      	b.n	800904a <RCCEx_PLLSAI1_Config+0x9e>
      status = HAL_ERROR;
 8009110:	2501      	movs	r5, #1
 8009112:	e75b      	b.n	8008fcc <RCCEx_PLLSAI1_Config+0x20>
 8009114:	40021000 	.word	0x40021000

08009118 <HAL_RCCEx_PeriphCLKConfig>:
{
 8009118:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800911c:	b082      	sub	sp, #8
 800911e:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8009120:	6803      	ldr	r3, [r0, #0]
 8009122:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009126:	d025      	beq.n	8009174 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    switch(PeriphClkInit->Sai1ClockSelection)
 8009128:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800912a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800912e:	d006      	beq.n	800913e <HAL_RCCEx_PeriphCLKConfig+0x26>
 8009130:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8009134:	d012      	beq.n	800915c <HAL_RCCEx_PeriphCLKConfig+0x44>
 8009136:	b14b      	cbz	r3, 800914c <HAL_RCCEx_PeriphCLKConfig+0x34>
 8009138:	2601      	movs	r6, #1
 800913a:	4637      	mov	r7, r6
 800913c:	e01c      	b.n	8009178 <HAL_RCCEx_PeriphCLKConfig+0x60>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
 800913e:	4a44      	ldr	r2, [pc, #272]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009140:	68d3      	ldr	r3, [r2, #12]
 8009142:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009146:	60d3      	str	r3, [r2, #12]
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8009148:	2700      	movs	r7, #0
 800914a:	e008      	b.n	800915e <HAL_RCCEx_PeriphCLKConfig+0x46>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 800914c:	2100      	movs	r1, #0
 800914e:	3004      	adds	r0, #4
 8009150:	f7ff ff2c 	bl	8008fac <RCCEx_PLLSAI1_Config>
    if(ret == HAL_OK)
 8009154:	4607      	mov	r7, r0
 8009156:	b110      	cbz	r0, 800915e <HAL_RCCEx_PeriphCLKConfig+0x46>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8009158:	4606      	mov	r6, r0
 800915a:	e00d      	b.n	8009178 <HAL_RCCEx_PeriphCLKConfig+0x60>
    switch(PeriphClkInit->Sai1ClockSelection)
 800915c:	2700      	movs	r7, #0
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800915e:	4a3c      	ldr	r2, [pc, #240]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009160:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009164:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8009168:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800916a:	430b      	orrs	r3, r1
 800916c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8009170:	2600      	movs	r6, #0
 8009172:	e001      	b.n	8009178 <HAL_RCCEx_PeriphCLKConfig+0x60>
 8009174:	2600      	movs	r6, #0
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8009176:	4637      	mov	r7, r6
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8009178:	6823      	ldr	r3, [r4, #0]
 800917a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800917e:	d070      	beq.n	8009262 <HAL_RCCEx_PeriphCLKConfig+0x14a>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8009180:	4b33      	ldr	r3, [pc, #204]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009182:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009184:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
 8009188:	d14c      	bne.n	8009224 <HAL_RCCEx_PeriphCLKConfig+0x10c>
      __HAL_RCC_PWR_CLK_ENABLE();
 800918a:	4b31      	ldr	r3, [pc, #196]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 800918c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800918e:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8009192:	659a      	str	r2, [r3, #88]	; 0x58
 8009194:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009196:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800919a:	9301      	str	r3, [sp, #4]
 800919c:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 800919e:	f04f 0801 	mov.w	r8, #1
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80091a2:	4a2c      	ldr	r2, [pc, #176]	; (8009254 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 80091a4:	6813      	ldr	r3, [r2, #0]
 80091a6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80091aa:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 80091ac:	f7fd fef4 	bl	8006f98 <HAL_GetTick>
 80091b0:	4605      	mov	r5, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 80091b2:	4b28      	ldr	r3, [pc, #160]	; (8009254 <HAL_RCCEx_PeriphCLKConfig+0x13c>)
 80091b4:	681b      	ldr	r3, [r3, #0]
 80091b6:	f413 7f80 	tst.w	r3, #256	; 0x100
 80091ba:	d105      	bne.n	80091c8 <HAL_RCCEx_PeriphCLKConfig+0xb0>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80091bc:	f7fd feec 	bl	8006f98 <HAL_GetTick>
 80091c0:	1b40      	subs	r0, r0, r5
 80091c2:	2802      	cmp	r0, #2
 80091c4:	d9f5      	bls.n	80091b2 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        ret = HAL_TIMEOUT;
 80091c6:	2703      	movs	r7, #3
    if(ret == HAL_OK)
 80091c8:	2f00      	cmp	r7, #0
 80091ca:	d145      	bne.n	8009258 <HAL_RCCEx_PeriphCLKConfig+0x140>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80091cc:	4b20      	ldr	r3, [pc, #128]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 80091ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80091d2:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 80091d6:	d015      	beq.n	8009204 <HAL_RCCEx_PeriphCLKConfig+0xec>
 80091d8:	6e62      	ldr	r2, [r4, #100]	; 0x64
 80091da:	429a      	cmp	r2, r3
 80091dc:	d012      	beq.n	8009204 <HAL_RCCEx_PeriphCLKConfig+0xec>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80091de:	4a1c      	ldr	r2, [pc, #112]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 80091e0:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 80091e4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 80091e8:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 80091ec:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 80091f0:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 80091f4:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 80091f8:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 80091fc:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8009200:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8009204:	f013 0f01 	tst.w	r3, #1
 8009208:	d10f      	bne.n	800922a <HAL_RCCEx_PeriphCLKConfig+0x112>
      if(ret == HAL_OK)
 800920a:	2f00      	cmp	r7, #0
 800920c:	f040 8116 	bne.w	800943c <HAL_RCCEx_PeriphCLKConfig+0x324>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8009210:	4a0f      	ldr	r2, [pc, #60]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009212:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 8009216:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800921a:	6e61      	ldr	r1, [r4, #100]	; 0x64
 800921c:	430b      	orrs	r3, r1
 800921e:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 8009222:	e01a      	b.n	800925a <HAL_RCCEx_PeriphCLKConfig+0x142>
    FlagStatus       pwrclkchanged = RESET;
 8009224:	f04f 0800 	mov.w	r8, #0
 8009228:	e7bb      	b.n	80091a2 <HAL_RCCEx_PeriphCLKConfig+0x8a>
        tickstart = HAL_GetTick();
 800922a:	f7fd feb5 	bl	8006f98 <HAL_GetTick>
 800922e:	4605      	mov	r5, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8009230:	4b07      	ldr	r3, [pc, #28]	; (8009250 <HAL_RCCEx_PeriphCLKConfig+0x138>)
 8009232:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8009236:	f013 0f02 	tst.w	r3, #2
 800923a:	d1e6      	bne.n	800920a <HAL_RCCEx_PeriphCLKConfig+0xf2>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800923c:	f7fd feac 	bl	8006f98 <HAL_GetTick>
 8009240:	1b40      	subs	r0, r0, r5
 8009242:	f241 3388 	movw	r3, #5000	; 0x1388
 8009246:	4298      	cmp	r0, r3
 8009248:	d9f2      	bls.n	8009230 <HAL_RCCEx_PeriphCLKConfig+0x118>
            ret = HAL_TIMEOUT;
 800924a:	2703      	movs	r7, #3
 800924c:	e7dd      	b.n	800920a <HAL_RCCEx_PeriphCLKConfig+0xf2>
 800924e:	bf00      	nop
 8009250:	40021000 	.word	0x40021000
 8009254:	40007000 	.word	0x40007000
      status = ret;
 8009258:	463e      	mov	r6, r7
    if(pwrclkchanged == SET)
 800925a:	f1b8 0f00 	cmp.w	r8, #0
 800925e:	f040 80ef 	bne.w	8009440 <HAL_RCCEx_PeriphCLKConfig+0x328>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8009262:	6823      	ldr	r3, [r4, #0]
 8009264:	f013 0f01 	tst.w	r3, #1
 8009268:	d008      	beq.n	800927c <HAL_RCCEx_PeriphCLKConfig+0x164>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800926a:	4a90      	ldr	r2, [pc, #576]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 800926c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009270:	f023 0303 	bic.w	r3, r3, #3
 8009274:	6a21      	ldr	r1, [r4, #32]
 8009276:	430b      	orrs	r3, r1
 8009278:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 800927c:	6823      	ldr	r3, [r4, #0]
 800927e:	f013 0f02 	tst.w	r3, #2
 8009282:	d008      	beq.n	8009296 <HAL_RCCEx_PeriphCLKConfig+0x17e>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8009284:	4a89      	ldr	r2, [pc, #548]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009286:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800928a:	f023 030c 	bic.w	r3, r3, #12
 800928e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8009290:	430b      	orrs	r3, r1
 8009292:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8009296:	6823      	ldr	r3, [r4, #0]
 8009298:	f013 0f04 	tst.w	r3, #4
 800929c:	d008      	beq.n	80092b0 <HAL_RCCEx_PeriphCLKConfig+0x198>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800929e:	4a83      	ldr	r2, [pc, #524]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092a0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092a4:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 80092a8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80092aa:	430b      	orrs	r3, r1
 80092ac:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 80092b0:	6823      	ldr	r3, [r4, #0]
 80092b2:	f013 0f08 	tst.w	r3, #8
 80092b6:	d008      	beq.n	80092ca <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 80092b8:	4a7c      	ldr	r2, [pc, #496]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092ba:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092be:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 80092c2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80092c4:	430b      	orrs	r3, r1
 80092c6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80092ca:	6823      	ldr	r3, [r4, #0]
 80092cc:	f013 0f20 	tst.w	r3, #32
 80092d0:	d008      	beq.n	80092e4 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 80092d2:	4a76      	ldr	r2, [pc, #472]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092d4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092d8:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80092dc:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80092de:	430b      	orrs	r3, r1
 80092e0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 80092e4:	6823      	ldr	r3, [r4, #0]
 80092e6:	f413 7f00 	tst.w	r3, #512	; 0x200
 80092ea:	d008      	beq.n	80092fe <HAL_RCCEx_PeriphCLKConfig+0x1e6>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80092ec:	4a6f      	ldr	r2, [pc, #444]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80092ee:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80092f2:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 80092f6:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80092f8:	430b      	orrs	r3, r1
 80092fa:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 80092fe:	6823      	ldr	r3, [r4, #0]
 8009300:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8009304:	d008      	beq.n	8009318 <HAL_RCCEx_PeriphCLKConfig+0x200>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8009306:	4a69      	ldr	r2, [pc, #420]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009308:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800930c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8009310:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8009312:	430b      	orrs	r3, r1
 8009314:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8009318:	6823      	ldr	r3, [r4, #0]
 800931a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800931e:	d008      	beq.n	8009332 <HAL_RCCEx_PeriphCLKConfig+0x21a>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8009320:	4a62      	ldr	r2, [pc, #392]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009322:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009326:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800932a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800932c:	430b      	orrs	r3, r1
 800932e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8009332:	6823      	ldr	r3, [r4, #0]
 8009334:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009338:	d008      	beq.n	800934c <HAL_RCCEx_PeriphCLKConfig+0x234>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 800933a:	4a5c      	ldr	r2, [pc, #368]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 800933c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009340:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8009344:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8009346:	430b      	orrs	r3, r1
 8009348:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800934c:	6823      	ldr	r3, [r4, #0]
 800934e:	f413 7f80 	tst.w	r3, #256	; 0x100
 8009352:	d008      	beq.n	8009366 <HAL_RCCEx_PeriphCLKConfig+0x24e>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8009354:	4a55      	ldr	r2, [pc, #340]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009356:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800935a:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 800935e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8009360:	430b      	orrs	r3, r1
 8009362:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8009366:	6823      	ldr	r3, [r4, #0]
 8009368:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800936c:	d008      	beq.n	8009380 <HAL_RCCEx_PeriphCLKConfig+0x268>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800936e:	4a4f      	ldr	r2, [pc, #316]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009370:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8009374:	f023 0303 	bic.w	r3, r3, #3
 8009378:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800937a:	430b      	orrs	r3, r1
 800937c:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8009380:	6823      	ldr	r3, [r4, #0]
 8009382:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 8009386:	d00f      	beq.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8009388:	4a48      	ldr	r2, [pc, #288]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 800938a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800938e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8009392:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8009394:	430b      	orrs	r3, r1
 8009396:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800939a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800939c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80093a0:	d054      	beq.n	800944c <HAL_RCCEx_PeriphCLKConfig+0x334>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 80093a2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80093a6:	d056      	beq.n	8009456 <HAL_RCCEx_PeriphCLKConfig+0x33e>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80093a8:	6823      	ldr	r3, [r4, #0]
 80093aa:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 80093ae:	d00f      	beq.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80093b0:	4a3e      	ldr	r2, [pc, #248]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80093b2:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80093b6:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80093ba:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80093bc:	430b      	orrs	r3, r1
 80093be:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80093c2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80093c4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80093c8:	d04d      	beq.n	8009466 <HAL_RCCEx_PeriphCLKConfig+0x34e>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 80093ca:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80093ce:	d04f      	beq.n	8009470 <HAL_RCCEx_PeriphCLKConfig+0x358>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 80093d0:	6823      	ldr	r3, [r4, #0]
 80093d2:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80093d6:	d00f      	beq.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 80093d8:	4a34      	ldr	r2, [pc, #208]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 80093da:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80093de:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80093e2:	6da1      	ldr	r1, [r4, #88]	; 0x58
 80093e4:	430b      	orrs	r3, r1
 80093e6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 80093ea:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80093ec:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 80093f0:	d046      	beq.n	8009480 <HAL_RCCEx_PeriphCLKConfig+0x368>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 80093f2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80093f6:	d048      	beq.n	800948a <HAL_RCCEx_PeriphCLKConfig+0x372>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 80093f8:	6823      	ldr	r3, [r4, #0]
 80093fa:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80093fe:	d00c      	beq.n	800941a <HAL_RCCEx_PeriphCLKConfig+0x302>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8009400:	4a2a      	ldr	r2, [pc, #168]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009402:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009406:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800940a:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800940c:	430b      	orrs	r3, r1
 800940e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8009412:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8009414:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8009418:	d03f      	beq.n	800949a <HAL_RCCEx_PeriphCLKConfig+0x382>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800941a:	6823      	ldr	r3, [r4, #0]
 800941c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 8009420:	d008      	beq.n	8009434 <HAL_RCCEx_PeriphCLKConfig+0x31c>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8009422:	4a22      	ldr	r2, [pc, #136]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009424:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8009428:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800942c:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800942e:	430b      	orrs	r3, r1
 8009430:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
 8009434:	4630      	mov	r0, r6
 8009436:	b002      	add	sp, #8
 8009438:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        status = ret;
 800943c:	463e      	mov	r6, r7
 800943e:	e70c      	b.n	800925a <HAL_RCCEx_PeriphCLKConfig+0x142>
      __HAL_RCC_PWR_CLK_DISABLE();
 8009440:	4a1a      	ldr	r2, [pc, #104]	; (80094ac <HAL_RCCEx_PeriphCLKConfig+0x394>)
 8009442:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009444:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8009448:	6593      	str	r3, [r2, #88]	; 0x58
 800944a:	e70a      	b.n	8009262 <HAL_RCCEx_PeriphCLKConfig+0x14a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800944c:	68d3      	ldr	r3, [r2, #12]
 800944e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009452:	60d3      	str	r3, [r2, #12]
 8009454:	e7a8      	b.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8009456:	2101      	movs	r1, #1
 8009458:	1d20      	adds	r0, r4, #4
 800945a:	f7ff fda7 	bl	8008fac <RCCEx_PLLSAI1_Config>
        if(ret != HAL_OK)
 800945e:	2800      	cmp	r0, #0
 8009460:	d0a2      	beq.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
          status = ret;
 8009462:	4606      	mov	r6, r0
 8009464:	e7a0      	b.n	80093a8 <HAL_RCCEx_PeriphCLKConfig+0x290>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8009466:	68d3      	ldr	r3, [r2, #12]
 8009468:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800946c:	60d3      	str	r3, [r2, #12]
 800946e:	e7af      	b.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8009470:	2101      	movs	r1, #1
 8009472:	1d20      	adds	r0, r4, #4
 8009474:	f7ff fd9a 	bl	8008fac <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8009478:	2800      	cmp	r0, #0
 800947a:	d0a9      	beq.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
        status = ret;
 800947c:	4606      	mov	r6, r0
 800947e:	e7a7      	b.n	80093d0 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8009480:	68d3      	ldr	r3, [r2, #12]
 8009482:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009486:	60d3      	str	r3, [r2, #12]
 8009488:	e7b6      	b.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800948a:	2101      	movs	r1, #1
 800948c:	1d20      	adds	r0, r4, #4
 800948e:	f7ff fd8d 	bl	8008fac <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 8009492:	2800      	cmp	r0, #0
 8009494:	d0b0      	beq.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
        status = ret;
 8009496:	4606      	mov	r6, r0
 8009498:	e7ae      	b.n	80093f8 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 800949a:	2102      	movs	r1, #2
 800949c:	1d20      	adds	r0, r4, #4
 800949e:	f7ff fd85 	bl	8008fac <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 80094a2:	2800      	cmp	r0, #0
 80094a4:	d0b9      	beq.n	800941a <HAL_RCCEx_PeriphCLKConfig+0x302>
        status = ret;
 80094a6:	4606      	mov	r6, r0
 80094a8:	e7b7      	b.n	800941a <HAL_RCCEx_PeriphCLKConfig+0x302>
 80094aa:	bf00      	nop
 80094ac:	40021000 	.word	0x40021000

080094b0 <HAL_RCCEx_EnableMSIPLLMode>:
  SET_BIT(RCC->CR, RCC_CR_MSIPLLEN) ;
 80094b0:	4a02      	ldr	r2, [pc, #8]	; (80094bc <HAL_RCCEx_EnableMSIPLLMode+0xc>)
 80094b2:	6813      	ldr	r3, [r2, #0]
 80094b4:	f043 0304 	orr.w	r3, r3, #4
 80094b8:	6013      	str	r3, [r2, #0]
}
 80094ba:	4770      	bx	lr
 80094bc:	40021000 	.word	0x40021000

080094c0 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 80094c0:	b378      	cbz	r0, 8009522 <HAL_RNG_Init+0x62>
{
 80094c2:	b538      	push	{r3, r4, r5, lr}
 80094c4:	4604      	mov	r4, r0

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 80094c6:	7943      	ldrb	r3, [r0, #5]
 80094c8:	b17b      	cbz	r3, 80094ea <HAL_RNG_Init+0x2a>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 80094ca:	2302      	movs	r3, #2
 80094cc:	7163      	strb	r3, [r4, #5]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
#endif /* defined(RNG_CR_CED) */
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 80094ce:	6822      	ldr	r2, [r4, #0]
 80094d0:	6813      	ldr	r3, [r2, #0]
 80094d2:	f043 0304 	orr.w	r3, r3, #4
 80094d6:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 80094d8:	6823      	ldr	r3, [r4, #0]
 80094da:	685b      	ldr	r3, [r3, #4]
 80094dc:	f013 0f40 	tst.w	r3, #64	; 0x40
 80094e0:	d007      	beq.n	80094f2 <HAL_RNG_Init+0x32>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 80094e2:	2304      	movs	r3, #4
 80094e4:	7163      	strb	r3, [r4, #5]
    return HAL_ERROR;
 80094e6:	2001      	movs	r0, #1
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 80094e8:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
 80094ea:	7103      	strb	r3, [r0, #4]
    HAL_RNG_MspInit(hrng);
 80094ec:	f7f7 ffc0 	bl	8001470 <HAL_RNG_MspInit>
 80094f0:	e7eb      	b.n	80094ca <HAL_RNG_Init+0xa>
  tickstart = HAL_GetTick();
 80094f2:	f7fd fd51 	bl	8006f98 <HAL_GetTick>
 80094f6:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 80094f8:	6823      	ldr	r3, [r4, #0]
 80094fa:	685b      	ldr	r3, [r3, #4]
 80094fc:	f013 0f04 	tst.w	r3, #4
 8009500:	d00a      	beq.n	8009518 <HAL_RNG_Init+0x58>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8009502:	f7fd fd49 	bl	8006f98 <HAL_GetTick>
 8009506:	1b40      	subs	r0, r0, r5
 8009508:	2802      	cmp	r0, #2
 800950a:	d9f5      	bls.n	80094f8 <HAL_RNG_Init+0x38>
      hrng->State = HAL_RNG_STATE_ERROR;
 800950c:	2304      	movs	r3, #4
 800950e:	7163      	strb	r3, [r4, #5]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 8009510:	2302      	movs	r3, #2
 8009512:	60a3      	str	r3, [r4, #8]
      return HAL_ERROR;
 8009514:	2001      	movs	r0, #1
 8009516:	e7e7      	b.n	80094e8 <HAL_RNG_Init+0x28>
  hrng->State = HAL_RNG_STATE_READY;
 8009518:	2301      	movs	r3, #1
 800951a:	7163      	strb	r3, [r4, #5]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 800951c:	2000      	movs	r0, #0
 800951e:	60a0      	str	r0, [r4, #8]
  return HAL_OK;
 8009520:	e7e2      	b.n	80094e8 <HAL_RNG_Init+0x28>
    return HAL_ERROR;
 8009522:	2001      	movs	r0, #1
}
 8009524:	4770      	bx	lr

08009526 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 8009526:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 8009528:	7903      	ldrb	r3, [r0, #4]
 800952a:	2b01      	cmp	r3, #1
 800952c:	d02b      	beq.n	8009586 <HAL_RNG_GenerateRandomNumber+0x60>
 800952e:	4604      	mov	r4, r0
 8009530:	460e      	mov	r6, r1
 8009532:	2301      	movs	r3, #1
 8009534:	7103      	strb	r3, [r0, #4]

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 8009536:	7945      	ldrb	r5, [r0, #5]
 8009538:	b2ed      	uxtb	r5, r5
 800953a:	429d      	cmp	r5, r3
 800953c:	d006      	beq.n	800954c <HAL_RNG_GenerateRandomNumber+0x26>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800953e:	2304      	movs	r3, #4
 8009540:	6083      	str	r3, [r0, #8]
    status = HAL_ERROR;
 8009542:	2501      	movs	r5, #1
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8009544:	2300      	movs	r3, #0
 8009546:	7123      	strb	r3, [r4, #4]

  return status;
}
 8009548:	4628      	mov	r0, r5
 800954a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
 800954c:	2302      	movs	r3, #2
 800954e:	7143      	strb	r3, [r0, #5]
    tickstart = HAL_GetTick();
 8009550:	f7fd fd22 	bl	8006f98 <HAL_GetTick>
 8009554:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8009556:	6823      	ldr	r3, [r4, #0]
 8009558:	685a      	ldr	r2, [r3, #4]
 800955a:	f012 0f01 	tst.w	r2, #1
 800955e:	d10b      	bne.n	8009578 <HAL_RNG_GenerateRandomNumber+0x52>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 8009560:	f7fd fd1a 	bl	8006f98 <HAL_GetTick>
 8009564:	1bc0      	subs	r0, r0, r7
 8009566:	2802      	cmp	r0, #2
 8009568:	d9f5      	bls.n	8009556 <HAL_RNG_GenerateRandomNumber+0x30>
        hrng->State = HAL_RNG_STATE_READY;
 800956a:	2301      	movs	r3, #1
 800956c:	7163      	strb	r3, [r4, #5]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800956e:	2302      	movs	r3, #2
 8009570:	60a3      	str	r3, [r4, #8]
        __HAL_UNLOCK(hrng);
 8009572:	2300      	movs	r3, #0
 8009574:	7123      	strb	r3, [r4, #4]
        return HAL_ERROR;
 8009576:	e7e7      	b.n	8009548 <HAL_RNG_GenerateRandomNumber+0x22>
    hrng->RandomNumber = hrng->Instance->DR;
 8009578:	689b      	ldr	r3, [r3, #8]
 800957a:	60e3      	str	r3, [r4, #12]
    *random32bit = hrng->RandomNumber;
 800957c:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
 800957e:	2301      	movs	r3, #1
 8009580:	7163      	strb	r3, [r4, #5]
  HAL_StatusTypeDef status = HAL_OK;
 8009582:	2500      	movs	r5, #0
 8009584:	e7de      	b.n	8009544 <HAL_RNG_GenerateRandomNumber+0x1e>
  __HAL_LOCK(hrng);
 8009586:	2502      	movs	r5, #2
 8009588:	e7de      	b.n	8009548 <HAL_RNG_GenerateRandomNumber+0x22>

0800958a <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 800958a:	b538      	push	{r3, r4, r5, lr}
 800958c:	4604      	mov	r4, r0

  /* Clear RSF flag */
#if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
  hrtc->Instance->ICSR &= (uint32_t)RTC_RSF_MASK;
#else
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 800958e:	6802      	ldr	r2, [r0, #0]
 8009590:	68d3      	ldr	r3, [r2, #12]
 8009592:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8009596:	60d3      	str	r3, [r2, #12]
#endif

  tickstart = HAL_GetTick();
 8009598:	f7fd fcfe 	bl	8006f98 <HAL_GetTick>
 800959c:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
#if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx)
  while ((hrtc->Instance->ICSR & RTC_ICSR_RSF) == 0U)
#else
  while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 800959e:	6823      	ldr	r3, [r4, #0]
 80095a0:	68db      	ldr	r3, [r3, #12]
 80095a2:	f013 0f20 	tst.w	r3, #32
 80095a6:	d107      	bne.n	80095b8 <HAL_RTC_WaitForSynchro+0x2e>
#endif
  {
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80095a8:	f7fd fcf6 	bl	8006f98 <HAL_GetTick>
 80095ac:	1b40      	subs	r0, r0, r5
 80095ae:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 80095b2:	d9f4      	bls.n	800959e <HAL_RTC_WaitForSynchro+0x14>
    {
      return HAL_TIMEOUT;
 80095b4:	2003      	movs	r0, #3
 80095b6:	e000      	b.n	80095ba <HAL_RTC_WaitForSynchro+0x30>
    }
  }

  return HAL_OK;
 80095b8:	2000      	movs	r0, #0
}
 80095ba:	bd38      	pop	{r3, r4, r5, pc}

080095bc <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 80095bc:	b570      	push	{r4, r5, r6, lr}
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
      }
    }
  }
#else /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */
  if ((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 80095be:	6803      	ldr	r3, [r0, #0]
 80095c0:	68da      	ldr	r2, [r3, #12]
 80095c2:	f012 0f40 	tst.w	r2, #64	; 0x40
 80095c6:	d002      	beq.n	80095ce <RTC_EnterInitMode+0x12>
  HAL_StatusTypeDef status = HAL_OK;
 80095c8:	2500      	movs	r5, #0
    }
  }
#endif /* #if defined(STM32L412xx) || defined(STM32L422xx) || defined (STM32L4P5xx) || defined (STM32L4Q5xx) */

  return status;
}
 80095ca:	4628      	mov	r0, r5
 80095cc:	bd70      	pop	{r4, r5, r6, pc}
 80095ce:	4604      	mov	r4, r0
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 80095d0:	f04f 32ff 	mov.w	r2, #4294967295
 80095d4:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 80095d6:	f7fd fcdf 	bl	8006f98 <HAL_GetTick>
 80095da:	4606      	mov	r6, r0
  HAL_StatusTypeDef status = HAL_OK;
 80095dc:	2500      	movs	r5, #0
    while ((READ_BIT(hrtc->Instance->ISR, RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 80095de:	6823      	ldr	r3, [r4, #0]
 80095e0:	68db      	ldr	r3, [r3, #12]
 80095e2:	f013 0f40 	tst.w	r3, #64	; 0x40
 80095e6:	d1f0      	bne.n	80095ca <RTC_EnterInitMode+0xe>
 80095e8:	2d03      	cmp	r5, #3
 80095ea:	d0ee      	beq.n	80095ca <RTC_EnterInitMode+0xe>
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 80095ec:	f7fd fcd4 	bl	8006f98 <HAL_GetTick>
 80095f0:	1b83      	subs	r3, r0, r6
 80095f2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80095f6:	d9f2      	bls.n	80095de <RTC_EnterInitMode+0x22>
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80095f8:	2503      	movs	r5, #3
 80095fa:	f884 5021 	strb.w	r5, [r4, #33]	; 0x21
 80095fe:	e7ee      	b.n	80095de <RTC_EnterInitMode+0x22>

08009600 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8009600:	b510      	push	{r4, lr}
 8009602:	4604      	mov	r4, r0
  /* Exit Initialization mode */
#if defined(STM32L412xx) || defined(STM32L422xx) || defined(STM32L4P5xx) || defined(STM32L4Q5xx)
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
#else
  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ISR, RTC_ISR_INIT);
 8009604:	4b10      	ldr	r3, [pc, #64]	; (8009648 <RTC_ExitInitMode+0x48>)
 8009606:	68da      	ldr	r2, [r3, #12]
 8009608:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800960c:	60da      	str	r2, [r3, #12]
#endif

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 800960e:	689b      	ldr	r3, [r3, #8]
 8009610:	f013 0f20 	tst.w	r3, #32
 8009614:	d106      	bne.n	8009624 <RTC_ExitInitMode+0x24>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8009616:	f7ff ffb8 	bl	800958a <HAL_RTC_WaitForSynchro>
 800961a:	b198      	cbz	r0, 8009644 <RTC_ExitInitMode+0x44>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 800961c:	2003      	movs	r0, #3
 800961e:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      status = HAL_TIMEOUT;
 8009622:	e00f      	b.n	8009644 <RTC_ExitInitMode+0x44>
    }
  }
  else /* WA 2.9.6 Calendar initialization may fail in case of consecutive INIT mode entry */
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8009624:	4a08      	ldr	r2, [pc, #32]	; (8009648 <RTC_ExitInitMode+0x48>)
 8009626:	6893      	ldr	r3, [r2, #8]
 8009628:	f023 0320 	bic.w	r3, r3, #32
 800962c:	6093      	str	r3, [r2, #8]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800962e:	f7ff ffac 	bl	800958a <HAL_RTC_WaitForSynchro>
 8009632:	b110      	cbz	r0, 800963a <RTC_ExitInitMode+0x3a>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8009634:	2003      	movs	r0, #3
 8009636:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      status = HAL_TIMEOUT;
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 800963a:	4a03      	ldr	r2, [pc, #12]	; (8009648 <RTC_ExitInitMode+0x48>)
 800963c:	6893      	ldr	r3, [r2, #8]
 800963e:	f043 0320 	orr.w	r3, r3, #32
 8009642:	6093      	str	r3, [r2, #8]
  }

  return status;
}
 8009644:	bd10      	pop	{r4, pc}
 8009646:	bf00      	nop
 8009648:	40002800 	.word	0x40002800

0800964c <HAL_RTC_Init>:
  if (hrtc != NULL)
 800964c:	2800      	cmp	r0, #0
 800964e:	d048      	beq.n	80096e2 <HAL_RTC_Init+0x96>
{
 8009650:	b538      	push	{r3, r4, r5, lr}
 8009652:	4604      	mov	r4, r0
    if (hrtc->State == HAL_RTC_STATE_RESET)
 8009654:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8009658:	b16b      	cbz	r3, 8009676 <HAL_RTC_Init+0x2a>
    hrtc->State = HAL_RTC_STATE_BUSY;
 800965a:	2302      	movs	r3, #2
 800965c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8009660:	6823      	ldr	r3, [r4, #0]
 8009662:	22ca      	movs	r2, #202	; 0xca
 8009664:	625a      	str	r2, [r3, #36]	; 0x24
 8009666:	6823      	ldr	r3, [r4, #0]
 8009668:	2253      	movs	r2, #83	; 0x53
 800966a:	625a      	str	r2, [r3, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 800966c:	4620      	mov	r0, r4
 800966e:	f7ff ffa5 	bl	80095bc <RTC_EnterInitMode>
    if (status == HAL_OK)
 8009672:	b128      	cbz	r0, 8009680 <HAL_RTC_Init+0x34>
}
 8009674:	bd38      	pop	{r3, r4, r5, pc}
      hrtc->Lock = HAL_UNLOCKED;
 8009676:	f880 3020 	strb.w	r3, [r0, #32]
      HAL_RTC_MspInit(hrtc);
 800967a:	f7f7 ff2b 	bl	80014d4 <HAL_RTC_MspInit>
 800967e:	e7ec      	b.n	800965a <HAL_RTC_Init+0xe>
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 8009680:	6822      	ldr	r2, [r4, #0]
 8009682:	6893      	ldr	r3, [r2, #8]
 8009684:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 8009688:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800968c:	6093      	str	r3, [r2, #8]
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 800968e:	6821      	ldr	r1, [r4, #0]
 8009690:	688a      	ldr	r2, [r1, #8]
 8009692:	6863      	ldr	r3, [r4, #4]
 8009694:	6920      	ldr	r0, [r4, #16]
 8009696:	4303      	orrs	r3, r0
 8009698:	69a0      	ldr	r0, [r4, #24]
 800969a:	4303      	orrs	r3, r0
 800969c:	4313      	orrs	r3, r2
 800969e:	608b      	str	r3, [r1, #8]
      hrtc->Instance->PRER = (hrtc->Init.SynchPrediv);
 80096a0:	6823      	ldr	r3, [r4, #0]
 80096a2:	68e2      	ldr	r2, [r4, #12]
 80096a4:	611a      	str	r2, [r3, #16]
      hrtc->Instance->PRER |= (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos);
 80096a6:	6822      	ldr	r2, [r4, #0]
 80096a8:	6913      	ldr	r3, [r2, #16]
 80096aa:	68a1      	ldr	r1, [r4, #8]
 80096ac:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80096b0:	6113      	str	r3, [r2, #16]
      status = RTC_ExitInitMode(hrtc);
 80096b2:	4620      	mov	r0, r4
 80096b4:	f7ff ffa4 	bl	8009600 <RTC_ExitInitMode>
      if (status == HAL_OK)
 80096b8:	2800      	cmp	r0, #0
 80096ba:	d1db      	bne.n	8009674 <HAL_RTC_Init+0x28>
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 80096bc:	6822      	ldr	r2, [r4, #0]
 80096be:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80096c0:	f023 0303 	bic.w	r3, r3, #3
 80096c4:	64d3      	str	r3, [r2, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 80096c6:	6821      	ldr	r1, [r4, #0]
 80096c8:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
 80096ca:	69e2      	ldr	r2, [r4, #28]
 80096cc:	6965      	ldr	r5, [r4, #20]
 80096ce:	432a      	orrs	r2, r5
 80096d0:	4313      	orrs	r3, r2
 80096d2:	64cb      	str	r3, [r1, #76]	; 0x4c
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80096d4:	6823      	ldr	r3, [r4, #0]
 80096d6:	22ff      	movs	r2, #255	; 0xff
 80096d8:	625a      	str	r2, [r3, #36]	; 0x24
          hrtc->State = HAL_RTC_STATE_READY;
 80096da:	2301      	movs	r3, #1
 80096dc:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 80096e0:	e7c8      	b.n	8009674 <HAL_RTC_Init+0x28>
  HAL_StatusTypeDef status = HAL_ERROR;
 80096e2:	2001      	movs	r0, #1
}
 80096e4:	4770      	bx	lr

080096e6 <HAL_SPI_Init>:
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  uint32_t frxth;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80096e6:	2800      	cmp	r0, #0
 80096e8:	d06a      	beq.n	80097c0 <HAL_SPI_Init+0xda>
{
 80096ea:	b510      	push	{r4, lr}
 80096ec:	4604      	mov	r4, r0
  assert_param(IS_SPI_NSS(hspi->Init.NSS));
  assert_param(IS_SPI_NSSP(hspi->Init.NSSPMode));
  assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(hspi->Init.FirstBit));
  assert_param(IS_SPI_TIMODE(hspi->Init.TIMode));
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80096ee:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80096f0:	b933      	cbnz	r3, 8009700 <HAL_SPI_Init+0x1a>
  {
    assert_param(IS_SPI_CPOL(hspi->Init.CLKPolarity));
    assert_param(IS_SPI_CPHA(hspi->Init.CLKPhase));

    if (hspi->Init.Mode == SPI_MODE_MASTER)
 80096f2:	6843      	ldr	r3, [r0, #4]
 80096f4:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 80096f8:	d005      	beq.n	8009706 <HAL_SPI_Init+0x20>
      assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));
    }
    else
    {
      /* Baudrate prescaler not use in Motoraola Slave mode. force to default value */
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 80096fa:	2300      	movs	r3, #0
 80096fc:	61c3      	str	r3, [r0, #28]
 80096fe:	e002      	b.n	8009706 <HAL_SPI_Init+0x20>
  else
  {
    assert_param(IS_SPI_BAUDRATE_PRESCALER(hspi->Init.BaudRatePrescaler));

    /* Force polarity and phase to TI protocaol requirements */
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 8009700:	2300      	movs	r3, #0
 8009702:	6103      	str	r3, [r0, #16]
    hspi->Init.CLKPhase    = SPI_PHASE_1EDGE;
 8009704:	6143      	str	r3, [r0, #20]
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_LENGTH(hspi->Init.CRCLength));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009706:	2300      	movs	r3, #0
 8009708:	62a3      	str	r3, [r4, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800970a:	f894 305d 	ldrb.w	r3, [r4, #93]	; 0x5d
 800970e:	2b00      	cmp	r3, #0
 8009710:	d04d      	beq.n	80097ae <HAL_SPI_Init+0xc8>
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8009712:	2302      	movs	r3, #2
 8009714:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8009718:	6822      	ldr	r2, [r4, #0]
 800971a:	6813      	ldr	r3, [r2, #0]
 800971c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009720:	6013      	str	r3, [r2, #0]

  /* Align by default the rs fifo threshold on the data size */
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8009722:	68e3      	ldr	r3, [r4, #12]
 8009724:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009728:	d947      	bls.n	80097ba <HAL_SPI_Init+0xd4>
  {
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800972a:	2200      	movs	r2, #0
  {
    frxth = SPI_RXFIFO_THRESHOLD_QF;
  }

  /* CRC calculation is valid only for 16Bit and 8 Bit */
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 800972c:	f5b3 6f70 	cmp.w	r3, #3840	; 0xf00
 8009730:	d004      	beq.n	800973c <HAL_SPI_Init+0x56>
 8009732:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 8009736:	d001      	beq.n	800973c <HAL_SPI_Init+0x56>
  {
    /* CRC must be disabled */
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8009738:	2300      	movs	r3, #0
 800973a:	62a3      	str	r3, [r4, #40]	; 0x28
  }

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800973c:	6863      	ldr	r3, [r4, #4]
 800973e:	f403 7382 	and.w	r3, r3, #260	; 0x104
 8009742:	68a1      	ldr	r1, [r4, #8]
 8009744:	f401 4104 	and.w	r1, r1, #33792	; 0x8400
 8009748:	430b      	orrs	r3, r1
 800974a:	6921      	ldr	r1, [r4, #16]
 800974c:	f001 0102 	and.w	r1, r1, #2
 8009750:	430b      	orrs	r3, r1
 8009752:	6961      	ldr	r1, [r4, #20]
 8009754:	f001 0101 	and.w	r1, r1, #1
 8009758:	430b      	orrs	r3, r1
 800975a:	69a1      	ldr	r1, [r4, #24]
 800975c:	f401 7100 	and.w	r1, r1, #512	; 0x200
 8009760:	430b      	orrs	r3, r1
 8009762:	69e1      	ldr	r1, [r4, #28]
 8009764:	f001 0138 	and.w	r1, r1, #56	; 0x38
 8009768:	430b      	orrs	r3, r1
 800976a:	6a21      	ldr	r1, [r4, #32]
 800976c:	f001 0180 	and.w	r1, r1, #128	; 0x80
 8009770:	430b      	orrs	r3, r1
 8009772:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8009774:	f401 5100 	and.w	r1, r1, #8192	; 0x2000
 8009778:	6820      	ldr	r0, [r4, #0]
 800977a:	430b      	orrs	r3, r1
 800977c:	6003      	str	r3, [r0, #0]
    }
  }
#endif /* USE_SPI_CRC */

  /* Configure : NSS management, TI Mode, NSS Pulse, Data size and Rx Fifo threshold */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800977e:	8b63      	ldrh	r3, [r4, #26]
 8009780:	f003 0304 	and.w	r3, r3, #4
 8009784:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8009786:	f001 0110 	and.w	r1, r1, #16
 800978a:	430b      	orrs	r3, r1
 800978c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800978e:	f001 0108 	and.w	r1, r1, #8
 8009792:	430b      	orrs	r3, r1
 8009794:	68e1      	ldr	r1, [r4, #12]
 8009796:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
 800979a:	430b      	orrs	r3, r1
 800979c:	6821      	ldr	r1, [r4, #0]
 800979e:	431a      	orrs	r2, r3
 80097a0:	604a      	str	r2, [r1, #4]
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* SPI_I2SCFGR_I2SMOD */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80097a2:	2000      	movs	r0, #0
 80097a4:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 80097a6:	2301      	movs	r3, #1
 80097a8:	f884 305d 	strb.w	r3, [r4, #93]	; 0x5d

  return HAL_OK;
}
 80097ac:	bd10      	pop	{r4, pc}
    hspi->Lock = HAL_UNLOCKED;
 80097ae:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
    HAL_SPI_MspInit(hspi);
 80097b2:	4620      	mov	r0, r4
 80097b4:	f7f7 feec 	bl	8001590 <HAL_SPI_MspInit>
 80097b8:	e7ab      	b.n	8009712 <HAL_SPI_Init+0x2c>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80097ba:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80097be:	e7b5      	b.n	800972c <HAL_SPI_Init+0x46>
    return HAL_ERROR;
 80097c0:	2001      	movs	r0, #1
}
 80097c2:	4770      	bx	lr

080097c4 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80097c4:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 80097c6:	6a03      	ldr	r3, [r0, #32]
 80097c8:	f023 0301 	bic.w	r3, r3, #1
 80097cc:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80097ce:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80097d0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 80097d2:	6983      	ldr	r3, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 80097d4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80097d8:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80097dc:	680d      	ldr	r5, [r1, #0]
 80097de:	431d      	orrs	r5, r3

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 80097e0:	f022 0202 	bic.w	r2, r2, #2
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80097e4:	688b      	ldr	r3, [r1, #8]
 80097e6:	4313      	orrs	r3, r2

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80097e8:	4a14      	ldr	r2, [pc, #80]	; (800983c <TIM_OC1_SetConfig+0x78>)
 80097ea:	4290      	cmp	r0, r2
 80097ec:	d007      	beq.n	80097fe <TIM_OC1_SetConfig+0x3a>
 80097ee:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 80097f2:	4290      	cmp	r0, r2
 80097f4:	d003      	beq.n	80097fe <TIM_OC1_SetConfig+0x3a>
 80097f6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80097fa:	4290      	cmp	r0, r2
 80097fc:	d105      	bne.n	800980a <TIM_OC1_SetConfig+0x46>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80097fe:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8009802:	68ca      	ldr	r2, [r1, #12]
 8009804:	431a      	orrs	r2, r3
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8009806:	f022 0304 	bic.w	r3, r2, #4
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800980a:	4a0c      	ldr	r2, [pc, #48]	; (800983c <TIM_OC1_SetConfig+0x78>)
 800980c:	4290      	cmp	r0, r2
 800980e:	d007      	beq.n	8009820 <TIM_OC1_SetConfig+0x5c>
 8009810:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 8009814:	4290      	cmp	r0, r2
 8009816:	d003      	beq.n	8009820 <TIM_OC1_SetConfig+0x5c>
 8009818:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800981c:	4290      	cmp	r0, r2
 800981e:	d105      	bne.n	800982c <TIM_OC1_SetConfig+0x68>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8009820:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8009824:	694a      	ldr	r2, [r1, #20]
 8009826:	4322      	orrs	r2, r4
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8009828:	698c      	ldr	r4, [r1, #24]
 800982a:	4314      	orrs	r4, r2
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800982c:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800982e:	6185      	str	r5, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8009830:	684a      	ldr	r2, [r1, #4]
 8009832:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009834:	6203      	str	r3, [r0, #32]
}
 8009836:	bc30      	pop	{r4, r5}
 8009838:	4770      	bx	lr
 800983a:	bf00      	nop
 800983c:	40012c00 	.word	0x40012c00

08009840 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8009840:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8009842:	6a03      	ldr	r3, [r0, #32]
 8009844:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8009848:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800984a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800984c:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 800984e:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8009850:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009854:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8009858:	680d      	ldr	r5, [r1, #0]
 800985a:	4315      	orrs	r5, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 800985c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8009860:	688a      	ldr	r2, [r1, #8]
 8009862:	ea43 2302 	orr.w	r3, r3, r2, lsl #8

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8009866:	4a12      	ldr	r2, [pc, #72]	; (80098b0 <TIM_OC3_SetConfig+0x70>)
 8009868:	4290      	cmp	r0, r2
 800986a:	d019      	beq.n	80098a0 <TIM_OC3_SetConfig+0x60>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800986c:	4a10      	ldr	r2, [pc, #64]	; (80098b0 <TIM_OC3_SetConfig+0x70>)
 800986e:	4290      	cmp	r0, r2
 8009870:	d007      	beq.n	8009882 <TIM_OC3_SetConfig+0x42>
 8009872:	f502 52a0 	add.w	r2, r2, #5120	; 0x1400
 8009876:	4290      	cmp	r0, r2
 8009878:	d003      	beq.n	8009882 <TIM_OC3_SetConfig+0x42>
 800987a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800987e:	4290      	cmp	r0, r2
 8009880:	d107      	bne.n	8009892 <TIM_OC3_SetConfig+0x52>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8009882:	f424 5440 	bic.w	r4, r4, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8009886:	694a      	ldr	r2, [r1, #20]
 8009888:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800988c:	698a      	ldr	r2, [r1, #24]
 800988e:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009892:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8009894:	61c5      	str	r5, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8009896:	684a      	ldr	r2, [r1, #4]
 8009898:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800989a:	6203      	str	r3, [r0, #32]
}
 800989c:	bc30      	pop	{r4, r5}
 800989e:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC3NP;
 80098a0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 80098a4:	68ca      	ldr	r2, [r1, #12]
 80098a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 80098aa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80098ae:	e7dd      	b.n	800986c <TIM_OC3_SetConfig+0x2c>
 80098b0:	40012c00 	.word	0x40012c00

080098b4 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 80098b4:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 80098b6:	6a03      	ldr	r3, [r0, #32]
 80098b8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80098bc:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80098be:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80098c0:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80098c2:	69c3      	ldr	r3, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80098c4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80098c8:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80098cc:	680d      	ldr	r5, [r1, #0]
 80098ce:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 80098d2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80098d6:	688d      	ldr	r5, [r1, #8]
 80098d8:	ea42 3205 	orr.w	r2, r2, r5, lsl #12

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80098dc:	4d0b      	ldr	r5, [pc, #44]	; (800990c <TIM_OC4_SetConfig+0x58>)
 80098de:	42a8      	cmp	r0, r5
 80098e0:	d007      	beq.n	80098f2 <TIM_OC4_SetConfig+0x3e>
 80098e2:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 80098e6:	42a8      	cmp	r0, r5
 80098e8:	d003      	beq.n	80098f2 <TIM_OC4_SetConfig+0x3e>
 80098ea:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80098ee:	42a8      	cmp	r0, r5
 80098f0:	d104      	bne.n	80098fc <TIM_OC4_SetConfig+0x48>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 80098f2:	f424 4480 	bic.w	r4, r4, #16384	; 0x4000

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 80098f6:	694d      	ldr	r5, [r1, #20]
 80098f8:	ea44 1485 	orr.w	r4, r4, r5, lsl #6
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80098fc:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80098fe:	61c3      	str	r3, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8009900:	684b      	ldr	r3, [r1, #4]
 8009902:	6403      	str	r3, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8009904:	6202      	str	r2, [r0, #32]
}
 8009906:	bc30      	pop	{r4, r5}
 8009908:	4770      	bx	lr
 800990a:	bf00      	nop
 800990c:	40012c00 	.word	0x40012c00

08009910 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8009910:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8009912:	6a03      	ldr	r3, [r0, #32]
 8009914:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8009918:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800991a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800991c:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800991e:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8009920:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8009924:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8009928:	680d      	ldr	r5, [r1, #0]
 800992a:	432a      	orrs	r2, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800992c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8009930:	688d      	ldr	r5, [r1, #8]
 8009932:	ea43 4305 	orr.w	r3, r3, r5, lsl #16

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8009936:	4d0b      	ldr	r5, [pc, #44]	; (8009964 <TIM_OC5_SetConfig+0x54>)
 8009938:	42a8      	cmp	r0, r5
 800993a:	d007      	beq.n	800994c <TIM_OC5_SetConfig+0x3c>
 800993c:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8009940:	42a8      	cmp	r0, r5
 8009942:	d003      	beq.n	800994c <TIM_OC5_SetConfig+0x3c>
 8009944:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8009948:	42a8      	cmp	r0, r5
 800994a:	d104      	bne.n	8009956 <TIM_OC5_SetConfig+0x46>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 800994c:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8009950:	694d      	ldr	r5, [r1, #20]
 8009952:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8009956:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8009958:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800995a:	684a      	ldr	r2, [r1, #4]
 800995c:	6582      	str	r2, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800995e:	6203      	str	r3, [r0, #32]
}
 8009960:	bc30      	pop	{r4, r5}
 8009962:	4770      	bx	lr
 8009964:	40012c00 	.word	0x40012c00

08009968 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8009968:	b430      	push	{r4, r5}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800996a:	6a03      	ldr	r3, [r0, #32]
 800996c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8009970:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8009972:	6a02      	ldr	r2, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8009974:	6844      	ldr	r4, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8009976:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8009978:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800997c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8009980:	680d      	ldr	r5, [r1, #0]
 8009982:	ea43 2305 	orr.w	r3, r3, r5, lsl #8

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8009986:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800998a:	688d      	ldr	r5, [r1, #8]
 800998c:	ea42 5205 	orr.w	r2, r2, r5, lsl #20

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8009990:	4d0b      	ldr	r5, [pc, #44]	; (80099c0 <TIM_OC6_SetConfig+0x58>)
 8009992:	42a8      	cmp	r0, r5
 8009994:	d007      	beq.n	80099a6 <TIM_OC6_SetConfig+0x3e>
 8009996:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 800999a:	42a8      	cmp	r0, r5
 800999c:	d003      	beq.n	80099a6 <TIM_OC6_SetConfig+0x3e>
 800999e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 80099a2:	42a8      	cmp	r0, r5
 80099a4:	d104      	bne.n	80099b0 <TIM_OC6_SetConfig+0x48>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 80099a6:	f424 2480 	bic.w	r4, r4, #262144	; 0x40000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 80099aa:	694d      	ldr	r5, [r1, #20]
 80099ac:	ea44 2485 	orr.w	r4, r4, r5, lsl #10
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80099b0:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 80099b2:	6543      	str	r3, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 80099b4:	684b      	ldr	r3, [r1, #4]
 80099b6:	65c3      	str	r3, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80099b8:	6202      	str	r2, [r0, #32]
}
 80099ba:	bc30      	pop	{r4, r5}
 80099bc:	4770      	bx	lr
 80099be:	bf00      	nop
 80099c0:	40012c00 	.word	0x40012c00

080099c4 <HAL_TIM_Base_MspInit>:
}
 80099c4:	4770      	bx	lr
	...

080099c8 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 80099c8:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80099cc:	b2db      	uxtb	r3, r3
 80099ce:	2b01      	cmp	r3, #1
 80099d0:	d12a      	bne.n	8009a28 <HAL_TIM_Base_Start_IT+0x60>
  htim->State = HAL_TIM_STATE_BUSY;
 80099d2:	2302      	movs	r3, #2
 80099d4:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80099d8:	6802      	ldr	r2, [r0, #0]
 80099da:	68d3      	ldr	r3, [r2, #12]
 80099dc:	f043 0301 	orr.w	r3, r3, #1
 80099e0:	60d3      	str	r3, [r2, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80099e2:	6803      	ldr	r3, [r0, #0]
 80099e4:	4a13      	ldr	r2, [pc, #76]	; (8009a34 <HAL_TIM_Base_Start_IT+0x6c>)
 80099e6:	4293      	cmp	r3, r2
 80099e8:	d010      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
 80099ea:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80099ee:	d00d      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
 80099f0:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 80099f4:	4293      	cmp	r3, r2
 80099f6:	d009      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
 80099f8:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 80099fc:	4293      	cmp	r3, r2
 80099fe:	d005      	beq.n	8009a0c <HAL_TIM_Base_Start_IT+0x44>
    __HAL_TIM_ENABLE(htim);
 8009a00:	681a      	ldr	r2, [r3, #0]
 8009a02:	f042 0201 	orr.w	r2, r2, #1
 8009a06:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8009a08:	2000      	movs	r0, #0
 8009a0a:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8009a0c:	6899      	ldr	r1, [r3, #8]
 8009a0e:	4a0a      	ldr	r2, [pc, #40]	; (8009a38 <HAL_TIM_Base_Start_IT+0x70>)
 8009a10:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8009a12:	2a06      	cmp	r2, #6
 8009a14:	d00a      	beq.n	8009a2c <HAL_TIM_Base_Start_IT+0x64>
 8009a16:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8009a1a:	d009      	beq.n	8009a30 <HAL_TIM_Base_Start_IT+0x68>
      __HAL_TIM_ENABLE(htim);
 8009a1c:	681a      	ldr	r2, [r3, #0]
 8009a1e:	f042 0201 	orr.w	r2, r2, #1
 8009a22:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8009a24:	2000      	movs	r0, #0
 8009a26:	4770      	bx	lr
    return HAL_ERROR;
 8009a28:	2001      	movs	r0, #1
 8009a2a:	4770      	bx	lr
  return HAL_OK;
 8009a2c:	2000      	movs	r0, #0
 8009a2e:	4770      	bx	lr
 8009a30:	2000      	movs	r0, #0
}
 8009a32:	4770      	bx	lr
 8009a34:	40012c00 	.word	0x40012c00
 8009a38:	00010007 	.word	0x00010007

08009a3c <HAL_TIM_OC_DelayElapsedCallback>:
}
 8009a3c:	4770      	bx	lr

08009a3e <HAL_TIM_IC_CaptureCallback>:
}
 8009a3e:	4770      	bx	lr

08009a40 <HAL_TIM_PWM_PulseFinishedCallback>:
}
 8009a40:	4770      	bx	lr

08009a42 <HAL_TIM_TriggerCallback>:
}
 8009a42:	4770      	bx	lr

08009a44 <HAL_TIM_IRQHandler>:
{
 8009a44:	b510      	push	{r4, lr}
 8009a46:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8009a48:	6803      	ldr	r3, [r0, #0]
 8009a4a:	691a      	ldr	r2, [r3, #16]
 8009a4c:	f012 0f02 	tst.w	r2, #2
 8009a50:	d011      	beq.n	8009a76 <HAL_TIM_IRQHandler+0x32>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8009a52:	68da      	ldr	r2, [r3, #12]
 8009a54:	f012 0f02 	tst.w	r2, #2
 8009a58:	d00d      	beq.n	8009a76 <HAL_TIM_IRQHandler+0x32>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8009a5a:	f06f 0202 	mvn.w	r2, #2
 8009a5e:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8009a60:	2301      	movs	r3, #1
 8009a62:	7703      	strb	r3, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8009a64:	6803      	ldr	r3, [r0, #0]
 8009a66:	699b      	ldr	r3, [r3, #24]
 8009a68:	f013 0f03 	tst.w	r3, #3
 8009a6c:	d079      	beq.n	8009b62 <HAL_TIM_IRQHandler+0x11e>
          HAL_TIM_IC_CaptureCallback(htim);
 8009a6e:	f7ff ffe6 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009a72:	2300      	movs	r3, #0
 8009a74:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8009a76:	6823      	ldr	r3, [r4, #0]
 8009a78:	691a      	ldr	r2, [r3, #16]
 8009a7a:	f012 0f04 	tst.w	r2, #4
 8009a7e:	d012      	beq.n	8009aa6 <HAL_TIM_IRQHandler+0x62>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8009a80:	68da      	ldr	r2, [r3, #12]
 8009a82:	f012 0f04 	tst.w	r2, #4
 8009a86:	d00e      	beq.n	8009aa6 <HAL_TIM_IRQHandler+0x62>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8009a88:	f06f 0204 	mvn.w	r2, #4
 8009a8c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8009a8e:	2302      	movs	r3, #2
 8009a90:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8009a92:	6823      	ldr	r3, [r4, #0]
 8009a94:	699b      	ldr	r3, [r3, #24]
 8009a96:	f413 7f40 	tst.w	r3, #768	; 0x300
 8009a9a:	d068      	beq.n	8009b6e <HAL_TIM_IRQHandler+0x12a>
        HAL_TIM_IC_CaptureCallback(htim);
 8009a9c:	4620      	mov	r0, r4
 8009a9e:	f7ff ffce 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009aa2:	2300      	movs	r3, #0
 8009aa4:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8009aa6:	6823      	ldr	r3, [r4, #0]
 8009aa8:	691a      	ldr	r2, [r3, #16]
 8009aaa:	f012 0f08 	tst.w	r2, #8
 8009aae:	d012      	beq.n	8009ad6 <HAL_TIM_IRQHandler+0x92>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8009ab0:	68da      	ldr	r2, [r3, #12]
 8009ab2:	f012 0f08 	tst.w	r2, #8
 8009ab6:	d00e      	beq.n	8009ad6 <HAL_TIM_IRQHandler+0x92>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8009ab8:	f06f 0208 	mvn.w	r2, #8
 8009abc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8009abe:	2304      	movs	r3, #4
 8009ac0:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8009ac2:	6823      	ldr	r3, [r4, #0]
 8009ac4:	69db      	ldr	r3, [r3, #28]
 8009ac6:	f013 0f03 	tst.w	r3, #3
 8009aca:	d057      	beq.n	8009b7c <HAL_TIM_IRQHandler+0x138>
        HAL_TIM_IC_CaptureCallback(htim);
 8009acc:	4620      	mov	r0, r4
 8009ace:	f7ff ffb6 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009ad2:	2300      	movs	r3, #0
 8009ad4:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8009ad6:	6823      	ldr	r3, [r4, #0]
 8009ad8:	691a      	ldr	r2, [r3, #16]
 8009ada:	f012 0f10 	tst.w	r2, #16
 8009ade:	d012      	beq.n	8009b06 <HAL_TIM_IRQHandler+0xc2>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8009ae0:	68da      	ldr	r2, [r3, #12]
 8009ae2:	f012 0f10 	tst.w	r2, #16
 8009ae6:	d00e      	beq.n	8009b06 <HAL_TIM_IRQHandler+0xc2>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8009ae8:	f06f 0210 	mvn.w	r2, #16
 8009aec:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8009aee:	2308      	movs	r3, #8
 8009af0:	7723      	strb	r3, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8009af2:	6823      	ldr	r3, [r4, #0]
 8009af4:	69db      	ldr	r3, [r3, #28]
 8009af6:	f413 7f40 	tst.w	r3, #768	; 0x300
 8009afa:	d046      	beq.n	8009b8a <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8009afc:	4620      	mov	r0, r4
 8009afe:	f7ff ff9e 	bl	8009a3e <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8009b02:	2300      	movs	r3, #0
 8009b04:	7723      	strb	r3, [r4, #28]
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8009b06:	6823      	ldr	r3, [r4, #0]
 8009b08:	691a      	ldr	r2, [r3, #16]
 8009b0a:	f012 0f01 	tst.w	r2, #1
 8009b0e:	d003      	beq.n	8009b18 <HAL_TIM_IRQHandler+0xd4>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8009b10:	68da      	ldr	r2, [r3, #12]
 8009b12:	f012 0f01 	tst.w	r2, #1
 8009b16:	d13f      	bne.n	8009b98 <HAL_TIM_IRQHandler+0x154>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8009b18:	6823      	ldr	r3, [r4, #0]
 8009b1a:	691a      	ldr	r2, [r3, #16]
 8009b1c:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b20:	d003      	beq.n	8009b2a <HAL_TIM_IRQHandler+0xe6>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8009b22:	68da      	ldr	r2, [r3, #12]
 8009b24:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b28:	d13d      	bne.n	8009ba6 <HAL_TIM_IRQHandler+0x162>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8009b2a:	6823      	ldr	r3, [r4, #0]
 8009b2c:	691a      	ldr	r2, [r3, #16]
 8009b2e:	f412 7f80 	tst.w	r2, #256	; 0x100
 8009b32:	d003      	beq.n	8009b3c <HAL_TIM_IRQHandler+0xf8>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8009b34:	68da      	ldr	r2, [r3, #12]
 8009b36:	f012 0f80 	tst.w	r2, #128	; 0x80
 8009b3a:	d13b      	bne.n	8009bb4 <HAL_TIM_IRQHandler+0x170>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8009b3c:	6823      	ldr	r3, [r4, #0]
 8009b3e:	691a      	ldr	r2, [r3, #16]
 8009b40:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009b44:	d003      	beq.n	8009b4e <HAL_TIM_IRQHandler+0x10a>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8009b46:	68da      	ldr	r2, [r3, #12]
 8009b48:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009b4c:	d139      	bne.n	8009bc2 <HAL_TIM_IRQHandler+0x17e>
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8009b4e:	6823      	ldr	r3, [r4, #0]
 8009b50:	691a      	ldr	r2, [r3, #16]
 8009b52:	f012 0f20 	tst.w	r2, #32
 8009b56:	d003      	beq.n	8009b60 <HAL_TIM_IRQHandler+0x11c>
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8009b58:	68da      	ldr	r2, [r3, #12]
 8009b5a:	f012 0f20 	tst.w	r2, #32
 8009b5e:	d137      	bne.n	8009bd0 <HAL_TIM_IRQHandler+0x18c>
}
 8009b60:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b62:	f7ff ff6b 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b66:	4620      	mov	r0, r4
 8009b68:	f7ff ff6a 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b6c:	e781      	b.n	8009a72 <HAL_TIM_IRQHandler+0x2e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b6e:	4620      	mov	r0, r4
 8009b70:	f7ff ff64 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b74:	4620      	mov	r0, r4
 8009b76:	f7ff ff63 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b7a:	e792      	b.n	8009aa2 <HAL_TIM_IRQHandler+0x5e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b7c:	4620      	mov	r0, r4
 8009b7e:	f7ff ff5d 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b82:	4620      	mov	r0, r4
 8009b84:	f7ff ff5c 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b88:	e7a3      	b.n	8009ad2 <HAL_TIM_IRQHandler+0x8e>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8009b8a:	4620      	mov	r0, r4
 8009b8c:	f7ff ff56 	bl	8009a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8009b90:	4620      	mov	r0, r4
 8009b92:	f7ff ff55 	bl	8009a40 <HAL_TIM_PWM_PulseFinishedCallback>
 8009b96:	e7b4      	b.n	8009b02 <HAL_TIM_IRQHandler+0xbe>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8009b98:	f06f 0201 	mvn.w	r2, #1
 8009b9c:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8009b9e:	4620      	mov	r0, r4
 8009ba0:	f7f7 fb3e 	bl	8001220 <HAL_TIM_PeriodElapsedCallback>
 8009ba4:	e7b8      	b.n	8009b18 <HAL_TIM_IRQHandler+0xd4>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8009ba6:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8009baa:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8009bac:	4620      	mov	r0, r4
 8009bae:	f000 f9c4 	bl	8009f3a <HAL_TIMEx_BreakCallback>
 8009bb2:	e7ba      	b.n	8009b2a <HAL_TIM_IRQHandler+0xe6>
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8009bb4:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8009bb8:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8009bba:	4620      	mov	r0, r4
 8009bbc:	f000 f9be 	bl	8009f3c <HAL_TIMEx_Break2Callback>
 8009bc0:	e7bc      	b.n	8009b3c <HAL_TIM_IRQHandler+0xf8>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8009bc2:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8009bc6:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8009bc8:	4620      	mov	r0, r4
 8009bca:	f7ff ff3a 	bl	8009a42 <HAL_TIM_TriggerCallback>
 8009bce:	e7be      	b.n	8009b4e <HAL_TIM_IRQHandler+0x10a>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8009bd0:	f06f 0220 	mvn.w	r2, #32
 8009bd4:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8009bd6:	4620      	mov	r0, r4
 8009bd8:	f000 f9ae 	bl	8009f38 <HAL_TIMEx_CommutCallback>
}
 8009bdc:	e7c0      	b.n	8009b60 <HAL_TIM_IRQHandler+0x11c>
	...

08009be0 <TIM_Base_SetConfig>:
  tmpcr1 = TIMx->CR1;
 8009be0:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8009be2:	4a1e      	ldr	r2, [pc, #120]	; (8009c5c <TIM_Base_SetConfig+0x7c>)
 8009be4:	4290      	cmp	r0, r2
 8009be6:	d006      	beq.n	8009bf6 <TIM_Base_SetConfig+0x16>
 8009be8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8009bec:	d003      	beq.n	8009bf6 <TIM_Base_SetConfig+0x16>
 8009bee:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8009bf2:	4290      	cmp	r0, r2
 8009bf4:	d103      	bne.n	8009bfe <TIM_Base_SetConfig+0x1e>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8009bf6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8009bfa:	684a      	ldr	r2, [r1, #4]
 8009bfc:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8009bfe:	4a17      	ldr	r2, [pc, #92]	; (8009c5c <TIM_Base_SetConfig+0x7c>)
 8009c00:	4290      	cmp	r0, r2
 8009c02:	d00e      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c04:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8009c08:	d00b      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c0a:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8009c0e:	4290      	cmp	r0, r2
 8009c10:	d007      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c12:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 8009c16:	4290      	cmp	r0, r2
 8009c18:	d003      	beq.n	8009c22 <TIM_Base_SetConfig+0x42>
 8009c1a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8009c1e:	4290      	cmp	r0, r2
 8009c20:	d103      	bne.n	8009c2a <TIM_Base_SetConfig+0x4a>
    tmpcr1 &= ~TIM_CR1_CKD;
 8009c22:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8009c26:	68ca      	ldr	r2, [r1, #12]
 8009c28:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8009c2a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009c2e:	694a      	ldr	r2, [r1, #20]
 8009c30:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8009c32:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8009c34:	688b      	ldr	r3, [r1, #8]
 8009c36:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8009c38:	680b      	ldr	r3, [r1, #0]
 8009c3a:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8009c3c:	4b07      	ldr	r3, [pc, #28]	; (8009c5c <TIM_Base_SetConfig+0x7c>)
 8009c3e:	4298      	cmp	r0, r3
 8009c40:	d007      	beq.n	8009c52 <TIM_Base_SetConfig+0x72>
 8009c42:	f503 53a0 	add.w	r3, r3, #5120	; 0x1400
 8009c46:	4298      	cmp	r0, r3
 8009c48:	d003      	beq.n	8009c52 <TIM_Base_SetConfig+0x72>
 8009c4a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009c4e:	4298      	cmp	r0, r3
 8009c50:	d101      	bne.n	8009c56 <TIM_Base_SetConfig+0x76>
    TIMx->RCR = Structure->RepetitionCounter;
 8009c52:	690b      	ldr	r3, [r1, #16]
 8009c54:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8009c56:	2301      	movs	r3, #1
 8009c58:	6143      	str	r3, [r0, #20]
}
 8009c5a:	4770      	bx	lr
 8009c5c:	40012c00 	.word	0x40012c00

08009c60 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8009c60:	b360      	cbz	r0, 8009cbc <HAL_TIM_Base_Init+0x5c>
{
 8009c62:	b510      	push	{r4, lr}
 8009c64:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8009c66:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009c6a:	b313      	cbz	r3, 8009cb2 <HAL_TIM_Base_Init+0x52>
  htim->State = HAL_TIM_STATE_BUSY;
 8009c6c:	2302      	movs	r3, #2
 8009c6e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8009c72:	4621      	mov	r1, r4
 8009c74:	f851 0b04 	ldr.w	r0, [r1], #4
 8009c78:	f7ff ffb2 	bl	8009be0 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8009c7c:	2301      	movs	r3, #1
 8009c7e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009c82:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8009c86:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8009c8a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8009c8e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8009c92:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8009c96:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009c9a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8009c9e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8009ca2:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 8009ca6:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 8009caa:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8009cae:	2000      	movs	r0, #0
}
 8009cb0:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8009cb2:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8009cb6:	f7ff fe85 	bl	80099c4 <HAL_TIM_Base_MspInit>
 8009cba:	e7d7      	b.n	8009c6c <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 8009cbc:	2001      	movs	r0, #1
}
 8009cbe:	4770      	bx	lr

08009cc0 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 8009cc0:	b360      	cbz	r0, 8009d1c <HAL_TIM_PWM_Init+0x5c>
{
 8009cc2:	b510      	push	{r4, lr}
 8009cc4:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 8009cc6:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8009cca:	b313      	cbz	r3, 8009d12 <HAL_TIM_PWM_Init+0x52>
  htim->State = HAL_TIM_STATE_BUSY;
 8009ccc:	2302      	movs	r3, #2
 8009cce:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8009cd2:	4621      	mov	r1, r4
 8009cd4:	f851 0b04 	ldr.w	r0, [r1], #4
 8009cd8:	f7ff ff82 	bl	8009be0 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8009cdc:	2301      	movs	r3, #1
 8009cde:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009ce2:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8009ce6:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8009cea:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8009cee:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
 8009cf2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8009cf6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8009cfa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8009cfe:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8009d02:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
 8009d06:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
  htim->State = HAL_TIM_STATE_READY;
 8009d0a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8009d0e:	2000      	movs	r0, #0
}
 8009d10:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8009d12:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 8009d16:	f7f7 fdbb 	bl	8001890 <HAL_TIM_PWM_MspInit>
 8009d1a:	e7d7      	b.n	8009ccc <HAL_TIM_PWM_Init+0xc>
    return HAL_ERROR;
 8009d1c:	2001      	movs	r0, #1
}
 8009d1e:	4770      	bx	lr

08009d20 <TIM_OC2_SetConfig>:
{
 8009d20:	b430      	push	{r4, r5}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8009d22:	6a03      	ldr	r3, [r0, #32]
 8009d24:	f023 0310 	bic.w	r3, r3, #16
 8009d28:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8009d2a:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8009d2c:	6844      	ldr	r4, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8009d2e:	6982      	ldr	r2, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8009d30:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009d34:	f422 42e6 	bic.w	r2, r2, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8009d38:	680d      	ldr	r5, [r1, #0]
 8009d3a:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
  tmpccer &= ~TIM_CCER_CC2P;
 8009d3e:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8009d42:	688d      	ldr	r5, [r1, #8]
 8009d44:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8009d48:	4d12      	ldr	r5, [pc, #72]	; (8009d94 <TIM_OC2_SetConfig+0x74>)
 8009d4a:	42a8      	cmp	r0, r5
 8009d4c:	d019      	beq.n	8009d82 <TIM_OC2_SetConfig+0x62>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8009d4e:	4d11      	ldr	r5, [pc, #68]	; (8009d94 <TIM_OC2_SetConfig+0x74>)
 8009d50:	42a8      	cmp	r0, r5
 8009d52:	d007      	beq.n	8009d64 <TIM_OC2_SetConfig+0x44>
 8009d54:	f505 55a0 	add.w	r5, r5, #5120	; 0x1400
 8009d58:	42a8      	cmp	r0, r5
 8009d5a:	d003      	beq.n	8009d64 <TIM_OC2_SetConfig+0x44>
 8009d5c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8009d60:	42a8      	cmp	r0, r5
 8009d62:	d107      	bne.n	8009d74 <TIM_OC2_SetConfig+0x54>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8009d64:	f424 6440 	bic.w	r4, r4, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8009d68:	694d      	ldr	r5, [r1, #20]
 8009d6a:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8009d6e:	698d      	ldr	r5, [r1, #24]
 8009d70:	ea44 0485 	orr.w	r4, r4, r5, lsl #2
  TIMx->CR2 = tmpcr2;
 8009d74:	6044      	str	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8009d76:	6182      	str	r2, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8009d78:	684a      	ldr	r2, [r1, #4]
 8009d7a:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8009d7c:	6203      	str	r3, [r0, #32]
}
 8009d7e:	bc30      	pop	{r4, r5}
 8009d80:	4770      	bx	lr
    tmpccer &= ~TIM_CCER_CC2NP;
 8009d82:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8009d86:	68cd      	ldr	r5, [r1, #12]
 8009d88:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 8009d8c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8009d90:	e7dd      	b.n	8009d4e <TIM_OC2_SetConfig+0x2e>
 8009d92:	bf00      	nop
 8009d94:	40012c00 	.word	0x40012c00

08009d98 <HAL_TIM_PWM_ConfigChannel>:
{
 8009d98:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(htim);
 8009d9a:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 8009d9e:	2b01      	cmp	r3, #1
 8009da0:	f000 808c 	beq.w	8009ebc <HAL_TIM_PWM_ConfigChannel+0x124>
 8009da4:	4604      	mov	r4, r0
 8009da6:	460d      	mov	r5, r1
 8009da8:	2301      	movs	r3, #1
 8009daa:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
  switch (Channel)
 8009dae:	2a14      	cmp	r2, #20
 8009db0:	d81e      	bhi.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
 8009db2:	e8df f002 	tbb	[pc, r2]
 8009db6:	1d0b      	.short	0x1d0b
 8009db8:	1d211d1d 	.word	0x1d211d1d
 8009dbc:	1d351d1d 	.word	0x1d351d1d
 8009dc0:	1d481d1d 	.word	0x1d481d1d
 8009dc4:	1d5c1d1d 	.word	0x1d5c1d1d
 8009dc8:	1d1d      	.short	0x1d1d
 8009dca:	6f          	.byte	0x6f
 8009dcb:	00          	.byte	0x00
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8009dcc:	6800      	ldr	r0, [r0, #0]
 8009dce:	f7ff fcf9 	bl	80097c4 <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8009dd2:	6822      	ldr	r2, [r4, #0]
 8009dd4:	6993      	ldr	r3, [r2, #24]
 8009dd6:	f043 0308 	orr.w	r3, r3, #8
 8009dda:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8009ddc:	6822      	ldr	r2, [r4, #0]
 8009dde:	6993      	ldr	r3, [r2, #24]
 8009de0:	f023 0304 	bic.w	r3, r3, #4
 8009de4:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8009de6:	6822      	ldr	r2, [r4, #0]
 8009de8:	6993      	ldr	r3, [r2, #24]
 8009dea:	6929      	ldr	r1, [r5, #16]
 8009dec:	430b      	orrs	r3, r1
 8009dee:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
 8009df0:	2000      	movs	r0, #0
 8009df2:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
}
 8009df6:	bd38      	pop	{r3, r4, r5, pc}
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8009df8:	6800      	ldr	r0, [r0, #0]
 8009dfa:	f7ff ff91 	bl	8009d20 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8009dfe:	6822      	ldr	r2, [r4, #0]
 8009e00:	6993      	ldr	r3, [r2, #24]
 8009e02:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009e06:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8009e08:	6822      	ldr	r2, [r4, #0]
 8009e0a:	6993      	ldr	r3, [r2, #24]
 8009e0c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009e10:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8009e12:	6822      	ldr	r2, [r4, #0]
 8009e14:	6993      	ldr	r3, [r2, #24]
 8009e16:	6929      	ldr	r1, [r5, #16]
 8009e18:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009e1c:	6193      	str	r3, [r2, #24]
      break;
 8009e1e:	e7e7      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8009e20:	6800      	ldr	r0, [r0, #0]
 8009e22:	f7ff fd0d 	bl	8009840 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8009e26:	6822      	ldr	r2, [r4, #0]
 8009e28:	69d3      	ldr	r3, [r2, #28]
 8009e2a:	f043 0308 	orr.w	r3, r3, #8
 8009e2e:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8009e30:	6822      	ldr	r2, [r4, #0]
 8009e32:	69d3      	ldr	r3, [r2, #28]
 8009e34:	f023 0304 	bic.w	r3, r3, #4
 8009e38:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8009e3a:	6822      	ldr	r2, [r4, #0]
 8009e3c:	69d3      	ldr	r3, [r2, #28]
 8009e3e:	6929      	ldr	r1, [r5, #16]
 8009e40:	430b      	orrs	r3, r1
 8009e42:	61d3      	str	r3, [r2, #28]
      break;
 8009e44:	e7d4      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8009e46:	6800      	ldr	r0, [r0, #0]
 8009e48:	f7ff fd34 	bl	80098b4 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8009e4c:	6822      	ldr	r2, [r4, #0]
 8009e4e:	69d3      	ldr	r3, [r2, #28]
 8009e50:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009e54:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8009e56:	6822      	ldr	r2, [r4, #0]
 8009e58:	69d3      	ldr	r3, [r2, #28]
 8009e5a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009e5e:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8009e60:	6822      	ldr	r2, [r4, #0]
 8009e62:	69d3      	ldr	r3, [r2, #28]
 8009e64:	6929      	ldr	r1, [r5, #16]
 8009e66:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009e6a:	61d3      	str	r3, [r2, #28]
      break;
 8009e6c:	e7c0      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8009e6e:	6800      	ldr	r0, [r0, #0]
 8009e70:	f7ff fd4e 	bl	8009910 <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8009e74:	6822      	ldr	r2, [r4, #0]
 8009e76:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e78:	f043 0308 	orr.w	r3, r3, #8
 8009e7c:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8009e7e:	6822      	ldr	r2, [r4, #0]
 8009e80:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e82:	f023 0304 	bic.w	r3, r3, #4
 8009e86:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8009e88:	6822      	ldr	r2, [r4, #0]
 8009e8a:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e8c:	6929      	ldr	r1, [r5, #16]
 8009e8e:	430b      	orrs	r3, r1
 8009e90:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 8009e92:	e7ad      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8009e94:	6800      	ldr	r0, [r0, #0]
 8009e96:	f7ff fd67 	bl	8009968 <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8009e9a:	6822      	ldr	r2, [r4, #0]
 8009e9c:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009e9e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009ea2:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8009ea4:	6822      	ldr	r2, [r4, #0]
 8009ea6:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009ea8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8009eac:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8009eae:	6822      	ldr	r2, [r4, #0]
 8009eb0:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8009eb2:	6929      	ldr	r1, [r5, #16]
 8009eb4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8009eb8:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 8009eba:	e799      	b.n	8009df0 <HAL_TIM_PWM_ConfigChannel+0x58>
  __HAL_LOCK(htim);
 8009ebc:	2002      	movs	r0, #2
 8009ebe:	e79a      	b.n	8009df6 <HAL_TIM_PWM_ConfigChannel+0x5e>

08009ec0 <HAL_TIMEx_MasterConfigSynchronization>:
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8009ec0:	f890 203c 	ldrb.w	r2, [r0, #60]	; 0x3c
 8009ec4:	2a01      	cmp	r2, #1
 8009ec6:	d033      	beq.n	8009f30 <HAL_TIMEx_MasterConfigSynchronization+0x70>
{
 8009ec8:	b430      	push	{r4, r5}
 8009eca:	4603      	mov	r3, r0
  __HAL_LOCK(htim);
 8009ecc:	2201      	movs	r2, #1
 8009ece:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8009ed2:	2202      	movs	r2, #2
 8009ed4:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8009ed8:	6800      	ldr	r0, [r0, #0]
 8009eda:	6842      	ldr	r2, [r0, #4]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8009edc:	6884      	ldr	r4, [r0, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8009ede:	4d15      	ldr	r5, [pc, #84]	; (8009f34 <HAL_TIMEx_MasterConfigSynchronization+0x74>)
 8009ee0:	42a8      	cmp	r0, r5
 8009ee2:	d020      	beq.n	8009f26 <HAL_TIMEx_MasterConfigSynchronization+0x66>
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8009ee4:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8009ee8:	680d      	ldr	r5, [r1, #0]
 8009eea:	432a      	orrs	r2, r5

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8009eec:	6042      	str	r2, [r0, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8009eee:	681a      	ldr	r2, [r3, #0]
 8009ef0:	4810      	ldr	r0, [pc, #64]	; (8009f34 <HAL_TIMEx_MasterConfigSynchronization+0x74>)
 8009ef2:	4282      	cmp	r2, r0
 8009ef4:	d00a      	beq.n	8009f0c <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8009ef6:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 8009efa:	d007      	beq.n	8009f0c <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8009efc:	f5a0 3094 	sub.w	r0, r0, #75776	; 0x12800
 8009f00:	4282      	cmp	r2, r0
 8009f02:	d003      	beq.n	8009f0c <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8009f04:	f500 309e 	add.w	r0, r0, #80896	; 0x13c00
 8009f08:	4282      	cmp	r2, r0
 8009f0a:	d104      	bne.n	8009f16 <HAL_TIMEx_MasterConfigSynchronization+0x56>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 8009f0c:	f024 0480 	bic.w	r4, r4, #128	; 0x80
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8009f10:	6889      	ldr	r1, [r1, #8]
 8009f12:	4321      	orrs	r1, r4

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8009f14:	6091      	str	r1, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8009f16:	2201      	movs	r2, #1
 8009f18:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8009f1c:	2000      	movs	r0, #0
 8009f1e:	f883 003c 	strb.w	r0, [r3, #60]	; 0x3c

  return HAL_OK;
}
 8009f22:	bc30      	pop	{r4, r5}
 8009f24:	4770      	bx	lr
    tmpcr2 &= ~TIM_CR2_MMS2;
 8009f26:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8009f2a:	684d      	ldr	r5, [r1, #4]
 8009f2c:	432a      	orrs	r2, r5
 8009f2e:	e7d9      	b.n	8009ee4 <HAL_TIMEx_MasterConfigSynchronization+0x24>
  __HAL_LOCK(htim);
 8009f30:	2002      	movs	r0, #2
}
 8009f32:	4770      	bx	lr
 8009f34:	40012c00 	.word	0x40012c00

08009f38 <HAL_TIMEx_CommutCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8009f38:	4770      	bx	lr

08009f3a <HAL_TIMEx_BreakCallback>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8009f3a:	4770      	bx	lr

08009f3c <HAL_TIMEx_Break2Callback>:
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8009f3c:	4770      	bx	lr

08009f3e <UART_EndRxTransfer>:
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
#if defined(USART_CR1_FIFOEN)
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
#else
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8009f3e:	6802      	ldr	r2, [r0, #0]
 8009f40:	6813      	ldr	r3, [r2, #0]
 8009f42:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8009f46:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009f48:	6802      	ldr	r2, [r0, #0]
 8009f4a:	6893      	ldr	r3, [r2, #8]
 8009f4c:	f023 0301 	bic.w	r3, r3, #1
 8009f50:	6093      	str	r3, [r2, #8]
#endif /* USART_CR1_FIFOEN */

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8009f52:	2320      	movs	r3, #32
 8009f54:	6783      	str	r3, [r0, #120]	; 0x78

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 8009f56:	2300      	movs	r3, #0
 8009f58:	6603      	str	r3, [r0, #96]	; 0x60
}
 8009f5a:	4770      	bx	lr

08009f5c <UART_TxISR_8BIT>:
  * @retval None
  */
static void UART_TxISR_8BIT(UART_HandleTypeDef *huart)
{
  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8009f5c:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8009f5e:	2b21      	cmp	r3, #33	; 0x21
 8009f60:	d000      	beq.n	8009f64 <UART_TxISR_8BIT+0x8>
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
      huart->pTxBuffPtr++;
      huart->TxXferCount--;
    }
  }
}
 8009f62:	4770      	bx	lr
    if (huart->TxXferCount == 0U)
 8009f64:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009f68:	b29b      	uxth	r3, r3
 8009f6a:	b953      	cbnz	r3, 8009f82 <UART_TxISR_8BIT+0x26>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8009f6c:	6802      	ldr	r2, [r0, #0]
 8009f6e:	6813      	ldr	r3, [r2, #0]
 8009f70:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009f74:	6013      	str	r3, [r2, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8009f76:	6802      	ldr	r2, [r0, #0]
 8009f78:	6813      	ldr	r3, [r2, #0]
 8009f7a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009f7e:	6013      	str	r3, [r2, #0]
 8009f80:	4770      	bx	lr
      huart->Instance->TDR = (uint8_t)(*huart->pTxBuffPtr & (uint8_t)0xFF);
 8009f82:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8009f84:	6803      	ldr	r3, [r0, #0]
 8009f86:	7812      	ldrb	r2, [r2, #0]
 8009f88:	851a      	strh	r2, [r3, #40]	; 0x28
      huart->pTxBuffPtr++;
 8009f8a:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8009f8c:	3301      	adds	r3, #1
 8009f8e:	64c3      	str	r3, [r0, #76]	; 0x4c
      huart->TxXferCount--;
 8009f90:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009f94:	b29b      	uxth	r3, r3
 8009f96:	3b01      	subs	r3, #1
 8009f98:	b29b      	uxth	r3, r3
 8009f9a:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
}
 8009f9e:	e7e0      	b.n	8009f62 <UART_TxISR_8BIT+0x6>

08009fa0 <UART_TxISR_16BIT>:
static void UART_TxISR_16BIT(UART_HandleTypeDef *huart)
{
  uint16_t *tmp;

  /* Check that a Tx process is ongoing */
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 8009fa0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 8009fa2:	2b21      	cmp	r3, #33	; 0x21
 8009fa4:	d000      	beq.n	8009fa8 <UART_TxISR_16BIT+0x8>
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
      huart->pTxBuffPtr += 2U;
      huart->TxXferCount--;
    }
  }
}
 8009fa6:	4770      	bx	lr
    if (huart->TxXferCount == 0U)
 8009fa8:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009fac:	b29b      	uxth	r3, r3
 8009fae:	b953      	cbnz	r3, 8009fc6 <UART_TxISR_16BIT+0x26>
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8009fb0:	6802      	ldr	r2, [r0, #0]
 8009fb2:	6813      	ldr	r3, [r2, #0]
 8009fb4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009fb8:	6013      	str	r3, [r2, #0]
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8009fba:	6802      	ldr	r2, [r0, #0]
 8009fbc:	6813      	ldr	r3, [r2, #0]
 8009fbe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009fc2:	6013      	str	r3, [r2, #0]
 8009fc4:	4770      	bx	lr
      tmp = (uint16_t *) huart->pTxBuffPtr;
 8009fc6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
      huart->Instance->TDR = (((uint32_t)(*tmp)) & 0x01FFUL);
 8009fc8:	881b      	ldrh	r3, [r3, #0]
 8009fca:	6802      	ldr	r2, [r0, #0]
 8009fcc:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009fd0:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->pTxBuffPtr += 2U;
 8009fd2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8009fd4:	3302      	adds	r3, #2
 8009fd6:	64c3      	str	r3, [r0, #76]	; 0x4c
      huart->TxXferCount--;
 8009fd8:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
 8009fdc:	b29b      	uxth	r3, r3
 8009fde:	3b01      	subs	r3, #1
 8009fe0:	b29b      	uxth	r3, r3
 8009fe2:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
}
 8009fe6:	e7de      	b.n	8009fa6 <UART_TxISR_16BIT+0x6>

08009fe8 <HAL_UART_DeInit>:
  if (huart == NULL)
 8009fe8:	b1c0      	cbz	r0, 800a01c <HAL_UART_DeInit+0x34>
{
 8009fea:	b538      	push	{r3, r4, r5, lr}
 8009fec:	4605      	mov	r5, r0
  huart->gState = HAL_UART_STATE_BUSY;
 8009fee:	2324      	movs	r3, #36	; 0x24
 8009ff0:	6743      	str	r3, [r0, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 8009ff2:	6802      	ldr	r2, [r0, #0]
 8009ff4:	6813      	ldr	r3, [r2, #0]
 8009ff6:	f023 0301 	bic.w	r3, r3, #1
 8009ffa:	6013      	str	r3, [r2, #0]
  huart->Instance->CR1 = 0x0U;
 8009ffc:	6803      	ldr	r3, [r0, #0]
 8009ffe:	2400      	movs	r4, #0
 800a000:	601c      	str	r4, [r3, #0]
  huart->Instance->CR2 = 0x0U;
 800a002:	6803      	ldr	r3, [r0, #0]
 800a004:	605c      	str	r4, [r3, #4]
  huart->Instance->CR3 = 0x0U;
 800a006:	6803      	ldr	r3, [r0, #0]
 800a008:	609c      	str	r4, [r3, #8]
  HAL_UART_MspDeInit(huart);
 800a00a:	f7f7 fde9 	bl	8001be0 <HAL_UART_MspDeInit>
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a00e:	67ec      	str	r4, [r5, #124]	; 0x7c
  huart->gState = HAL_UART_STATE_RESET;
 800a010:	676c      	str	r4, [r5, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_RESET;
 800a012:	67ac      	str	r4, [r5, #120]	; 0x78
  __HAL_UNLOCK(huart);
 800a014:	f885 4070 	strb.w	r4, [r5, #112]	; 0x70
  return HAL_OK;
 800a018:	4620      	mov	r0, r4
}
 800a01a:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 800a01c:	2001      	movs	r0, #1
}
 800a01e:	4770      	bx	lr

0800a020 <HAL_UART_Transmit_IT>:
  if (huart->gState == HAL_UART_STATE_READY)
 800a020:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a022:	2b20      	cmp	r3, #32
 800a024:	d128      	bne.n	800a078 <HAL_UART_Transmit_IT+0x58>
    if ((pData == NULL) || (Size == 0U))
 800a026:	b349      	cbz	r1, 800a07c <HAL_UART_Transmit_IT+0x5c>
 800a028:	b352      	cbz	r2, 800a080 <HAL_UART_Transmit_IT+0x60>
    __HAL_LOCK(huart);
 800a02a:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 800a02e:	2b01      	cmp	r3, #1
 800a030:	d028      	beq.n	800a084 <HAL_UART_Transmit_IT+0x64>
 800a032:	2301      	movs	r3, #1
 800a034:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->pTxBuffPtr  = pData;
 800a038:	64c1      	str	r1, [r0, #76]	; 0x4c
    huart->TxXferSize  = Size;
 800a03a:	f8a0 2050 	strh.w	r2, [r0, #80]	; 0x50
    huart->TxXferCount = Size;
 800a03e:	f8a0 2052 	strh.w	r2, [r0, #82]	; 0x52
    huart->TxISR       = NULL;
 800a042:	2300      	movs	r3, #0
 800a044:	6643      	str	r3, [r0, #100]	; 0x64
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a046:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800a048:	2321      	movs	r3, #33	; 0x21
 800a04a:	6743      	str	r3, [r0, #116]	; 0x74
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a04c:	6883      	ldr	r3, [r0, #8]
 800a04e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a052:	d00b      	beq.n	800a06c <HAL_UART_Transmit_IT+0x4c>
      huart->TxISR = UART_TxISR_8BIT;
 800a054:	4b0c      	ldr	r3, [pc, #48]	; (800a088 <HAL_UART_Transmit_IT+0x68>)
 800a056:	6643      	str	r3, [r0, #100]	; 0x64
    __HAL_UNLOCK(huart);
 800a058:	2300      	movs	r3, #0
 800a05a:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 800a05e:	6801      	ldr	r1, [r0, #0]
 800a060:	680a      	ldr	r2, [r1, #0]
 800a062:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800a066:	600a      	str	r2, [r1, #0]
    return HAL_OK;
 800a068:	4618      	mov	r0, r3
 800a06a:	4770      	bx	lr
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a06c:	6903      	ldr	r3, [r0, #16]
 800a06e:	2b00      	cmp	r3, #0
 800a070:	d1f0      	bne.n	800a054 <HAL_UART_Transmit_IT+0x34>
      huart->TxISR = UART_TxISR_16BIT;
 800a072:	4b06      	ldr	r3, [pc, #24]	; (800a08c <HAL_UART_Transmit_IT+0x6c>)
 800a074:	6643      	str	r3, [r0, #100]	; 0x64
 800a076:	e7ef      	b.n	800a058 <HAL_UART_Transmit_IT+0x38>
    return HAL_BUSY;
 800a078:	2002      	movs	r0, #2
 800a07a:	4770      	bx	lr
      return HAL_ERROR;
 800a07c:	2001      	movs	r0, #1
 800a07e:	4770      	bx	lr
 800a080:	2001      	movs	r0, #1
 800a082:	4770      	bx	lr
    __HAL_LOCK(huart);
 800a084:	2002      	movs	r0, #2
}
 800a086:	4770      	bx	lr
 800a088:	08009f5d 	.word	0x08009f5d
 800a08c:	08009fa1 	.word	0x08009fa1

0800a090 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 800a090:	6f83      	ldr	r3, [r0, #120]	; 0x78
 800a092:	2b20      	cmp	r3, #32
 800a094:	d15a      	bne.n	800a14c <HAL_UART_Receive_IT+0xbc>
    if ((pData == NULL) || (Size == 0U))
 800a096:	2900      	cmp	r1, #0
 800a098:	d05a      	beq.n	800a150 <HAL_UART_Receive_IT+0xc0>
 800a09a:	2a00      	cmp	r2, #0
 800a09c:	d05a      	beq.n	800a154 <HAL_UART_Receive_IT+0xc4>
    __HAL_LOCK(huart);
 800a09e:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 800a0a2:	2b01      	cmp	r3, #1
 800a0a4:	d058      	beq.n	800a158 <HAL_UART_Receive_IT+0xc8>
 800a0a6:	2301      	movs	r3, #1
 800a0a8:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->pRxBuffPtr  = pData;
 800a0ac:	6541      	str	r1, [r0, #84]	; 0x54
    huart->RxXferSize  = Size;
 800a0ae:	f8a0 2058 	strh.w	r2, [r0, #88]	; 0x58
    huart->RxXferCount = Size;
 800a0b2:	f8a0 205a 	strh.w	r2, [r0, #90]	; 0x5a
    huart->RxISR       = NULL;
 800a0b6:	2300      	movs	r3, #0
 800a0b8:	6603      	str	r3, [r0, #96]	; 0x60
    UART_MASK_COMPUTATION(huart);
 800a0ba:	6883      	ldr	r3, [r0, #8]
 800a0bc:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a0c0:	d006      	beq.n	800a0d0 <HAL_UART_Receive_IT+0x40>
 800a0c2:	b9a3      	cbnz	r3, 800a0ee <HAL_UART_Receive_IT+0x5e>
 800a0c4:	6903      	ldr	r3, [r0, #16]
 800a0c6:	b973      	cbnz	r3, 800a0e6 <HAL_UART_Receive_IT+0x56>
 800a0c8:	23ff      	movs	r3, #255	; 0xff
 800a0ca:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0ce:	e014      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0d0:	6903      	ldr	r3, [r0, #16]
 800a0d2:	b923      	cbnz	r3, 800a0de <HAL_UART_Receive_IT+0x4e>
 800a0d4:	f240 13ff 	movw	r3, #511	; 0x1ff
 800a0d8:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0dc:	e00d      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0de:	23ff      	movs	r3, #255	; 0xff
 800a0e0:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0e4:	e009      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0e6:	237f      	movs	r3, #127	; 0x7f
 800a0e8:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a0ec:	e005      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a0ee:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800a0f2:	d01b      	beq.n	800a12c <HAL_UART_Receive_IT+0x9c>
 800a0f4:	2300      	movs	r3, #0
 800a0f6:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a0fa:	2300      	movs	r3, #0
 800a0fc:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 800a0fe:	2322      	movs	r3, #34	; 0x22
 800a100:	6783      	str	r3, [r0, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a102:	6802      	ldr	r2, [r0, #0]
 800a104:	6893      	ldr	r3, [r2, #8]
 800a106:	f043 0301 	orr.w	r3, r3, #1
 800a10a:	6093      	str	r3, [r2, #8]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a10c:	6883      	ldr	r3, [r0, #8]
 800a10e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a112:	d015      	beq.n	800a140 <HAL_UART_Receive_IT+0xb0>
      huart->RxISR = UART_RxISR_8BIT;
 800a114:	4b11      	ldr	r3, [pc, #68]	; (800a15c <HAL_UART_Receive_IT+0xcc>)
 800a116:	6603      	str	r3, [r0, #96]	; 0x60
    __HAL_UNLOCK(huart);
 800a118:	2300      	movs	r3, #0
 800a11a:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 800a11e:	6801      	ldr	r1, [r0, #0]
 800a120:	680a      	ldr	r2, [r1, #0]
 800a122:	f442 7290 	orr.w	r2, r2, #288	; 0x120
 800a126:	600a      	str	r2, [r1, #0]
    return HAL_OK;
 800a128:	4618      	mov	r0, r3
 800a12a:	4770      	bx	lr
    UART_MASK_COMPUTATION(huart);
 800a12c:	6903      	ldr	r3, [r0, #16]
 800a12e:	b91b      	cbnz	r3, 800a138 <HAL_UART_Receive_IT+0xa8>
 800a130:	237f      	movs	r3, #127	; 0x7f
 800a132:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a136:	e7e0      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
 800a138:	233f      	movs	r3, #63	; 0x3f
 800a13a:	f8a0 305c 	strh.w	r3, [r0, #92]	; 0x5c
 800a13e:	e7dc      	b.n	800a0fa <HAL_UART_Receive_IT+0x6a>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a140:	6903      	ldr	r3, [r0, #16]
 800a142:	2b00      	cmp	r3, #0
 800a144:	d1e6      	bne.n	800a114 <HAL_UART_Receive_IT+0x84>
      huart->RxISR = UART_RxISR_16BIT;
 800a146:	4b06      	ldr	r3, [pc, #24]	; (800a160 <HAL_UART_Receive_IT+0xd0>)
 800a148:	6603      	str	r3, [r0, #96]	; 0x60
 800a14a:	e7e5      	b.n	800a118 <HAL_UART_Receive_IT+0x88>
    return HAL_BUSY;
 800a14c:	2002      	movs	r0, #2
 800a14e:	4770      	bx	lr
      return HAL_ERROR;
 800a150:	2001      	movs	r0, #1
 800a152:	4770      	bx	lr
 800a154:	2001      	movs	r0, #1
 800a156:	4770      	bx	lr
    __HAL_LOCK(huart);
 800a158:	2002      	movs	r0, #2
}
 800a15a:	4770      	bx	lr
 800a15c:	0800a17f 	.word	0x0800a17f
 800a160:	0800a1e5 	.word	0x0800a1e5

0800a164 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 800a164:	b508      	push	{r3, lr}
  /* Disable the UART Transmit Complete Interrupt */
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800a166:	6801      	ldr	r1, [r0, #0]
 800a168:	680a      	ldr	r2, [r1, #0]
 800a16a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a16e:	600a      	str	r2, [r1, #0]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800a170:	2220      	movs	r2, #32
 800a172:	6742      	str	r2, [r0, #116]	; 0x74

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800a174:	2200      	movs	r2, #0
 800a176:	6642      	str	r2, [r0, #100]	; 0x64
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800a178:	f014 f986 	bl	801e488 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800a17c:	bd08      	pop	{r3, pc}

0800a17e <UART_RxISR_8BIT>:
  * @brief RX interrrupt handler for 7 or 8 bits data word length .
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT(UART_HandleTypeDef *huart)
{
 800a17e:	b508      	push	{r3, lr}
  uint16_t uhMask = huart->Mask;
 800a180:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800a184:	6f82      	ldr	r2, [r0, #120]	; 0x78
 800a186:	2a22      	cmp	r2, #34	; 0x22
 800a188:	d006      	beq.n	800a198 <UART_RxISR_8BIT+0x1a>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800a18a:	6802      	ldr	r2, [r0, #0]
 800a18c:	8b13      	ldrh	r3, [r2, #24]
 800a18e:	b29b      	uxth	r3, r3
 800a190:	f043 0308 	orr.w	r3, r3, #8
 800a194:	8313      	strh	r3, [r2, #24]
  }
}
 800a196:	bd08      	pop	{r3, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800a198:	6802      	ldr	r2, [r0, #0]
 800a19a:	8c91      	ldrh	r1, [r2, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 800a19c:	b2db      	uxtb	r3, r3
 800a19e:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800a1a0:	400b      	ands	r3, r1
 800a1a2:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
 800a1a4:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800a1a6:	3301      	adds	r3, #1
 800a1a8:	6543      	str	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800a1aa:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a1ae:	b29b      	uxth	r3, r3
 800a1b0:	3b01      	subs	r3, #1
 800a1b2:	b29b      	uxth	r3, r3
 800a1b4:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 800a1b8:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a1bc:	b29b      	uxth	r3, r3
 800a1be:	2b00      	cmp	r3, #0
 800a1c0:	d1e9      	bne.n	800a196 <UART_RxISR_8BIT+0x18>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a1c2:	6802      	ldr	r2, [r0, #0]
 800a1c4:	6813      	ldr	r3, [r2, #0]
 800a1c6:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800a1ca:	6013      	str	r3, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a1cc:	6802      	ldr	r2, [r0, #0]
 800a1ce:	6893      	ldr	r3, [r2, #8]
 800a1d0:	f023 0301 	bic.w	r3, r3, #1
 800a1d4:	6093      	str	r3, [r2, #8]
      huart->RxState = HAL_UART_STATE_READY;
 800a1d6:	2320      	movs	r3, #32
 800a1d8:	6783      	str	r3, [r0, #120]	; 0x78
      huart->RxISR = NULL;
 800a1da:	2300      	movs	r3, #0
 800a1dc:	6603      	str	r3, [r0, #96]	; 0x60
      HAL_UART_RxCpltCallback(huart);
 800a1de:	f014 f93f 	bl	801e460 <HAL_UART_RxCpltCallback>
 800a1e2:	e7d8      	b.n	800a196 <UART_RxISR_8BIT+0x18>

0800a1e4 <UART_RxISR_16BIT>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT(UART_HandleTypeDef *huart)
{
 800a1e4:	b508      	push	{r3, lr}
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
 800a1e6:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800a1ea:	6f82      	ldr	r2, [r0, #120]	; 0x78
 800a1ec:	2a22      	cmp	r2, #34	; 0x22
 800a1ee:	d006      	beq.n	800a1fe <UART_RxISR_16BIT+0x1a>
    }
  }
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 800a1f0:	6802      	ldr	r2, [r0, #0]
 800a1f2:	8b13      	ldrh	r3, [r2, #24]
 800a1f4:	b29b      	uxth	r3, r3
 800a1f6:	f043 0308 	orr.w	r3, r3, #8
 800a1fa:	8313      	strh	r3, [r2, #24]
  }
}
 800a1fc:	bd08      	pop	{r3, pc}
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 800a1fe:	6802      	ldr	r2, [r0, #0]
 800a200:	8c91      	ldrh	r1, [r2, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 800a202:	6d42      	ldr	r2, [r0, #84]	; 0x54
    *tmp = (uint16_t)(uhdata & uhMask);
 800a204:	400b      	ands	r3, r1
 800a206:	8013      	strh	r3, [r2, #0]
    huart->pRxBuffPtr += 2U;
 800a208:	6d43      	ldr	r3, [r0, #84]	; 0x54
 800a20a:	3302      	adds	r3, #2
 800a20c:	6543      	str	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 800a20e:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a212:	b29b      	uxth	r3, r3
 800a214:	3b01      	subs	r3, #1
 800a216:	b29b      	uxth	r3, r3
 800a218:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
    if (huart->RxXferCount == 0U)
 800a21c:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
 800a220:	b29b      	uxth	r3, r3
 800a222:	2b00      	cmp	r3, #0
 800a224:	d1ea      	bne.n	800a1fc <UART_RxISR_16BIT+0x18>
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800a226:	6802      	ldr	r2, [r0, #0]
 800a228:	6813      	ldr	r3, [r2, #0]
 800a22a:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 800a22e:	6013      	str	r3, [r2, #0]
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a230:	6802      	ldr	r2, [r0, #0]
 800a232:	6893      	ldr	r3, [r2, #8]
 800a234:	f023 0301 	bic.w	r3, r3, #1
 800a238:	6093      	str	r3, [r2, #8]
      huart->RxState = HAL_UART_STATE_READY;
 800a23a:	2320      	movs	r3, #32
 800a23c:	6783      	str	r3, [r0, #120]	; 0x78
      huart->RxISR = NULL;
 800a23e:	2300      	movs	r3, #0
 800a240:	6603      	str	r3, [r0, #96]	; 0x60
      HAL_UART_RxCpltCallback(huart);
 800a242:	f014 f90d 	bl	801e460 <HAL_UART_RxCpltCallback>
 800a246:	e7d9      	b.n	800a1fc <UART_RxISR_16BIT+0x18>

0800a248 <HAL_UART_IRQHandler>:
{
 800a248:	b570      	push	{r4, r5, r6, lr}
 800a24a:	4604      	mov	r4, r0
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800a24c:	6801      	ldr	r1, [r0, #0]
 800a24e:	69cb      	ldr	r3, [r1, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 800a250:	6808      	ldr	r0, [r1, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 800a252:	688d      	ldr	r5, [r1, #8]
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 800a254:	f640 020f 	movw	r2, #2063	; 0x80f
  if (errorflags == 0U)
 800a258:	401a      	ands	r2, r3
 800a25a:	d105      	bne.n	800a268 <HAL_UART_IRQHandler+0x20>
    if (((isrflags & USART_ISR_RXNE) != 0U)
 800a25c:	f013 0f20 	tst.w	r3, #32
 800a260:	d002      	beq.n	800a268 <HAL_UART_IRQHandler+0x20>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800a262:	f010 0f20 	tst.w	r0, #32
 800a266:	d11c      	bne.n	800a2a2 <HAL_UART_IRQHandler+0x5a>
  if ((errorflags != 0U)
 800a268:	b12a      	cbz	r2, 800a276 <HAL_UART_IRQHandler+0x2e>
      && (((cr3its & USART_CR3_EIE) != 0U)
 800a26a:	f015 0201 	ands.w	r2, r5, #1
 800a26e:	d11e      	bne.n	800a2ae <HAL_UART_IRQHandler+0x66>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
 800a270:	4e54      	ldr	r6, [pc, #336]	; (800a3c4 <HAL_UART_IRQHandler+0x17c>)
 800a272:	4230      	tst	r0, r6
 800a274:	d11b      	bne.n	800a2ae <HAL_UART_IRQHandler+0x66>
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 800a276:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800a27a:	d003      	beq.n	800a284 <HAL_UART_IRQHandler+0x3c>
 800a27c:	f415 0f80 	tst.w	r5, #4194304	; 0x400000
 800a280:	f040 808e 	bne.w	800a3a0 <HAL_UART_IRQHandler+0x158>
  if (((isrflags & USART_ISR_TXE) != 0U)
 800a284:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a288:	d003      	beq.n	800a292 <HAL_UART_IRQHandler+0x4a>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 800a28a:	f010 0f80 	tst.w	r0, #128	; 0x80
 800a28e:	f040 808e 	bne.w	800a3ae <HAL_UART_IRQHandler+0x166>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800a292:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a296:	d003      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
 800a298:	f010 0f40 	tst.w	r0, #64	; 0x40
 800a29c:	f040 808e 	bne.w	800a3bc <HAL_UART_IRQHandler+0x174>
}
 800a2a0:	bd70      	pop	{r4, r5, r6, pc}
      if (huart->RxISR != NULL)
 800a2a2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a2a4:	2b00      	cmp	r3, #0
 800a2a6:	d0fb      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
        huart->RxISR(huart);
 800a2a8:	4620      	mov	r0, r4
 800a2aa:	4798      	blx	r3
      return;
 800a2ac:	e7f8      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 800a2ae:	f013 0f01 	tst.w	r3, #1
 800a2b2:	d007      	beq.n	800a2c4 <HAL_UART_IRQHandler+0x7c>
 800a2b4:	f410 7f80 	tst.w	r0, #256	; 0x100
 800a2b8:	d004      	beq.n	800a2c4 <HAL_UART_IRQHandler+0x7c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 800a2ba:	2501      	movs	r5, #1
 800a2bc:	620d      	str	r5, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 800a2be:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800a2c0:	4329      	orrs	r1, r5
 800a2c2:	67e1      	str	r1, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800a2c4:	f013 0f02 	tst.w	r3, #2
 800a2c8:	d007      	beq.n	800a2da <HAL_UART_IRQHandler+0x92>
 800a2ca:	b132      	cbz	r2, 800a2da <HAL_UART_IRQHandler+0x92>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 800a2cc:	6821      	ldr	r1, [r4, #0]
 800a2ce:	2502      	movs	r5, #2
 800a2d0:	620d      	str	r5, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 800a2d2:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800a2d4:	f041 0104 	orr.w	r1, r1, #4
 800a2d8:	67e1      	str	r1, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 800a2da:	f013 0f04 	tst.w	r3, #4
 800a2de:	d007      	beq.n	800a2f0 <HAL_UART_IRQHandler+0xa8>
 800a2e0:	b132      	cbz	r2, 800a2f0 <HAL_UART_IRQHandler+0xa8>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 800a2e2:	6821      	ldr	r1, [r4, #0]
 800a2e4:	2504      	movs	r5, #4
 800a2e6:	620d      	str	r5, [r1, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 800a2e8:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800a2ea:	f041 0102 	orr.w	r1, r1, #2
 800a2ee:	67e1      	str	r1, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_ORE) != 0U)
 800a2f0:	f013 0f08 	tst.w	r3, #8
 800a2f4:	d009      	beq.n	800a30a <HAL_UART_IRQHandler+0xc2>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 800a2f6:	f010 0f20 	tst.w	r0, #32
 800a2fa:	d100      	bne.n	800a2fe <HAL_UART_IRQHandler+0xb6>
 800a2fc:	b12a      	cbz	r2, 800a30a <HAL_UART_IRQHandler+0xc2>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800a2fe:	6822      	ldr	r2, [r4, #0]
 800a300:	2108      	movs	r1, #8
 800a302:	6211      	str	r1, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 800a304:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a306:	430a      	orrs	r2, r1
 800a308:	67e2      	str	r2, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 800a30a:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800a30e:	d00a      	beq.n	800a326 <HAL_UART_IRQHandler+0xde>
 800a310:	f010 6f80 	tst.w	r0, #67108864	; 0x4000000
 800a314:	d007      	beq.n	800a326 <HAL_UART_IRQHandler+0xde>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800a316:	6822      	ldr	r2, [r4, #0]
 800a318:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800a31c:	6211      	str	r1, [r2, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 800a31e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a320:	f042 0220 	orr.w	r2, r2, #32
 800a324:	67e2      	str	r2, [r4, #124]	; 0x7c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800a326:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800a328:	2a00      	cmp	r2, #0
 800a32a:	d0b9      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800a32c:	f013 0f20 	tst.w	r3, #32
 800a330:	d006      	beq.n	800a340 <HAL_UART_IRQHandler+0xf8>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 800a332:	f010 0f20 	tst.w	r0, #32
 800a336:	d003      	beq.n	800a340 <HAL_UART_IRQHandler+0xf8>
        if (huart->RxISR != NULL)
 800a338:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800a33a:	b10b      	cbz	r3, 800a340 <HAL_UART_IRQHandler+0xf8>
          huart->RxISR(huart);
 800a33c:	4620      	mov	r0, r4
 800a33e:	4798      	blx	r3
      errorcode = huart->ErrorCode;
 800a340:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800a342:	6823      	ldr	r3, [r4, #0]
 800a344:	689b      	ldr	r3, [r3, #8]
 800a346:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a34a:	d102      	bne.n	800a352 <HAL_UART_IRQHandler+0x10a>
 800a34c:	f012 0f28 	tst.w	r2, #40	; 0x28
 800a350:	d020      	beq.n	800a394 <HAL_UART_IRQHandler+0x14c>
        UART_EndRxTransfer(huart);
 800a352:	4620      	mov	r0, r4
 800a354:	f7ff fdf3 	bl	8009f3e <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 800a358:	6823      	ldr	r3, [r4, #0]
 800a35a:	689a      	ldr	r2, [r3, #8]
 800a35c:	f012 0f40 	tst.w	r2, #64	; 0x40
 800a360:	d014      	beq.n	800a38c <HAL_UART_IRQHandler+0x144>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a362:	689a      	ldr	r2, [r3, #8]
 800a364:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800a368:	609a      	str	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 800a36a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800a36c:	b153      	cbz	r3, 800a384 <HAL_UART_IRQHandler+0x13c>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800a36e:	4a16      	ldr	r2, [pc, #88]	; (800a3c8 <HAL_UART_IRQHandler+0x180>)
 800a370:	639a      	str	r2, [r3, #56]	; 0x38
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800a372:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800a374:	f7fd fa10 	bl	8007798 <HAL_DMA_Abort_IT>
 800a378:	2800      	cmp	r0, #0
 800a37a:	d091      	beq.n	800a2a0 <HAL_UART_IRQHandler+0x58>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 800a37c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800a37e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a380:	4798      	blx	r3
 800a382:	e78d      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
            HAL_UART_ErrorCallback(huart);
 800a384:	4620      	mov	r0, r4
 800a386:	f014 f88b 	bl	801e4a0 <HAL_UART_ErrorCallback>
 800a38a:	e789      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
          HAL_UART_ErrorCallback(huart);
 800a38c:	4620      	mov	r0, r4
 800a38e:	f014 f887 	bl	801e4a0 <HAL_UART_ErrorCallback>
 800a392:	e785      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
        HAL_UART_ErrorCallback(huart);
 800a394:	4620      	mov	r0, r4
 800a396:	f014 f883 	bl	801e4a0 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a39a:	2300      	movs	r3, #0
 800a39c:	67e3      	str	r3, [r4, #124]	; 0x7c
    return;
 800a39e:	e77f      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 800a3a0:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 800a3a4:	620b      	str	r3, [r1, #32]
    HAL_UARTEx_WakeupCallback(huart);
 800a3a6:	4620      	mov	r0, r4
 800a3a8:	f000 fb50 	bl	800aa4c <HAL_UARTEx_WakeupCallback>
    return;
 800a3ac:	e778      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    if (huart->TxISR != NULL)
 800a3ae:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800a3b0:	2b00      	cmp	r3, #0
 800a3b2:	f43f af75 	beq.w	800a2a0 <HAL_UART_IRQHandler+0x58>
      huart->TxISR(huart);
 800a3b6:	4620      	mov	r0, r4
 800a3b8:	4798      	blx	r3
    return;
 800a3ba:	e771      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
    UART_EndTransmit_IT(huart);
 800a3bc:	4620      	mov	r0, r4
 800a3be:	f7ff fed1 	bl	800a164 <UART_EndTransmit_IT>
    return;
 800a3c2:	e76d      	b.n	800a2a0 <HAL_UART_IRQHandler+0x58>
 800a3c4:	04000120 	.word	0x04000120
 800a3c8:	0800a3cd 	.word	0x0800a3cd

0800a3cc <UART_DMAAbortOnError>:
{
 800a3cc:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a3ce:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->RxXferCount = 0U;
 800a3d0:	2300      	movs	r3, #0
 800a3d2:	f8a0 305a 	strh.w	r3, [r0, #90]	; 0x5a
  huart->TxXferCount = 0U;
 800a3d6:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
  HAL_UART_ErrorCallback(huart);
 800a3da:	f014 f861 	bl	801e4a0 <HAL_UART_ErrorCallback>
}
 800a3de:	bd08      	pop	{r3, pc}

0800a3e0 <HAL_UART_AbortTransmitCpltCallback>:
}
 800a3e0:	4770      	bx	lr
	...

0800a3e4 <HAL_UART_AbortTransmit_IT>:
{
 800a3e4:	b510      	push	{r4, lr}
 800a3e6:	4604      	mov	r4, r0
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
 800a3e8:	6802      	ldr	r2, [r0, #0]
 800a3ea:	6813      	ldr	r3, [r2, #0]
 800a3ec:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800a3f0:	6013      	str	r3, [r2, #0]
  if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
 800a3f2:	6803      	ldr	r3, [r0, #0]
 800a3f4:	689a      	ldr	r2, [r3, #8]
 800a3f6:	f012 0f80 	tst.w	r2, #128	; 0x80
 800a3fa:	d018      	beq.n	800a42e <HAL_UART_AbortTransmit_IT+0x4a>
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800a3fc:	689a      	ldr	r2, [r3, #8]
 800a3fe:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800a402:	609a      	str	r2, [r3, #8]
    if (huart->hdmatx != NULL)
 800a404:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800a406:	b14b      	cbz	r3, 800a41c <HAL_UART_AbortTransmit_IT+0x38>
      huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
 800a408:	4a0e      	ldr	r2, [pc, #56]	; (800a444 <HAL_UART_AbortTransmit_IT+0x60>)
 800a40a:	639a      	str	r2, [r3, #56]	; 0x38
      if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
 800a40c:	6e80      	ldr	r0, [r0, #104]	; 0x68
 800a40e:	f7fd f9c3 	bl	8007798 <HAL_DMA_Abort_IT>
 800a412:	b1a0      	cbz	r0, 800a43e <HAL_UART_AbortTransmit_IT+0x5a>
        huart->hdmatx->XferAbortCallback(huart->hdmatx);
 800a414:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 800a416:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800a418:	4798      	blx	r3
 800a41a:	e010      	b.n	800a43e <HAL_UART_AbortTransmit_IT+0x5a>
      huart->TxXferCount = 0U;
 800a41c:	2300      	movs	r3, #0
 800a41e:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
      huart->TxISR = NULL;
 800a422:	6643      	str	r3, [r0, #100]	; 0x64
      huart->gState = HAL_UART_STATE_READY;
 800a424:	2320      	movs	r3, #32
 800a426:	6743      	str	r3, [r0, #116]	; 0x74
      HAL_UART_AbortTransmitCpltCallback(huart);
 800a428:	f7ff ffda 	bl	800a3e0 <HAL_UART_AbortTransmitCpltCallback>
 800a42c:	e007      	b.n	800a43e <HAL_UART_AbortTransmit_IT+0x5a>
    huart->TxXferCount = 0U;
 800a42e:	2300      	movs	r3, #0
 800a430:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
    huart->TxISR = NULL;
 800a434:	6643      	str	r3, [r0, #100]	; 0x64
    huart->gState = HAL_UART_STATE_READY;
 800a436:	2320      	movs	r3, #32
 800a438:	6743      	str	r3, [r0, #116]	; 0x74
    HAL_UART_AbortTransmitCpltCallback(huart);
 800a43a:	f7ff ffd1 	bl	800a3e0 <HAL_UART_AbortTransmitCpltCallback>
}
 800a43e:	2000      	movs	r0, #0
 800a440:	bd10      	pop	{r4, pc}
 800a442:	bf00      	nop
 800a444:	0800a449 	.word	0x0800a449

0800a448 <UART_DMATxOnlyAbortCallback>:
{
 800a448:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a44a:	6a80      	ldr	r0, [r0, #40]	; 0x28
  huart->TxXferCount = 0U;
 800a44c:	2300      	movs	r3, #0
 800a44e:	f8a0 3052 	strh.w	r3, [r0, #82]	; 0x52
  huart->gState = HAL_UART_STATE_READY;
 800a452:	2320      	movs	r3, #32
 800a454:	6743      	str	r3, [r0, #116]	; 0x74
  HAL_UART_AbortTransmitCpltCallback(huart);
 800a456:	f7ff ffc3 	bl	800a3e0 <HAL_UART_AbortTransmitCpltCallback>
}
 800a45a:	bd08      	pop	{r3, pc}

0800a45c <UART_SetConfig>:
{
 800a45c:	b510      	push	{r4, lr}
 800a45e:	4604      	mov	r4, r0
  if (UART_INSTANCE_LOWPOWER(huart))
 800a460:	6801      	ldr	r1, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800a462:	6883      	ldr	r3, [r0, #8]
 800a464:	6902      	ldr	r2, [r0, #16]
 800a466:	4313      	orrs	r3, r2
 800a468:	6942      	ldr	r2, [r0, #20]
 800a46a:	4313      	orrs	r3, r2
 800a46c:	69c2      	ldr	r2, [r0, #28]
 800a46e:	4313      	orrs	r3, r2
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800a470:	6808      	ldr	r0, [r1, #0]
 800a472:	4a8f      	ldr	r2, [pc, #572]	; (800a6b0 <UART_SetConfig+0x254>)
 800a474:	4002      	ands	r2, r0
 800a476:	431a      	orrs	r2, r3
 800a478:	600a      	str	r2, [r1, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800a47a:	6822      	ldr	r2, [r4, #0]
 800a47c:	6853      	ldr	r3, [r2, #4]
 800a47e:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800a482:	68e1      	ldr	r1, [r4, #12]
 800a484:	430b      	orrs	r3, r1
 800a486:	6053      	str	r3, [r2, #4]
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800a488:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800a48a:	6822      	ldr	r2, [r4, #0]
 800a48c:	4b89      	ldr	r3, [pc, #548]	; (800a6b4 <UART_SetConfig+0x258>)
 800a48e:	429a      	cmp	r2, r3
 800a490:	d001      	beq.n	800a496 <UART_SetConfig+0x3a>
    tmpreg |= huart->Init.OneBitSampling;
 800a492:	6a23      	ldr	r3, [r4, #32]
 800a494:	4319      	orrs	r1, r3
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800a496:	6893      	ldr	r3, [r2, #8]
 800a498:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 800a49c:	430b      	orrs	r3, r1
 800a49e:	6093      	str	r3, [r2, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a4a0:	6823      	ldr	r3, [r4, #0]
 800a4a2:	4a85      	ldr	r2, [pc, #532]	; (800a6b8 <UART_SetConfig+0x25c>)
 800a4a4:	4293      	cmp	r3, r2
 800a4a6:	d023      	beq.n	800a4f0 <UART_SetConfig+0x94>
 800a4a8:	4a84      	ldr	r2, [pc, #528]	; (800a6bc <UART_SetConfig+0x260>)
 800a4aa:	4293      	cmp	r3, r2
 800a4ac:	d034      	beq.n	800a518 <UART_SetConfig+0xbc>
 800a4ae:	4a84      	ldr	r2, [pc, #528]	; (800a6c0 <UART_SetConfig+0x264>)
 800a4b0:	4293      	cmp	r3, r2
 800a4b2:	d04a      	beq.n	800a54a <UART_SetConfig+0xee>
 800a4b4:	4a83      	ldr	r2, [pc, #524]	; (800a6c4 <UART_SetConfig+0x268>)
 800a4b6:	4293      	cmp	r3, r2
 800a4b8:	d059      	beq.n	800a56e <UART_SetConfig+0x112>
 800a4ba:	4a7e      	ldr	r2, [pc, #504]	; (800a6b4 <UART_SetConfig+0x258>)
 800a4bc:	4293      	cmp	r3, r2
 800a4be:	d068      	beq.n	800a592 <UART_SetConfig+0x136>
 800a4c0:	2210      	movs	r2, #16
  if (UART_INSTANCE_LOWPOWER(huart))
 800a4c2:	497c      	ldr	r1, [pc, #496]	; (800a6b4 <UART_SetConfig+0x258>)
 800a4c4:	428b      	cmp	r3, r1
 800a4c6:	f000 8095 	beq.w	800a5f4 <UART_SetConfig+0x198>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800a4ca:	69e0      	ldr	r0, [r4, #28]
 800a4cc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 800a4d0:	f000 80c1 	beq.w	800a656 <UART_SetConfig+0x1fa>
    switch (clocksource)
 800a4d4:	2a08      	cmp	r2, #8
 800a4d6:	f200 812a 	bhi.w	800a72e <UART_SetConfig+0x2d2>
 800a4da:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a4de:	00f9      	.short	0x00f9
 800a4e0:	00e7010f 	.word	0x00e7010f
 800a4e4:	01120128 	.word	0x01120128
 800a4e8:	01280128 	.word	0x01280128
 800a4ec:	01150128 	.word	0x01150128
  UART_GETCLOCKSOURCE(huart, clocksource);
 800a4f0:	f502 4258 	add.w	r2, r2, #55296	; 0xd800
 800a4f4:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a4f8:	f002 0203 	and.w	r2, r2, #3
 800a4fc:	2a03      	cmp	r2, #3
 800a4fe:	d809      	bhi.n	800a514 <UART_SetConfig+0xb8>
 800a500:	e8df f002 	tbb	[pc, r2]
 800a504:	065c0402 	.word	0x065c0402
 800a508:	2201      	movs	r2, #1
 800a50a:	e7da      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a50c:	2204      	movs	r2, #4
 800a50e:	e7d8      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a510:	2208      	movs	r2, #8
 800a512:	e7d6      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a514:	2210      	movs	r2, #16
 800a516:	e7d4      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a518:	f502 32e6 	add.w	r2, r2, #117760	; 0x1cc00
 800a51c:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a520:	f002 020c 	and.w	r2, r2, #12
 800a524:	2a0c      	cmp	r2, #12
 800a526:	d80e      	bhi.n	800a546 <UART_SetConfig+0xea>
 800a528:	e8df f002 	tbb	[pc, r2]
 800a52c:	0d0d0d07 	.word	0x0d0d0d07
 800a530:	0d0d0d09 	.word	0x0d0d0d09
 800a534:	0d0d0d4a 	.word	0x0d0d0d4a
 800a538:	0b          	.byte	0x0b
 800a539:	00          	.byte	0x00
 800a53a:	2200      	movs	r2, #0
 800a53c:	e7c1      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a53e:	2204      	movs	r2, #4
 800a540:	e7bf      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a542:	2208      	movs	r2, #8
 800a544:	e7bd      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a546:	2210      	movs	r2, #16
 800a548:	e7bb      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a54a:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 800a54e:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a552:	f002 0230 	and.w	r2, r2, #48	; 0x30
 800a556:	2a20      	cmp	r2, #32
 800a558:	d034      	beq.n	800a5c4 <UART_SetConfig+0x168>
 800a55a:	d804      	bhi.n	800a566 <UART_SetConfig+0x10a>
 800a55c:	b3a2      	cbz	r2, 800a5c8 <UART_SetConfig+0x16c>
 800a55e:	2a10      	cmp	r2, #16
 800a560:	d134      	bne.n	800a5cc <UART_SetConfig+0x170>
 800a562:	2204      	movs	r2, #4
 800a564:	e7ad      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a566:	2a30      	cmp	r2, #48	; 0x30
 800a568:	d132      	bne.n	800a5d0 <UART_SetConfig+0x174>
 800a56a:	2208      	movs	r2, #8
 800a56c:	e7a9      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a56e:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 800a572:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a576:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 800a57a:	2a80      	cmp	r2, #128	; 0x80
 800a57c:	d02a      	beq.n	800a5d4 <UART_SetConfig+0x178>
 800a57e:	d804      	bhi.n	800a58a <UART_SetConfig+0x12e>
 800a580:	b352      	cbz	r2, 800a5d8 <UART_SetConfig+0x17c>
 800a582:	2a40      	cmp	r2, #64	; 0x40
 800a584:	d12a      	bne.n	800a5dc <UART_SetConfig+0x180>
 800a586:	2204      	movs	r2, #4
 800a588:	e79b      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a58a:	2ac0      	cmp	r2, #192	; 0xc0
 800a58c:	d128      	bne.n	800a5e0 <UART_SetConfig+0x184>
 800a58e:	2208      	movs	r2, #8
 800a590:	e797      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a592:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 800a596:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 800a59a:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 800a59e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800a5a2:	d01f      	beq.n	800a5e4 <UART_SetConfig+0x188>
 800a5a4:	d805      	bhi.n	800a5b2 <UART_SetConfig+0x156>
 800a5a6:	b1fa      	cbz	r2, 800a5e8 <UART_SetConfig+0x18c>
 800a5a8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800a5ac:	d11e      	bne.n	800a5ec <UART_SetConfig+0x190>
 800a5ae:	2204      	movs	r2, #4
 800a5b0:	e787      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5b2:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 800a5b6:	d11b      	bne.n	800a5f0 <UART_SetConfig+0x194>
 800a5b8:	2208      	movs	r2, #8
 800a5ba:	e782      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5bc:	2202      	movs	r2, #2
 800a5be:	e780      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5c0:	2202      	movs	r2, #2
 800a5c2:	e77e      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5c4:	2202      	movs	r2, #2
 800a5c6:	e77c      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5c8:	2200      	movs	r2, #0
 800a5ca:	e77a      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5cc:	2210      	movs	r2, #16
 800a5ce:	e778      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5d0:	2210      	movs	r2, #16
 800a5d2:	e776      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5d4:	2202      	movs	r2, #2
 800a5d6:	e774      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5d8:	2200      	movs	r2, #0
 800a5da:	e772      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5dc:	2210      	movs	r2, #16
 800a5de:	e770      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5e0:	2210      	movs	r2, #16
 800a5e2:	e76e      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5e4:	2202      	movs	r2, #2
 800a5e6:	e76c      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5e8:	2200      	movs	r2, #0
 800a5ea:	e76a      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5ec:	2210      	movs	r2, #16
 800a5ee:	e768      	b.n	800a4c2 <UART_SetConfig+0x66>
 800a5f0:	2210      	movs	r2, #16
 800a5f2:	e766      	b.n	800a4c2 <UART_SetConfig+0x66>
    switch (clocksource)
 800a5f4:	2a08      	cmp	r2, #8
 800a5f6:	f200 808a 	bhi.w	800a70e <UART_SetConfig+0x2b2>
 800a5fa:	e8df f002 	tbb	[pc, r2]
 800a5fe:	8808      	.short	0x8808
 800a600:	8827882a 	.word	0x8827882a
 800a604:	8888      	.short	0x8888
 800a606:	05          	.byte	0x05
 800a607:	00          	.byte	0x00
 800a608:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800a60c:	e003      	b.n	800a616 <UART_SetConfig+0x1ba>
        pclk = HAL_RCC_GetPCLK1Freq();
 800a60e:	f7fe fc8b 	bl	8008f28 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800a612:	2800      	cmp	r0, #0
 800a614:	d07d      	beq.n	800a712 <UART_SetConfig+0x2b6>
      if ((pclk < (3U * huart->Init.BaudRate)) ||
 800a616:	6862      	ldr	r2, [r4, #4]
 800a618:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 800a61c:	4283      	cmp	r3, r0
 800a61e:	d87a      	bhi.n	800a716 <UART_SetConfig+0x2ba>
 800a620:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 800a624:	d879      	bhi.n	800a71a <UART_SetConfig+0x2be>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate));
 800a626:	0e01      	lsrs	r1, r0, #24
 800a628:	0200      	lsls	r0, r0, #8
 800a62a:	0853      	lsrs	r3, r2, #1
 800a62c:	18c0      	adds	r0, r0, r3
 800a62e:	f04f 0300 	mov.w	r3, #0
 800a632:	f141 0100 	adc.w	r1, r1, #0
 800a636:	f7f6 facf 	bl	8000bd8 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800a63a:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
 800a63e:	4b22      	ldr	r3, [pc, #136]	; (800a6c8 <UART_SetConfig+0x26c>)
 800a640:	429a      	cmp	r2, r3
 800a642:	d86c      	bhi.n	800a71e <UART_SetConfig+0x2c2>
          huart->Instance->BRR = usartdiv;
 800a644:	6823      	ldr	r3, [r4, #0]
 800a646:	60d8      	str	r0, [r3, #12]
 800a648:	2000      	movs	r0, #0
 800a64a:	e053      	b.n	800a6f4 <UART_SetConfig+0x298>
        pclk = HAL_RCC_GetSysClockFreq();
 800a64c:	f7fe f81e 	bl	800868c <HAL_RCC_GetSysClockFreq>
        break;
 800a650:	e7df      	b.n	800a612 <UART_SetConfig+0x1b6>
        pclk = (uint32_t) HSI_VALUE;
 800a652:	481e      	ldr	r0, [pc, #120]	; (800a6cc <UART_SetConfig+0x270>)
 800a654:	e7df      	b.n	800a616 <UART_SetConfig+0x1ba>
    switch (clocksource)
 800a656:	2a08      	cmp	r2, #8
 800a658:	d863      	bhi.n	800a722 <UART_SetConfig+0x2c6>
 800a65a:	e8df f002 	tbb	[pc, r2]
 800a65e:	2107      	.short	0x2107
 800a660:	62246205 	.word	0x62246205
 800a664:	6262      	.short	0x6262
 800a666:	0b          	.byte	0x0b
 800a667:	00          	.byte	0x00
 800a668:	4818      	ldr	r0, [pc, #96]	; (800a6cc <UART_SetConfig+0x270>)
 800a66a:	e003      	b.n	800a674 <UART_SetConfig+0x218>
        pclk = HAL_RCC_GetPCLK1Freq();
 800a66c:	f7fe fc5c 	bl	8008f28 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800a670:	2800      	cmp	r0, #0
 800a672:	d058      	beq.n	800a726 <UART_SetConfig+0x2ca>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 800a674:	6862      	ldr	r2, [r4, #4]
 800a676:	0853      	lsrs	r3, r2, #1
 800a678:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800a67c:	fbb3 f3f2 	udiv	r3, r3, r2
 800a680:	b29b      	uxth	r3, r3
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800a682:	f1a3 0110 	sub.w	r1, r3, #16
 800a686:	f64f 72ef 	movw	r2, #65519	; 0xffef
 800a68a:	4291      	cmp	r1, r2
 800a68c:	d84d      	bhi.n	800a72a <UART_SetConfig+0x2ce>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800a68e:	f023 020f 	bic.w	r2, r3, #15
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800a692:	f3c3 0342 	ubfx	r3, r3, #1, #3
 800a696:	4313      	orrs	r3, r2
        huart->Instance->BRR = brrtemp;
 800a698:	6822      	ldr	r2, [r4, #0]
 800a69a:	60d3      	str	r3, [r2, #12]
 800a69c:	2000      	movs	r0, #0
 800a69e:	e029      	b.n	800a6f4 <UART_SetConfig+0x298>
        pclk = HAL_RCC_GetPCLK2Freq();
 800a6a0:	f7fe fc54 	bl	8008f4c <HAL_RCC_GetPCLK2Freq>
        break;
 800a6a4:	e7e4      	b.n	800a670 <UART_SetConfig+0x214>
        pclk = HAL_RCC_GetSysClockFreq();
 800a6a6:	f7fd fff1 	bl	800868c <HAL_RCC_GetSysClockFreq>
        break;
 800a6aa:	e7e1      	b.n	800a670 <UART_SetConfig+0x214>
    switch (clocksource)
 800a6ac:	4807      	ldr	r0, [pc, #28]	; (800a6cc <UART_SetConfig+0x270>)
 800a6ae:	e012      	b.n	800a6d6 <UART_SetConfig+0x27a>
 800a6b0:	efff69f3 	.word	0xefff69f3
 800a6b4:	40008000 	.word	0x40008000
 800a6b8:	40013800 	.word	0x40013800
 800a6bc:	40004400 	.word	0x40004400
 800a6c0:	40004800 	.word	0x40004800
 800a6c4:	40004c00 	.word	0x40004c00
 800a6c8:	000ffcff 	.word	0x000ffcff
 800a6cc:	00f42400 	.word	0x00f42400
        pclk = HAL_RCC_GetPCLK1Freq();
 800a6d0:	f7fe fc2a 	bl	8008f28 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 800a6d4:	b368      	cbz	r0, 800a732 <UART_SetConfig+0x2d6>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800a6d6:	6863      	ldr	r3, [r4, #4]
 800a6d8:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800a6dc:	fbb0 f0f3 	udiv	r0, r0, r3
 800a6e0:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800a6e2:	f1a0 0210 	sub.w	r2, r0, #16
 800a6e6:	f64f 73ef 	movw	r3, #65519	; 0xffef
 800a6ea:	429a      	cmp	r2, r3
 800a6ec:	d823      	bhi.n	800a736 <UART_SetConfig+0x2da>
        huart->Instance->BRR = usartdiv;
 800a6ee:	6823      	ldr	r3, [r4, #0]
 800a6f0:	60d8      	str	r0, [r3, #12]
 800a6f2:	2000      	movs	r0, #0
  huart->RxISR = NULL;
 800a6f4:	2300      	movs	r3, #0
 800a6f6:	6623      	str	r3, [r4, #96]	; 0x60
  huart->TxISR = NULL;
 800a6f8:	6663      	str	r3, [r4, #100]	; 0x64
}
 800a6fa:	bd10      	pop	{r4, pc}
        pclk = HAL_RCC_GetPCLK2Freq();
 800a6fc:	f7fe fc26 	bl	8008f4c <HAL_RCC_GetPCLK2Freq>
        break;
 800a700:	e7e8      	b.n	800a6d4 <UART_SetConfig+0x278>
        pclk = HAL_RCC_GetSysClockFreq();
 800a702:	f7fd ffc3 	bl	800868c <HAL_RCC_GetSysClockFreq>
        break;
 800a706:	e7e5      	b.n	800a6d4 <UART_SetConfig+0x278>
        pclk = (uint32_t) LSE_VALUE;
 800a708:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800a70c:	e7e3      	b.n	800a6d6 <UART_SetConfig+0x27a>
    switch (clocksource)
 800a70e:	2001      	movs	r0, #1
 800a710:	e7f0      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a712:	2000      	movs	r0, #0
 800a714:	e7ee      	b.n	800a6f4 <UART_SetConfig+0x298>
        ret = HAL_ERROR;
 800a716:	2001      	movs	r0, #1
 800a718:	e7ec      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a71a:	2001      	movs	r0, #1
 800a71c:	e7ea      	b.n	800a6f4 <UART_SetConfig+0x298>
          ret = HAL_ERROR;
 800a71e:	2001      	movs	r0, #1
 800a720:	e7e8      	b.n	800a6f4 <UART_SetConfig+0x298>
    switch (clocksource)
 800a722:	2001      	movs	r0, #1
 800a724:	e7e6      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a726:	2000      	movs	r0, #0
 800a728:	e7e4      	b.n	800a6f4 <UART_SetConfig+0x298>
        ret = HAL_ERROR;
 800a72a:	2001      	movs	r0, #1
 800a72c:	e7e2      	b.n	800a6f4 <UART_SetConfig+0x298>
    switch (clocksource)
 800a72e:	2001      	movs	r0, #1
 800a730:	e7e0      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a732:	2000      	movs	r0, #0
 800a734:	e7de      	b.n	800a6f4 <UART_SetConfig+0x298>
        ret = HAL_ERROR;
 800a736:	2001      	movs	r0, #1
 800a738:	e7dc      	b.n	800a6f4 <UART_SetConfig+0x298>
 800a73a:	bf00      	nop

0800a73c <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800a73c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a73e:	f013 0f01 	tst.w	r3, #1
 800a742:	d006      	beq.n	800a752 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800a744:	6802      	ldr	r2, [r0, #0]
 800a746:	6853      	ldr	r3, [r2, #4]
 800a748:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800a74c:	6a81      	ldr	r1, [r0, #40]	; 0x28
 800a74e:	430b      	orrs	r3, r1
 800a750:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800a752:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a754:	f013 0f02 	tst.w	r3, #2
 800a758:	d006      	beq.n	800a768 <UART_AdvFeatureConfig+0x2c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800a75a:	6802      	ldr	r2, [r0, #0]
 800a75c:	6853      	ldr	r3, [r2, #4]
 800a75e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800a762:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 800a764:	430b      	orrs	r3, r1
 800a766:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800a768:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a76a:	f013 0f04 	tst.w	r3, #4
 800a76e:	d006      	beq.n	800a77e <UART_AdvFeatureConfig+0x42>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800a770:	6802      	ldr	r2, [r0, #0]
 800a772:	6853      	ldr	r3, [r2, #4]
 800a774:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800a778:	6b01      	ldr	r1, [r0, #48]	; 0x30
 800a77a:	430b      	orrs	r3, r1
 800a77c:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800a77e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a780:	f013 0f08 	tst.w	r3, #8
 800a784:	d006      	beq.n	800a794 <UART_AdvFeatureConfig+0x58>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800a786:	6802      	ldr	r2, [r0, #0]
 800a788:	6853      	ldr	r3, [r2, #4]
 800a78a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800a78e:	6b41      	ldr	r1, [r0, #52]	; 0x34
 800a790:	430b      	orrs	r3, r1
 800a792:	6053      	str	r3, [r2, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800a794:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a796:	f013 0f10 	tst.w	r3, #16
 800a79a:	d006      	beq.n	800a7aa <UART_AdvFeatureConfig+0x6e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800a79c:	6802      	ldr	r2, [r0, #0]
 800a79e:	6893      	ldr	r3, [r2, #8]
 800a7a0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800a7a4:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800a7a6:	430b      	orrs	r3, r1
 800a7a8:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800a7aa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a7ac:	f013 0f20 	tst.w	r3, #32
 800a7b0:	d006      	beq.n	800a7c0 <UART_AdvFeatureConfig+0x84>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800a7b2:	6802      	ldr	r2, [r0, #0]
 800a7b4:	6893      	ldr	r3, [r2, #8]
 800a7b6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800a7ba:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
 800a7bc:	430b      	orrs	r3, r1
 800a7be:	6093      	str	r3, [r2, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800a7c0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a7c2:	f013 0f40 	tst.w	r3, #64	; 0x40
 800a7c6:	d00a      	beq.n	800a7de <UART_AdvFeatureConfig+0xa2>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800a7c8:	6802      	ldr	r2, [r0, #0]
 800a7ca:	6853      	ldr	r3, [r2, #4]
 800a7cc:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800a7d0:	6c01      	ldr	r1, [r0, #64]	; 0x40
 800a7d2:	430b      	orrs	r3, r1
 800a7d4:	6053      	str	r3, [r2, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800a7d6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800a7d8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800a7dc:	d00b      	beq.n	800a7f6 <UART_AdvFeatureConfig+0xba>
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800a7de:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800a7e0:	f013 0f80 	tst.w	r3, #128	; 0x80
 800a7e4:	d006      	beq.n	800a7f4 <UART_AdvFeatureConfig+0xb8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800a7e6:	6802      	ldr	r2, [r0, #0]
 800a7e8:	6853      	ldr	r3, [r2, #4]
 800a7ea:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800a7ee:	6c81      	ldr	r1, [r0, #72]	; 0x48
 800a7f0:	430b      	orrs	r3, r1
 800a7f2:	6053      	str	r3, [r2, #4]
}
 800a7f4:	4770      	bx	lr
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800a7f6:	6802      	ldr	r2, [r0, #0]
 800a7f8:	6853      	ldr	r3, [r2, #4]
 800a7fa:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 800a7fe:	6c41      	ldr	r1, [r0, #68]	; 0x44
 800a800:	430b      	orrs	r3, r1
 800a802:	6053      	str	r3, [r2, #4]
 800a804:	e7eb      	b.n	800a7de <UART_AdvFeatureConfig+0xa2>

0800a806 <UART_WaitOnFlagUntilTimeout>:
{
 800a806:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800a80a:	4605      	mov	r5, r0
 800a80c:	460f      	mov	r7, r1
 800a80e:	4616      	mov	r6, r2
 800a810:	4699      	mov	r9, r3
 800a812:	f8dd 8020 	ldr.w	r8, [sp, #32]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800a816:	682b      	ldr	r3, [r5, #0]
 800a818:	69dc      	ldr	r4, [r3, #28]
 800a81a:	ea37 0404 	bics.w	r4, r7, r4
 800a81e:	bf0c      	ite	eq
 800a820:	2401      	moveq	r4, #1
 800a822:	2400      	movne	r4, #0
 800a824:	42b4      	cmp	r4, r6
 800a826:	d13c      	bne.n	800a8a2 <UART_WaitOnFlagUntilTimeout+0x9c>
    if (Timeout != HAL_MAX_DELAY)
 800a828:	f1b8 3fff 	cmp.w	r8, #4294967295
 800a82c:	d0f3      	beq.n	800a816 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800a82e:	f7fc fbb3 	bl	8006f98 <HAL_GetTick>
 800a832:	eba0 0009 	sub.w	r0, r0, r9
 800a836:	4540      	cmp	r0, r8
 800a838:	d821      	bhi.n	800a87e <UART_WaitOnFlagUntilTimeout+0x78>
 800a83a:	f1b8 0f00 	cmp.w	r8, #0
 800a83e:	d01e      	beq.n	800a87e <UART_WaitOnFlagUntilTimeout+0x78>
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800a840:	682b      	ldr	r3, [r5, #0]
 800a842:	681a      	ldr	r2, [r3, #0]
 800a844:	f012 0f04 	tst.w	r2, #4
 800a848:	d0e5      	beq.n	800a816 <UART_WaitOnFlagUntilTimeout+0x10>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800a84a:	69da      	ldr	r2, [r3, #28]
 800a84c:	f412 6f00 	tst.w	r2, #2048	; 0x800
 800a850:	d0e1      	beq.n	800a816 <UART_WaitOnFlagUntilTimeout+0x10>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800a852:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800a856:	621a      	str	r2, [r3, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800a858:	682a      	ldr	r2, [r5, #0]
 800a85a:	6813      	ldr	r3, [r2, #0]
 800a85c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800a860:	6013      	str	r3, [r2, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a862:	682a      	ldr	r2, [r5, #0]
 800a864:	6893      	ldr	r3, [r2, #8]
 800a866:	f023 0301 	bic.w	r3, r3, #1
 800a86a:	6093      	str	r3, [r2, #8]
          huart->gState = HAL_UART_STATE_READY;
 800a86c:	2320      	movs	r3, #32
 800a86e:	676b      	str	r3, [r5, #116]	; 0x74
          huart->RxState = HAL_UART_STATE_READY;
 800a870:	67ab      	str	r3, [r5, #120]	; 0x78
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800a872:	67eb      	str	r3, [r5, #124]	; 0x7c
          __HAL_UNLOCK(huart);
 800a874:	2300      	movs	r3, #0
 800a876:	f885 3070 	strb.w	r3, [r5, #112]	; 0x70
          return HAL_TIMEOUT;
 800a87a:	2003      	movs	r0, #3
 800a87c:	e012      	b.n	800a8a4 <UART_WaitOnFlagUntilTimeout+0x9e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800a87e:	682a      	ldr	r2, [r5, #0]
 800a880:	6813      	ldr	r3, [r2, #0]
 800a882:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 800a886:	6013      	str	r3, [r2, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a888:	682a      	ldr	r2, [r5, #0]
 800a88a:	6893      	ldr	r3, [r2, #8]
 800a88c:	f023 0301 	bic.w	r3, r3, #1
 800a890:	6093      	str	r3, [r2, #8]
        huart->gState = HAL_UART_STATE_READY;
 800a892:	2320      	movs	r3, #32
 800a894:	676b      	str	r3, [r5, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 800a896:	67ab      	str	r3, [r5, #120]	; 0x78
        __HAL_UNLOCK(huart);
 800a898:	2300      	movs	r3, #0
 800a89a:	f885 3070 	strb.w	r3, [r5, #112]	; 0x70
        return HAL_TIMEOUT;
 800a89e:	2003      	movs	r0, #3
 800a8a0:	e000      	b.n	800a8a4 <UART_WaitOnFlagUntilTimeout+0x9e>
  return HAL_OK;
 800a8a2:	2000      	movs	r0, #0
}
 800a8a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800a8a8 <HAL_UART_Transmit>:
{
 800a8a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a8ac:	b082      	sub	sp, #8
 800a8ae:	461e      	mov	r6, r3
  if (huart->gState == HAL_UART_STATE_READY)
 800a8b0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a8b2:	2b20      	cmp	r3, #32
 800a8b4:	d155      	bne.n	800a962 <HAL_UART_Transmit+0xba>
 800a8b6:	4604      	mov	r4, r0
 800a8b8:	460d      	mov	r5, r1
 800a8ba:	4690      	mov	r8, r2
    if ((pData == NULL) || (Size == 0U))
 800a8bc:	2900      	cmp	r1, #0
 800a8be:	d054      	beq.n	800a96a <HAL_UART_Transmit+0xc2>
 800a8c0:	2a00      	cmp	r2, #0
 800a8c2:	d054      	beq.n	800a96e <HAL_UART_Transmit+0xc6>
    __HAL_LOCK(huart);
 800a8c4:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 800a8c8:	2b01      	cmp	r3, #1
 800a8ca:	d052      	beq.n	800a972 <HAL_UART_Transmit+0xca>
 800a8cc:	2301      	movs	r3, #1
 800a8ce:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a8d2:	2300      	movs	r3, #0
 800a8d4:	67c3      	str	r3, [r0, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800a8d6:	2321      	movs	r3, #33	; 0x21
 800a8d8:	6743      	str	r3, [r0, #116]	; 0x74
    tickstart = HAL_GetTick();
 800a8da:	f7fc fb5d 	bl	8006f98 <HAL_GetTick>
 800a8de:	4607      	mov	r7, r0
    huart->TxXferSize  = Size;
 800a8e0:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50
    huart->TxXferCount = Size;
 800a8e4:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a8e8:	68a3      	ldr	r3, [r4, #8]
 800a8ea:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800a8ee:	d005      	beq.n	800a8fc <HAL_UART_Transmit+0x54>
      pdata16bits = NULL;
 800a8f0:	f04f 0800 	mov.w	r8, #0
    __HAL_UNLOCK(huart);
 800a8f4:	2300      	movs	r3, #0
 800a8f6:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
    while (huart->TxXferCount > 0U)
 800a8fa:	e014      	b.n	800a926 <HAL_UART_Transmit+0x7e>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800a8fc:	6923      	ldr	r3, [r4, #16]
 800a8fe:	b113      	cbz	r3, 800a906 <HAL_UART_Transmit+0x5e>
      pdata16bits = NULL;
 800a900:	f04f 0800 	mov.w	r8, #0
 800a904:	e7f6      	b.n	800a8f4 <HAL_UART_Transmit+0x4c>
      pdata16bits = (uint16_t *) pData;
 800a906:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 800a908:	2500      	movs	r5, #0
 800a90a:	e7f3      	b.n	800a8f4 <HAL_UART_Transmit+0x4c>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800a90c:	f838 3b02 	ldrh.w	r3, [r8], #2
 800a910:	6822      	ldr	r2, [r4, #0]
 800a912:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a916:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 800a918:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
 800a91c:	b292      	uxth	r2, r2
 800a91e:	3a01      	subs	r2, #1
 800a920:	b292      	uxth	r2, r2
 800a922:	f8a4 2052 	strh.w	r2, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 800a926:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 800a92a:	b29b      	uxth	r3, r3
 800a92c:	b173      	cbz	r3, 800a94c <HAL_UART_Transmit+0xa4>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800a92e:	9600      	str	r6, [sp, #0]
 800a930:	463b      	mov	r3, r7
 800a932:	2200      	movs	r2, #0
 800a934:	2180      	movs	r1, #128	; 0x80
 800a936:	4620      	mov	r0, r4
 800a938:	f7ff ff65 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a93c:	b9d8      	cbnz	r0, 800a976 <HAL_UART_Transmit+0xce>
      if (pdata8bits == NULL)
 800a93e:	2d00      	cmp	r5, #0
 800a940:	d0e4      	beq.n	800a90c <HAL_UART_Transmit+0x64>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800a942:	6823      	ldr	r3, [r4, #0]
 800a944:	f815 2b01 	ldrb.w	r2, [r5], #1
 800a948:	851a      	strh	r2, [r3, #40]	; 0x28
        pdata8bits++;
 800a94a:	e7e5      	b.n	800a918 <HAL_UART_Transmit+0x70>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800a94c:	9600      	str	r6, [sp, #0]
 800a94e:	463b      	mov	r3, r7
 800a950:	2200      	movs	r2, #0
 800a952:	2140      	movs	r1, #64	; 0x40
 800a954:	4620      	mov	r0, r4
 800a956:	f7ff ff56 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a95a:	b970      	cbnz	r0, 800a97a <HAL_UART_Transmit+0xd2>
    huart->gState = HAL_UART_STATE_READY;
 800a95c:	2320      	movs	r3, #32
 800a95e:	6763      	str	r3, [r4, #116]	; 0x74
    return HAL_OK;
 800a960:	e000      	b.n	800a964 <HAL_UART_Transmit+0xbc>
    return HAL_BUSY;
 800a962:	2002      	movs	r0, #2
}
 800a964:	b002      	add	sp, #8
 800a966:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 800a96a:	2001      	movs	r0, #1
 800a96c:	e7fa      	b.n	800a964 <HAL_UART_Transmit+0xbc>
 800a96e:	2001      	movs	r0, #1
 800a970:	e7f8      	b.n	800a964 <HAL_UART_Transmit+0xbc>
    __HAL_LOCK(huart);
 800a972:	2002      	movs	r0, #2
 800a974:	e7f6      	b.n	800a964 <HAL_UART_Transmit+0xbc>
        return HAL_TIMEOUT;
 800a976:	2003      	movs	r0, #3
 800a978:	e7f4      	b.n	800a964 <HAL_UART_Transmit+0xbc>
      return HAL_TIMEOUT;
 800a97a:	2003      	movs	r0, #3
 800a97c:	e7f2      	b.n	800a964 <HAL_UART_Transmit+0xbc>

0800a97e <UART_CheckIdleState>:
{
 800a97e:	b530      	push	{r4, r5, lr}
 800a980:	b083      	sub	sp, #12
 800a982:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800a984:	2300      	movs	r3, #0
 800a986:	67c3      	str	r3, [r0, #124]	; 0x7c
  tickstart = HAL_GetTick();
 800a988:	f7fc fb06 	bl	8006f98 <HAL_GetTick>
 800a98c:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800a98e:	6822      	ldr	r2, [r4, #0]
 800a990:	6812      	ldr	r2, [r2, #0]
 800a992:	f012 0f08 	tst.w	r2, #8
 800a996:	d10c      	bne.n	800a9b2 <UART_CheckIdleState+0x34>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800a998:	6823      	ldr	r3, [r4, #0]
 800a99a:	681b      	ldr	r3, [r3, #0]
 800a99c:	f013 0f04 	tst.w	r3, #4
 800a9a0:	d115      	bne.n	800a9ce <UART_CheckIdleState+0x50>
  huart->gState = HAL_UART_STATE_READY;
 800a9a2:	2320      	movs	r3, #32
 800a9a4:	6763      	str	r3, [r4, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 800a9a6:	67a3      	str	r3, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 800a9a8:	2000      	movs	r0, #0
 800a9aa:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
}
 800a9ae:	b003      	add	sp, #12
 800a9b0:	bd30      	pop	{r4, r5, pc}
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800a9b2:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800a9b6:	9300      	str	r3, [sp, #0]
 800a9b8:	4603      	mov	r3, r0
 800a9ba:	2200      	movs	r2, #0
 800a9bc:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800a9c0:	4620      	mov	r0, r4
 800a9c2:	f7ff ff20 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a9c6:	2800      	cmp	r0, #0
 800a9c8:	d0e6      	beq.n	800a998 <UART_CheckIdleState+0x1a>
      return HAL_TIMEOUT;
 800a9ca:	2003      	movs	r0, #3
 800a9cc:	e7ef      	b.n	800a9ae <UART_CheckIdleState+0x30>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800a9ce:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 800a9d2:	9300      	str	r3, [sp, #0]
 800a9d4:	462b      	mov	r3, r5
 800a9d6:	2200      	movs	r2, #0
 800a9d8:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 800a9dc:	4620      	mov	r0, r4
 800a9de:	f7ff ff12 	bl	800a806 <UART_WaitOnFlagUntilTimeout>
 800a9e2:	2800      	cmp	r0, #0
 800a9e4:	d0dd      	beq.n	800a9a2 <UART_CheckIdleState+0x24>
      return HAL_TIMEOUT;
 800a9e6:	2003      	movs	r0, #3
 800a9e8:	e7e1      	b.n	800a9ae <UART_CheckIdleState+0x30>

0800a9ea <HAL_UART_Init>:
  if (huart == NULL)
 800a9ea:	b368      	cbz	r0, 800aa48 <HAL_UART_Init+0x5e>
{
 800a9ec:	b510      	push	{r4, lr}
 800a9ee:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_RESET)
 800a9f0:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800a9f2:	b303      	cbz	r3, 800aa36 <HAL_UART_Init+0x4c>
  huart->gState = HAL_UART_STATE_BUSY;
 800a9f4:	2324      	movs	r3, #36	; 0x24
 800a9f6:	6763      	str	r3, [r4, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 800a9f8:	6822      	ldr	r2, [r4, #0]
 800a9fa:	6813      	ldr	r3, [r2, #0]
 800a9fc:	f023 0301 	bic.w	r3, r3, #1
 800aa00:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 800aa02:	4620      	mov	r0, r4
 800aa04:	f7ff fd2a 	bl	800a45c <UART_SetConfig>
 800aa08:	2801      	cmp	r0, #1
 800aa0a:	d013      	beq.n	800aa34 <HAL_UART_Init+0x4a>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800aa0c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800aa0e:	b9bb      	cbnz	r3, 800aa40 <HAL_UART_Init+0x56>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800aa10:	6822      	ldr	r2, [r4, #0]
 800aa12:	6853      	ldr	r3, [r2, #4]
 800aa14:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800aa18:	6053      	str	r3, [r2, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800aa1a:	6822      	ldr	r2, [r4, #0]
 800aa1c:	6893      	ldr	r3, [r2, #8]
 800aa1e:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 800aa22:	6093      	str	r3, [r2, #8]
  __HAL_UART_ENABLE(huart);
 800aa24:	6822      	ldr	r2, [r4, #0]
 800aa26:	6813      	ldr	r3, [r2, #0]
 800aa28:	f043 0301 	orr.w	r3, r3, #1
 800aa2c:	6013      	str	r3, [r2, #0]
  return (UART_CheckIdleState(huart));
 800aa2e:	4620      	mov	r0, r4
 800aa30:	f7ff ffa5 	bl	800a97e <UART_CheckIdleState>
}
 800aa34:	bd10      	pop	{r4, pc}
    huart->Lock = HAL_UNLOCKED;
 800aa36:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 800aa3a:	f7f7 f833 	bl	8001aa4 <HAL_UART_MspInit>
 800aa3e:	e7d9      	b.n	800a9f4 <HAL_UART_Init+0xa>
    UART_AdvFeatureConfig(huart);
 800aa40:	4620      	mov	r0, r4
 800aa42:	f7ff fe7b 	bl	800a73c <UART_AdvFeatureConfig>
 800aa46:	e7e3      	b.n	800aa10 <HAL_UART_Init+0x26>
    return HAL_ERROR;
 800aa48:	2001      	movs	r0, #1
}
 800aa4a:	4770      	bx	lr

0800aa4c <HAL_UARTEx_WakeupCallback>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 800aa4c:	4770      	bx	lr

0800aa4e <USB_CoreInit>:
  * @param  cfg : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800aa4e:	b084      	sub	sp, #16
 800aa50:	a801      	add	r0, sp, #4
 800aa52:	e880 000e 	stmia.w	r0, {r1, r2, r3}
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */

  return HAL_OK;
}
 800aa56:	2000      	movs	r0, #0
 800aa58:	b004      	add	sp, #16
 800aa5a:	4770      	bx	lr

0800aa5c <USB_DisableGlobalInt>:
                   USB_CNTR_SUSPM | USB_CNTR_ERRM |
                   USB_CNTR_SOFM | USB_CNTR_ESOFM |
                   USB_CNTR_RESETM | USB_CNTR_L1REQM;

  /* Clear interrupt mask */
  USBx->CNTR &= (uint16_t)(~winterruptmask);
 800aa5c:	f8b0 3040 	ldrh.w	r3, [r0, #64]	; 0x40
 800aa60:	f423 537e 	bic.w	r3, r3, #16256	; 0x3f80
 800aa64:	045b      	lsls	r3, r3, #17
 800aa66:	0c5b      	lsrs	r3, r3, #17
 800aa68:	f8a0 3040 	strh.w	r3, [r0, #64]	; 0x40

  return HAL_OK;
}
 800aa6c:	2000      	movs	r0, #0
 800aa6e:	4770      	bx	lr

0800aa70 <USB_SetCurrentMode>:
  /* NOTE : - This function is not required by USB Device FS peripheral, it is used
              only by USB OTG FS peripheral.
            - This function is added to ensure compatibility across platforms.
   */
  return HAL_OK;
}
 800aa70:	2000      	movs	r0, #0
 800aa72:	4770      	bx	lr

0800aa74 <USB_DevInit>:
  * @param  cfg  : pointer to a USB_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_DevInit(USB_TypeDef *USBx, USB_CfgTypeDef cfg)
{
 800aa74:	b084      	sub	sp, #16
 800aa76:	4684      	mov	ip, r0
 800aa78:	a801      	add	r0, sp, #4
 800aa7a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  /* Prevent unused argument(s) compilation warning */
  UNUSED(cfg);

  /* Init Device */
  /*CNTR_FRES = 1*/
  USBx->CNTR = (uint16_t)USB_CNTR_FRES;
 800aa7e:	2301      	movs	r3, #1
 800aa80:	f8ac 3040 	strh.w	r3, [ip, #64]	; 0x40

  /*CNTR_FRES = 0*/
  USBx->CNTR = 0U;
 800aa84:	2000      	movs	r0, #0
 800aa86:	f8ac 0040 	strh.w	r0, [ip, #64]	; 0x40

  /*Clear pending interrupts*/
  USBx->ISTR = 0U;
 800aa8a:	f8ac 0044 	strh.w	r0, [ip, #68]	; 0x44

  /*Set Btable Address*/
  USBx->BTABLE = BTABLE_ADDRESS;
 800aa8e:	f8ac 0050 	strh.w	r0, [ip, #80]	; 0x50

  return HAL_OK;
}
 800aa92:	b004      	add	sp, #16
 800aa94:	4770      	bx	lr

0800aa96 <USB_DevDisconnect>:
  * @retval HAL status
  */
HAL_StatusTypeDef  USB_DevDisconnect(USB_TypeDef *USBx)
{
  /* Disable DP Pull-Up bit to disconnect the Internal PU resistor on USB DP line */
  USBx->BCDR &= (uint16_t)(~(USB_BCDR_DPPU));
 800aa96:	f8b0 3058 	ldrh.w	r3, [r0, #88]	; 0x58
 800aa9a:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800aa9e:	f8a0 3058 	strh.w	r3, [r0, #88]	; 0x58

  return HAL_OK;
}
 800aaa2:	2000      	movs	r0, #0
 800aaa4:	4770      	bx	lr
	...

0800aaa8 <find_deviceType_ATHandle>:

  return (retval);
}

static at_handle_t find_deviceType_ATHandle(sysctrl_device_type_t deviceType)
{
 800aaa8:	4602      	mov	r2, r0
  at_handle_t retval = AT_HANDLE_INVALID; /* default value */
  at_handle_t idx = 0;
 800aaaa:	2000      	movs	r0, #0

  /* find handle */
  while (idx < ATCORE_MAX_HANDLES)
 800aaac:	2800      	cmp	r0, #0
 800aaae:	dd02      	ble.n	800aab6 <find_deviceType_ATHandle+0xe>
  at_handle_t retval = AT_HANDLE_INVALID; /* default value */
 800aab0:	f04f 30ff 	mov.w	r0, #4294967295
    }
    idx++;
  }

  return (retval);
}
 800aab4:	4770      	bx	lr
    if (at_context[idx].device_type == deviceType)
 800aab6:	f240 639c 	movw	r3, #1692	; 0x69c
 800aaba:	fb00 f303 	mul.w	r3, r0, r3
 800aabe:	4903      	ldr	r1, [pc, #12]	; (800aacc <find_deviceType_ATHandle+0x24>)
 800aac0:	5ccb      	ldrb	r3, [r1, r3]
 800aac2:	4293      	cmp	r3, r2
 800aac4:	d0f6      	beq.n	800aab4 <find_deviceType_ATHandle+0xc>
    idx++;
 800aac6:	1c43      	adds	r3, r0, #1
 800aac8:	b218      	sxth	r0, r3
 800aaca:	e7ef      	b.n	800aaac <find_deviceType_ATHandle+0x4>
 800aacc:	2000188c 	.word	0x2000188c

0800aad0 <IRQ_DISABLE>:
  __ASM volatile ("cpsid i" : : : "memory");
 800aad0:	b672      	cpsid	i
}

static void IRQ_DISABLE(void)
{
  __disable_irq();
}
 800aad2:	4770      	bx	lr

0800aad4 <IRQ_ENABLE>:
  __ASM volatile ("cpsie i" : : : "memory");
 800aad4:	b662      	cpsie	i

static void IRQ_ENABLE(void)
{
  __enable_irq();
}
 800aad6:	4770      	bx	lr

0800aad8 <findMsgReceivedHandle>:

  return (retval);
}

static at_status_t findMsgReceivedHandle(at_handle_t *athandle)
{
 800aad8:	4603      	mov	r3, r0
  bool leave_loop = false;
  at_handle_t i = 0;

  do
  {
    if (MsgReceived[i] != 0U)
 800aada:	4a04      	ldr	r2, [pc, #16]	; (800aaec <findMsgReceivedHandle+0x14>)
 800aadc:	7812      	ldrb	r2, [r2, #0]
 800aade:	b112      	cbz	r2, 800aae6 <findMsgReceivedHandle+0xe>
    {
      *athandle = (at_handle_t) i;
 800aae0:	2000      	movs	r0, #0
 800aae2:	8018      	strh	r0, [r3, #0]
      retval = ATSTATUS_OK;
      leave_loop = true;
 800aae4:	4770      	bx	lr
 800aae6:	2001      	movs	r0, #1
    }
    i++;
  } while ((leave_loop == false) && (i < ATCORE_MAX_HANDLES));

  return (retval);
}
 800aae8:	4770      	bx	lr
 800aaea:	bf00      	nop
 800aaec:	20001888 	.word	0x20001888

0800aaf0 <allocate_ATHandle>:
{
 800aaf0:	b538      	push	{r3, r4, r5, lr}
 800aaf2:	4605      	mov	r5, r0
  at_handle_t idx = 0;
 800aaf4:	2400      	movs	r4, #0
  while ((idx < ATCORE_MAX_HANDLES) && (at_context[idx].device_type != DEVTYPE_INVALID))
 800aaf6:	2c00      	cmp	r4, #0
 800aaf8:	dc0a      	bgt.n	800ab10 <allocate_ATHandle+0x20>
 800aafa:	f240 639c 	movw	r3, #1692	; 0x69c
 800aafe:	fb04 f303 	mul.w	r3, r4, r3
 800ab02:	4a09      	ldr	r2, [pc, #36]	; (800ab28 <allocate_ATHandle+0x38>)
 800ab04:	5cd3      	ldrb	r3, [r2, r3]
 800ab06:	2b01      	cmp	r3, #1
 800ab08:	d002      	beq.n	800ab10 <allocate_ATHandle+0x20>
    idx++;
 800ab0a:	3401      	adds	r4, #1
 800ab0c:	b224      	sxth	r4, r4
 800ab0e:	e7f2      	b.n	800aaf6 <allocate_ATHandle+0x6>
  if (idx == ATCORE_MAX_HANDLES)
 800ab10:	2c01      	cmp	r4, #1
 800ab12:	d002      	beq.n	800ab1a <allocate_ATHandle+0x2a>
  at_status_t retval = ATSTATUS_OK;
 800ab14:	2000      	movs	r0, #0
  *athandle = (at_handle_t) idx;
 800ab16:	802c      	strh	r4, [r5, #0]
}
 800ab18:	bd38      	pop	{r3, r4, r5, pc}
    LOG_ERROR(6, ERROR_WARNING);
 800ab1a:	2202      	movs	r2, #2
 800ab1c:	2106      	movs	r1, #6
 800ab1e:	4610      	mov	r0, r2
 800ab20:	f013 fc20 	bl	801e364 <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800ab24:	2001      	movs	r0, #1
 800ab26:	e7f6      	b.n	800ab16 <allocate_ATHandle+0x26>
 800ab28:	2000188c 	.word	0x2000188c

0800ab2c <find_index>:
{
 800ab2c:	b508      	push	{r3, lr}
    if (&ipcHandleTab[idx] == ipcHandle)
 800ab2e:	4b05      	ldr	r3, [pc, #20]	; (800ab44 <find_index+0x18>)
 800ab30:	4283      	cmp	r3, r0
 800ab32:	d004      	beq.n	800ab3e <find_index+0x12>
    LOG_ERROR(5, ERROR_FATAL);
 800ab34:	2203      	movs	r2, #3
 800ab36:	2105      	movs	r1, #5
 800ab38:	2002      	movs	r0, #2
 800ab3a:	f013 fc13 	bl	801e364 <ERROR_Handler>
}
 800ab3e:	2000      	movs	r0, #0
 800ab40:	bd08      	pop	{r3, pc}
 800ab42:	bf00      	nop
 800ab44:	20002570 	.word	0x20002570

0800ab48 <waitOnMsgUntilTimeout>:
{
 800ab48:	b570      	push	{r4, r5, r6, lr}
 800ab4a:	4615      	mov	r5, r2
  TRACE_DBG("**** Waiting Sema (to=%lu) *****", Timeout)
 800ab4c:	4c2c      	ldr	r4, [pc, #176]	; (800ac00 <waitOnMsgUntilTimeout+0xb8>)
 800ab4e:	492d      	ldr	r1, [pc, #180]	; (800ac04 <waitOnMsgUntilTimeout+0xbc>)
 800ab50:	4620      	mov	r0, r4
 800ab52:	f01b fe79 	bl	8026848 <sprintf>
 800ab56:	4620      	mov	r0, r4
 800ab58:	f014 fbe7 	bl	801f32a <crs_strlen>
 800ab5c:	b283      	uxth	r3, r0
 800ab5e:	4622      	mov	r2, r4
 800ab60:	2102      	movs	r1, #2
 800ab62:	4608      	mov	r0, r1
 800ab64:	f014 fc24 	bl	801f3b0 <traceIF_itmPrint>
 800ab68:	4620      	mov	r0, r4
 800ab6a:	f014 fbde 	bl	801f32a <crs_strlen>
 800ab6e:	b283      	uxth	r3, r0
 800ab70:	4622      	mov	r2, r4
 800ab72:	2102      	movs	r1, #2
 800ab74:	4608      	mov	r0, r1
 800ab76:	f014 fc3d 	bl	801f3f4 <traceIF_uartPrint>
  if (rtosalSemaphoreAcquire(s_WaitAnswer_SemaphoreId, Timeout) != ((rtosalStatus)osOK))
 800ab7a:	4629      	mov	r1, r5
 800ab7c:	4b22      	ldr	r3, [pc, #136]	; (800ac08 <waitOnMsgUntilTimeout+0xc0>)
 800ab7e:	6818      	ldr	r0, [r3, #0]
 800ab80:	f014 fadb 	bl	801f13a <rtosalSemaphoreAcquire>
 800ab84:	bb18      	cbnz	r0, 800abce <waitOnMsgUntilTimeout+0x86>
  at_status_t retval = ATSTATUS_OK;
 800ab86:	2600      	movs	r6, #0
  TRACE_DBG("**** Sema Freed *****")
 800ab88:	4c1d      	ldr	r4, [pc, #116]	; (800ac00 <waitOnMsgUntilTimeout+0xb8>)
 800ab8a:	4d20      	ldr	r5, [pc, #128]	; (800ac0c <waitOnMsgUntilTimeout+0xc4>)
 800ab8c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ab8e:	6020      	str	r0, [r4, #0]
 800ab90:	6061      	str	r1, [r4, #4]
 800ab92:	60a2      	str	r2, [r4, #8]
 800ab94:	60e3      	str	r3, [r4, #12]
 800ab96:	cd07      	ldmia	r5!, {r0, r1, r2}
 800ab98:	6120      	str	r0, [r4, #16]
 800ab9a:	6161      	str	r1, [r4, #20]
 800ab9c:	61a2      	str	r2, [r4, #24]
 800ab9e:	882a      	ldrh	r2, [r5, #0]
 800aba0:	78ab      	ldrb	r3, [r5, #2]
 800aba2:	83a2      	strh	r2, [r4, #28]
 800aba4:	77a3      	strb	r3, [r4, #30]
 800aba6:	4620      	mov	r0, r4
 800aba8:	f014 fbbf 	bl	801f32a <crs_strlen>
 800abac:	b283      	uxth	r3, r0
 800abae:	4622      	mov	r2, r4
 800abb0:	2102      	movs	r1, #2
 800abb2:	4608      	mov	r0, r1
 800abb4:	f014 fbfc 	bl	801f3b0 <traceIF_itmPrint>
 800abb8:	4620      	mov	r0, r4
 800abba:	f014 fbb6 	bl	801f32a <crs_strlen>
 800abbe:	b283      	uxth	r3, r0
 800abc0:	4622      	mov	r2, r4
 800abc2:	2102      	movs	r1, #2
 800abc4:	4608      	mov	r0, r1
 800abc6:	f014 fc15 	bl	801f3f4 <traceIF_uartPrint>
}
 800abca:	4630      	mov	r0, r6
 800abcc:	bd70      	pop	{r4, r5, r6, pc}
    TRACE_DBG("**** Sema Timeout (=%ld) !!! *****", Timeout)
 800abce:	462a      	mov	r2, r5
 800abd0:	490f      	ldr	r1, [pc, #60]	; (800ac10 <waitOnMsgUntilTimeout+0xc8>)
 800abd2:	4620      	mov	r0, r4
 800abd4:	f01b fe38 	bl	8026848 <sprintf>
 800abd8:	4620      	mov	r0, r4
 800abda:	f014 fba6 	bl	801f32a <crs_strlen>
 800abde:	b283      	uxth	r3, r0
 800abe0:	4622      	mov	r2, r4
 800abe2:	2102      	movs	r1, #2
 800abe4:	4608      	mov	r0, r1
 800abe6:	f014 fbe3 	bl	801f3b0 <traceIF_itmPrint>
 800abea:	4620      	mov	r0, r4
 800abec:	f014 fb9d 	bl	801f32a <crs_strlen>
 800abf0:	b283      	uxth	r3, r0
 800abf2:	4622      	mov	r2, r4
 800abf4:	2102      	movs	r1, #2
 800abf6:	4608      	mov	r0, r1
 800abf8:	f014 fbfc 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_TIMEOUT;
 800abfc:	2602      	movs	r6, #2
 800abfe:	e7c3      	b.n	800ab88 <waitOnMsgUntilTimeout+0x40>
 800ac00:	200048dc 	.word	0x200048dc
 800ac04:	0802dcb8 	.word	0x0802dcb8
 800ac08:	20003544 	.word	0x20003544
 800ac0c:	0802dd10 	.word	0x0802dd10
 800ac10:	0802dce4 	.word	0x0802dce4

0800ac14 <waitFromIPC>:
{
 800ac14:	b570      	push	{r4, r5, r6, lr}
 800ac16:	4614      	mov	r4, r2
  retval = waitOnMsgUntilTimeout(athandle, tickstart, cmdTimeout);
 800ac18:	f7ff ff96 	bl	800ab48 <waitOnMsgUntilTimeout>
  if (retval != ATSTATUS_OK)
 800ac1c:	4605      	mov	r5, r0
 800ac1e:	b100      	cbz	r0, 800ac22 <waitFromIPC+0xe>
    if (cmdTimeout != 0U)
 800ac20:	b90c      	cbnz	r4, 800ac26 <waitFromIPC+0x12>
}
 800ac22:	4628      	mov	r0, r5
 800ac24:	bd70      	pop	{r4, r5, r6, pc}
      TRACE_INFO("TIMEOUT EVENT(%ld ms)", cmdTimeout)
 800ac26:	4e0c      	ldr	r6, [pc, #48]	; (800ac58 <waitFromIPC+0x44>)
 800ac28:	4622      	mov	r2, r4
 800ac2a:	490c      	ldr	r1, [pc, #48]	; (800ac5c <waitFromIPC+0x48>)
 800ac2c:	4630      	mov	r0, r6
 800ac2e:	f01b fe0b 	bl	8026848 <sprintf>
 800ac32:	4630      	mov	r0, r6
 800ac34:	f014 fb79 	bl	801f32a <crs_strlen>
 800ac38:	b283      	uxth	r3, r0
 800ac3a:	4632      	mov	r2, r6
 800ac3c:	2101      	movs	r1, #1
 800ac3e:	2002      	movs	r0, #2
 800ac40:	f014 fbb6 	bl	801f3b0 <traceIF_itmPrint>
 800ac44:	4630      	mov	r0, r6
 800ac46:	f014 fb70 	bl	801f32a <crs_strlen>
 800ac4a:	b283      	uxth	r3, r0
 800ac4c:	4632      	mov	r2, r6
 800ac4e:	2101      	movs	r1, #1
 800ac50:	2002      	movs	r0, #2
 800ac52:	f014 fbcf 	bl	801f3f4 <traceIF_uartPrint>
 800ac56:	e7e4      	b.n	800ac22 <waitFromIPC+0xe>
 800ac58:	200048dc 	.word	0x200048dc
 800ac5c:	0802dd30 	.word	0x0802dd30

0800ac60 <msgSentCallback>:
{
 800ac60:	b508      	push	{r3, lr}
  uint8_t index = find_index(ipcHandle);
 800ac62:	f7ff ff63 	bl	800ab2c <find_index>
  at_context[index].dataSent = AT_TRUE;
 800ac66:	4b06      	ldr	r3, [pc, #24]	; (800ac80 <msgSentCallback+0x20>)
 800ac68:	f240 629c 	movw	r2, #1692	; 0x69c
 800ac6c:	fb02 3000 	mla	r0, r2, r0, r3
 800ac70:	2301      	movs	r3, #1
 800ac72:	7303      	strb	r3, [r0, #12]
  (void) rtosalSemaphoreRelease(at_context[index].s_SendConfirm_SemaphoreId);
 800ac74:	f8d0 0698 	ldr.w	r0, [r0, #1688]	; 0x698
 800ac78:	f014 fa63 	bl	801f142 <rtosalSemaphoreRelease>
}
 800ac7c:	bd08      	pop	{r3, pc}
 800ac7e:	bf00      	nop
 800ac80:	2000188c 	.word	0x2000188c

0800ac84 <msgReceivedCallback>:
{
 800ac84:	b538      	push	{r3, r4, r5, lr}
  uint8_t index = find_index(ipcHandle);
 800ac86:	f7ff ff51 	bl	800ab2c <find_index>
  MsgReceived[index]++;
 800ac8a:	4a1b      	ldr	r2, [pc, #108]	; (800acf8 <msgReceivedCallback+0x74>)
 800ac8c:	5c13      	ldrb	r3, [r2, r0]
 800ac8e:	3301      	adds	r3, #1
 800ac90:	b2db      	uxtb	r3, r3
 800ac92:	5413      	strb	r3, [r2, r0]
  if (rtosalMessageQueuePut(q_msg_IPC_received_Id,
 800ac94:	2200      	movs	r2, #0
 800ac96:	2101      	movs	r1, #1
 800ac98:	4b18      	ldr	r3, [pc, #96]	; (800acfc <msgReceivedCallback+0x78>)
 800ac9a:	6818      	ldr	r0, [r3, #0]
 800ac9c:	f014 fa73 	bl	801f186 <rtosalMessageQueuePut>
 800aca0:	b900      	cbnz	r0, 800aca4 <msgReceivedCallback+0x20>
}
 800aca2:	bd38      	pop	{r3, r4, r5, pc}
    TRACE_ERR("q_msg_IPC_received_Id error for SIG_IPC_MSG")
 800aca4:	4d16      	ldr	r5, [pc, #88]	; (800ad00 <msgReceivedCallback+0x7c>)
 800aca6:	4c17      	ldr	r4, [pc, #92]	; (800ad04 <msgReceivedCallback+0x80>)
 800aca8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 800acac:	46ac      	mov	ip, r5
 800acae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800acb2:	6020      	str	r0, [r4, #0]
 800acb4:	6061      	str	r1, [r4, #4]
 800acb6:	60a2      	str	r2, [r4, #8]
 800acb8:	60e3      	str	r3, [r4, #12]
 800acba:	4665      	mov	r5, ip
 800acbc:	3410      	adds	r4, #16
 800acbe:	45f4      	cmp	ip, lr
 800acc0:	d1f4      	bne.n	800acac <msgReceivedCallback+0x28>
 800acc2:	cd03      	ldmia	r5!, {r0, r1}
 800acc4:	6020      	str	r0, [r4, #0]
 800acc6:	6061      	str	r1, [r4, #4]
 800acc8:	882a      	ldrh	r2, [r5, #0]
 800acca:	78ab      	ldrb	r3, [r5, #2]
 800accc:	8122      	strh	r2, [r4, #8]
 800acce:	72a3      	strb	r3, [r4, #10]
 800acd0:	4c0c      	ldr	r4, [pc, #48]	; (800ad04 <msgReceivedCallback+0x80>)
 800acd2:	4620      	mov	r0, r4
 800acd4:	f014 fb29 	bl	801f32a <crs_strlen>
 800acd8:	b283      	uxth	r3, r0
 800acda:	4622      	mov	r2, r4
 800acdc:	2110      	movs	r1, #16
 800acde:	2002      	movs	r0, #2
 800ace0:	f014 fb66 	bl	801f3b0 <traceIF_itmPrint>
 800ace4:	4620      	mov	r0, r4
 800ace6:	f014 fb20 	bl	801f32a <crs_strlen>
 800acea:	b283      	uxth	r3, r0
 800acec:	4622      	mov	r2, r4
 800acee:	2110      	movs	r1, #16
 800acf0:	2002      	movs	r0, #2
 800acf2:	f014 fb7f 	bl	801f3f4 <traceIF_uartPrint>
}
 800acf6:	e7d4      	b.n	800aca2 <msgReceivedCallback+0x1e>
 800acf8:	20001888 	.word	0x20001888
 800acfc:	2000353c 	.word	0x2000353c
 800ad00:	0802dd50 	.word	0x0802dd50
 800ad04:	200048dc 	.word	0x200048dc

0800ad08 <sendToIPC>:
{
 800ad08:	b570      	push	{r4, r5, r6, lr}
 800ad0a:	4605      	mov	r5, r0
  if (IPC_send(at_context[athandle].ipc_handle, cmdBuf, cmdSize) == IPC_ERROR)
 800ad0c:	4b21      	ldr	r3, [pc, #132]	; (800ad94 <sendToIPC+0x8c>)
 800ad0e:	f240 609c 	movw	r0, #1692	; 0x69c
 800ad12:	fb00 3305 	mla	r3, r0, r5, r3
 800ad16:	6858      	ldr	r0, [r3, #4]
 800ad18:	f013 fc38 	bl	801e58c <IPC_send>
 800ad1c:	2801      	cmp	r0, #1
 800ad1e:	d00e      	beq.n	800ad3e <sendToIPC+0x36>
    (void) rtosalSemaphoreAcquire(at_context[athandle].s_SendConfirm_SemaphoreId, 5000U);
 800ad20:	4c1c      	ldr	r4, [pc, #112]	; (800ad94 <sendToIPC+0x8c>)
 800ad22:	f240 639c 	movw	r3, #1692	; 0x69c
 800ad26:	fb03 4405 	mla	r4, r3, r5, r4
 800ad2a:	f241 3188 	movw	r1, #5000	; 0x1388
 800ad2e:	f8d4 0698 	ldr.w	r0, [r4, #1688]	; 0x698
 800ad32:	f014 fa02 	bl	801f13a <rtosalSemaphoreAcquire>
    if (at_context[athandle].dataSent == AT_TRUE)
 800ad36:	7b23      	ldrb	r3, [r4, #12]
 800ad38:	b353      	cbz	r3, 800ad90 <sendToIPC+0x88>
      retval = ATSTATUS_OK;
 800ad3a:	2400      	movs	r4, #0
 800ad3c:	e026      	b.n	800ad8c <sendToIPC+0x84>
 800ad3e:	4604      	mov	r4, r0
    TRACE_ERR(" IPC send error")
 800ad40:	4d15      	ldr	r5, [pc, #84]	; (800ad98 <sendToIPC+0x90>)
 800ad42:	4e16      	ldr	r6, [pc, #88]	; (800ad9c <sendToIPC+0x94>)
 800ad44:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800ad46:	6028      	str	r0, [r5, #0]
 800ad48:	6069      	str	r1, [r5, #4]
 800ad4a:	60aa      	str	r2, [r5, #8]
 800ad4c:	60eb      	str	r3, [r5, #12]
 800ad4e:	ce07      	ldmia	r6!, {r0, r1, r2}
 800ad50:	6128      	str	r0, [r5, #16]
 800ad52:	6169      	str	r1, [r5, #20]
 800ad54:	61aa      	str	r2, [r5, #24]
 800ad56:	8832      	ldrh	r2, [r6, #0]
 800ad58:	78b3      	ldrb	r3, [r6, #2]
 800ad5a:	83aa      	strh	r2, [r5, #28]
 800ad5c:	77ab      	strb	r3, [r5, #30]
 800ad5e:	4628      	mov	r0, r5
 800ad60:	f014 fae3 	bl	801f32a <crs_strlen>
 800ad64:	b283      	uxth	r3, r0
 800ad66:	462a      	mov	r2, r5
 800ad68:	2110      	movs	r1, #16
 800ad6a:	2002      	movs	r0, #2
 800ad6c:	f014 fb20 	bl	801f3b0 <traceIF_itmPrint>
 800ad70:	4628      	mov	r0, r5
 800ad72:	f014 fada 	bl	801f32a <crs_strlen>
 800ad76:	b283      	uxth	r3, r0
 800ad78:	462a      	mov	r2, r5
 800ad7a:	2110      	movs	r1, #16
 800ad7c:	2002      	movs	r0, #2
 800ad7e:	f014 fb39 	bl	801f3f4 <traceIF_uartPrint>
    LOG_ERROR(15, ERROR_WARNING);
 800ad82:	2202      	movs	r2, #2
 800ad84:	210f      	movs	r1, #15
 800ad86:	4610      	mov	r0, r2
 800ad88:	f013 faec 	bl	801e364 <ERROR_Handler>
}
 800ad8c:	4620      	mov	r0, r4
 800ad8e:	bd70      	pop	{r4, r5, r6, pc}
      retval = ATSTATUS_ERROR;
 800ad90:	2401      	movs	r4, #1
 800ad92:	e7fb      	b.n	800ad8c <sendToIPC+0x84>
 800ad94:	2000188c 	.word	0x2000188c
 800ad98:	200048dc 	.word	0x200048dc
 800ad9c:	0802dd8c 	.word	0x0802dd8c

0800ada0 <process_answer>:
{
 800ada0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800ada4:	4604      	mov	r4, r0
 800ada6:	460f      	mov	r7, r1
 800ada8:	4616      	mov	r6, r2
  uint32_t tickstart = HAL_GetTick();
 800adaa:	f7fc f8f5 	bl	8006f98 <HAL_GetTick>
 800adae:	4605      	mov	r5, r0
    waitIPCstatus = waitFromIPC(athandle, tickstart, at_cmd_timeout, &msgFromIPC[athandle]);
 800adb0:	4b61      	ldr	r3, [pc, #388]	; (800af38 <process_answer+0x198>)
 800adb2:	f240 72d2 	movw	r2, #2002	; 0x7d2
 800adb6:	fb02 3304 	mla	r3, r2, r4, r3
 800adba:	4632      	mov	r2, r6
 800adbc:	4629      	mov	r1, r5
 800adbe:	4620      	mov	r0, r4
 800adc0:	f7ff ff28 	bl	800ac14 <waitFromIPC>
    if (waitIPCstatus != ATSTATUS_OK)
 800adc4:	b9b8      	cbnz	r0, 800adf6 <process_answer+0x56>
      if ((at_context[athandle].action_flags & ATACTION_RSP_FRC_END) != 0U)
 800adc6:	4b5d      	ldr	r3, [pc, #372]	; (800af3c <process_answer+0x19c>)
 800adc8:	f240 629c 	movw	r2, #1692	; 0x69c
 800adcc:	fb02 3304 	mla	r3, r2, r4, r3
 800add0:	f8b3 3690 	ldrh.w	r3, [r3, #1680]	; 0x690
 800add4:	f013 0f01 	tst.w	r3, #1
 800add8:	d060      	beq.n	800ae9c <process_answer+0xfc>
        at_context[athandle].action_flags &= ~((at_action_rsp_t) ATACTION_RSP_FRC_END);
 800adda:	4a58      	ldr	r2, [pc, #352]	; (800af3c <process_answer+0x19c>)
 800addc:	f240 619c 	movw	r1, #1692	; 0x69c
 800ade0:	fb01 2204 	mla	r2, r1, r4, r2
 800ade4:	f023 0301 	bic.w	r3, r3, #1
 800ade8:	f8a2 3690 	strh.w	r3, [r2, #1680]	; 0x690
        action_rsp = ATACTION_RSP_FRC_END;
 800adec:	2001      	movs	r0, #1
  } while ((action_rsp == ATACTION_RSP_INTERMEDIATE) ||
 800adee:	2810      	cmp	r0, #16
 800adf0:	d0de      	beq.n	800adb0 <process_answer+0x10>
}
 800adf2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      (void) IPC_abort(at_context[athandle].ipc_handle);
 800adf6:	4b51      	ldr	r3, [pc, #324]	; (800af3c <process_answer+0x19c>)
 800adf8:	f240 629c 	movw	r2, #1692	; 0x69c
 800adfc:	fb02 3304 	mla	r3, r2, r4, r3
 800ae00:	6858      	ldr	r0, [r3, #4]
 800ae02:	f013 fbb1 	bl	801e568 <IPC_abort>
      if ((action_send & ATACTION_SEND_WAIT_MANDATORY_RSP) != 0U)
 800ae06:	f017 0f01 	tst.w	r7, #1
 800ae0a:	d104      	bne.n	800ae16 <process_answer+0x76>
        if ((action_send & ATACTION_SEND_FLAG_LAST_CMD) != 0U)
 800ae0c:	f417 4f00 	tst.w	r7, #32768	; 0x8000
 800ae10:	d042      	beq.n	800ae98 <process_answer+0xf8>
          action_rsp = ATACTION_RSP_FRC_END;
 800ae12:	2001      	movs	r0, #1
 800ae14:	e7eb      	b.n	800adee <process_answer+0x4e>
        TRACE_ERR("AT_sendcmd error: wait from ipc")
 800ae16:	f8df e128 	ldr.w	lr, [pc, #296]	; 800af40 <process_answer+0x1a0>
 800ae1a:	f8df c128 	ldr.w	ip, [pc, #296]	; 800af44 <process_answer+0x1a4>
 800ae1e:	f10e 0920 	add.w	r9, lr, #32
 800ae22:	46f0      	mov	r8, lr
 800ae24:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 800ae28:	f8cc 0000 	str.w	r0, [ip]
 800ae2c:	f8cc 1004 	str.w	r1, [ip, #4]
 800ae30:	f8cc 2008 	str.w	r2, [ip, #8]
 800ae34:	f8cc 300c 	str.w	r3, [ip, #12]
 800ae38:	46c6      	mov	lr, r8
 800ae3a:	f10c 0c10 	add.w	ip, ip, #16
 800ae3e:	45c8      	cmp	r8, r9
 800ae40:	d1ef      	bne.n	800ae22 <process_answer+0x82>
 800ae42:	e8be 0007 	ldmia.w	lr!, {r0, r1, r2}
 800ae46:	f8cc 0000 	str.w	r0, [ip]
 800ae4a:	f8cc 1004 	str.w	r1, [ip, #4]
 800ae4e:	f8cc 2008 	str.w	r2, [ip, #8]
 800ae52:	f8be 2000 	ldrh.w	r2, [lr]
 800ae56:	f89e 3002 	ldrb.w	r3, [lr, #2]
 800ae5a:	f8ac 200c 	strh.w	r2, [ip, #12]
 800ae5e:	f88c 300e 	strb.w	r3, [ip, #14]
 800ae62:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 800af44 <process_answer+0x1a4>
 800ae66:	4640      	mov	r0, r8
 800ae68:	f014 fa5f 	bl	801f32a <crs_strlen>
 800ae6c:	b283      	uxth	r3, r0
 800ae6e:	4642      	mov	r2, r8
 800ae70:	2110      	movs	r1, #16
 800ae72:	2002      	movs	r0, #2
 800ae74:	f014 fa9c 	bl	801f3b0 <traceIF_itmPrint>
 800ae78:	4640      	mov	r0, r8
 800ae7a:	f014 fa56 	bl	801f32a <crs_strlen>
 800ae7e:	b283      	uxth	r3, r0
 800ae80:	4642      	mov	r2, r8
 800ae82:	2110      	movs	r1, #16
 800ae84:	2002      	movs	r0, #2
 800ae86:	f014 fab5 	bl	801f3f4 <traceIF_uartPrint>
        LOG_ERROR(10, ERROR_WARNING);
 800ae8a:	2202      	movs	r2, #2
 800ae8c:	210a      	movs	r1, #10
 800ae8e:	4610      	mov	r0, r2
 800ae90:	f013 fa68 	bl	801e364 <ERROR_Handler>
        action_rsp = ATACTION_RSP_ERROR;
 800ae94:	2004      	movs	r0, #4
 800ae96:	e7aa      	b.n	800adee <process_answer+0x4e>
          action_rsp = ATACTION_RSP_FRC_CONTINUE;
 800ae98:	2002      	movs	r0, #2
 800ae9a:	e7a8      	b.n	800adee <process_answer+0x4e>
      else if ((at_context[athandle].action_flags & ATACTION_RSP_FRC_CONTINUE) != 0U)
 800ae9c:	f013 0f02 	tst.w	r3, #2
 800aea0:	d104      	bne.n	800aeac <process_answer+0x10c>
      else if ((at_context[athandle].action_flags & ATACTION_RSP_ERROR) != 0U)
 800aea2:	f013 0f04 	tst.w	r3, #4
 800aea6:	d10c      	bne.n	800aec2 <process_answer+0x122>
        action_rsp = ATACTION_RSP_IGNORED;
 800aea8:	2010      	movs	r0, #16
 800aeaa:	e7a0      	b.n	800adee <process_answer+0x4e>
        at_context[athandle].action_flags &= ~((at_action_rsp_t) ATACTION_RSP_FRC_CONTINUE);
 800aeac:	4a23      	ldr	r2, [pc, #140]	; (800af3c <process_answer+0x19c>)
 800aeae:	f240 619c 	movw	r1, #1692	; 0x69c
 800aeb2:	fb01 2204 	mla	r2, r1, r4, r2
 800aeb6:	f023 0302 	bic.w	r3, r3, #2
 800aeba:	f8a2 3690 	strh.w	r3, [r2, #1680]	; 0x690
        action_rsp = ATACTION_RSP_FRC_CONTINUE;
 800aebe:	2002      	movs	r0, #2
 800aec0:	e795      	b.n	800adee <process_answer+0x4e>
        at_context[athandle].action_flags &= ~((at_action_rsp_t) ATACTION_RSP_ERROR);
 800aec2:	4a1e      	ldr	r2, [pc, #120]	; (800af3c <process_answer+0x19c>)
 800aec4:	f240 619c 	movw	r1, #1692	; 0x69c
 800aec8:	fb01 2204 	mla	r2, r1, r4, r2
 800aecc:	f023 0304 	bic.w	r3, r3, #4
 800aed0:	f8a2 3690 	strh.w	r3, [r2, #1680]	; 0x690
        TRACE_ERR("AT_sendcmd error: parse from rsp")
 800aed4:	f8df 8070 	ldr.w	r8, [pc, #112]	; 800af48 <process_answer+0x1a8>
 800aed8:	f8df e068 	ldr.w	lr, [pc, #104]	; 800af44 <process_answer+0x1a4>
 800aedc:	f108 0930 	add.w	r9, r8, #48	; 0x30
 800aee0:	46c4      	mov	ip, r8
 800aee2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800aee6:	f8ce 0000 	str.w	r0, [lr]
 800aeea:	f8ce 1004 	str.w	r1, [lr, #4]
 800aeee:	f8ce 2008 	str.w	r2, [lr, #8]
 800aef2:	f8ce 300c 	str.w	r3, [lr, #12]
 800aef6:	46e0      	mov	r8, ip
 800aef8:	f10e 0e10 	add.w	lr, lr, #16
 800aefc:	45cc      	cmp	ip, r9
 800aefe:	d1ef      	bne.n	800aee0 <process_answer+0x140>
 800af00:	f8df 8040 	ldr.w	r8, [pc, #64]	; 800af44 <process_answer+0x1a4>
 800af04:	4640      	mov	r0, r8
 800af06:	f014 fa10 	bl	801f32a <crs_strlen>
 800af0a:	b283      	uxth	r3, r0
 800af0c:	4642      	mov	r2, r8
 800af0e:	2110      	movs	r1, #16
 800af10:	2002      	movs	r0, #2
 800af12:	f014 fa4d 	bl	801f3b0 <traceIF_itmPrint>
 800af16:	4640      	mov	r0, r8
 800af18:	f014 fa07 	bl	801f32a <crs_strlen>
 800af1c:	b283      	uxth	r3, r0
 800af1e:	4642      	mov	r2, r8
 800af20:	2110      	movs	r1, #16
 800af22:	2002      	movs	r0, #2
 800af24:	f014 fa66 	bl	801f3f4 <traceIF_uartPrint>
        LOG_ERROR(11, ERROR_WARNING);
 800af28:	2202      	movs	r2, #2
 800af2a:	210b      	movs	r1, #11
 800af2c:	4610      	mov	r0, r2
 800af2e:	f013 fa19 	bl	801e364 <ERROR_Handler>
        action_rsp = ATACTION_RSP_ERROR;
 800af32:	2004      	movs	r0, #4
 800af34:	e75b      	b.n	800adee <process_answer+0x4e>
 800af36:	bf00      	nop
 800af38:	20002d68 	.word	0x20002d68
 800af3c:	2000188c 	.word	0x2000188c
 800af40:	0802ddac 	.word	0x0802ddac
 800af44:	200048dc 	.word	0x200048dc
 800af48:	0802dddc 	.word	0x0802dddc

0800af4c <process_AT_transaction>:
{
 800af4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800af50:	b085      	sub	sp, #20
 800af52:	4606      	mov	r6, r0
 800af54:	4688      	mov	r8, r1
  uint32_t at_cmd_timeout = 0U;
 800af56:	2400      	movs	r4, #0
 800af58:	9403      	str	r4, [sp, #12]
  (void) memset((void *) build_atcmd, 0, ATCMD_MAX_CMD_SIZE);
 800af5a:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 800af5e:	4621      	mov	r1, r4
 800af60:	489d      	ldr	r0, [pc, #628]	; (800b1d8 <process_AT_transaction+0x28c>)
 800af62:	f01b fce4 	bl	802692e <memset>
  at_action_rsp_t action_rsp = ATACTION_RSP_NO_ACTION;
 800af66:	4627      	mov	r7, r4
  at_status_t retval = ATSTATUS_OK;
 800af68:	46a1      	mov	r9, r4
 800af6a:	e035      	b.n	800afd8 <process_AT_transaction+0x8c>
      TRACE_DBG("AT_sendcmd error: get at command")
 800af6c:	4d9b      	ldr	r5, [pc, #620]	; (800b1dc <process_AT_transaction+0x290>)
 800af6e:	4c9c      	ldr	r4, [pc, #624]	; (800b1e0 <process_AT_transaction+0x294>)
 800af70:	f105 0e20 	add.w	lr, r5, #32
 800af74:	46ac      	mov	ip, r5
 800af76:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800af7a:	6020      	str	r0, [r4, #0]
 800af7c:	6061      	str	r1, [r4, #4]
 800af7e:	60a2      	str	r2, [r4, #8]
 800af80:	60e3      	str	r3, [r4, #12]
 800af82:	4665      	mov	r5, ip
 800af84:	3410      	adds	r4, #16
 800af86:	45f4      	cmp	ip, lr
 800af88:	d1f4      	bne.n	800af74 <process_AT_transaction+0x28>
 800af8a:	cd03      	ldmia	r5!, {r0, r1}
 800af8c:	6020      	str	r0, [r4, #0]
 800af8e:	6061      	str	r1, [r4, #4]
 800af90:	882b      	ldrh	r3, [r5, #0]
 800af92:	8123      	strh	r3, [r4, #8]
 800af94:	4c92      	ldr	r4, [pc, #584]	; (800b1e0 <process_AT_transaction+0x294>)
 800af96:	4620      	mov	r0, r4
 800af98:	f014 f9c7 	bl	801f32a <crs_strlen>
 800af9c:	b283      	uxth	r3, r0
 800af9e:	4622      	mov	r2, r4
 800afa0:	2102      	movs	r1, #2
 800afa2:	4608      	mov	r0, r1
 800afa4:	f014 fa04 	bl	801f3b0 <traceIF_itmPrint>
 800afa8:	4620      	mov	r0, r4
 800afaa:	f014 f9be 	bl	801f32a <crs_strlen>
 800afae:	b283      	uxth	r3, r0
 800afb0:	4622      	mov	r2, r4
 800afb2:	2102      	movs	r1, #2
 800afb4:	4608      	mov	r0, r1
 800afb6:	f014 fa1d 	bl	801f3f4 <traceIF_uartPrint>
      LOG_ERROR(7, ERROR_WARNING);
 800afba:	2202      	movs	r2, #2
 800afbc:	2107      	movs	r1, #7
 800afbe:	4610      	mov	r0, r2
 800afc0:	f013 f9d0 	bl	801e364 <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800afc4:	2300      	movs	r3, #0
      retval = ATSTATUS_ERROR;
 800afc6:	f04f 0901 	mov.w	r9, #1
    if (retval == ATSTATUS_ERROR)
 800afca:	f1b9 0f01 	cmp.w	r9, #1
 800afce:	f000 80d5 	beq.w	800b17c <process_AT_transaction+0x230>
  } while (another_cmd_to_send == 1U);
 800afd2:	2b00      	cmp	r3, #0
 800afd4:	f000 80d2 	beq.w	800b17c <process_AT_transaction+0x230>
    (void) memset((void *)&build_atcmd[0], 0, sizeof(AT_CHAR_t) * ATCMD_MAX_CMD_SIZE);
 800afd8:	4c7f      	ldr	r4, [pc, #508]	; (800b1d8 <process_AT_transaction+0x28c>)
 800afda:	f44f 65c8 	mov.w	r5, #1600	; 0x640
 800afde:	462a      	mov	r2, r5
 800afe0:	2100      	movs	r1, #0
 800afe2:	4620      	mov	r0, r4
 800afe4:	f01b fca3 	bl	802692e <memset>
    build_atcmd_size = 0U;
 800afe8:	2300      	movs	r3, #0
 800afea:	f8ad 300a 	strh.w	r3, [sp, #10]
    action_send = ATParser_get_ATcmd(&at_context[athandle],
 800afee:	ab03      	add	r3, sp, #12
 800aff0:	9300      	str	r3, [sp, #0]
 800aff2:	f10d 030a 	add.w	r3, sp, #10
 800aff6:	462a      	mov	r2, r5
 800aff8:	4621      	mov	r1, r4
 800affa:	487a      	ldr	r0, [pc, #488]	; (800b1e4 <process_AT_transaction+0x298>)
 800affc:	f240 649c 	movw	r4, #1692	; 0x69c
 800b000:	fb04 0006 	mla	r0, r4, r6, r0
 800b004:	f009 fc9c 	bl	8014940 <ATParser_get_ATcmd>
 800b008:	4604      	mov	r4, r0
    if ((action_send & ATACTION_SEND_ERROR) != 0U)
 800b00a:	f010 0f04 	tst.w	r0, #4
 800b00e:	d1ad      	bne.n	800af6c <process_AT_transaction+0x20>
      if (build_atcmd_size > 0U)
 800b010:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 800b014:	b182      	cbz	r2, 800b038 <process_AT_transaction+0xec>
        if ((at_context[athandle].in_data_mode == AT_TRUE) && (msg_in_id != (at_msg_t) SID_CS_DATA_SUSPEND))
 800b016:	4b73      	ldr	r3, [pc, #460]	; (800b1e4 <process_AT_transaction+0x298>)
 800b018:	f240 619c 	movw	r1, #1692	; 0x69c
 800b01c:	fb01 3306 	mla	r3, r1, r6, r3
 800b020:	7a9b      	ldrb	r3, [r3, #10]
 800b022:	b113      	cbz	r3, 800b02a <process_AT_transaction+0xde>
 800b024:	f1b8 0f7e 	cmp.w	r8, #126	; 0x7e
 800b028:	d117      	bne.n	800b05a <process_AT_transaction+0x10e>
          retval = sendToIPC(athandle, (uint8_t *)&build_atcmd[0], build_atcmd_size);
 800b02a:	496b      	ldr	r1, [pc, #428]	; (800b1d8 <process_AT_transaction+0x28c>)
 800b02c:	4630      	mov	r0, r6
 800b02e:	f7ff fe6b 	bl	800ad08 <sendToIPC>
          if (retval != ATSTATUS_OK)
 800b032:	4681      	mov	r9, r0
 800b034:	2800      	cmp	r0, #0
 800b036:	d13d      	bne.n	800b0b4 <process_AT_transaction+0x168>
      if (retval != ATSTATUS_ERROR)
 800b038:	f1b9 0f01 	cmp.w	r9, #1
 800b03c:	f000 809c 	beq.w	800b178 <process_AT_transaction+0x22c>
        if (((action_send & ATACTION_SEND_WAIT_MANDATORY_RSP) != 0U) ||
 800b040:	f014 0f03 	tst.w	r4, #3
 800b044:	d069      	beq.n	800b11a <process_AT_transaction+0x1ce>
          action_rsp = process_answer(athandle, action_send, at_cmd_timeout);
 800b046:	9a03      	ldr	r2, [sp, #12]
 800b048:	4621      	mov	r1, r4
 800b04a:	4630      	mov	r0, r6
 800b04c:	f7ff fea8 	bl	800ada0 <process_answer>
 800b050:	4607      	mov	r7, r0
          if (action_rsp == ATACTION_RSP_FRC_CONTINUE)
 800b052:	2802      	cmp	r0, #2
 800b054:	d15f      	bne.n	800b116 <process_AT_transaction+0x1ca>
            another_cmd_to_send = 1U;
 800b056:	2301      	movs	r3, #1
 800b058:	e7b7      	b.n	800afca <process_AT_transaction+0x7e>
          TRACE_ERR("DATA ongoing, can not send a command")
 800b05a:	f8df c194 	ldr.w	ip, [pc, #404]	; 800b1f0 <process_AT_transaction+0x2a4>
 800b05e:	4d60      	ldr	r5, [pc, #384]	; (800b1e0 <process_AT_transaction+0x294>)
 800b060:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 800b064:	4664      	mov	r4, ip
 800b066:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b068:	6028      	str	r0, [r5, #0]
 800b06a:	6069      	str	r1, [r5, #4]
 800b06c:	60aa      	str	r2, [r5, #8]
 800b06e:	60eb      	str	r3, [r5, #12]
 800b070:	46a4      	mov	ip, r4
 800b072:	3510      	adds	r5, #16
 800b074:	4574      	cmp	r4, lr
 800b076:	d1f5      	bne.n	800b064 <process_AT_transaction+0x118>
 800b078:	6820      	ldr	r0, [r4, #0]
 800b07a:	6028      	str	r0, [r5, #0]
 800b07c:	4c58      	ldr	r4, [pc, #352]	; (800b1e0 <process_AT_transaction+0x294>)
 800b07e:	4620      	mov	r0, r4
 800b080:	f014 f953 	bl	801f32a <crs_strlen>
 800b084:	b283      	uxth	r3, r0
 800b086:	4622      	mov	r2, r4
 800b088:	2110      	movs	r1, #16
 800b08a:	2002      	movs	r0, #2
 800b08c:	f014 f990 	bl	801f3b0 <traceIF_itmPrint>
 800b090:	4620      	mov	r0, r4
 800b092:	f014 f94a 	bl	801f32a <crs_strlen>
 800b096:	b283      	uxth	r3, r0
 800b098:	4622      	mov	r2, r4
 800b09a:	2110      	movs	r1, #16
 800b09c:	2002      	movs	r0, #2
 800b09e:	f014 f9a9 	bl	801f3f4 <traceIF_uartPrint>
          LOG_ERROR(8, ERROR_WARNING);
 800b0a2:	2202      	movs	r2, #2
 800b0a4:	2108      	movs	r1, #8
 800b0a6:	4610      	mov	r0, r2
 800b0a8:	f013 f95c 	bl	801e364 <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b0ac:	2300      	movs	r3, #0
          retval = ATSTATUS_ERROR;
 800b0ae:	f04f 0901 	mov.w	r9, #1
 800b0b2:	e78a      	b.n	800afca <process_AT_transaction+0x7e>
            TRACE_ERR("AT_sendcmd error: send to ipc")
 800b0b4:	4d4c      	ldr	r5, [pc, #304]	; (800b1e8 <process_AT_transaction+0x29c>)
 800b0b6:	4c4a      	ldr	r4, [pc, #296]	; (800b1e0 <process_AT_transaction+0x294>)
 800b0b8:	f105 0e20 	add.w	lr, r5, #32
 800b0bc:	46ac      	mov	ip, r5
 800b0be:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b0c2:	6020      	str	r0, [r4, #0]
 800b0c4:	6061      	str	r1, [r4, #4]
 800b0c6:	60a2      	str	r2, [r4, #8]
 800b0c8:	60e3      	str	r3, [r4, #12]
 800b0ca:	4665      	mov	r5, ip
 800b0cc:	3410      	adds	r4, #16
 800b0ce:	45f4      	cmp	ip, lr
 800b0d0:	d1f4      	bne.n	800b0bc <process_AT_transaction+0x170>
 800b0d2:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b0d4:	6020      	str	r0, [r4, #0]
 800b0d6:	6061      	str	r1, [r4, #4]
 800b0d8:	60a2      	str	r2, [r4, #8]
 800b0da:	782b      	ldrb	r3, [r5, #0]
 800b0dc:	7323      	strb	r3, [r4, #12]
 800b0de:	4c40      	ldr	r4, [pc, #256]	; (800b1e0 <process_AT_transaction+0x294>)
 800b0e0:	4620      	mov	r0, r4
 800b0e2:	f014 f922 	bl	801f32a <crs_strlen>
 800b0e6:	b283      	uxth	r3, r0
 800b0e8:	4622      	mov	r2, r4
 800b0ea:	2110      	movs	r1, #16
 800b0ec:	2002      	movs	r0, #2
 800b0ee:	f014 f95f 	bl	801f3b0 <traceIF_itmPrint>
 800b0f2:	4620      	mov	r0, r4
 800b0f4:	f014 f919 	bl	801f32a <crs_strlen>
 800b0f8:	b283      	uxth	r3, r0
 800b0fa:	4622      	mov	r2, r4
 800b0fc:	2110      	movs	r1, #16
 800b0fe:	2002      	movs	r0, #2
 800b100:	f014 f978 	bl	801f3f4 <traceIF_uartPrint>
            LOG_ERROR(9, ERROR_WARNING);
 800b104:	2202      	movs	r2, #2
 800b106:	2109      	movs	r1, #9
 800b108:	4610      	mov	r0, r2
 800b10a:	f013 f92b 	bl	801e364 <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b10e:	2300      	movs	r3, #0
            retval = ATSTATUS_ERROR;
 800b110:	f04f 0901 	mov.w	r9, #1
 800b114:	e759      	b.n	800afca <process_AT_transaction+0x7e>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b116:	2300      	movs	r3, #0
 800b118:	e757      	b.n	800afca <process_AT_transaction+0x7e>
          TRACE_ERR("Invalid action code")
 800b11a:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 800b1f4 <process_AT_transaction+0x2a8>
 800b11e:	4c30      	ldr	r4, [pc, #192]	; (800b1e0 <process_AT_transaction+0x294>)
 800b120:	f10c 0e20 	add.w	lr, ip, #32
 800b124:	4665      	mov	r5, ip
 800b126:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b128:	6020      	str	r0, [r4, #0]
 800b12a:	6061      	str	r1, [r4, #4]
 800b12c:	60a2      	str	r2, [r4, #8]
 800b12e:	60e3      	str	r3, [r4, #12]
 800b130:	46ac      	mov	ip, r5
 800b132:	3410      	adds	r4, #16
 800b134:	4575      	cmp	r5, lr
 800b136:	d1f5      	bne.n	800b124 <process_AT_transaction+0x1d8>
 800b138:	882a      	ldrh	r2, [r5, #0]
 800b13a:	78ab      	ldrb	r3, [r5, #2]
 800b13c:	8022      	strh	r2, [r4, #0]
 800b13e:	70a3      	strb	r3, [r4, #2]
 800b140:	4c27      	ldr	r4, [pc, #156]	; (800b1e0 <process_AT_transaction+0x294>)
 800b142:	4620      	mov	r0, r4
 800b144:	f014 f8f1 	bl	801f32a <crs_strlen>
 800b148:	b283      	uxth	r3, r0
 800b14a:	4622      	mov	r2, r4
 800b14c:	2110      	movs	r1, #16
 800b14e:	2002      	movs	r0, #2
 800b150:	f014 f92e 	bl	801f3b0 <traceIF_itmPrint>
 800b154:	4620      	mov	r0, r4
 800b156:	f014 f8e8 	bl	801f32a <crs_strlen>
 800b15a:	b283      	uxth	r3, r0
 800b15c:	4622      	mov	r2, r4
 800b15e:	2110      	movs	r1, #16
 800b160:	2002      	movs	r0, #2
 800b162:	f014 f947 	bl	801f3f4 <traceIF_uartPrint>
          LOG_ERROR(13, ERROR_WARNING);
 800b166:	2202      	movs	r2, #2
 800b168:	210d      	movs	r1, #13
 800b16a:	4610      	mov	r0, r2
 800b16c:	f013 f8fa 	bl	801e364 <ERROR_Handler>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b170:	2300      	movs	r3, #0
          retval = ATSTATUS_ERROR;
 800b172:	f04f 0901 	mov.w	r9, #1
 800b176:	e728      	b.n	800afca <process_AT_transaction+0x7e>
    another_cmd_to_send = 0U; /* default value: this is the last command (will be changed if this is not the case) */
 800b178:	2300      	movs	r3, #0
 800b17a:	e726      	b.n	800afca <process_AT_transaction+0x7e>
  at_context[athandle].action_flags = ATACTION_RSP_NO_ACTION;
 800b17c:	4b19      	ldr	r3, [pc, #100]	; (800b1e4 <process_AT_transaction+0x298>)
 800b17e:	f240 629c 	movw	r2, #1692	; 0x69c
 800b182:	fb02 3306 	mla	r3, r2, r6, r3
 800b186:	2200      	movs	r2, #0
 800b188:	f8a3 2690 	strh.w	r2, [r3, #1680]	; 0x690
  TRACE_DBG("action_rsp value = %d", action_rsp)
 800b18c:	4c14      	ldr	r4, [pc, #80]	; (800b1e0 <process_AT_transaction+0x294>)
 800b18e:	463a      	mov	r2, r7
 800b190:	4916      	ldr	r1, [pc, #88]	; (800b1ec <process_AT_transaction+0x2a0>)
 800b192:	4620      	mov	r0, r4
 800b194:	f01b fb58 	bl	8026848 <sprintf>
 800b198:	4620      	mov	r0, r4
 800b19a:	f014 f8c6 	bl	801f32a <crs_strlen>
 800b19e:	b283      	uxth	r3, r0
 800b1a0:	4622      	mov	r2, r4
 800b1a2:	2102      	movs	r1, #2
 800b1a4:	4608      	mov	r0, r1
 800b1a6:	f014 f903 	bl	801f3b0 <traceIF_itmPrint>
 800b1aa:	4620      	mov	r0, r4
 800b1ac:	f014 f8bd 	bl	801f32a <crs_strlen>
 800b1b0:	b283      	uxth	r3, r0
 800b1b2:	4622      	mov	r2, r4
 800b1b4:	2102      	movs	r1, #2
 800b1b6:	4608      	mov	r0, r1
 800b1b8:	f014 f91c 	bl	801f3f4 <traceIF_uartPrint>
  if (action_rsp == ATACTION_RSP_ERROR)
 800b1bc:	2f04      	cmp	r7, #4
 800b1be:	d003      	beq.n	800b1c8 <process_AT_transaction+0x27c>
}
 800b1c0:	4648      	mov	r0, r9
 800b1c2:	b005      	add	sp, #20
 800b1c4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    LOG_ERROR(14, ERROR_WARNING);
 800b1c8:	2202      	movs	r2, #2
 800b1ca:	210e      	movs	r1, #14
 800b1cc:	4610      	mov	r0, r2
 800b1ce:	f013 f8c9 	bl	801e364 <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800b1d2:	f04f 0901 	mov.w	r9, #1
 800b1d6:	e7f3      	b.n	800b1c0 <process_AT_transaction+0x274>
 800b1d8:	20001f2c 	.word	0x20001f2c
 800b1dc:	0802de0c 	.word	0x0802de0c
 800b1e0:	200048dc 	.word	0x200048dc
 800b1e4:	2000188c 	.word	0x2000188c
 800b1e8:	0802de6c 	.word	0x0802de6c
 800b1ec:	0802dec0 	.word	0x0802dec0
 800b1f0:	0802de38 	.word	0x0802de38
 800b1f4:	0802de9c 	.word	0x0802de9c

0800b1f8 <analyze_action_result>:
{
 800b1f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b1fc:	4605      	mov	r5, r0
 800b1fe:	460a      	mov	r2, r1
  at_bool_t data_mode = ((val & ATACTION_RSP_FLAG_DATA_MODE) != 0U) ? AT_TRUE : AT_FALSE;
 800b200:	0bcf      	lsrs	r7, r1, #15
  action = (at_action_rsp_t)(val & ~(at_action_rsp_t)ATACTION_RSP_FLAG_DATA_MODE);
 800b202:	f3c1 060e 	ubfx	r6, r1, #0, #15
  TRACE_DBG("RAW ACTION (analyze_action_result) = 0x%x", val)
 800b206:	4c65      	ldr	r4, [pc, #404]	; (800b39c <analyze_action_result+0x1a4>)
 800b208:	4965      	ldr	r1, [pc, #404]	; (800b3a0 <analyze_action_result+0x1a8>)
 800b20a:	4620      	mov	r0, r4
 800b20c:	f01b fb1c 	bl	8026848 <sprintf>
 800b210:	4620      	mov	r0, r4
 800b212:	f014 f88a 	bl	801f32a <crs_strlen>
 800b216:	b283      	uxth	r3, r0
 800b218:	4622      	mov	r2, r4
 800b21a:	2102      	movs	r1, #2
 800b21c:	4608      	mov	r0, r1
 800b21e:	f014 f8c7 	bl	801f3b0 <traceIF_itmPrint>
 800b222:	4620      	mov	r0, r4
 800b224:	f014 f881 	bl	801f32a <crs_strlen>
 800b228:	b283      	uxth	r3, r0
 800b22a:	4622      	mov	r2, r4
 800b22c:	2102      	movs	r1, #2
 800b22e:	4608      	mov	r0, r1
 800b230:	f014 f8e0 	bl	801f3f4 <traceIF_uartPrint>
  TRACE_DBG("CLEANED ACTION=%d (data mode=%d)", action, data_mode)
 800b234:	463b      	mov	r3, r7
 800b236:	4632      	mov	r2, r6
 800b238:	495a      	ldr	r1, [pc, #360]	; (800b3a4 <analyze_action_result+0x1ac>)
 800b23a:	4620      	mov	r0, r4
 800b23c:	f01b fb04 	bl	8026848 <sprintf>
 800b240:	4620      	mov	r0, r4
 800b242:	f014 f872 	bl	801f32a <crs_strlen>
 800b246:	b283      	uxth	r3, r0
 800b248:	4622      	mov	r2, r4
 800b24a:	2102      	movs	r1, #2
 800b24c:	4608      	mov	r0, r1
 800b24e:	f014 f8af 	bl	801f3b0 <traceIF_itmPrint>
 800b252:	4620      	mov	r0, r4
 800b254:	f014 f869 	bl	801f32a <crs_strlen>
 800b258:	b283      	uxth	r3, r0
 800b25a:	4622      	mov	r2, r4
 800b25c:	2102      	movs	r1, #2
 800b25e:	4608      	mov	r0, r1
 800b260:	f014 f8c8 	bl	801f3f4 <traceIF_uartPrint>
  if (data_mode == AT_TRUE)
 800b264:	2f00      	cmp	r7, #0
 800b266:	d064      	beq.n	800b332 <analyze_action_result+0x13a>
    if (at_context[athandle].in_data_mode == AT_FALSE)
 800b268:	4b4f      	ldr	r3, [pc, #316]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b26a:	f240 629c 	movw	r2, #1692	; 0x69c
 800b26e:	fb02 3305 	mla	r3, r2, r5, r3
 800b272:	7a9b      	ldrb	r3, [r3, #10]
 800b274:	b113      	cbz	r3, 800b27c <analyze_action_result+0x84>
}
 800b276:	4630      	mov	r0, r6
 800b278:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      IPC_Handle_t *h_other_ipc = IPC_get_other_channel(at_context[athandle].ipc_handle);
 800b27c:	4b4a      	ldr	r3, [pc, #296]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b27e:	fb02 3305 	mla	r3, r2, r5, r3
 800b282:	6858      	ldr	r0, [r3, #4]
 800b284:	f013 f97e 	bl	801e584 <IPC_get_other_channel>
      if (h_other_ipc != NULL)
 800b288:	b360      	cbz	r0, 800b2e4 <analyze_action_result+0xec>
        (void) IPC_select(h_other_ipc);
 800b28a:	f013 f974 	bl	801e576 <IPC_select>
        at_context[athandle].in_data_mode = AT_TRUE;
 800b28e:	4b46      	ldr	r3, [pc, #280]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b290:	f240 629c 	movw	r2, #1692	; 0x69c
 800b294:	fb02 3305 	mla	r3, r2, r5, r3
 800b298:	2201      	movs	r2, #1
 800b29a:	729a      	strb	r2, [r3, #10]
        TRACE_INFO("<<< DATA MODE SELECTED >>>")
 800b29c:	4f43      	ldr	r7, [pc, #268]	; (800b3ac <analyze_action_result+0x1b4>)
 800b29e:	4625      	mov	r5, r4
 800b2a0:	f107 0c20 	add.w	ip, r7, #32
 800b2a4:	463c      	mov	r4, r7
 800b2a6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b2a8:	6028      	str	r0, [r5, #0]
 800b2aa:	6069      	str	r1, [r5, #4]
 800b2ac:	60aa      	str	r2, [r5, #8]
 800b2ae:	60eb      	str	r3, [r5, #12]
 800b2b0:	4627      	mov	r7, r4
 800b2b2:	3510      	adds	r5, #16
 800b2b4:	4564      	cmp	r4, ip
 800b2b6:	d1f5      	bne.n	800b2a4 <analyze_action_result+0xac>
 800b2b8:	6820      	ldr	r0, [r4, #0]
 800b2ba:	6028      	str	r0, [r5, #0]
 800b2bc:	4c37      	ldr	r4, [pc, #220]	; (800b39c <analyze_action_result+0x1a4>)
 800b2be:	4620      	mov	r0, r4
 800b2c0:	f014 f833 	bl	801f32a <crs_strlen>
 800b2c4:	b283      	uxth	r3, r0
 800b2c6:	4622      	mov	r2, r4
 800b2c8:	2101      	movs	r1, #1
 800b2ca:	2002      	movs	r0, #2
 800b2cc:	f014 f870 	bl	801f3b0 <traceIF_itmPrint>
 800b2d0:	4620      	mov	r0, r4
 800b2d2:	f014 f82a 	bl	801f32a <crs_strlen>
 800b2d6:	b283      	uxth	r3, r0
 800b2d8:	4622      	mov	r2, r4
 800b2da:	2101      	movs	r1, #1
 800b2dc:	2002      	movs	r0, #2
 800b2de:	f014 f889 	bl	801f3f4 <traceIF_uartPrint>
 800b2e2:	e7c8      	b.n	800b276 <analyze_action_result+0x7e>
        TRACE_ERR("<<< ERROR WHEN SELECTING DATA MODE >>>")
 800b2e4:	4e32      	ldr	r6, [pc, #200]	; (800b3b0 <analyze_action_result+0x1b8>)
 800b2e6:	4c2d      	ldr	r4, [pc, #180]	; (800b39c <analyze_action_result+0x1a4>)
 800b2e8:	f106 0730 	add.w	r7, r6, #48	; 0x30
 800b2ec:	4635      	mov	r5, r6
 800b2ee:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b2f0:	6020      	str	r0, [r4, #0]
 800b2f2:	6061      	str	r1, [r4, #4]
 800b2f4:	60a2      	str	r2, [r4, #8]
 800b2f6:	60e3      	str	r3, [r4, #12]
 800b2f8:	462e      	mov	r6, r5
 800b2fa:	3410      	adds	r4, #16
 800b2fc:	42bd      	cmp	r5, r7
 800b2fe:	d1f5      	bne.n	800b2ec <analyze_action_result+0xf4>
 800b300:	6828      	ldr	r0, [r5, #0]
 800b302:	6020      	str	r0, [r4, #0]
 800b304:	88ab      	ldrh	r3, [r5, #4]
 800b306:	80a3      	strh	r3, [r4, #4]
 800b308:	4c24      	ldr	r4, [pc, #144]	; (800b39c <analyze_action_result+0x1a4>)
 800b30a:	4620      	mov	r0, r4
 800b30c:	f014 f80d 	bl	801f32a <crs_strlen>
 800b310:	b283      	uxth	r3, r0
 800b312:	4622      	mov	r2, r4
 800b314:	2110      	movs	r1, #16
 800b316:	2002      	movs	r0, #2
 800b318:	f014 f84a 	bl	801f3b0 <traceIF_itmPrint>
 800b31c:	4620      	mov	r0, r4
 800b31e:	f014 f804 	bl	801f32a <crs_strlen>
 800b322:	b283      	uxth	r3, r0
 800b324:	4622      	mov	r2, r4
 800b326:	2110      	movs	r1, #16
 800b328:	2002      	movs	r0, #2
 800b32a:	f014 f863 	bl	801f3f4 <traceIF_uartPrint>
        action = ATACTION_RSP_ERROR;
 800b32e:	2604      	movs	r6, #4
 800b330:	e7a1      	b.n	800b276 <analyze_action_result+0x7e>
    if (at_context[athandle].in_data_mode == AT_TRUE)
 800b332:	4b1d      	ldr	r3, [pc, #116]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b334:	f240 629c 	movw	r2, #1692	; 0x69c
 800b338:	fb02 3305 	mla	r3, r2, r5, r3
 800b33c:	7a9b      	ldrb	r3, [r3, #10]
 800b33e:	2b00      	cmp	r3, #0
 800b340:	d099      	beq.n	800b276 <analyze_action_result+0x7e>
      at_context[athandle].in_data_mode = AT_FALSE;
 800b342:	4b19      	ldr	r3, [pc, #100]	; (800b3a8 <analyze_action_result+0x1b0>)
 800b344:	fb02 3305 	mla	r3, r2, r5, r3
 800b348:	2200      	movs	r2, #0
 800b34a:	729a      	strb	r2, [r3, #10]
      TRACE_INFO("<<< COMMAND MODE SELECTED >>>")
 800b34c:	4f19      	ldr	r7, [pc, #100]	; (800b3b4 <analyze_action_result+0x1bc>)
 800b34e:	4c13      	ldr	r4, [pc, #76]	; (800b39c <analyze_action_result+0x1a4>)
 800b350:	f107 0c20 	add.w	ip, r7, #32
 800b354:	463d      	mov	r5, r7
 800b356:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b358:	6020      	str	r0, [r4, #0]
 800b35a:	6061      	str	r1, [r4, #4]
 800b35c:	60a2      	str	r2, [r4, #8]
 800b35e:	60e3      	str	r3, [r4, #12]
 800b360:	462f      	mov	r7, r5
 800b362:	3410      	adds	r4, #16
 800b364:	4565      	cmp	r5, ip
 800b366:	d1f5      	bne.n	800b354 <analyze_action_result+0x15c>
 800b368:	6828      	ldr	r0, [r5, #0]
 800b36a:	6020      	str	r0, [r4, #0]
 800b36c:	88aa      	ldrh	r2, [r5, #4]
 800b36e:	79ab      	ldrb	r3, [r5, #6]
 800b370:	80a2      	strh	r2, [r4, #4]
 800b372:	71a3      	strb	r3, [r4, #6]
 800b374:	4c09      	ldr	r4, [pc, #36]	; (800b39c <analyze_action_result+0x1a4>)
 800b376:	4620      	mov	r0, r4
 800b378:	f013 ffd7 	bl	801f32a <crs_strlen>
 800b37c:	b283      	uxth	r3, r0
 800b37e:	4622      	mov	r2, r4
 800b380:	2101      	movs	r1, #1
 800b382:	2002      	movs	r0, #2
 800b384:	f014 f814 	bl	801f3b0 <traceIF_itmPrint>
 800b388:	4620      	mov	r0, r4
 800b38a:	f013 ffce 	bl	801f32a <crs_strlen>
 800b38e:	b283      	uxth	r3, r0
 800b390:	4622      	mov	r2, r4
 800b392:	2101      	movs	r1, #1
 800b394:	2002      	movs	r0, #2
 800b396:	f014 f82d 	bl	801f3f4 <traceIF_uartPrint>
 800b39a:	e76c      	b.n	800b276 <analyze_action_result+0x7e>
 800b39c:	200048dc 	.word	0x200048dc
 800b3a0:	0802dee0 	.word	0x0802dee0
 800b3a4:	0802df14 	.word	0x0802df14
 800b3a8:	2000188c 	.word	0x2000188c
 800b3ac:	0802df40 	.word	0x0802df40
 800b3b0:	0802df64 	.word	0x0802df64
 800b3b4:	0802df9c 	.word	0x0802df9c

0800b3b8 <ATCoreTaskBody>:

static void ATCoreTaskBody(void *argument)
{
 800b3b8:	b570      	push	{r4, r5, r6, lr}
 800b3ba:	b082      	sub	sp, #8
  at_status_t retUrc;
  at_handle_t athandle;
  at_status_t ret;
  at_action_rsp_t action;
  rtosalStatus status;
  uint32_t msg = 0;
 800b3bc:	2300      	movs	r3, #0
 800b3be:	9300      	str	r3, [sp, #0]

  static at_buf_t urc_buf[ATCMD_MAX_BUF_SIZE]; /* buffer size not optimized yet */

  TRACE_DBG("<start ATCore TASK>")
 800b3c0:	4cbd      	ldr	r4, [pc, #756]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b3c2:	4dbe      	ldr	r5, [pc, #760]	; (800b6bc <ATCoreTaskBody+0x304>)
 800b3c4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b3c6:	6020      	str	r0, [r4, #0]
 800b3c8:	6061      	str	r1, [r4, #4]
 800b3ca:	60a2      	str	r2, [r4, #8]
 800b3cc:	60e3      	str	r3, [r4, #12]
 800b3ce:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b3d0:	6120      	str	r0, [r4, #16]
 800b3d2:	6161      	str	r1, [r4, #20]
 800b3d4:	61a2      	str	r2, [r4, #24]
 800b3d6:	782b      	ldrb	r3, [r5, #0]
 800b3d8:	7723      	strb	r3, [r4, #28]
 800b3da:	4620      	mov	r0, r4
 800b3dc:	f013 ffa5 	bl	801f32a <crs_strlen>
 800b3e0:	b283      	uxth	r3, r0
 800b3e2:	4622      	mov	r2, r4
 800b3e4:	2102      	movs	r1, #2
 800b3e6:	4608      	mov	r0, r1
 800b3e8:	f013 ffe2 	bl	801f3b0 <traceIF_itmPrint>
 800b3ec:	4620      	mov	r0, r4
 800b3ee:	f013 ff9c 	bl	801f32a <crs_strlen>
 800b3f2:	b283      	uxth	r3, r0
 800b3f4:	4622      	mov	r2, r4
 800b3f6:	2102      	movs	r1, #2
 800b3f8:	4608      	mov	r0, r1
 800b3fa:	f013 fffb 	bl	801f3f4 <traceIF_uartPrint>
 800b3fe:	e1ef      	b.n	800b7e0 <ATCoreTaskBody+0x428>
      TRACE_DBG("<ATCore TASK> - received msg event= 0x%lx", msg)

      if (msg == (SIG_IPC_MSG))
      {
        /* a message has been received from IPC, retrieve its handle */
        ret = findMsgReceivedHandle(&athandle);
 800b400:	f10d 0006 	add.w	r0, sp, #6
 800b404:	f7ff fb68 	bl	800aad8 <findMsgReceivedHandle>
        if (ret != ATSTATUS_OK)
 800b408:	2800      	cmp	r0, #0
 800b40a:	f040 81e9 	bne.w	800b7e0 <ATCoreTaskBody+0x428>
          /* skip this loop iteration */
          continue;
        }

        /* retrieve message from IPC */
        if (IPC_receive(&ipcHandleTab[athandle], &msgFromIPC[athandle]) == IPC_ERROR)
 800b40e:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b412:	ebc3 2003 	rsb	r0, r3, r3, lsl #8
 800b416:	4aaa      	ldr	r2, [pc, #680]	; (800b6c0 <ATCoreTaskBody+0x308>)
 800b418:	f240 71d2 	movw	r1, #2002	; 0x7d2
 800b41c:	fb01 2103 	mla	r1, r1, r3, r2
 800b420:	4ba8      	ldr	r3, [pc, #672]	; (800b6c4 <ATCoreTaskBody+0x30c>)
 800b422:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800b426:	f013 f8bb 	bl	801e5a0 <IPC_receive>
 800b42a:	2801      	cmp	r0, #1
 800b42c:	d073      	beq.n	800b516 <ATCoreTaskBody+0x15e>
          /* skip this loop iteration */
          continue;
        }

        /* one message has been read */
        IRQ_DISABLE();
 800b42e:	f7ff fb4f 	bl	800aad0 <IRQ_DISABLE>
        MsgReceived[athandle]--;
 800b432:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b436:	49a4      	ldr	r1, [pc, #656]	; (800b6c8 <ATCoreTaskBody+0x310>)
 800b438:	5c8b      	ldrb	r3, [r1, r2]
 800b43a:	3b01      	subs	r3, #1
 800b43c:	b2db      	uxtb	r3, r3
 800b43e:	548b      	strb	r3, [r1, r2]
        IRQ_ENABLE();
 800b440:	f7ff fb48 	bl	800aad4 <IRQ_ENABLE>

        /* Parse the response */
        action = ATParser_parse_rsp(&at_context[athandle], &msgFromIPC[athandle]);
 800b444:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
 800b448:	4da0      	ldr	r5, [pc, #640]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b44a:	f240 669c 	movw	r6, #1692	; 0x69c
 800b44e:	4b9c      	ldr	r3, [pc, #624]	; (800b6c0 <ATCoreTaskBody+0x308>)
 800b450:	f240 71d2 	movw	r1, #2002	; 0x7d2
 800b454:	fb01 3100 	mla	r1, r1, r0, r3
 800b458:	fb06 5000 	mla	r0, r6, r0, r5
 800b45c:	f009 fb18 	bl	8014a90 <ATParser_parse_rsp>
 800b460:	4601      	mov	r1, r0

        /* analyze the response (check data mode flag) */
        action = analyze_action_result(athandle, action);
 800b462:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
 800b466:	f7ff fec7 	bl	800b1f8 <analyze_action_result>
 800b46a:	4604      	mov	r4, r0

        /* add this action to action flags */
        at_context[athandle].action_flags |= action;
 800b46c:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b470:	fb06 5503 	mla	r5, r6, r3, r5
 800b474:	f8b5 3690 	ldrh.w	r3, [r5, #1680]	; 0x690
 800b478:	4303      	orrs	r3, r0
 800b47a:	b29b      	uxth	r3, r3
 800b47c:	f8a5 3690 	strh.w	r3, [r5, #1680]	; 0x690
        TRACE_DBG("add action 0x%x (flags=0x%x)", action, at_context[athandle].action_flags)
 800b480:	4d8d      	ldr	r5, [pc, #564]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b482:	4602      	mov	r2, r0
 800b484:	4992      	ldr	r1, [pc, #584]	; (800b6d0 <ATCoreTaskBody+0x318>)
 800b486:	4628      	mov	r0, r5
 800b488:	f01b f9de 	bl	8026848 <sprintf>
 800b48c:	4628      	mov	r0, r5
 800b48e:	f013 ff4c 	bl	801f32a <crs_strlen>
 800b492:	b283      	uxth	r3, r0
 800b494:	462a      	mov	r2, r5
 800b496:	2102      	movs	r1, #2
 800b498:	4608      	mov	r0, r1
 800b49a:	f013 ff89 	bl	801f3b0 <traceIF_itmPrint>
 800b49e:	4628      	mov	r0, r5
 800b4a0:	f013 ff43 	bl	801f32a <crs_strlen>
 800b4a4:	b283      	uxth	r3, r0
 800b4a6:	462a      	mov	r2, r5
 800b4a8:	2102      	movs	r1, #2
 800b4aa:	4608      	mov	r0, r1
 800b4ac:	f013 ffa2 	bl	801f3f4 <traceIF_uartPrint>
        if (action == ATACTION_RSP_ERROR)
 800b4b0:	2c04      	cmp	r4, #4
 800b4b2:	f000 8087 	beq.w	800b5c4 <ATCoreTaskBody+0x20c>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
          continue;
        }

        /* check if this is an URC to forward */
        if (action == ATACTION_RSP_URC_FORWARDED)
 800b4b6:	2c40      	cmp	r4, #64	; 0x40
 800b4b8:	f000 80d4 	beq.w	800b664 <ATCoreTaskBody+0x2ac>
                (* register_URC_callback[athandle])(urc_buf);
              }
            } while (retUrc == ATSTATUS_OK_PENDING_URC);
          }
        }
        else if ((action == ATACTION_RSP_FRC_CONTINUE) ||
 800b4bc:	3c01      	subs	r4, #1
 800b4be:	b2a4      	uxth	r4, r4
 800b4c0:	2c01      	cmp	r4, #1
 800b4c2:	f200 818d 	bhi.w	800b7e0 <ATCoreTaskBody+0x428>
                 (action == ATACTION_RSP_FRC_END) ||
                 (action == ATACTION_RSP_ERROR))
        {
          TRACE_DBG("**** Sema released *****")
 800b4c6:	4e83      	ldr	r6, [pc, #524]	; (800b6d4 <ATCoreTaskBody+0x31c>)
 800b4c8:	4d7b      	ldr	r5, [pc, #492]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b4ca:	f106 0c20 	add.w	ip, r6, #32
 800b4ce:	4634      	mov	r4, r6
 800b4d0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b4d2:	6028      	str	r0, [r5, #0]
 800b4d4:	6069      	str	r1, [r5, #4]
 800b4d6:	60aa      	str	r2, [r5, #8]
 800b4d8:	60eb      	str	r3, [r5, #12]
 800b4da:	4626      	mov	r6, r4
 800b4dc:	3510      	adds	r5, #16
 800b4de:	4564      	cmp	r4, ip
 800b4e0:	d1f5      	bne.n	800b4ce <ATCoreTaskBody+0x116>
 800b4e2:	8823      	ldrh	r3, [r4, #0]
 800b4e4:	802b      	strh	r3, [r5, #0]
 800b4e6:	4c74      	ldr	r4, [pc, #464]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b4e8:	4620      	mov	r0, r4
 800b4ea:	f013 ff1e 	bl	801f32a <crs_strlen>
 800b4ee:	b283      	uxth	r3, r0
 800b4f0:	4622      	mov	r2, r4
 800b4f2:	2102      	movs	r1, #2
 800b4f4:	4608      	mov	r0, r1
 800b4f6:	f013 ff5b 	bl	801f3b0 <traceIF_itmPrint>
 800b4fa:	4620      	mov	r0, r4
 800b4fc:	f013 ff15 	bl	801f32a <crs_strlen>
 800b500:	b283      	uxth	r3, r0
 800b502:	4622      	mov	r2, r4
 800b504:	2102      	movs	r1, #2
 800b506:	4608      	mov	r0, r1
 800b508:	f013 ff74 	bl	801f3f4 <traceIF_uartPrint>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
 800b50c:	4b72      	ldr	r3, [pc, #456]	; (800b6d8 <ATCoreTaskBody+0x320>)
 800b50e:	6818      	ldr	r0, [r3, #0]
 800b510:	f013 fe17 	bl	801f142 <rtosalSemaphoreRelease>
 800b514:	e164      	b.n	800b7e0 <ATCoreTaskBody+0x428>
          TRACE_ERR("IPC receive error")
 800b516:	4e71      	ldr	r6, [pc, #452]	; (800b6dc <ATCoreTaskBody+0x324>)
 800b518:	4625      	mov	r5, r4
 800b51a:	f106 0c20 	add.w	ip, r6, #32
 800b51e:	4634      	mov	r4, r6
 800b520:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800b522:	6028      	str	r0, [r5, #0]
 800b524:	6069      	str	r1, [r5, #4]
 800b526:	60aa      	str	r2, [r5, #8]
 800b528:	60eb      	str	r3, [r5, #12]
 800b52a:	4626      	mov	r6, r4
 800b52c:	3510      	adds	r5, #16
 800b52e:	4564      	cmp	r4, ip
 800b530:	d1f5      	bne.n	800b51e <ATCoreTaskBody+0x166>
 800b532:	7823      	ldrb	r3, [r4, #0]
 800b534:	702b      	strb	r3, [r5, #0]
 800b536:	4c60      	ldr	r4, [pc, #384]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b538:	4620      	mov	r0, r4
 800b53a:	f013 fef6 	bl	801f32a <crs_strlen>
 800b53e:	b283      	uxth	r3, r0
 800b540:	4622      	mov	r2, r4
 800b542:	2110      	movs	r1, #16
 800b544:	2002      	movs	r0, #2
 800b546:	f013 ff33 	bl	801f3b0 <traceIF_itmPrint>
 800b54a:	4620      	mov	r0, r4
 800b54c:	f013 feed 	bl	801f32a <crs_strlen>
 800b550:	b283      	uxth	r3, r0
 800b552:	4622      	mov	r2, r4
 800b554:	2110      	movs	r1, #16
 800b556:	2002      	movs	r0, #2
 800b558:	f013 ff4c 	bl	801f3f4 <traceIF_uartPrint>
          ATParser_abort_request(&at_context[athandle]);
 800b55c:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b560:	4b5a      	ldr	r3, [pc, #360]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b562:	f240 609c 	movw	r0, #1692	; 0x69c
 800b566:	fb00 3002 	mla	r0, r0, r2, r3
 800b56a:	f009 fb74 	bl	8014c56 <ATParser_abort_request>
          TRACE_DBG("**** Sema Released on error 1 *****")
 800b56e:	4d5c      	ldr	r5, [pc, #368]	; (800b6e0 <ATCoreTaskBody+0x328>)
 800b570:	f105 0c20 	add.w	ip, r5, #32
 800b574:	462e      	mov	r6, r5
 800b576:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800b578:	6020      	str	r0, [r4, #0]
 800b57a:	6061      	str	r1, [r4, #4]
 800b57c:	60a2      	str	r2, [r4, #8]
 800b57e:	60e3      	str	r3, [r4, #12]
 800b580:	4635      	mov	r5, r6
 800b582:	3410      	adds	r4, #16
 800b584:	4566      	cmp	r6, ip
 800b586:	d1f5      	bne.n	800b574 <ATCoreTaskBody+0x1bc>
 800b588:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b58a:	6020      	str	r0, [r4, #0]
 800b58c:	6061      	str	r1, [r4, #4]
 800b58e:	60a2      	str	r2, [r4, #8]
 800b590:	782b      	ldrb	r3, [r5, #0]
 800b592:	7323      	strb	r3, [r4, #12]
 800b594:	4c48      	ldr	r4, [pc, #288]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b596:	4620      	mov	r0, r4
 800b598:	f013 fec7 	bl	801f32a <crs_strlen>
 800b59c:	b283      	uxth	r3, r0
 800b59e:	4622      	mov	r2, r4
 800b5a0:	2102      	movs	r1, #2
 800b5a2:	4608      	mov	r0, r1
 800b5a4:	f013 ff04 	bl	801f3b0 <traceIF_itmPrint>
 800b5a8:	4620      	mov	r0, r4
 800b5aa:	f013 febe 	bl	801f32a <crs_strlen>
 800b5ae:	b283      	uxth	r3, r0
 800b5b0:	4622      	mov	r2, r4
 800b5b2:	2102      	movs	r1, #2
 800b5b4:	4608      	mov	r0, r1
 800b5b6:	f013 ff1d 	bl	801f3f4 <traceIF_uartPrint>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
 800b5ba:	4b47      	ldr	r3, [pc, #284]	; (800b6d8 <ATCoreTaskBody+0x320>)
 800b5bc:	6818      	ldr	r0, [r3, #0]
 800b5be:	f013 fdc0 	bl	801f142 <rtosalSemaphoreRelease>
          continue;
 800b5c2:	e10d      	b.n	800b7e0 <ATCoreTaskBody+0x428>
          TRACE_ERR("AT_sendcmd error")
 800b5c4:	462c      	mov	r4, r5
 800b5c6:	4d47      	ldr	r5, [pc, #284]	; (800b6e4 <ATCoreTaskBody+0x32c>)
 800b5c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b5ca:	6020      	str	r0, [r4, #0]
 800b5cc:	6061      	str	r1, [r4, #4]
 800b5ce:	60a2      	str	r2, [r4, #8]
 800b5d0:	60e3      	str	r3, [r4, #12]
 800b5d2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b5d4:	6120      	str	r0, [r4, #16]
 800b5d6:	6161      	str	r1, [r4, #20]
 800b5d8:	61a2      	str	r2, [r4, #24]
 800b5da:	61e3      	str	r3, [r4, #28]
 800b5dc:	4620      	mov	r0, r4
 800b5de:	f013 fea4 	bl	801f32a <crs_strlen>
 800b5e2:	b283      	uxth	r3, r0
 800b5e4:	4622      	mov	r2, r4
 800b5e6:	2110      	movs	r1, #16
 800b5e8:	2002      	movs	r0, #2
 800b5ea:	f013 fee1 	bl	801f3b0 <traceIF_itmPrint>
 800b5ee:	4620      	mov	r0, r4
 800b5f0:	f013 fe9b 	bl	801f32a <crs_strlen>
 800b5f4:	b283      	uxth	r3, r0
 800b5f6:	4622      	mov	r2, r4
 800b5f8:	2110      	movs	r1, #16
 800b5fa:	2002      	movs	r0, #2
 800b5fc:	f013 fefa 	bl	801f3f4 <traceIF_uartPrint>
          ATParser_abort_request(&at_context[athandle]);
 800b600:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b604:	4b31      	ldr	r3, [pc, #196]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b606:	fb06 3002 	mla	r0, r6, r2, r3
 800b60a:	f009 fb24 	bl	8014c56 <ATParser_abort_request>
          TRACE_DBG("**** Sema Released on error 2 *****")
 800b60e:	4d36      	ldr	r5, [pc, #216]	; (800b6e8 <ATCoreTaskBody+0x330>)
 800b610:	f105 0c20 	add.w	ip, r5, #32
 800b614:	462e      	mov	r6, r5
 800b616:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800b618:	6020      	str	r0, [r4, #0]
 800b61a:	6061      	str	r1, [r4, #4]
 800b61c:	60a2      	str	r2, [r4, #8]
 800b61e:	60e3      	str	r3, [r4, #12]
 800b620:	4635      	mov	r5, r6
 800b622:	3410      	adds	r4, #16
 800b624:	4566      	cmp	r6, ip
 800b626:	d1f5      	bne.n	800b614 <ATCoreTaskBody+0x25c>
 800b628:	cd07      	ldmia	r5!, {r0, r1, r2}
 800b62a:	6020      	str	r0, [r4, #0]
 800b62c:	6061      	str	r1, [r4, #4]
 800b62e:	60a2      	str	r2, [r4, #8]
 800b630:	782b      	ldrb	r3, [r5, #0]
 800b632:	7323      	strb	r3, [r4, #12]
 800b634:	4c20      	ldr	r4, [pc, #128]	; (800b6b8 <ATCoreTaskBody+0x300>)
 800b636:	4620      	mov	r0, r4
 800b638:	f013 fe77 	bl	801f32a <crs_strlen>
 800b63c:	b283      	uxth	r3, r0
 800b63e:	4622      	mov	r2, r4
 800b640:	2102      	movs	r1, #2
 800b642:	4608      	mov	r0, r1
 800b644:	f013 feb4 	bl	801f3b0 <traceIF_itmPrint>
 800b648:	4620      	mov	r0, r4
 800b64a:	f013 fe6e 	bl	801f32a <crs_strlen>
 800b64e:	b283      	uxth	r3, r0
 800b650:	4622      	mov	r2, r4
 800b652:	2102      	movs	r1, #2
 800b654:	4608      	mov	r0, r1
 800b656:	f013 fecd 	bl	801f3f4 <traceIF_uartPrint>
          (void) rtosalSemaphoreRelease(s_WaitAnswer_SemaphoreId);
 800b65a:	4b1f      	ldr	r3, [pc, #124]	; (800b6d8 <ATCoreTaskBody+0x320>)
 800b65c:	6818      	ldr	r0, [r3, #0]
 800b65e:	f013 fd70 	bl	801f142 <rtosalSemaphoreRelease>
          continue;
 800b662:	e0bd      	b.n	800b7e0 <ATCoreTaskBody+0x428>
          if (register_URC_callback[athandle] != NULL)
 800b664:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b668:	4b20      	ldr	r3, [pc, #128]	; (800b6ec <ATCoreTaskBody+0x334>)
 800b66a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b66e:	2b00      	cmp	r3, #0
 800b670:	f000 80b6 	beq.w	800b7e0 <ATCoreTaskBody+0x428>
 800b674:	e009      	b.n	800b68a <ATCoreTaskBody+0x2d2>
                (* register_URC_callback[athandle])(urc_buf);
 800b676:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b67a:	4b1c      	ldr	r3, [pc, #112]	; (800b6ec <ATCoreTaskBody+0x334>)
 800b67c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b680:	481b      	ldr	r0, [pc, #108]	; (800b6f0 <ATCoreTaskBody+0x338>)
 800b682:	4798      	blx	r3
            } while (retUrc == ATSTATUS_OK_PENDING_URC);
 800b684:	2c03      	cmp	r4, #3
 800b686:	f040 80ab 	bne.w	800b7e0 <ATCoreTaskBody+0x428>
              (void) memset((void *) urc_buf, 0, ATCMD_MAX_BUF_SIZE);
 800b68a:	4c19      	ldr	r4, [pc, #100]	; (800b6f0 <ATCoreTaskBody+0x338>)
 800b68c:	2280      	movs	r2, #128	; 0x80
 800b68e:	2100      	movs	r1, #0
 800b690:	4620      	mov	r0, r4
 800b692:	f01b f94c 	bl	802692e <memset>
              retUrc = ATParser_get_urc(&at_context[athandle], urc_buf);
 800b696:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b69a:	4621      	mov	r1, r4
 800b69c:	4b0b      	ldr	r3, [pc, #44]	; (800b6cc <ATCoreTaskBody+0x314>)
 800b69e:	f240 609c 	movw	r0, #1692	; 0x69c
 800b6a2:	fb00 3002 	mla	r0, r0, r2, r3
 800b6a6:	f009 face 	bl	8014c46 <ATParser_get_urc>
              if ((retUrc == ATSTATUS_OK) || (retUrc == ATSTATUS_OK_PENDING_URC))
 800b6aa:	4604      	mov	r4, r0
 800b6ac:	2800      	cmp	r0, #0
 800b6ae:	d0e2      	beq.n	800b676 <ATCoreTaskBody+0x2be>
 800b6b0:	2803      	cmp	r0, #3
 800b6b2:	d1e7      	bne.n	800b684 <ATCoreTaskBody+0x2cc>
 800b6b4:	e7df      	b.n	800b676 <ATCoreTaskBody+0x2be>
 800b6b6:	bf00      	nop
 800b6b8:	200048dc 	.word	0x200048dc
 800b6bc:	0802dfc4 	.word	0x0802dfc4
 800b6c0:	20002d68 	.word	0x20002d68
 800b6c4:	20002570 	.word	0x20002570
 800b6c8:	20001888 	.word	0x20001888
 800b6cc:	2000188c 	.word	0x2000188c
 800b6d0:	0802e06c 	.word	0x0802e06c
 800b6d4:	0802e0e4 	.word	0x0802e0e4
 800b6d8:	20003544 	.word	0x20003544
 800b6dc:	0802e018 	.word	0x0802e018
 800b6e0:	0802e03c 	.word	0x0802e03c
 800b6e4:	0802e094 	.word	0x0802e094
 800b6e8:	0802e0b4 	.word	0x0802e0b4
 800b6ec:	20003540 	.word	0x20003540
 800b6f0:	20003548 	.word	0x20003548
      else if (msg == (SIG_INTERNAL_EVENT_MODEM))
      {
        /* An internal event has been received (ie not coming from IPC: could be an interrupt from modem,...)
         * Do not call IPC_receive in this case
         */
        TRACE_INFO("!!! an internal event has been received !!!")
 800b6f4:	4e52      	ldr	r6, [pc, #328]	; (800b840 <ATCoreTaskBody+0x488>)
 800b6f6:	4c53      	ldr	r4, [pc, #332]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b6f8:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 800b6fc:	4635      	mov	r5, r6
 800b6fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800b700:	6020      	str	r0, [r4, #0]
 800b702:	6061      	str	r1, [r4, #4]
 800b704:	60a2      	str	r2, [r4, #8]
 800b706:	60e3      	str	r3, [r4, #12]
 800b708:	462e      	mov	r6, r5
 800b70a:	3410      	adds	r4, #16
 800b70c:	4565      	cmp	r5, ip
 800b70e:	d1f5      	bne.n	800b6fc <ATCoreTaskBody+0x344>
 800b710:	6828      	ldr	r0, [r5, #0]
 800b712:	6020      	str	r0, [r4, #0]
 800b714:	792b      	ldrb	r3, [r5, #4]
 800b716:	7123      	strb	r3, [r4, #4]
 800b718:	4c4a      	ldr	r4, [pc, #296]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b71a:	4620      	mov	r0, r4
 800b71c:	f013 fe05 	bl	801f32a <crs_strlen>
 800b720:	b283      	uxth	r3, r0
 800b722:	4622      	mov	r2, r4
 800b724:	2101      	movs	r1, #1
 800b726:	2002      	movs	r0, #2
 800b728:	f013 fe42 	bl	801f3b0 <traceIF_itmPrint>
 800b72c:	4620      	mov	r0, r4
 800b72e:	f013 fdfc 	bl	801f32a <crs_strlen>
 800b732:	b283      	uxth	r3, r0
 800b734:	4622      	mov	r2, r4
 800b736:	2101      	movs	r1, #1
 800b738:	2002      	movs	r0, #2
 800b73a:	f013 fe5b 	bl	801f3f4 <traceIF_uartPrint>
        athandle = find_deviceType_ATHandle(DEVTYPE_MODEM_CELLULAR);
 800b73e:	2000      	movs	r0, #0
 800b740:	f7ff f9b2 	bl	800aaa8 <find_deviceType_ATHandle>
 800b744:	f8ad 0006 	strh.w	r0, [sp, #6]
        if (athandle != AT_HANDLE_INVALID)
 800b748:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b74c:	d048      	beq.n	800b7e0 <ATCoreTaskBody+0x428>
        {
          if (register_URC_callback[athandle] != NULL)
 800b74e:	4b3e      	ldr	r3, [pc, #248]	; (800b848 <ATCoreTaskBody+0x490>)
 800b750:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 800b754:	2b00      	cmp	r3, #0
 800b756:	d043      	beq.n	800b7e0 <ATCoreTaskBody+0x428>
 800b758:	e008      	b.n	800b76c <ATCoreTaskBody+0x3b4>
              (void) memset((void *) urc_buf, 0, ATCMD_MAX_BUF_SIZE);
              retUrc = ATParser_get_urc(&at_context[athandle], urc_buf);
              if ((retUrc == ATSTATUS_OK) || (retUrc == ATSTATUS_OK_PENDING_URC))
              {
                /* call the URC callback */
                (* register_URC_callback[athandle])(urc_buf);
 800b75a:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b75e:	4b3a      	ldr	r3, [pc, #232]	; (800b848 <ATCoreTaskBody+0x490>)
 800b760:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800b764:	4839      	ldr	r0, [pc, #228]	; (800b84c <ATCoreTaskBody+0x494>)
 800b766:	4798      	blx	r3
              }
            } while (retUrc == ATSTATUS_OK_PENDING_URC);
 800b768:	2c03      	cmp	r4, #3
 800b76a:	d139      	bne.n	800b7e0 <ATCoreTaskBody+0x428>
              (void) memset((void *) urc_buf, 0, ATCMD_MAX_BUF_SIZE);
 800b76c:	4c37      	ldr	r4, [pc, #220]	; (800b84c <ATCoreTaskBody+0x494>)
 800b76e:	2280      	movs	r2, #128	; 0x80
 800b770:	2100      	movs	r1, #0
 800b772:	4620      	mov	r0, r4
 800b774:	f01b f8db 	bl	802692e <memset>
              retUrc = ATParser_get_urc(&at_context[athandle], urc_buf);
 800b778:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b77c:	4621      	mov	r1, r4
 800b77e:	4b34      	ldr	r3, [pc, #208]	; (800b850 <ATCoreTaskBody+0x498>)
 800b780:	f240 609c 	movw	r0, #1692	; 0x69c
 800b784:	fb00 3002 	mla	r0, r0, r2, r3
 800b788:	f009 fa5d 	bl	8014c46 <ATParser_get_urc>
              if ((retUrc == ATSTATUS_OK) || (retUrc == ATSTATUS_OK_PENDING_URC))
 800b78c:	4604      	mov	r4, r0
 800b78e:	2800      	cmp	r0, #0
 800b790:	d0e3      	beq.n	800b75a <ATCoreTaskBody+0x3a2>
 800b792:	2803      	cmp	r0, #3
 800b794:	d1e8      	bne.n	800b768 <ATCoreTaskBody+0x3b0>
 800b796:	e7e0      	b.n	800b75a <ATCoreTaskBody+0x3a2>
        }
      }
      else
      {
        /* should not happen */
        TRACE_INFO("an unexpected event has been received !!!")
 800b798:	46ac      	mov	ip, r5
 800b79a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800b79e:	6020      	str	r0, [r4, #0]
 800b7a0:	6061      	str	r1, [r4, #4]
 800b7a2:	60a2      	str	r2, [r4, #8]
 800b7a4:	60e3      	str	r3, [r4, #12]
 800b7a6:	4665      	mov	r5, ip
 800b7a8:	3410      	adds	r4, #16
 800b7aa:	45b4      	cmp	ip, r6
 800b7ac:	d1f4      	bne.n	800b798 <ATCoreTaskBody+0x3e0>
 800b7ae:	f8bc 2000 	ldrh.w	r2, [ip]
 800b7b2:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800b7b6:	8022      	strh	r2, [r4, #0]
 800b7b8:	70a3      	strb	r3, [r4, #2]
 800b7ba:	4c22      	ldr	r4, [pc, #136]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b7bc:	4620      	mov	r0, r4
 800b7be:	f013 fdb4 	bl	801f32a <crs_strlen>
 800b7c2:	b283      	uxth	r3, r0
 800b7c4:	4622      	mov	r2, r4
 800b7c6:	2101      	movs	r1, #1
 800b7c8:	2002      	movs	r0, #2
 800b7ca:	f013 fdf1 	bl	801f3b0 <traceIF_itmPrint>
 800b7ce:	4620      	mov	r0, r4
 800b7d0:	f013 fdab 	bl	801f32a <crs_strlen>
 800b7d4:	b283      	uxth	r3, r0
 800b7d6:	4622      	mov	r2, r4
 800b7d8:	2101      	movs	r1, #1
 800b7da:	2002      	movs	r0, #2
 800b7dc:	f013 fe0a 	bl	801f3f4 <traceIF_uartPrint>
    status = rtosalMessageQueueGet(q_msg_IPC_received_Id,
 800b7e0:	f04f 32ff 	mov.w	r2, #4294967295
 800b7e4:	4669      	mov	r1, sp
 800b7e6:	4b1b      	ldr	r3, [pc, #108]	; (800b854 <ATCoreTaskBody+0x49c>)
 800b7e8:	6818      	ldr	r0, [r3, #0]
 800b7ea:	f013 fcd0 	bl	801f18e <rtosalMessageQueueGet>
    if ((status == osEventMessage) || (status == osOK))
 800b7ee:	2810      	cmp	r0, #16
 800b7f0:	d001      	beq.n	800b7f6 <ATCoreTaskBody+0x43e>
 800b7f2:	2800      	cmp	r0, #0
 800b7f4:	d1f4      	bne.n	800b7e0 <ATCoreTaskBody+0x428>
      TRACE_DBG("<ATCore TASK> - received msg event= 0x%lx", msg)
 800b7f6:	4c13      	ldr	r4, [pc, #76]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b7f8:	9a00      	ldr	r2, [sp, #0]
 800b7fa:	4917      	ldr	r1, [pc, #92]	; (800b858 <ATCoreTaskBody+0x4a0>)
 800b7fc:	4620      	mov	r0, r4
 800b7fe:	f01b f823 	bl	8026848 <sprintf>
 800b802:	4620      	mov	r0, r4
 800b804:	f013 fd91 	bl	801f32a <crs_strlen>
 800b808:	b283      	uxth	r3, r0
 800b80a:	4622      	mov	r2, r4
 800b80c:	2102      	movs	r1, #2
 800b80e:	4608      	mov	r0, r1
 800b810:	f013 fdce 	bl	801f3b0 <traceIF_itmPrint>
 800b814:	4620      	mov	r0, r4
 800b816:	f013 fd88 	bl	801f32a <crs_strlen>
 800b81a:	b283      	uxth	r3, r0
 800b81c:	4622      	mov	r2, r4
 800b81e:	2102      	movs	r1, #2
 800b820:	4608      	mov	r0, r1
 800b822:	f013 fde7 	bl	801f3f4 <traceIF_uartPrint>
      if (msg == (SIG_IPC_MSG))
 800b826:	9b00      	ldr	r3, [sp, #0]
 800b828:	2b01      	cmp	r3, #1
 800b82a:	f43f ade9 	beq.w	800b400 <ATCoreTaskBody+0x48>
      else if (msg == (SIG_INTERNAL_EVENT_MODEM))
 800b82e:	2b02      	cmp	r3, #2
 800b830:	f43f af60 	beq.w	800b6f4 <ATCoreTaskBody+0x33c>
        TRACE_INFO("an unexpected event has been received !!!")
 800b834:	4d09      	ldr	r5, [pc, #36]	; (800b85c <ATCoreTaskBody+0x4a4>)
 800b836:	4c03      	ldr	r4, [pc, #12]	; (800b844 <ATCoreTaskBody+0x48c>)
 800b838:	f105 0630 	add.w	r6, r5, #48	; 0x30
 800b83c:	e7ac      	b.n	800b798 <ATCoreTaskBody+0x3e0>
 800b83e:	bf00      	nop
 800b840:	0802e108 	.word	0x0802e108
 800b844:	200048dc 	.word	0x200048dc
 800b848:	20003540 	.word	0x20003540
 800b84c:	20003548 	.word	0x20003548
 800b850:	2000188c 	.word	0x2000188c
 800b854:	2000353c 	.word	0x2000353c
 800b858:	0802dfe4 	.word	0x0802dfe4
 800b85c:	0802e140 	.word	0x0802e140

0800b860 <AT_init>:
{
 800b860:	b510      	push	{r4, lr}
  if (AT_Core_initialized == 1U)
 800b862:	4b1a      	ldr	r3, [pc, #104]	; (800b8cc <AT_init+0x6c>)
 800b864:	781c      	ldrb	r4, [r3, #0]
 800b866:	2c01      	cmp	r4, #1
 800b868:	d12e      	bne.n	800b8c8 <AT_init+0x68>
    LOG_ERROR(1, ERROR_WARNING);
 800b86a:	2202      	movs	r2, #2
 800b86c:	2101      	movs	r1, #1
 800b86e:	4610      	mov	r0, r2
 800b870:	f012 fd78 	bl	801e364 <ERROR_Handler>
}
 800b874:	4620      	mov	r0, r4
 800b876:	bd10      	pop	{r4, pc}
      MsgReceived[idx] = 0U;
 800b878:	2100      	movs	r1, #0
 800b87a:	4b15      	ldr	r3, [pc, #84]	; (800b8d0 <AT_init+0x70>)
 800b87c:	5519      	strb	r1, [r3, r4]
      register_URC_callback[idx] = NULL;
 800b87e:	4b15      	ldr	r3, [pc, #84]	; (800b8d4 <AT_init+0x74>)
 800b880:	f843 1024 	str.w	r1, [r3, r4, lsl #2]
      at_context[idx].device_type = DEVTYPE_INVALID;
 800b884:	4814      	ldr	r0, [pc, #80]	; (800b8d8 <AT_init+0x78>)
 800b886:	f240 639c 	movw	r3, #1692	; 0x69c
 800b88a:	fb04 f303 	mul.w	r3, r4, r3
 800b88e:	18c2      	adds	r2, r0, r3
 800b890:	f04f 0c01 	mov.w	ip, #1
 800b894:	f800 c003 	strb.w	ip, [r0, r3]
      at_context[idx].in_data_mode = AT_FALSE;
 800b898:	7291      	strb	r1, [r2, #10]
      at_context[idx].processing_cmd = 0U;
 800b89a:	72d1      	strb	r1, [r2, #11]
      at_context[idx].dataSent = AT_FALSE;
 800b89c:	7311      	strb	r1, [r2, #12]
      at_context[idx].action_flags = ATACTION_RSP_NO_ACTION;
 800b89e:	f8a2 1690 	strh.w	r1, [r2, #1680]	; 0x690
      at_context[idx].p_rsp_buf = NULL;
 800b8a2:	f8c2 1694 	str.w	r1, [r2, #1684]	; 0x694
      at_context[idx].s_SendConfirm_SemaphoreId = NULL;
 800b8a6:	f8c2 1698 	str.w	r1, [r2, #1688]	; 0x698
      (void) memset((void *)&at_context[idx].parser, 0, sizeof(atparser_context_t));
 800b8aa:	3310      	adds	r3, #16
 800b8ac:	f44f 62d0 	mov.w	r2, #1664	; 0x680
 800b8b0:	4418      	add	r0, r3
 800b8b2:	f01b f83c 	bl	802692e <memset>
    for (idx = 0; idx < ATCORE_MAX_HANDLES; idx++)
 800b8b6:	3401      	adds	r4, #1
 800b8b8:	b224      	sxth	r4, r4
 800b8ba:	2c00      	cmp	r4, #0
 800b8bc:	dddc      	ble.n	800b878 <AT_init+0x18>
    AT_Core_initialized = 1U;
 800b8be:	4b03      	ldr	r3, [pc, #12]	; (800b8cc <AT_init+0x6c>)
 800b8c0:	2201      	movs	r2, #1
 800b8c2:	701a      	strb	r2, [r3, #0]
    retval = ATSTATUS_OK;
 800b8c4:	2400      	movs	r4, #0
 800b8c6:	e7d5      	b.n	800b874 <AT_init+0x14>
    for (idx = 0; idx < ATCORE_MAX_HANDLES; idx++)
 800b8c8:	2400      	movs	r4, #0
 800b8ca:	e7f6      	b.n	800b8ba <AT_init+0x5a>
 800b8cc:	20001884 	.word	0x20001884
 800b8d0:	20001888 	.word	0x20001888
 800b8d4:	20003540 	.word	0x20003540
 800b8d8:	2000188c 	.word	0x2000188c

0800b8dc <AT_open>:
{
 800b8dc:	b570      	push	{r4, r5, r6, lr}
 800b8de:	b082      	sub	sp, #8
 800b8e0:	4604      	mov	r4, r0
 800b8e2:	4615      	mov	r5, r2
  if (ATParser_initParsers(p_device_infos->type) != ATSTATUS_OK)
 800b8e4:	7800      	ldrb	r0, [r0, #0]
 800b8e6:	f009 f801 	bl	80148ec <ATParser_initParsers>
 800b8ea:	b318      	cbz	r0, 800b934 <AT_open+0x58>
    affectedHandle = AT_HANDLE_INVALID;
 800b8ec:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b8f0:	f8ad 3006 	strh.w	r3, [sp, #6]
  if (affectedHandle != AT_HANDLE_INVALID)
 800b8f4:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b8f8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b8fc:	d016      	beq.n	800b92c <AT_open+0x50>
    at_context[affectedHandle].ipc_handle = &ipcHandleTab[affectedHandle];
 800b8fe:	ebc3 2103 	rsb	r1, r3, r3, lsl #8
 800b902:	4a30      	ldr	r2, [pc, #192]	; (800b9c4 <AT_open+0xe8>)
 800b904:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800b908:	4e2f      	ldr	r6, [pc, #188]	; (800b9c8 <AT_open+0xec>)
 800b90a:	f240 619c 	movw	r1, #1692	; 0x69c
 800b90e:	fb03 f101 	mul.w	r1, r3, r1
 800b912:	1870      	adds	r0, r6, r1
 800b914:	6042      	str	r2, [r0, #4]
    at_context[affectedHandle].device_type = p_device_infos->type;
 800b916:	7822      	ldrb	r2, [r4, #0]
 800b918:	5472      	strb	r2, [r6, r1]
    at_context[affectedHandle].ipc_device  = p_device_infos->ipc_device;
 800b91a:	7862      	ldrb	r2, [r4, #1]
 800b91c:	7202      	strb	r2, [r0, #8]
    if (p_device_infos->ipc_interface == IPC_INTERFACE_UART)
 800b91e:	78a2      	ldrb	r2, [r4, #2]
 800b920:	2a01      	cmp	r2, #1
 800b922:	d012      	beq.n	800b94a <AT_open+0x6e>
      affectedHandle = AT_HANDLE_INVALID;
 800b924:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b928:	f8ad 3006 	strh.w	r3, [sp, #6]
}
 800b92c:	f9bd 0006 	ldrsh.w	r0, [sp, #6]
 800b930:	b002      	add	sp, #8
 800b932:	bd70      	pop	{r4, r5, r6, pc}
  else if (allocate_ATHandle(&affectedHandle) != ATSTATUS_OK)
 800b934:	f10d 0006 	add.w	r0, sp, #6
 800b938:	f7ff f8da 	bl	800aaf0 <allocate_ATHandle>
 800b93c:	2800      	cmp	r0, #0
 800b93e:	d0d9      	beq.n	800b8f4 <AT_open+0x18>
    affectedHandle = AT_HANDLE_INVALID;
 800b940:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b944:	f8ad 3006 	strh.w	r3, [sp, #6]
 800b948:	e7d4      	b.n	800b8f4 <AT_open+0x18>
      at_context[affectedHandle].ipc_mode = IPC_MODE_UART_CHARACTER;
 800b94a:	4604      	mov	r4, r0
 800b94c:	2300      	movs	r3, #0
 800b94e:	7243      	strb	r3, [r0, #9]
      at_context[affectedHandle].in_data_mode = AT_FALSE;
 800b950:	7283      	strb	r3, [r0, #10]
      at_context[affectedHandle].processing_cmd = 0U;
 800b952:	72c3      	strb	r3, [r0, #11]
      at_context[affectedHandle].dataSent = AT_FALSE;
 800b954:	7303      	strb	r3, [r0, #12]
        rtosalSemaphoreNew((const rtosal_char_t *)"ATCORE_SEM_SEND",
 800b956:	2101      	movs	r1, #1
 800b958:	481c      	ldr	r0, [pc, #112]	; (800b9cc <AT_open+0xf0>)
 800b95a:	f013 fbe4 	bl	801f126 <rtosalSemaphoreNew>
      at_context[affectedHandle].s_SendConfirm_SemaphoreId =
 800b95e:	f8c4 0698 	str.w	r0, [r4, #1688]	; 0x698
      if (at_context[affectedHandle].s_SendConfirm_SemaphoreId != NULL)
 800b962:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 800b966:	b180      	cbz	r0, 800b98a <AT_open+0xae>
        (void) rtosalSemaphoreAcquire(at_context[affectedHandle].s_SendConfirm_SemaphoreId, 5000U);
 800b968:	f241 3188 	movw	r1, #5000	; 0x1388
 800b96c:	f013 fbe5 	bl	801f13a <rtosalSemaphoreAcquire>
        register_URC_callback[affectedHandle] = urc_callback;
 800b970:	f9bd 3006 	ldrsh.w	r3, [sp, #6]
 800b974:	4a16      	ldr	r2, [pc, #88]	; (800b9d0 <AT_open+0xf4>)
 800b976:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
        ATParser_init(&at_context[affectedHandle], &custom_checkEndOfMsgCallback);
 800b97a:	4916      	ldr	r1, [pc, #88]	; (800b9d4 <AT_open+0xf8>)
 800b97c:	f240 609c 	movw	r0, #1692	; 0x69c
 800b980:	fb00 6003 	mla	r0, r0, r3, r6
 800b984:	f008 ffb6 	bl	80148f4 <ATParser_init>
 800b988:	e7d0      	b.n	800b92c <AT_open+0x50>
        TRACE_ERR("SendSemaphoreId creation error for handle = %d", affectedHandle)
 800b98a:	4c13      	ldr	r4, [pc, #76]	; (800b9d8 <AT_open+0xfc>)
 800b98c:	4913      	ldr	r1, [pc, #76]	; (800b9dc <AT_open+0x100>)
 800b98e:	4620      	mov	r0, r4
 800b990:	f01a ff5a 	bl	8026848 <sprintf>
 800b994:	4620      	mov	r0, r4
 800b996:	f013 fcc8 	bl	801f32a <crs_strlen>
 800b99a:	b283      	uxth	r3, r0
 800b99c:	4622      	mov	r2, r4
 800b99e:	2110      	movs	r1, #16
 800b9a0:	2002      	movs	r0, #2
 800b9a2:	f013 fd05 	bl	801f3b0 <traceIF_itmPrint>
 800b9a6:	4620      	mov	r0, r4
 800b9a8:	f013 fcbf 	bl	801f32a <crs_strlen>
 800b9ac:	b283      	uxth	r3, r0
 800b9ae:	4622      	mov	r2, r4
 800b9b0:	2110      	movs	r1, #16
 800b9b2:	2002      	movs	r0, #2
 800b9b4:	f013 fd1e 	bl	801f3f4 <traceIF_uartPrint>
        affectedHandle = AT_HANDLE_INVALID;
 800b9b8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800b9bc:	f8ad 3006 	strh.w	r3, [sp, #6]
 800b9c0:	e7b4      	b.n	800b92c <AT_open+0x50>
 800b9c2:	bf00      	nop
 800b9c4:	20002570 	.word	0x20002570
 800b9c8:	2000188c 	.word	0x2000188c
 800b9cc:	0802e174 	.word	0x0802e174
 800b9d0:	20003540 	.word	0x20003540
 800b9d4:	2000256c 	.word	0x2000256c
 800b9d8:	200048dc 	.word	0x200048dc
 800b9dc:	0802e184 	.word	0x0802e184

0800b9e0 <AT_open_channel>:
{
 800b9e0:	b570      	push	{r4, r5, r6, lr}
 800b9e2:	b082      	sub	sp, #8
  if (athandle != AT_HANDLE_INVALID)
 800b9e4:	f1b0 3fff 	cmp.w	r0, #4294967295
 800b9e8:	d063      	beq.n	800bab2 <AT_open_channel+0xd2>
    at_context[athandle].in_data_mode = AT_FALSE;
 800b9ea:	4c46      	ldr	r4, [pc, #280]	; (800bb04 <AT_open_channel+0x124>)
 800b9ec:	f240 639c 	movw	r3, #1692	; 0x69c
 800b9f0:	fb03 4400 	mla	r4, r3, r0, r4
 800b9f4:	2300      	movs	r3, #0
 800b9f6:	72a3      	strb	r3, [r4, #10]
    at_context[athandle].processing_cmd = 0U;
 800b9f8:	72e3      	strb	r3, [r4, #11]
    at_context[athandle].dataSent = AT_FALSE;
 800b9fa:	7323      	strb	r3, [r4, #12]
    at_context[athandle].action_flags = ATACTION_RSP_NO_ACTION;
 800b9fc:	f8a4 3690 	strh.w	r3, [r4, #1680]	; 0x690
    if (IPC_open(at_context[athandle].ipc_handle,
 800ba00:	4b41      	ldr	r3, [pc, #260]	; (800bb08 <AT_open_channel+0x128>)
 800ba02:	681b      	ldr	r3, [r3, #0]
 800ba04:	9301      	str	r3, [sp, #4]
 800ba06:	4b41      	ldr	r3, [pc, #260]	; (800bb0c <AT_open_channel+0x12c>)
 800ba08:	9300      	str	r3, [sp, #0]
 800ba0a:	4b41      	ldr	r3, [pc, #260]	; (800bb10 <AT_open_channel+0x130>)
 800ba0c:	7a62      	ldrb	r2, [r4, #9]
 800ba0e:	7a21      	ldrb	r1, [r4, #8]
 800ba10:	6860      	ldr	r0, [r4, #4]
 800ba12:	f012 fd6f 	bl	801e4f4 <IPC_open>
 800ba16:	bb58      	cbnz	r0, 800ba70 <AT_open_channel+0x90>
      if (IPC_select(at_context[athandle].ipc_handle) == IPC_OK)
 800ba18:	6860      	ldr	r0, [r4, #4]
 800ba1a:	f012 fdac 	bl	801e576 <IPC_select>
 800ba1e:	2800      	cmp	r0, #0
 800ba20:	d06d      	beq.n	800bafe <AT_open_channel+0x11e>
        TRACE_ERR("IPC selection error")
 800ba22:	4e3c      	ldr	r6, [pc, #240]	; (800bb14 <AT_open_channel+0x134>)
 800ba24:	4c3c      	ldr	r4, [pc, #240]	; (800bb18 <AT_open_channel+0x138>)
 800ba26:	f106 0c20 	add.w	ip, r6, #32
 800ba2a:	4635      	mov	r5, r6
 800ba2c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ba2e:	6020      	str	r0, [r4, #0]
 800ba30:	6061      	str	r1, [r4, #4]
 800ba32:	60a2      	str	r2, [r4, #8]
 800ba34:	60e3      	str	r3, [r4, #12]
 800ba36:	462e      	mov	r6, r5
 800ba38:	3410      	adds	r4, #16
 800ba3a:	4565      	cmp	r5, ip
 800ba3c:	d1f5      	bne.n	800ba2a <AT_open_channel+0x4a>
 800ba3e:	882a      	ldrh	r2, [r5, #0]
 800ba40:	78ab      	ldrb	r3, [r5, #2]
 800ba42:	8022      	strh	r2, [r4, #0]
 800ba44:	70a3      	strb	r3, [r4, #2]
 800ba46:	4c34      	ldr	r4, [pc, #208]	; (800bb18 <AT_open_channel+0x138>)
 800ba48:	4620      	mov	r0, r4
 800ba4a:	f013 fc6e 	bl	801f32a <crs_strlen>
 800ba4e:	b283      	uxth	r3, r0
 800ba50:	4622      	mov	r2, r4
 800ba52:	2110      	movs	r1, #16
 800ba54:	2002      	movs	r0, #2
 800ba56:	f013 fcab 	bl	801f3b0 <traceIF_itmPrint>
 800ba5a:	4620      	mov	r0, r4
 800ba5c:	f013 fc65 	bl	801f32a <crs_strlen>
 800ba60:	b283      	uxth	r3, r0
 800ba62:	4622      	mov	r2, r4
 800ba64:	2110      	movs	r1, #16
 800ba66:	2002      	movs	r0, #2
 800ba68:	f013 fcc4 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800ba6c:	2001      	movs	r0, #1
 800ba6e:	e046      	b.n	800bafe <AT_open_channel+0x11e>
      TRACE_ERR("IPC open error")
 800ba70:	4c29      	ldr	r4, [pc, #164]	; (800bb18 <AT_open_channel+0x138>)
 800ba72:	4d2a      	ldr	r5, [pc, #168]	; (800bb1c <AT_open_channel+0x13c>)
 800ba74:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ba76:	6020      	str	r0, [r4, #0]
 800ba78:	6061      	str	r1, [r4, #4]
 800ba7a:	60a2      	str	r2, [r4, #8]
 800ba7c:	60e3      	str	r3, [r4, #12]
 800ba7e:	cd07      	ldmia	r5!, {r0, r1, r2}
 800ba80:	6120      	str	r0, [r4, #16]
 800ba82:	6161      	str	r1, [r4, #20]
 800ba84:	61a2      	str	r2, [r4, #24]
 800ba86:	882b      	ldrh	r3, [r5, #0]
 800ba88:	83a3      	strh	r3, [r4, #28]
 800ba8a:	4620      	mov	r0, r4
 800ba8c:	f013 fc4d 	bl	801f32a <crs_strlen>
 800ba90:	b283      	uxth	r3, r0
 800ba92:	4622      	mov	r2, r4
 800ba94:	2110      	movs	r1, #16
 800ba96:	2002      	movs	r0, #2
 800ba98:	f013 fc8a 	bl	801f3b0 <traceIF_itmPrint>
 800ba9c:	4620      	mov	r0, r4
 800ba9e:	f013 fc44 	bl	801f32a <crs_strlen>
 800baa2:	b283      	uxth	r3, r0
 800baa4:	4622      	mov	r2, r4
 800baa6:	2110      	movs	r1, #16
 800baa8:	2002      	movs	r0, #2
 800baaa:	f013 fca3 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800baae:	2001      	movs	r0, #1
 800bab0:	e025      	b.n	800bafe <AT_open_channel+0x11e>
    TRACE_ERR("IPC invalid handle")
 800bab2:	4d1b      	ldr	r5, [pc, #108]	; (800bb20 <AT_open_channel+0x140>)
 800bab4:	4c18      	ldr	r4, [pc, #96]	; (800bb18 <AT_open_channel+0x138>)
 800bab6:	f105 0620 	add.w	r6, r5, #32
 800baba:	46ac      	mov	ip, r5
 800babc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bac0:	6020      	str	r0, [r4, #0]
 800bac2:	6061      	str	r1, [r4, #4]
 800bac4:	60a2      	str	r2, [r4, #8]
 800bac6:	60e3      	str	r3, [r4, #12]
 800bac8:	4665      	mov	r5, ip
 800baca:	3410      	adds	r4, #16
 800bacc:	45b4      	cmp	ip, r6
 800bace:	d1f4      	bne.n	800baba <AT_open_channel+0xda>
 800bad0:	f8bc 3000 	ldrh.w	r3, [ip]
 800bad4:	8023      	strh	r3, [r4, #0]
 800bad6:	4c10      	ldr	r4, [pc, #64]	; (800bb18 <AT_open_channel+0x138>)
 800bad8:	4620      	mov	r0, r4
 800bada:	f013 fc26 	bl	801f32a <crs_strlen>
 800bade:	b283      	uxth	r3, r0
 800bae0:	4622      	mov	r2, r4
 800bae2:	2110      	movs	r1, #16
 800bae4:	2002      	movs	r0, #2
 800bae6:	f013 fc63 	bl	801f3b0 <traceIF_itmPrint>
 800baea:	4620      	mov	r0, r4
 800baec:	f013 fc1d 	bl	801f32a <crs_strlen>
 800baf0:	b283      	uxth	r3, r0
 800baf2:	4622      	mov	r2, r4
 800baf4:	2110      	movs	r1, #16
 800baf6:	2002      	movs	r0, #2
 800baf8:	f013 fc7c 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800bafc:	2001      	movs	r0, #1
}
 800bafe:	b002      	add	sp, #8
 800bb00:	bd70      	pop	{r4, r5, r6, pc}
 800bb02:	bf00      	nop
 800bb04:	2000188c 	.word	0x2000188c
 800bb08:	2000256c 	.word	0x2000256c
 800bb0c:	0800ac61 	.word	0x0800ac61
 800bb10:	0800ac85 	.word	0x0800ac85
 800bb14:	0802e1c4 	.word	0x0802e1c4
 800bb18:	200048dc 	.word	0x200048dc
 800bb1c:	0802e1e8 	.word	0x0802e1e8
 800bb20:	0802e208 	.word	0x0802e208

0800bb24 <AT_close_channel>:
{
 800bb24:	b538      	push	{r3, r4, r5, lr}
  if (athandle != AT_HANDLE_INVALID)
 800bb26:	f1b0 3fff 	cmp.w	r0, #4294967295
 800bb2a:	d02c      	beq.n	800bb86 <AT_close_channel+0x62>
    if (IPC_close(at_context[athandle].ipc_handle) == IPC_OK)
 800bb2c:	4b29      	ldr	r3, [pc, #164]	; (800bbd4 <AT_close_channel+0xb0>)
 800bb2e:	f240 629c 	movw	r2, #1692	; 0x69c
 800bb32:	fb02 3300 	mla	r3, r2, r0, r3
 800bb36:	6858      	ldr	r0, [r3, #4]
 800bb38:	f012 fd08 	bl	801e54c <IPC_close>
 800bb3c:	b900      	cbnz	r0, 800bb40 <AT_close_channel+0x1c>
}
 800bb3e:	bd38      	pop	{r3, r4, r5, pc}
      TRACE_ERR("IPC close error")
 800bb40:	4c25      	ldr	r4, [pc, #148]	; (800bbd8 <AT_close_channel+0xb4>)
 800bb42:	4d26      	ldr	r5, [pc, #152]	; (800bbdc <AT_close_channel+0xb8>)
 800bb44:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800bb46:	6020      	str	r0, [r4, #0]
 800bb48:	6061      	str	r1, [r4, #4]
 800bb4a:	60a2      	str	r2, [r4, #8]
 800bb4c:	60e3      	str	r3, [r4, #12]
 800bb4e:	cd07      	ldmia	r5!, {r0, r1, r2}
 800bb50:	6120      	str	r0, [r4, #16]
 800bb52:	6161      	str	r1, [r4, #20]
 800bb54:	61a2      	str	r2, [r4, #24]
 800bb56:	882a      	ldrh	r2, [r5, #0]
 800bb58:	78ab      	ldrb	r3, [r5, #2]
 800bb5a:	83a2      	strh	r2, [r4, #28]
 800bb5c:	77a3      	strb	r3, [r4, #30]
 800bb5e:	4620      	mov	r0, r4
 800bb60:	f013 fbe3 	bl	801f32a <crs_strlen>
 800bb64:	b283      	uxth	r3, r0
 800bb66:	4622      	mov	r2, r4
 800bb68:	2110      	movs	r1, #16
 800bb6a:	2002      	movs	r0, #2
 800bb6c:	f013 fc20 	bl	801f3b0 <traceIF_itmPrint>
 800bb70:	4620      	mov	r0, r4
 800bb72:	f013 fbda 	bl	801f32a <crs_strlen>
 800bb76:	b283      	uxth	r3, r0
 800bb78:	4622      	mov	r2, r4
 800bb7a:	2110      	movs	r1, #16
 800bb7c:	2002      	movs	r0, #2
 800bb7e:	f013 fc39 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800bb82:	2001      	movs	r0, #1
 800bb84:	e7db      	b.n	800bb3e <AT_close_channel+0x1a>
    TRACE_ERR("IPC invalid handle")
 800bb86:	4d16      	ldr	r5, [pc, #88]	; (800bbe0 <AT_close_channel+0xbc>)
 800bb88:	4c13      	ldr	r4, [pc, #76]	; (800bbd8 <AT_close_channel+0xb4>)
 800bb8a:	f105 0e20 	add.w	lr, r5, #32
 800bb8e:	46ac      	mov	ip, r5
 800bb90:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bb94:	6020      	str	r0, [r4, #0]
 800bb96:	6061      	str	r1, [r4, #4]
 800bb98:	60a2      	str	r2, [r4, #8]
 800bb9a:	60e3      	str	r3, [r4, #12]
 800bb9c:	4665      	mov	r5, ip
 800bb9e:	3410      	adds	r4, #16
 800bba0:	45f4      	cmp	ip, lr
 800bba2:	d1f4      	bne.n	800bb8e <AT_close_channel+0x6a>
 800bba4:	f8bc 3000 	ldrh.w	r3, [ip]
 800bba8:	8023      	strh	r3, [r4, #0]
 800bbaa:	4c0b      	ldr	r4, [pc, #44]	; (800bbd8 <AT_close_channel+0xb4>)
 800bbac:	4620      	mov	r0, r4
 800bbae:	f013 fbbc 	bl	801f32a <crs_strlen>
 800bbb2:	b283      	uxth	r3, r0
 800bbb4:	4622      	mov	r2, r4
 800bbb6:	2110      	movs	r1, #16
 800bbb8:	2002      	movs	r0, #2
 800bbba:	f013 fbf9 	bl	801f3b0 <traceIF_itmPrint>
 800bbbe:	4620      	mov	r0, r4
 800bbc0:	f013 fbb3 	bl	801f32a <crs_strlen>
 800bbc4:	b283      	uxth	r3, r0
 800bbc6:	4622      	mov	r2, r4
 800bbc8:	2110      	movs	r1, #16
 800bbca:	2002      	movs	r0, #2
 800bbcc:	f013 fc12 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800bbd0:	2001      	movs	r0, #1
 800bbd2:	e7b4      	b.n	800bb3e <AT_close_channel+0x1a>
 800bbd4:	2000188c 	.word	0x2000188c
 800bbd8:	200048dc 	.word	0x200048dc
 800bbdc:	0802e22c 	.word	0x0802e22c
 800bbe0:	0802e208 	.word	0x0802e208

0800bbe4 <AT_sendcmd>:
{
 800bbe4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (athandle == AT_HANDLE_INVALID)
 800bbe8:	f1b0 3fff 	cmp.w	r0, #4294967295
 800bbec:	d05f      	beq.n	800bcae <AT_sendcmd+0xca>
 800bbee:	4604      	mov	r4, r0
 800bbf0:	460e      	mov	r6, r1
 800bbf2:	4617      	mov	r7, r2
 800bbf4:	461d      	mov	r5, r3
    if (at_context[athandle].processing_cmd == 1U)
 800bbf6:	4b96      	ldr	r3, [pc, #600]	; (800be50 <AT_sendcmd+0x26c>)
 800bbf8:	f240 629c 	movw	r2, #1692	; 0x69c
 800bbfc:	fb02 3300 	mla	r3, r2, r0, r3
 800bc00:	f893 800b 	ldrb.w	r8, [r3, #11]
 800bc04:	f1b8 0f01 	cmp.w	r8, #1
 800bc08:	d059      	beq.n	800bcbe <AT_sendcmd+0xda>
    (void) memset((void *)p_rsp_buf, 0, ATCMD_MAX_BUF_SIZE);
 800bc0a:	2280      	movs	r2, #128	; 0x80
 800bc0c:	2100      	movs	r1, #0
 800bc0e:	4628      	mov	r0, r5
 800bc10:	f01a fe8d 	bl	802692e <memset>
    at_context[athandle].processing_cmd = 1U;
 800bc14:	4b8e      	ldr	r3, [pc, #568]	; (800be50 <AT_sendcmd+0x26c>)
 800bc16:	f240 629c 	movw	r2, #1692	; 0x69c
 800bc1a:	fb02 3304 	mla	r3, r2, r4, r3
 800bc1e:	2201      	movs	r2, #1
 800bc20:	72da      	strb	r2, [r3, #11]
    at_context[athandle].p_rsp_buf = p_rsp_buf;
 800bc22:	f8c3 5694 	str.w	r5, [r3, #1684]	; 0x694
    if (at_context[athandle].in_data_mode == AT_TRUE)
 800bc26:	7a9b      	ldrb	r3, [r3, #10]
 800bc28:	2b00      	cmp	r3, #0
 800bc2a:	d066      	beq.n	800bcfa <AT_sendcmd+0x116>
      if (msg_in_id == (at_msg_t) SID_CS_DATA_SUSPEND)
 800bc2c:	2e7e      	cmp	r6, #126	; 0x7e
 800bc2e:	d166      	bne.n	800bcfe <AT_sendcmd+0x11a>
        TRACE_DBG("<<< restore IPC COMMAND channel >>>")
 800bc30:	f8df e230 	ldr.w	lr, [pc, #560]	; 800be64 <AT_sendcmd+0x280>
 800bc34:	f8df c21c 	ldr.w	ip, [pc, #540]	; 800be54 <AT_sendcmd+0x270>
 800bc38:	f10e 0920 	add.w	r9, lr, #32
 800bc3c:	46f0      	mov	r8, lr
 800bc3e:	e8b8 000f 	ldmia.w	r8!, {r0, r1, r2, r3}
 800bc42:	f8cc 0000 	str.w	r0, [ip]
 800bc46:	f8cc 1004 	str.w	r1, [ip, #4]
 800bc4a:	f8cc 2008 	str.w	r2, [ip, #8]
 800bc4e:	f8cc 300c 	str.w	r3, [ip, #12]
 800bc52:	46c6      	mov	lr, r8
 800bc54:	f10c 0c10 	add.w	ip, ip, #16
 800bc58:	45c8      	cmp	r8, r9
 800bc5a:	d1ef      	bne.n	800bc3c <AT_sendcmd+0x58>
 800bc5c:	e8be 0007 	ldmia.w	lr!, {r0, r1, r2}
 800bc60:	f8cc 0000 	str.w	r0, [ip]
 800bc64:	f8cc 1004 	str.w	r1, [ip, #4]
 800bc68:	f8cc 2008 	str.w	r2, [ip, #8]
 800bc6c:	f89e 3000 	ldrb.w	r3, [lr]
 800bc70:	f88c 300c 	strb.w	r3, [ip, #12]
 800bc74:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 800be54 <AT_sendcmd+0x270>
 800bc78:	4640      	mov	r0, r8
 800bc7a:	f013 fb56 	bl	801f32a <crs_strlen>
 800bc7e:	b283      	uxth	r3, r0
 800bc80:	4642      	mov	r2, r8
 800bc82:	2102      	movs	r1, #2
 800bc84:	4608      	mov	r0, r1
 800bc86:	f013 fb93 	bl	801f3b0 <traceIF_itmPrint>
 800bc8a:	4640      	mov	r0, r8
 800bc8c:	f013 fb4d 	bl	801f32a <crs_strlen>
 800bc90:	b283      	uxth	r3, r0
 800bc92:	4642      	mov	r2, r8
 800bc94:	2102      	movs	r1, #2
 800bc96:	4608      	mov	r0, r1
 800bc98:	f013 fbac 	bl	801f3f4 <traceIF_uartPrint>
        (void) IPC_select(at_context[athandle].ipc_handle);
 800bc9c:	4b6c      	ldr	r3, [pc, #432]	; (800be50 <AT_sendcmd+0x26c>)
 800bc9e:	f240 629c 	movw	r2, #1692	; 0x69c
 800bca2:	fb02 3304 	mla	r3, r2, r4, r3
 800bca6:	6858      	ldr	r0, [r3, #4]
 800bca8:	f012 fc65 	bl	801e576 <IPC_select>
 800bcac:	e027      	b.n	800bcfe <AT_sendcmd+0x11a>
    LOG_ERROR(21, ERROR_WARNING);
 800bcae:	2202      	movs	r2, #2
 800bcb0:	2115      	movs	r1, #21
 800bcb2:	4610      	mov	r0, r2
 800bcb4:	f012 fb56 	bl	801e364 <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800bcb8:	f04f 0801 	mov.w	r8, #1
 800bcbc:	e03b      	b.n	800bd36 <AT_sendcmd+0x152>
      TRACE_ERR("!!!!!!!!!!!!!!!!!! WARNING COMMAND IS UNDER PROCESS !!!!!!!!!!!!!!!!!!")
 800bcbe:	4d65      	ldr	r5, [pc, #404]	; (800be54 <AT_sendcmd+0x270>)
 800bcc0:	2256      	movs	r2, #86	; 0x56
 800bcc2:	4965      	ldr	r1, [pc, #404]	; (800be58 <AT_sendcmd+0x274>)
 800bcc4:	4628      	mov	r0, r5
 800bcc6:	f01a ff0f 	bl	8026ae8 <memcpy>
 800bcca:	4628      	mov	r0, r5
 800bccc:	f013 fb2d 	bl	801f32a <crs_strlen>
 800bcd0:	b283      	uxth	r3, r0
 800bcd2:	462a      	mov	r2, r5
 800bcd4:	2110      	movs	r1, #16
 800bcd6:	2002      	movs	r0, #2
 800bcd8:	f013 fb6a 	bl	801f3b0 <traceIF_itmPrint>
 800bcdc:	4628      	mov	r0, r5
 800bcde:	f013 fb24 	bl	801f32a <crs_strlen>
 800bce2:	b283      	uxth	r3, r0
 800bce4:	462a      	mov	r2, r5
 800bce6:	2110      	movs	r1, #16
 800bce8:	2002      	movs	r0, #2
 800bcea:	f013 fb83 	bl	801f3f4 <traceIF_uartPrint>
      LOG_ERROR(2, ERROR_WARNING);
 800bcee:	2202      	movs	r2, #2
 800bcf0:	4611      	mov	r1, r2
 800bcf2:	4610      	mov	r0, r2
 800bcf4:	f012 fb36 	bl	801e364 <ERROR_Handler>
      goto exit_func;
 800bcf8:	e016      	b.n	800bd28 <AT_sendcmd+0x144>
    else if (msg_in_id == (at_msg_t) SID_CS_DATA_SUSPEND)
 800bcfa:	2e7e      	cmp	r6, #126	; 0x7e
 800bcfc:	d01e      	beq.n	800bd3c <AT_sendcmd+0x158>
    ATParser_process_request(&at_context[athandle], msg_in_id, p_cmd_in_buf);
 800bcfe:	4b54      	ldr	r3, [pc, #336]	; (800be50 <AT_sendcmd+0x26c>)
 800bd00:	f240 629c 	movw	r2, #1692	; 0x69c
 800bd04:	fb02 3904 	mla	r9, r2, r4, r3
 800bd08:	463a      	mov	r2, r7
 800bd0a:	4631      	mov	r1, r6
 800bd0c:	4648      	mov	r0, r9
 800bd0e:	f008 fe0b 	bl	8014928 <ATParser_process_request>
    retval = process_AT_transaction(athandle, msg_in_id, p_rsp_buf);
 800bd12:	462a      	mov	r2, r5
 800bd14:	4631      	mov	r1, r6
 800bd16:	4620      	mov	r0, r4
 800bd18:	f7ff f918 	bl	800af4c <process_AT_transaction>
    if (retval != ATSTATUS_OK)
 800bd1c:	4680      	mov	r8, r0
 800bd1e:	bbb0      	cbnz	r0, 800bd8e <AT_sendcmd+0x1aa>
    (void) ATParser_get_rsp(&at_context[athandle], p_rsp_buf);
 800bd20:	4629      	mov	r1, r5
 800bd22:	4648      	mov	r0, r9
 800bd24:	f008 ff84 	bl	8014c30 <ATParser_get_rsp>
    at_context[athandle].processing_cmd = 0U;
 800bd28:	4b49      	ldr	r3, [pc, #292]	; (800be50 <AT_sendcmd+0x26c>)
 800bd2a:	f240 629c 	movw	r2, #1692	; 0x69c
 800bd2e:	fb02 3304 	mla	r3, r2, r4, r3
 800bd32:	2200      	movs	r2, #0
 800bd34:	72da      	strb	r2, [r3, #11]
}
 800bd36:	4640      	mov	r0, r8
 800bd38:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      LOG_ERROR(3, ERROR_WARNING);
 800bd3c:	2202      	movs	r2, #2
 800bd3e:	2103      	movs	r1, #3
 800bd40:	4610      	mov	r0, r2
 800bd42:	f012 fb0f 	bl	801e364 <ERROR_Handler>
      TRACE_ERR("DATA not active")
 800bd46:	4d43      	ldr	r5, [pc, #268]	; (800be54 <AT_sendcmd+0x270>)
 800bd48:	4e44      	ldr	r6, [pc, #272]	; (800be5c <AT_sendcmd+0x278>)
 800bd4a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800bd4c:	6028      	str	r0, [r5, #0]
 800bd4e:	6069      	str	r1, [r5, #4]
 800bd50:	60aa      	str	r2, [r5, #8]
 800bd52:	60eb      	str	r3, [r5, #12]
 800bd54:	ce07      	ldmia	r6!, {r0, r1, r2}
 800bd56:	6128      	str	r0, [r5, #16]
 800bd58:	6169      	str	r1, [r5, #20]
 800bd5a:	61aa      	str	r2, [r5, #24]
 800bd5c:	8832      	ldrh	r2, [r6, #0]
 800bd5e:	78b3      	ldrb	r3, [r6, #2]
 800bd60:	83aa      	strh	r2, [r5, #28]
 800bd62:	77ab      	strb	r3, [r5, #30]
 800bd64:	4628      	mov	r0, r5
 800bd66:	f013 fae0 	bl	801f32a <crs_strlen>
 800bd6a:	b283      	uxth	r3, r0
 800bd6c:	462a      	mov	r2, r5
 800bd6e:	2110      	movs	r1, #16
 800bd70:	2002      	movs	r0, #2
 800bd72:	f013 fb1d 	bl	801f3b0 <traceIF_itmPrint>
 800bd76:	4628      	mov	r0, r5
 800bd78:	f013 fad7 	bl	801f32a <crs_strlen>
 800bd7c:	b283      	uxth	r3, r0
 800bd7e:	462a      	mov	r2, r5
 800bd80:	2110      	movs	r1, #16
 800bd82:	2002      	movs	r0, #2
 800bd84:	f013 fb36 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800bd88:	f04f 0801 	mov.w	r8, #1
      goto exit_func;
 800bd8c:	e7cc      	b.n	800bd28 <AT_sendcmd+0x144>
      TRACE_DBG("AT_sendcmd error: process AT transaction")
 800bd8e:	f8df e0d8 	ldr.w	lr, [pc, #216]	; 800be68 <AT_sendcmd+0x284>
 800bd92:	4f30      	ldr	r7, [pc, #192]	; (800be54 <AT_sendcmd+0x270>)
 800bd94:	f10e 0a30 	add.w	sl, lr, #48	; 0x30
 800bd98:	46f4      	mov	ip, lr
 800bd9a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bd9e:	6038      	str	r0, [r7, #0]
 800bda0:	6079      	str	r1, [r7, #4]
 800bda2:	60ba      	str	r2, [r7, #8]
 800bda4:	60fb      	str	r3, [r7, #12]
 800bda6:	46e6      	mov	lr, ip
 800bda8:	3710      	adds	r7, #16
 800bdaa:	45d4      	cmp	ip, sl
 800bdac:	d1f4      	bne.n	800bd98 <AT_sendcmd+0x1b4>
 800bdae:	f8bc 3000 	ldrh.w	r3, [ip]
 800bdb2:	803b      	strh	r3, [r7, #0]
 800bdb4:	4f27      	ldr	r7, [pc, #156]	; (800be54 <AT_sendcmd+0x270>)
 800bdb6:	4638      	mov	r0, r7
 800bdb8:	f013 fab7 	bl	801f32a <crs_strlen>
 800bdbc:	b283      	uxth	r3, r0
 800bdbe:	463a      	mov	r2, r7
 800bdc0:	2102      	movs	r1, #2
 800bdc2:	4608      	mov	r0, r1
 800bdc4:	f013 faf4 	bl	801f3b0 <traceIF_itmPrint>
 800bdc8:	4638      	mov	r0, r7
 800bdca:	f013 faae 	bl	801f32a <crs_strlen>
 800bdce:	b283      	uxth	r3, r0
 800bdd0:	463a      	mov	r2, r7
 800bdd2:	2102      	movs	r1, #2
 800bdd4:	4608      	mov	r0, r1
 800bdd6:	f013 fb0d 	bl	801f3f4 <traceIF_uartPrint>
      (void) ATParser_get_error(&at_context[athandle], p_rsp_buf);
 800bdda:	4629      	mov	r1, r5
 800bddc:	4648      	mov	r0, r9
 800bdde:	f008 ff36 	bl	8014c4e <ATParser_get_error>
      ATParser_abort_request(&at_context[athandle]);
 800bde2:	4648      	mov	r0, r9
 800bde4:	f008 ff37 	bl	8014c56 <ATParser_abort_request>
      if (msg_in_id == (at_msg_t) SID_CS_DATA_SUSPEND)
 800bde8:	2e7e      	cmp	r6, #126	; 0x7e
 800bdea:	d19d      	bne.n	800bd28 <AT_sendcmd+0x144>
        TRACE_ERR("force to return to COMMAND mode")
 800bdec:	4e1c      	ldr	r6, [pc, #112]	; (800be60 <AT_sendcmd+0x27c>)
 800bdee:	463d      	mov	r5, r7
 800bdf0:	f106 0c20 	add.w	ip, r6, #32
 800bdf4:	4637      	mov	r7, r6
 800bdf6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800bdf8:	6028      	str	r0, [r5, #0]
 800bdfa:	6069      	str	r1, [r5, #4]
 800bdfc:	60aa      	str	r2, [r5, #8]
 800bdfe:	60eb      	str	r3, [r5, #12]
 800be00:	463e      	mov	r6, r7
 800be02:	3510      	adds	r5, #16
 800be04:	4567      	cmp	r7, ip
 800be06:	d1f5      	bne.n	800bdf4 <AT_sendcmd+0x210>
 800be08:	ce07      	ldmia	r6!, {r0, r1, r2}
 800be0a:	6028      	str	r0, [r5, #0]
 800be0c:	6069      	str	r1, [r5, #4]
 800be0e:	60aa      	str	r2, [r5, #8]
 800be10:	8832      	ldrh	r2, [r6, #0]
 800be12:	78b3      	ldrb	r3, [r6, #2]
 800be14:	81aa      	strh	r2, [r5, #12]
 800be16:	73ab      	strb	r3, [r5, #14]
 800be18:	4d0e      	ldr	r5, [pc, #56]	; (800be54 <AT_sendcmd+0x270>)
 800be1a:	4628      	mov	r0, r5
 800be1c:	f013 fa85 	bl	801f32a <crs_strlen>
 800be20:	b283      	uxth	r3, r0
 800be22:	462a      	mov	r2, r5
 800be24:	2110      	movs	r1, #16
 800be26:	2002      	movs	r0, #2
 800be28:	f013 fac2 	bl	801f3b0 <traceIF_itmPrint>
 800be2c:	4628      	mov	r0, r5
 800be2e:	f013 fa7c 	bl	801f32a <crs_strlen>
 800be32:	b283      	uxth	r3, r0
 800be34:	462a      	mov	r2, r5
 800be36:	2110      	movs	r1, #16
 800be38:	2002      	movs	r0, #2
 800be3a:	f013 fadb 	bl	801f3f4 <traceIF_uartPrint>
        at_context[athandle].in_data_mode = AT_FALSE ;
 800be3e:	4b04      	ldr	r3, [pc, #16]	; (800be50 <AT_sendcmd+0x26c>)
 800be40:	f240 629c 	movw	r2, #1692	; 0x69c
 800be44:	fb02 3304 	mla	r3, r2, r4, r3
 800be48:	2200      	movs	r2, #0
 800be4a:	729a      	strb	r2, [r3, #10]
      goto exit_func;
 800be4c:	e76c      	b.n	800bd28 <AT_sendcmd+0x144>
 800be4e:	bf00      	nop
 800be50:	2000188c 	.word	0x2000188c
 800be54:	200048dc 	.word	0x200048dc
 800be58:	0802e24c 	.word	0x0802e24c
 800be5c:	0802e2d4 	.word	0x0802e2d4
 800be60:	0802e328 	.word	0x0802e328
 800be64:	0802e2a4 	.word	0x0802e2a4
 800be68:	0802e2f4 	.word	0x0802e2f4

0800be6c <AT_internalEvent>:
  if (deviceType == DEVTYPE_MODEM_CELLULAR)
 800be6c:	b100      	cbz	r0, 800be70 <AT_internalEvent+0x4>
 800be6e:	4770      	bx	lr
{
 800be70:	b510      	push	{r4, lr}
    if (rtosalMessageQueuePut(q_msg_IPC_received_Id,
 800be72:	2200      	movs	r2, #0
 800be74:	2102      	movs	r1, #2
 800be76:	4b0f      	ldr	r3, [pc, #60]	; (800beb4 <AT_internalEvent+0x48>)
 800be78:	6818      	ldr	r0, [r3, #0]
 800be7a:	f013 f984 	bl	801f186 <rtosalMessageQueuePut>
 800be7e:	b900      	cbnz	r0, 800be82 <AT_internalEvent+0x16>
}
 800be80:	bd10      	pop	{r4, pc}
      TRACE_ERR("q_msg_IPC_received_Id error for SIG_INTERNAL_EVENT_MODEM")
 800be82:	4c0d      	ldr	r4, [pc, #52]	; (800beb8 <AT_internalEvent+0x4c>)
 800be84:	2248      	movs	r2, #72	; 0x48
 800be86:	490d      	ldr	r1, [pc, #52]	; (800bebc <AT_internalEvent+0x50>)
 800be88:	4620      	mov	r0, r4
 800be8a:	f01a fe2d 	bl	8026ae8 <memcpy>
 800be8e:	4620      	mov	r0, r4
 800be90:	f013 fa4b 	bl	801f32a <crs_strlen>
 800be94:	b283      	uxth	r3, r0
 800be96:	4622      	mov	r2, r4
 800be98:	2110      	movs	r1, #16
 800be9a:	2002      	movs	r0, #2
 800be9c:	f013 fa88 	bl	801f3b0 <traceIF_itmPrint>
 800bea0:	4620      	mov	r0, r4
 800bea2:	f013 fa42 	bl	801f32a <crs_strlen>
 800bea6:	b283      	uxth	r3, r0
 800bea8:	4622      	mov	r2, r4
 800beaa:	2110      	movs	r1, #16
 800beac:	2002      	movs	r0, #2
 800beae:	f013 faa1 	bl	801f3f4 <traceIF_uartPrint>
}
 800beb2:	e7e5      	b.n	800be80 <AT_internalEvent+0x14>
 800beb4:	2000353c 	.word	0x2000353c
 800beb8:	200048dc 	.word	0x200048dc
 800bebc:	0802e358 	.word	0x0802e358

0800bec0 <atcore_task_start>:
{
 800bec0:	b570      	push	{r4, r5, r6, lr}
 800bec2:	b082      	sub	sp, #8
  if (AT_Core_initialized != 1U)
 800bec4:	4c57      	ldr	r4, [pc, #348]	; (800c024 <atcore_task_start+0x164>)
 800bec6:	7824      	ldrb	r4, [r4, #0]
 800bec8:	2c01      	cmp	r4, #1
 800beca:	d02a      	beq.n	800bf22 <atcore_task_start+0x62>
    TRACE_ERR("error, ATCore is not initialized")
 800becc:	4d56      	ldr	r5, [pc, #344]	; (800c028 <atcore_task_start+0x168>)
 800bece:	4c57      	ldr	r4, [pc, #348]	; (800c02c <atcore_task_start+0x16c>)
 800bed0:	f105 0630 	add.w	r6, r5, #48	; 0x30
 800bed4:	46ac      	mov	ip, r5
 800bed6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800beda:	6020      	str	r0, [r4, #0]
 800bedc:	6061      	str	r1, [r4, #4]
 800bede:	60a2      	str	r2, [r4, #8]
 800bee0:	60e3      	str	r3, [r4, #12]
 800bee2:	4665      	mov	r5, ip
 800bee4:	3410      	adds	r4, #16
 800bee6:	45b4      	cmp	ip, r6
 800bee8:	d1f4      	bne.n	800bed4 <atcore_task_start+0x14>
 800beea:	4c50      	ldr	r4, [pc, #320]	; (800c02c <atcore_task_start+0x16c>)
 800beec:	4620      	mov	r0, r4
 800beee:	f013 fa1c 	bl	801f32a <crs_strlen>
 800bef2:	b283      	uxth	r3, r0
 800bef4:	4622      	mov	r2, r4
 800bef6:	2110      	movs	r1, #16
 800bef8:	2002      	movs	r0, #2
 800befa:	f013 fa59 	bl	801f3b0 <traceIF_itmPrint>
 800befe:	4620      	mov	r0, r4
 800bf00:	f013 fa13 	bl	801f32a <crs_strlen>
 800bf04:	b283      	uxth	r3, r0
 800bf06:	4622      	mov	r2, r4
 800bf08:	2110      	movs	r1, #16
 800bf0a:	2002      	movs	r0, #2
 800bf0c:	f013 fa72 	bl	801f3f4 <traceIF_uartPrint>
    LOG_ERROR(17, ERROR_WARNING);
 800bf10:	2202      	movs	r2, #2
 800bf12:	2111      	movs	r1, #17
 800bf14:	4610      	mov	r0, r2
 800bf16:	f012 fa25 	bl	801e364 <ERROR_Handler>
    retval = ATSTATUS_ERROR;
 800bf1a:	2401      	movs	r4, #1
}
 800bf1c:	4620      	mov	r0, r4
 800bf1e:	b002      	add	sp, #8
 800bf20:	bd70      	pop	{r4, r5, r6, pc}
 800bf22:	4606      	mov	r6, r0
 800bf24:	460d      	mov	r5, r1
    s_WaitAnswer_SemaphoreId = rtosalSemaphoreNew((const rtosal_char_t *) "ATCORE_SEM_WAIT_ANSWER",
 800bf26:	2101      	movs	r1, #1
 800bf28:	4841      	ldr	r0, [pc, #260]	; (800c030 <atcore_task_start+0x170>)
 800bf2a:	f013 f8fc 	bl	801f126 <rtosalSemaphoreNew>
 800bf2e:	4b41      	ldr	r3, [pc, #260]	; (800c034 <atcore_task_start+0x174>)
 800bf30:	6018      	str	r0, [r3, #0]
    if (s_WaitAnswer_SemaphoreId == NULL)
 800bf32:	b1b0      	cbz	r0, 800bf62 <atcore_task_start+0xa2>
      (void) rtosalSemaphoreAcquire(s_WaitAnswer_SemaphoreId, 15000U);
 800bf34:	f643 2198 	movw	r1, #15000	; 0x3a98
 800bf38:	f013 f8ff 	bl	801f13a <rtosalSemaphoreAcquire>
      q_msg_IPC_received_Id = rtosalMessageQueueNew((const rtosal_char_t *) "IPC_MSG_RCV",
 800bf3c:	2180      	movs	r1, #128	; 0x80
 800bf3e:	483e      	ldr	r0, [pc, #248]	; (800c038 <atcore_task_start+0x178>)
 800bf40:	f013 f915 	bl	801f16e <rtosalMessageQueueNew>
 800bf44:	4b3d      	ldr	r3, [pc, #244]	; (800c03c <atcore_task_start+0x17c>)
 800bf46:	6018      	str	r0, [r3, #0]
      atcoreTaskId = rtosalThreadNew((const rtosal_char_t *)"atcoreTask",
 800bf48:	2300      	movs	r3, #0
 800bf4a:	9300      	str	r3, [sp, #0]
 800bf4c:	462b      	mov	r3, r5
 800bf4e:	4632      	mov	r2, r6
 800bf50:	493b      	ldr	r1, [pc, #236]	; (800c040 <atcore_task_start+0x180>)
 800bf52:	483c      	ldr	r0, [pc, #240]	; (800c044 <atcore_task_start+0x184>)
 800bf54:	f013 f8d7 	bl	801f106 <rtosalThreadNew>
 800bf58:	4b3b      	ldr	r3, [pc, #236]	; (800c048 <atcore_task_start+0x188>)
 800bf5a:	6018      	str	r0, [r3, #0]
      if (atcoreTaskId == NULL)
 800bf5c:	b390      	cbz	r0, 800bfc4 <atcore_task_start+0x104>
        retval = ATSTATUS_OK;
 800bf5e:	2400      	movs	r4, #0
 800bf60:	e7dc      	b.n	800bf1c <atcore_task_start+0x5c>
      TRACE_ERR("s_WaitAnswer_SemaphoreId creation error")
 800bf62:	4e3a      	ldr	r6, [pc, #232]	; (800c04c <atcore_task_start+0x18c>)
 800bf64:	4d31      	ldr	r5, [pc, #196]	; (800c02c <atcore_task_start+0x16c>)
 800bf66:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 800bf6a:	46b4      	mov	ip, r6
 800bf6c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bf70:	6028      	str	r0, [r5, #0]
 800bf72:	6069      	str	r1, [r5, #4]
 800bf74:	60aa      	str	r2, [r5, #8]
 800bf76:	60eb      	str	r3, [r5, #12]
 800bf78:	4666      	mov	r6, ip
 800bf7a:	3510      	adds	r5, #16
 800bf7c:	45f4      	cmp	ip, lr
 800bf7e:	d1f4      	bne.n	800bf6a <atcore_task_start+0xaa>
 800bf80:	f8dc 0000 	ldr.w	r0, [ip]
 800bf84:	6028      	str	r0, [r5, #0]
 800bf86:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800bf8a:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800bf8e:	80aa      	strh	r2, [r5, #4]
 800bf90:	71ab      	strb	r3, [r5, #6]
 800bf92:	4d26      	ldr	r5, [pc, #152]	; (800c02c <atcore_task_start+0x16c>)
 800bf94:	4628      	mov	r0, r5
 800bf96:	f013 f9c8 	bl	801f32a <crs_strlen>
 800bf9a:	b283      	uxth	r3, r0
 800bf9c:	462a      	mov	r2, r5
 800bf9e:	2110      	movs	r1, #16
 800bfa0:	2002      	movs	r0, #2
 800bfa2:	f013 fa05 	bl	801f3b0 <traceIF_itmPrint>
 800bfa6:	4628      	mov	r0, r5
 800bfa8:	f013 f9bf 	bl	801f32a <crs_strlen>
 800bfac:	b283      	uxth	r3, r0
 800bfae:	462a      	mov	r2, r5
 800bfb0:	2110      	movs	r1, #16
 800bfb2:	2002      	movs	r0, #2
 800bfb4:	f013 fa1e 	bl	801f3f4 <traceIF_uartPrint>
      LOG_ERROR(18, ERROR_WARNING);
 800bfb8:	2202      	movs	r2, #2
 800bfba:	2112      	movs	r1, #18
 800bfbc:	4610      	mov	r0, r2
 800bfbe:	f012 f9d1 	bl	801e364 <ERROR_Handler>
      retval = ATSTATUS_ERROR;
 800bfc2:	e7ab      	b.n	800bf1c <atcore_task_start+0x5c>
        TRACE_ERR("atcoreTaskId creation error")
 800bfc4:	4e22      	ldr	r6, [pc, #136]	; (800c050 <atcore_task_start+0x190>)
 800bfc6:	4d19      	ldr	r5, [pc, #100]	; (800c02c <atcore_task_start+0x16c>)
 800bfc8:	f106 0e20 	add.w	lr, r6, #32
 800bfcc:	46b4      	mov	ip, r6
 800bfce:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800bfd2:	6028      	str	r0, [r5, #0]
 800bfd4:	6069      	str	r1, [r5, #4]
 800bfd6:	60aa      	str	r2, [r5, #8]
 800bfd8:	60eb      	str	r3, [r5, #12]
 800bfda:	4666      	mov	r6, ip
 800bfdc:	3510      	adds	r5, #16
 800bfde:	45f4      	cmp	ip, lr
 800bfe0:	d1f4      	bne.n	800bfcc <atcore_task_start+0x10c>
 800bfe2:	ce03      	ldmia	r6!, {r0, r1}
 800bfe4:	6028      	str	r0, [r5, #0]
 800bfe6:	6069      	str	r1, [r5, #4]
 800bfe8:	8832      	ldrh	r2, [r6, #0]
 800bfea:	78b3      	ldrb	r3, [r6, #2]
 800bfec:	812a      	strh	r2, [r5, #8]
 800bfee:	72ab      	strb	r3, [r5, #10]
 800bff0:	4d0e      	ldr	r5, [pc, #56]	; (800c02c <atcore_task_start+0x16c>)
 800bff2:	4628      	mov	r0, r5
 800bff4:	f013 f999 	bl	801f32a <crs_strlen>
 800bff8:	b283      	uxth	r3, r0
 800bffa:	462a      	mov	r2, r5
 800bffc:	2110      	movs	r1, #16
 800bffe:	2002      	movs	r0, #2
 800c000:	f013 f9d6 	bl	801f3b0 <traceIF_itmPrint>
 800c004:	4628      	mov	r0, r5
 800c006:	f013 f990 	bl	801f32a <crs_strlen>
 800c00a:	b283      	uxth	r3, r0
 800c00c:	462a      	mov	r2, r5
 800c00e:	2110      	movs	r1, #16
 800c010:	2002      	movs	r0, #2
 800c012:	f013 f9ef 	bl	801f3f4 <traceIF_uartPrint>
        LOG_ERROR(19, ERROR_WARNING);
 800c016:	2202      	movs	r2, #2
 800c018:	2113      	movs	r1, #19
 800c01a:	4610      	mov	r0, r2
 800c01c:	f012 f9a2 	bl	801e364 <ERROR_Handler>
        retval = ATSTATUS_ERROR;
 800c020:	e77c      	b.n	800bf1c <atcore_task_start+0x5c>
 800c022:	bf00      	nop
 800c024:	20001884 	.word	0x20001884
 800c028:	0802e3a0 	.word	0x0802e3a0
 800c02c:	200048dc 	.word	0x200048dc
 800c030:	0802e3d0 	.word	0x0802e3d0
 800c034:	20003544 	.word	0x20003544
 800c038:	0802e420 	.word	0x0802e420
 800c03c:	2000353c 	.word	0x2000353c
 800c040:	0800b3b9 	.word	0x0800b3b9
 800c044:	0802e42c 	.word	0x0802e42c
 800c048:	20001f28 	.word	0x20001f28
 800c04c:	0802e3e8 	.word	0x0802e3e8
 800c050:	0802e438 	.word	0x0802e438

0800c054 <DATAPACK_writePtr>:
  * @param  msgtype Type of message
  * @param  p_data Pointer to user data structure
  * @retval DataPack_Status_t
  */
DataPack_Status_t DATAPACK_writePtr(uint8_t *p_buf, uint16_t msgtype, void *p_data)
{
 800c054:	4603      	mov	r3, r0
  uint16_t size = (uint16_t) sizeof(datapack_structptr_t);
  datapack_structptr_t sptr;
  sptr.structptr = p_data;

  /* check pointers */
  if ((p_data == NULL) || (p_buf == NULL))
 800c056:	4694      	mov	ip, r2
 800c058:	b162      	cbz	r2, 800c074 <DATAPACK_writePtr+0x20>
 800c05a:	b158      	cbz	r0, 800c074 <DATAPACK_writePtr+0x20>
    retvalue = DATAPACK_ERROR;
  }
  else
  {
    /* write header: message type */
    p_buf[0] = (uint8_t)(msgtype >> 8);
 800c05c:	0a0a      	lsrs	r2, r1, #8
 800c05e:	7002      	strb	r2, [r0, #0]
    p_buf[1] = (uint8_t)(msgtype & 0x00FFU);
 800c060:	7041      	strb	r1, [r0, #1]

    /* write header: size */
    p_buf[2] = (uint8_t)(size >> 8);
 800c062:	2000      	movs	r0, #0
 800c064:	7098      	strb	r0, [r3, #2]
    p_buf[3] = (uint8_t)(size & 0x00FFU);
 800c066:	2204      	movs	r2, #4
 800c068:	70da      	strb	r2, [r3, #3]

    /* write header: content type (pointer of data) */
    p_buf[4] = DATASTRUCT_POINTER_TYPE;
 800c06a:	2201      	movs	r2, #1
 800c06c:	711a      	strb	r2, [r3, #4]

    /* write pointer on user data structure */
    (void) memcpy((void *)&p_buf[DATAPACK_HEADER_BYTE_SIZE + 1U], (void *)&sptr, sizeof(datapack_structptr_t));
 800c06e:	f8c3 c005 	str.w	ip, [r3, #5]

    retvalue = DATAPACK_OK;
  }
  return (retvalue);
}
 800c072:	4770      	bx	lr
{
 800c074:	b510      	push	{r4, lr}
    PRINT_ERR("DATAPACK_writePtr error (%p, %p)", p_data, p_buf)
 800c076:	4c0d      	ldr	r4, [pc, #52]	; (800c0ac <DATAPACK_writePtr+0x58>)
 800c078:	4662      	mov	r2, ip
 800c07a:	490d      	ldr	r1, [pc, #52]	; (800c0b0 <DATAPACK_writePtr+0x5c>)
 800c07c:	4620      	mov	r0, r4
 800c07e:	f01a fbe3 	bl	8026848 <sprintf>
 800c082:	4620      	mov	r0, r4
 800c084:	f013 f951 	bl	801f32a <crs_strlen>
 800c088:	b283      	uxth	r3, r0
 800c08a:	4622      	mov	r2, r4
 800c08c:	2110      	movs	r1, #16
 800c08e:	2002      	movs	r0, #2
 800c090:	f013 f98e 	bl	801f3b0 <traceIF_itmPrint>
 800c094:	4620      	mov	r0, r4
 800c096:	f013 f948 	bl	801f32a <crs_strlen>
 800c09a:	b283      	uxth	r3, r0
 800c09c:	4622      	mov	r2, r4
 800c09e:	2110      	movs	r1, #16
 800c0a0:	2002      	movs	r0, #2
 800c0a2:	f013 f9a7 	bl	801f3f4 <traceIF_uartPrint>
    retvalue = DATAPACK_ERROR;
 800c0a6:	2001      	movs	r0, #1
}
 800c0a8:	bd10      	pop	{r4, pc}
 800c0aa:	bf00      	nop
 800c0ac:	200048dc 	.word	0x200048dc
 800c0b0:	0802e464 	.word	0x0802e464

0800c0b4 <DATAPACK_writeStruct>:
  * @param  size Size of the structure
  * @param  p_data Pointer to user data structure
  * @retval DataPack_Status_t
  */
DataPack_Status_t DATAPACK_writeStruct(uint8_t *p_buf, uint16_t msgtype, uint16_t size, void *p_data)
{
 800c0b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c0b8:	b082      	sub	sp, #8
 800c0ba:	4606      	mov	r6, r0
 800c0bc:	460f      	mov	r7, r1
 800c0be:	4614      	mov	r4, r2
 800c0c0:	4698      	mov	r8, r3

  DataPack_Status_t retvalue;

#if (USE_TRACE_ATDATAPACK == 1U)
  static uint32_t datapack_biggest_size = 0U; /* for debug only, used to track maximum struct size */
  if (size > datapack_biggest_size)
 800c0c2:	4b2f      	ldr	r3, [pc, #188]	; (800c180 <DATAPACK_writeStruct+0xcc>)
 800c0c4:	681b      	ldr	r3, [r3, #0]
 800c0c6:	429a      	cmp	r2, r3
 800c0c8:	d901      	bls.n	800c0ce <DATAPACK_writeStruct+0x1a>
  {
    datapack_biggest_size = size;
 800c0ca:	4b2d      	ldr	r3, [pc, #180]	; (800c180 <DATAPACK_writeStruct+0xcc>)
 800c0cc:	601a      	str	r2, [r3, #0]
  }
  PRINT_DBG("<MAX SIZE INFO> msgtype=%d size=%d (biggest =%ld)", msgtype, size, datapack_biggest_size)
 800c0ce:	4b2c      	ldr	r3, [pc, #176]	; (800c180 <DATAPACK_writeStruct+0xcc>)
 800c0d0:	681b      	ldr	r3, [r3, #0]
 800c0d2:	4d2c      	ldr	r5, [pc, #176]	; (800c184 <DATAPACK_writeStruct+0xd0>)
 800c0d4:	9300      	str	r3, [sp, #0]
 800c0d6:	4623      	mov	r3, r4
 800c0d8:	463a      	mov	r2, r7
 800c0da:	492b      	ldr	r1, [pc, #172]	; (800c188 <DATAPACK_writeStruct+0xd4>)
 800c0dc:	4628      	mov	r0, r5
 800c0de:	f01a fbb3 	bl	8026848 <sprintf>
 800c0e2:	4628      	mov	r0, r5
 800c0e4:	f013 f921 	bl	801f32a <crs_strlen>
 800c0e8:	b283      	uxth	r3, r0
 800c0ea:	462a      	mov	r2, r5
 800c0ec:	2102      	movs	r1, #2
 800c0ee:	4608      	mov	r0, r1
 800c0f0:	f013 f95e 	bl	801f3b0 <traceIF_itmPrint>
 800c0f4:	4628      	mov	r0, r5
 800c0f6:	f013 f918 	bl	801f32a <crs_strlen>
 800c0fa:	b283      	uxth	r3, r0
 800c0fc:	462a      	mov	r2, r5
 800c0fe:	2102      	movs	r1, #2
 800c100:	4608      	mov	r0, r1
 800c102:	f013 f977 	bl	801f3f4 <traceIF_uartPrint>
#endif /* USE_TRACE_ATDATAPACK */

  /* check maximum size and pointer */
  if (((size - DATAPACK_HEADER_BYTE_SIZE) > DATAPACK_MAX_BUF_SIZE) || (p_buf == NULL))
 800c106:	2c84      	cmp	r4, #132	; 0x84
 800c108:	d80f      	bhi.n	800c12a <DATAPACK_writeStruct+0x76>
 800c10a:	b176      	cbz	r6, 800c12a <DATAPACK_writeStruct+0x76>
    retvalue = DATAPACK_ERROR;
  }
  else
  {
    /* write header: message type */
    p_buf[0] = (uint8_t)(msgtype >> 8);
 800c10c:	0a3b      	lsrs	r3, r7, #8
 800c10e:	7033      	strb	r3, [r6, #0]
    p_buf[1] = (uint8_t)(msgtype & 0x00FFU);
 800c110:	7077      	strb	r7, [r6, #1]

    /* write header: size */
    p_buf[2] = (uint8_t)(size >> 8);
 800c112:	0a23      	lsrs	r3, r4, #8
 800c114:	70b3      	strb	r3, [r6, #2]
    p_buf[3] = (uint8_t)(size & 0x00FFU);
 800c116:	70f4      	strb	r4, [r6, #3]

    /* write header: content type (pointer of data) */
    p_buf[4] = DATASTRUCT_CONTENT_TYPE;
 800c118:	2302      	movs	r3, #2
 800c11a:	7133      	strb	r3, [r6, #4]

    /* transmit structure content */
    (void) memcpy((void *)&p_buf[DATAPACK_HEADER_BYTE_SIZE + 1U],
 800c11c:	4622      	mov	r2, r4
 800c11e:	4641      	mov	r1, r8
 800c120:	1d70      	adds	r0, r6, #5
 800c122:	f01a fce1 	bl	8026ae8 <memcpy>
                  (void *)p_data,
                  (size_t) size);

    retvalue = DATAPACK_OK;
 800c126:	2000      	movs	r0, #0
 800c128:	e026      	b.n	800c178 <DATAPACK_writeStruct+0xc4>
    PRINT_ERR("DATAPACK_writeStruct error")
 800c12a:	4c18      	ldr	r4, [pc, #96]	; (800c18c <DATAPACK_writeStruct+0xd8>)
 800c12c:	4d15      	ldr	r5, [pc, #84]	; (800c184 <DATAPACK_writeStruct+0xd0>)
 800c12e:	f104 0620 	add.w	r6, r4, #32
 800c132:	46a4      	mov	ip, r4
 800c134:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800c138:	6028      	str	r0, [r5, #0]
 800c13a:	6069      	str	r1, [r5, #4]
 800c13c:	60aa      	str	r2, [r5, #8]
 800c13e:	60eb      	str	r3, [r5, #12]
 800c140:	4664      	mov	r4, ip
 800c142:	3510      	adds	r5, #16
 800c144:	45b4      	cmp	ip, r6
 800c146:	d1f4      	bne.n	800c132 <DATAPACK_writeStruct+0x7e>
 800c148:	cc07      	ldmia	r4!, {r0, r1, r2}
 800c14a:	6028      	str	r0, [r5, #0]
 800c14c:	6069      	str	r1, [r5, #4]
 800c14e:	60aa      	str	r2, [r5, #8]
 800c150:	4c0c      	ldr	r4, [pc, #48]	; (800c184 <DATAPACK_writeStruct+0xd0>)
 800c152:	4620      	mov	r0, r4
 800c154:	f013 f8e9 	bl	801f32a <crs_strlen>
 800c158:	b283      	uxth	r3, r0
 800c15a:	4622      	mov	r2, r4
 800c15c:	2110      	movs	r1, #16
 800c15e:	2002      	movs	r0, #2
 800c160:	f013 f926 	bl	801f3b0 <traceIF_itmPrint>
 800c164:	4620      	mov	r0, r4
 800c166:	f013 f8e0 	bl	801f32a <crs_strlen>
 800c16a:	b283      	uxth	r3, r0
 800c16c:	4622      	mov	r2, r4
 800c16e:	2110      	movs	r1, #16
 800c170:	2002      	movs	r0, #2
 800c172:	f013 f93f 	bl	801f3f4 <traceIF_uartPrint>
    retvalue = DATAPACK_ERROR;
 800c176:	2001      	movs	r0, #1
  }

  return (retvalue);
}
 800c178:	b002      	add	sp, #8
 800c17a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c17e:	bf00      	nop
 800c180:	200035c8 	.word	0x200035c8
 800c184:	200048dc 	.word	0x200048dc
 800c188:	0802e498 	.word	0x0802e498
 800c18c:	0802e4d8 	.word	0x0802e4d8

0800c190 <DATAPACK_readMsgType>:

uint16_t DATAPACK_readMsgType(uint8_t *p_buf)
{
  uint16_t msgtype;
  /* read header: message type */
  msgtype = ((uint16_t)p_buf[0] << 8) + (uint16_t)p_buf[1];
 800c190:	7803      	ldrb	r3, [r0, #0]
 800c192:	7840      	ldrb	r0, [r0, #1]
 800c194:	eb00 2003 	add.w	r0, r0, r3, lsl #8
  return ((uint16_t)msgtype);
}
 800c198:	b280      	uxth	r0, r0
 800c19a:	4770      	bx	lr

0800c19c <DATAPACK_readSize>:

uint16_t DATAPACK_readSize(uint8_t *p_buf)
{
  uint16_t size;
  /* read header: size */
  size = ((uint16_t)p_buf[2] << 8) + (uint16_t)p_buf[3];
 800c19c:	7883      	ldrb	r3, [r0, #2]
 800c19e:	78c0      	ldrb	r0, [r0, #3]
 800c1a0:	eb00 2003 	add.w	r0, r0, r3, lsl #8
  return (size);
}
 800c1a4:	b280      	uxth	r0, r0
 800c1a6:	4770      	bx	lr

0800c1a8 <check_structure_to_read>:

/* static functions ---------------------------------------------------------------------- */
static DataPack_Status_t check_structure_to_read(uint8_t *p_buf, uint16_t msgtype,
                                                 uint16_t expect_size, uint8_t expect_type)
{
 800c1a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c1aa:	4605      	mov	r5, r0
 800c1ac:	460c      	mov	r4, r1
 800c1ae:	4616      	mov	r6, r2
 800c1b0:	461f      	mov	r7, r3
  DataPack_Status_t retval;
  uint16_t rx_msgtype;

  /* check that indicated msg type and received msg type are matching */
  rx_msgtype = DATAPACK_readMsgType(p_buf);
 800c1b2:	f7ff ffed 	bl	800c190 <DATAPACK_readMsgType>
  if (rx_msgtype != msgtype)
 800c1b6:	42a0      	cmp	r0, r4
 800c1b8:	d109      	bne.n	800c1ce <check_structure_to_read+0x26>
  }
  else
  {
    /* check that expect_size and received size are matching */
    uint16_t rx_size;
    rx_size = DATAPACK_readSize(p_buf);
 800c1ba:	4628      	mov	r0, r5
 800c1bc:	f7ff ffee 	bl	800c19c <DATAPACK_readSize>
    if (rx_size != expect_size)
 800c1c0:	42b0      	cmp	r0, r6
 800c1c2:	d11f      	bne.n	800c204 <check_structure_to_read+0x5c>
    }
    else
    {
      /* check that expect_type corresponds to the received content type */
      uint8_t rx_contenttype;
      rx_contenttype = p_buf[4];
 800c1c4:	792b      	ldrb	r3, [r5, #4]
      if (rx_contenttype != expect_type)
 800c1c6:	42bb      	cmp	r3, r7
 800c1c8:	d137      	bne.n	800c23a <check_structure_to_read+0x92>
        PRINT_ERR("DATAPACK read content type not matching")
        retval = DATAPACK_ERROR;
      }
      else
      {
        retval = DATAPACK_OK;
 800c1ca:	2000      	movs	r0, #0
 800c1cc:	e019      	b.n	800c202 <check_structure_to_read+0x5a>
    PRINT_INFO("DATAPACK read msgtype not matching (%d vs %d)", rx_msgtype, msgtype)
 800c1ce:	4d2f      	ldr	r5, [pc, #188]	; (800c28c <check_structure_to_read+0xe4>)
 800c1d0:	4623      	mov	r3, r4
 800c1d2:	4602      	mov	r2, r0
 800c1d4:	492e      	ldr	r1, [pc, #184]	; (800c290 <check_structure_to_read+0xe8>)
 800c1d6:	4628      	mov	r0, r5
 800c1d8:	f01a fb36 	bl	8026848 <sprintf>
 800c1dc:	4628      	mov	r0, r5
 800c1de:	f013 f8a4 	bl	801f32a <crs_strlen>
 800c1e2:	b283      	uxth	r3, r0
 800c1e4:	462a      	mov	r2, r5
 800c1e6:	2101      	movs	r1, #1
 800c1e8:	2002      	movs	r0, #2
 800c1ea:	f013 f8e1 	bl	801f3b0 <traceIF_itmPrint>
 800c1ee:	4628      	mov	r0, r5
 800c1f0:	f013 f89b 	bl	801f32a <crs_strlen>
 800c1f4:	b283      	uxth	r3, r0
 800c1f6:	462a      	mov	r2, r5
 800c1f8:	2101      	movs	r1, #1
 800c1fa:	2002      	movs	r0, #2
 800c1fc:	f013 f8fa 	bl	801f3f4 <traceIF_uartPrint>
    retval = DATAPACK_ERROR;
 800c200:	2001      	movs	r0, #1
      }
    }
  }

  return (retval);
}
 800c202:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      PRINT_ERR("DATAPACK read size error (%d, %d)", rx_size, expect_size)
 800c204:	4c21      	ldr	r4, [pc, #132]	; (800c28c <check_structure_to_read+0xe4>)
 800c206:	4633      	mov	r3, r6
 800c208:	4602      	mov	r2, r0
 800c20a:	4922      	ldr	r1, [pc, #136]	; (800c294 <check_structure_to_read+0xec>)
 800c20c:	4620      	mov	r0, r4
 800c20e:	f01a fb1b 	bl	8026848 <sprintf>
 800c212:	4620      	mov	r0, r4
 800c214:	f013 f889 	bl	801f32a <crs_strlen>
 800c218:	b283      	uxth	r3, r0
 800c21a:	4622      	mov	r2, r4
 800c21c:	2110      	movs	r1, #16
 800c21e:	2002      	movs	r0, #2
 800c220:	f013 f8c6 	bl	801f3b0 <traceIF_itmPrint>
 800c224:	4620      	mov	r0, r4
 800c226:	f013 f880 	bl	801f32a <crs_strlen>
 800c22a:	b283      	uxth	r3, r0
 800c22c:	4622      	mov	r2, r4
 800c22e:	2110      	movs	r1, #16
 800c230:	2002      	movs	r0, #2
 800c232:	f013 f8df 	bl	801f3f4 <traceIF_uartPrint>
      retval = DATAPACK_ERROR;
 800c236:	2001      	movs	r0, #1
 800c238:	e7e3      	b.n	800c202 <check_structure_to_read+0x5a>
        PRINT_ERR("DATAPACK read content type not matching")
 800c23a:	4d17      	ldr	r5, [pc, #92]	; (800c298 <check_structure_to_read+0xf0>)
 800c23c:	4c13      	ldr	r4, [pc, #76]	; (800c28c <check_structure_to_read+0xe4>)
 800c23e:	f105 0730 	add.w	r7, r5, #48	; 0x30
 800c242:	462e      	mov	r6, r5
 800c244:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800c246:	6020      	str	r0, [r4, #0]
 800c248:	6061      	str	r1, [r4, #4]
 800c24a:	60a2      	str	r2, [r4, #8]
 800c24c:	60e3      	str	r3, [r4, #12]
 800c24e:	4635      	mov	r5, r6
 800c250:	3410      	adds	r4, #16
 800c252:	42be      	cmp	r6, r7
 800c254:	d1f5      	bne.n	800c242 <check_structure_to_read+0x9a>
 800c256:	cd03      	ldmia	r5!, {r0, r1}
 800c258:	6020      	str	r0, [r4, #0]
 800c25a:	6061      	str	r1, [r4, #4]
 800c25c:	782b      	ldrb	r3, [r5, #0]
 800c25e:	7223      	strb	r3, [r4, #8]
 800c260:	4c0a      	ldr	r4, [pc, #40]	; (800c28c <check_structure_to_read+0xe4>)
 800c262:	4620      	mov	r0, r4
 800c264:	f013 f861 	bl	801f32a <crs_strlen>
 800c268:	b283      	uxth	r3, r0
 800c26a:	4622      	mov	r2, r4
 800c26c:	2110      	movs	r1, #16
 800c26e:	2002      	movs	r0, #2
 800c270:	f013 f89e 	bl	801f3b0 <traceIF_itmPrint>
 800c274:	4620      	mov	r0, r4
 800c276:	f013 f858 	bl	801f32a <crs_strlen>
 800c27a:	b283      	uxth	r3, r0
 800c27c:	4622      	mov	r2, r4
 800c27e:	2110      	movs	r1, #16
 800c280:	2002      	movs	r0, #2
 800c282:	f013 f8b7 	bl	801f3f4 <traceIF_uartPrint>
        retval = DATAPACK_ERROR;
 800c286:	2001      	movs	r0, #1
 800c288:	e7bb      	b.n	800c202 <check_structure_to_read+0x5a>
 800c28a:	bf00      	nop
 800c28c:	200048dc 	.word	0x200048dc
 800c290:	0802e504 	.word	0x0802e504
 800c294:	0802e540 	.word	0x0802e540
 800c298:	0802e574 	.word	0x0802e574

0800c29c <DATAPACK_readPtr>:
{
 800c29c:	b538      	push	{r3, r4, r5, lr}
  if (p_buf == NULL)
 800c29e:	4605      	mov	r5, r0
 800c2a0:	b148      	cbz	r0, 800c2b6 <DATAPACK_readPtr+0x1a>
 800c2a2:	4614      	mov	r4, r2
    retval = check_structure_to_read(p_buf, msgtype, size, DATASTRUCT_POINTER_TYPE);
 800c2a4:	2301      	movs	r3, #1
 800c2a6:	2204      	movs	r2, #4
 800c2a8:	f7ff ff7e 	bl	800c1a8 <check_structure_to_read>
    if (retval == DATAPACK_OK)
 800c2ac:	b910      	cbnz	r0, 800c2b4 <DATAPACK_readPtr+0x18>
      (void) memcpy((void *)&sptr,
 800c2ae:	f8d5 3005 	ldr.w	r3, [r5, #5]
      *p_data = sptr.structptr;
 800c2b2:	6023      	str	r3, [r4, #0]
}
 800c2b4:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_ERR("DATAPACK_readPtr pointer error (%p)", p_buf)
 800c2b6:	4c0d      	ldr	r4, [pc, #52]	; (800c2ec <DATAPACK_readPtr+0x50>)
 800c2b8:	4602      	mov	r2, r0
 800c2ba:	490d      	ldr	r1, [pc, #52]	; (800c2f0 <DATAPACK_readPtr+0x54>)
 800c2bc:	4620      	mov	r0, r4
 800c2be:	f01a fac3 	bl	8026848 <sprintf>
 800c2c2:	4620      	mov	r0, r4
 800c2c4:	f013 f831 	bl	801f32a <crs_strlen>
 800c2c8:	b283      	uxth	r3, r0
 800c2ca:	4622      	mov	r2, r4
 800c2cc:	2110      	movs	r1, #16
 800c2ce:	2002      	movs	r0, #2
 800c2d0:	f013 f86e 	bl	801f3b0 <traceIF_itmPrint>
 800c2d4:	4620      	mov	r0, r4
 800c2d6:	f013 f828 	bl	801f32a <crs_strlen>
 800c2da:	b283      	uxth	r3, r0
 800c2dc:	4622      	mov	r2, r4
 800c2de:	2110      	movs	r1, #16
 800c2e0:	2002      	movs	r0, #2
 800c2e2:	f013 f887 	bl	801f3f4 <traceIF_uartPrint>
    retval = DATAPACK_ERROR;
 800c2e6:	2001      	movs	r0, #1
 800c2e8:	e7e4      	b.n	800c2b4 <DATAPACK_readPtr+0x18>
 800c2ea:	bf00      	nop
 800c2ec:	200048dc 	.word	0x200048dc
 800c2f0:	0802e5b0 	.word	0x0802e5b0

0800c2f4 <DATAPACK_readStruct>:
{
 800c2f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c2f6:	4604      	mov	r4, r0
  if ((p_data == NULL) || (p_buf == NULL))
 800c2f8:	461f      	mov	r7, r3
 800c2fa:	b163      	cbz	r3, 800c316 <DATAPACK_readStruct+0x22>
 800c2fc:	4615      	mov	r5, r2
 800c2fe:	b150      	cbz	r0, 800c316 <DATAPACK_readStruct+0x22>
    retval = check_structure_to_read(p_buf, msgtype, size, DATASTRUCT_CONTENT_TYPE);
 800c300:	2302      	movs	r3, #2
 800c302:	f7ff ff51 	bl	800c1a8 <check_structure_to_read>
    if (retval == DATAPACK_OK)
 800c306:	4606      	mov	r6, r0
 800c308:	b9f8      	cbnz	r0, 800c34a <DATAPACK_readStruct+0x56>
      (void) memcpy((void *)p_data,
 800c30a:	462a      	mov	r2, r5
 800c30c:	1d61      	adds	r1, r4, #5
 800c30e:	4638      	mov	r0, r7
 800c310:	f01a fbea 	bl	8026ae8 <memcpy>
 800c314:	e019      	b.n	800c34a <DATAPACK_readStruct+0x56>
    PRINT_ERR("DATAPACK_readStruct pointer error( %p, %p)", p_data, p_buf)
 800c316:	4d0e      	ldr	r5, [pc, #56]	; (800c350 <DATAPACK_readStruct+0x5c>)
 800c318:	4623      	mov	r3, r4
 800c31a:	463a      	mov	r2, r7
 800c31c:	490d      	ldr	r1, [pc, #52]	; (800c354 <DATAPACK_readStruct+0x60>)
 800c31e:	4628      	mov	r0, r5
 800c320:	f01a fa92 	bl	8026848 <sprintf>
 800c324:	4628      	mov	r0, r5
 800c326:	f013 f800 	bl	801f32a <crs_strlen>
 800c32a:	b283      	uxth	r3, r0
 800c32c:	462a      	mov	r2, r5
 800c32e:	2110      	movs	r1, #16
 800c330:	2002      	movs	r0, #2
 800c332:	f013 f83d 	bl	801f3b0 <traceIF_itmPrint>
 800c336:	4628      	mov	r0, r5
 800c338:	f012 fff7 	bl	801f32a <crs_strlen>
 800c33c:	b283      	uxth	r3, r0
 800c33e:	462a      	mov	r2, r5
 800c340:	2110      	movs	r1, #16
 800c342:	2002      	movs	r0, #2
 800c344:	f013 f856 	bl	801f3f4 <traceIF_uartPrint>
    retval = DATAPACK_ERROR;
 800c348:	2601      	movs	r6, #1
}
 800c34a:	4630      	mov	r0, r6
 800c34c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c34e:	bf00      	nop
 800c350:	200048dc 	.word	0x200048dc
 800c354:	0802e5e8 	.word	0x0802e5e8

0800c358 <atcc_initParsers>:
  * @brief  Initialize modem parsers.
  * @param  deviceType Device ID on which the event has been received.
  * @retval at_status_t
  */
at_status_t atcc_initParsers(sysctrl_device_type_t device_type)
{
 800c358:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c35a:	4604      	mov	r4, r0
  at_status_t retval;

  /* check if device is already initialized */
  if (at_custom_func[device_type].initialized == 0U)
 800c35c:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 800c360:	011b      	lsls	r3, r3, #4
 800c362:	4a15      	ldr	r2, [pc, #84]	; (800c3b8 <atcc_initParsers+0x60>)
 800c364:	5cd5      	ldrb	r5, [r2, r3]
 800c366:	b96d      	cbnz	r5, 800c384 <atcc_initParsers+0x2c>
  {
    /* Init  AT functions pointers */
    atcma_init_at_func_ptrs(&at_custom_func[device_type]);
 800c368:	4617      	mov	r7, r2
 800c36a:	0046      	lsls	r6, r0, #1
 800c36c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 800c370:	eb02 1000 	add.w	r0, r2, r0, lsl #4
 800c374:	f7f5 ff3a 	bl	80021ec <atcma_init_at_func_ptrs>
    /* device is initialized now */
    at_custom_func[device_type].initialized = 1U;
 800c378:	4426      	add	r6, r4
 800c37a:	0136      	lsls	r6, r6, #4
 800c37c:	2301      	movs	r3, #1
 800c37e:	55bb      	strb	r3, [r7, r6]
    PRINT_ERR("Device type %d AT functions already initialized", device_type);
    retval = ATSTATUS_ERROR;
  }

  return (retval);
}
 800c380:	4628      	mov	r0, r5
 800c382:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_ERR("Device type %d AT functions already initialized", device_type);
 800c384:	4d0d      	ldr	r5, [pc, #52]	; (800c3bc <atcc_initParsers+0x64>)
 800c386:	4602      	mov	r2, r0
 800c388:	490d      	ldr	r1, [pc, #52]	; (800c3c0 <atcc_initParsers+0x68>)
 800c38a:	4628      	mov	r0, r5
 800c38c:	f01a fa5c 	bl	8026848 <sprintf>
 800c390:	4628      	mov	r0, r5
 800c392:	f012 ffca 	bl	801f32a <crs_strlen>
 800c396:	b283      	uxth	r3, r0
 800c398:	462a      	mov	r2, r5
 800c39a:	2110      	movs	r1, #16
 800c39c:	2002      	movs	r0, #2
 800c39e:	f013 f807 	bl	801f3b0 <traceIF_itmPrint>
 800c3a2:	4628      	mov	r0, r5
 800c3a4:	f012 ffc1 	bl	801f32a <crs_strlen>
 800c3a8:	b283      	uxth	r3, r0
 800c3aa:	462a      	mov	r2, r5
 800c3ac:	2110      	movs	r1, #16
 800c3ae:	2002      	movs	r0, #2
 800c3b0:	f013 f820 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800c3b4:	2501      	movs	r5, #1
 800c3b6:	e7e3      	b.n	800c380 <atcc_initParsers+0x28>
 800c3b8:	200035cc 	.word	0x200035cc
 800c3bc:	200048dc 	.word	0x200048dc
 800c3c0:	0802e624 	.word	0x0802e624

0800c3c4 <atcc_init>:
  * @brief  Call modem initialization function.
  * @param  p_at_ctxt Pointer to the modem context.
  * @retval none
  */
void atcc_init(at_context_t *p_at_ctxt)
{
 800c3c4:	b508      	push	{r3, lr}
  (* at_custom_func[p_at_ctxt->device_type].f_init)(&p_at_ctxt->parser);
 800c3c6:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c3ca:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c3ce:	4a03      	ldr	r2, [pc, #12]	; (800c3dc <atcc_init+0x18>)
 800c3d0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c3d4:	685b      	ldr	r3, [r3, #4]
 800c3d6:	4798      	blx	r3
}
 800c3d8:	bd08      	pop	{r3, pc}
 800c3da:	bf00      	nop
 800c3dc:	200035cc 	.word	0x200035cc

0800c3e0 <atcc_checkEndOfMsgCallback>:
  * @retval none
  */
ATC_checkEndOfMsgCallbackTypeDef atcc_checkEndOfMsgCallback(const at_context_t *p_at_ctxt)
{
  /* called under interruption, do not put trace here */
  return (at_custom_func[p_at_ctxt->device_type].f_checkEndOfMsgCallback);
 800c3e0:	7803      	ldrb	r3, [r0, #0]
 800c3e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c3e6:	4a02      	ldr	r2, [pc, #8]	; (800c3f0 <atcc_checkEndOfMsgCallback+0x10>)
 800c3e8:	eb02 1303 	add.w	r3, r2, r3, lsl #4
}
 800c3ec:	6898      	ldr	r0, [r3, #8]
 800c3ee:	4770      	bx	lr
 800c3f0:	200035cc 	.word	0x200035cc

0800c3f4 <atcc_getCmd>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_ATcmdTimeout Timeout value to apply for this command.
  * @retval at_status_t
  */
at_status_t atcc_getCmd(at_context_t *p_at_ctxt, uint32_t *p_ATcmdTimeout)
{
 800c3f4:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_getCmd)(p_at_ctxt, p_ATcmdTimeout);
 800c3f6:	7803      	ldrb	r3, [r0, #0]
 800c3f8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c3fc:	4a0f      	ldr	r2, [pc, #60]	; (800c43c <atcc_getCmd+0x48>)
 800c3fe:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c402:	68db      	ldr	r3, [r3, #12]
 800c404:	4798      	blx	r3
 800c406:	4605      	mov	r5, r0

  PRINT_DBG("atcc_getCmd returned status = %d", retval)
 800c408:	4c0d      	ldr	r4, [pc, #52]	; (800c440 <atcc_getCmd+0x4c>)
 800c40a:	4602      	mov	r2, r0
 800c40c:	490d      	ldr	r1, [pc, #52]	; (800c444 <atcc_getCmd+0x50>)
 800c40e:	4620      	mov	r0, r4
 800c410:	f01a fa1a 	bl	8026848 <sprintf>
 800c414:	4620      	mov	r0, r4
 800c416:	f012 ff88 	bl	801f32a <crs_strlen>
 800c41a:	b283      	uxth	r3, r0
 800c41c:	4622      	mov	r2, r4
 800c41e:	2102      	movs	r1, #2
 800c420:	4608      	mov	r0, r1
 800c422:	f012 ffc5 	bl	801f3b0 <traceIF_itmPrint>
 800c426:	4620      	mov	r0, r4
 800c428:	f012 ff7f 	bl	801f32a <crs_strlen>
 800c42c:	b283      	uxth	r3, r0
 800c42e:	4622      	mov	r2, r4
 800c430:	2102      	movs	r1, #2
 800c432:	4608      	mov	r0, r1
 800c434:	f012 ffde 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c438:	4628      	mov	r0, r5
 800c43a:	bd38      	pop	{r3, r4, r5, pc}
 800c43c:	200035cc 	.word	0x200035cc
 800c440:	200048dc 	.word	0x200048dc
 800c444:	0802e668 	.word	0x0802e668

0800c448 <atcc_extractElement>:
  * @retval at_endmsg_t Indicates if this is the last message.
  */
at_endmsg_t atcc_extractElement(at_context_t *p_at_ctxt,
                                const IPC_RxMessage_t *p_msg_in,
                                at_element_info_t *element_infos)
{
 800c448:	b570      	push	{r4, r5, r6, lr}
 800c44a:	b082      	sub	sp, #8
 800c44c:	4615      	mov	r5, r2
  at_endmsg_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_extractElement)(&p_at_ctxt->parser, p_msg_in, element_infos);
 800c44e:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c452:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c456:	4c1f      	ldr	r4, [pc, #124]	; (800c4d4 <atcc_extractElement+0x8c>)
 800c458:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800c45c:	691b      	ldr	r3, [r3, #16]
 800c45e:	4798      	blx	r3
 800c460:	4606      	mov	r6, r0

  PRINT_DBG("start idx=%d  end idx=%d  size=%d rank=%d",
 800c462:	89eb      	ldrh	r3, [r5, #14]
 800c464:	892a      	ldrh	r2, [r5, #8]
 800c466:	4c1c      	ldr	r4, [pc, #112]	; (800c4d8 <atcc_extractElement+0x90>)
 800c468:	9201      	str	r2, [sp, #4]
 800c46a:	9300      	str	r3, [sp, #0]
 800c46c:	89ab      	ldrh	r3, [r5, #12]
 800c46e:	896a      	ldrh	r2, [r5, #10]
 800c470:	491a      	ldr	r1, [pc, #104]	; (800c4dc <atcc_extractElement+0x94>)
 800c472:	4620      	mov	r0, r4
 800c474:	f01a f9e8 	bl	8026848 <sprintf>
 800c478:	4620      	mov	r0, r4
 800c47a:	f012 ff56 	bl	801f32a <crs_strlen>
 800c47e:	b283      	uxth	r3, r0
 800c480:	4622      	mov	r2, r4
 800c482:	2102      	movs	r1, #2
 800c484:	4608      	mov	r0, r1
 800c486:	f012 ff93 	bl	801f3b0 <traceIF_itmPrint>
 800c48a:	4620      	mov	r0, r4
 800c48c:	f012 ff4d 	bl	801f32a <crs_strlen>
 800c490:	b283      	uxth	r3, r0
 800c492:	4622      	mov	r2, r4
 800c494:	2102      	movs	r1, #2
 800c496:	4608      	mov	r0, r1
 800c498:	f012 ffac 	bl	801f3f4 <traceIF_uartPrint>
            element_infos->str_start_idx, element_infos->str_end_idx,
            element_infos->str_size, element_infos->param_rank)
  PRINT_DBG("atcc_extractElement returned endmsg = %d", (retval == ATENDMSG_YES) ? 1 : 0)
 800c49c:	fab6 f286 	clz	r2, r6
 800c4a0:	0952      	lsrs	r2, r2, #5
 800c4a2:	490f      	ldr	r1, [pc, #60]	; (800c4e0 <atcc_extractElement+0x98>)
 800c4a4:	4620      	mov	r0, r4
 800c4a6:	f01a f9cf 	bl	8026848 <sprintf>
 800c4aa:	4620      	mov	r0, r4
 800c4ac:	f012 ff3d 	bl	801f32a <crs_strlen>
 800c4b0:	b283      	uxth	r3, r0
 800c4b2:	4622      	mov	r2, r4
 800c4b4:	2102      	movs	r1, #2
 800c4b6:	4608      	mov	r0, r1
 800c4b8:	f012 ff7a 	bl	801f3b0 <traceIF_itmPrint>
 800c4bc:	4620      	mov	r0, r4
 800c4be:	f012 ff34 	bl	801f32a <crs_strlen>
 800c4c2:	b283      	uxth	r3, r0
 800c4c4:	4622      	mov	r2, r4
 800c4c6:	2102      	movs	r1, #2
 800c4c8:	4608      	mov	r0, r1
 800c4ca:	f012 ff93 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c4ce:	4630      	mov	r0, r6
 800c4d0:	b002      	add	sp, #8
 800c4d2:	bd70      	pop	{r4, r5, r6, pc}
 800c4d4:	200035cc 	.word	0x200035cc
 800c4d8:	200048dc 	.word	0x200048dc
 800c4dc:	0802e694 	.word	0x0802e694
 800c4e0:	0802e6cc 	.word	0x0802e6cc

0800c4e4 <atcc_analyzeCmd>:
  * @retval at_action_rsp_t Indicates next action.
  */
at_action_rsp_t atcc_analyzeCmd(at_context_t *p_at_ctxt,
                                const IPC_RxMessage_t *p_msg_in,
                                at_element_info_t *element_infos)
{
 800c4e4:	b538      	push	{r3, r4, r5, lr}
  at_action_rsp_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_analyzeCmd)(p_at_ctxt, p_msg_in, element_infos);
 800c4e6:	7803      	ldrb	r3, [r0, #0]
 800c4e8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c4ec:	4c0f      	ldr	r4, [pc, #60]	; (800c52c <atcc_analyzeCmd+0x48>)
 800c4ee:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800c4f2:	695b      	ldr	r3, [r3, #20]
 800c4f4:	4798      	blx	r3
 800c4f6:	4605      	mov	r5, r0

  PRINT_DBG("atcc_analyzeCmd returned action = 0x%x", retval)
 800c4f8:	4c0d      	ldr	r4, [pc, #52]	; (800c530 <atcc_analyzeCmd+0x4c>)
 800c4fa:	4602      	mov	r2, r0
 800c4fc:	490d      	ldr	r1, [pc, #52]	; (800c534 <atcc_analyzeCmd+0x50>)
 800c4fe:	4620      	mov	r0, r4
 800c500:	f01a f9a2 	bl	8026848 <sprintf>
 800c504:	4620      	mov	r0, r4
 800c506:	f012 ff10 	bl	801f32a <crs_strlen>
 800c50a:	b283      	uxth	r3, r0
 800c50c:	4622      	mov	r2, r4
 800c50e:	2102      	movs	r1, #2
 800c510:	4608      	mov	r0, r1
 800c512:	f012 ff4d 	bl	801f3b0 <traceIF_itmPrint>
 800c516:	4620      	mov	r0, r4
 800c518:	f012 ff07 	bl	801f32a <crs_strlen>
 800c51c:	b283      	uxth	r3, r0
 800c51e:	4622      	mov	r2, r4
 800c520:	2102      	movs	r1, #2
 800c522:	4608      	mov	r0, r1
 800c524:	f012 ff66 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c528:	4628      	mov	r0, r5
 800c52a:	bd38      	pop	{r3, r4, r5, pc}
 800c52c:	200035cc 	.word	0x200035cc
 800c530:	200048dc 	.word	0x200048dc
 800c534:	0802e700 	.word	0x0802e700

0800c538 <atcc_analyzeParam>:
  * @retval at_action_rsp_t Indicates next action.
  */
at_action_rsp_t atcc_analyzeParam(at_context_t *p_at_ctxt,
                                  const IPC_RxMessage_t *p_msg_in,
                                  at_element_info_t *element_infos)
{
 800c538:	b538      	push	{r3, r4, r5, lr}
  at_action_rsp_t retval_final;

  retval_final = (*at_custom_func[p_at_ctxt->device_type].f_analyzeParam)(p_at_ctxt, p_msg_in, element_infos);
 800c53a:	7803      	ldrb	r3, [r0, #0]
 800c53c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c540:	4c0f      	ldr	r4, [pc, #60]	; (800c580 <atcc_analyzeParam+0x48>)
 800c542:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 800c546:	699b      	ldr	r3, [r3, #24]
 800c548:	4798      	blx	r3
 800c54a:	4605      	mov	r5, r0

  PRINT_DBG("atcc_analyzeParam returned action = 0x%x", retval_final)
 800c54c:	4c0d      	ldr	r4, [pc, #52]	; (800c584 <atcc_analyzeParam+0x4c>)
 800c54e:	4602      	mov	r2, r0
 800c550:	490d      	ldr	r1, [pc, #52]	; (800c588 <atcc_analyzeParam+0x50>)
 800c552:	4620      	mov	r0, r4
 800c554:	f01a f978 	bl	8026848 <sprintf>
 800c558:	4620      	mov	r0, r4
 800c55a:	f012 fee6 	bl	801f32a <crs_strlen>
 800c55e:	b283      	uxth	r3, r0
 800c560:	4622      	mov	r2, r4
 800c562:	2102      	movs	r1, #2
 800c564:	4608      	mov	r0, r1
 800c566:	f012 ff23 	bl	801f3b0 <traceIF_itmPrint>
 800c56a:	4620      	mov	r0, r4
 800c56c:	f012 fedd 	bl	801f32a <crs_strlen>
 800c570:	b283      	uxth	r3, r0
 800c572:	4622      	mov	r2, r4
 800c574:	2102      	movs	r1, #2
 800c576:	4608      	mov	r0, r1
 800c578:	f012 ff3c 	bl	801f3f4 <traceIF_uartPrint>
  return (retval_final);
}
 800c57c:	4628      	mov	r0, r5
 800c57e:	bd38      	pop	{r3, r4, r5, pc}
 800c580:	200035cc 	.word	0x200035cc
 800c584:	200048dc 	.word	0x200048dc
 800c588:	0802e734 	.word	0x0802e734

0800c58c <atcc_terminateCmd>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  element_infos Pointer to the structure with extracted information.
  * @retval at_action_rsp_t Indicates next action.
  */
at_action_rsp_t atcc_terminateCmd(at_context_t *p_at_ctxt, at_element_info_t *element_infos)
{
 800c58c:	b538      	push	{r3, r4, r5, lr}
  at_action_rsp_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_terminateCmd)(&p_at_ctxt->parser, element_infos);
 800c58e:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c592:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c596:	4a10      	ldr	r2, [pc, #64]	; (800c5d8 <atcc_terminateCmd+0x4c>)
 800c598:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c59c:	69db      	ldr	r3, [r3, #28]
 800c59e:	4798      	blx	r3
 800c5a0:	4605      	mov	r5, r0

  PRINT_DBG("atcc_terminateCmd returned action = 0x%x", retval)
 800c5a2:	4c0e      	ldr	r4, [pc, #56]	; (800c5dc <atcc_terminateCmd+0x50>)
 800c5a4:	4602      	mov	r2, r0
 800c5a6:	490e      	ldr	r1, [pc, #56]	; (800c5e0 <atcc_terminateCmd+0x54>)
 800c5a8:	4620      	mov	r0, r4
 800c5aa:	f01a f94d 	bl	8026848 <sprintf>
 800c5ae:	4620      	mov	r0, r4
 800c5b0:	f012 febb 	bl	801f32a <crs_strlen>
 800c5b4:	b283      	uxth	r3, r0
 800c5b6:	4622      	mov	r2, r4
 800c5b8:	2102      	movs	r1, #2
 800c5ba:	4608      	mov	r0, r1
 800c5bc:	f012 fef8 	bl	801f3b0 <traceIF_itmPrint>
 800c5c0:	4620      	mov	r0, r4
 800c5c2:	f012 feb2 	bl	801f32a <crs_strlen>
 800c5c6:	b283      	uxth	r3, r0
 800c5c8:	4622      	mov	r2, r4
 800c5ca:	2102      	movs	r1, #2
 800c5cc:	4608      	mov	r0, r1
 800c5ce:	f012 ff11 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c5d2:	4628      	mov	r0, r5
 800c5d4:	bd38      	pop	{r3, r4, r5, pc}
 800c5d6:	bf00      	nop
 800c5d8:	200035cc 	.word	0x200035cc
 800c5dc:	200048dc 	.word	0x200048dc
 800c5e0:	0802e768 	.word	0x0802e768

0800c5e4 <atcc_get_rsp>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_rsp_buf Pointer to the buffer to return the message.
  * @retval at_status_t
  */
at_status_t atcc_get_rsp(at_context_t *p_at_ctxt, at_buf_t *p_rsp_buf)
{
 800c5e4:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_get_rsp)(&p_at_ctxt->parser, p_rsp_buf);
 800c5e6:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c5ea:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c5ee:	4a10      	ldr	r2, [pc, #64]	; (800c630 <atcc_get_rsp+0x4c>)
 800c5f0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c5f4:	6a1b      	ldr	r3, [r3, #32]
 800c5f6:	4798      	blx	r3
 800c5f8:	4605      	mov	r5, r0

  PRINT_DBG("atcc_get_rsp returned status = %d", retval)
 800c5fa:	4c0e      	ldr	r4, [pc, #56]	; (800c634 <atcc_get_rsp+0x50>)
 800c5fc:	4602      	mov	r2, r0
 800c5fe:	490e      	ldr	r1, [pc, #56]	; (800c638 <atcc_get_rsp+0x54>)
 800c600:	4620      	mov	r0, r4
 800c602:	f01a f921 	bl	8026848 <sprintf>
 800c606:	4620      	mov	r0, r4
 800c608:	f012 fe8f 	bl	801f32a <crs_strlen>
 800c60c:	b283      	uxth	r3, r0
 800c60e:	4622      	mov	r2, r4
 800c610:	2102      	movs	r1, #2
 800c612:	4608      	mov	r0, r1
 800c614:	f012 fecc 	bl	801f3b0 <traceIF_itmPrint>
 800c618:	4620      	mov	r0, r4
 800c61a:	f012 fe86 	bl	801f32a <crs_strlen>
 800c61e:	b283      	uxth	r3, r0
 800c620:	4622      	mov	r2, r4
 800c622:	2102      	movs	r1, #2
 800c624:	4608      	mov	r0, r1
 800c626:	f012 fee5 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c62a:	4628      	mov	r0, r5
 800c62c:	bd38      	pop	{r3, r4, r5, pc}
 800c62e:	bf00      	nop
 800c630:	200035cc 	.word	0x200035cc
 800c634:	200048dc 	.word	0x200048dc
 800c638:	0802e79c 	.word	0x0802e79c

0800c63c <atcc_get_urc>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_rsp_buf Pointer to the buffer to return the message.
  * @retval at_status_t
  */
at_status_t atcc_get_urc(at_context_t *p_at_ctxt, at_buf_t *p_rsp_buf)
{
 800c63c:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_get_urc)(&p_at_ctxt->parser, p_rsp_buf);
 800c63e:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c642:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c646:	4a10      	ldr	r2, [pc, #64]	; (800c688 <atcc_get_urc+0x4c>)
 800c648:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c64c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800c64e:	4798      	blx	r3
 800c650:	4605      	mov	r5, r0

  PRINT_DBG("atcc_get_urc returned status = %d", retval)
 800c652:	4c0e      	ldr	r4, [pc, #56]	; (800c68c <atcc_get_urc+0x50>)
 800c654:	4602      	mov	r2, r0
 800c656:	490e      	ldr	r1, [pc, #56]	; (800c690 <atcc_get_urc+0x54>)
 800c658:	4620      	mov	r0, r4
 800c65a:	f01a f8f5 	bl	8026848 <sprintf>
 800c65e:	4620      	mov	r0, r4
 800c660:	f012 fe63 	bl	801f32a <crs_strlen>
 800c664:	b283      	uxth	r3, r0
 800c666:	4622      	mov	r2, r4
 800c668:	2102      	movs	r1, #2
 800c66a:	4608      	mov	r0, r1
 800c66c:	f012 fea0 	bl	801f3b0 <traceIF_itmPrint>
 800c670:	4620      	mov	r0, r4
 800c672:	f012 fe5a 	bl	801f32a <crs_strlen>
 800c676:	b283      	uxth	r3, r0
 800c678:	4622      	mov	r2, r4
 800c67a:	2102      	movs	r1, #2
 800c67c:	4608      	mov	r0, r1
 800c67e:	f012 feb9 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c682:	4628      	mov	r0, r5
 800c684:	bd38      	pop	{r3, r4, r5, pc}
 800c686:	bf00      	nop
 800c688:	200035cc 	.word	0x200035cc
 800c68c:	200048dc 	.word	0x200048dc
 800c690:	0802e7cc 	.word	0x0802e7cc

0800c694 <atcc_get_error>:
  * @param  p_at_ctxt Pointer to the modem context.
  * @param  p_rsp_buf Pointer to the buffer to return the message.
  * @retval at_status_t
  */
at_status_t atcc_get_error(at_context_t *p_at_ctxt, at_buf_t *p_rsp_buf)
{
 800c694:	b538      	push	{r3, r4, r5, lr}
  at_status_t retval;

  retval = (*at_custom_func[p_at_ctxt->device_type].f_get_error)(&p_at_ctxt->parser, p_rsp_buf);
 800c696:	f810 3b10 	ldrb.w	r3, [r0], #16
 800c69a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800c69e:	4a10      	ldr	r2, [pc, #64]	; (800c6e0 <atcc_get_error+0x4c>)
 800c6a0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 800c6a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c6a6:	4798      	blx	r3
 800c6a8:	4605      	mov	r5, r0

  PRINT_DBG("atcc_get_error returned status = %d", retval)
 800c6aa:	4c0e      	ldr	r4, [pc, #56]	; (800c6e4 <atcc_get_error+0x50>)
 800c6ac:	4602      	mov	r2, r0
 800c6ae:	490e      	ldr	r1, [pc, #56]	; (800c6e8 <atcc_get_error+0x54>)
 800c6b0:	4620      	mov	r0, r4
 800c6b2:	f01a f8c9 	bl	8026848 <sprintf>
 800c6b6:	4620      	mov	r0, r4
 800c6b8:	f012 fe37 	bl	801f32a <crs_strlen>
 800c6bc:	b283      	uxth	r3, r0
 800c6be:	4622      	mov	r2, r4
 800c6c0:	2102      	movs	r1, #2
 800c6c2:	4608      	mov	r0, r1
 800c6c4:	f012 fe74 	bl	801f3b0 <traceIF_itmPrint>
 800c6c8:	4620      	mov	r0, r4
 800c6ca:	f012 fe2e 	bl	801f32a <crs_strlen>
 800c6ce:	b283      	uxth	r3, r0
 800c6d0:	4622      	mov	r2, r4
 800c6d2:	2102      	movs	r1, #2
 800c6d4:	4608      	mov	r0, r1
 800c6d6:	f012 fe8d 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800c6da:	4628      	mov	r0, r5
 800c6dc:	bd38      	pop	{r3, r4, r5, pc}
 800c6de:	bf00      	nop
 800c6e0:	200035cc 	.word	0x200035cc
 800c6e4:	200048dc 	.word	0x200048dc
 800c6e8:	0802e7fc 	.word	0x0802e7fc

0800c6ec <atcc_hw_event>:
void atcc_hw_event(sysctrl_device_type_t deviceType, at_hw_event_t hwEvent, GPIO_PinState gstate)
{
  /* Do not add traces (called under interrupt if GPIO event)
   * device type = modem
   */
  if (deviceType == DEVTYPE_MODEM_CELLULAR)
 800c6ec:	b930      	cbnz	r0, 800c6fc <atcc_hw_event+0x10>
{
 800c6ee:	b510      	push	{r4, lr}
 800c6f0:	4603      	mov	r3, r0
  {
    (void)(*at_custom_func[DEVTYPE_MODEM_CELLULAR].f_hw_event)(deviceType, hwEvent, gstate);
 800c6f2:	4803      	ldr	r0, [pc, #12]	; (800c700 <atcc_hw_event+0x14>)
 800c6f4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 800c6f6:	4618      	mov	r0, r3
 800c6f8:	47a0      	blx	r4
  }
}
 800c6fa:	bd10      	pop	{r4, pc}
 800c6fc:	4770      	bx	lr
 800c6fe:	bf00      	nop
 800c700:	200035cc 	.word	0x200035cc

0800c704 <affect_modem_cid>:

/*
*  Affect a modem cid to the specified user PDP config
*/
static void affect_modem_cid(atcustom_persistent_context_t *p_persistent_ctxt, CS_PDN_conf_id_t conf_id)
{
 800c704:	b538      	push	{r3, r4, r5, lr}

  /* only for CS_PDN_USER_CONFIG_1 to CS_PDN_USER_CONFIG_5 */
  if ((conf_id == CS_PDN_USER_CONFIG_1) ||
      (conf_id == CS_PDN_USER_CONFIG_2) ||
      (conf_id == CS_PDN_USER_CONFIG_3) ||
      (conf_id == CS_PDN_USER_CONFIG_4) ||
 800c706:	1e4b      	subs	r3, r1, #1
 800c708:	b2db      	uxtb	r3, r3
  if ((conf_id == CS_PDN_USER_CONFIG_1) ||
 800c70a:	2b04      	cmp	r3, #4
 800c70c:	d925      	bls.n	800c75a <affect_modem_cid+0x56>
      i++;
    } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
  }
  else
  {
    PRINT_ERR("Trying to affect a non-valid modem CID")
 800c70e:	4c1f      	ldr	r4, [pc, #124]	; (800c78c <affect_modem_cid+0x88>)
 800c710:	4d1f      	ldr	r5, [pc, #124]	; (800c790 <affect_modem_cid+0x8c>)
 800c712:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 800c716:	46a4      	mov	ip, r4
 800c718:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800c71c:	6028      	str	r0, [r5, #0]
 800c71e:	6069      	str	r1, [r5, #4]
 800c720:	60aa      	str	r2, [r5, #8]
 800c722:	60eb      	str	r3, [r5, #12]
 800c724:	4664      	mov	r4, ip
 800c726:	3510      	adds	r5, #16
 800c728:	45f4      	cmp	ip, lr
 800c72a:	d1f4      	bne.n	800c716 <affect_modem_cid+0x12>
 800c72c:	cc03      	ldmia	r4!, {r0, r1}
 800c72e:	6028      	str	r0, [r5, #0]
 800c730:	6069      	str	r1, [r5, #4]
 800c732:	4c17      	ldr	r4, [pc, #92]	; (800c790 <affect_modem_cid+0x8c>)
 800c734:	4620      	mov	r0, r4
 800c736:	f012 fdf8 	bl	801f32a <crs_strlen>
 800c73a:	b283      	uxth	r3, r0
 800c73c:	4622      	mov	r2, r4
 800c73e:	2110      	movs	r1, #16
 800c740:	2002      	movs	r0, #2
 800c742:	f012 fe35 	bl	801f3b0 <traceIF_itmPrint>
 800c746:	4620      	mov	r0, r4
 800c748:	f012 fdef 	bl	801f32a <crs_strlen>
 800c74c:	b283      	uxth	r3, r0
 800c74e:	4622      	mov	r2, r4
 800c750:	2110      	movs	r1, #16
 800c752:	2002      	movs	r0, #2
 800c754:	f012 fe4e 	bl	801f3f4 <traceIF_uartPrint>
  }

  return;
}
 800c758:	bd38      	pop	{r3, r4, r5, pc}
    uint8_t i = 0U;
 800c75a:	2300      	movs	r3, #0
    bool leave_loop = false;
 800c75c:	461c      	mov	r4, r3
 800c75e:	e005      	b.n	800c76c <affect_modem_cid+0x68>
      i++;
 800c760:	3301      	adds	r3, #1
 800c762:	b2db      	uxtb	r3, r3
    } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800c764:	2c00      	cmp	r4, #0
 800c766:	d1f7      	bne.n	800c758 <affect_modem_cid+0x54>
 800c768:	2b05      	cmp	r3, #5
 800c76a:	d8f5      	bhi.n	800c758 <affect_modem_cid+0x54>
      if (conf_id == p_tmp->affected_config)
 800c76c:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800c770:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800c774:	f892 2352 	ldrb.w	r2, [r2, #850]	; 0x352
 800c778:	428a      	cmp	r2, r1
 800c77a:	d1f1      	bne.n	800c760 <affect_modem_cid+0x5c>
        p_tmp->pdn_defined = AT_TRUE;
 800c77c:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800c780:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 800c784:	2401      	movs	r4, #1
 800c786:	f882 4351 	strb.w	r4, [r2, #849]	; 0x351
        leave_loop = true;
 800c78a:	e7e9      	b.n	800c760 <affect_modem_cid+0x5c>
 800c78c:	0802e82c 	.word	0x0802e82c
 800c790:	200048dc 	.word	0x200048dc

0800c794 <atcm_put_IP_address_infos>:
  * @retval none
  */
void atcm_put_IP_address_infos(atcustom_persistent_context_t *p_persistent_ctxt,
                               uint8_t modem_cid,
                               csint_ip_addr_info_t *ip_addr_info)
{
 800c794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c796:	4605      	mov	r5, r0
 800c798:	460e      	mov	r6, r1
 800c79a:	4617      	mov	r7, r2
  bool leave_loop = false;
  uint8_t i = 0U;
 800c79c:	2400      	movs	r4, #0
  bool leave_loop = false;
 800c79e:	4622      	mov	r2, r4
  do
  {
    atcustom_modem_cid_table_t *p_tmp;
    p_tmp = &p_persistent_ctxt->modem_cid_table[i];
    if (p_tmp->mdm_cid_value == modem_cid)
 800c7a0:	eb04 1304 	add.w	r3, r4, r4, lsl #4
 800c7a4:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800c7a8:	f893 3350 	ldrb.w	r3, [r3, #848]	; 0x350
 800c7ac:	42b3      	cmp	r3, r6
 800c7ae:	d005      	beq.n	800c7bc <atcm_put_IP_address_infos+0x28>
      (void) memcpy((void *)& p_tmp->ip_addr_infos,
                    (void *)ip_addr_info,
                    sizeof(csint_ip_addr_info_t));
      leave_loop = true;
    }
    i++;
 800c7b0:	3401      	adds	r4, #1
 800c7b2:	b2e4      	uxtb	r4, r4
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800c7b4:	b90a      	cbnz	r2, 800c7ba <atcm_put_IP_address_infos+0x26>
 800c7b6:	2c05      	cmp	r4, #5
 800c7b8:	d9f2      	bls.n	800c7a0 <atcm_put_IP_address_infos+0xc>

  return;
}
 800c7ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void) memcpy((void *)& p_tmp->ip_addr_infos,
 800c7bc:	eb04 1004 	add.w	r0, r4, r4, lsl #4
 800c7c0:	0080      	lsls	r0, r0, #2
 800c7c2:	f500 7054 	add.w	r0, r0, #848	; 0x350
 800c7c6:	4428      	add	r0, r5
 800c7c8:	2241      	movs	r2, #65	; 0x41
 800c7ca:	4639      	mov	r1, r7
 800c7cc:	3003      	adds	r0, #3
 800c7ce:	f01a f98b 	bl	8026ae8 <memcpy>
      leave_loop = true;
 800c7d2:	2201      	movs	r2, #1
 800c7d4:	e7ec      	b.n	800c7b0 <atcm_put_IP_address_infos+0x1c>

0800c7d6 <atcm_get_IP_address_infos>:
  * @retval none
  */
void atcm_get_IP_address_infos(atcustom_persistent_context_t *p_persistent_ctxt,
                               CS_PDN_conf_id_t conf_id,
                               csint_ip_addr_info_t  *ip_addr_info)
{
 800c7d6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c7d8:	4605      	mov	r5, r0
 800c7da:	460e      	mov	r6, r1
 800c7dc:	4617      	mov	r7, r2
  bool leave_loop = false;
  uint8_t i = 0U;
 800c7de:	2400      	movs	r4, #0
  bool leave_loop = false;
 800c7e0:	4622      	mov	r2, r4
  do
  {
    atcustom_modem_cid_table_t *p_tmp;
    p_tmp = &p_persistent_ctxt->modem_cid_table[i];
    if (p_tmp->affected_config == conf_id)
 800c7e2:	eb04 1304 	add.w	r3, r4, r4, lsl #4
 800c7e6:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800c7ea:	f893 3352 	ldrb.w	r3, [r3, #850]	; 0x352
 800c7ee:	42b3      	cmp	r3, r6
 800c7f0:	d005      	beq.n	800c7fe <atcm_get_IP_address_infos+0x28>
      (void) memcpy((void *)ip_addr_info,
                    (void *)& p_tmp->ip_addr_infos,
                    sizeof(csint_ip_addr_info_t));
      leave_loop = true;
    }
    i++;
 800c7f2:	3401      	adds	r4, #1
 800c7f4:	b2e4      	uxtb	r4, r4
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800c7f6:	b90a      	cbnz	r2, 800c7fc <atcm_get_IP_address_infos+0x26>
 800c7f8:	2c05      	cmp	r4, #5
 800c7fa:	d9f2      	bls.n	800c7e2 <atcm_get_IP_address_infos+0xc>

  return;
}
 800c7fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    (void *)& p_tmp->ip_addr_infos,
 800c7fe:	eb04 1104 	add.w	r1, r4, r4, lsl #4
 800c802:	0089      	lsls	r1, r1, #2
 800c804:	f501 7154 	add.w	r1, r1, #848	; 0x350
 800c808:	4429      	add	r1, r5
      (void) memcpy((void *)ip_addr_info,
 800c80a:	2241      	movs	r2, #65	; 0x41
 800c80c:	3103      	adds	r1, #3
 800c80e:	4638      	mov	r0, r7
 800c810:	f01a f96a 	bl	8026ae8 <memcpy>
      leave_loop = true;
 800c814:	2201      	movs	r2, #1
 800c816:	e7ec      	b.n	800c7f2 <atcm_get_IP_address_infos+0x1c>

0800c818 <atcm_get_ip_address_type>:
  *                According to 3GP TS27.007, IPv6 can also use IPv4-like dot-notation:
  *                format= a1.a2.a3.a4.a5a.a6.a7.a8.a9.a10.a11.a12a.a13.a14.a15.a16  (where 0<=ax<=255)
  *                (max string size = 63 characters )
  *
  */
  if (p_addr_str != NULL)
 800c818:	b328      	cbz	r0, 800c866 <atcm_get_ip_address_type+0x4e>
{
 800c81a:	b510      	push	{r4, lr}
 800c81c:	4604      	mov	r4, r0
  {
    uint8_t str_size_cpt = (uint8_t) strlen((const CRC_CHAR_t *)p_addr_str);
 800c81e:	f7f3 fce9 	bl	80001f4 <strlen>
 800c822:	b2c0      	uxtb	r0, r0
    str_size_cpt = (str_size_cpt > 39U) ? 39U : str_size_cpt;
 800c824:	2827      	cmp	r0, #39	; 0x27
 800c826:	bf28      	it	cs
 800c828:	2027      	movcs	r0, #39	; 0x27
    uint8_t count_dots = 0U;
    uint8_t count_colons = 0U;
 800c82a:	2100      	movs	r1, #0
    uint8_t count_dots = 0U;
 800c82c:	460a      	mov	r2, r1
 800c82e:	e006      	b.n	800c83e <atcm_get_ip_address_type+0x26>

    do
    {
      if (*pTmp == ((AT_CHAR_t)'.'))
      {
        count_dots++;
 800c830:	3201      	adds	r2, #1
 800c832:	b2d2      	uxtb	r2, r2
      else
      {
        /* nothing to do - MISRA */
      }
      /* next character */
      pTmp++;
 800c834:	3401      	adds	r4, #1
      str_size_cpt--;
 800c836:	3801      	subs	r0, #1
    }  while (str_size_cpt > 0U);
 800c838:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 800c83c:	d007      	beq.n	800c84e <atcm_get_ip_address_type+0x36>
      if (*pTmp == ((AT_CHAR_t)'.'))
 800c83e:	7823      	ldrb	r3, [r4, #0]
 800c840:	2b2e      	cmp	r3, #46	; 0x2e
 800c842:	d0f5      	beq.n	800c830 <atcm_get_ip_address_type+0x18>
      else if (*pTmp == ((AT_CHAR_t)':'))
 800c844:	2b3a      	cmp	r3, #58	; 0x3a
 800c846:	d1f5      	bne.n	800c834 <atcm_get_ip_address_type+0x1c>
        count_colons++;
 800c848:	3101      	adds	r1, #1
 800c84a:	b2c9      	uxtb	r1, r1
 800c84c:	e7f2      	b.n	800c834 <atcm_get_ip_address_type+0x1c>

    /* analyze result */
    if ((count_dots >= 1U) && (count_dots <= 3U))
 800c84e:	1e53      	subs	r3, r2, #1
 800c850:	b2db      	uxtb	r3, r3
 800c852:	2b02      	cmp	r3, #2
 800c854:	d909      	bls.n	800c86a <atcm_get_ip_address_type+0x52>
    {
      retval = CS_IPAT_IPV4;
    }
    else if (((count_colons >= 1U) && (count_colons <= 7U)) ||
 800c856:	3901      	subs	r1, #1
 800c858:	b2c9      	uxtb	r1, r1
 800c85a:	2906      	cmp	r1, #6
 800c85c:	d907      	bls.n	800c86e <atcm_get_ip_address_type+0x56>
 800c85e:	2a03      	cmp	r2, #3
 800c860:	d904      	bls.n	800c86c <atcm_get_ip_address_type+0x54>
             (count_dots > 3U))
    {
      retval = CS_IPAT_IPV6;
 800c862:	2002      	movs	r0, #2
 800c864:	e002      	b.n	800c86c <atcm_get_ip_address_type+0x54>
      retval = CS_IPAT_INVALID;
    }
  }
  else
  {
    retval = CS_IPAT_INVALID;
 800c866:	2000      	movs	r0, #0
  }

  return (retval);
}
 800c868:	4770      	bx	lr
      retval = CS_IPAT_IPV4;
 800c86a:	2001      	movs	r0, #1
}
 800c86c:	bd10      	pop	{r4, pc}
      retval = CS_IPAT_IPV6;
 800c86e:	2002      	movs	r0, #2
 800c870:	e7fc      	b.n	800c86c <atcm_get_ip_address_type+0x54>

0800c872 <atcm_extract_IP_address>:
  * @param  p_Dst ptr to Destination Buffer !!! this buffer has to be defined
  *               with buffer[MAX_IP_ADDR_SIZE] !!!
  * @retval at_status_t.
  */
void atcm_extract_IP_address(const uint8_t *p_Src, uint16_t size, uint8_t *p_Dst)
{
 800c872:	b570      	push	{r4, r5, r6, lr}
 800c874:	4605      	mov	r5, r0
 800c876:	460c      	mov	r4, r1
 800c878:	4616      	mov	r6, r2
  uint16_t src_idx;
  uint16_t dest_idx = 0U;

  /* reset p_Dst buffer */
  (void) memset((void *)p_Dst, 0, MAX_IP_ADDR_SIZE);
 800c87a:	2240      	movs	r2, #64	; 0x40
 800c87c:	2100      	movs	r1, #0
 800c87e:	4630      	mov	r0, r6
 800c880:	f01a f855 	bl	802692e <memset>
  uint16_t dest_idx = 0U;
 800c884:	f04f 0c00 	mov.w	ip, #0

  /* parse p_Src */
  for (src_idx = 0; ((src_idx < size) && (dest_idx < MAX_IP_ADDR_SIZE)); src_idx++)
 800c888:	4663      	mov	r3, ip
 800c88a:	e001      	b.n	800c890 <atcm_extract_IP_address+0x1e>
 800c88c:	3301      	adds	r3, #1
 800c88e:	b29b      	uxth	r3, r3
 800c890:	42a3      	cmp	r3, r4
 800c892:	d20e      	bcs.n	800c8b2 <atcm_extract_IP_address+0x40>
 800c894:	f1bc 0f3f 	cmp.w	ip, #63	; 0x3f
 800c898:	d80b      	bhi.n	800c8b2 <atcm_extract_IP_address+0x40>
  {
    /* remove quotes from the string */
    if (p_Src[src_idx] != 0x22U)
 800c89a:	f815 e003 	ldrb.w	lr, [r5, r3]
 800c89e:	f1be 0f22 	cmp.w	lr, #34	; 0x22
 800c8a2:	d0f3      	beq.n	800c88c <atcm_extract_IP_address+0x1a>
    {
      /* write to p_Dst*/
      p_Dst[dest_idx] = p_Src[src_idx];
 800c8a4:	f806 e00c 	strb.w	lr, [r6, ip]
      dest_idx++;
 800c8a8:	f10c 0c01 	add.w	ip, ip, #1
 800c8ac:	fa1f fc8c 	uxth.w	ip, ip
 800c8b0:	e7ec      	b.n	800c88c <atcm_extract_IP_address+0x1a>
    }
  }
}
 800c8b2:	bd70      	pop	{r4, r5, r6, pc}

0800c8b4 <atcm_get_cid_current_SID>:
  * @brief  Get conf_ig in current SID context (interpret default if needed)
  * @param  p_modem_ctxt
  * @retval CS_PDN_conf_id_t
  */
CS_PDN_conf_id_t atcm_get_cid_current_SID(atcustom_modem_context_t *p_modem_ctxt)
{
 800c8b4:	b538      	push	{r3, r4, r5, lr}
  /* get conf_id received for current SID */
  CS_PDN_conf_id_t current_conf_id = p_modem_ctxt->SID_ctxt.pdn_conf_id;
 800c8b6:	f890 46c9 	ldrb.w	r4, [r0, #1737]	; 0x6c9

  /* if default PDN is required, retrieve corresponding conf_id */
  if (current_conf_id == CS_PDN_CONFIG_DEFAULT)
 800c8ba:	2c0b      	cmp	r4, #11
 800c8bc:	d001      	beq.n	800c8c2 <atcm_get_cid_current_SID+0xe>
    current_conf_id = p_modem_ctxt->persist.pdn_default_conf_id;
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
  }

  return (current_conf_id);
}
 800c8be:	4620      	mov	r0, r4
 800c8c0:	bd38      	pop	{r3, r4, r5, pc}
    current_conf_id = p_modem_ctxt->persist.pdn_default_conf_id;
 800c8c2:	f890 44f4 	ldrb.w	r4, [r0, #1268]	; 0x4f4
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
 800c8c6:	4d0c      	ldr	r5, [pc, #48]	; (800c8f8 <atcm_get_cid_current_SID+0x44>)
 800c8c8:	4622      	mov	r2, r4
 800c8ca:	490c      	ldr	r1, [pc, #48]	; (800c8fc <atcm_get_cid_current_SID+0x48>)
 800c8cc:	4628      	mov	r0, r5
 800c8ce:	f019 ffbb 	bl	8026848 <sprintf>
 800c8d2:	4628      	mov	r0, r5
 800c8d4:	f012 fd29 	bl	801f32a <crs_strlen>
 800c8d8:	b283      	uxth	r3, r0
 800c8da:	462a      	mov	r2, r5
 800c8dc:	2102      	movs	r1, #2
 800c8de:	4608      	mov	r0, r1
 800c8e0:	f012 fd66 	bl	801f3b0 <traceIF_itmPrint>
 800c8e4:	4628      	mov	r0, r5
 800c8e6:	f012 fd20 	bl	801f32a <crs_strlen>
 800c8ea:	b283      	uxth	r3, r0
 800c8ec:	462a      	mov	r2, r5
 800c8ee:	2102      	movs	r1, #2
 800c8f0:	4608      	mov	r0, r1
 800c8f2:	f012 fd7f 	bl	801f3f4 <traceIF_uartPrint>
 800c8f6:	e7e2      	b.n	800c8be <atcm_get_cid_current_SID+0xa>
 800c8f8:	200048dc 	.word	0x200048dc
 800c8fc:	0802e864 	.word	0x0802e864

0800c900 <atcm_get_CmdStr>:
  const AT_CHAR_t *retval = ((uint8_t *)"");
  uint16_t i = 0U;
  bool leave_loop = false;

  /* check if this is the invalid cmd id*/
  if (cmd_id != CMD_AT_INVALID)
 800c900:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c904:	d101      	bne.n	800c90a <atcm_get_CmdStr+0xa>
  const AT_CHAR_t *retval = ((uint8_t *)"");
 800c906:	480e      	ldr	r0, [pc, #56]	; (800c940 <atcm_get_CmdStr+0x40>)
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c908:	4770      	bx	lr
{
 800c90a:	b530      	push	{r4, r5, lr}
 800c90c:	4603      	mov	r3, r0
  bool leave_loop = false;
 800c90e:	2500      	movs	r5, #0
  uint16_t i = 0U;
 800c910:	462a      	mov	r2, r5
  const AT_CHAR_t *retval = ((uint8_t *)"");
 800c912:	480b      	ldr	r0, [pc, #44]	; (800c940 <atcm_get_CmdStr+0x40>)
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c914:	685c      	ldr	r4, [r3, #4]
 800c916:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800c91a:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c91e:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c922:	f854 400e 	ldr.w	r4, [r4, lr]
 800c926:	428c      	cmp	r4, r1
 800c928:	d006      	beq.n	800c938 <atcm_get_CmdStr+0x38>
      i++;
 800c92a:	3201      	adds	r2, #1
 800c92c:	b292      	uxth	r2, r2
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c92e:	b915      	cbnz	r5, 800c936 <atcm_get_CmdStr+0x36>
 800c930:	681c      	ldr	r4, [r3, #0]
 800c932:	42a2      	cmp	r2, r4
 800c934:	d3ee      	bcc.n	800c914 <atcm_get_CmdStr+0x14>
}
 800c936:	bd30      	pop	{r4, r5, pc}
        retval = (const AT_CHAR_t *)(&p_modem_ctxt->p_modem_LUT[i].cmd_str);
 800c938:	f10c 0004 	add.w	r0, ip, #4
        leave_loop = true;
 800c93c:	2501      	movs	r5, #1
 800c93e:	e7f4      	b.n	800c92a <atcm_get_CmdStr+0x2a>
 800c940:	08035c54 	.word	0x08035c54

0800c944 <atcm_get_CmdTimeout>:
uint32_t atcm_get_CmdTimeout(const atcustom_modem_context_t *p_modem_ctxt, uint32_t cmd_id)
{
  uint32_t retval = MODEM_DEFAULT_TIMEOUT;

  /* check if this is the invalid cmd id */
  if (cmd_id != CMD_AT_INVALID)
 800c944:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c948:	d102      	bne.n	800c950 <atcm_get_CmdTimeout+0xc>
  uint32_t retval = MODEM_DEFAULT_TIMEOUT;
 800c94a:	f242 7010 	movw	r0, #10000	; 0x2710
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c94e:	4770      	bx	lr
{
 800c950:	b530      	push	{r4, r5, lr}
 800c952:	4602      	mov	r2, r0
    uint16_t i = 0U;
 800c954:	2300      	movs	r3, #0
    bool leave_loop = false;
 800c956:	461d      	mov	r5, r3
  uint32_t retval = MODEM_DEFAULT_TIMEOUT;
 800c958:	f242 7010 	movw	r0, #10000	; 0x2710
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c95c:	6854      	ldr	r4, [r2, #4]
 800c95e:	eb03 0c43 	add.w	ip, r3, r3, lsl #1
 800c962:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c966:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c96a:	f854 400e 	ldr.w	r4, [r4, lr]
 800c96e:	428c      	cmp	r4, r1
 800c970:	d006      	beq.n	800c980 <atcm_get_CmdTimeout+0x3c>
      i++;
 800c972:	3301      	adds	r3, #1
 800c974:	b29b      	uxth	r3, r3
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c976:	b915      	cbnz	r5, 800c97e <atcm_get_CmdTimeout+0x3a>
 800c978:	6814      	ldr	r4, [r2, #0]
 800c97a:	42a3      	cmp	r3, r4
 800c97c:	d3ee      	bcc.n	800c95c <atcm_get_CmdTimeout+0x18>
}
 800c97e:	bd30      	pop	{r4, r5, pc}
        retval = p_modem_ctxt->p_modem_LUT[i].cmd_timeout;
 800c980:	f8dc 0024 	ldr.w	r0, [ip, #36]	; 0x24
        leave_loop = true;
 800c984:	2501      	movs	r5, #1
 800c986:	e7f4      	b.n	800c972 <atcm_get_CmdTimeout+0x2e>

0800c988 <atcm_get_CmdBuildFunc>:
  */
CmdBuildFuncTypeDef atcm_get_CmdBuildFunc(const atcustom_modem_context_t *p_modem_ctxt, uint32_t cmd_id)
{
  CmdBuildFuncTypeDef retval = fCmdBuild_NoParams; /* return default value */

  if (cmd_id != CMD_AT_INVALID)
 800c988:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c98c:	d101      	bne.n	800c992 <atcm_get_CmdBuildFunc+0xa>
  CmdBuildFuncTypeDef retval = fCmdBuild_NoParams; /* return default value */
 800c98e:	480e      	ldr	r0, [pc, #56]	; (800c9c8 <atcm_get_CmdBuildFunc+0x40>)
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c990:	4770      	bx	lr
{
 800c992:	b530      	push	{r4, r5, lr}
 800c994:	4603      	mov	r3, r0
    bool leave_loop = false;
 800c996:	2500      	movs	r5, #0
    uint16_t i = 0U;
 800c998:	462a      	mov	r2, r5
  CmdBuildFuncTypeDef retval = fCmdBuild_NoParams; /* return default value */
 800c99a:	480b      	ldr	r0, [pc, #44]	; (800c9c8 <atcm_get_CmdBuildFunc+0x40>)
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c99c:	685c      	ldr	r4, [r3, #4]
 800c99e:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800c9a2:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c9a6:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c9aa:	f854 400e 	ldr.w	r4, [r4, lr]
 800c9ae:	428c      	cmp	r4, r1
 800c9b0:	d006      	beq.n	800c9c0 <atcm_get_CmdBuildFunc+0x38>
      i++;
 800c9b2:	3201      	adds	r2, #1
 800c9b4:	b292      	uxth	r2, r2
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c9b6:	b915      	cbnz	r5, 800c9be <atcm_get_CmdBuildFunc+0x36>
 800c9b8:	681c      	ldr	r4, [r3, #0]
 800c9ba:	42a2      	cmp	r2, r4
 800c9bc:	d3ee      	bcc.n	800c99c <atcm_get_CmdBuildFunc+0x14>
}
 800c9be:	bd30      	pop	{r4, r5, pc}
        retval = p_modem_ctxt->p_modem_LUT[i].cmd_BuildFunc;
 800c9c0:	f8dc 0028 	ldr.w	r0, [ip, #40]	; 0x28
        leave_loop = true;
 800c9c4:	2501      	movs	r5, #1
 800c9c6:	e7f4      	b.n	800c9b2 <atcm_get_CmdBuildFunc+0x2a>
 800c9c8:	0800ed0d 	.word	0x0800ed0d

0800c9cc <atcm_get_CmdAnalyzeFunc>:
  */
CmdAnalyzeFuncTypeDef atcm_get_CmdAnalyzeFunc(const atcustom_modem_context_t *p_modem_ctxt, uint32_t cmd_id)
{
  CmdAnalyzeFuncTypeDef retval = fRspAnalyze_None;

  if (cmd_id != CMD_AT_INVALID)
 800c9cc:	f1b1 3fff 	cmp.w	r1, #4294967295
 800c9d0:	d101      	bne.n	800c9d6 <atcm_get_CmdAnalyzeFunc+0xa>
  CmdAnalyzeFuncTypeDef retval = fRspAnalyze_None;
 800c9d2:	480e      	ldr	r0, [pc, #56]	; (800ca0c <atcm_get_CmdAnalyzeFunc+0x40>)
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }

  return (retval);
}
 800c9d4:	4770      	bx	lr
{
 800c9d6:	b530      	push	{r4, r5, lr}
 800c9d8:	4603      	mov	r3, r0
    bool leave_loop = false;
 800c9da:	2500      	movs	r5, #0
    uint16_t i = 0U;
 800c9dc:	462a      	mov	r2, r5
  CmdAnalyzeFuncTypeDef retval = fRspAnalyze_None;
 800c9de:	480b      	ldr	r0, [pc, #44]	; (800ca0c <atcm_get_CmdAnalyzeFunc+0x40>)
      if (p_modem_ctxt->p_modem_LUT[i].cmd_id == cmd_id)
 800c9e0:	685c      	ldr	r4, [r3, #4]
 800c9e2:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 800c9e6:	ea4f 1e0c 	mov.w	lr, ip, lsl #4
 800c9ea:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
 800c9ee:	f854 400e 	ldr.w	r4, [r4, lr]
 800c9f2:	428c      	cmp	r4, r1
 800c9f4:	d006      	beq.n	800ca04 <atcm_get_CmdAnalyzeFunc+0x38>
      i++;
 800c9f6:	3201      	adds	r2, #1
 800c9f8:	b292      	uxth	r2, r2
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800c9fa:	b915      	cbnz	r5, 800ca02 <atcm_get_CmdAnalyzeFunc+0x36>
 800c9fc:	681c      	ldr	r4, [r3, #0]
 800c9fe:	42a2      	cmp	r2, r4
 800ca00:	d3ee      	bcc.n	800c9e0 <atcm_get_CmdAnalyzeFunc+0x14>
}
 800ca02:	bd30      	pop	{r4, r5, pc}
        retval = p_modem_ctxt->p_modem_LUT[i].rsp_AnalyzeFunc;
 800ca04:	f8dc 002c 	ldr.w	r0, [ip, #44]	; 0x2c
        leave_loop = true;
 800ca08:	2501      	movs	r5, #1
 800ca0a:	e7f4      	b.n	800c9f6 <atcm_get_CmdAnalyzeFunc+0x2a>
 800ca0c:	08010075 	.word	0x08010075

0800ca10 <atcm_get_PDPtypeStr>:
  * @brief  Get type of PDP address
  * @param  pdp_type
  * @retval AT_CHAR_t
  */
const AT_CHAR_t *atcm_get_PDPtypeStr(CS_PDPtype_t pdp_type)
{
 800ca10:	b410      	push	{r4}
 800ca12:	4684      	mov	ip, r0
    {CS_PDPTYPE_IPV4V6, "IPV4V6"},
    {CS_PDPTYPE_PPP,    "PPP"},
  };
  uint16_t i = 0U;
  uint16_t max_array_size = (uint16_t)(sizeof(ACTM_PDP_TYPE_LUT) / sizeof(atcm_pdp_type_LUT_t));
  bool leave_loop = false;
 800ca14:	2400      	movs	r4, #0
  uint16_t i = 0U;
 800ca16:	4623      	mov	r3, r4
  const AT_CHAR_t *retval = ((uint8_t *)"");
 800ca18:	480b      	ldr	r0, [pc, #44]	; (800ca48 <atcm_get_PDPtypeStr+0x38>)
 800ca1a:	e004      	b.n	800ca26 <atcm_get_PDPtypeStr+0x16>
    if (pdp_type == ACTM_PDP_TYPE_LUT[i].pdp_type)
    {
      retval = ((const AT_CHAR_t *)(&ACTM_PDP_TYPE_LUT[i].pdp_type_string));
      leave_loop = true;
    }
    i++;
 800ca1c:	3301      	adds	r3, #1
 800ca1e:	b29b      	uxth	r3, r3
  } while ((leave_loop == false) && (i < max_array_size));
 800ca20:	b974      	cbnz	r4, 800ca40 <atcm_get_PDPtypeStr+0x30>
 800ca22:	2b03      	cmp	r3, #3
 800ca24:	d80c      	bhi.n	800ca40 <atcm_get_PDPtypeStr+0x30>
    if (pdp_type == ACTM_PDP_TYPE_LUT[i].pdp_type)
 800ca26:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800ca2a:	4908      	ldr	r1, [pc, #32]	; (800ca4c <atcm_get_PDPtypeStr+0x3c>)
 800ca2c:	5c8a      	ldrb	r2, [r1, r2]
 800ca2e:	4562      	cmp	r2, ip
 800ca30:	d1f4      	bne.n	800ca1c <atcm_get_PDPtypeStr+0xc>
      retval = ((const AT_CHAR_t *)(&ACTM_PDP_TYPE_LUT[i].pdp_type_string));
 800ca32:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 800ca36:	4a05      	ldr	r2, [pc, #20]	; (800ca4c <atcm_get_PDPtypeStr+0x3c>)
 800ca38:	440a      	add	r2, r1
 800ca3a:	1c50      	adds	r0, r2, #1
      leave_loop = true;
 800ca3c:	2401      	movs	r4, #1
 800ca3e:	e7ed      	b.n	800ca1c <atcm_get_PDPtypeStr+0xc>

  /* string no found, return empty string */
  return (retval);
}
 800ca40:	f85d 4b04 	ldr.w	r4, [sp], #4
 800ca44:	4770      	bx	lr
 800ca46:	bf00      	nop
 800ca48:	08035c54 	.word	0x08035c54
 800ca4c:	0802ee74 	.word	0x0802ee74

0800ca50 <atcm_program_AT_CMD>:
void atcm_program_AT_CMD(atcustom_modem_context_t *p_modem_ctxt,
                         atparser_context_t *p_atp_ctxt,
                         at_type_t cmd_type,
                         uint32_t cmd_id,
                         atcustom_FinalCmd_t final)
{
 800ca50:	b510      	push	{r4, lr}
 800ca52:	460c      	mov	r4, r1
 800ca54:	4619      	mov	r1, r3
 800ca56:	f89d 3008 	ldrb.w	r3, [sp, #8]
  /* command type */
  p_atp_ctxt->current_atcmd.type = cmd_type;
 800ca5a:	8122      	strh	r2, [r4, #8]
  /* command id */
  p_atp_ctxt->current_atcmd.id = cmd_id;
 800ca5c:	60e1      	str	r1, [r4, #12]
  /* is it final command ? */
  p_atp_ctxt->is_final_cmd = (final == FINAL_CMD) ? 1U : 0U;
 800ca5e:	2b01      	cmp	r3, #1
 800ca60:	d000      	beq.n	800ca64 <atcm_program_AT_CMD+0x14>
 800ca62:	2300      	movs	r3, #0
 800ca64:	7123      	strb	r3, [r4, #4]
  /* an answer is expected */
  p_atp_ctxt->answer_expected = CMD_MANDATORY_ANSWER_EXPECTED;
 800ca66:	2300      	movs	r3, #0
 800ca68:	70e3      	strb	r3, [r4, #3]

  /* set command timeout according to LUT */
  p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800ca6a:	f7ff ff6b 	bl	800c944 <atcm_get_CmdTimeout>
 800ca6e:	f8c4 0678 	str.w	r0, [r4, #1656]	; 0x678
}
 800ca72:	bd10      	pop	{r4, pc}

0800ca74 <atcm_program_AT_CMD_ANSWER_OPTIONAL>:
void atcm_program_AT_CMD_ANSWER_OPTIONAL(atcustom_modem_context_t *p_modem_ctxt,
                                         atparser_context_t *p_atp_ctxt,
                                         at_type_t cmd_type,
                                         uint32_t cmd_id,
                                         atcustom_FinalCmd_t final)
{
 800ca74:	b510      	push	{r4, lr}
 800ca76:	460c      	mov	r4, r1
 800ca78:	4619      	mov	r1, r3
 800ca7a:	f89d 3008 	ldrb.w	r3, [sp, #8]
  /* command type */
  p_atp_ctxt->current_atcmd.type = cmd_type;
 800ca7e:	8122      	strh	r2, [r4, #8]
  /* command id */
  p_atp_ctxt->current_atcmd.id = cmd_id;
 800ca80:	60e1      	str	r1, [r4, #12]
  /* is it final command ? */
  p_atp_ctxt->is_final_cmd = (final == FINAL_CMD) ? 1U : 0U;
 800ca82:	2b01      	cmp	r3, #1
 800ca84:	d000      	beq.n	800ca88 <atcm_program_AT_CMD_ANSWER_OPTIONAL+0x14>
 800ca86:	2300      	movs	r3, #0
 800ca88:	7123      	strb	r3, [r4, #4]
  /* an answer is expected */
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800ca8a:	2301      	movs	r3, #1
 800ca8c:	70e3      	strb	r3, [r4, #3]

  /* set command timeout according to LUT */
  p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800ca8e:	f7ff ff59 	bl	800c944 <atcm_get_CmdTimeout>
 800ca92:	f8c4 0678 	str.w	r0, [r4, #1656]	; 0x678
}
 800ca96:	bd10      	pop	{r4, pc}

0800ca98 <atcm_program_CMD_TIMEOUT>:
  * @retval none
  */
void atcm_program_CMD_TIMEOUT(atcustom_modem_context_t *p_modem_ctxt,
                              atparser_context_t *p_atp_ctxt,
                              uint32_t new_timeout)
{
 800ca98:	b510      	push	{r4, lr}
 800ca9a:	460c      	mov	r4, r1
  if (new_timeout == 0U)
 800ca9c:	b112      	cbz	r2, 800caa4 <atcm_program_CMD_TIMEOUT+0xc>
    /* set command timeout according to LUT */
    p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
  }
  else
  {
    p_atp_ctxt->cmd_timeout = new_timeout;
 800ca9e:	f8c4 2678 	str.w	r2, [r4, #1656]	; 0x678
  }
}
 800caa2:	bd10      	pop	{r4, pc}
    p_atp_ctxt->cmd_timeout =  atcm_get_CmdTimeout(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800caa4:	68c9      	ldr	r1, [r1, #12]
 800caa6:	f7ff ff4d 	bl	800c944 <atcm_get_CmdTimeout>
 800caaa:	f8c4 0678 	str.w	r0, [r4, #1656]	; 0x678
 800caae:	e7f8      	b.n	800caa2 <atcm_program_CMD_TIMEOUT+0xa>

0800cab0 <atcm_program_TEMPO>:
  * @param  tempo_value
  * @param  final
  * @retval none
  */
void atcm_program_TEMPO(atparser_context_t *p_atp_ctxt, uint32_t tempo_value, atcustom_FinalCmd_t final)
{
 800cab0:	b538      	push	{r3, r4, r5, lr}
  p_atp_ctxt->current_atcmd.type = ATTYPE_NO_CMD;
 800cab2:	2305      	movs	r3, #5
 800cab4:	8103      	strh	r3, [r0, #8]
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 800cab6:	f04f 33ff 	mov.w	r3, #4294967295
 800caba:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->is_final_cmd = (final == FINAL_CMD) ? 1U : 0U;
 800cabc:	2a01      	cmp	r2, #1
 800cabe:	d000      	beq.n	800cac2 <atcm_program_TEMPO+0x12>
 800cac0:	2200      	movs	r2, #0
 800cac2:	7102      	strb	r2, [r0, #4]
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800cac4:	2501      	movs	r5, #1
 800cac6:	70c5      	strb	r5, [r0, #3]
  p_atp_ctxt->cmd_timeout = tempo_value;
 800cac8:	f8c0 1678 	str.w	r1, [r0, #1656]	; 0x678

  PRINT_INFO("Tempo started (%ld ms)...", tempo_value)
 800cacc:	4c0c      	ldr	r4, [pc, #48]	; (800cb00 <atcm_program_TEMPO+0x50>)
 800cace:	460a      	mov	r2, r1
 800cad0:	490c      	ldr	r1, [pc, #48]	; (800cb04 <atcm_program_TEMPO+0x54>)
 800cad2:	4620      	mov	r0, r4
 800cad4:	f019 feb8 	bl	8026848 <sprintf>
 800cad8:	4620      	mov	r0, r4
 800cada:	f012 fc26 	bl	801f32a <crs_strlen>
 800cade:	b283      	uxth	r3, r0
 800cae0:	4622      	mov	r2, r4
 800cae2:	4629      	mov	r1, r5
 800cae4:	2002      	movs	r0, #2
 800cae6:	f012 fc63 	bl	801f3b0 <traceIF_itmPrint>
 800caea:	4620      	mov	r0, r4
 800caec:	f012 fc1d 	bl	801f32a <crs_strlen>
 800caf0:	b283      	uxth	r3, r0
 800caf2:	4622      	mov	r2, r4
 800caf4:	4629      	mov	r1, r5
 800caf6:	2002      	movs	r0, #2
 800caf8:	f012 fc7c 	bl	801f3f4 <traceIF_uartPrint>
}
 800cafc:	bd38      	pop	{r3, r4, r5, pc}
 800cafe:	bf00      	nop
 800cb00:	200048dc 	.word	0x200048dc
 800cb04:	0802e89c 	.word	0x0802e89c

0800cb08 <atcm_program_NO_MORE_CMD>:
  * @param  p_atp_ctxt
  * @retval none
  */
void atcm_program_NO_MORE_CMD(atparser_context_t *p_atp_ctxt)
{
  p_atp_ctxt->current_atcmd.type = ATTYPE_NO_CMD;
 800cb08:	2305      	movs	r3, #5
 800cb0a:	8103      	strh	r3, [r0, #8]
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 800cb0c:	f04f 33ff 	mov.w	r3, #4294967295
 800cb10:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->is_final_cmd = 1U;
 800cb12:	2301      	movs	r3, #1
 800cb14:	7103      	strb	r3, [r0, #4]
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800cb16:	70c3      	strb	r3, [r0, #3]
  p_atp_ctxt->cmd_timeout = 0U;
 800cb18:	2300      	movs	r3, #0
 800cb1a:	f8c0 3678 	str.w	r3, [r0, #1656]	; 0x678
}
 800cb1e:	4770      	bx	lr

0800cb20 <atcm_program_SKIP_CMD>:
  * @param  p_atp_ctxt
  * @retval none
  */
void atcm_program_SKIP_CMD(atparser_context_t *p_atp_ctxt)
{
  p_atp_ctxt->current_atcmd.type = ATTYPE_NO_CMD;
 800cb20:	2305      	movs	r3, #5
 800cb22:	8103      	strh	r3, [r0, #8]
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 800cb24:	f04f 33ff 	mov.w	r3, #4294967295
 800cb28:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->is_final_cmd = 0U;
 800cb2a:	2300      	movs	r3, #0
 800cb2c:	7103      	strb	r3, [r0, #4]
  p_atp_ctxt->answer_expected = CMD_OPTIONAL_ANSWER_EXPECTED;
 800cb2e:	2201      	movs	r2, #1
 800cb30:	70c2      	strb	r2, [r0, #3]
  p_atp_ctxt->cmd_timeout = 0U;
 800cb32:	f8c0 3678 	str.w	r3, [r0, #1656]	; 0x678
}
 800cb36:	4770      	bx	lr

0800cb38 <atcm_modem_build_cmd>:
  * @retval at_status_t
  */
at_status_t atcm_modem_build_cmd(atcustom_modem_context_t *p_modem_ctxt,
                                 atparser_context_t *p_atp_ctxt,
                                 uint32_t *p_ATcmdTimeout)
{
 800cb38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cb3c:	b083      	sub	sp, #12
 800cb3e:	4607      	mov	r7, r0
 800cb40:	460c      	mov	r4, r1
 800cb42:	4690      	mov	r8, r2
  at_status_t retval = ATSTATUS_OK;

  /* 1- set the commande name (get it from LUT) */
  const AT_CHAR_t *p_cmd_name_string = atcm_get_CmdStr(p_modem_ctxt, p_atp_ctxt->current_atcmd.id);
 800cb44:	68c9      	ldr	r1, [r1, #12]
 800cb46:	f7ff fedb 	bl	800c900 <atcm_get_CmdStr>
 800cb4a:	4605      	mov	r5, r0
  uint8_t string_length = (uint8_t) strlen((const CRC_CHAR_t *) p_cmd_name_string);
 800cb4c:	f7f3 fb52 	bl	80001f4 <strlen>
  (void) memcpy((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.name,
 800cb50:	f104 0910 	add.w	r9, r4, #16
 800cb54:	b2c6      	uxtb	r6, r0
 800cb56:	4632      	mov	r2, r6
 800cb58:	4629      	mov	r1, r5
 800cb5a:	4648      	mov	r0, r9
 800cb5c:	f019 ffc4 	bl	8026ae8 <memcpy>
                p_cmd_name_string,
                string_length);

  PRINT_DBG("<modem custom> build the cmd %s (type=%d, length=%d)",
 800cb60:	4d32      	ldr	r5, [pc, #200]	; (800cc2c <atcm_modem_build_cmd+0xf4>)
 800cb62:	9600      	str	r6, [sp, #0]
 800cb64:	8923      	ldrh	r3, [r4, #8]
 800cb66:	464a      	mov	r2, r9
 800cb68:	4931      	ldr	r1, [pc, #196]	; (800cc30 <atcm_modem_build_cmd+0xf8>)
 800cb6a:	4628      	mov	r0, r5
 800cb6c:	f019 fe6c 	bl	8026848 <sprintf>
 800cb70:	4628      	mov	r0, r5
 800cb72:	f012 fbda 	bl	801f32a <crs_strlen>
 800cb76:	b283      	uxth	r3, r0
 800cb78:	462a      	mov	r2, r5
 800cb7a:	2102      	movs	r1, #2
 800cb7c:	4608      	mov	r0, r1
 800cb7e:	f012 fc17 	bl	801f3b0 <traceIF_itmPrint>
 800cb82:	4628      	mov	r0, r5
 800cb84:	f012 fbd1 	bl	801f32a <crs_strlen>
 800cb88:	b283      	uxth	r3, r0
 800cb8a:	462a      	mov	r2, r5
 800cb8c:	2102      	movs	r1, #2
 800cb8e:	4608      	mov	r0, r1
 800cb90:	f012 fc30 	bl	801f3f4 <traceIF_uartPrint>
            p_atp_ctxt->current_atcmd.name,
            p_atp_ctxt->current_atcmd.type,
            string_length)

  /* 2- set the command parameters (only for write or execution commands or for data) */
  if ((p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD) ||
 800cb94:	8922      	ldrh	r2, [r4, #8]
 800cb96:	1ed3      	subs	r3, r2, #3
 800cb98:	b29b      	uxth	r3, r3
 800cb9a:	2b01      	cmp	r3, #1
 800cb9c:	d903      	bls.n	800cba6 <atcm_modem_build_cmd+0x6e>
      (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD) ||
 800cb9e:	2a06      	cmp	r2, #6
 800cba0:	d001      	beq.n	800cba6 <atcm_modem_build_cmd+0x6e>
  at_status_t retval = ATSTATUS_OK;
 800cba2:	2600      	movs	r6, #0
 800cba4:	e008      	b.n	800cbb8 <atcm_modem_build_cmd+0x80>
      (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD))
  {
    retval = (atcm_get_CmdBuildFunc(p_modem_ctxt, p_atp_ctxt->current_atcmd.id))(p_atp_ctxt, p_modem_ctxt);
 800cba6:	68e1      	ldr	r1, [r4, #12]
 800cba8:	4638      	mov	r0, r7
 800cbaa:	f7ff feed 	bl	800c988 <atcm_get_CmdBuildFunc>
 800cbae:	4603      	mov	r3, r0
 800cbb0:	4639      	mov	r1, r7
 800cbb2:	4620      	mov	r0, r4
 800cbb4:	4798      	blx	r3
 800cbb6:	4606      	mov	r6, r0
  }

  /* 3- set command timeout (has been set in command programmation) */
  *p_ATcmdTimeout = p_atp_ctxt->cmd_timeout;
 800cbb8:	f8d4 2678 	ldr.w	r2, [r4, #1656]	; 0x678
 800cbbc:	f8c8 2000 	str.w	r2, [r8]
  PRINT_DBG("==== CMD TIMEOUT = %ld ====", *p_ATcmdTimeout)
 800cbc0:	4d1a      	ldr	r5, [pc, #104]	; (800cc2c <atcm_modem_build_cmd+0xf4>)
 800cbc2:	491c      	ldr	r1, [pc, #112]	; (800cc34 <atcm_modem_build_cmd+0xfc>)
 800cbc4:	4628      	mov	r0, r5
 800cbc6:	f019 fe3f 	bl	8026848 <sprintf>
 800cbca:	4628      	mov	r0, r5
 800cbcc:	f012 fbad 	bl	801f32a <crs_strlen>
 800cbd0:	b283      	uxth	r3, r0
 800cbd2:	462a      	mov	r2, r5
 800cbd4:	2102      	movs	r1, #2
 800cbd6:	4608      	mov	r0, r1
 800cbd8:	f012 fbea 	bl	801f3b0 <traceIF_itmPrint>
 800cbdc:	4628      	mov	r0, r5
 800cbde:	f012 fba4 	bl	801f32a <crs_strlen>
 800cbe2:	b283      	uxth	r3, r0
 800cbe4:	462a      	mov	r2, r5
 800cbe6:	2102      	movs	r1, #2
 800cbe8:	4608      	mov	r0, r1
 800cbea:	f012 fc03 	bl	801f3f4 <traceIF_uartPrint>

  /* increment step in SID treatment */
  p_atp_ctxt->step++;
 800cbee:	78a3      	ldrb	r3, [r4, #2]
 800cbf0:	3301      	adds	r3, #1
 800cbf2:	70a3      	strb	r3, [r4, #2]

  PRINT_DBG("atcm_modem_build_cmd returned status = %d", retval)
 800cbf4:	4632      	mov	r2, r6
 800cbf6:	4910      	ldr	r1, [pc, #64]	; (800cc38 <atcm_modem_build_cmd+0x100>)
 800cbf8:	4628      	mov	r0, r5
 800cbfa:	f019 fe25 	bl	8026848 <sprintf>
 800cbfe:	4628      	mov	r0, r5
 800cc00:	f012 fb93 	bl	801f32a <crs_strlen>
 800cc04:	b283      	uxth	r3, r0
 800cc06:	462a      	mov	r2, r5
 800cc08:	2102      	movs	r1, #2
 800cc0a:	4608      	mov	r0, r1
 800cc0c:	f012 fbd0 	bl	801f3b0 <traceIF_itmPrint>
 800cc10:	4628      	mov	r0, r5
 800cc12:	f012 fb8a 	bl	801f32a <crs_strlen>
 800cc16:	b283      	uxth	r3, r0
 800cc18:	462a      	mov	r2, r5
 800cc1a:	2102      	movs	r1, #2
 800cc1c:	4608      	mov	r0, r1
 800cc1e:	f012 fbe9 	bl	801f3f4 <traceIF_uartPrint>
  return (retval);
}
 800cc22:	4630      	mov	r0, r6
 800cc24:	b003      	add	sp, #12
 800cc26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800cc2a:	bf00      	nop
 800cc2c:	200048dc 	.word	0x200048dc
 800cc30:	0802e8c4 	.word	0x0802e8c4
 800cc34:	0802e904 	.word	0x0802e904
 800cc38:	0802e92c 	.word	0x0802e92c

0800cc3c <atcm_modem_get_rsp>:
  * @retval at_status_t
  */
at_status_t atcm_modem_get_rsp(atcustom_modem_context_t *p_modem_ctxt,
                               const atparser_context_t *p_atp_ctxt,
                               at_buf_t *p_rsp_buf)
{
 800cc3c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800cc3e:	b093      	sub	sp, #76	; 0x4c
 800cc40:	4604      	mov	r4, r0
 800cc42:	4615      	mov	r5, r2

  /* prepare response for a SID
  *  all common behaviors for SID which are returning data in rsp_buf have to be implemented here
  */

  switch (p_atp_ctxt->current_SID)
 800cc44:	880b      	ldrh	r3, [r1, #0]
 800cc46:	3b69      	subs	r3, #105	; 0x69
 800cc48:	2b1f      	cmp	r3, #31
 800cc4a:	f200 8192 	bhi.w	800cf72 <atcm_modem_get_rsp+0x336>
 800cc4e:	e8df f013 	tbh	[pc, r3, lsl #1]
 800cc52:	00ce      	.short	0x00ce
 800cc54:	01900190 	.word	0x01900190
 800cc58:	002000ce 	.word	0x002000ce
 800cc5c:	01900190 	.word	0x01900190
 800cc60:	01900190 	.word	0x01900190
 800cc64:	01900190 	.word	0x01900190
 800cc68:	01090190 	.word	0x01090190
 800cc6c:	01900190 	.word	0x01900190
 800cc70:	01900190 	.word	0x01900190
 800cc74:	00510190 	.word	0x00510190
 800cc78:	01900082 	.word	0x01900082
 800cc7c:	01900190 	.word	0x01900190
 800cc80:	01900190 	.word	0x01900190
 800cc84:	01900190 	.word	0x01900190
 800cc88:	01900190 	.word	0x01900190
 800cc8c:	01900190 	.word	0x01900190
 800cc90:	0160      	.short	0x0160
  {
    case SID_CS_GET_ATTACHSTATUS:
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800cc92:	f200 6365 	addw	r3, r0, #1637	; 0x665
 800cc96:	2201      	movs	r2, #1
 800cc98:	2113      	movs	r1, #19
 800cc9a:	4628      	mov	r0, r5
 800cc9c:	f7ff fa0a 	bl	800c0b4 <DATAPACK_writeStruct>
 800cca0:	2800      	cmp	r0, #0
 800cca2:	f000 8167 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_ATTACHSTATUS,
                               (uint16_t) sizeof(CS_PSattach_t),
                               (void *)&p_modem_ctxt->SID_ctxt.attach_status) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800cca6:	4eb4      	ldr	r6, [pc, #720]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800cca8:	4cb4      	ldr	r4, [pc, #720]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ccaa:	f106 0720 	add.w	r7, r6, #32
 800ccae:	4635      	mov	r5, r6
 800ccb0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ccb2:	6020      	str	r0, [r4, #0]
 800ccb4:	6061      	str	r1, [r4, #4]
 800ccb6:	60a2      	str	r2, [r4, #8]
 800ccb8:	60e3      	str	r3, [r4, #12]
 800ccba:	462e      	mov	r6, r5
 800ccbc:	3410      	adds	r4, #16
 800ccbe:	42bd      	cmp	r5, r7
 800ccc0:	d1f5      	bne.n	800ccae <atcm_modem_get_rsp+0x72>
 800ccc2:	6828      	ldr	r0, [r5, #0]
 800ccc4:	6020      	str	r0, [r4, #0]
 800ccc6:	792b      	ldrb	r3, [r5, #4]
 800ccc8:	7123      	strb	r3, [r4, #4]
 800ccca:	4cac      	ldr	r4, [pc, #688]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cccc:	4620      	mov	r0, r4
 800ccce:	f012 fb2c 	bl	801f32a <crs_strlen>
 800ccd2:	b283      	uxth	r3, r0
 800ccd4:	4622      	mov	r2, r4
 800ccd6:	2110      	movs	r1, #16
 800ccd8:	2002      	movs	r0, #2
 800ccda:	f012 fb69 	bl	801f3b0 <traceIF_itmPrint>
 800ccde:	4620      	mov	r0, r4
 800cce0:	f012 fb23 	bl	801f32a <crs_strlen>
 800cce4:	b283      	uxth	r3, r0
 800cce6:	4622      	mov	r2, r4
 800cce8:	2110      	movs	r1, #16
 800ccea:	2002      	movs	r0, #2
 800ccec:	f012 fb82 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800ccf0:	2001      	movs	r0, #1
 800ccf2:	e13f      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
      }
      break;

    case SID_CS_RECEIVE_DATA:
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800ccf4:	f500 63ea 	add.w	r3, r0, #1872	; 0x750
 800ccf8:	2204      	movs	r2, #4
 800ccfa:	211a      	movs	r1, #26
 800ccfc:	4628      	mov	r0, r5
 800ccfe:	f7ff f9d9 	bl	800c0b4 <DATAPACK_writeStruct>
 800cd02:	2800      	cmp	r0, #0
 800cd04:	f000 8136 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_SOCKET_RXDATA,
                               (uint16_t) sizeof(uint32_t),
                               (void *)&p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800cd08:	4e9b      	ldr	r6, [pc, #620]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800cd0a:	4c9c      	ldr	r4, [pc, #624]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cd0c:	f106 0720 	add.w	r7, r6, #32
 800cd10:	4635      	mov	r5, r6
 800cd12:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800cd14:	6020      	str	r0, [r4, #0]
 800cd16:	6061      	str	r1, [r4, #4]
 800cd18:	60a2      	str	r2, [r4, #8]
 800cd1a:	60e3      	str	r3, [r4, #12]
 800cd1c:	462e      	mov	r6, r5
 800cd1e:	3410      	adds	r4, #16
 800cd20:	42bd      	cmp	r5, r7
 800cd22:	d1f5      	bne.n	800cd10 <atcm_modem_get_rsp+0xd4>
 800cd24:	6828      	ldr	r0, [r5, #0]
 800cd26:	6020      	str	r0, [r4, #0]
 800cd28:	792b      	ldrb	r3, [r5, #4]
 800cd2a:	7123      	strb	r3, [r4, #4]
 800cd2c:	4c93      	ldr	r4, [pc, #588]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cd2e:	4620      	mov	r0, r4
 800cd30:	f012 fafb 	bl	801f32a <crs_strlen>
 800cd34:	b283      	uxth	r3, r0
 800cd36:	4622      	mov	r2, r4
 800cd38:	2110      	movs	r1, #16
 800cd3a:	2002      	movs	r0, #2
 800cd3c:	f012 fb38 	bl	801f3b0 <traceIF_itmPrint>
 800cd40:	4620      	mov	r0, r4
 800cd42:	f012 faf2 	bl	801f32a <crs_strlen>
 800cd46:	b283      	uxth	r3, r0
 800cd48:	4622      	mov	r2, r4
 800cd4a:	2110      	movs	r1, #16
 800cd4c:	2002      	movs	r0, #2
 800cd4e:	f012 fb51 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cd52:	2001      	movs	r0, #1
 800cd54:	e10e      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
      break;

    case SID_CS_RECEIVE_DATA_FROM:
    {
      csint_socket_rxdata_from_t  rxdata_from;
      (void) memset((void *)&rxdata_from, 0, sizeof(csint_socket_rxdata_from_t));
 800cd56:	2648      	movs	r6, #72	; 0x48
 800cd58:	4632      	mov	r2, r6
 800cd5a:	2100      	movs	r1, #0
 800cd5c:	4668      	mov	r0, sp
 800cd5e:	f019 fde6 	bl	802692e <memset>
      /* recopy info received */
      rxdata_from.bytes_received = p_modem_ctxt->socket_ctxt.socketReceivedata.buffer_size;
 800cd62:	f8d4 3750 	ldr.w	r3, [r4, #1872]	; 0x750
 800cd66:	9300      	str	r3, [sp, #0]
      (void) memcpy((void *)&rxdata_from.ip_addr_value,
                    (void *)p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value,
 800cd68:	f204 7759 	addw	r7, r4, #1881	; 0x759
      (void) memcpy((void *)&rxdata_from.ip_addr_value,
 800cd6c:	4638      	mov	r0, r7
 800cd6e:	f7f3 fa41 	bl	80001f4 <strlen>
 800cd72:	4602      	mov	r2, r0
 800cd74:	4639      	mov	r1, r7
 800cd76:	f10d 0005 	add.w	r0, sp, #5
 800cd7a:	f019 feb5 	bl	8026ae8 <memcpy>
                    strlen((CRC_CHAR_t *)p_modem_ctxt->socket_ctxt.socketReceivedata.ip_addr_value));
      rxdata_from.remote_port = p_modem_ctxt->socket_ctxt.socketReceivedata.remote_port;
 800cd7e:	f8b4 379a 	ldrh.w	r3, [r4, #1946]	; 0x79a
 800cd82:	f8ad 3046 	strh.w	r3, [sp, #70]	; 0x46
      if (DATAPACK_writeStruct(p_rsp_buf,
 800cd86:	466b      	mov	r3, sp
 800cd88:	4632      	mov	r2, r6
 800cd8a:	211b      	movs	r1, #27
 800cd8c:	4628      	mov	r0, r5
 800cd8e:	f7ff f991 	bl	800c0b4 <DATAPACK_writeStruct>
 800cd92:	2800      	cmp	r0, #0
 800cd94:	f000 80ee 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_SOCKET_RXDATA_FROM,
                               (uint16_t) sizeof(csint_socket_rxdata_from_t),
                               (void *)&rxdata_from) != DATAPACK_OK)
      {
        PRINT_ERR("Receive data from problem")
 800cd98:	4d79      	ldr	r5, [pc, #484]	; (800cf80 <atcm_modem_get_rsp+0x344>)
 800cd9a:	4c78      	ldr	r4, [pc, #480]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cd9c:	f105 0620 	add.w	r6, r5, #32
 800cda0:	46ac      	mov	ip, r5
 800cda2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cda6:	6020      	str	r0, [r4, #0]
 800cda8:	6061      	str	r1, [r4, #4]
 800cdaa:	60a2      	str	r2, [r4, #8]
 800cdac:	60e3      	str	r3, [r4, #12]
 800cdae:	4665      	mov	r5, ip
 800cdb0:	3410      	adds	r4, #16
 800cdb2:	45b4      	cmp	ip, r6
 800cdb4:	d1f4      	bne.n	800cda0 <atcm_modem_get_rsp+0x164>
 800cdb6:	cd03      	ldmia	r5!, {r0, r1}
 800cdb8:	6020      	str	r0, [r4, #0]
 800cdba:	6061      	str	r1, [r4, #4]
 800cdbc:	882a      	ldrh	r2, [r5, #0]
 800cdbe:	78ab      	ldrb	r3, [r5, #2]
 800cdc0:	8122      	strh	r2, [r4, #8]
 800cdc2:	72a3      	strb	r3, [r4, #10]
 800cdc4:	4c6d      	ldr	r4, [pc, #436]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cdc6:	4620      	mov	r0, r4
 800cdc8:	f012 faaf 	bl	801f32a <crs_strlen>
 800cdcc:	b283      	uxth	r3, r0
 800cdce:	4622      	mov	r2, r4
 800cdd0:	2110      	movs	r1, #16
 800cdd2:	2002      	movs	r0, #2
 800cdd4:	f012 faec 	bl	801f3b0 <traceIF_itmPrint>
 800cdd8:	4620      	mov	r0, r4
 800cdda:	f012 faa6 	bl	801f32a <crs_strlen>
 800cdde:	b283      	uxth	r3, r0
 800cde0:	4622      	mov	r2, r4
 800cde2:	2110      	movs	r1, #16
 800cde4:	2002      	movs	r0, #2
 800cde6:	f012 fb05 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cdea:	2001      	movs	r0, #1
      }
      break;
 800cdec:	e0c2      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
    }

    case SID_CS_REGISTER_NET:
    case SID_CS_GET_NETSTATUS:
      /* Add EPS, GPRS and CS registration states (from CREG, CGREG, CEREG commands) */
      p_modem_ctxt->SID_ctxt.read_operator_infos.EPS_NetworkRegState = p_modem_ctxt->persist.eps_network_state;
 800cdee:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 800cdf0:	f8a0 3612 	strh.w	r3, [r0, #1554]	; 0x612
      p_modem_ctxt->SID_ctxt.read_operator_infos.GPRS_NetworkRegState = p_modem_ctxt->persist.gprs_network_state;
 800cdf4:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
 800cdf6:	f8a0 3614 	strh.w	r3, [r0, #1556]	; 0x614
      p_modem_ctxt->SID_ctxt.read_operator_infos.CS_NetworkRegState = p_modem_ctxt->persist.cs_network_state;
 800cdfa:	f8b0 3048 	ldrh.w	r3, [r0, #72]	; 0x48
 800cdfe:	f8a0 3616 	strh.w	r3, [r0, #1558]	; 0x616
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800ce02:	f500 63c2 	add.w	r3, r0, #1552	; 0x610
 800ce06:	224e      	movs	r2, #78	; 0x4e
 800ce08:	2115      	movs	r1, #21
 800ce0a:	4628      	mov	r0, r5
 800ce0c:	f7ff f952 	bl	800c0b4 <DATAPACK_writeStruct>
 800ce10:	2800      	cmp	r0, #0
 800ce12:	f000 80af 	beq.w	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_REGISTRATIONSTATUS,
                               (uint16_t) sizeof(CS_RegistrationStatus_t),
                               (void *)&p_modem_ctxt->SID_ctxt.read_operator_infos) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800ce16:	4e58      	ldr	r6, [pc, #352]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800ce18:	4c58      	ldr	r4, [pc, #352]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ce1a:	f106 0720 	add.w	r7, r6, #32
 800ce1e:	4635      	mov	r5, r6
 800ce20:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ce22:	6020      	str	r0, [r4, #0]
 800ce24:	6061      	str	r1, [r4, #4]
 800ce26:	60a2      	str	r2, [r4, #8]
 800ce28:	60e3      	str	r3, [r4, #12]
 800ce2a:	462e      	mov	r6, r5
 800ce2c:	3410      	adds	r4, #16
 800ce2e:	42bd      	cmp	r5, r7
 800ce30:	d1f5      	bne.n	800ce1e <atcm_modem_get_rsp+0x1e2>
 800ce32:	6828      	ldr	r0, [r5, #0]
 800ce34:	6020      	str	r0, [r4, #0]
 800ce36:	792b      	ldrb	r3, [r5, #4]
 800ce38:	7123      	strb	r3, [r4, #4]
 800ce3a:	4c50      	ldr	r4, [pc, #320]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ce3c:	4620      	mov	r0, r4
 800ce3e:	f012 fa74 	bl	801f32a <crs_strlen>
 800ce42:	b283      	uxth	r3, r0
 800ce44:	4622      	mov	r2, r4
 800ce46:	2110      	movs	r1, #16
 800ce48:	2002      	movs	r0, #2
 800ce4a:	f012 fab1 	bl	801f3b0 <traceIF_itmPrint>
 800ce4e:	4620      	mov	r0, r4
 800ce50:	f012 fa6b 	bl	801f32a <crs_strlen>
 800ce54:	b283      	uxth	r3, r0
 800ce56:	4622      	mov	r2, r4
 800ce58:	2110      	movs	r1, #16
 800ce5a:	2002      	movs	r0, #2
 800ce5c:	f012 faca 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800ce60:	2001      	movs	r0, #1
 800ce62:	e087      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
      }
      break;

    case SID_CS_GET_IP_ADDRESS:
    {
      CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800ce64:	f7ff fd26 	bl	800c8b4 <atcm_get_cid_current_SID>
 800ce68:	4606      	mov	r6, r0
      csint_ip_addr_info_t ip_addr_info;
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 800ce6a:	2741      	movs	r7, #65	; 0x41
 800ce6c:	463a      	mov	r2, r7
 800ce6e:	2100      	movs	r1, #0
 800ce70:	4668      	mov	r0, sp
 800ce72:	f019 fd5c 	bl	802692e <memset>
      /* retrieve IP infos for request config_id */
      atcm_get_IP_address_infos(&p_modem_ctxt->persist, current_conf_id, &ip_addr_info);
 800ce76:	466a      	mov	r2, sp
 800ce78:	4631      	mov	r1, r6
 800ce7a:	f104 000c 	add.w	r0, r4, #12
 800ce7e:	f7ff fcaa 	bl	800c7d6 <atcm_get_IP_address_infos>
      PRINT_DBG("retrieve IP address for cid %d = %s", current_conf_id, ip_addr_info.ip_addr_value)
 800ce82:	4c3e      	ldr	r4, [pc, #248]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ce84:	f10d 0301 	add.w	r3, sp, #1
 800ce88:	4632      	mov	r2, r6
 800ce8a:	493e      	ldr	r1, [pc, #248]	; (800cf84 <atcm_modem_get_rsp+0x348>)
 800ce8c:	4620      	mov	r0, r4
 800ce8e:	f019 fcdb 	bl	8026848 <sprintf>
 800ce92:	4620      	mov	r0, r4
 800ce94:	f012 fa49 	bl	801f32a <crs_strlen>
 800ce98:	b283      	uxth	r3, r0
 800ce9a:	4622      	mov	r2, r4
 800ce9c:	2102      	movs	r1, #2
 800ce9e:	4608      	mov	r0, r1
 800cea0:	f012 fa86 	bl	801f3b0 <traceIF_itmPrint>
 800cea4:	4620      	mov	r0, r4
 800cea6:	f012 fa40 	bl	801f32a <crs_strlen>
 800ceaa:	b283      	uxth	r3, r0
 800ceac:	4622      	mov	r2, r4
 800ceae:	2102      	movs	r1, #2
 800ceb0:	4608      	mov	r0, r1
 800ceb2:	f012 fa9f 	bl	801f3f4 <traceIF_uartPrint>
      /* PACK data to response buffer */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800ceb6:	466b      	mov	r3, sp
 800ceb8:	463a      	mov	r2, r7
 800ceba:	2125      	movs	r1, #37	; 0x25
 800cebc:	4628      	mov	r0, r5
 800cebe:	f7ff f8f9 	bl	800c0b4 <DATAPACK_writeStruct>
 800cec2:	2800      	cmp	r0, #0
 800cec4:	d056      	beq.n	800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_GET_IP_ADDRESS,
                               (uint16_t) sizeof(csint_ip_addr_info_t),
                               (void *)&ip_addr_info) != DATAPACK_OK)
      {
        PRINT_ERR("Buffer size problem")
 800cec6:	4e2c      	ldr	r6, [pc, #176]	; (800cf78 <atcm_modem_get_rsp+0x33c>)
 800cec8:	f106 0720 	add.w	r7, r6, #32
 800cecc:	4635      	mov	r5, r6
 800cece:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800ced0:	6020      	str	r0, [r4, #0]
 800ced2:	6061      	str	r1, [r4, #4]
 800ced4:	60a2      	str	r2, [r4, #8]
 800ced6:	60e3      	str	r3, [r4, #12]
 800ced8:	462e      	mov	r6, r5
 800ceda:	3410      	adds	r4, #16
 800cedc:	42bd      	cmp	r5, r7
 800cede:	d1f5      	bne.n	800cecc <atcm_modem_get_rsp+0x290>
 800cee0:	6828      	ldr	r0, [r5, #0]
 800cee2:	6020      	str	r0, [r4, #0]
 800cee4:	792b      	ldrb	r3, [r5, #4]
 800cee6:	7123      	strb	r3, [r4, #4]
 800cee8:	4c24      	ldr	r4, [pc, #144]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800ceea:	4620      	mov	r0, r4
 800ceec:	f012 fa1d 	bl	801f32a <crs_strlen>
 800cef0:	b283      	uxth	r3, r0
 800cef2:	4622      	mov	r2, r4
 800cef4:	2110      	movs	r1, #16
 800cef6:	2002      	movs	r0, #2
 800cef8:	f012 fa5a 	bl	801f3b0 <traceIF_itmPrint>
 800cefc:	4620      	mov	r0, r4
 800cefe:	f012 fa14 	bl	801f32a <crs_strlen>
 800cf02:	b283      	uxth	r3, r0
 800cf04:	4622      	mov	r2, r4
 800cf06:	2110      	movs	r1, #16
 800cf08:	2002      	movs	r0, #2
 800cf0a:	f012 fa73 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cf0e:	2001      	movs	r0, #1
      }
      break;
 800cf10:	e030      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
    }

    case SID_CS_SIM_GENERIC_ACCESS:
    {
      /* recopy info received for cellular service in p_rsp_buf */
      if (DATAPACK_writeStruct(p_rsp_buf,
 800cf12:	f500 63cd 	add.w	r3, r0, #1640	; 0x668
 800cf16:	2208      	movs	r2, #8
 800cf18:	212d      	movs	r1, #45	; 0x2d
 800cf1a:	4628      	mov	r0, r5
 800cf1c:	f7ff f8ca 	bl	800c0b4 <DATAPACK_writeStruct>
 800cf20:	b340      	cbz	r0, 800cf74 <atcm_modem_get_rsp+0x338>
                               (uint16_t) CSMT_SIM_GENERIC_ACCESS,
                               (uint16_t) sizeof(csint_sim_generic_access_t),
                               (void *)&p_modem_ctxt->SID_ctxt.sim_generic_access) != DATAPACK_OK)
      {
        PRINT_ERR("SIM generic access problem")
 800cf22:	4d19      	ldr	r5, [pc, #100]	; (800cf88 <atcm_modem_get_rsp+0x34c>)
 800cf24:	4c15      	ldr	r4, [pc, #84]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cf26:	f105 0620 	add.w	r6, r5, #32
 800cf2a:	46ac      	mov	ip, r5
 800cf2c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cf30:	6020      	str	r0, [r4, #0]
 800cf32:	6061      	str	r1, [r4, #4]
 800cf34:	60a2      	str	r2, [r4, #8]
 800cf36:	60e3      	str	r3, [r4, #12]
 800cf38:	4665      	mov	r5, ip
 800cf3a:	3410      	adds	r4, #16
 800cf3c:	45b4      	cmp	ip, r6
 800cf3e:	d1f4      	bne.n	800cf2a <atcm_modem_get_rsp+0x2ee>
 800cf40:	cd07      	ldmia	r5!, {r0, r1, r2}
 800cf42:	6020      	str	r0, [r4, #0]
 800cf44:	6061      	str	r1, [r4, #4]
 800cf46:	60a2      	str	r2, [r4, #8]
 800cf48:	4c0c      	ldr	r4, [pc, #48]	; (800cf7c <atcm_modem_get_rsp+0x340>)
 800cf4a:	4620      	mov	r0, r4
 800cf4c:	f012 f9ed 	bl	801f32a <crs_strlen>
 800cf50:	b283      	uxth	r3, r0
 800cf52:	4622      	mov	r2, r4
 800cf54:	2110      	movs	r1, #16
 800cf56:	2002      	movs	r0, #2
 800cf58:	f012 fa2a 	bl	801f3b0 <traceIF_itmPrint>
 800cf5c:	4620      	mov	r0, r4
 800cf5e:	f012 f9e4 	bl	801f32a <crs_strlen>
 800cf62:	b283      	uxth	r3, r0
 800cf64:	4622      	mov	r2, r4
 800cf66:	2110      	movs	r1, #16
 800cf68:	2002      	movs	r0, #2
 800cf6a:	f012 fa43 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800cf6e:	2001      	movs	r0, #1
 800cf70:	e000      	b.n	800cf74 <atcm_modem_get_rsp+0x338>
  switch (p_atp_ctxt->current_SID)
 800cf72:	2000      	movs	r0, #0
    default:
      break;
  }

  return (retval);
}
 800cf74:	b013      	add	sp, #76	; 0x4c
 800cf76:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cf78:	0802e964 	.word	0x0802e964
 800cf7c:	200048dc 	.word	0x200048dc
 800cf80:	0802e98c 	.word	0x0802e98c
 800cf84:	0802e9b8 	.word	0x0802e9b8
 800cf88:	0802e9e8 	.word	0x0802e9e8

0800cf8c <atcm_modem_get_error>:
  * @retval at_status_t
  */
at_status_t atcm_modem_get_error(atcustom_modem_context_t *p_modem_ctxt,
                                 const atparser_context_t *p_atp_ctxt,
                                 at_buf_t *p_rsp_buf)
{
 800cf8c:	b538      	push	{r3, r4, r5, lr}
 800cf8e:	4603      	mov	r3, r0
 800cf90:	4610      	mov	r0, r2
  UNUSED(p_atp_ctxt);
  at_status_t retval = ATSTATUS_OK;

  /* prepare error report */
  if (DATAPACK_writeStruct(p_rsp_buf,
 800cf92:	f203 732a 	addw	r3, r3, #1834	; 0x72a
 800cf96:	2202      	movs	r2, #2
 800cf98:	212a      	movs	r1, #42	; 0x2a
 800cf9a:	f7ff f88b 	bl	800c0b4 <DATAPACK_writeStruct>
 800cf9e:	b900      	cbnz	r0, 800cfa2 <atcm_modem_get_error+0x16>
  {
    PRINT_ERR("Buffer size problem")
    retval = ATSTATUS_ERROR;
  }
  return (retval);
}
 800cfa0:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_ERR("Buffer size problem")
 800cfa2:	4d15      	ldr	r5, [pc, #84]	; (800cff8 <atcm_modem_get_error+0x6c>)
 800cfa4:	4c15      	ldr	r4, [pc, #84]	; (800cffc <atcm_modem_get_error+0x70>)
 800cfa6:	f105 0e20 	add.w	lr, r5, #32
 800cfaa:	46ac      	mov	ip, r5
 800cfac:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800cfb0:	6020      	str	r0, [r4, #0]
 800cfb2:	6061      	str	r1, [r4, #4]
 800cfb4:	60a2      	str	r2, [r4, #8]
 800cfb6:	60e3      	str	r3, [r4, #12]
 800cfb8:	4665      	mov	r5, ip
 800cfba:	3410      	adds	r4, #16
 800cfbc:	45f4      	cmp	ip, lr
 800cfbe:	d1f4      	bne.n	800cfaa <atcm_modem_get_error+0x1e>
 800cfc0:	f8dc 0000 	ldr.w	r0, [ip]
 800cfc4:	6020      	str	r0, [r4, #0]
 800cfc6:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800cfca:	7123      	strb	r3, [r4, #4]
 800cfcc:	4c0b      	ldr	r4, [pc, #44]	; (800cffc <atcm_modem_get_error+0x70>)
 800cfce:	4620      	mov	r0, r4
 800cfd0:	f012 f9ab 	bl	801f32a <crs_strlen>
 800cfd4:	b283      	uxth	r3, r0
 800cfd6:	4622      	mov	r2, r4
 800cfd8:	2110      	movs	r1, #16
 800cfda:	2002      	movs	r0, #2
 800cfdc:	f012 f9e8 	bl	801f3b0 <traceIF_itmPrint>
 800cfe0:	4620      	mov	r0, r4
 800cfe2:	f012 f9a2 	bl	801f32a <crs_strlen>
 800cfe6:	b283      	uxth	r3, r0
 800cfe8:	4622      	mov	r2, r4
 800cfea:	2110      	movs	r1, #16
 800cfec:	2002      	movs	r0, #2
 800cfee:	f012 fa01 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800cff2:	2001      	movs	r0, #1
 800cff4:	e7d4      	b.n	800cfa0 <atcm_modem_get_error+0x14>
 800cff6:	bf00      	nop
 800cff8:	0802e964 	.word	0x0802e964
 800cffc:	200048dc 	.word	0x200048dc

0800d000 <atcm_subscribe_net_event>:
  * @param  p_modem_ctxt  pointer to modem context
  * @param  p_atp_ctxt    pointer to parser context
  * @retval at_status_t
  */
at_status_t atcm_subscribe_net_event(atcustom_modem_context_t *p_modem_ctxt, atparser_context_t *p_atp_ctxt)
{
 800d000:	b500      	push	{lr}
 800d002:	b083      	sub	sp, #12
  /* Retrieve urc event request: CEREG, CREG or CGREG ?
  *  note: only one event at same time
  */
  CS_UrcEvent_t urcEvent = p_modem_ctxt->SID_ctxt.urcEvent;
 800d004:	f890 3664 	ldrb.w	r3, [r0, #1636]	; 0x664

  /* is an event linked to CEREG ? */
  if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO))
 800d008:	1e5a      	subs	r2, r3, #1
 800d00a:	b2d2      	uxtb	r2, r2
 800d00c:	2a01      	cmp	r2, #1
 800d00e:	d918      	bls.n	800d042 <atcm_subscribe_net_event+0x42>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CGREG ?  */
  else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 800d010:	1eda      	subs	r2, r3, #3
 800d012:	b2d2      	uxtb	r2, r2
 800d014:	2a01      	cmp	r2, #1
 800d016:	d938      	bls.n	800d08a <atcm_subscribe_net_event+0x8a>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CREG ? */
  else if ((urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 800d018:	1f5a      	subs	r2, r3, #5
 800d01a:	b2d2      	uxtb	r2, r2
 800d01c:	2a01      	cmp	r2, #1
 800d01e:	d822      	bhi.n	800d066 <atcm_subscribe_net_event+0x66>
  {
    /* if CREG not yet subscbribe */
    if ((p_modem_ctxt->persist.urc_subscript_cs_networkReg == CELLULAR_FALSE) &&
 800d020:	8a02      	ldrh	r2, [r0, #16]
 800d022:	2a00      	cmp	r2, #0
 800d024:	d158      	bne.n	800d0d8 <atcm_subscribe_net_event+0xd8>
        (p_modem_ctxt->persist.urc_subscript_cs_locationInfo == CELLULAR_FALSE))
    {
      /* set event as subscribed */
      if (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT)
 800d026:	2b05      	cmp	r3, #5
 800d028:	d050      	beq.n	800d0cc <atcm_subscribe_net_event+0xcc>
      {
        p_modem_ctxt->persist.urc_subscript_cs_networkReg = CELLULAR_TRUE;
      }
      if (urcEvent == CS_URCEVENT_CS_LOCATION_INFO)
 800d02a:	2b06      	cmp	r3, #6
 800d02c:	d051      	beq.n	800d0d2 <atcm_subscribe_net_event+0xd2>
      {
        p_modem_ctxt->persist.urc_subscript_cs_locationInfo = CELLULAR_TRUE;
      }

      /* request all URC, we will filter them */
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800d02e:	2302      	movs	r3, #2
 800d030:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CREG, FINAL_CMD);
 800d034:	2301      	movs	r3, #1
 800d036:	9300      	str	r3, [sp, #0]
 800d038:	2317      	movs	r3, #23
 800d03a:	2203      	movs	r2, #3
 800d03c:	f7ff fd08 	bl	800ca50 <atcm_program_AT_CMD>
 800d040:	e011      	b.n	800d066 <atcm_subscribe_net_event+0x66>
    if ((p_modem_ctxt->persist.urc_subscript_eps_networkReg == CELLULAR_FALSE) &&
 800d042:	8982      	ldrh	r2, [r0, #12]
 800d044:	b9ea      	cbnz	r2, 800d082 <atcm_subscribe_net_event+0x82>
      if (urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT)
 800d046:	2b01      	cmp	r3, #1
 800d048:	d011      	beq.n	800d06e <atcm_subscribe_net_event+0x6e>
      if (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO)
 800d04a:	2b02      	cmp	r3, #2
 800d04c:	d012      	beq.n	800d074 <atcm_subscribe_net_event+0x74>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800d04e:	f890 350d 	ldrb.w	r3, [r0, #1293]	; 0x50d
 800d052:	b193      	cbz	r3, 800d07a <atcm_subscribe_net_event+0x7a>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800d054:	2304      	movs	r3, #4
 800d056:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEREG, FINAL_CMD);
 800d05a:	2301      	movs	r3, #1
 800d05c:	9300      	str	r3, [sp, #0]
 800d05e:	2319      	movs	r3, #25
 800d060:	2203      	movs	r2, #3
 800d062:	f7ff fcf5 	bl	800ca50 <atcm_program_AT_CMD>
  {
    /* nothing to do */
  }

  return (ATSTATUS_OK);
}
 800d066:	2000      	movs	r0, #0
 800d068:	b003      	add	sp, #12
 800d06a:	f85d fb04 	ldr.w	pc, [sp], #4
        p_modem_ctxt->persist.urc_subscript_eps_networkReg = CELLULAR_TRUE;
 800d06e:	2201      	movs	r2, #1
 800d070:	7302      	strb	r2, [r0, #12]
 800d072:	e7ea      	b.n	800d04a <atcm_subscribe_net_event+0x4a>
        p_modem_ctxt->persist.urc_subscript_eps_locationInfo = CELLULAR_TRUE;
 800d074:	2301      	movs	r3, #1
 800d076:	7343      	strb	r3, [r0, #13]
 800d078:	e7e9      	b.n	800d04e <atcm_subscribe_net_event+0x4e>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800d07a:	2302      	movs	r3, #2
 800d07c:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
 800d080:	e7eb      	b.n	800d05a <atcm_subscribe_net_event+0x5a>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d082:	4608      	mov	r0, r1
 800d084:	f7ff fd40 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d088:	e7ed      	b.n	800d066 <atcm_subscribe_net_event+0x66>
    if ((p_modem_ctxt->persist.urc_subscript_gprs_networkReg == CELLULAR_FALSE) &&
 800d08a:	89c2      	ldrh	r2, [r0, #14]
 800d08c:	b9d2      	cbnz	r2, 800d0c4 <atcm_subscribe_net_event+0xc4>
      if (urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT)
 800d08e:	2b03      	cmp	r3, #3
 800d090:	d00e      	beq.n	800d0b0 <atcm_subscribe_net_event+0xb0>
      if (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO)
 800d092:	2b04      	cmp	r3, #4
 800d094:	d00f      	beq.n	800d0b6 <atcm_subscribe_net_event+0xb6>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800d096:	f890 350d 	ldrb.w	r3, [r0, #1293]	; 0x50d
 800d09a:	b17b      	cbz	r3, 800d0bc <atcm_subscribe_net_event+0xbc>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800d09c:	2304      	movs	r3, #4
 800d09e:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGREG, FINAL_CMD);
 800d0a2:	2301      	movs	r3, #1
 800d0a4:	9300      	str	r3, [sp, #0]
 800d0a6:	2318      	movs	r3, #24
 800d0a8:	2203      	movs	r2, #3
 800d0aa:	f7ff fcd1 	bl	800ca50 <atcm_program_AT_CMD>
 800d0ae:	e7da      	b.n	800d066 <atcm_subscribe_net_event+0x66>
        p_modem_ctxt->persist.urc_subscript_gprs_networkReg = CELLULAR_TRUE;
 800d0b0:	2201      	movs	r2, #1
 800d0b2:	7382      	strb	r2, [r0, #14]
 800d0b4:	e7ed      	b.n	800d092 <atcm_subscribe_net_event+0x92>
        p_modem_ctxt->persist.urc_subscript_gprs_locationInfo = CELLULAR_TRUE;
 800d0b6:	2301      	movs	r3, #1
 800d0b8:	73c3      	strb	r3, [r0, #15]
 800d0ba:	e7ec      	b.n	800d096 <atcm_subscribe_net_event+0x96>
        p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800d0bc:	2302      	movs	r3, #2
 800d0be:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
 800d0c2:	e7ee      	b.n	800d0a2 <atcm_subscribe_net_event+0xa2>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d0c4:	4608      	mov	r0, r1
 800d0c6:	f7ff fd1f 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d0ca:	e7cc      	b.n	800d066 <atcm_subscribe_net_event+0x66>
        p_modem_ctxt->persist.urc_subscript_cs_networkReg = CELLULAR_TRUE;
 800d0cc:	2201      	movs	r2, #1
 800d0ce:	7402      	strb	r2, [r0, #16]
 800d0d0:	e7ab      	b.n	800d02a <atcm_subscribe_net_event+0x2a>
        p_modem_ctxt->persist.urc_subscript_cs_locationInfo = CELLULAR_TRUE;
 800d0d2:	2301      	movs	r3, #1
 800d0d4:	7443      	strb	r3, [r0, #17]
 800d0d6:	e7aa      	b.n	800d02e <atcm_subscribe_net_event+0x2e>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d0d8:	4608      	mov	r0, r1
 800d0da:	f7ff fd15 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d0de:	e7c2      	b.n	800d066 <atcm_subscribe_net_event+0x66>

0800d0e0 <atcm_unsubscribe_net_event>:
  * @param  p_modem_ctxt  pointer to modem context
  * @param  p_atp_ctxt    pointer to parser context
  * @retval at_status_t
  */
at_status_t atcm_unsubscribe_net_event(atcustom_modem_context_t *p_modem_ctxt, atparser_context_t *p_atp_ctxt)
{
 800d0e0:	b500      	push	{lr}
 800d0e2:	b083      	sub	sp, #12
  /* Retrieve urc event request: CEREG, CREG or CGREG ?
  *  note: only one event at same time
  */
  CS_UrcEvent_t urcEvent = p_modem_ctxt->SID_ctxt.urcEvent;
 800d0e4:	f890 3664 	ldrb.w	r3, [r0, #1636]	; 0x664

  /* is an event linked to CEREG ? */
  if ((urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO))
 800d0e8:	1e5a      	subs	r2, r3, #1
 800d0ea:	b2d2      	uxtb	r2, r2
 800d0ec:	2a01      	cmp	r2, #1
 800d0ee:	d90b      	bls.n	800d108 <atcm_unsubscribe_net_event+0x28>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CGREG ? */
  else if ((urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO))
 800d0f0:	1eda      	subs	r2, r3, #3
 800d0f2:	b2d2      	uxtb	r2, r2
 800d0f4:	2a01      	cmp	r2, #1
 800d0f6:	d920      	bls.n	800d13a <atcm_unsubscribe_net_event+0x5a>
    {
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
    }
  }
  /* is an event linked to CREG ? */
  else if ((urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT) || (urcEvent == CS_URCEVENT_CS_LOCATION_INFO))
 800d0f8:	1f5a      	subs	r2, r3, #5
 800d0fa:	b2d2      	uxtb	r2, r2
 800d0fc:	2a01      	cmp	r2, #1
 800d0fe:	d935      	bls.n	800d16c <atcm_unsubscribe_net_event+0x8c>
  {
    /* nothing to do */
  }

  return (ATSTATUS_OK);
}
 800d100:	2000      	movs	r0, #0
 800d102:	b003      	add	sp, #12
 800d104:	f85d fb04 	ldr.w	pc, [sp], #4
    if (urcEvent == CS_URCEVENT_EPS_NETWORK_REG_STAT)
 800d108:	2b01      	cmp	r3, #1
 800d10a:	d00c      	beq.n	800d126 <atcm_unsubscribe_net_event+0x46>
    if (urcEvent == CS_URCEVENT_EPS_LOCATION_INFO)
 800d10c:	2b02      	cmp	r3, #2
 800d10e:	d00d      	beq.n	800d12c <atcm_unsubscribe_net_event+0x4c>
    if ((p_modem_ctxt->persist.urc_subscript_eps_networkReg == CELLULAR_FALSE) &&
 800d110:	8983      	ldrh	r3, [r0, #12]
 800d112:	b973      	cbnz	r3, 800d132 <atcm_unsubscribe_net_event+0x52>
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d114:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CEREG, FINAL_CMD);
 800d118:	2301      	movs	r3, #1
 800d11a:	9300      	str	r3, [sp, #0]
 800d11c:	2319      	movs	r3, #25
 800d11e:	2203      	movs	r2, #3
 800d120:	f7ff fc96 	bl	800ca50 <atcm_program_AT_CMD>
 800d124:	e7ec      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
      p_modem_ctxt->persist.urc_subscript_eps_networkReg = CELLULAR_FALSE;
 800d126:	2200      	movs	r2, #0
 800d128:	7302      	strb	r2, [r0, #12]
 800d12a:	e7ef      	b.n	800d10c <atcm_unsubscribe_net_event+0x2c>
      p_modem_ctxt->persist.urc_subscript_eps_locationInfo = CELLULAR_FALSE;
 800d12c:	2300      	movs	r3, #0
 800d12e:	7343      	strb	r3, [r0, #13]
 800d130:	e7ee      	b.n	800d110 <atcm_unsubscribe_net_event+0x30>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d132:	4608      	mov	r0, r1
 800d134:	f7ff fce8 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d138:	e7e2      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
    if (urcEvent == CS_URCEVENT_GPRS_NETWORK_REG_STAT)
 800d13a:	2b03      	cmp	r3, #3
 800d13c:	d00c      	beq.n	800d158 <atcm_unsubscribe_net_event+0x78>
    if (urcEvent == CS_URCEVENT_GPRS_LOCATION_INFO)
 800d13e:	2b04      	cmp	r3, #4
 800d140:	d00d      	beq.n	800d15e <atcm_unsubscribe_net_event+0x7e>
    if ((p_modem_ctxt->persist.urc_subscript_gprs_networkReg == CELLULAR_FALSE) &&
 800d142:	89c3      	ldrh	r3, [r0, #14]
 800d144:	b973      	cbnz	r3, 800d164 <atcm_unsubscribe_net_event+0x84>
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d146:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CGREG, FINAL_CMD);
 800d14a:	2301      	movs	r3, #1
 800d14c:	9300      	str	r3, [sp, #0]
 800d14e:	2318      	movs	r3, #24
 800d150:	2203      	movs	r2, #3
 800d152:	f7ff fc7d 	bl	800ca50 <atcm_program_AT_CMD>
 800d156:	e7d3      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
      p_modem_ctxt->persist.urc_subscript_gprs_networkReg = CELLULAR_FALSE;
 800d158:	2200      	movs	r2, #0
 800d15a:	7382      	strb	r2, [r0, #14]
 800d15c:	e7ef      	b.n	800d13e <atcm_unsubscribe_net_event+0x5e>
      p_modem_ctxt->persist.urc_subscript_gprs_locationInfo = CELLULAR_FALSE;
 800d15e:	2300      	movs	r3, #0
 800d160:	73c3      	strb	r3, [r0, #15]
 800d162:	e7ee      	b.n	800d142 <atcm_unsubscribe_net_event+0x62>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d164:	4608      	mov	r0, r1
 800d166:	f7ff fccf 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d16a:	e7c9      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
    if (urcEvent == CS_URCEVENT_CS_NETWORK_REG_STAT)
 800d16c:	2b05      	cmp	r3, #5
 800d16e:	d00c      	beq.n	800d18a <atcm_unsubscribe_net_event+0xaa>
    if (urcEvent == CS_URCEVENT_CS_LOCATION_INFO)
 800d170:	2b06      	cmp	r3, #6
 800d172:	d00d      	beq.n	800d190 <atcm_unsubscribe_net_event+0xb0>
    if ((p_modem_ctxt->persist.urc_subscript_cs_networkReg == CELLULAR_FALSE) &&
 800d174:	8a03      	ldrh	r3, [r0, #16]
 800d176:	b973      	cbnz	r3, 800d196 <atcm_unsubscribe_net_event+0xb6>
      p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d178:	f880 372e 	strb.w	r3, [r0, #1838]	; 0x72e
      atcm_program_AT_CMD(p_modem_ctxt, p_atp_ctxt, ATTYPE_WRITE_CMD, (CMD_ID_t) CMD_AT_CREG, FINAL_CMD);
 800d17c:	2301      	movs	r3, #1
 800d17e:	9300      	str	r3, [sp, #0]
 800d180:	2317      	movs	r3, #23
 800d182:	2203      	movs	r2, #3
 800d184:	f7ff fc64 	bl	800ca50 <atcm_program_AT_CMD>
 800d188:	e7ba      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>
      p_modem_ctxt->persist.urc_subscript_cs_networkReg = CELLULAR_FALSE;
 800d18a:	2200      	movs	r2, #0
 800d18c:	7402      	strb	r2, [r0, #16]
 800d18e:	e7ef      	b.n	800d170 <atcm_unsubscribe_net_event+0x90>
      p_modem_ctxt->persist.urc_subscript_cs_locationInfo = CELLULAR_FALSE;
 800d190:	2300      	movs	r3, #0
 800d192:	7443      	strb	r3, [r0, #17]
 800d194:	e7ee      	b.n	800d174 <atcm_unsubscribe_net_event+0x94>
      atcm_program_NO_MORE_CMD(p_atp_ctxt);
 800d196:	4608      	mov	r0, r1
 800d198:	f7ff fcb6 	bl	800cb08 <atcm_program_NO_MORE_CMD>
 800d19c:	e7b0      	b.n	800d100 <atcm_unsubscribe_net_event+0x20>

0800d19e <atcm_validate_ping_request>:
  *         - synchronous: call this function when requesting ping to te modem.
  * @param  p_modem_ctxt Pointer to the modem context
  * @retval none
  */
void atcm_validate_ping_request(atcustom_modem_context_t *p_modem_ctxt)
{
 800d19e:	b570      	push	{r4, r5, r6, lr}
 800d1a0:	4604      	mov	r4, r0
  /* PING request is valid */
  /* reset and copy SID ping parameters to persistent context */
  (void) memset((void *)&p_modem_ctxt->persist.ping_infos, 0, sizeof(csint_ping_params_t));
 800d1a2:	f200 5516 	addw	r5, r0, #1302	; 0x516
 800d1a6:	2643      	movs	r6, #67	; 0x43
 800d1a8:	4632      	mov	r2, r6
 800d1aa:	2100      	movs	r1, #0
 800d1ac:	4628      	mov	r0, r5
 800d1ae:	f019 fbbe 	bl	802692e <memset>
  (void) memcpy((void *)&p_modem_ctxt->persist.ping_infos, (void *)&p_modem_ctxt->SID_ctxt.ping_infos,
 800d1b2:	4632      	mov	r2, r6
 800d1b4:	f504 61da 	add.w	r1, r4, #1744	; 0x6d0
 800d1b8:	4628      	mov	r0, r5
 800d1ba:	f019 fc95 	bl	8026ae8 <memcpy>
                sizeof(csint_ping_params_t));
  /* reset other parameters */
  (void) memset((void *)&p_modem_ctxt->persist.ping_resp_urc, 0, sizeof(CS_Ping_response_t));
 800d1be:	2250      	movs	r2, #80	; 0x50
 800d1c0:	2100      	movs	r1, #0
 800d1c2:	f204 505c 	addw	r0, r4, #1372	; 0x55c
 800d1c6:	f019 fbb2 	bl	802692e <memset>
  /* initialize ping index to invalid value */
  p_modem_ctxt->persist.ping_resp_urc.index = PING_INVALID_INDEX;
 800d1ca:	23ff      	movs	r3, #255	; 0xff
 800d1cc:	f884 355c 	strb.w	r3, [r4, #1372]	; 0x55c
  /* initialize ping URC to "not available" */
  p_modem_ctxt->persist.urc_avail_ping_rsp = AT_FALSE;
 800d1d0:	2300      	movs	r3, #0
 800d1d2:	f884 35ac 	strb.w	r3, [r4, #1452]	; 0x5ac
}
 800d1d6:	bd70      	pop	{r4, r5, r6, pc}

0800d1d8 <atcm_modem_event_received>:
at_bool_t atcm_modem_event_received(atcustom_modem_context_t *p_modem_ctxt, CS_ModemEvent_t mdm_evt)
{
  at_bool_t event_subscribed = AT_FALSE;

  /* if the event received is subscribed, save it */
  if ((p_modem_ctxt->persist.modem_events_subscript & mdm_evt) != 0U) /* bitmask check */
 800d1d8:	8c43      	ldrh	r3, [r0, #34]	; 0x22
 800d1da:	420b      	tst	r3, r1
 800d1dc:	d004      	beq.n	800d1e8 <atcm_modem_event_received+0x10>
  {
    p_modem_ctxt->persist.urc_avail_modem_events |= mdm_evt;
 800d1de:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 800d1e0:	4319      	orrs	r1, r3
 800d1e2:	8481      	strh	r1, [r0, #36]	; 0x24
    event_subscribed = AT_TRUE;
 800d1e4:	2001      	movs	r0, #1
 800d1e6:	4770      	bx	lr
  at_bool_t event_subscribed = AT_FALSE;
 800d1e8:	2000      	movs	r0, #0
  }

  /* returns true only if event has been subscribed */
  return (event_subscribed);
}
 800d1ea:	4770      	bx	lr

0800d1ec <atcm_reset_SID_context>:
  * @brief  atcm_reset_SID_context
  * @param  p_sid_ctxt
  * @retval none
  */
void atcm_reset_SID_context(atcustom_SID_context_t *p_sid_ctxt)
{
 800d1ec:	b570      	push	{r4, r5, r6, lr}
 800d1ee:	4604      	mov	r4, r0
  PRINT_API("enter reset_SID_context()")
 800d1f0:	4d38      	ldr	r5, [pc, #224]	; (800d2d4 <atcm_reset_SID_context+0xe8>)
 800d1f2:	4e39      	ldr	r6, [pc, #228]	; (800d2d8 <atcm_reset_SID_context+0xec>)
 800d1f4:	f105 0e20 	add.w	lr, r5, #32
 800d1f8:	46ac      	mov	ip, r5
 800d1fa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d1fe:	6030      	str	r0, [r6, #0]
 800d200:	6071      	str	r1, [r6, #4]
 800d202:	60b2      	str	r2, [r6, #8]
 800d204:	60f3      	str	r3, [r6, #12]
 800d206:	4665      	mov	r5, ip
 800d208:	3610      	adds	r6, #16
 800d20a:	45f4      	cmp	ip, lr
 800d20c:	d1f4      	bne.n	800d1f8 <atcm_reset_SID_context+0xc>
 800d20e:	cd03      	ldmia	r5!, {r0, r1}
 800d210:	6030      	str	r0, [r6, #0]
 800d212:	6071      	str	r1, [r6, #4]
 800d214:	782b      	ldrb	r3, [r5, #0]
 800d216:	7233      	strb	r3, [r6, #8]
 800d218:	4d2f      	ldr	r5, [pc, #188]	; (800d2d8 <atcm_reset_SID_context+0xec>)
 800d21a:	4628      	mov	r0, r5
 800d21c:	f012 f885 	bl	801f32a <crs_strlen>
 800d220:	b283      	uxth	r3, r0
 800d222:	462a      	mov	r2, r5
 800d224:	2104      	movs	r1, #4
 800d226:	2002      	movs	r0, #2
 800d228:	f012 f8c2 	bl	801f3b0 <traceIF_itmPrint>
 800d22c:	4628      	mov	r0, r5
 800d22e:	f012 f87c 	bl	801f32a <crs_strlen>
 800d232:	b283      	uxth	r3, r0
 800d234:	462a      	mov	r2, r5
 800d236:	2104      	movs	r1, #4
 800d238:	2002      	movs	r0, #2
 800d23a:	f012 f8db 	bl	801f3f4 <traceIF_uartPrint>

  p_sid_ctxt->attach_status = CS_PS_DETACHED;
 800d23e:	2500      	movs	r5, #0
 800d240:	f884 50b5 	strb.w	r5, [r4, #181]	; 0xb5
  p_sid_ctxt->cfun_status = CS_CMI_MINI;
 800d244:	f884 50b6 	strb.w	r5, [r4, #182]	; 0xb6

  (void) memset((void *)&p_sid_ctxt->write_operator_infos, 0, sizeof(CS_OperatorSelector_t));
 800d248:	2248      	movs	r2, #72	; 0x48
 800d24a:	4629      	mov	r1, r5
 800d24c:	f104 0018 	add.w	r0, r4, #24
 800d250:	f019 fb6d 	bl	802692e <memset>
  p_sid_ctxt->write_operator_infos.format = CS_ONF_NOT_PRESENT;
 800d254:	2309      	movs	r3, #9
 800d256:	8363      	strh	r3, [r4, #26]
  /* code commented to avoid Code Sonar error (variable already initialized with same value)
   * p_sid_ctxt->write_operator_infos.AcT_present = CELLULAR_FALSE;
   */

  (void) memset((void *)&p_sid_ctxt->read_operator_infos, 0, sizeof(CS_RegistrationStatus_t));
 800d258:	224e      	movs	r2, #78	; 0x4e
 800d25a:	4629      	mov	r1, r5
 800d25c:	f104 0060 	add.w	r0, r4, #96	; 0x60
 800d260:	f019 fb65 	bl	802692e <memset>
  * read_operator_infos.EPS_NetworkRegState = CS_NRS_NOT_REGISTERED_NOT_SEARCHING;
  * read_operator_infos.GPRS_NetworkRegState = CS_NRS_NOT_REGISTERED_NOT_SEARCHING;
  * read_operator_infos.CS_NetworkRegState = CS_NRS_NOT_REGISTERED_NOT_SEARCHING;
  * read_operator_infos.optional_fields_presence = CS_RSF_NONE;
  */
  p_sid_ctxt->modem_init.init = CS_CMI_MINI;
 800d264:	7065      	strb	r5, [r4, #1]
  p_sid_ctxt->modem_init.reset = CELLULAR_FALSE;
 800d266:	70a5      	strb	r5, [r4, #2]
  (void) memset((void *)&p_sid_ctxt->modem_init.pincode.pincode, 0, sizeof(csint_pinCode_t));
 800d268:	f8c4 5003 	str.w	r5, [r4, #3]
 800d26c:	f8c4 5007 	str.w	r5, [r4, #7]
 800d270:	f8c4 500b 	str.w	r5, [r4, #11]
 800d274:	f8c4 500f 	str.w	r5, [r4, #15]

  p_sid_ctxt->device_info = NULL;
 800d278:	6165      	str	r5, [r4, #20]
  p_sid_ctxt->signal_quality = NULL;
 800d27a:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
  p_sid_ctxt->dns_request_infos = NULL;
 800d27e:	f8c4 511c 	str.w	r5, [r4, #284]	; 0x11c
  p_sid_ctxt->direct_cmd_tx = NULL;
 800d282:	f8c4 5164 	str.w	r5, [r4, #356]	; 0x164
  p_sid_ctxt->sim_generic_access.data = NULL;
 800d286:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
  p_sid_ctxt->sim_generic_access.bytes_received = 0U;
 800d28a:	f8c4 50bc 	str.w	r5, [r4, #188]	; 0xbc

  (void) memset((void *)&p_sid_ctxt->init_power_config, 0, sizeof(CS_init_power_config_t));
 800d28e:	f8c4 5168 	str.w	r5, [r4, #360]	; 0x168
 800d292:	f8c4 516b 	str.w	r5, [r4, #363]	; 0x16b
  (void) memset((void *)&p_sid_ctxt->set_power_config, 0, sizeof(CS_set_power_config_t));
 800d296:	f8c4 516f 	str.w	r5, [r4, #367]	; 0x16f
 800d29a:	f8c4 5173 	str.w	r5, [r4, #371]	; 0x173
 800d29e:	f8a4 5177 	strh.w	r5, [r4, #375]	; 0x177

  p_sid_ctxt->wakeup_origin = UNKNOWN_WAKEUP;
 800d2a2:	f884 5179 	strb.w	r5, [r4, #377]	; 0x179

  p_sid_ctxt->urcEvent = CS_URCEVENT_NONE;
 800d2a6:	f884 50b4 	strb.w	r5, [r4, #180]	; 0xb4
  p_sid_ctxt->pdn_conf_id = CS_PDN_CONFIG_DEFAULT;
 800d2aa:	230b      	movs	r3, #11
 800d2ac:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119

  (void) memset((void *)&p_sid_ctxt->socketSendData_struct, 0, sizeof(csint_socket_data_buffer_t));
 800d2b0:	2258      	movs	r2, #88	; 0x58
 800d2b2:	4629      	mov	r1, r5
 800d2b4:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
 800d2b8:	f019 fb39 	bl	802692e <memset>
  (void) memset((void *)&p_sid_ctxt->ping_infos, 0, sizeof(csint_ping_params_t));
 800d2bc:	2243      	movs	r2, #67	; 0x43
 800d2be:	4629      	mov	r1, r5
 800d2c0:	f504 7090 	add.w	r0, r4, #288	; 0x120
 800d2c4:	f019 fb33 	bl	802692e <memset>

  p_sid_ctxt->error_report.error_type = CSERR_UNKNOWN;
 800d2c8:	f884 517a 	strb.w	r5, [r4, #378]	; 0x17a
  p_sid_ctxt->error_report.sim_state = CS_SIMSTATE_UNKNOWN;
 800d2cc:	f884 517b 	strb.w	r5, [r4, #379]	; 0x17b
}
 800d2d0:	bd70      	pop	{r4, r5, r6, pc}
 800d2d2:	bf00      	nop
 800d2d4:	0802ea14 	.word	0x0802ea14
 800d2d8:	200048dc 	.word	0x200048dc

0800d2dc <atcm_reset_CMD_context>:
  * @brief  atcm_reset_CMD_context
  * @param  p_cmd_ctxt
  * @retval none
  */
void atcm_reset_CMD_context(atcustom_CMD_context_t *p_cmd_ctxt)
{
 800d2dc:	b570      	push	{r4, r5, r6, lr}
 800d2de:	4605      	mov	r5, r0
  PRINT_API("enter reset_CMD_context()")
 800d2e0:	4c1a      	ldr	r4, [pc, #104]	; (800d34c <atcm_reset_CMD_context+0x70>)
 800d2e2:	4e1b      	ldr	r6, [pc, #108]	; (800d350 <atcm_reset_CMD_context+0x74>)
 800d2e4:	f104 0e20 	add.w	lr, r4, #32
 800d2e8:	46a4      	mov	ip, r4
 800d2ea:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d2ee:	6030      	str	r0, [r6, #0]
 800d2f0:	6071      	str	r1, [r6, #4]
 800d2f2:	60b2      	str	r2, [r6, #8]
 800d2f4:	60f3      	str	r3, [r6, #12]
 800d2f6:	4664      	mov	r4, ip
 800d2f8:	3610      	adds	r6, #16
 800d2fa:	45f4      	cmp	ip, lr
 800d2fc:	d1f4      	bne.n	800d2e8 <atcm_reset_CMD_context+0xc>
 800d2fe:	cc03      	ldmia	r4!, {r0, r1}
 800d300:	6030      	str	r0, [r6, #0]
 800d302:	6071      	str	r1, [r6, #4]
 800d304:	7823      	ldrb	r3, [r4, #0]
 800d306:	7233      	strb	r3, [r6, #8]
 800d308:	4c11      	ldr	r4, [pc, #68]	; (800d350 <atcm_reset_CMD_context+0x74>)
 800d30a:	4620      	mov	r0, r4
 800d30c:	f012 f80d 	bl	801f32a <crs_strlen>
 800d310:	b283      	uxth	r3, r0
 800d312:	4622      	mov	r2, r4
 800d314:	2104      	movs	r1, #4
 800d316:	2002      	movs	r0, #2
 800d318:	f012 f84a 	bl	801f3b0 <traceIF_itmPrint>
 800d31c:	4620      	mov	r0, r4
 800d31e:	f012 f804 	bl	801f32a <crs_strlen>
 800d322:	b283      	uxth	r3, r0
 800d324:	4622      	mov	r2, r4
 800d326:	2104      	movs	r1, #4
 800d328:	2002      	movs	r0, #2
 800d32a:	f012 f863 	bl	801f3f4 <traceIF_uartPrint>

  /* p_cmd_ctxt->cgsn_write_cmd_param parameter used in fCmdBuild_CGSN() for AT+GCSN cmd */
  p_cmd_ctxt->cgatt_write_cmd_param = CGATT_UNKNOWN;
 800d32e:	2302      	movs	r3, #2
 800d330:	706b      	strb	r3, [r5, #1]
  p_cmd_ctxt->cxreg_write_cmd_param = CXREG_DISABLE_NETWK_REG_URC;
 800d332:	2300      	movs	r3, #0
 800d334:	70ab      	strb	r3, [r5, #2]
  /* p_cmd_ctxt->command_echo parameter  used in fCmdBuild_ATE() for ATE cmd */
  /* p_cmd_ctxt->dce_full_resp_format parameter used in fCmdBuild_ATV() for ATV cmd*/
  p_cmd_ctxt->pdn_state = PDN_STATE_ACTIVATE;
 800d336:	2301      	movs	r3, #1
 800d338:	716b      	strb	r3, [r5, #5]
  p_cmd_ctxt->modem_cid = 0xFFFFU;
 800d33a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800d33e:	60aa      	str	r2, [r5, #8]
  p_cmd_ctxt->baud_rate = MODEM_UART_BAUDRATE;
 800d340:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 800d344:	60ea      	str	r2, [r5, #12]
  p_cmd_ctxt->cfun_value = 1U;
 800d346:	746b      	strb	r3, [r5, #17]
#if (CONFIG_MODEM_UART_RTS_CTS == 1)
  p_cmd_ctxt->flow_control_cts_rts = AT_TRUE;
 800d348:	742b      	strb	r3, [r5, #16]
#else
  p_cmd_ctxt->flow_control_cts_rts = AT_FALSE;
#endif /* CONFIG_MODEM_UART_RTS_CTS */
}
 800d34a:	bd70      	pop	{r4, r5, r6, pc}
 800d34c:	0802ea40 	.word	0x0802ea40
 800d350:	200048dc 	.word	0x200048dc

0800d354 <atcm_reset_SOCKET_context>:
  * @brief  atcm_reset_SOCKET_context
  * @param  p_modem_ctxt
  * @retval none
  */
void atcm_reset_SOCKET_context(atcustom_modem_context_t *p_modem_ctxt)
{
 800d354:	b570      	push	{r4, r5, r6, lr}
 800d356:	4604      	mov	r4, r0
  PRINT_API("enter atcm_reset_SOCKET_context()")
 800d358:	4e1d      	ldr	r6, [pc, #116]	; (800d3d0 <atcm_reset_SOCKET_context+0x7c>)
 800d35a:	4d1e      	ldr	r5, [pc, #120]	; (800d3d4 <atcm_reset_SOCKET_context+0x80>)
 800d35c:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 800d360:	46b4      	mov	ip, r6
 800d362:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800d366:	6028      	str	r0, [r5, #0]
 800d368:	6069      	str	r1, [r5, #4]
 800d36a:	60aa      	str	r2, [r5, #8]
 800d36c:	60eb      	str	r3, [r5, #12]
 800d36e:	4666      	mov	r6, ip
 800d370:	3510      	adds	r5, #16
 800d372:	45f4      	cmp	ip, lr
 800d374:	d1f4      	bne.n	800d360 <atcm_reset_SOCKET_context+0xc>
 800d376:	f89c 3000 	ldrb.w	r3, [ip]
 800d37a:	702b      	strb	r3, [r5, #0]
 800d37c:	4d15      	ldr	r5, [pc, #84]	; (800d3d4 <atcm_reset_SOCKET_context+0x80>)
 800d37e:	4628      	mov	r0, r5
 800d380:	f011 ffd3 	bl	801f32a <crs_strlen>
 800d384:	b283      	uxth	r3, r0
 800d386:	462a      	mov	r2, r5
 800d388:	2104      	movs	r1, #4
 800d38a:	2002      	movs	r0, #2
 800d38c:	f012 f810 	bl	801f3b0 <traceIF_itmPrint>
 800d390:	4628      	mov	r0, r5
 800d392:	f011 ffca 	bl	801f32a <crs_strlen>
 800d396:	b283      	uxth	r3, r0
 800d398:	462a      	mov	r2, r5
 800d39a:	2104      	movs	r1, #4
 800d39c:	2002      	movs	r0, #2
 800d39e:	f012 f829 	bl	801f3f4 <traceIF_uartPrint>

  p_modem_ctxt->socket_ctxt.socket_info = NULL;
 800d3a2:	2500      	movs	r5, #0
 800d3a4:	f8c4 5740 	str.w	r5, [r4, #1856]	; 0x740
  (void) memset((void *)&p_modem_ctxt->socket_ctxt.socketReceivedata, 0, sizeof(csint_socket_data_buffer_t));
 800d3a8:	2258      	movs	r2, #88	; 0x58
 800d3aa:	4629      	mov	r1, r5
 800d3ac:	f204 7044 	addw	r0, r4, #1860	; 0x744
 800d3b0:	f019 fabd 	bl	802692e <memset>
  p_modem_ctxt->socket_ctxt.socket_current_connId = 0U;
 800d3b4:	f8c4 579c 	str.w	r5, [r4, #1948]	; 0x79c
  p_modem_ctxt->socket_ctxt.socket_rx_expected_buf_size = 0U;
 800d3b8:	f8c4 57a0 	str.w	r5, [r4, #1952]	; 0x7a0
  p_modem_ctxt->socket_ctxt.socket_rx_count_bytes_received = 0U;
 800d3bc:	f8c4 57a4 	str.w	r5, [r4, #1956]	; 0x7a4

  p_modem_ctxt->socket_ctxt.socket_send_state = SocketSendState_No_Activity;
 800d3c0:	f884 57ac 	strb.w	r5, [r4, #1964]	; 0x7ac
  p_modem_ctxt->socket_ctxt.socket_receive_state = SocketRcvState_No_Activity;
 800d3c4:	f884 57ad 	strb.w	r5, [r4, #1965]	; 0x7ad
  p_modem_ctxt->socket_ctxt.socket_RxData_state = SocketRxDataState_not_started;
 800d3c8:	f884 57ae 	strb.w	r5, [r4, #1966]	; 0x7ae
}
 800d3cc:	bd70      	pop	{r4, r5, r6, pc}
 800d3ce:	bf00      	nop
 800d3d0:	0802ea6c 	.word	0x0802ea6c
 800d3d4:	200048dc 	.word	0x200048dc

0800d3d8 <atcm_searchCmdInLUT>:
  */
at_status_t atcm_searchCmdInLUT(atcustom_modem_context_t *p_modem_ctxt,
                                const atparser_context_t  *p_atp_ctxt,
                                const IPC_RxMessage_t *p_msg_in,
                                at_element_info_t *element_infos)
{
 800d3d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d3dc:	b083      	sub	sp, #12
 800d3de:	9201      	str	r2, [sp, #4]
 800d3e0:	4698      	mov	r8, r3
  UNUSED(p_atp_ctxt);
  at_status_t retval = ATSTATUS_ERROR;

  element_infos->cmd_id_received = CMD_AT_INVALID;
 800d3e2:	f04f 33ff 	mov.w	r3, #4294967295
 800d3e6:	f8c8 3004 	str.w	r3, [r8, #4]

  /* check if we receive empty command */
  if (element_infos->str_size == 0U)
 800d3ea:	f8b8 300e 	ldrh.w	r3, [r8, #14]
 800d3ee:	b933      	cbnz	r3, 800d3fe <atcm_searchCmdInLUT+0x26>
  {
    /* empty answer */
    element_infos->cmd_id_received = (CMD_ID_t) CMD_AT;
 800d3f0:	f8c8 3004 	str.w	r3, [r8, #4]
    /* null size string */
    retval = ATSTATUS_OK;
 800d3f4:	469b      	mov	fp, r3
      }
      i++;
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
  }
  return (retval);
}
 800d3f6:	4658      	mov	r0, fp
 800d3f8:	b003      	add	sp, #12
 800d3fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d3fe:	4606      	mov	r6, r0
    uint16_t i = 0U;
 800d400:	2400      	movs	r4, #0
    bool leave_loop = false;
 800d402:	46a1      	mov	r9, r4
  at_status_t retval = ATSTATUS_ERROR;
 800d404:	f04f 0b01 	mov.w	fp, #1
 800d408:	e007      	b.n	800d41a <atcm_searchCmdInLUT+0x42>
      i++;
 800d40a:	3401      	adds	r4, #1
 800d40c:	b2a4      	uxth	r4, r4
    } while ((leave_loop == false) && (i < p_modem_ctxt->modem_LUT_size));
 800d40e:	f1b9 0f00 	cmp.w	r9, #0
 800d412:	d1f0      	bne.n	800d3f6 <atcm_searchCmdInLUT+0x1e>
 800d414:	6833      	ldr	r3, [r6, #0]
 800d416:	429c      	cmp	r4, r3
 800d418:	d2ed      	bcs.n	800d3f6 <atcm_searchCmdInLUT+0x1e>
      if (strlen((const CRC_CHAR_t *)(p_modem_ctxt->p_modem_LUT)[i].cmd_str) > 0U)
 800d41a:	6877      	ldr	r7, [r6, #4]
 800d41c:	eb04 0544 	add.w	r5, r4, r4, lsl #1
 800d420:	ea4f 1a05 	mov.w	sl, r5, lsl #4
 800d424:	eb07 1505 	add.w	r5, r7, r5, lsl #4
 800d428:	792b      	ldrb	r3, [r5, #4]
 800d42a:	2b00      	cmp	r3, #0
 800d42c:	d0ed      	beq.n	800d40a <atcm_searchCmdInLUT+0x32>
        if ((strlen((const CRC_CHAR_t *)(p_modem_ctxt->p_modem_LUT)[i].cmd_str) == element_infos->str_size))
 800d42e:	3504      	adds	r5, #4
 800d430:	4628      	mov	r0, r5
 800d432:	f7f2 fedf 	bl	80001f4 <strlen>
 800d436:	f8b8 200e 	ldrh.w	r2, [r8, #14]
 800d43a:	4290      	cmp	r0, r2
 800d43c:	d1e5      	bne.n	800d40a <atcm_searchCmdInLUT+0x32>
          if (0 == memcmp((const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 800d43e:	f8b8 000a 	ldrh.w	r0, [r8, #10]
 800d442:	4629      	mov	r1, r5
 800d444:	9b01      	ldr	r3, [sp, #4]
 800d446:	4418      	add	r0, r3
 800d448:	f019 fa61 	bl	802690e <memcmp>
 800d44c:	2800      	cmp	r0, #0
 800d44e:	d1dc      	bne.n	800d40a <atcm_searchCmdInLUT+0x32>
            PRINT_DBG("we received LUT#%ld : %s \r\n", (p_modem_ctxt->p_modem_LUT)[i].cmd_id,
 800d450:	f8df 904c 	ldr.w	r9, [pc, #76]	; 800d4a0 <atcm_searchCmdInLUT+0xc8>
 800d454:	462b      	mov	r3, r5
 800d456:	f857 200a 	ldr.w	r2, [r7, sl]
 800d45a:	4910      	ldr	r1, [pc, #64]	; (800d49c <atcm_searchCmdInLUT+0xc4>)
 800d45c:	4648      	mov	r0, r9
 800d45e:	f019 f9f3 	bl	8026848 <sprintf>
 800d462:	4648      	mov	r0, r9
 800d464:	f011 ff61 	bl	801f32a <crs_strlen>
 800d468:	b283      	uxth	r3, r0
 800d46a:	464a      	mov	r2, r9
 800d46c:	2102      	movs	r1, #2
 800d46e:	4608      	mov	r0, r1
 800d470:	f011 ff9e 	bl	801f3b0 <traceIF_itmPrint>
 800d474:	4648      	mov	r0, r9
 800d476:	f011 ff58 	bl	801f32a <crs_strlen>
 800d47a:	b283      	uxth	r3, r0
 800d47c:	464a      	mov	r2, r9
 800d47e:	2102      	movs	r1, #2
 800d480:	4608      	mov	r0, r1
 800d482:	f011 ffb7 	bl	801f3f4 <traceIF_uartPrint>
            element_infos->cmd_id_received = (p_modem_ctxt->p_modem_LUT)[i].cmd_id;
 800d486:	6873      	ldr	r3, [r6, #4]
 800d488:	f853 300a 	ldr.w	r3, [r3, sl]
 800d48c:	f8c8 3004 	str.w	r3, [r8, #4]
            leave_loop = true;
 800d490:	f04f 0901 	mov.w	r9, #1
            retval = ATSTATUS_OK;
 800d494:	f04f 0b00 	mov.w	fp, #0
 800d498:	e7b7      	b.n	800d40a <atcm_searchCmdInLUT+0x32>
 800d49a:	bf00      	nop
 800d49c:	0802eaa0 	.word	0x0802eaa0
 800d4a0:	200048dc 	.word	0x200048dc

0800d4a4 <atcm_check_text_line_cmd>:
  */
at_action_rsp_t atcm_check_text_line_cmd(atcustom_modem_context_t *p_modem_ctxt,
                                         at_context_t *p_at_ctxt,
                                         const IPC_RxMessage_t *p_msg_in,
                                         at_element_info_t *element_infos)
{
 800d4a4:	b508      	push	{r3, lr}
 800d4a6:	4686      	mov	lr, r0
 800d4a8:	4608      	mov	r0, r1
  const atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_ERROR;

  /* in this section, we treat all commands which can return text lines */
  switch (p_atp_ctxt->current_atcmd.id)
 800d4aa:	69c9      	ldr	r1, [r1, #28]
 800d4ac:	f1a1 0c0b 	sub.w	ip, r1, #11
 800d4b0:	f1bc 0f27 	cmp.w	ip, #39	; 0x27
 800d4b4:	d854      	bhi.n	800d560 <atcm_check_text_line_cmd+0xbc>
 800d4b6:	e8df f00c 	tbb	[pc, ip]
 800d4ba:	1b14      	.short	0x1b14
 800d4bc:	53452922 	.word	0x53452922
 800d4c0:	53535353 	.word	0x53535353
 800d4c4:	53535353 	.word	0x53535353
 800d4c8:	53535353 	.word	0x53535353
 800d4cc:	53535353 	.word	0x53535353
 800d4d0:	5353534c 	.word	0x5353534c
 800d4d4:	53535353 	.word	0x53535353
 800d4d8:	53535353 	.word	0x53535353
 800d4dc:	30535353 	.word	0x30535353
 800d4e0:	3e37      	.short	0x3e37
  {
    case CMD_AT_CGMI:
      if (fRspAnalyze_CGMI(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d4e2:	4671      	mov	r1, lr
 800d4e4:	f003 f8f2 	bl	80106cc <fRspAnalyze_CGMI>
 800d4e8:	2804      	cmp	r0, #4
 800d4ea:	d03a      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        retval = ATACTION_RSP_INTERMEDIATE;
 800d4ec:	2008      	movs	r0, #8
 800d4ee:	e038      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGMM:
      if (fRspAnalyze_CGMM(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d4f0:	4671      	mov	r1, lr
 800d4f2:	f003 f951 	bl	8010798 <fRspAnalyze_CGMM>
 800d4f6:	2804      	cmp	r0, #4
 800d4f8:	d033      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d4fa:	2008      	movs	r0, #8
 800d4fc:	e031      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGMR:
      if (fRspAnalyze_CGMR(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d4fe:	4671      	mov	r1, lr
 800d500:	f003 f9ac 	bl	801085c <fRspAnalyze_CGMR>
 800d504:	2804      	cmp	r0, #4
 800d506:	d02c      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d508:	2008      	movs	r0, #8
 800d50a:	e02a      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGSN:
      if (fRspAnalyze_CGSN(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d50c:	4671      	mov	r1, lr
 800d50e:	f003 fa09 	bl	8010924 <fRspAnalyze_CGSN>
 800d512:	2804      	cmp	r0, #4
 800d514:	d025      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d516:	2008      	movs	r0, #8
 800d518:	e023      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_GSN:
      if (fRspAnalyze_GSN(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d51a:	4671      	mov	r1, lr
 800d51c:	f006 fbf6 	bl	8013d0c <fRspAnalyze_GSN>
 800d520:	2804      	cmp	r0, #4
 800d522:	d01e      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d524:	2008      	movs	r0, #8
 800d526:	e01c      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_IPR:
      if (fRspAnalyze_IPR(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d528:	4671      	mov	r1, lr
 800d52a:	f006 fc57 	bl	8013ddc <fRspAnalyze_IPR>
 800d52e:	2804      	cmp	r0, #4
 800d530:	d017      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d532:	2008      	movs	r0, #8
 800d534:	e015      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_IFC:
      if (fRspAnalyze_IFC(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d536:	4671      	mov	r1, lr
 800d538:	f006 fcdc 	bl	8013ef4 <fRspAnalyze_IFC>
 800d53c:	2804      	cmp	r0, #4
 800d53e:	d010      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d540:	2008      	movs	r0, #8
 800d542:	e00e      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CIMI:
      if (fRspAnalyze_CIMI(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d544:	4671      	mov	r1, lr
 800d546:	f003 fb3d 	bl	8010bc4 <fRspAnalyze_CIMI>
 800d54a:	2804      	cmp	r0, #4
 800d54c:	d009      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d54e:	2008      	movs	r0, #8
 800d550:	e007      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
      }
      break;

    case CMD_AT_CGPADDR:
      if (fRspAnalyze_CGPADDR(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos) != ATACTION_RSP_ERROR)
 800d552:	4671      	mov	r1, lr
 800d554:	f005 ff08 	bl	8013368 <fRspAnalyze_CGPADDR>
 800d558:	2804      	cmp	r0, #4
 800d55a:	d002      	beq.n	800d562 <atcm_check_text_line_cmd+0xbe>
      {
        /* received a valid intermediate answer */
        retval = ATACTION_RSP_INTERMEDIATE;
 800d55c:	2008      	movs	r0, #8
 800d55e:	e000      	b.n	800d562 <atcm_check_text_line_cmd+0xbe>
  switch (p_atp_ctxt->current_atcmd.id)
 800d560:	2000      	movs	r0, #0
      retval = ATACTION_RSP_NO_ACTION;
      break;
  }

  return (retval);
}
 800d562:	bd08      	pop	{r3, pc}

0800d564 <atcm_retrieve_SID_parameters>:
  * @param  p_modem_ctxt
  * @param  p_atp_ctxt
  * @retval at_status_t
  */
at_status_t atcm_retrieve_SID_parameters(atcustom_modem_context_t *p_modem_ctxt, atparser_context_t *p_atp_ctxt)
{
 800d564:	b530      	push	{r4, r5, lr}
 800d566:	b083      	sub	sp, #12
  at_status_t retval = ATSTATUS_OK;

  /* only retrieve SID parameters on first call (step = 0)*/
  if (p_atp_ctxt->step == 0U)
 800d568:	788c      	ldrb	r4, [r1, #2]
 800d56a:	2c00      	cmp	r4, #0
 800d56c:	f040 821c 	bne.w	800d9a8 <atcm_retrieve_SID_parameters+0x444>
 800d570:	4605      	mov	r5, r0
 800d572:	468c      	mov	ip, r1
  {
    switch (p_atp_ctxt->current_SID)
 800d574:	880a      	ldrh	r2, [r1, #0]
 800d576:	f1a2 0364 	sub.w	r3, r2, #100	; 0x64
 800d57a:	2b2a      	cmp	r3, #42	; 0x2a
 800d57c:	f200 81fb 	bhi.w	800d976 <atcm_retrieve_SID_parameters+0x412>
 800d580:	e8df f013 	tbh	[pc, r3, lsl #1]
 800d584:	018b018b 	.word	0x018b018b
 800d588:	0039018b 	.word	0x0039018b
 800d58c:	00610047 	.word	0x00610047
 800d590:	007d006f 	.word	0x007d006f
 800d594:	018b018b 	.word	0x018b018b
 800d598:	00cf0054 	.word	0x00cf0054
 800d59c:	018b018b 	.word	0x018b018b
 800d5a0:	01a300dd 	.word	0x01a300dd
 800d5a4:	011701a3 	.word	0x011701a3
 800d5a8:	010900eb 	.word	0x010900eb
 800d5ac:	008b01f9 	.word	0x008b01f9
 800d5b0:	00a60098 	.word	0x00a60098
 800d5b4:	00b400a6 	.word	0x00b400a6
 800d5b8:	018b018b 	.word	0x018b018b
 800d5bc:	013600c1 	.word	0x013600c1
 800d5c0:	0125002b 	.word	0x0125002b
 800d5c4:	01430151 	.word	0x01430151
 800d5c8:	016f0162 	.word	0x016f0162
 800d5cc:	01bb017d 	.word	0x01bb017d
 800d5d0:	01d501c8 	.word	0x01d501c8
 800d5d4:	01d501d5 	.word	0x01d501d5
 800d5d8:	01ed      	.short	0x01ed
    {
      case SID_CS_MODEM_CONFIG:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d5da:	f500 63b6 	add.w	r3, r0, #1456	; 0x5b0
 800d5de:	2201      	movs	r2, #1
 800d5e0:	2126      	movs	r1, #38	; 0x26
 800d5e2:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d5e6:	f7fe fe85 	bl	800c2f4 <DATAPACK_readStruct>
 800d5ea:	4604      	mov	r4, r0
 800d5ec:	2800      	cmp	r0, #0
 800d5ee:	f000 81dc 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_MODEMCONFIG,
                                (uint16_t) sizeof(CS_ModemConfig_t),
                                (void *)&p_modem_ctxt->SID_ctxt.modem_config) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d5f2:	2401      	movs	r4, #1
 800d5f4:	e1d9      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_INIT_MODEM:
        /* retrieve  client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d5f6:	f200 53b1 	addw	r3, r0, #1457	; 0x5b1
 800d5fa:	2212      	movs	r2, #18
 800d5fc:	4611      	mov	r1, r2
 800d5fe:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d602:	f7fe fe77 	bl	800c2f4 <DATAPACK_readStruct>
 800d606:	4604      	mov	r4, r0
 800d608:	2800      	cmp	r0, #0
 800d60a:	f000 81ce 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_INITMODEM,
                                (uint16_t) sizeof(csint_modemInit_t),
                                (void *)&p_modem_ctxt->SID_ctxt.modem_init) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d60e:	2401      	movs	r4, #1
 800d610:	e1cb      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_GET_DEVICE_INFO:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d612:	f200 52c4 	addw	r2, r0, #1476	; 0x5c4
 800d616:	2117      	movs	r1, #23
 800d618:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d61c:	f7fe fe3e 	bl	800c29c <DATAPACK_readPtr>
 800d620:	4604      	mov	r4, r0
 800d622:	2800      	cmp	r0, #0
 800d624:	f000 81c1 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_DEVICE_INFO,
                             (void **)&p_modem_ctxt->SID_ctxt.device_info) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d628:	2401      	movs	r4, #1
 800d62a:	e1be      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_GET_SIGNAL_QUALITY:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d62c:	f500 62cc 	add.w	r2, r0, #1632	; 0x660
 800d630:	211d      	movs	r1, #29
 800d632:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d636:	f7fe fe31 	bl	800c29c <DATAPACK_readPtr>
 800d63a:	4604      	mov	r4, r0
 800d63c:	2800      	cmp	r0, #0
 800d63e:	f000 81b4 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SIGNAL_QUALITY,
                             (void **)&p_modem_ctxt->SID_ctxt.signal_quality) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d642:	2401      	movs	r4, #1
 800d644:	e1b1      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_REGISTER_NET:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d646:	f500 63b9 	add.w	r3, r0, #1480	; 0x5c8
 800d64a:	2248      	movs	r2, #72	; 0x48
 800d64c:	2114      	movs	r1, #20
 800d64e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d652:	f7fe fe4f 	bl	800c2f4 <DATAPACK_readStruct>
 800d656:	4604      	mov	r4, r0
 800d658:	2800      	cmp	r0, #0
 800d65a:	f000 81a6 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_OPERATORSELECT,
                                (uint16_t) sizeof(CS_OperatorSelector_t),
                                (void *)&p_modem_ctxt->SID_ctxt.write_operator_infos) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d65e:	2401      	movs	r4, #1
 800d660:	e1a3      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SUSBCRIBE_NET_EVENT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d662:	f200 6364 	addw	r3, r0, #1636	; 0x664
 800d666:	2201      	movs	r2, #1
 800d668:	2116      	movs	r1, #22
 800d66a:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d66e:	f7fe fe41 	bl	800c2f4 <DATAPACK_readStruct>
 800d672:	4604      	mov	r4, r0
 800d674:	2800      	cmp	r0, #0
 800d676:	f000 8198 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_URC_EVENT,
                                (uint16_t) sizeof(CS_UrcEvent_t),
                                (void *)&p_modem_ctxt->SID_ctxt.urcEvent) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d67a:	2401      	movs	r4, #1
 800d67c:	e195      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_UNSUSBCRIBE_NET_EVENT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d67e:	f200 6364 	addw	r3, r0, #1636	; 0x664
 800d682:	2201      	movs	r2, #1
 800d684:	2116      	movs	r1, #22
 800d686:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d68a:	f7fe fe33 	bl	800c2f4 <DATAPACK_readStruct>
 800d68e:	4604      	mov	r4, r0
 800d690:	2800      	cmp	r0, #0
 800d692:	f000 818a 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_URC_EVENT,
                                (uint16_t) sizeof(CS_UrcEvent_t),
                                (void *)&p_modem_ctxt->SID_ctxt.urcEvent) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d696:	2401      	movs	r4, #1
 800d698:	e187      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DIAL_COMMAND:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d69a:	f500 62e8 	add.w	r2, r0, #1856	; 0x740
 800d69e:	2118      	movs	r1, #24
 800d6a0:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6a4:	f7fe fdfa 	bl	800c29c <DATAPACK_readPtr>
 800d6a8:	4604      	mov	r4, r0
 800d6aa:	2800      	cmp	r0, #0
 800d6ac:	f000 817d 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SOCKET_INFO,
                             (void **)&p_modem_ctxt->socket_ctxt.socket_info) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d6b0:	2401      	movs	r4, #1
 800d6b2:	e17a      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SEND_DATA:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d6b4:	f500 63ce 	add.w	r3, r0, #1648	; 0x670
 800d6b8:	2258      	movs	r2, #88	; 0x58
 800d6ba:	2119      	movs	r1, #25
 800d6bc:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6c0:	f7fe fe18 	bl	800c2f4 <DATAPACK_readStruct>
 800d6c4:	4604      	mov	r4, r0
 800d6c6:	2800      	cmp	r0, #0
 800d6c8:	f000 816f 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SOCKET_DATA_BUFFER,
                                (uint16_t) sizeof(csint_socket_data_buffer_t),
                                &p_modem_ctxt->SID_ctxt.socketSendData_struct) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d6cc:	2401      	movs	r4, #1
 800d6ce:	e16c      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        break;

      case SID_CS_RECEIVE_DATA:
      case SID_CS_RECEIVE_DATA_FROM:
        /* retrieve pointer on client structure */
        if (DATAPACK_readStruct(p_atp_ctxt->p_cmd_input,
 800d6d0:	f200 7344 	addw	r3, r0, #1860	; 0x744
 800d6d4:	2258      	movs	r2, #88	; 0x58
 800d6d6:	2119      	movs	r1, #25
 800d6d8:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6dc:	f7fe fe0a 	bl	800c2f4 <DATAPACK_readStruct>
 800d6e0:	4604      	mov	r4, r0
 800d6e2:	2800      	cmp	r0, #0
 800d6e4:	f000 8161 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SOCKET_DATA_BUFFER,
                                (uint16_t) sizeof(csint_socket_data_buffer_t),
                                (void *)&p_modem_ctxt->socket_ctxt.socketReceivedata) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d6e8:	2401      	movs	r4, #1
 800d6ea:	e15e      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SOCKET_CLOSE:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d6ec:	f500 62e8 	add.w	r2, r0, #1856	; 0x740
 800d6f0:	2118      	movs	r1, #24
 800d6f2:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d6f6:	f7fe fdd1 	bl	800c29c <DATAPACK_readPtr>
 800d6fa:	4604      	mov	r4, r0
 800d6fc:	2800      	cmp	r0, #0
 800d6fe:	f000 8154 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SOCKET_INFO,
                             (void **)&p_modem_ctxt->socket_ctxt.socket_info) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d702:	2401      	movs	r4, #1
 800d704:	e151      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_RESET:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d706:	f500 63d9 	add.w	r3, r0, #1736	; 0x6c8
 800d70a:	2201      	movs	r2, #1
 800d70c:	2120      	movs	r1, #32
 800d70e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d712:	f7fe fdef 	bl	800c2f4 <DATAPACK_readStruct>
 800d716:	4604      	mov	r4, r0
 800d718:	2800      	cmp	r0, #0
 800d71a:	f000 8146 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_RESET,
                                (uint16_t) sizeof(CS_Reset_t),
                                (void *)&p_modem_ctxt->SID_ctxt.reset_type) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d71e:	2401      	movs	r4, #1
 800d720:	e143      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_ACTIVATE_PDN:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d722:	f200 63c9 	addw	r3, r0, #1737	; 0x6c9
 800d726:	2201      	movs	r2, #1
 800d728:	2121      	movs	r1, #33	; 0x21
 800d72a:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d72e:	f7fe fde1 	bl	800c2f4 <DATAPACK_readStruct>
 800d732:	4604      	mov	r4, r0
 800d734:	2800      	cmp	r0, #0
 800d736:	f000 8138 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_ACTIVATE_PDN,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->SID_ctxt.pdn_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d73a:	2401      	movs	r4, #1
 800d73c:	e135      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DEACTIVATE_PDN:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d73e:	f200 63c9 	addw	r3, r0, #1737	; 0x6c9
 800d742:	2201      	movs	r2, #1
 800d744:	2122      	movs	r1, #34	; 0x22
 800d746:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d74a:	f7fe fdd3 	bl	800c2f4 <DATAPACK_readStruct>
 800d74e:	4604      	mov	r4, r0
 800d750:	2800      	cmp	r0, #0
 800d752:	f000 812a 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_DEACTIVATE_PDN,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->SID_ctxt.pdn_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d756:	2401      	movs	r4, #1
 800d758:	e127      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_DEFINE_PDN:
      {
        csint_pdn_infos_t *ptr_pdn_infos;
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d75a:	aa01      	add	r2, sp, #4
 800d75c:	2123      	movs	r1, #35	; 0x23
 800d75e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d762:	f7fe fd9b 	bl	800c29c <DATAPACK_readPtr>
 800d766:	4604      	mov	r4, r0
 800d768:	b108      	cbz	r0, 800d76e <atcm_retrieve_SID_parameters+0x20a>
          /* affect a modem cid to this configuration */
          affect_modem_cid(&p_modem_ctxt->persist, ptr_pdn_infos->conf_id);
        }
        else
        {
          retval = ATSTATUS_ERROR;
 800d76a:	2401      	movs	r4, #1
        }
        break;
 800d76c:	e11d      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
          (void) memcpy((void *)&p_modem_ctxt->persist.pdp_ctxt_infos[ptr_pdn_infos->conf_id],
 800d76e:	9901      	ldr	r1, [sp, #4]
 800d770:	780b      	ldrb	r3, [r1, #0]
 800d772:	eb03 1383 	add.w	r3, r3, r3, lsl #6
 800d776:	0058      	lsls	r0, r3, #1
 800d778:	3048      	adds	r0, #72	; 0x48
 800d77a:	4428      	add	r0, r5
 800d77c:	2282      	movs	r2, #130	; 0x82
 800d77e:	3008      	adds	r0, #8
 800d780:	f019 f9b2 	bl	8026ae8 <memcpy>
          p_modem_ctxt->SID_ctxt.pdn_conf_id = ptr_pdn_infos->conf_id;
 800d784:	9b01      	ldr	r3, [sp, #4]
 800d786:	7819      	ldrb	r1, [r3, #0]
 800d788:	f885 16c9 	strb.w	r1, [r5, #1737]	; 0x6c9
          affect_modem_cid(&p_modem_ctxt->persist, ptr_pdn_infos->conf_id);
 800d78c:	f105 000c 	add.w	r0, r5, #12
 800d790:	f7fe ffb8 	bl	800c704 <affect_modem_cid>
 800d794:	e109      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
      }

      case SID_CS_SET_DEFAULT_PDN:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d796:	f200 43f4 	addw	r3, r0, #1268	; 0x4f4
 800d79a:	2201      	movs	r2, #1
 800d79c:	2124      	movs	r1, #36	; 0x24
 800d79e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7a2:	f7fe fda7 	bl	800c2f4 <DATAPACK_readStruct>
 800d7a6:	4604      	mov	r4, r0
 800d7a8:	2800      	cmp	r0, #0
 800d7aa:	f000 80fe 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SET_DEFAULT_PDN,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->persist.pdn_default_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d7ae:	2401      	movs	r4, #1
 800d7b0:	e0fb      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_GET_IP_ADDRESS:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d7b2:	f200 63c9 	addw	r3, r0, #1737	; 0x6c9
 800d7b6:	2201      	movs	r2, #1
 800d7b8:	2125      	movs	r1, #37	; 0x25
 800d7ba:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7be:	f7fe fd99 	bl	800c2f4 <DATAPACK_readStruct>
 800d7c2:	4604      	mov	r4, r0
 800d7c4:	2800      	cmp	r0, #0
 800d7c6:	f000 80f0 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_GET_IP_ADDRESS,
                                (uint16_t) sizeof(CS_PDN_conf_id_t),
                                (void *)&p_modem_ctxt->SID_ctxt.pdn_conf_id) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d7ca:	2401      	movs	r4, #1
 800d7cc:	e0ed      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DNS_REQ:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d7ce:	f200 62cc 	addw	r2, r0, #1740	; 0x6cc
 800d7d2:	2127      	movs	r1, #39	; 0x27
 800d7d4:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7d8:	f7fe fd60 	bl	800c29c <DATAPACK_readPtr>
 800d7dc:	4604      	mov	r4, r0
 800d7de:	2800      	cmp	r0, #0
 800d7e0:	f040 80e6 	bne.w	800d9b0 <atcm_retrieve_SID_parameters+0x44c>
                             (uint16_t) CSMT_DNS_REQ,
                             (void **)&p_modem_ctxt->SID_ctxt.dns_request_infos) == DATAPACK_OK)
        {
          /* set SID ctxt pdn conf id */
          p_modem_ctxt->SID_ctxt.pdn_conf_id = p_modem_ctxt->SID_ctxt.dns_request_infos->conf_id;
 800d7e4:	f8d5 36cc 	ldr.w	r3, [r5, #1740]	; 0x6cc
 800d7e8:	781b      	ldrb	r3, [r3, #0]
 800d7ea:	f885 36c9 	strb.w	r3, [r5, #1737]	; 0x6c9
 800d7ee:	e0dc      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SOCKET_CNX_STATUS:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d7f0:	f500 62f5 	add.w	r2, r0, #1960	; 0x7a8
 800d7f4:	211c      	movs	r1, #28
 800d7f6:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d7fa:	f7fe fd4f 	bl	800c29c <DATAPACK_readPtr>
 800d7fe:	4604      	mov	r4, r0
 800d800:	2800      	cmp	r0, #0
 800d802:	f000 80d2 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_SOCKET_CNX_STATUS,
                             (void **)&p_modem_ctxt->socket_ctxt.socket_cnx_infos) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d806:	2401      	movs	r4, #1
 800d808:	e0cf      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SUSBCRIBE_MODEM_EVENT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d80a:	f100 0322 	add.w	r3, r0, #34	; 0x22
 800d80e:	2202      	movs	r2, #2
 800d810:	2129      	movs	r1, #41	; 0x29
 800d812:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d816:	f7fe fd6d 	bl	800c2f4 <DATAPACK_readStruct>
 800d81a:	4604      	mov	r4, r0
 800d81c:	2800      	cmp	r0, #0
 800d81e:	f000 80c4 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_MODEM_EVENT,
                                (uint16_t) sizeof(CS_ModemEvent_t),
                                (void *)&p_modem_ctxt->persist.modem_events_subscript) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d822:	2401      	movs	r4, #1
 800d824:	e0c1      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_PING_IP_ADDRESS:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d826:	f500 63da 	add.w	r3, r0, #1744	; 0x6d0
 800d82a:	2243      	movs	r2, #67	; 0x43
 800d82c:	2128      	movs	r1, #40	; 0x28
 800d82e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d832:	f7fe fd5f 	bl	800c2f4 <DATAPACK_readStruct>
 800d836:	4604      	mov	r4, r0
 800d838:	2800      	cmp	r0, #0
 800d83a:	f040 80bb 	bne.w	800d9b4 <atcm_retrieve_SID_parameters+0x450>
                                (uint16_t) CSMT_PING_ADDRESS,
                                (uint16_t) sizeof(csint_ping_params_t),
                                (void *)&p_modem_ctxt->SID_ctxt.ping_infos) == DATAPACK_OK)
        {
          /* set SID ctxt pdn conf id */
          p_modem_ctxt->SID_ctxt.pdn_conf_id = p_modem_ctxt->SID_ctxt.ping_infos.conf_id;
 800d83e:	f895 36d0 	ldrb.w	r3, [r5, #1744]	; 0x6d0
 800d842:	f885 36c9 	strb.w	r3, [r5, #1737]	; 0x6c9
 800d846:	e0b0      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_DIRECT_CMD:
        /* retrieve pointer on client structure */
        if (DATAPACK_readPtr(p_atp_ctxt->p_cmd_input,
 800d848:	f200 7214 	addw	r2, r0, #1812	; 0x714
 800d84c:	212b      	movs	r1, #43	; 0x2b
 800d84e:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d852:	f7fe fd23 	bl	800c29c <DATAPACK_readPtr>
 800d856:	4604      	mov	r4, r0
 800d858:	2800      	cmp	r0, #0
 800d85a:	f000 80a6 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                             (uint16_t) CSMT_DIRECT_CMD,
                             (void **)&p_modem_ctxt->SID_ctxt.direct_cmd_tx) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d85e:	2401      	movs	r4, #1
 800d860:	e0a3      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SIM_SELECT:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d862:	f200 5312 	addw	r3, r0, #1298	; 0x512
 800d866:	2201      	movs	r2, #1
 800d868:	212c      	movs	r1, #44	; 0x2c
 800d86a:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d86e:	f7fe fd41 	bl	800c2f4 <DATAPACK_readStruct>
 800d872:	4604      	mov	r4, r0
 800d874:	2800      	cmp	r0, #0
 800d876:	f000 8098 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SIM_SELECT,
                                (uint16_t) sizeof(CS_SimSlot_t),
                                (void *)&p_modem_ctxt->persist.sim_selected) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d87a:	2401      	movs	r4, #1
 800d87c:	e095      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SIM_GENERIC_ACCESS:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d87e:	f500 63cd 	add.w	r3, r0, #1640	; 0x668
 800d882:	2208      	movs	r2, #8
 800d884:	212d      	movs	r1, #45	; 0x2d
 800d886:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d88a:	f7fe fd33 	bl	800c2f4 <DATAPACK_readStruct>
 800d88e:	4604      	mov	r4, r0
 800d890:	2800      	cmp	r0, #0
 800d892:	f000 808a 	beq.w	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SIM_GENERIC_ACCESS,
                                (uint16_t) sizeof(csint_sim_generic_access_t),
                                &p_modem_ctxt->SID_ctxt.sim_generic_access) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d896:	2401      	movs	r4, #1
 800d898:	e087      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
      case SID_CS_GET_ATTACHSTATUS:
      case SID_ATTACH_PS_DOMAIN:
      case SID_DETACH_PS_DOMAIN:
      case SID_CS_DATA_SUSPEND:
      case SID_CS_DATA_RESUME:
        PRINT_DBG("No data to unpack for SID %d", p_atp_ctxt->current_SID)
 800d89a:	4d47      	ldr	r5, [pc, #284]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d89c:	4947      	ldr	r1, [pc, #284]	; (800d9bc <atcm_retrieve_SID_parameters+0x458>)
 800d89e:	4628      	mov	r0, r5
 800d8a0:	f018 ffd2 	bl	8026848 <sprintf>
 800d8a4:	4628      	mov	r0, r5
 800d8a6:	f011 fd40 	bl	801f32a <crs_strlen>
 800d8aa:	b283      	uxth	r3, r0
 800d8ac:	462a      	mov	r2, r5
 800d8ae:	2102      	movs	r1, #2
 800d8b0:	4608      	mov	r0, r1
 800d8b2:	f011 fd7d 	bl	801f3b0 <traceIF_itmPrint>
 800d8b6:	4628      	mov	r0, r5
 800d8b8:	f011 fd37 	bl	801f32a <crs_strlen>
 800d8bc:	b283      	uxth	r3, r0
 800d8be:	462a      	mov	r2, r5
 800d8c0:	2102      	movs	r1, #2
 800d8c2:	4608      	mov	r0, r1
 800d8c4:	f011 fd96 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800d8c8:	e06f      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_REGISTER_PDN_EVENT:
      case SID_CS_DEREGISTER_PDN_EVENT:
        PRINT_DBG("No data to unpack for SID %d", p_atp_ctxt->current_SID)
 800d8ca:	4d3b      	ldr	r5, [pc, #236]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d8cc:	493b      	ldr	r1, [pc, #236]	; (800d9bc <atcm_retrieve_SID_parameters+0x458>)
 800d8ce:	4628      	mov	r0, r5
 800d8d0:	f018 ffba 	bl	8026848 <sprintf>
 800d8d4:	4628      	mov	r0, r5
 800d8d6:	f011 fd28 	bl	801f32a <crs_strlen>
 800d8da:	b283      	uxth	r3, r0
 800d8dc:	462a      	mov	r2, r5
 800d8de:	2102      	movs	r1, #2
 800d8e0:	4608      	mov	r0, r1
 800d8e2:	f011 fd65 	bl	801f3b0 <traceIF_itmPrint>
 800d8e6:	4628      	mov	r0, r5
 800d8e8:	f011 fd1f 	bl	801f32a <crs_strlen>
 800d8ec:	b283      	uxth	r3, r0
 800d8ee:	462a      	mov	r2, r5
 800d8f0:	2102      	movs	r1, #2
 800d8f2:	4608      	mov	r0, r1
 800d8f4:	f011 fd7e 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800d8f8:	e057      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_INIT_POWER_CONFIG:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d8fa:	f500 63e3 	add.w	r3, r0, #1816	; 0x718
 800d8fe:	2207      	movs	r2, #7
 800d900:	212e      	movs	r1, #46	; 0x2e
 800d902:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d906:	f7fe fcf5 	bl	800c2f4 <DATAPACK_readStruct>
 800d90a:	4604      	mov	r4, r0
 800d90c:	2800      	cmp	r0, #0
 800d90e:	d04c      	beq.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_INIT_POWER_CONFIG,
                                (uint16_t) sizeof(CS_init_power_config_t),
                                (void *)&p_modem_ctxt->SID_ctxt.init_power_config) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d910:	2401      	movs	r4, #1
 800d912:	e04a      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        }
        break;

      case SID_CS_SET_POWER_CONFIG:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d914:	f200 731f 	addw	r3, r0, #1823	; 0x71f
 800d918:	220a      	movs	r2, #10
 800d91a:	212f      	movs	r1, #47	; 0x2f
 800d91c:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d920:	f7fe fce8 	bl	800c2f4 <DATAPACK_readStruct>
 800d924:	4604      	mov	r4, r0
 800d926:	2800      	cmp	r0, #0
 800d928:	d03f      	beq.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_SET_POWER_CONFIG,
                                (uint16_t) sizeof(CS_set_power_config_t),
                                (void *)&p_modem_ctxt->SID_ctxt.set_power_config) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d92a:	2401      	movs	r4, #1
 800d92c:	e03d      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>


      case SID_CS_SLEEP_REQUEST:
      case SID_CS_SLEEP_COMPLETE:
      case SID_CS_SLEEP_CANCEL:
        PRINT_DBG("No data to unpack for SID %d", p_atp_ctxt->current_SID)
 800d92e:	4d22      	ldr	r5, [pc, #136]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d930:	4922      	ldr	r1, [pc, #136]	; (800d9bc <atcm_retrieve_SID_parameters+0x458>)
 800d932:	4628      	mov	r0, r5
 800d934:	f018 ff88 	bl	8026848 <sprintf>
 800d938:	4628      	mov	r0, r5
 800d93a:	f011 fcf6 	bl	801f32a <crs_strlen>
 800d93e:	b283      	uxth	r3, r0
 800d940:	462a      	mov	r2, r5
 800d942:	2102      	movs	r1, #2
 800d944:	4608      	mov	r0, r1
 800d946:	f011 fd33 	bl	801f3b0 <traceIF_itmPrint>
 800d94a:	4628      	mov	r0, r5
 800d94c:	f011 fced 	bl	801f32a <crs_strlen>
 800d950:	b283      	uxth	r3, r0
 800d952:	462a      	mov	r2, r5
 800d954:	2102      	movs	r1, #2
 800d956:	4608      	mov	r0, r1
 800d958:	f011 fd4c 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800d95c:	e025      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>

      case SID_CS_WAKEUP:
        /* retrieve client data */
        if (DATAPACK_readStruct((uint8_t *)p_atp_ctxt->p_cmd_input,
 800d95e:	f200 7329 	addw	r3, r0, #1833	; 0x729
 800d962:	2201      	movs	r2, #1
 800d964:	2130      	movs	r1, #48	; 0x30
 800d966:	f8dc 067c 	ldr.w	r0, [ip, #1660]	; 0x67c
 800d96a:	f7fe fcc3 	bl	800c2f4 <DATAPACK_readStruct>
 800d96e:	4604      	mov	r4, r0
 800d970:	b1d8      	cbz	r0, 800d9aa <atcm_retrieve_SID_parameters+0x446>
                                (uint16_t) CSMT_WAKEUP_ORIGIN,
                                (uint16_t) sizeof(CS_wakeup_origin_t),
                                (void *)&p_modem_ctxt->SID_ctxt.wakeup_origin) != DATAPACK_OK)
        {
          retval = ATSTATUS_ERROR;
 800d972:	2401      	movs	r4, #1
 800d974:	e019      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
        SID_CS_SOCKET_CREATE, - not needed, config is done at CS level
        SID_CS_SOCKET_SET_OPTION, - not needed, config is done at CS level
        SID_CS_SOCKET_GET_OPTION, - not needed, config is done at CS level
        ***************/
      default:
        PRINT_ERR("Missing treatment for SID %d", p_atp_ctxt->current_SID)
 800d976:	4c10      	ldr	r4, [pc, #64]	; (800d9b8 <atcm_retrieve_SID_parameters+0x454>)
 800d978:	4911      	ldr	r1, [pc, #68]	; (800d9c0 <atcm_retrieve_SID_parameters+0x45c>)
 800d97a:	4620      	mov	r0, r4
 800d97c:	f018 ff64 	bl	8026848 <sprintf>
 800d980:	4620      	mov	r0, r4
 800d982:	f011 fcd2 	bl	801f32a <crs_strlen>
 800d986:	b283      	uxth	r3, r0
 800d988:	4622      	mov	r2, r4
 800d98a:	2110      	movs	r1, #16
 800d98c:	2002      	movs	r0, #2
 800d98e:	f011 fd0f 	bl	801f3b0 <traceIF_itmPrint>
 800d992:	4620      	mov	r0, r4
 800d994:	f011 fcc9 	bl	801f32a <crs_strlen>
 800d998:	b283      	uxth	r3, r0
 800d99a:	4622      	mov	r2, r4
 800d99c:	2110      	movs	r1, #16
 800d99e:	2002      	movs	r0, #2
 800d9a0:	f011 fd28 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATSTATUS_ERROR;
 800d9a4:	2401      	movs	r4, #1
        break;
 800d9a6:	e000      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
  at_status_t retval = ATSTATUS_OK;
 800d9a8:	2400      	movs	r4, #0
    }

  }

  return (retval);
}
 800d9aa:	4620      	mov	r0, r4
 800d9ac:	b003      	add	sp, #12
 800d9ae:	bd30      	pop	{r4, r5, pc}
          retval = ATSTATUS_ERROR;
 800d9b0:	2401      	movs	r4, #1
 800d9b2:	e7fa      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
          retval = ATSTATUS_ERROR;
 800d9b4:	2401      	movs	r4, #1
 800d9b6:	e7f8      	b.n	800d9aa <atcm_retrieve_SID_parameters+0x446>
 800d9b8:	200048dc 	.word	0x200048dc
 800d9bc:	0802eac8 	.word	0x0802eac8
 800d9c0:	0802eaf0 	.word	0x0802eaf0

0800d9c4 <atcm_get_affected_modem_cid>:
  * @param  p_persistent_ctxt
  * @param  conf_id
  * @retval uint8_t affected modem CID
  */
uint8_t atcm_get_affected_modem_cid(atcustom_persistent_context_t *p_persistent_ctxt, CS_PDN_conf_id_t conf_id)
{
 800d9c4:	b570      	push	{r4, r5, r6, lr}
 800d9c6:	4604      	mov	r4, r0
 800d9c8:	460d      	mov	r5, r1
  uint8_t retval = 1U; /* return first valid cid by default (do not return 0 which is a special cid value !!!) */
  CS_PDN_conf_id_t current_conf_id = conf_id;

  /* if default PDN is required, retrieve corresponding conf_id */
  if (conf_id == CS_PDN_CONFIG_DEFAULT)
 800d9ca:	290b      	cmp	r1, #11
 800d9cc:	d003      	beq.n	800d9d6 <atcm_get_affected_modem_cid+0x12>
    current_conf_id = p_persistent_ctxt->pdn_default_conf_id;
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
  }

  bool leave_loop = false;
  uint8_t i = 0U;
 800d9ce:	2300      	movs	r3, #0
  bool leave_loop = false;
 800d9d0:	4619      	mov	r1, r3
  uint8_t retval = 1U; /* return first valid cid by default (do not return 0 which is a special cid value !!!) */
 800d9d2:	2001      	movs	r0, #1
 800d9d4:	e01f      	b.n	800da16 <atcm_get_affected_modem_cid+0x52>
    current_conf_id = p_persistent_ctxt->pdn_default_conf_id;
 800d9d6:	f890 54e8 	ldrb.w	r5, [r0, #1256]	; 0x4e8
    PRINT_DBG("Default PDP context selected (conf_id = %d)", current_conf_id)
 800d9da:	4e17      	ldr	r6, [pc, #92]	; (800da38 <atcm_get_affected_modem_cid+0x74>)
 800d9dc:	462a      	mov	r2, r5
 800d9de:	4917      	ldr	r1, [pc, #92]	; (800da3c <atcm_get_affected_modem_cid+0x78>)
 800d9e0:	4630      	mov	r0, r6
 800d9e2:	f018 ff31 	bl	8026848 <sprintf>
 800d9e6:	4630      	mov	r0, r6
 800d9e8:	f011 fc9f 	bl	801f32a <crs_strlen>
 800d9ec:	b283      	uxth	r3, r0
 800d9ee:	4632      	mov	r2, r6
 800d9f0:	2102      	movs	r1, #2
 800d9f2:	4608      	mov	r0, r1
 800d9f4:	f011 fcdc 	bl	801f3b0 <traceIF_itmPrint>
 800d9f8:	4630      	mov	r0, r6
 800d9fa:	f011 fc96 	bl	801f32a <crs_strlen>
 800d9fe:	b283      	uxth	r3, r0
 800da00:	4632      	mov	r2, r6
 800da02:	2102      	movs	r1, #2
 800da04:	4608      	mov	r0, r1
 800da06:	f011 fcf5 	bl	801f3f4 <traceIF_uartPrint>
 800da0a:	e7e0      	b.n	800d9ce <atcm_get_affected_modem_cid+0xa>
    {
      /* return affected modem cid */
      retval = p_tmp->mdm_cid_value;
      leave_loop = true;
    }
    i++;
 800da0c:	3301      	adds	r3, #1
 800da0e:	b2db      	uxtb	r3, r3
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800da10:	b989      	cbnz	r1, 800da36 <atcm_get_affected_modem_cid+0x72>
 800da12:	2b05      	cmp	r3, #5
 800da14:	d80f      	bhi.n	800da36 <atcm_get_affected_modem_cid+0x72>
    if (p_tmp->affected_config == current_conf_id)
 800da16:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da1a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800da1e:	f892 2352 	ldrb.w	r2, [r2, #850]	; 0x352
 800da22:	42aa      	cmp	r2, r5
 800da24:	d1f2      	bne.n	800da0c <atcm_get_affected_modem_cid+0x48>
      retval = p_tmp->mdm_cid_value;
 800da26:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da2a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 800da2e:	f892 0350 	ldrb.w	r0, [r2, #848]	; 0x350
      leave_loop = true;
 800da32:	2101      	movs	r1, #1
 800da34:	e7ea      	b.n	800da0c <atcm_get_affected_modem_cid+0x48>

  return (retval);
}
 800da36:	bd70      	pop	{r4, r5, r6, pc}
 800da38:	200048dc 	.word	0x200048dc
 800da3c:	0802e864 	.word	0x0802e864

0800da40 <atcm_get_configID_for_modem_cid>:
  * @param  modem_cid
  * @retval CS_PDN_conf_id_t
  */
CS_PDN_conf_id_t atcm_get_configID_for_modem_cid(const atcustom_persistent_context_t *p_persistent_ctxt,
                                                 uint8_t modem_cid)
{
 800da40:	b410      	push	{r4}
 800da42:	4684      	mov	ip, r0
  CS_PDN_conf_id_t retval = CS_PDN_NOT_DEFINED;
  bool leave_loop = false;
  uint8_t i = 0U;
 800da44:	2300      	movs	r3, #0
  bool leave_loop = false;
 800da46:	461c      	mov	r4, r3
  CS_PDN_conf_id_t retval = CS_PDN_NOT_DEFINED;
 800da48:	200c      	movs	r0, #12
 800da4a:	e004      	b.n	800da56 <atcm_get_configID_for_modem_cid+0x16>
    {
      /* return corresponding Used Config ID */
      retval = p_tmp->affected_config;
      leave_loop = true;
    }
    i++;
 800da4c:	3301      	adds	r3, #1
 800da4e:	b2db      	uxtb	r3, r3
  } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800da50:	b98c      	cbnz	r4, 800da76 <atcm_get_configID_for_modem_cid+0x36>
 800da52:	2b05      	cmp	r3, #5
 800da54:	d80f      	bhi.n	800da76 <atcm_get_configID_for_modem_cid+0x36>
    if (p_tmp->mdm_cid_value == modem_cid)
 800da56:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da5a:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
 800da5e:	f892 2350 	ldrb.w	r2, [r2, #848]	; 0x350
 800da62:	428a      	cmp	r2, r1
 800da64:	d1f2      	bne.n	800da4c <atcm_get_configID_for_modem_cid+0xc>
      retval = p_tmp->affected_config;
 800da66:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 800da6a:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
 800da6e:	f892 0352 	ldrb.w	r0, [r2, #850]	; 0x352
      leave_loop = true;
 800da72:	2401      	movs	r4, #1
 800da74:	e7ea      	b.n	800da4c <atcm_get_configID_for_modem_cid+0xc>

  return (retval);
}
 800da76:	f85d 4b04 	ldr.w	r4, [sp], #4
 800da7a:	4770      	bx	lr

0800da7c <atcm_convert_index_to_PDN_conf>:
  * @retval CS_PDN_conf_id_t
  */
CS_PDN_conf_id_t atcm_convert_index_to_PDN_conf(uint8_t index)
{
  CS_PDN_conf_id_t PDNconf;
  switch (index)
 800da7c:	2805      	cmp	r0, #5
 800da7e:	d804      	bhi.n	800da8a <atcm_convert_index_to_PDN_conf+0xe>
 800da80:	e8df f000 	tbb	[pc, r0]
 800da84:	04040404 	.word	0x04040404
 800da88:	0404      	.short	0x0404
      break;
    case 5:
      PDNconf = CS_PDN_USER_CONFIG_5;
      break;
    default:
      PDNconf = CS_PDN_NOT_DEFINED;
 800da8a:	200c      	movs	r0, #12
      break;
  }
  return (PDNconf);
}
 800da8c:	4770      	bx	lr
	...

0800da90 <reserve_user_modem_cid>:
{
 800da90:	b538      	push	{r3, r4, r5, lr}
 800da92:	4605      	mov	r5, r0
 800da94:	4614      	mov	r4, r2
  CS_PDN_conf_id_t user_pdn_conf = atcm_convert_index_to_PDN_conf(reserved_user_modem_cid);
 800da96:	4610      	mov	r0, r2
 800da98:	f7ff fff0 	bl	800da7c <atcm_convert_index_to_PDN_conf>
      (user_pdn_conf == CS_PDN_USER_CONFIG_4) ||
 800da9c:	1e43      	subs	r3, r0, #1
 800da9e:	b2db      	uxtb	r3, r3
  if ((user_pdn_conf == CS_PDN_USER_CONFIG_1) ||
 800daa0:	2b04      	cmp	r3, #4
 800daa2:	d925      	bls.n	800daf0 <reserve_user_modem_cid+0x60>
    PRINT_ERR("Trying to affect a non-valid modem CID")
 800daa4:	4c1f      	ldr	r4, [pc, #124]	; (800db24 <reserve_user_modem_cid+0x94>)
 800daa6:	4d20      	ldr	r5, [pc, #128]	; (800db28 <reserve_user_modem_cid+0x98>)
 800daa8:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 800daac:	46a4      	mov	ip, r4
 800daae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dab2:	6028      	str	r0, [r5, #0]
 800dab4:	6069      	str	r1, [r5, #4]
 800dab6:	60aa      	str	r2, [r5, #8]
 800dab8:	60eb      	str	r3, [r5, #12]
 800daba:	4664      	mov	r4, ip
 800dabc:	3510      	adds	r5, #16
 800dabe:	45f4      	cmp	ip, lr
 800dac0:	d1f4      	bne.n	800daac <reserve_user_modem_cid+0x1c>
 800dac2:	cc03      	ldmia	r4!, {r0, r1}
 800dac4:	6028      	str	r0, [r5, #0]
 800dac6:	6069      	str	r1, [r5, #4]
 800dac8:	4c17      	ldr	r4, [pc, #92]	; (800db28 <reserve_user_modem_cid+0x98>)
 800daca:	4620      	mov	r0, r4
 800dacc:	f011 fc2d 	bl	801f32a <crs_strlen>
 800dad0:	b283      	uxth	r3, r0
 800dad2:	4622      	mov	r2, r4
 800dad4:	2110      	movs	r1, #16
 800dad6:	2002      	movs	r0, #2
 800dad8:	f011 fc6a 	bl	801f3b0 <traceIF_itmPrint>
 800dadc:	4620      	mov	r0, r4
 800dade:	f011 fc24 	bl	801f32a <crs_strlen>
 800dae2:	b283      	uxth	r3, r0
 800dae4:	4622      	mov	r2, r4
 800dae6:	2110      	movs	r1, #16
 800dae8:	2002      	movs	r0, #2
 800daea:	f011 fc83 	bl	801f3f4 <traceIF_uartPrint>
}
 800daee:	bd38      	pop	{r3, r4, r5, pc}
    uint8_t i = 0U;
 800daf0:	2300      	movs	r3, #0
    bool leave_loop = false;
 800daf2:	461a      	mov	r2, r3
 800daf4:	e005      	b.n	800db02 <reserve_user_modem_cid+0x72>
      i++;
 800daf6:	3301      	adds	r3, #1
 800daf8:	b2db      	uxtb	r3, r3
    } while ((leave_loop == false) && (i < MODEM_MAX_NB_PDP_CTXT));
 800dafa:	2a00      	cmp	r2, #0
 800dafc:	d1f7      	bne.n	800daee <reserve_user_modem_cid+0x5e>
 800dafe:	2b05      	cmp	r3, #5
 800db00:	d8f5      	bhi.n	800daee <reserve_user_modem_cid+0x5e>
      if (reserved_user_modem_cid == p_tmp->mdm_cid_value)
 800db02:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 800db06:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 800db0a:	f891 1350 	ldrb.w	r1, [r1, #848]	; 0x350
 800db0e:	42a1      	cmp	r1, r4
 800db10:	d1f1      	bne.n	800daf6 <reserve_user_modem_cid+0x66>
        p_tmp->pdn_defined = AT_TRUE;
 800db12:	eb03 1103 	add.w	r1, r3, r3, lsl #4
 800db16:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 800db1a:	2201      	movs	r2, #1
 800db1c:	f881 2351 	strb.w	r2, [r1, #849]	; 0x351
        leave_loop = true;
 800db20:	e7e9      	b.n	800daf6 <reserve_user_modem_cid+0x66>
 800db22:	bf00      	nop
 800db24:	0802e82c 	.word	0x0802e82c
 800db28:	200048dc 	.word	0x200048dc

0800db2c <reset_pdn_event>:
  * @param  p_persistent_ctxt
  * @retval none
  */
void reset_pdn_event(atcustom_persistent_context_t *p_persistent_ctxt)
{
  p_persistent_ctxt->pdn_event.event_origine = CGEV_EVENT_UNDEFINE;
 800db2c:	2300      	movs	r3, #0
 800db2e:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  p_persistent_ctxt->pdn_event.event_scope   = CGEV_EVENT_SCOPE_GLOBAL;
 800db32:	220b      	movs	r2, #11
 800db34:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
  p_persistent_ctxt->pdn_event.event_type    = CGEV_EVENT_UNDEFINE;
 800db38:	f880 3042 	strb.w	r3, [r0, #66]	; 0x42
  p_persistent_ctxt->pdn_event.conf_id       = CS_PDN_NOT_DEFINED;
 800db3c:	230c      	movs	r3, #12
 800db3e:	f880 3043 	strb.w	r3, [r0, #67]	; 0x43
}
 800db42:	4770      	bx	lr

0800db44 <atcm_modem_get_urc>:
{
 800db44:	b5f0      	push	{r4, r5, r6, r7, lr}
 800db46:	b083      	sub	sp, #12
 800db48:	4604      	mov	r4, r0
 800db4a:	4617      	mov	r7, r2
  if (p_modem_ctxt->persist.urc_avail_eps_network_registration == AT_TRUE)
 800db4c:	7d03      	ldrb	r3, [r0, #20]
 800db4e:	2b00      	cmp	r3, #0
 800db50:	d149      	bne.n	800dbe6 <atcm_modem_get_urc+0xa2>
  else if (p_modem_ctxt->persist.urc_avail_gprs_network_registration == AT_TRUE)
 800db52:	7dc3      	ldrb	r3, [r0, #23]
 800db54:	2b00      	cmp	r3, #0
 800db56:	f040 80ba 	bne.w	800dcce <atcm_modem_get_urc+0x18a>
  else if (p_modem_ctxt->persist.urc_avail_cs_network_registration == AT_TRUE)
 800db5a:	7e83      	ldrb	r3, [r0, #26]
 800db5c:	2b00      	cmp	r3, #0
 800db5e:	f040 80ed 	bne.w	800dd3c <atcm_modem_get_urc+0x1f8>
  else if ((p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE)
 800db62:	7d43      	ldrb	r3, [r0, #21]
 800db64:	b91b      	cbnz	r3, 800db6e <atcm_modem_get_urc+0x2a>
           || (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE))
 800db66:	7d83      	ldrb	r3, [r0, #22]
 800db68:	2b00      	cmp	r3, #0
 800db6a:	f000 811c 	beq.w	800dda6 <atcm_modem_get_urc+0x262>
    PRINT_DBG("urc_avail_eps_location_info_tac or urc_avail_eps_location_info_ci")
 800db6e:	4daf      	ldr	r5, [pc, #700]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800db70:	224d      	movs	r2, #77	; 0x4d
 800db72:	49af      	ldr	r1, [pc, #700]	; (800de30 <atcm_modem_get_urc+0x2ec>)
 800db74:	4628      	mov	r0, r5
 800db76:	f018 ffb7 	bl	8026ae8 <memcpy>
 800db7a:	4628      	mov	r0, r5
 800db7c:	f011 fbd5 	bl	801f32a <crs_strlen>
 800db80:	b283      	uxth	r3, r0
 800db82:	462a      	mov	r2, r5
 800db84:	2102      	movs	r1, #2
 800db86:	4608      	mov	r0, r1
 800db88:	f011 fc12 	bl	801f3b0 <traceIF_itmPrint>
 800db8c:	4628      	mov	r0, r5
 800db8e:	f011 fbcc 	bl	801f32a <crs_strlen>
 800db92:	b283      	uxth	r3, r0
 800db94:	462a      	mov	r2, r5
 800db96:	2102      	movs	r1, #2
 800db98:	4608      	mov	r0, r1
 800db9a:	f011 fc2b 	bl	801f3f4 <traceIF_uartPrint>
    csint_location_info_t loc_struct = { .ci_updated = CELLULAR_FALSE, .lac_updated = CELLULAR_FALSE, };
 800db9e:	2300      	movs	r3, #0
 800dba0:	9300      	str	r3, [sp, #0]
 800dba2:	9301      	str	r3, [sp, #4]
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE)
 800dba4:	7d63      	ldrb	r3, [r4, #21]
 800dba6:	b12b      	cbz	r3, 800dbb4 <atcm_modem_get_urc+0x70>
      loc_struct.lac = p_modem_ctxt->persist.eps_location_info.lac;
 800dba8:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 800dbaa:	f8ad 3004 	strh.w	r3, [sp, #4]
      loc_struct.lac_updated = CELLULAR_TRUE;
 800dbae:	2301      	movs	r3, #1
 800dbb0:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE)
 800dbb4:	7da3      	ldrb	r3, [r4, #22]
 800dbb6:	b123      	cbz	r3, 800dbc2 <atcm_modem_get_urc+0x7e>
      loc_struct.ci = p_modem_ctxt->persist.eps_location_info.ci;
 800dbb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800dbba:	9300      	str	r3, [sp, #0]
      loc_struct.ci_updated = CELLULAR_TRUE;
 800dbbc:	2301      	movs	r3, #1
 800dbbe:	f88d 3006 	strb.w	r3, [sp, #6]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dbc2:	466b      	mov	r3, sp
 800dbc4:	2208      	movs	r2, #8
 800dbc6:	2106      	movs	r1, #6
 800dbc8:	4638      	mov	r0, r7
 800dbca:	f7fe fa73 	bl	800c0b4 <DATAPACK_writeStruct>
 800dbce:	4605      	mov	r5, r0
 800dbd0:	b100      	cbz	r0, 800dbd4 <atcm_modem_get_urc+0x90>
      retval = ATSTATUS_ERROR;
 800dbd2:	2501      	movs	r5, #1
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE)
 800dbd4:	7d63      	ldrb	r3, [r4, #21]
 800dbd6:	b10b      	cbz	r3, 800dbdc <atcm_modem_get_urc+0x98>
      p_modem_ctxt->persist.urc_avail_eps_location_info_tac = AT_FALSE;
 800dbd8:	2300      	movs	r3, #0
 800dbda:	7563      	strb	r3, [r4, #21]
    if (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE)
 800dbdc:	7da3      	ldrb	r3, [r4, #22]
 800dbde:	b3b3      	cbz	r3, 800dc4e <atcm_modem_get_urc+0x10a>
      p_modem_ctxt->persist.urc_avail_eps_location_info_ci = AT_FALSE;
 800dbe0:	2300      	movs	r3, #0
 800dbe2:	75a3      	strb	r3, [r4, #22]
  {
 800dbe4:	e033      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_eps_network_registration")
 800dbe6:	4e93      	ldr	r6, [pc, #588]	; (800de34 <atcm_modem_get_urc+0x2f0>)
 800dbe8:	4d90      	ldr	r5, [pc, #576]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dbea:	f106 0e20 	add.w	lr, r6, #32
 800dbee:	46b4      	mov	ip, r6
 800dbf0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dbf4:	6028      	str	r0, [r5, #0]
 800dbf6:	6069      	str	r1, [r5, #4]
 800dbf8:	60aa      	str	r2, [r5, #8]
 800dbfa:	60eb      	str	r3, [r5, #12]
 800dbfc:	4666      	mov	r6, ip
 800dbfe:	3510      	adds	r5, #16
 800dc00:	45f4      	cmp	ip, lr
 800dc02:	d1f4      	bne.n	800dbee <atcm_modem_get_urc+0xaa>
 800dc04:	ce07      	ldmia	r6!, {r0, r1, r2}
 800dc06:	6028      	str	r0, [r5, #0]
 800dc08:	6069      	str	r1, [r5, #4]
 800dc0a:	60aa      	str	r2, [r5, #8]
 800dc0c:	8833      	ldrh	r3, [r6, #0]
 800dc0e:	81ab      	strh	r3, [r5, #12]
 800dc10:	4d86      	ldr	r5, [pc, #536]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dc12:	4628      	mov	r0, r5
 800dc14:	f011 fb89 	bl	801f32a <crs_strlen>
 800dc18:	b283      	uxth	r3, r0
 800dc1a:	462a      	mov	r2, r5
 800dc1c:	2102      	movs	r1, #2
 800dc1e:	4608      	mov	r0, r1
 800dc20:	f011 fbc6 	bl	801f3b0 <traceIF_itmPrint>
 800dc24:	4628      	mov	r0, r5
 800dc26:	f011 fb80 	bl	801f32a <crs_strlen>
 800dc2a:	b283      	uxth	r3, r0
 800dc2c:	462a      	mov	r2, r5
 800dc2e:	2102      	movs	r1, #2
 800dc30:	4608      	mov	r0, r1
 800dc32:	f011 fbdf 	bl	801f3f4 <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dc36:	f104 0330 	add.w	r3, r4, #48	; 0x30
 800dc3a:	2202      	movs	r2, #2
 800dc3c:	2105      	movs	r1, #5
 800dc3e:	4638      	mov	r0, r7
 800dc40:	f7fe fa38 	bl	800c0b4 <DATAPACK_writeStruct>
 800dc44:	4605      	mov	r5, r0
 800dc46:	b100      	cbz	r0, 800dc4a <atcm_modem_get_urc+0x106>
      retval = ATSTATUS_ERROR;
 800dc48:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_eps_network_registration = AT_FALSE;
 800dc4a:	2300      	movs	r3, #0
 800dc4c:	7523      	strb	r3, [r4, #20]
  if ((p_modem_ctxt->persist.urc_avail_eps_network_registration == AT_TRUE) ||
 800dc4e:	7d23      	ldrb	r3, [r4, #20]
 800dc50:	2b00      	cmp	r3, #0
 800dc52:	f040 8322 	bne.w	800e29a <atcm_modem_get_urc+0x756>
      (p_modem_ctxt->persist.urc_avail_gprs_network_registration == AT_TRUE) ||
 800dc56:	7de3      	ldrb	r3, [r4, #23]
  if ((p_modem_ctxt->persist.urc_avail_eps_network_registration == AT_TRUE) ||
 800dc58:	2b00      	cmp	r3, #0
 800dc5a:	f040 8322 	bne.w	800e2a2 <atcm_modem_get_urc+0x75e>
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE) ||
 800dc5e:	7e23      	ldrb	r3, [r4, #24]
      (p_modem_ctxt->persist.urc_avail_gprs_network_registration == AT_TRUE) ||
 800dc60:	2b00      	cmp	r3, #0
 800dc62:	f040 8320 	bne.w	800e2a6 <atcm_modem_get_urc+0x762>
      (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE) ||
 800dc66:	7d63      	ldrb	r3, [r4, #21]
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE) ||
 800dc68:	2b00      	cmp	r3, #0
 800dc6a:	f040 831e 	bne.w	800e2aa <atcm_modem_get_urc+0x766>
      (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE) ||
 800dc6e:	7da3      	ldrb	r3, [r4, #22]
      (p_modem_ctxt->persist.urc_avail_eps_location_info_tac == AT_TRUE) ||
 800dc70:	2b00      	cmp	r3, #0
 800dc72:	f040 831c 	bne.w	800e2ae <atcm_modem_get_urc+0x76a>
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE) ||
 800dc76:	7e63      	ldrb	r3, [r4, #25]
      (p_modem_ctxt->persist.urc_avail_eps_location_info_ci == AT_TRUE) ||
 800dc78:	2b00      	cmp	r3, #0
 800dc7a:	f040 831a 	bne.w	800e2b2 <atcm_modem_get_urc+0x76e>
      (p_modem_ctxt->persist.urc_avail_cs_network_registration == AT_TRUE) ||
 800dc7e:	7ea3      	ldrb	r3, [r4, #26]
      (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE) ||
 800dc80:	2b00      	cmp	r3, #0
 800dc82:	f040 8318 	bne.w	800e2b6 <atcm_modem_get_urc+0x772>
      (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE) ||
 800dc86:	7ee3      	ldrb	r3, [r4, #27]
      (p_modem_ctxt->persist.urc_avail_cs_network_registration == AT_TRUE) ||
 800dc88:	2b00      	cmp	r3, #0
 800dc8a:	f040 8316 	bne.w	800e2ba <atcm_modem_get_urc+0x776>
      (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE) ||
 800dc8e:	7f23      	ldrb	r3, [r4, #28]
      (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE) ||
 800dc90:	2b00      	cmp	r3, #0
 800dc92:	f040 8314 	bne.w	800e2be <atcm_modem_get_urc+0x77a>
      (p_modem_ctxt->persist.urc_avail_signal_quality == AT_TRUE) ||
 800dc96:	7f63      	ldrb	r3, [r4, #29]
      (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE) ||
 800dc98:	2b00      	cmp	r3, #0
 800dc9a:	f040 8312 	bne.w	800e2c2 <atcm_modem_get_urc+0x77e>
      (p_modem_ctxt->persist.urc_avail_socket_data_pending == AT_TRUE) ||
 800dc9e:	7fa3      	ldrb	r3, [r4, #30]
      (p_modem_ctxt->persist.urc_avail_signal_quality == AT_TRUE) ||
 800dca0:	2b00      	cmp	r3, #0
 800dca2:	f040 8310 	bne.w	800e2c6 <atcm_modem_get_urc+0x782>
      (p_modem_ctxt->persist.urc_avail_socket_closed_by_remote == AT_TRUE) ||
 800dca6:	7fe3      	ldrb	r3, [r4, #31]
      (p_modem_ctxt->persist.urc_avail_socket_data_pending == AT_TRUE) ||
 800dca8:	2b00      	cmp	r3, #0
 800dcaa:	f040 830e 	bne.w	800e2ca <atcm_modem_get_urc+0x786>
      (p_modem_ctxt->persist.urc_avail_pdn_event == AT_TRUE) ||
 800dcae:	f894 3020 	ldrb.w	r3, [r4, #32]
      (p_modem_ctxt->persist.urc_avail_socket_closed_by_remote == AT_TRUE) ||
 800dcb2:	2b00      	cmp	r3, #0
 800dcb4:	f040 830b 	bne.w	800e2ce <atcm_modem_get_urc+0x78a>
      (p_modem_ctxt->persist.urc_avail_ping_rsp == AT_TRUE) ||
 800dcb8:	f894 35ac 	ldrb.w	r3, [r4, #1452]	; 0x5ac
      (p_modem_ctxt->persist.urc_avail_pdn_event == AT_TRUE) ||
 800dcbc:	2b00      	cmp	r3, #0
 800dcbe:	f040 8308 	bne.w	800e2d2 <atcm_modem_get_urc+0x78e>
      (p_modem_ctxt->persist.urc_avail_modem_events != CS_MDMEVENT_NONE))
 800dcc2:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
      (p_modem_ctxt->persist.urc_avail_ping_rsp == AT_TRUE) ||
 800dcc4:	2b00      	cmp	r3, #0
 800dcc6:	f000 82e9 	beq.w	800e29c <atcm_modem_get_urc+0x758>
    retval = ATSTATUS_OK_PENDING_URC;
 800dcca:	2503      	movs	r5, #3
 800dccc:	e2e6      	b.n	800e29c <atcm_modem_get_urc+0x758>
    PRINT_DBG("urc_avail_gprs_network_registration")
 800dcce:	4e5a      	ldr	r6, [pc, #360]	; (800de38 <atcm_modem_get_urc+0x2f4>)
 800dcd0:	4d56      	ldr	r5, [pc, #344]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dcd2:	f106 0e20 	add.w	lr, r6, #32
 800dcd6:	46b4      	mov	ip, r6
 800dcd8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dcdc:	6028      	str	r0, [r5, #0]
 800dcde:	6069      	str	r1, [r5, #4]
 800dce0:	60aa      	str	r2, [r5, #8]
 800dce2:	60eb      	str	r3, [r5, #12]
 800dce4:	4666      	mov	r6, ip
 800dce6:	3510      	adds	r5, #16
 800dce8:	45f4      	cmp	ip, lr
 800dcea:	d1f4      	bne.n	800dcd6 <atcm_modem_get_urc+0x192>
 800dcec:	ce07      	ldmia	r6!, {r0, r1, r2}
 800dcee:	6028      	str	r0, [r5, #0]
 800dcf0:	6069      	str	r1, [r5, #4]
 800dcf2:	60aa      	str	r2, [r5, #8]
 800dcf4:	8832      	ldrh	r2, [r6, #0]
 800dcf6:	78b3      	ldrb	r3, [r6, #2]
 800dcf8:	81aa      	strh	r2, [r5, #12]
 800dcfa:	73ab      	strb	r3, [r5, #14]
 800dcfc:	4d4b      	ldr	r5, [pc, #300]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dcfe:	4628      	mov	r0, r5
 800dd00:	f011 fb13 	bl	801f32a <crs_strlen>
 800dd04:	b283      	uxth	r3, r0
 800dd06:	462a      	mov	r2, r5
 800dd08:	2102      	movs	r1, #2
 800dd0a:	4608      	mov	r0, r1
 800dd0c:	f011 fb50 	bl	801f3b0 <traceIF_itmPrint>
 800dd10:	4628      	mov	r0, r5
 800dd12:	f011 fb0a 	bl	801f32a <crs_strlen>
 800dd16:	b283      	uxth	r3, r0
 800dd18:	462a      	mov	r2, r5
 800dd1a:	2102      	movs	r1, #2
 800dd1c:	4608      	mov	r0, r1
 800dd1e:	f011 fb69 	bl	801f3f4 <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dd22:	f104 033c 	add.w	r3, r4, #60	; 0x3c
 800dd26:	2202      	movs	r2, #2
 800dd28:	2107      	movs	r1, #7
 800dd2a:	4638      	mov	r0, r7
 800dd2c:	f7fe f9c2 	bl	800c0b4 <DATAPACK_writeStruct>
 800dd30:	4605      	mov	r5, r0
 800dd32:	b100      	cbz	r0, 800dd36 <atcm_modem_get_urc+0x1f2>
      retval = ATSTATUS_ERROR;
 800dd34:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_gprs_network_registration = AT_FALSE;
 800dd36:	2300      	movs	r3, #0
 800dd38:	75e3      	strb	r3, [r4, #23]
 800dd3a:	e788      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_cs_network_registration")
 800dd3c:	4e3f      	ldr	r6, [pc, #252]	; (800de3c <atcm_modem_get_urc+0x2f8>)
 800dd3e:	4d3b      	ldr	r5, [pc, #236]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dd40:	f106 0e20 	add.w	lr, r6, #32
 800dd44:	46b4      	mov	ip, r6
 800dd46:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800dd4a:	6028      	str	r0, [r5, #0]
 800dd4c:	6069      	str	r1, [r5, #4]
 800dd4e:	60aa      	str	r2, [r5, #8]
 800dd50:	60eb      	str	r3, [r5, #12]
 800dd52:	4666      	mov	r6, ip
 800dd54:	3510      	adds	r5, #16
 800dd56:	45f4      	cmp	ip, lr
 800dd58:	d1f4      	bne.n	800dd44 <atcm_modem_get_urc+0x200>
 800dd5a:	ce07      	ldmia	r6!, {r0, r1, r2}
 800dd5c:	6028      	str	r0, [r5, #0]
 800dd5e:	6069      	str	r1, [r5, #4]
 800dd60:	60aa      	str	r2, [r5, #8]
 800dd62:	7833      	ldrb	r3, [r6, #0]
 800dd64:	732b      	strb	r3, [r5, #12]
 800dd66:	4d31      	ldr	r5, [pc, #196]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800dd68:	4628      	mov	r0, r5
 800dd6a:	f011 fade 	bl	801f32a <crs_strlen>
 800dd6e:	b283      	uxth	r3, r0
 800dd70:	462a      	mov	r2, r5
 800dd72:	2102      	movs	r1, #2
 800dd74:	4608      	mov	r0, r1
 800dd76:	f011 fb1b 	bl	801f3b0 <traceIF_itmPrint>
 800dd7a:	4628      	mov	r0, r5
 800dd7c:	f011 fad5 	bl	801f32a <crs_strlen>
 800dd80:	b283      	uxth	r3, r0
 800dd82:	462a      	mov	r2, r5
 800dd84:	2102      	movs	r1, #2
 800dd86:	4608      	mov	r0, r1
 800dd88:	f011 fb34 	bl	801f3f4 <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dd8c:	f104 0348 	add.w	r3, r4, #72	; 0x48
 800dd90:	2202      	movs	r2, #2
 800dd92:	2109      	movs	r1, #9
 800dd94:	4638      	mov	r0, r7
 800dd96:	f7fe f98d 	bl	800c0b4 <DATAPACK_writeStruct>
 800dd9a:	4605      	mov	r5, r0
 800dd9c:	b100      	cbz	r0, 800dda0 <atcm_modem_get_urc+0x25c>
      retval = ATSTATUS_ERROR;
 800dd9e:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_cs_network_registration = AT_FALSE;
 800dda0:	2300      	movs	r3, #0
 800dda2:	76a3      	strb	r3, [r4, #26]
 800dda4:	e753      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
  else if ((p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE)
 800dda6:	7e03      	ldrb	r3, [r0, #24]
 800dda8:	b913      	cbnz	r3, 800ddb0 <atcm_modem_get_urc+0x26c>
           || (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE))
 800ddaa:	7e43      	ldrb	r3, [r0, #25]
 800ddac:	2b00      	cmp	r3, #0
 800ddae:	d049      	beq.n	800de44 <atcm_modem_get_urc+0x300>
    PRINT_DBG("urc_avail_gprs_location_info_tac or urc_avail_gprs_location_info_ci")
 800ddb0:	4d1e      	ldr	r5, [pc, #120]	; (800de2c <atcm_modem_get_urc+0x2e8>)
 800ddb2:	224f      	movs	r2, #79	; 0x4f
 800ddb4:	4922      	ldr	r1, [pc, #136]	; (800de40 <atcm_modem_get_urc+0x2fc>)
 800ddb6:	4628      	mov	r0, r5
 800ddb8:	f018 fe96 	bl	8026ae8 <memcpy>
 800ddbc:	4628      	mov	r0, r5
 800ddbe:	f011 fab4 	bl	801f32a <crs_strlen>
 800ddc2:	b283      	uxth	r3, r0
 800ddc4:	462a      	mov	r2, r5
 800ddc6:	2102      	movs	r1, #2
 800ddc8:	4608      	mov	r0, r1
 800ddca:	f011 faf1 	bl	801f3b0 <traceIF_itmPrint>
 800ddce:	4628      	mov	r0, r5
 800ddd0:	f011 faab 	bl	801f32a <crs_strlen>
 800ddd4:	b283      	uxth	r3, r0
 800ddd6:	462a      	mov	r2, r5
 800ddd8:	2102      	movs	r1, #2
 800ddda:	4608      	mov	r0, r1
 800dddc:	f011 fb0a 	bl	801f3f4 <traceIF_uartPrint>
    csint_location_info_t loc_struct = { .ci_updated = CELLULAR_FALSE, .lac_updated = CELLULAR_FALSE, };
 800dde0:	2300      	movs	r3, #0
 800dde2:	9300      	str	r3, [sp, #0]
 800dde4:	9301      	str	r3, [sp, #4]
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE)
 800dde6:	7e23      	ldrb	r3, [r4, #24]
 800dde8:	b12b      	cbz	r3, 800ddf6 <atcm_modem_get_urc+0x2b2>
      loc_struct.lac = p_modem_ctxt->persist.gprs_location_info.lac;
 800ddea:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800ddec:	f8ad 3004 	strh.w	r3, [sp, #4]
      loc_struct.lac_updated = CELLULAR_TRUE;
 800ddf0:	2301      	movs	r3, #1
 800ddf2:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE)
 800ddf6:	7e63      	ldrb	r3, [r4, #25]
 800ddf8:	b123      	cbz	r3, 800de04 <atcm_modem_get_urc+0x2c0>
      loc_struct.ci = p_modem_ctxt->persist.gprs_location_info.ci;
 800ddfa:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800ddfc:	9300      	str	r3, [sp, #0]
      loc_struct.ci_updated = CELLULAR_TRUE;
 800ddfe:	2301      	movs	r3, #1
 800de00:	f88d 3006 	strb.w	r3, [sp, #6]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800de04:	466b      	mov	r3, sp
 800de06:	2208      	movs	r2, #8
 800de08:	4611      	mov	r1, r2
 800de0a:	4638      	mov	r0, r7
 800de0c:	f7fe f952 	bl	800c0b4 <DATAPACK_writeStruct>
 800de10:	4605      	mov	r5, r0
 800de12:	b100      	cbz	r0, 800de16 <atcm_modem_get_urc+0x2d2>
      retval = ATSTATUS_ERROR;
 800de14:	2501      	movs	r5, #1
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_lac == AT_TRUE)
 800de16:	7e23      	ldrb	r3, [r4, #24]
 800de18:	b10b      	cbz	r3, 800de1e <atcm_modem_get_urc+0x2da>
      p_modem_ctxt->persist.urc_avail_gprs_location_info_lac = AT_FALSE;
 800de1a:	2300      	movs	r3, #0
 800de1c:	7623      	strb	r3, [r4, #24]
    if (p_modem_ctxt->persist.urc_avail_gprs_location_info_ci == AT_TRUE)
 800de1e:	7e63      	ldrb	r3, [r4, #25]
 800de20:	2b00      	cmp	r3, #0
 800de22:	f43f af14 	beq.w	800dc4e <atcm_modem_get_urc+0x10a>
      p_modem_ctxt->persist.urc_avail_gprs_location_info_ci = AT_FALSE;
 800de26:	2300      	movs	r3, #0
 800de28:	7663      	strb	r3, [r4, #25]
  {
 800de2a:	e710      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
 800de2c:	200048dc 	.word	0x200048dc
 800de30:	0802ebb0 	.word	0x0802ebb0
 800de34:	0802eb20 	.word	0x0802eb20
 800de38:	0802eb50 	.word	0x0802eb50
 800de3c:	0802eb80 	.word	0x0802eb80
 800de40:	0802ec00 	.word	0x0802ec00
  else if ((p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE)
 800de44:	7ec3      	ldrb	r3, [r0, #27]
 800de46:	b913      	cbnz	r3, 800de4e <atcm_modem_get_urc+0x30a>
           || (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE))
 800de48:	7f03      	ldrb	r3, [r0, #28]
 800de4a:	2b00      	cmp	r3, #0
 800de4c:	d03e      	beq.n	800decc <atcm_modem_get_urc+0x388>
    PRINT_DBG("urc_avail_cs_location_info_lac or urc_avail_cs_location_info_ci")
 800de4e:	4dc3      	ldr	r5, [pc, #780]	; (800e15c <atcm_modem_get_urc+0x618>)
 800de50:	224b      	movs	r2, #75	; 0x4b
 800de52:	49c3      	ldr	r1, [pc, #780]	; (800e160 <atcm_modem_get_urc+0x61c>)
 800de54:	4628      	mov	r0, r5
 800de56:	f018 fe47 	bl	8026ae8 <memcpy>
 800de5a:	4628      	mov	r0, r5
 800de5c:	f011 fa65 	bl	801f32a <crs_strlen>
 800de60:	b283      	uxth	r3, r0
 800de62:	462a      	mov	r2, r5
 800de64:	2102      	movs	r1, #2
 800de66:	4608      	mov	r0, r1
 800de68:	f011 faa2 	bl	801f3b0 <traceIF_itmPrint>
 800de6c:	4628      	mov	r0, r5
 800de6e:	f011 fa5c 	bl	801f32a <crs_strlen>
 800de72:	b283      	uxth	r3, r0
 800de74:	462a      	mov	r2, r5
 800de76:	2102      	movs	r1, #2
 800de78:	4608      	mov	r0, r1
 800de7a:	f011 fabb 	bl	801f3f4 <traceIF_uartPrint>
    csint_location_info_t loc_struct = { .ci_updated = CELLULAR_FALSE, .lac_updated = CELLULAR_FALSE, };
 800de7e:	2300      	movs	r3, #0
 800de80:	9300      	str	r3, [sp, #0]
 800de82:	9301      	str	r3, [sp, #4]
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE)
 800de84:	7ee3      	ldrb	r3, [r4, #27]
 800de86:	b133      	cbz	r3, 800de96 <atcm_modem_get_urc+0x352>
      loc_struct.lac = p_modem_ctxt->persist.cs_location_info.lac;
 800de88:	f8b4 3044 	ldrh.w	r3, [r4, #68]	; 0x44
 800de8c:	f8ad 3004 	strh.w	r3, [sp, #4]
      loc_struct.lac_updated = CELLULAR_TRUE;
 800de90:	2301      	movs	r3, #1
 800de92:	f88d 3007 	strb.w	r3, [sp, #7]
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE)
 800de96:	7f23      	ldrb	r3, [r4, #28]
 800de98:	b123      	cbz	r3, 800dea4 <atcm_modem_get_urc+0x360>
      loc_struct.ci = p_modem_ctxt->persist.cs_location_info.ci;
 800de9a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800de9c:	9300      	str	r3, [sp, #0]
      loc_struct.ci_updated = CELLULAR_TRUE;
 800de9e:	2301      	movs	r3, #1
 800dea0:	f88d 3006 	strb.w	r3, [sp, #6]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dea4:	466b      	mov	r3, sp
 800dea6:	2208      	movs	r2, #8
 800dea8:	210a      	movs	r1, #10
 800deaa:	4638      	mov	r0, r7
 800deac:	f7fe f902 	bl	800c0b4 <DATAPACK_writeStruct>
 800deb0:	4605      	mov	r5, r0
 800deb2:	b100      	cbz	r0, 800deb6 <atcm_modem_get_urc+0x372>
      retval = ATSTATUS_ERROR;
 800deb4:	2501      	movs	r5, #1
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_lac == AT_TRUE)
 800deb6:	7ee3      	ldrb	r3, [r4, #27]
 800deb8:	b10b      	cbz	r3, 800debe <atcm_modem_get_urc+0x37a>
      p_modem_ctxt->persist.urc_avail_cs_location_info_lac = AT_FALSE;
 800deba:	2300      	movs	r3, #0
 800debc:	76e3      	strb	r3, [r4, #27]
    if (p_modem_ctxt->persist.urc_avail_cs_location_info_ci == AT_TRUE)
 800debe:	7f23      	ldrb	r3, [r4, #28]
 800dec0:	2b00      	cmp	r3, #0
 800dec2:	f43f aec4 	beq.w	800dc4e <atcm_modem_get_urc+0x10a>
      p_modem_ctxt->persist.urc_avail_cs_location_info_ci = AT_FALSE;
 800dec6:	2300      	movs	r3, #0
 800dec8:	7723      	strb	r3, [r4, #28]
  {
 800deca:	e6c0      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
  else if (p_modem_ctxt->persist.urc_avail_signal_quality == AT_TRUE)
 800decc:	7f43      	ldrb	r3, [r0, #29]
 800dece:	2b00      	cmp	r3, #0
 800ded0:	d145      	bne.n	800df5e <atcm_modem_get_urc+0x41a>
  else if (p_modem_ctxt->persist.urc_avail_socket_data_pending == AT_TRUE)
 800ded2:	7f83      	ldrb	r3, [r0, #30]
 800ded4:	2b00      	cmp	r3, #0
 800ded6:	d17a      	bne.n	800dfce <atcm_modem_get_urc+0x48a>
  else if (p_modem_ctxt->persist.urc_avail_socket_closed_by_remote == AT_TRUE)
 800ded8:	7fc3      	ldrb	r3, [r0, #31]
 800deda:	2b00      	cmp	r3, #0
 800dedc:	f040 80b2 	bne.w	800e044 <atcm_modem_get_urc+0x500>
  else if (p_modem_ctxt->persist.urc_avail_pdn_event == AT_TRUE)
 800dee0:	f890 3020 	ldrb.w	r3, [r0, #32]
 800dee4:	2b00      	cmp	r3, #0
 800dee6:	f040 80e9 	bne.w	800e0bc <atcm_modem_get_urc+0x578>
  else if (p_modem_ctxt->persist.urc_avail_ping_rsp == AT_TRUE)
 800deea:	f890 35ac 	ldrb.w	r3, [r0, #1452]	; 0x5ac
 800deee:	2b00      	cmp	r3, #0
 800def0:	f040 8186 	bne.w	800e200 <atcm_modem_get_urc+0x6bc>
  else if (p_modem_ctxt->persist.urc_avail_modem_events != CS_MDMEVENT_NONE)
 800def4:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 800def6:	2b00      	cmp	r3, #0
 800def8:	f000 81af 	beq.w	800e25a <atcm_modem_get_urc+0x716>
    PRINT_DBG("urc_avail_modem_events")
 800defc:	f8df c268 	ldr.w	ip, [pc, #616]	; 800e168 <atcm_modem_get_urc+0x624>
 800df00:	4d96      	ldr	r5, [pc, #600]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df02:	f10c 0e20 	add.w	lr, ip, #32
 800df06:	4666      	mov	r6, ip
 800df08:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800df0a:	6028      	str	r0, [r5, #0]
 800df0c:	6069      	str	r1, [r5, #4]
 800df0e:	60aa      	str	r2, [r5, #8]
 800df10:	60eb      	str	r3, [r5, #12]
 800df12:	46b4      	mov	ip, r6
 800df14:	3510      	adds	r5, #16
 800df16:	4576      	cmp	r6, lr
 800df18:	d1f5      	bne.n	800df06 <atcm_modem_get_urc+0x3c2>
 800df1a:	8833      	ldrh	r3, [r6, #0]
 800df1c:	802b      	strh	r3, [r5, #0]
 800df1e:	4d8f      	ldr	r5, [pc, #572]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df20:	4628      	mov	r0, r5
 800df22:	f011 fa02 	bl	801f32a <crs_strlen>
 800df26:	b283      	uxth	r3, r0
 800df28:	462a      	mov	r2, r5
 800df2a:	2102      	movs	r1, #2
 800df2c:	4608      	mov	r0, r1
 800df2e:	f011 fa3f 	bl	801f3b0 <traceIF_itmPrint>
 800df32:	4628      	mov	r0, r5
 800df34:	f011 f9f9 	bl	801f32a <crs_strlen>
 800df38:	b283      	uxth	r3, r0
 800df3a:	462a      	mov	r2, r5
 800df3c:	2102      	movs	r1, #2
 800df3e:	4608      	mov	r0, r1
 800df40:	f011 fa58 	bl	801f3f4 <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800df44:	f104 0324 	add.w	r3, r4, #36	; 0x24
 800df48:	2202      	movs	r2, #2
 800df4a:	210f      	movs	r1, #15
 800df4c:	4638      	mov	r0, r7
 800df4e:	f7fe f8b1 	bl	800c0b4 <DATAPACK_writeStruct>
 800df52:	4605      	mov	r5, r0
 800df54:	b100      	cbz	r0, 800df58 <atcm_modem_get_urc+0x414>
      retval = ATSTATUS_ERROR;
 800df56:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_modem_events = CS_MDMEVENT_NONE;
 800df58:	2300      	movs	r3, #0
 800df5a:	84a3      	strh	r3, [r4, #36]	; 0x24
 800df5c:	e677      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_signal_quality")
 800df5e:	f8df c20c 	ldr.w	ip, [pc, #524]	; 800e16c <atcm_modem_get_urc+0x628>
 800df62:	4e7e      	ldr	r6, [pc, #504]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df64:	f10c 0e20 	add.w	lr, ip, #32
 800df68:	4665      	mov	r5, ip
 800df6a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800df6c:	6030      	str	r0, [r6, #0]
 800df6e:	6071      	str	r1, [r6, #4]
 800df70:	60b2      	str	r2, [r6, #8]
 800df72:	60f3      	str	r3, [r6, #12]
 800df74:	46ac      	mov	ip, r5
 800df76:	3610      	adds	r6, #16
 800df78:	4575      	cmp	r5, lr
 800df7a:	d1f5      	bne.n	800df68 <atcm_modem_get_urc+0x424>
 800df7c:	6828      	ldr	r0, [r5, #0]
 800df7e:	6030      	str	r0, [r6, #0]
 800df80:	4d76      	ldr	r5, [pc, #472]	; (800e15c <atcm_modem_get_urc+0x618>)
 800df82:	4628      	mov	r0, r5
 800df84:	f011 f9d1 	bl	801f32a <crs_strlen>
 800df88:	b283      	uxth	r3, r0
 800df8a:	462a      	mov	r2, r5
 800df8c:	2102      	movs	r1, #2
 800df8e:	4608      	mov	r0, r1
 800df90:	f011 fa0e 	bl	801f3b0 <traceIF_itmPrint>
 800df94:	4628      	mov	r0, r5
 800df96:	f011 f9c8 	bl	801f32a <crs_strlen>
 800df9a:	b283      	uxth	r3, r0
 800df9c:	462a      	mov	r2, r5
 800df9e:	2102      	movs	r1, #2
 800dfa0:	4608      	mov	r0, r1
 800dfa2:	f011 fa27 	bl	801f3f4 <traceIF_uartPrint>
    signal_quality_struct.rssi = p_modem_ctxt->persist.signal_quality.rssi;
 800dfa6:	f894 304a 	ldrb.w	r3, [r4, #74]	; 0x4a
 800dfaa:	f88d 3000 	strb.w	r3, [sp]
    signal_quality_struct.ber = p_modem_ctxt->persist.signal_quality.ber;
 800dfae:	f894 304b 	ldrb.w	r3, [r4, #75]	; 0x4b
 800dfb2:	f88d 3001 	strb.w	r3, [sp, #1]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800dfb6:	466b      	mov	r3, sp
 800dfb8:	2202      	movs	r2, #2
 800dfba:	210b      	movs	r1, #11
 800dfbc:	4638      	mov	r0, r7
 800dfbe:	f7fe f879 	bl	800c0b4 <DATAPACK_writeStruct>
 800dfc2:	4605      	mov	r5, r0
 800dfc4:	b100      	cbz	r0, 800dfc8 <atcm_modem_get_urc+0x484>
      retval = ATSTATUS_ERROR;
 800dfc6:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_signal_quality = AT_FALSE;
 800dfc8:	2300      	movs	r3, #0
 800dfca:	7763      	strb	r3, [r4, #29]
 800dfcc:	e63f      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_socket_data_pending")
 800dfce:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 800e170 <atcm_modem_get_urc+0x62c>
 800dfd2:	4d62      	ldr	r5, [pc, #392]	; (800e15c <atcm_modem_get_urc+0x618>)
 800dfd4:	f10c 0e20 	add.w	lr, ip, #32
 800dfd8:	4666      	mov	r6, ip
 800dfda:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800dfdc:	6028      	str	r0, [r5, #0]
 800dfde:	6069      	str	r1, [r5, #4]
 800dfe0:	60aa      	str	r2, [r5, #8]
 800dfe2:	60eb      	str	r3, [r5, #12]
 800dfe4:	46b4      	mov	ip, r6
 800dfe6:	3510      	adds	r5, #16
 800dfe8:	4576      	cmp	r6, lr
 800dfea:	d1f5      	bne.n	800dfd8 <atcm_modem_get_urc+0x494>
 800dfec:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 800dff0:	6028      	str	r0, [r5, #0]
 800dff2:	6069      	str	r1, [r5, #4]
 800dff4:	f89c 3000 	ldrb.w	r3, [ip]
 800dff8:	722b      	strb	r3, [r5, #8]
 800dffa:	4d58      	ldr	r5, [pc, #352]	; (800e15c <atcm_modem_get_urc+0x618>)
 800dffc:	4628      	mov	r0, r5
 800dffe:	f011 f994 	bl	801f32a <crs_strlen>
 800e002:	b283      	uxth	r3, r0
 800e004:	462a      	mov	r2, r5
 800e006:	2102      	movs	r1, #2
 800e008:	4608      	mov	r0, r1
 800e00a:	f011 f9d1 	bl	801f3b0 <traceIF_itmPrint>
 800e00e:	4628      	mov	r0, r5
 800e010:	f011 f98b 	bl	801f32a <crs_strlen>
 800e014:	b283      	uxth	r3, r0
 800e016:	462a      	mov	r2, r5
 800e018:	2102      	movs	r1, #2
 800e01a:	4608      	mov	r0, r1
 800e01c:	f011 f9ea 	bl	801f3f4 <traceIF_uartPrint>
    socket_handle_t sockHandle = atcm_socket_get_hdle_urc_data_pending(p_modem_ctxt);
 800e020:	4620      	mov	r0, r4
 800e022:	f006 f987 	bl	8014334 <atcm_socket_get_hdle_urc_data_pending>
 800e026:	9000      	str	r0, [sp, #0]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800e028:	466b      	mov	r3, sp
 800e02a:	2204      	movs	r2, #4
 800e02c:	210d      	movs	r1, #13
 800e02e:	4638      	mov	r0, r7
 800e030:	f7fe f840 	bl	800c0b4 <DATAPACK_writeStruct>
 800e034:	4605      	mov	r5, r0
 800e036:	b100      	cbz	r0, 800e03a <atcm_modem_get_urc+0x4f6>
      retval = ATSTATUS_ERROR;
 800e038:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_socket_data_pending = atcm_socket_remaining_urc_data_pending(p_modem_ctxt);
 800e03a:	4620      	mov	r0, r4
 800e03c:	f006 fa08 	bl	8014450 <atcm_socket_remaining_urc_data_pending>
 800e040:	77a0      	strb	r0, [r4, #30]
 800e042:	e604      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_socket_closed_by_remote")
 800e044:	f8df c12c 	ldr.w	ip, [pc, #300]	; 800e174 <atcm_modem_get_urc+0x630>
 800e048:	4d44      	ldr	r5, [pc, #272]	; (800e15c <atcm_modem_get_urc+0x618>)
 800e04a:	f10c 0e20 	add.w	lr, ip, #32
 800e04e:	4666      	mov	r6, ip
 800e050:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e052:	6028      	str	r0, [r5, #0]
 800e054:	6069      	str	r1, [r5, #4]
 800e056:	60aa      	str	r2, [r5, #8]
 800e058:	60eb      	str	r3, [r5, #12]
 800e05a:	46b4      	mov	ip, r6
 800e05c:	3510      	adds	r5, #16
 800e05e:	4576      	cmp	r6, lr
 800e060:	d1f5      	bne.n	800e04e <atcm_modem_get_urc+0x50a>
 800e062:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 800e066:	6028      	str	r0, [r5, #0]
 800e068:	6069      	str	r1, [r5, #4]
 800e06a:	60aa      	str	r2, [r5, #8]
 800e06c:	f89c 3000 	ldrb.w	r3, [ip]
 800e070:	732b      	strb	r3, [r5, #12]
 800e072:	4d3a      	ldr	r5, [pc, #232]	; (800e15c <atcm_modem_get_urc+0x618>)
 800e074:	4628      	mov	r0, r5
 800e076:	f011 f958 	bl	801f32a <crs_strlen>
 800e07a:	b283      	uxth	r3, r0
 800e07c:	462a      	mov	r2, r5
 800e07e:	2102      	movs	r1, #2
 800e080:	4608      	mov	r0, r1
 800e082:	f011 f995 	bl	801f3b0 <traceIF_itmPrint>
 800e086:	4628      	mov	r0, r5
 800e088:	f011 f94f 	bl	801f32a <crs_strlen>
 800e08c:	b283      	uxth	r3, r0
 800e08e:	462a      	mov	r2, r5
 800e090:	2102      	movs	r1, #2
 800e092:	4608      	mov	r0, r1
 800e094:	f011 f9ae 	bl	801f3f4 <traceIF_uartPrint>
    socket_handle_t sockHandle = atcm_socket_get_hdlr_urc_closed_by_remote(p_modem_ctxt);
 800e098:	4620      	mov	r0, r4
 800e09a:	f006 f991 	bl	80143c0 <atcm_socket_get_hdlr_urc_closed_by_remote>
 800e09e:	9000      	str	r0, [sp, #0]
    if (DATAPACK_writeStruct(p_rsp_buf,
 800e0a0:	466b      	mov	r3, sp
 800e0a2:	2204      	movs	r2, #4
 800e0a4:	210e      	movs	r1, #14
 800e0a6:	4638      	mov	r0, r7
 800e0a8:	f7fe f804 	bl	800c0b4 <DATAPACK_writeStruct>
 800e0ac:	4605      	mov	r5, r0
 800e0ae:	b100      	cbz	r0, 800e0b2 <atcm_modem_get_urc+0x56e>
      retval = ATSTATUS_ERROR;
 800e0b0:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_socket_closed_by_remote = atcm_socket_remaining_urc_closed_by_remote(p_modem_ctxt);
 800e0b2:	4620      	mov	r0, r4
 800e0b4:	f006 fa06 	bl	80144c4 <atcm_socket_remaining_urc_closed_by_remote>
 800e0b8:	77e0      	strb	r0, [r4, #31]
 800e0ba:	e5c8      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_pdn_event")
 800e0bc:	4d27      	ldr	r5, [pc, #156]	; (800e15c <atcm_modem_get_urc+0x618>)
 800e0be:	4e29      	ldr	r6, [pc, #164]	; (800e164 <atcm_modem_get_urc+0x620>)
 800e0c0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e0c2:	6028      	str	r0, [r5, #0]
 800e0c4:	6069      	str	r1, [r5, #4]
 800e0c6:	60aa      	str	r2, [r5, #8]
 800e0c8:	60eb      	str	r3, [r5, #12]
 800e0ca:	ce07      	ldmia	r6!, {r0, r1, r2}
 800e0cc:	6128      	str	r0, [r5, #16]
 800e0ce:	6169      	str	r1, [r5, #20]
 800e0d0:	61aa      	str	r2, [r5, #24]
 800e0d2:	8832      	ldrh	r2, [r6, #0]
 800e0d4:	78b3      	ldrb	r3, [r6, #2]
 800e0d6:	83aa      	strh	r2, [r5, #28]
 800e0d8:	77ab      	strb	r3, [r5, #30]
 800e0da:	4628      	mov	r0, r5
 800e0dc:	f011 f925 	bl	801f32a <crs_strlen>
 800e0e0:	b283      	uxth	r3, r0
 800e0e2:	462a      	mov	r2, r5
 800e0e4:	2102      	movs	r1, #2
 800e0e6:	4608      	mov	r0, r1
 800e0e8:	f011 f962 	bl	801f3b0 <traceIF_itmPrint>
 800e0ec:	4628      	mov	r0, r5
 800e0ee:	f011 f91c 	bl	801f32a <crs_strlen>
 800e0f2:	b283      	uxth	r3, r0
 800e0f4:	462a      	mov	r2, r5
 800e0f6:	2102      	movs	r1, #2
 800e0f8:	4608      	mov	r0, r1
 800e0fa:	f011 f97b 	bl	801f3f4 <traceIF_uartPrint>
    if (p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW)
 800e0fe:	f894 504c 	ldrb.w	r5, [r4, #76]	; 0x4c
 800e102:	2d01      	cmp	r5, #1
 800e104:	d150      	bne.n	800e1a8 <atcm_modem_get_urc+0x664>
      switch (p_modem_ctxt->persist.pdn_event.event_type)
 800e106:	f894 204e 	ldrb.w	r2, [r4, #78]	; 0x4e
 800e10a:	2a0d      	cmp	r2, #13
 800e10c:	d00c      	beq.n	800e128 <atcm_modem_get_urc+0x5e4>
 800e10e:	2a0f      	cmp	r2, #15
 800e110:	d132      	bne.n	800e178 <atcm_modem_get_urc+0x634>
          if (DATAPACK_writeStruct(p_rsp_buf,
 800e112:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 800e116:	2204      	movs	r2, #4
 800e118:	210c      	movs	r1, #12
 800e11a:	4638      	mov	r0, r7
 800e11c:	f7fd ffca 	bl	800c0b4 <DATAPACK_writeStruct>
 800e120:	2800      	cmp	r0, #0
 800e122:	d165      	bne.n	800e1f0 <atcm_modem_get_urc+0x6ac>
  at_status_t retval = ATSTATUS_OK;
 800e124:	4605      	mov	r5, r0
 800e126:	e063      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
          if (p_modem_ctxt->persist.pdn_event.event_scope == CGEV_EVENT_SCOPE_PDN)
 800e128:	f894 304d 	ldrb.w	r3, [r4, #77]	; 0x4d
 800e12c:	2b0a      	cmp	r3, #10
 800e12e:	d00a      	beq.n	800e146 <atcm_modem_get_urc+0x602>
            if (DATAPACK_writeStruct(p_rsp_buf,
 800e130:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 800e134:	2204      	movs	r2, #4
 800e136:	210c      	movs	r1, #12
 800e138:	4638      	mov	r0, r7
 800e13a:	f7fd ffbb 	bl	800c0b4 <DATAPACK_writeStruct>
 800e13e:	2800      	cmp	r0, #0
 800e140:	d156      	bne.n	800e1f0 <atcm_modem_get_urc+0x6ac>
  at_status_t retval = ATSTATUS_OK;
 800e142:	4605      	mov	r5, r0
 800e144:	e054      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
            if (DATAPACK_writeStruct(p_rsp_buf,
 800e146:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 800e14a:	2204      	movs	r2, #4
 800e14c:	210c      	movs	r1, #12
 800e14e:	4638      	mov	r0, r7
 800e150:	f7fd ffb0 	bl	800c0b4 <DATAPACK_writeStruct>
 800e154:	2800      	cmp	r0, #0
 800e156:	d14b      	bne.n	800e1f0 <atcm_modem_get_urc+0x6ac>
  at_status_t retval = ATSTATUS_OK;
 800e158:	4605      	mov	r5, r0
 800e15a:	e049      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
 800e15c:	200048dc 	.word	0x200048dc
 800e160:	0802ec50 	.word	0x0802ec50
 800e164:	0802ed1c 	.word	0x0802ed1c
 800e168:	0802edb0 	.word	0x0802edb0
 800e16c:	0802ec9c 	.word	0x0802ec9c
 800e170:	0802ecc0 	.word	0x0802ecc0
 800e174:	0802ecec 	.word	0x0802ecec
          PRINT_INFO("+CGEV URC discarded (NW), type=%d", p_modem_ctxt->persist.pdn_event.event_type)
 800e178:	4e57      	ldr	r6, [pc, #348]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e17a:	4958      	ldr	r1, [pc, #352]	; (800e2dc <atcm_modem_get_urc+0x798>)
 800e17c:	4630      	mov	r0, r6
 800e17e:	f018 fb63 	bl	8026848 <sprintf>
 800e182:	4630      	mov	r0, r6
 800e184:	f011 f8d1 	bl	801f32a <crs_strlen>
 800e188:	b283      	uxth	r3, r0
 800e18a:	4632      	mov	r2, r6
 800e18c:	2101      	movs	r1, #1
 800e18e:	2002      	movs	r0, #2
 800e190:	f011 f90e 	bl	801f3b0 <traceIF_itmPrint>
 800e194:	4630      	mov	r0, r6
 800e196:	f011 f8c8 	bl	801f32a <crs_strlen>
 800e19a:	b283      	uxth	r3, r0
 800e19c:	4632      	mov	r2, r6
 800e19e:	2101      	movs	r1, #1
 800e1a0:	2002      	movs	r0, #2
 800e1a2:	f011 f927 	bl	801f3f4 <traceIF_uartPrint>
          break;
 800e1a6:	e023      	b.n	800e1f0 <atcm_modem_get_urc+0x6ac>
      PRINT_INFO("+CGEV URC discarded (ME)")
 800e1a8:	4e4d      	ldr	r6, [pc, #308]	; (800e2e0 <atcm_modem_get_urc+0x79c>)
 800e1aa:	4d4b      	ldr	r5, [pc, #300]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e1ac:	f106 0c20 	add.w	ip, r6, #32
 800e1b0:	4637      	mov	r7, r6
 800e1b2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800e1b4:	6028      	str	r0, [r5, #0]
 800e1b6:	6069      	str	r1, [r5, #4]
 800e1b8:	60aa      	str	r2, [r5, #8]
 800e1ba:	60eb      	str	r3, [r5, #12]
 800e1bc:	463e      	mov	r6, r7
 800e1be:	3510      	adds	r5, #16
 800e1c0:	4567      	cmp	r7, ip
 800e1c2:	d1f5      	bne.n	800e1b0 <atcm_modem_get_urc+0x66c>
 800e1c4:	6838      	ldr	r0, [r7, #0]
 800e1c6:	6028      	str	r0, [r5, #0]
 800e1c8:	4d43      	ldr	r5, [pc, #268]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e1ca:	4628      	mov	r0, r5
 800e1cc:	f011 f8ad 	bl	801f32a <crs_strlen>
 800e1d0:	b283      	uxth	r3, r0
 800e1d2:	462a      	mov	r2, r5
 800e1d4:	2101      	movs	r1, #1
 800e1d6:	2002      	movs	r0, #2
 800e1d8:	f011 f8ea 	bl	801f3b0 <traceIF_itmPrint>
 800e1dc:	4628      	mov	r0, r5
 800e1de:	f011 f8a4 	bl	801f32a <crs_strlen>
 800e1e2:	b283      	uxth	r3, r0
 800e1e4:	462a      	mov	r2, r5
 800e1e6:	2101      	movs	r1, #1
 800e1e8:	2002      	movs	r0, #2
 800e1ea:	f011 f903 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800e1ee:	2501      	movs	r5, #1
    reset_pdn_event(&p_modem_ctxt->persist);
 800e1f0:	f104 000c 	add.w	r0, r4, #12
 800e1f4:	f7ff fc9a 	bl	800db2c <reset_pdn_event>
    p_modem_ctxt->persist.urc_avail_pdn_event = AT_FALSE;
 800e1f8:	2300      	movs	r3, #0
 800e1fa:	f884 3020 	strb.w	r3, [r4, #32]
 800e1fe:	e526      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_DBG("urc_avail_ping_rsp")
 800e200:	4d35      	ldr	r5, [pc, #212]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e202:	4e38      	ldr	r6, [pc, #224]	; (800e2e4 <atcm_modem_get_urc+0x7a0>)
 800e204:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e206:	6028      	str	r0, [r5, #0]
 800e208:	6069      	str	r1, [r5, #4]
 800e20a:	60aa      	str	r2, [r5, #8]
 800e20c:	60eb      	str	r3, [r5, #12]
 800e20e:	ce07      	ldmia	r6!, {r0, r1, r2}
 800e210:	6128      	str	r0, [r5, #16]
 800e212:	6169      	str	r1, [r5, #20]
 800e214:	61aa      	str	r2, [r5, #24]
 800e216:	8833      	ldrh	r3, [r6, #0]
 800e218:	83ab      	strh	r3, [r5, #28]
 800e21a:	4628      	mov	r0, r5
 800e21c:	f011 f885 	bl	801f32a <crs_strlen>
 800e220:	b283      	uxth	r3, r0
 800e222:	462a      	mov	r2, r5
 800e224:	2102      	movs	r1, #2
 800e226:	4608      	mov	r0, r1
 800e228:	f011 f8c2 	bl	801f3b0 <traceIF_itmPrint>
 800e22c:	4628      	mov	r0, r5
 800e22e:	f011 f87c 	bl	801f32a <crs_strlen>
 800e232:	b283      	uxth	r3, r0
 800e234:	462a      	mov	r2, r5
 800e236:	2102      	movs	r1, #2
 800e238:	4608      	mov	r0, r1
 800e23a:	f011 f8db 	bl	801f3f4 <traceIF_uartPrint>
    if (DATAPACK_writeStruct(p_rsp_buf,
 800e23e:	f204 535c 	addw	r3, r4, #1372	; 0x55c
 800e242:	2250      	movs	r2, #80	; 0x50
 800e244:	2110      	movs	r1, #16
 800e246:	4638      	mov	r0, r7
 800e248:	f7fd ff34 	bl	800c0b4 <DATAPACK_writeStruct>
 800e24c:	4605      	mov	r5, r0
 800e24e:	b100      	cbz	r0, 800e252 <atcm_modem_get_urc+0x70e>
      retval = ATSTATUS_ERROR;
 800e250:	2501      	movs	r5, #1
    p_modem_ctxt->persist.urc_avail_ping_rsp = AT_FALSE;
 800e252:	2300      	movs	r3, #0
 800e254:	f884 35ac 	strb.w	r3, [r4, #1452]	; 0x5ac
 800e258:	e4f9      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    PRINT_ERR("unexpected URC")
 800e25a:	4d1f      	ldr	r5, [pc, #124]	; (800e2d8 <atcm_modem_get_urc+0x794>)
 800e25c:	4e22      	ldr	r6, [pc, #136]	; (800e2e8 <atcm_modem_get_urc+0x7a4>)
 800e25e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e260:	6028      	str	r0, [r5, #0]
 800e262:	6069      	str	r1, [r5, #4]
 800e264:	60aa      	str	r2, [r5, #8]
 800e266:	60eb      	str	r3, [r5, #12]
 800e268:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800e26a:	6128      	str	r0, [r5, #16]
 800e26c:	6169      	str	r1, [r5, #20]
 800e26e:	61aa      	str	r2, [r5, #24]
 800e270:	61eb      	str	r3, [r5, #28]
 800e272:	4628      	mov	r0, r5
 800e274:	f011 f859 	bl	801f32a <crs_strlen>
 800e278:	b283      	uxth	r3, r0
 800e27a:	462a      	mov	r2, r5
 800e27c:	2110      	movs	r1, #16
 800e27e:	2002      	movs	r0, #2
 800e280:	f011 f896 	bl	801f3b0 <traceIF_itmPrint>
 800e284:	4628      	mov	r0, r5
 800e286:	f011 f850 	bl	801f32a <crs_strlen>
 800e28a:	b283      	uxth	r3, r0
 800e28c:	462a      	mov	r2, r5
 800e28e:	2110      	movs	r1, #16
 800e290:	2002      	movs	r0, #2
 800e292:	f011 f8af 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800e296:	2501      	movs	r5, #1
 800e298:	e4d9      	b.n	800dc4e <atcm_modem_get_urc+0x10a>
    retval = ATSTATUS_OK_PENDING_URC;
 800e29a:	2503      	movs	r5, #3
}
 800e29c:	4628      	mov	r0, r5
 800e29e:	b003      	add	sp, #12
 800e2a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    retval = ATSTATUS_OK_PENDING_URC;
 800e2a2:	2503      	movs	r5, #3
 800e2a4:	e7fa      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2a6:	2503      	movs	r5, #3
 800e2a8:	e7f8      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2aa:	2503      	movs	r5, #3
 800e2ac:	e7f6      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ae:	2503      	movs	r5, #3
 800e2b0:	e7f4      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2b2:	2503      	movs	r5, #3
 800e2b4:	e7f2      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2b6:	2503      	movs	r5, #3
 800e2b8:	e7f0      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ba:	2503      	movs	r5, #3
 800e2bc:	e7ee      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2be:	2503      	movs	r5, #3
 800e2c0:	e7ec      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2c2:	2503      	movs	r5, #3
 800e2c4:	e7ea      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2c6:	2503      	movs	r5, #3
 800e2c8:	e7e8      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ca:	2503      	movs	r5, #3
 800e2cc:	e7e6      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2ce:	2503      	movs	r5, #3
 800e2d0:	e7e4      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2d2:	2503      	movs	r5, #3
 800e2d4:	e7e2      	b.n	800e29c <atcm_modem_get_urc+0x758>
 800e2d6:	bf00      	nop
 800e2d8:	200048dc 	.word	0x200048dc
 800e2dc:	0802ed3c 	.word	0x0802ed3c
 800e2e0:	0802ed6c 	.word	0x0802ed6c
 800e2e4:	0802ed90 	.word	0x0802ed90
 800e2e8:	0802edd4 	.word	0x0802edd4

0800e2ec <atcm_reset_persistent_context>:
{
 800e2ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e2f0:	4605      	mov	r5, r0
  PRINT_API("enter reset_persistent_context()")
 800e2f2:	4f61      	ldr	r7, [pc, #388]	; (800e478 <atcm_reset_persistent_context+0x18c>)
 800e2f4:	4e61      	ldr	r6, [pc, #388]	; (800e47c <atcm_reset_persistent_context+0x190>)
 800e2f6:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 800e2fa:	463c      	mov	r4, r7
 800e2fc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800e2fe:	6030      	str	r0, [r6, #0]
 800e300:	6071      	str	r1, [r6, #4]
 800e302:	60b2      	str	r2, [r6, #8]
 800e304:	60f3      	str	r3, [r6, #12]
 800e306:	4627      	mov	r7, r4
 800e308:	3610      	adds	r6, #16
 800e30a:	4564      	cmp	r4, ip
 800e30c:	d1f5      	bne.n	800e2fa <atcm_reset_persistent_context+0xe>
 800e30e:	4c5b      	ldr	r4, [pc, #364]	; (800e47c <atcm_reset_persistent_context+0x190>)
 800e310:	4620      	mov	r0, r4
 800e312:	f011 f80a 	bl	801f32a <crs_strlen>
 800e316:	b283      	uxth	r3, r0
 800e318:	4622      	mov	r2, r4
 800e31a:	2104      	movs	r1, #4
 800e31c:	2002      	movs	r0, #2
 800e31e:	f011 f847 	bl	801f3b0 <traceIF_itmPrint>
 800e322:	4620      	mov	r0, r4
 800e324:	f011 f801 	bl	801f32a <crs_strlen>
 800e328:	b283      	uxth	r3, r0
 800e32a:	4622      	mov	r2, r4
 800e32c:	2104      	movs	r1, #4
 800e32e:	2002      	movs	r0, #2
 800e330:	f011 f860 	bl	801f3f4 <traceIF_uartPrint>
  p_persistent_ctxt->urc_subscript_eps_networkReg = CELLULAR_FALSE;
 800e334:	2400      	movs	r4, #0
 800e336:	702c      	strb	r4, [r5, #0]
  p_persistent_ctxt->urc_subscript_eps_locationInfo = CELLULAR_FALSE;
 800e338:	706c      	strb	r4, [r5, #1]
  p_persistent_ctxt->urc_subscript_gprs_networkReg = CELLULAR_FALSE;
 800e33a:	70ac      	strb	r4, [r5, #2]
  p_persistent_ctxt->urc_subscript_gprs_locationInfo = CELLULAR_FALSE;
 800e33c:	70ec      	strb	r4, [r5, #3]
  p_persistent_ctxt->urc_subscript_cs_networkReg = CELLULAR_FALSE;
 800e33e:	712c      	strb	r4, [r5, #4]
  p_persistent_ctxt->urc_subscript_cs_locationInfo = CELLULAR_FALSE;
 800e340:	716c      	strb	r4, [r5, #5]
  p_persistent_ctxt->urc_subscript_signalQuality = CELLULAR_FALSE;
 800e342:	71ac      	strb	r4, [r5, #6]
  p_persistent_ctxt->urc_subscript_pdn_event = CELLULAR_FALSE;
 800e344:	71ec      	strb	r4, [r5, #7]
  p_persistent_ctxt->urc_avail_eps_network_registration = AT_FALSE;
 800e346:	722c      	strb	r4, [r5, #8]
  p_persistent_ctxt->urc_avail_eps_location_info_tac = AT_FALSE;
 800e348:	726c      	strb	r4, [r5, #9]
  p_persistent_ctxt->urc_avail_eps_location_info_ci = AT_FALSE;
 800e34a:	72ac      	strb	r4, [r5, #10]
  p_persistent_ctxt->urc_avail_gprs_network_registration = AT_FALSE;
 800e34c:	72ec      	strb	r4, [r5, #11]
  p_persistent_ctxt->urc_avail_gprs_location_info_lac = AT_FALSE;
 800e34e:	732c      	strb	r4, [r5, #12]
  p_persistent_ctxt->urc_avail_gprs_location_info_ci = AT_FALSE;
 800e350:	736c      	strb	r4, [r5, #13]
  p_persistent_ctxt->urc_avail_cs_network_registration = AT_FALSE;
 800e352:	73ac      	strb	r4, [r5, #14]
  p_persistent_ctxt->urc_avail_cs_location_info_lac = AT_FALSE;
 800e354:	73ec      	strb	r4, [r5, #15]
  p_persistent_ctxt->urc_avail_cs_location_info_ci = AT_FALSE;
 800e356:	742c      	strb	r4, [r5, #16]
  p_persistent_ctxt->urc_avail_signal_quality = AT_FALSE;
 800e358:	746c      	strb	r4, [r5, #17]
  p_persistent_ctxt->urc_avail_socket_data_pending = AT_FALSE;
 800e35a:	74ac      	strb	r4, [r5, #18]
  p_persistent_ctxt->urc_avail_socket_closed_by_remote = AT_FALSE;
 800e35c:	74ec      	strb	r4, [r5, #19]
  p_persistent_ctxt->urc_avail_pdn_event = AT_FALSE;
 800e35e:	752c      	strb	r4, [r5, #20]
  p_persistent_ctxt->modem_events_subscript = CS_MDMEVENT_NONE;
 800e360:	82ec      	strh	r4, [r5, #22]
  p_persistent_ctxt->urc_avail_modem_events = CS_MDMEVENT_NONE;
 800e362:	832c      	strh	r4, [r5, #24]
  reset_pdn_event(p_persistent_ctxt);
 800e364:	4628      	mov	r0, r5
 800e366:	f7ff fbe1 	bl	800db2c <reset_pdn_event>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e36a:	e01c      	b.n	800e3a6 <atcm_reset_persistent_context+0xba>
    p_tmp->mdm_cid_value = i; /* modem cid value (0 is a reserved value) */
 800e36c:	0126      	lsls	r6, r4, #4
 800e36e:	eb04 1804 	add.w	r8, r4, r4, lsl #4
 800e372:	eb05 0888 	add.w	r8, r5, r8, lsl #2
 800e376:	f888 4350 	strb.w	r4, [r8, #848]	; 0x350
    p_tmp->pdn_defined = AT_FALSE;
 800e37a:	2700      	movs	r7, #0
 800e37c:	f888 7351 	strb.w	r7, [r8, #849]	; 0x351
    p_tmp->affected_config = atcm_convert_index_to_PDN_conf(i);
 800e380:	4620      	mov	r0, r4
 800e382:	f7ff fb7b 	bl	800da7c <atcm_convert_index_to_PDN_conf>
 800e386:	f888 0352 	strb.w	r0, [r8, #850]	; 0x352
    p_tmp->ip_addr_infos.ip_addr_type = CS_IPAT_INVALID;
 800e38a:	f888 7353 	strb.w	r7, [r8, #851]	; 0x353
    (void) memset((void *)&p_tmp->ip_addr_infos.ip_addr_value, 0, MAX_IP_ADDR_SIZE);
 800e38e:	1930      	adds	r0, r6, r4
 800e390:	0080      	lsls	r0, r0, #2
 800e392:	f500 7054 	add.w	r0, r0, #848	; 0x350
 800e396:	4428      	add	r0, r5
 800e398:	2240      	movs	r2, #64	; 0x40
 800e39a:	4639      	mov	r1, r7
 800e39c:	3004      	adds	r0, #4
 800e39e:	f018 fac6 	bl	802692e <memset>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e3a2:	3401      	adds	r4, #1
 800e3a4:	b2e4      	uxtb	r4, r4
 800e3a6:	2c05      	cmp	r4, #5
 800e3a8:	d9e0      	bls.n	800e36c <atcm_reset_persistent_context+0x80>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e3aa:	2400      	movs	r4, #0
 800e3ac:	e01c      	b.n	800e3e8 <atcm_reset_persistent_context+0xfc>
    p_tmp->conf_id = CS_PDN_NOT_DEFINED; /* not used */
 800e3ae:	01a6      	lsls	r6, r4, #6
 800e3b0:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800e3b4:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800e3b8:	220c      	movs	r2, #12
 800e3ba:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
    (void) memset((void *)&p_tmp->apn, 0, MAX_APN_SIZE);
 800e3be:	eb04 1084 	add.w	r0, r4, r4, lsl #6
 800e3c2:	0040      	lsls	r0, r0, #1
 800e3c4:	3040      	adds	r0, #64	; 0x40
 800e3c6:	4428      	add	r0, r5
 800e3c8:	2240      	movs	r2, #64	; 0x40
 800e3ca:	2100      	movs	r1, #0
 800e3cc:	3005      	adds	r0, #5
 800e3ce:	f018 faae 	bl	802692e <memset>
    (void) memset((void *)&p_tmp->pdn_conf, 0, sizeof(CS_PDN_configuration_t));
 800e3d2:	1930      	adds	r0, r6, r4
 800e3d4:	0040      	lsls	r0, r0, #1
 800e3d6:	3080      	adds	r0, #128	; 0x80
 800e3d8:	4428      	add	r0, r5
 800e3da:	2241      	movs	r2, #65	; 0x41
 800e3dc:	2100      	movs	r1, #0
 800e3de:	3005      	adds	r0, #5
 800e3e0:	f018 faa5 	bl	802692e <memset>
  for (uint8_t i = 0U; i < MODEM_MAX_NB_PDP_CTXT; i++)
 800e3e4:	3401      	adds	r4, #1
 800e3e6:	b2e4      	uxtb	r4, r4
 800e3e8:	2c05      	cmp	r4, #5
 800e3ea:	d9e0      	bls.n	800e3ae <atcm_reset_persistent_context+0xc2>
  p_persistent_ctxt->pdn_default_conf_id = CS_PDN_PREDEF_CONFIG;
 800e3ec:	2400      	movs	r4, #0
 800e3ee:	f885 44e8 	strb.w	r4, [r5, #1256]	; 0x4e8
  p_predef->conf_id = CS_PDN_PREDEF_CONFIG;
 800e3f2:	f885 4044 	strb.w	r4, [r5, #68]	; 0x44
  reserve_user_modem_cid(p_persistent_ctxt, CS_PDN_PREDEF_CONFIG, 1U);
 800e3f6:	2201      	movs	r2, #1
 800e3f8:	4621      	mov	r1, r4
 800e3fa:	4628      	mov	r0, r5
 800e3fc:	f7ff fb48 	bl	800da90 <reserve_user_modem_cid>
  p_predef->pdn_conf.pdp_type = CS_PDPTYPE_IP;
 800e400:	f885 4085 	strb.w	r4, [r5, #133]	; 0x85
  (void) memcpy((AT_CHAR_t *)&p_predef->apn, "", sizeof(""));
 800e404:	f885 4045 	strb.w	r4, [r5, #69]	; 0x45
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 800e408:	4621      	mov	r1, r4
 800e40a:	e00b      	b.n	800e424 <atcm_reset_persistent_context+0x138>
    p_tmp = &p_persistent_ctxt->socket[i];
 800e40c:	460b      	mov	r3, r1
    p_tmp->socket_connId_value = ((uint8_t)i + 1U); /* socket ID range from 1 to 6,
 800e40e:	3101      	adds	r1, #1
 800e410:	b2c9      	uxtb	r1, r1
 800e412:	f503 739d 	add.w	r3, r3, #314	; 0x13a
 800e416:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 800e41a:	7059      	strb	r1, [r3, #1]
    p_tmp->socket_connected = AT_FALSE;
 800e41c:	2200      	movs	r2, #0
 800e41e:	709a      	strb	r2, [r3, #2]
    p_tmp->socket_data_pending_urc = AT_FALSE;
 800e420:	70da      	strb	r2, [r3, #3]
    p_tmp->socket_closed_pending_urc = AT_FALSE;
 800e422:	711a      	strb	r2, [r3, #4]
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 800e424:	2905      	cmp	r1, #5
 800e426:	d9f1      	bls.n	800e40c <atcm_reset_persistent_context+0x120>
  p_persistent_ctxt->psm_urc_requested = AT_FALSE;       /* PSM default value */
 800e428:	2400      	movs	r4, #0
 800e42a:	f885 4501 	strb.w	r4, [r5, #1281]	; 0x501
  p_persistent_ctxt->modem_at_ready = AT_FALSE;     /* modem ready to receive AT commands */
 800e42e:	f885 4502 	strb.w	r4, [r5, #1282]	; 0x502
  p_persistent_ctxt->modem_sim_ready = AT_FALSE;    /* modem sim ready */
 800e432:	f885 4503 	strb.w	r4, [r5, #1283]	; 0x503
  p_persistent_ctxt->sim_pin_code_ready = AT_FALSE; /* modem pin code status */
 800e436:	f885 4504 	strb.w	r4, [r5, #1284]	; 0x504
  p_persistent_ctxt->cmee_level = CMEE_VERBOSE;
 800e43a:	2302      	movs	r3, #2
 800e43c:	f885 3507 	strb.w	r3, [r5, #1287]	; 0x507
  p_persistent_ctxt->sim_state = CS_SIMSTATE_UNKNOWN;
 800e440:	f885 4505 	strb.w	r4, [r5, #1285]	; 0x505
  p_persistent_ctxt->sim_selected = CS_MODEM_SIM_SOCKET_0; /* default SIM slot selected */
 800e444:	f885 4506 	strb.w	r4, [r5, #1286]	; 0x506
  p_persistent_ctxt->flowCtrl_RTS = 0xFF;       /* not initialized (from AT+IFC) */
 800e448:	26ff      	movs	r6, #255	; 0xff
 800e44a:	f885 6508 	strb.w	r6, [r5, #1288]	; 0x508
  p_persistent_ctxt->flowCtrl_CTS = 0xFF;       /* not initialized (from AT+IFC) */
 800e44e:	f885 6509 	strb.w	r6, [r5, #1289]	; 0x509
  (void) memset((void *)&p_persistent_ctxt->ping_infos, 0, sizeof(csint_ping_params_t));
 800e452:	2243      	movs	r2, #67	; 0x43
 800e454:	4621      	mov	r1, r4
 800e456:	f205 500a 	addw	r0, r5, #1290	; 0x50a
 800e45a:	f018 fa68 	bl	802692e <memset>
  (void) memset((void *)&p_persistent_ctxt->ping_resp_urc, 0, sizeof(CS_Ping_response_t));
 800e45e:	2250      	movs	r2, #80	; 0x50
 800e460:	4621      	mov	r1, r4
 800e462:	f505 60aa 	add.w	r0, r5, #1360	; 0x550
 800e466:	f018 fa62 	bl	802692e <memset>
  p_persistent_ctxt->ping_resp_urc.index = PING_INVALID_INDEX;
 800e46a:	f885 6550 	strb.w	r6, [r5, #1360]	; 0x550
  p_persistent_ctxt->urc_avail_ping_rsp = AT_FALSE;
 800e46e:	f885 45a0 	strb.w	r4, [r5, #1440]	; 0x5a0
}
 800e472:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800e476:	bf00      	nop
 800e478:	0802edf4 	.word	0x0802edf4
 800e47c:	200048dc 	.word	0x200048dc

0800e480 <atcm_modem_init>:
{
 800e480:	b570      	push	{r4, r5, r6, lr}
 800e482:	4605      	mov	r5, r0
  PRINT_API("enter atcm_modem_init")
 800e484:	4e1c      	ldr	r6, [pc, #112]	; (800e4f8 <atcm_modem_init+0x78>)
 800e486:	4c1d      	ldr	r4, [pc, #116]	; (800e4fc <atcm_modem_init+0x7c>)
 800e488:	f106 0e20 	add.w	lr, r6, #32
 800e48c:	46b4      	mov	ip, r6
 800e48e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800e492:	6020      	str	r0, [r4, #0]
 800e494:	6061      	str	r1, [r4, #4]
 800e496:	60a2      	str	r2, [r4, #8]
 800e498:	60e3      	str	r3, [r4, #12]
 800e49a:	4666      	mov	r6, ip
 800e49c:	3410      	adds	r4, #16
 800e49e:	45f4      	cmp	ip, lr
 800e4a0:	d1f4      	bne.n	800e48c <atcm_modem_init+0xc>
 800e4a2:	f8dc 0000 	ldr.w	r0, [ip]
 800e4a6:	6020      	str	r0, [r4, #0]
 800e4a8:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800e4ac:	7123      	strb	r3, [r4, #4]
 800e4ae:	4c13      	ldr	r4, [pc, #76]	; (800e4fc <atcm_modem_init+0x7c>)
 800e4b0:	4620      	mov	r0, r4
 800e4b2:	f010 ff3a 	bl	801f32a <crs_strlen>
 800e4b6:	b283      	uxth	r3, r0
 800e4b8:	4622      	mov	r2, r4
 800e4ba:	2104      	movs	r1, #4
 800e4bc:	2002      	movs	r0, #2
 800e4be:	f010 ff77 	bl	801f3b0 <traceIF_itmPrint>
 800e4c2:	4620      	mov	r0, r4
 800e4c4:	f010 ff31 	bl	801f32a <crs_strlen>
 800e4c8:	b283      	uxth	r3, r0
 800e4ca:	4622      	mov	r2, r4
 800e4cc:	2104      	movs	r1, #4
 800e4ce:	2002      	movs	r0, #2
 800e4d0:	f010 ff90 	bl	801f3f4 <traceIF_uartPrint>
  atcm_reset_persistent_context(&p_modem_ctxt->persist);
 800e4d4:	f105 000c 	add.w	r0, r5, #12
 800e4d8:	f7ff ff08 	bl	800e2ec <atcm_reset_persistent_context>
  atcm_reset_SID_context(&p_modem_ctxt->SID_ctxt);
 800e4dc:	f505 60b6 	add.w	r0, r5, #1456	; 0x5b0
 800e4e0:	f7fe fe84 	bl	800d1ec <atcm_reset_SID_context>
  atcm_reset_CMD_context(&p_modem_ctxt->CMD_ctxt);
 800e4e4:	f205 702c 	addw	r0, r5, #1836	; 0x72c
 800e4e8:	f7fe fef8 	bl	800d2dc <atcm_reset_CMD_context>
  atcm_reset_SOCKET_context(p_modem_ctxt);
 800e4ec:	4628      	mov	r0, r5
 800e4ee:	f7fe ff31 	bl	800d354 <atcm_reset_SOCKET_context>
  p_modem_ctxt->state_SyntaxAutomaton = WAITING_FOR_INIT_CR;
 800e4f2:	2300      	movs	r3, #0
 800e4f4:	722b      	strb	r3, [r5, #8]
}
 800e4f6:	bd70      	pop	{r4, r5, r6, pc}
 800e4f8:	0802ee24 	.word	0x0802ee24
 800e4fc:	200048dc 	.word	0x200048dc

0800e500 <atcm_modem_reset>:
{
 800e500:	b570      	push	{r4, r5, r6, lr}
 800e502:	4606      	mov	r6, r0
  PRINT_API("enter atcm_modem_reset")
 800e504:	4d1a      	ldr	r5, [pc, #104]	; (800e570 <atcm_modem_reset+0x70>)
 800e506:	4c1b      	ldr	r4, [pc, #108]	; (800e574 <atcm_modem_reset+0x74>)
 800e508:	f105 0e20 	add.w	lr, r5, #32
 800e50c:	46ac      	mov	ip, r5
 800e50e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800e512:	6020      	str	r0, [r4, #0]
 800e514:	6061      	str	r1, [r4, #4]
 800e516:	60a2      	str	r2, [r4, #8]
 800e518:	60e3      	str	r3, [r4, #12]
 800e51a:	4665      	mov	r5, ip
 800e51c:	3410      	adds	r4, #16
 800e51e:	45f4      	cmp	ip, lr
 800e520:	d1f4      	bne.n	800e50c <atcm_modem_reset+0xc>
 800e522:	f8dc 0000 	ldr.w	r0, [ip]
 800e526:	6020      	str	r0, [r4, #0]
 800e528:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800e52c:	80a3      	strh	r3, [r4, #4]
 800e52e:	4c11      	ldr	r4, [pc, #68]	; (800e574 <atcm_modem_reset+0x74>)
 800e530:	4620      	mov	r0, r4
 800e532:	f010 fefa 	bl	801f32a <crs_strlen>
 800e536:	b283      	uxth	r3, r0
 800e538:	4622      	mov	r2, r4
 800e53a:	2104      	movs	r1, #4
 800e53c:	2002      	movs	r0, #2
 800e53e:	f010 ff37 	bl	801f3b0 <traceIF_itmPrint>
 800e542:	4620      	mov	r0, r4
 800e544:	f010 fef1 	bl	801f32a <crs_strlen>
 800e548:	b283      	uxth	r3, r0
 800e54a:	4622      	mov	r2, r4
 800e54c:	2104      	movs	r1, #4
 800e54e:	2002      	movs	r0, #2
 800e550:	f010 ff50 	bl	801f3f4 <traceIF_uartPrint>
  atcm_reset_persistent_context(&p_modem_ctxt->persist);
 800e554:	f106 000c 	add.w	r0, r6, #12
 800e558:	f7ff fec8 	bl	800e2ec <atcm_reset_persistent_context>
  atcm_reset_CMD_context(&p_modem_ctxt->CMD_ctxt);
 800e55c:	f206 702c 	addw	r0, r6, #1836	; 0x72c
 800e560:	f7fe febc 	bl	800d2dc <atcm_reset_CMD_context>
  atcm_reset_SOCKET_context(p_modem_ctxt);
 800e564:	4630      	mov	r0, r6
 800e566:	f7fe fef5 	bl	800d354 <atcm_reset_SOCKET_context>
  p_modem_ctxt->state_SyntaxAutomaton = WAITING_FOR_INIT_CR;
 800e56a:	2300      	movs	r3, #0
 800e56c:	7233      	strb	r3, [r6, #8]
}
 800e56e:	bd70      	pop	{r4, r5, r6, pc}
 800e570:	0802ee4c 	.word	0x0802ee4c
 800e574:	200048dc 	.word	0x200048dc

0800e578 <set_error_report>:
/*
 * Update error report that will be sent to Cellular Service
 */
static void set_error_report(csint_error_type_t err_type, atcustom_modem_context_t *p_modem_ctxt)
{
  p_modem_ctxt->SID_ctxt.error_report.error_type = err_type;
 800e578:	f881 072a 	strb.w	r0, [r1, #1834]	; 0x72a

  switch (err_type)
 800e57c:	2801      	cmp	r0, #1
 800e57e:	d000      	beq.n	800e582 <set_error_report+0xa>

    default:
      /* nothing to do*/
      break;
  }
}
 800e580:	4770      	bx	lr
      p_modem_ctxt->SID_ctxt.error_report.sim_state = p_modem_ctxt->persist.sim_state;
 800e582:	f891 3511 	ldrb.w	r3, [r1, #1297]	; 0x511
 800e586:	f881 372b 	strb.w	r3, [r1, #1835]	; 0x72b
}
 800e58a:	e7f9      	b.n	800e580 <set_error_report+0x8>

0800e58c <display_clear_network_state>:
{
 800e58c:	b538      	push	{r3, r4, r5, lr}
  if (network_type <= EPS_NETWORK_TYPE)
 800e58e:	2903      	cmp	r1, #3
 800e590:	f200 815b 	bhi.w	800e84a <display_clear_network_state+0x2be>
    switch (state)
 800e594:	280a      	cmp	r0, #10
 800e596:	f200 8136 	bhi.w	800e806 <display_clear_network_state+0x27a>
 800e59a:	e8df f010 	tbh	[pc, r0, lsl #1]
 800e59e:	000b      	.short	0x000b
 800e5a0:	00410026 	.word	0x00410026
 800e5a4:	0077005c 	.word	0x0077005c
 800e5a8:	00ad0092 	.word	0x00ad0092
 800e5ac:	00e300c8 	.word	0x00e300c8
 800e5b0:	011900fe 	.word	0x011900fe
        PRINT_INFO("NetworkState %s = NOT_REGISTERED_NOT_SEARCHING", NETWORK_TYPE_LUT[network_type])
 800e5b4:	4cb1      	ldr	r4, [pc, #708]	; (800e87c <display_clear_network_state+0x2f0>)
 800e5b6:	4ab2      	ldr	r2, [pc, #712]	; (800e880 <display_clear_network_state+0x2f4>)
 800e5b8:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e5bc:	49b1      	ldr	r1, [pc, #708]	; (800e884 <display_clear_network_state+0x2f8>)
 800e5be:	4620      	mov	r0, r4
 800e5c0:	f018 f942 	bl	8026848 <sprintf>
 800e5c4:	4620      	mov	r0, r4
 800e5c6:	f010 feb0 	bl	801f32a <crs_strlen>
 800e5ca:	b283      	uxth	r3, r0
 800e5cc:	4622      	mov	r2, r4
 800e5ce:	2101      	movs	r1, #1
 800e5d0:	2002      	movs	r0, #2
 800e5d2:	f010 feed 	bl	801f3b0 <traceIF_itmPrint>
 800e5d6:	4620      	mov	r0, r4
 800e5d8:	f010 fea7 	bl	801f32a <crs_strlen>
 800e5dc:	b283      	uxth	r3, r0
 800e5de:	4622      	mov	r2, r4
 800e5e0:	2101      	movs	r1, #1
 800e5e2:	2002      	movs	r0, #2
 800e5e4:	f010 ff06 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e5e8:	e147      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_HOME_NETWORK", NETWORK_TYPE_LUT[network_type])
 800e5ea:	4ca4      	ldr	r4, [pc, #656]	; (800e87c <display_clear_network_state+0x2f0>)
 800e5ec:	4aa4      	ldr	r2, [pc, #656]	; (800e880 <display_clear_network_state+0x2f4>)
 800e5ee:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e5f2:	49a5      	ldr	r1, [pc, #660]	; (800e888 <display_clear_network_state+0x2fc>)
 800e5f4:	4620      	mov	r0, r4
 800e5f6:	f018 f927 	bl	8026848 <sprintf>
 800e5fa:	4620      	mov	r0, r4
 800e5fc:	f010 fe95 	bl	801f32a <crs_strlen>
 800e600:	b283      	uxth	r3, r0
 800e602:	4622      	mov	r2, r4
 800e604:	2101      	movs	r1, #1
 800e606:	2002      	movs	r0, #2
 800e608:	f010 fed2 	bl	801f3b0 <traceIF_itmPrint>
 800e60c:	4620      	mov	r0, r4
 800e60e:	f010 fe8c 	bl	801f32a <crs_strlen>
 800e612:	b283      	uxth	r3, r0
 800e614:	4622      	mov	r2, r4
 800e616:	2101      	movs	r1, #1
 800e618:	2002      	movs	r0, #2
 800e61a:	f010 feeb 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e61e:	e12c      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = NOT_REGISTERED_SEARCHING", NETWORK_TYPE_LUT[network_type])
 800e620:	4c96      	ldr	r4, [pc, #600]	; (800e87c <display_clear_network_state+0x2f0>)
 800e622:	4a97      	ldr	r2, [pc, #604]	; (800e880 <display_clear_network_state+0x2f4>)
 800e624:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e628:	4998      	ldr	r1, [pc, #608]	; (800e88c <display_clear_network_state+0x300>)
 800e62a:	4620      	mov	r0, r4
 800e62c:	f018 f90c 	bl	8026848 <sprintf>
 800e630:	4620      	mov	r0, r4
 800e632:	f010 fe7a 	bl	801f32a <crs_strlen>
 800e636:	b283      	uxth	r3, r0
 800e638:	4622      	mov	r2, r4
 800e63a:	2101      	movs	r1, #1
 800e63c:	2002      	movs	r0, #2
 800e63e:	f010 feb7 	bl	801f3b0 <traceIF_itmPrint>
 800e642:	4620      	mov	r0, r4
 800e644:	f010 fe71 	bl	801f32a <crs_strlen>
 800e648:	b283      	uxth	r3, r0
 800e64a:	4622      	mov	r2, r4
 800e64c:	2101      	movs	r1, #1
 800e64e:	2002      	movs	r0, #2
 800e650:	f010 fed0 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e654:	e111      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTRATION_DENIED", NETWORK_TYPE_LUT[network_type])
 800e656:	4c89      	ldr	r4, [pc, #548]	; (800e87c <display_clear_network_state+0x2f0>)
 800e658:	4a89      	ldr	r2, [pc, #548]	; (800e880 <display_clear_network_state+0x2f4>)
 800e65a:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e65e:	498c      	ldr	r1, [pc, #560]	; (800e890 <display_clear_network_state+0x304>)
 800e660:	4620      	mov	r0, r4
 800e662:	f018 f8f1 	bl	8026848 <sprintf>
 800e666:	4620      	mov	r0, r4
 800e668:	f010 fe5f 	bl	801f32a <crs_strlen>
 800e66c:	b283      	uxth	r3, r0
 800e66e:	4622      	mov	r2, r4
 800e670:	2101      	movs	r1, #1
 800e672:	2002      	movs	r0, #2
 800e674:	f010 fe9c 	bl	801f3b0 <traceIF_itmPrint>
 800e678:	4620      	mov	r0, r4
 800e67a:	f010 fe56 	bl	801f32a <crs_strlen>
 800e67e:	b283      	uxth	r3, r0
 800e680:	4622      	mov	r2, r4
 800e682:	2101      	movs	r1, #1
 800e684:	2002      	movs	r0, #2
 800e686:	f010 feb5 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e68a:	e0f6      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = UNKNOWN", NETWORK_TYPE_LUT[network_type])
 800e68c:	4c7b      	ldr	r4, [pc, #492]	; (800e87c <display_clear_network_state+0x2f0>)
 800e68e:	4a7c      	ldr	r2, [pc, #496]	; (800e880 <display_clear_network_state+0x2f4>)
 800e690:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e694:	497f      	ldr	r1, [pc, #508]	; (800e894 <display_clear_network_state+0x308>)
 800e696:	4620      	mov	r0, r4
 800e698:	f018 f8d6 	bl	8026848 <sprintf>
 800e69c:	4620      	mov	r0, r4
 800e69e:	f010 fe44 	bl	801f32a <crs_strlen>
 800e6a2:	b283      	uxth	r3, r0
 800e6a4:	4622      	mov	r2, r4
 800e6a6:	2101      	movs	r1, #1
 800e6a8:	2002      	movs	r0, #2
 800e6aa:	f010 fe81 	bl	801f3b0 <traceIF_itmPrint>
 800e6ae:	4620      	mov	r0, r4
 800e6b0:	f010 fe3b 	bl	801f32a <crs_strlen>
 800e6b4:	b283      	uxth	r3, r0
 800e6b6:	4622      	mov	r2, r4
 800e6b8:	2101      	movs	r1, #1
 800e6ba:	2002      	movs	r0, #2
 800e6bc:	f010 fe9a 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e6c0:	e0db      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_ROAMING", NETWORK_TYPE_LUT[network_type])
 800e6c2:	4c6e      	ldr	r4, [pc, #440]	; (800e87c <display_clear_network_state+0x2f0>)
 800e6c4:	4a6e      	ldr	r2, [pc, #440]	; (800e880 <display_clear_network_state+0x2f4>)
 800e6c6:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e6ca:	4973      	ldr	r1, [pc, #460]	; (800e898 <display_clear_network_state+0x30c>)
 800e6cc:	4620      	mov	r0, r4
 800e6ce:	f018 f8bb 	bl	8026848 <sprintf>
 800e6d2:	4620      	mov	r0, r4
 800e6d4:	f010 fe29 	bl	801f32a <crs_strlen>
 800e6d8:	b283      	uxth	r3, r0
 800e6da:	4622      	mov	r2, r4
 800e6dc:	2101      	movs	r1, #1
 800e6de:	2002      	movs	r0, #2
 800e6e0:	f010 fe66 	bl	801f3b0 <traceIF_itmPrint>
 800e6e4:	4620      	mov	r0, r4
 800e6e6:	f010 fe20 	bl	801f32a <crs_strlen>
 800e6ea:	b283      	uxth	r3, r0
 800e6ec:	4622      	mov	r2, r4
 800e6ee:	2101      	movs	r1, #1
 800e6f0:	2002      	movs	r0, #2
 800e6f2:	f010 fe7f 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e6f6:	e0c0      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_SMS_ONLY_HOME_NETWORK", NETWORK_TYPE_LUT[network_type])
 800e6f8:	4c60      	ldr	r4, [pc, #384]	; (800e87c <display_clear_network_state+0x2f0>)
 800e6fa:	4a61      	ldr	r2, [pc, #388]	; (800e880 <display_clear_network_state+0x2f4>)
 800e6fc:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e700:	4966      	ldr	r1, [pc, #408]	; (800e89c <display_clear_network_state+0x310>)
 800e702:	4620      	mov	r0, r4
 800e704:	f018 f8a0 	bl	8026848 <sprintf>
 800e708:	4620      	mov	r0, r4
 800e70a:	f010 fe0e 	bl	801f32a <crs_strlen>
 800e70e:	b283      	uxth	r3, r0
 800e710:	4622      	mov	r2, r4
 800e712:	2101      	movs	r1, #1
 800e714:	2002      	movs	r0, #2
 800e716:	f010 fe4b 	bl	801f3b0 <traceIF_itmPrint>
 800e71a:	4620      	mov	r0, r4
 800e71c:	f010 fe05 	bl	801f32a <crs_strlen>
 800e720:	b283      	uxth	r3, r0
 800e722:	4622      	mov	r2, r4
 800e724:	2101      	movs	r1, #1
 800e726:	2002      	movs	r0, #2
 800e728:	f010 fe64 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e72c:	e0a5      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_SMS_ONLY_ROAMING", NETWORK_TYPE_LUT[network_type])
 800e72e:	4c53      	ldr	r4, [pc, #332]	; (800e87c <display_clear_network_state+0x2f0>)
 800e730:	4a53      	ldr	r2, [pc, #332]	; (800e880 <display_clear_network_state+0x2f4>)
 800e732:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e736:	495a      	ldr	r1, [pc, #360]	; (800e8a0 <display_clear_network_state+0x314>)
 800e738:	4620      	mov	r0, r4
 800e73a:	f018 f885 	bl	8026848 <sprintf>
 800e73e:	4620      	mov	r0, r4
 800e740:	f010 fdf3 	bl	801f32a <crs_strlen>
 800e744:	b283      	uxth	r3, r0
 800e746:	4622      	mov	r2, r4
 800e748:	2101      	movs	r1, #1
 800e74a:	2002      	movs	r0, #2
 800e74c:	f010 fe30 	bl	801f3b0 <traceIF_itmPrint>
 800e750:	4620      	mov	r0, r4
 800e752:	f010 fdea 	bl	801f32a <crs_strlen>
 800e756:	b283      	uxth	r3, r0
 800e758:	4622      	mov	r2, r4
 800e75a:	2101      	movs	r1, #1
 800e75c:	2002      	movs	r0, #2
 800e75e:	f010 fe49 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e762:	e08a      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = EMERGENCY_ONLY", NETWORK_TYPE_LUT[network_type])
 800e764:	4c45      	ldr	r4, [pc, #276]	; (800e87c <display_clear_network_state+0x2f0>)
 800e766:	4a46      	ldr	r2, [pc, #280]	; (800e880 <display_clear_network_state+0x2f4>)
 800e768:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e76c:	494d      	ldr	r1, [pc, #308]	; (800e8a4 <display_clear_network_state+0x318>)
 800e76e:	4620      	mov	r0, r4
 800e770:	f018 f86a 	bl	8026848 <sprintf>
 800e774:	4620      	mov	r0, r4
 800e776:	f010 fdd8 	bl	801f32a <crs_strlen>
 800e77a:	b283      	uxth	r3, r0
 800e77c:	4622      	mov	r2, r4
 800e77e:	2101      	movs	r1, #1
 800e780:	2002      	movs	r0, #2
 800e782:	f010 fe15 	bl	801f3b0 <traceIF_itmPrint>
 800e786:	4620      	mov	r0, r4
 800e788:	f010 fdcf 	bl	801f32a <crs_strlen>
 800e78c:	b283      	uxth	r3, r0
 800e78e:	4622      	mov	r2, r4
 800e790:	2101      	movs	r1, #1
 800e792:	2002      	movs	r0, #2
 800e794:	f010 fe2e 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e798:	e06f      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_CFSB_NP_HOME_NETWORK", NETWORK_TYPE_LUT[network_type])
 800e79a:	4c38      	ldr	r4, [pc, #224]	; (800e87c <display_clear_network_state+0x2f0>)
 800e79c:	4a38      	ldr	r2, [pc, #224]	; (800e880 <display_clear_network_state+0x2f4>)
 800e79e:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e7a2:	4941      	ldr	r1, [pc, #260]	; (800e8a8 <display_clear_network_state+0x31c>)
 800e7a4:	4620      	mov	r0, r4
 800e7a6:	f018 f84f 	bl	8026848 <sprintf>
 800e7aa:	4620      	mov	r0, r4
 800e7ac:	f010 fdbd 	bl	801f32a <crs_strlen>
 800e7b0:	b283      	uxth	r3, r0
 800e7b2:	4622      	mov	r2, r4
 800e7b4:	2101      	movs	r1, #1
 800e7b6:	2002      	movs	r0, #2
 800e7b8:	f010 fdfa 	bl	801f3b0 <traceIF_itmPrint>
 800e7bc:	4620      	mov	r0, r4
 800e7be:	f010 fdb4 	bl	801f32a <crs_strlen>
 800e7c2:	b283      	uxth	r3, r0
 800e7c4:	4622      	mov	r2, r4
 800e7c6:	2101      	movs	r1, #1
 800e7c8:	2002      	movs	r0, #2
 800e7ca:	f010 fe13 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e7ce:	e054      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("NetworkState %s = REGISTERED_CFSB_NP_ROAMING", NETWORK_TYPE_LUT[network_type])
 800e7d0:	4c2a      	ldr	r4, [pc, #168]	; (800e87c <display_clear_network_state+0x2f0>)
 800e7d2:	4a2b      	ldr	r2, [pc, #172]	; (800e880 <display_clear_network_state+0x2f4>)
 800e7d4:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800e7d8:	4934      	ldr	r1, [pc, #208]	; (800e8ac <display_clear_network_state+0x320>)
 800e7da:	4620      	mov	r0, r4
 800e7dc:	f018 f834 	bl	8026848 <sprintf>
 800e7e0:	4620      	mov	r0, r4
 800e7e2:	f010 fda2 	bl	801f32a <crs_strlen>
 800e7e6:	b283      	uxth	r3, r0
 800e7e8:	4622      	mov	r2, r4
 800e7ea:	2101      	movs	r1, #1
 800e7ec:	2002      	movs	r0, #2
 800e7ee:	f010 fddf 	bl	801f3b0 <traceIF_itmPrint>
 800e7f2:	4620      	mov	r0, r4
 800e7f4:	f010 fd99 	bl	801f32a <crs_strlen>
 800e7f8:	b283      	uxth	r3, r0
 800e7fa:	4622      	mov	r2, r4
 800e7fc:	2101      	movs	r1, #1
 800e7fe:	2002      	movs	r0, #2
 800e800:	f010 fdf8 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e804:	e039      	b.n	800e87a <display_clear_network_state+0x2ee>
        PRINT_INFO("unknown state value")
 800e806:	4c1d      	ldr	r4, [pc, #116]	; (800e87c <display_clear_network_state+0x2f0>)
 800e808:	4d29      	ldr	r5, [pc, #164]	; (800e8b0 <display_clear_network_state+0x324>)
 800e80a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800e80c:	6020      	str	r0, [r4, #0]
 800e80e:	6061      	str	r1, [r4, #4]
 800e810:	60a2      	str	r2, [r4, #8]
 800e812:	60e3      	str	r3, [r4, #12]
 800e814:	cd07      	ldmia	r5!, {r0, r1, r2}
 800e816:	6120      	str	r0, [r4, #16]
 800e818:	6161      	str	r1, [r4, #20]
 800e81a:	61a2      	str	r2, [r4, #24]
 800e81c:	882a      	ldrh	r2, [r5, #0]
 800e81e:	78ab      	ldrb	r3, [r5, #2]
 800e820:	83a2      	strh	r2, [r4, #28]
 800e822:	77a3      	strb	r3, [r4, #30]
 800e824:	4620      	mov	r0, r4
 800e826:	f010 fd80 	bl	801f32a <crs_strlen>
 800e82a:	b283      	uxth	r3, r0
 800e82c:	4622      	mov	r2, r4
 800e82e:	2101      	movs	r1, #1
 800e830:	2002      	movs	r0, #2
 800e832:	f010 fdbd 	bl	801f3b0 <traceIF_itmPrint>
 800e836:	4620      	mov	r0, r4
 800e838:	f010 fd77 	bl	801f32a <crs_strlen>
 800e83c:	b283      	uxth	r3, r0
 800e83e:	4622      	mov	r2, r4
 800e840:	2101      	movs	r1, #1
 800e842:	2002      	movs	r0, #2
 800e844:	f010 fdd6 	bl	801f3f4 <traceIF_uartPrint>
        break;
 800e848:	e017      	b.n	800e87a <display_clear_network_state+0x2ee>
    PRINT_ERR("Invalid network type %d", network_type)
 800e84a:	4c0c      	ldr	r4, [pc, #48]	; (800e87c <display_clear_network_state+0x2f0>)
 800e84c:	460a      	mov	r2, r1
 800e84e:	4919      	ldr	r1, [pc, #100]	; (800e8b4 <display_clear_network_state+0x328>)
 800e850:	4620      	mov	r0, r4
 800e852:	f017 fff9 	bl	8026848 <sprintf>
 800e856:	4620      	mov	r0, r4
 800e858:	f010 fd67 	bl	801f32a <crs_strlen>
 800e85c:	b283      	uxth	r3, r0
 800e85e:	4622      	mov	r2, r4
 800e860:	2110      	movs	r1, #16
 800e862:	2002      	movs	r0, #2
 800e864:	f010 fda4 	bl	801f3b0 <traceIF_itmPrint>
 800e868:	4620      	mov	r0, r4
 800e86a:	f010 fd5e 	bl	801f32a <crs_strlen>
 800e86e:	b283      	uxth	r3, r0
 800e870:	4622      	mov	r2, r4
 800e872:	2110      	movs	r1, #16
 800e874:	2002      	movs	r0, #2
 800e876:	f010 fdbd 	bl	801f3f4 <traceIF_uartPrint>
}
 800e87a:	bd38      	pop	{r3, r4, r5, pc}
 800e87c:	200048dc 	.word	0x200048dc
 800e880:	08031350 	.word	0x08031350
 800e884:	0802eeb8 	.word	0x0802eeb8
 800e888:	0802eef4 	.word	0x0802eef4
 800e88c:	0802ef2c 	.word	0x0802ef2c
 800e890:	0802ef64 	.word	0x0802ef64
 800e894:	0802ef98 	.word	0x0802ef98
 800e898:	0802efc0 	.word	0x0802efc0
 800e89c:	0802eff0 	.word	0x0802eff0
 800e8a0:	0802f030 	.word	0x0802f030
 800e8a4:	0802f06c 	.word	0x0802f06c
 800e8a8:	0802f098 	.word	0x0802f098
 800e8ac:	0802f0d8 	.word	0x0802f0d8
 800e8b0:	0802f110 	.word	0x0802f110
 800e8b4:	0802f130 	.word	0x0802f130

0800e8b8 <convert_NetworkState>:
{
 800e8b8:	b510      	push	{r4, lr}
  switch (state)
 800e8ba:	280a      	cmp	r0, #10
 800e8bc:	d81f      	bhi.n	800e8fe <convert_NetworkState+0x46>
 800e8be:	e8df f000 	tbb	[pc, r0]
 800e8c2:	2006      	.short	0x2006
 800e8c4:	12100e0c 	.word	0x12100e0c
 800e8c8:	1a181614 	.word	0x1a181614
 800e8cc:	1c          	.byte	0x1c
 800e8cd:	00          	.byte	0x00
 800e8ce:	2400      	movs	r4, #0
  display_clear_network_state(retval, network_type);
 800e8d0:	4620      	mov	r0, r4
 800e8d2:	f7ff fe5b 	bl	800e58c <display_clear_network_state>
}
 800e8d6:	4620      	mov	r0, r4
 800e8d8:	bd10      	pop	{r4, pc}
      retval = CS_NRS_NOT_REGISTERED_SEARCHING;
 800e8da:	2402      	movs	r4, #2
      break;
 800e8dc:	e7f8      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTRATION_DENIED;
 800e8de:	2403      	movs	r4, #3
      break;
 800e8e0:	e7f6      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_UNKNOWN;
 800e8e2:	2404      	movs	r4, #4
      break;
 800e8e4:	e7f4      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_ROAMING;
 800e8e6:	2405      	movs	r4, #5
      break;
 800e8e8:	e7f2      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_SMS_ONLY_HOME_NETWORK;
 800e8ea:	2406      	movs	r4, #6
      break;
 800e8ec:	e7f0      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_SMS_ONLY_ROAMING;
 800e8ee:	2407      	movs	r4, #7
      break;
 800e8f0:	e7ee      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_EMERGENCY_ONLY;
 800e8f2:	2408      	movs	r4, #8
      break;
 800e8f4:	e7ec      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_CFSB_NP_HOME_NETWORK;
 800e8f6:	2409      	movs	r4, #9
      break;
 800e8f8:	e7ea      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_CFSB_NP_ROAMING;
 800e8fa:	240a      	movs	r4, #10
      break;
 800e8fc:	e7e8      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_UNKNOWN;
 800e8fe:	2404      	movs	r4, #4
      break;
 800e900:	e7e6      	b.n	800e8d0 <convert_NetworkState+0x18>
      retval = CS_NRS_REGISTERED_HOME_NETWORK;
 800e902:	2401      	movs	r4, #1
 800e904:	e7e4      	b.n	800e8d0 <convert_NetworkState+0x18>
	...

0800e908 <analyze_CmeError>:
{
 800e908:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e90c:	b088      	sub	sp, #32
 800e90e:	4680      	mov	r8, r0
 800e910:	4689      	mov	r9, r1
 800e912:	4617      	mov	r7, r2
 800e914:	461e      	mov	r6, r3
  PRINT_API("enter analyze_CmeError_CPIN()")
 800e916:	4ca9      	ldr	r4, [pc, #676]	; (800ebbc <analyze_CmeError+0x2b4>)
 800e918:	4da9      	ldr	r5, [pc, #676]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e91a:	f104 0e20 	add.w	lr, r4, #32
 800e91e:	46a4      	mov	ip, r4
 800e920:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800e924:	6028      	str	r0, [r5, #0]
 800e926:	6069      	str	r1, [r5, #4]
 800e928:	60aa      	str	r2, [r5, #8]
 800e92a:	60eb      	str	r3, [r5, #12]
 800e92c:	4664      	mov	r4, ip
 800e92e:	3510      	adds	r5, #16
 800e930:	45f4      	cmp	ip, lr
 800e932:	d1f4      	bne.n	800e91e <analyze_CmeError+0x16>
 800e934:	cc07      	ldmia	r4!, {r0, r1, r2}
 800e936:	6028      	str	r0, [r5, #0]
 800e938:	6069      	str	r1, [r5, #4]
 800e93a:	60aa      	str	r2, [r5, #8]
 800e93c:	7823      	ldrb	r3, [r4, #0]
 800e93e:	732b      	strb	r3, [r5, #12]
 800e940:	4c9f      	ldr	r4, [pc, #636]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e942:	4620      	mov	r0, r4
 800e944:	f010 fcf1 	bl	801f32a <crs_strlen>
 800e948:	b283      	uxth	r3, r0
 800e94a:	4622      	mov	r2, r4
 800e94c:	2104      	movs	r1, #4
 800e94e:	2002      	movs	r0, #2
 800e950:	f010 fd2e 	bl	801f3b0 <traceIF_itmPrint>
 800e954:	4620      	mov	r0, r4
 800e956:	f010 fce8 	bl	801f32a <crs_strlen>
 800e95a:	b283      	uxth	r3, r0
 800e95c:	4622      	mov	r2, r4
 800e95e:	2104      	movs	r1, #4
 800e960:	2002      	movs	r0, #2
 800e962:	f010 fd47 	bl	801f3f4 <traceIF_uartPrint>
  START_PARAM_LOOP()
 800e966:	2400      	movs	r4, #0
 800e968:	4632      	mov	r2, r6
 800e96a:	4639      	mov	r1, r7
 800e96c:	4640      	mov	r0, r8
 800e96e:	f7fd fd6b 	bl	800c448 <atcc_extractElement>
 800e972:	2801      	cmp	r0, #1
 800e974:	d000      	beq.n	800e978 <analyze_CmeError+0x70>
 800e976:	2401      	movs	r4, #1
 800e978:	89f3      	ldrh	r3, [r6, #14]
 800e97a:	b113      	cbz	r3, 800e982 <analyze_CmeError+0x7a>
  if (element_infos->param_rank == 2U)
 800e97c:	8933      	ldrh	r3, [r6, #8]
 800e97e:	2b02      	cmp	r3, #2
 800e980:	d005      	beq.n	800e98e <analyze_CmeError+0x86>
  END_PARAM_LOOP()
 800e982:	2c00      	cmp	r4, #0
 800e984:	d0f0      	beq.n	800e968 <analyze_CmeError+0x60>
}
 800e986:	2010      	movs	r0, #16
 800e988:	b008      	add	sp, #32
 800e98a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    AT_CHAR_t line[32] = {0U};
 800e98e:	2300      	movs	r3, #0
 800e990:	9300      	str	r3, [sp, #0]
 800e992:	9301      	str	r3, [sp, #4]
 800e994:	9302      	str	r3, [sp, #8]
 800e996:	9303      	str	r3, [sp, #12]
 800e998:	9304      	str	r3, [sp, #16]
 800e99a:	9305      	str	r3, [sp, #20]
 800e99c:	9306      	str	r3, [sp, #24]
 800e99e:	9307      	str	r3, [sp, #28]
    PRINT_DBG("CME ERROR parameter received:")
 800e9a0:	f8df c248 	ldr.w	ip, [pc, #584]	; 800ebec <analyze_CmeError+0x2e4>
 800e9a4:	4d86      	ldr	r5, [pc, #536]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e9a6:	f10c 0a20 	add.w	sl, ip, #32
 800e9aa:	46e6      	mov	lr, ip
 800e9ac:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800e9b0:	6028      	str	r0, [r5, #0]
 800e9b2:	6069      	str	r1, [r5, #4]
 800e9b4:	60aa      	str	r2, [r5, #8]
 800e9b6:	60eb      	str	r3, [r5, #12]
 800e9b8:	46f4      	mov	ip, lr
 800e9ba:	3510      	adds	r5, #16
 800e9bc:	45d6      	cmp	lr, sl
 800e9be:	d1f4      	bne.n	800e9aa <analyze_CmeError+0xa2>
 800e9c0:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 800e9c4:	6028      	str	r0, [r5, #0]
 800e9c6:	6069      	str	r1, [r5, #4]
 800e9c8:	f89c 3000 	ldrb.w	r3, [ip]
 800e9cc:	722b      	strb	r3, [r5, #8]
 800e9ce:	4d7c      	ldr	r5, [pc, #496]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800e9d0:	4628      	mov	r0, r5
 800e9d2:	f010 fcaa 	bl	801f32a <crs_strlen>
 800e9d6:	b283      	uxth	r3, r0
 800e9d8:	462a      	mov	r2, r5
 800e9da:	2102      	movs	r1, #2
 800e9dc:	4608      	mov	r0, r1
 800e9de:	f010 fce7 	bl	801f3b0 <traceIF_itmPrint>
 800e9e2:	4628      	mov	r0, r5
 800e9e4:	f010 fca1 	bl	801f32a <crs_strlen>
 800e9e8:	b283      	uxth	r3, r0
 800e9ea:	462a      	mov	r2, r5
 800e9ec:	2102      	movs	r1, #2
 800e9ee:	4608      	mov	r0, r1
 800e9f0:	f010 fd00 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 800e9f4:	8972      	ldrh	r2, [r6, #10]
 800e9f6:	89f3      	ldrh	r3, [r6, #14]
 800e9f8:	443a      	add	r2, r7
 800e9fa:	2102      	movs	r1, #2
 800e9fc:	4608      	mov	r0, r1
 800e9fe:	f010 ffc5 	bl	801f98c <traceIF_BufCharPrint>
    if (element_infos->str_size <= 32U)
 800ea02:	89f2      	ldrh	r2, [r6, #14]
 800ea04:	2a20      	cmp	r2, #32
 800ea06:	d805      	bhi.n	800ea14 <analyze_CmeError+0x10c>
                    (const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 800ea08:	8971      	ldrh	r1, [r6, #10]
      (void) memcpy((void *)&line[0],
 800ea0a:	4439      	add	r1, r7
 800ea0c:	4668      	mov	r0, sp
 800ea0e:	f018 f86b 	bl	8026ae8 <memcpy>
 800ea12:	e02c      	b.n	800ea6e <analyze_CmeError+0x166>
      PRINT_ERR("line exceed maximum size, line ignored...")
 800ea14:	f8df c1d8 	ldr.w	ip, [pc, #472]	; 800ebf0 <analyze_CmeError+0x2e8>
 800ea18:	4d69      	ldr	r5, [pc, #420]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800ea1a:	f10c 0a30 	add.w	sl, ip, #48	; 0x30
 800ea1e:	46e6      	mov	lr, ip
 800ea20:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 800ea24:	6028      	str	r0, [r5, #0]
 800ea26:	6069      	str	r1, [r5, #4]
 800ea28:	60aa      	str	r2, [r5, #8]
 800ea2a:	60eb      	str	r3, [r5, #12]
 800ea2c:	46f4      	mov	ip, lr
 800ea2e:	3510      	adds	r5, #16
 800ea30:	45d6      	cmp	lr, sl
 800ea32:	d1f4      	bne.n	800ea1e <analyze_CmeError+0x116>
 800ea34:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 800ea38:	6028      	str	r0, [r5, #0]
 800ea3a:	6069      	str	r1, [r5, #4]
 800ea3c:	f8bc 2000 	ldrh.w	r2, [ip]
 800ea40:	f89c 3002 	ldrb.w	r3, [ip, #2]
 800ea44:	812a      	strh	r2, [r5, #8]
 800ea46:	72ab      	strb	r3, [r5, #10]
 800ea48:	4d5d      	ldr	r5, [pc, #372]	; (800ebc0 <analyze_CmeError+0x2b8>)
 800ea4a:	4628      	mov	r0, r5
 800ea4c:	f010 fc6d 	bl	801f32a <crs_strlen>
 800ea50:	b283      	uxth	r3, r0
 800ea52:	462a      	mov	r2, r5
 800ea54:	2110      	movs	r1, #16
 800ea56:	2002      	movs	r0, #2
 800ea58:	f010 fcaa 	bl	801f3b0 <traceIF_itmPrint>
 800ea5c:	4628      	mov	r0, r5
 800ea5e:	f010 fc64 	bl	801f32a <crs_strlen>
 800ea62:	b283      	uxth	r3, r0
 800ea64:	462a      	mov	r2, r5
 800ea66:	2110      	movs	r1, #16
 800ea68:	2002      	movs	r0, #2
 800ea6a:	f010 fcc3 	bl	801f3f4 <traceIF_uartPrint>
    ATutil_convertStringToUpperCase(&line[0], 32U);
 800ea6e:	2120      	movs	r1, #32
 800ea70:	4668      	mov	r0, sp
 800ea72:	f006 f9e9 	bl	8014e48 <ATutil_convertStringToUpperCase>
    if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM NOT INSERTED") != NULL)
 800ea76:	4953      	ldr	r1, [pc, #332]	; (800ebc4 <analyze_CmeError+0x2bc>)
 800ea78:	4668      	mov	r0, sp
 800ea7a:	f017 ffa3 	bl	80269c4 <strstr>
 800ea7e:	b150      	cbz	r0, 800ea96 <analyze_CmeError+0x18e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800ea80:	2300      	movs	r3, #0
 800ea82:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_NOT_INSERTED;
 800ea86:	2302      	movs	r3, #2
 800ea88:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800ea8c:	4649      	mov	r1, r9
 800ea8e:	2001      	movs	r0, #1
 800ea90:	f7ff fd72 	bl	800e578 <set_error_report>
 800ea94:	e775      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN NECESSARY") != NULL)
 800ea96:	494c      	ldr	r1, [pc, #304]	; (800ebc8 <analyze_CmeError+0x2c0>)
 800ea98:	4668      	mov	r0, sp
 800ea9a:	f017 ff93 	bl	80269c4 <strstr>
 800ea9e:	b150      	cbz	r0, 800eab6 <analyze_CmeError+0x1ae>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eaa0:	2300      	movs	r3, #0
 800eaa2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN_REQUIRED;
 800eaa6:	2306      	movs	r3, #6
 800eaa8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eaac:	4649      	mov	r1, r9
 800eaae:	2001      	movs	r0, #1
 800eab0:	f7ff fd62 	bl	800e578 <set_error_report>
 800eab4:	e765      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN REQUIRED") != NULL)
 800eab6:	4945      	ldr	r1, [pc, #276]	; (800ebcc <analyze_CmeError+0x2c4>)
 800eab8:	4668      	mov	r0, sp
 800eaba:	f017 ff83 	bl	80269c4 <strstr>
 800eabe:	b150      	cbz	r0, 800ead6 <analyze_CmeError+0x1ce>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eac0:	2300      	movs	r3, #0
 800eac2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN_REQUIRED;
 800eac6:	2306      	movs	r3, #6
 800eac8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eacc:	4649      	mov	r1, r9
 800eace:	2001      	movs	r0, #1
 800ead0:	f7ff fd52 	bl	800e578 <set_error_report>
 800ead4:	e755      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK REQUIRED") != NULL)
 800ead6:	493e      	ldr	r1, [pc, #248]	; (800ebd0 <analyze_CmeError+0x2c8>)
 800ead8:	4668      	mov	r0, sp
 800eada:	f017 ff73 	bl	80269c4 <strstr>
 800eade:	b150      	cbz	r0, 800eaf6 <analyze_CmeError+0x1ee>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eae0:	2300      	movs	r3, #0
 800eae2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK_REQUIRED;
 800eae6:	2308      	movs	r3, #8
 800eae8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eaec:	4649      	mov	r1, r9
 800eaee:	2001      	movs	r0, #1
 800eaf0:	f7ff fd42 	bl	800e578 <set_error_report>
 800eaf4:	e745      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM FAILURE") != NULL)
 800eaf6:	4937      	ldr	r1, [pc, #220]	; (800ebd4 <analyze_CmeError+0x2cc>)
 800eaf8:	4668      	mov	r0, sp
 800eafa:	f017 ff63 	bl	80269c4 <strstr>
 800eafe:	b150      	cbz	r0, 800eb16 <analyze_CmeError+0x20e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb00:	2300      	movs	r3, #0
 800eb02:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_FAILURE;
 800eb06:	2304      	movs	r3, #4
 800eb08:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb0c:	4649      	mov	r1, r9
 800eb0e:	2001      	movs	r0, #1
 800eb10:	f7ff fd32 	bl	800e578 <set_error_report>
 800eb14:	e735      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM BUSY") != NULL)
 800eb16:	4930      	ldr	r1, [pc, #192]	; (800ebd8 <analyze_CmeError+0x2d0>)
 800eb18:	4668      	mov	r0, sp
 800eb1a:	f017 ff53 	bl	80269c4 <strstr>
 800eb1e:	b150      	cbz	r0, 800eb36 <analyze_CmeError+0x22e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb20:	2300      	movs	r3, #0
 800eb22:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_BUSY;
 800eb26:	2303      	movs	r3, #3
 800eb28:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb2c:	4649      	mov	r1, r9
 800eb2e:	2001      	movs	r0, #1
 800eb30:	f7ff fd22 	bl	800e578 <set_error_report>
 800eb34:	e725      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM WRONG") != NULL)
 800eb36:	4929      	ldr	r1, [pc, #164]	; (800ebdc <analyze_CmeError+0x2d4>)
 800eb38:	4668      	mov	r0, sp
 800eb3a:	f017 ff43 	bl	80269c4 <strstr>
 800eb3e:	b150      	cbz	r0, 800eb56 <analyze_CmeError+0x24e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb40:	2300      	movs	r3, #0
 800eb42:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_WRONG;
 800eb46:	2305      	movs	r3, #5
 800eb48:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb4c:	4649      	mov	r1, r9
 800eb4e:	2001      	movs	r0, #1
 800eb50:	f7ff fd12 	bl	800e578 <set_error_report>
 800eb54:	e715      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "INCORRECT PASSWORD") != NULL)
 800eb56:	4922      	ldr	r1, [pc, #136]	; (800ebe0 <analyze_CmeError+0x2d8>)
 800eb58:	4668      	mov	r0, sp
 800eb5a:	f017 ff33 	bl	80269c4 <strstr>
 800eb5e:	b150      	cbz	r0, 800eb76 <analyze_CmeError+0x26e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb60:	2300      	movs	r3, #0
 800eb62:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_INCORRECT_PASSWORD;
 800eb66:	230a      	movs	r3, #10
 800eb68:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb6c:	4649      	mov	r1, r9
 800eb6e:	2001      	movs	r0, #1
 800eb70:	f7ff fd02 	bl	800e578 <set_error_report>
 800eb74:	e705      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN2 REQUIRED") != NULL)
 800eb76:	491b      	ldr	r1, [pc, #108]	; (800ebe4 <analyze_CmeError+0x2dc>)
 800eb78:	4668      	mov	r0, sp
 800eb7a:	f017 ff23 	bl	80269c4 <strstr>
 800eb7e:	b150      	cbz	r0, 800eb96 <analyze_CmeError+0x28e>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eb80:	2300      	movs	r3, #0
 800eb82:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN2_REQUIRED;
 800eb86:	2307      	movs	r3, #7
 800eb88:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800eb8c:	4649      	mov	r1, r9
 800eb8e:	2001      	movs	r0, #1
 800eb90:	f7ff fcf2 	bl	800e578 <set_error_report>
 800eb94:	e6f5      	b.n	800e982 <analyze_CmeError+0x7a>
    else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK2 REQUIRED") != NULL)
 800eb96:	4914      	ldr	r1, [pc, #80]	; (800ebe8 <analyze_CmeError+0x2e0>)
 800eb98:	4668      	mov	r0, sp
 800eb9a:	f017 ff13 	bl	80269c4 <strstr>
 800eb9e:	b150      	cbz	r0, 800ebb6 <analyze_CmeError+0x2ae>
      p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 800eba0:	2300      	movs	r3, #0
 800eba2:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
      p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK2_REQUIRED;
 800eba6:	2309      	movs	r3, #9
 800eba8:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
      set_error_report(CSERR_SIM, p_modem_ctxt);
 800ebac:	4649      	mov	r1, r9
 800ebae:	2001      	movs	r0, #1
 800ebb0:	f7ff fce2 	bl	800e578 <set_error_report>
 800ebb4:	e6e5      	b.n	800e982 <analyze_CmeError+0x7a>
      __NOP();
 800ebb6:	bf00      	nop
 800ebb8:	e6e3      	b.n	800e982 <analyze_CmeError+0x7a>
 800ebba:	bf00      	nop
 800ebbc:	0802f15c 	.word	0x0802f15c
 800ebc0:	200048dc 	.word	0x200048dc
 800ebc4:	0802f1f4 	.word	0x0802f1f4
 800ebc8:	0802f208 	.word	0x0802f208
 800ebcc:	0802f21c 	.word	0x0802f21c
 800ebd0:	0802f230 	.word	0x0802f230
 800ebd4:	0802f244 	.word	0x0802f244
 800ebd8:	0802f250 	.word	0x0802f250
 800ebdc:	0802f25c 	.word	0x0802f25c
 800ebe0:	08034190 	.word	0x08034190
 800ebe4:	0802f268 	.word	0x0802f268
 800ebe8:	0802f27c 	.word	0x0802f27c
 800ebec:	0802f18c 	.word	0x0802f18c
 800ebf0:	0802f1b8 	.word	0x0802f1b8

0800ebf4 <extract_hex_value_from_quotes>:
#define MAX_PARAM_SIZE 8 /* max of previous values         */
/*
 * Extract the value of an hexadecimal parameter from a string
 */
static uint32_t extract_hex_value_from_quotes(const uint8_t *p_str, uint16_t str_size, uint8_t param_size)
{
 800ebf4:	b510      	push	{r4, lr}
 800ebf6:	b082      	sub	sp, #8
 800ebf8:	4613      	mov	r3, r2
  uint8_t tmp_array[MAX_PARAM_SIZE] = {0};
 800ebfa:	2400      	movs	r4, #0
 800ebfc:	9400      	str	r4, [sp, #0]
 800ebfe:	9401      	str	r4, [sp, #4]
  uint16_t real_size;
  uint32_t converted_value;
  real_size = ATutil_remove_quotes(p_str, str_size, &tmp_array[0], param_size);
 800ec00:	466a      	mov	r2, sp
 800ec02:	f006 f95e 	bl	8014ec2 <ATutil_remove_quotes>
 800ec06:	4601      	mov	r1, r0
  converted_value = ATutil_convertHexaStringToInt32(&tmp_array[0], real_size);
 800ec08:	4668      	mov	r0, sp
 800ec0a:	f006 f837 	bl	8014c7c <ATutil_convertHexaStringToInt32>

  return (converted_value);
}
 800ec0e:	b002      	add	sp, #8
 800ec10:	bd10      	pop	{r4, pc}

0800ec12 <extract_bin_value_from_quotes>:
#if (SW_DEBUG_VERSION == 1U)
/*
 * Extract the value of an binary parameter from a string
 */
static uint32_t extract_bin_value_from_quotes(const uint8_t *p_str, uint16_t str_size, uint8_t param_size)
{
 800ec12:	b510      	push	{r4, lr}
 800ec14:	b082      	sub	sp, #8
 800ec16:	4613      	mov	r3, r2
  uint8_t tmp_array[MAX_PARAM_SIZE] = {0};
 800ec18:	2400      	movs	r4, #0
 800ec1a:	9400      	str	r4, [sp, #0]
 800ec1c:	9401      	str	r4, [sp, #4]
  uint16_t real_size;
  uint32_t converted_value;
  real_size = ATutil_remove_quotes(p_str, str_size, &tmp_array[0], param_size);
 800ec1e:	466a      	mov	r2, sp
 800ec20:	f006 f94f 	bl	8014ec2 <ATutil_remove_quotes>
 800ec24:	4601      	mov	r1, r0
  converted_value = ATutil_convertBinStringToInt32(&tmp_array[0], real_size);
 800ec26:	4668      	mov	r0, sp
 800ec28:	f006 f8ef 	bl	8014e0a <ATutil_convertBinStringToInt32>

  return (converted_value);
}
 800ec2c:	b002      	add	sp, #8
 800ec2e:	bd10      	pop	{r4, pc}

0800ec30 <find_user_cid_with_matching_ip_addr>:
{
 800ec30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ec34:	b082      	sub	sp, #8
 800ec36:	4607      	mov	r7, r0
 800ec38:	460e      	mov	r6, r1
  for (uint8_t loop = 0U; loop < MODEM_MAX_NB_PDP_CTXT; loop++)
 800ec3a:	2500      	movs	r5, #0
  CS_PDN_conf_id_t user_cid = CS_PDN_NOT_DEFINED;
 800ec3c:	f04f 080c 	mov.w	r8, #12
  for (uint8_t loop = 0U; loop < MODEM_MAX_NB_PDP_CTXT; loop++)
 800ec40:	e001      	b.n	800ec46 <find_user_cid_with_matching_ip_addr+0x16>
 800ec42:	3501      	adds	r5, #1
 800ec44:	b2ed      	uxtb	r5, r5
 800ec46:	2d05      	cmp	r5, #5
 800ec48:	d856      	bhi.n	800ecf8 <find_user_cid_with_matching_ip_addr+0xc8>
    PRINT_DBG("[Compare ip addr with user cid=%d]: <%s> vs <%s>",
 800ec4a:	f106 0a01 	add.w	sl, r6, #1
 800ec4e:	eb05 1405 	add.w	r4, r5, r5, lsl #4
 800ec52:	00a4      	lsls	r4, r4, #2
 800ec54:	f504 7454 	add.w	r4, r4, #848	; 0x350
 800ec58:	443c      	add	r4, r7
 800ec5a:	3404      	adds	r4, #4
 800ec5c:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 800ed04 <find_user_cid_with_matching_ip_addr+0xd4>
 800ec60:	9400      	str	r4, [sp, #0]
 800ec62:	4653      	mov	r3, sl
 800ec64:	462a      	mov	r2, r5
 800ec66:	4926      	ldr	r1, [pc, #152]	; (800ed00 <find_user_cid_with_matching_ip_addr+0xd0>)
 800ec68:	4648      	mov	r0, r9
 800ec6a:	f017 fded 	bl	8026848 <sprintf>
 800ec6e:	4648      	mov	r0, r9
 800ec70:	f010 fb5b 	bl	801f32a <crs_strlen>
 800ec74:	b283      	uxth	r3, r0
 800ec76:	464a      	mov	r2, r9
 800ec78:	2102      	movs	r1, #2
 800ec7a:	4608      	mov	r0, r1
 800ec7c:	f010 fb98 	bl	801f3b0 <traceIF_itmPrint>
 800ec80:	4648      	mov	r0, r9
 800ec82:	f010 fb52 	bl	801f32a <crs_strlen>
 800ec86:	b283      	uxth	r3, r0
 800ec88:	464a      	mov	r2, r9
 800ec8a:	2102      	movs	r1, #2
 800ec8c:	4608      	mov	r0, r1
 800ec8e:	f010 fbb1 	bl	801f3f4 <traceIF_uartPrint>
    size1 = (uint8_t) strlen((CRC_CHAR_t *)&ip_addr_struct->ip_addr_value);
 800ec92:	4650      	mov	r0, sl
 800ec94:	f7f1 faae 	bl	80001f4 <strlen>
 800ec98:	fa5f f980 	uxtb.w	r9, r0
    size2 = (uint8_t) strlen((CRC_CHAR_t *)&p_tmp->ip_addr_infos.ip_addr_value);
 800ec9c:	4620      	mov	r0, r4
 800ec9e:	f7f1 faa9 	bl	80001f4 <strlen>
 800eca2:	b2c0      	uxtb	r0, r0
    minsize = (size1 < size2) ? size1 : size2;
 800eca4:	4581      	cmp	r9, r0
 800eca6:	bf28      	it	cs
 800eca8:	4681      	movcs	r9, r0
    if ((0 == memcmp((AT_CHAR_t *)&ip_addr_struct->ip_addr_value[0],
 800ecaa:	464a      	mov	r2, r9
 800ecac:	4621      	mov	r1, r4
 800ecae:	4650      	mov	r0, sl
 800ecb0:	f017 fe2d 	bl	802690e <memcmp>
 800ecb4:	2800      	cmp	r0, #0
 800ecb6:	d1c4      	bne.n	800ec42 <find_user_cid_with_matching_ip_addr+0x12>
                     (size_t) minsize)) &&
 800ecb8:	f1b9 0f00 	cmp.w	r9, #0
 800ecbc:	d0c1      	beq.n	800ec42 <find_user_cid_with_matching_ip_addr+0x12>
      user_cid = atcm_convert_index_to_PDN_conf(loop);
 800ecbe:	4628      	mov	r0, r5
 800ecc0:	f7fe fedc 	bl	800da7c <atcm_convert_index_to_PDN_conf>
 800ecc4:	4680      	mov	r8, r0
      PRINT_DBG("Found matching user cid=%d", user_cid)
 800ecc6:	4c0f      	ldr	r4, [pc, #60]	; (800ed04 <find_user_cid_with_matching_ip_addr+0xd4>)
 800ecc8:	4602      	mov	r2, r0
 800ecca:	490f      	ldr	r1, [pc, #60]	; (800ed08 <find_user_cid_with_matching_ip_addr+0xd8>)
 800eccc:	4620      	mov	r0, r4
 800ecce:	f017 fdbb 	bl	8026848 <sprintf>
 800ecd2:	4620      	mov	r0, r4
 800ecd4:	f010 fb29 	bl	801f32a <crs_strlen>
 800ecd8:	b283      	uxth	r3, r0
 800ecda:	4622      	mov	r2, r4
 800ecdc:	2102      	movs	r1, #2
 800ecde:	4608      	mov	r0, r1
 800ece0:	f010 fb66 	bl	801f3b0 <traceIF_itmPrint>
 800ece4:	4620      	mov	r0, r4
 800ece6:	f010 fb20 	bl	801f32a <crs_strlen>
 800ecea:	b283      	uxth	r3, r0
 800ecec:	4622      	mov	r2, r4
 800ecee:	2102      	movs	r1, #2
 800ecf0:	4608      	mov	r0, r1
 800ecf2:	f010 fb7f 	bl	801f3f4 <traceIF_uartPrint>
 800ecf6:	e7a4      	b.n	800ec42 <find_user_cid_with_matching_ip_addr+0x12>
}
 800ecf8:	4640      	mov	r0, r8
 800ecfa:	b002      	add	sp, #8
 800ecfc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ed00:	0802f290 	.word	0x0802f290
 800ed04:	200048dc 	.word	0x200048dc
 800ed08:	0802f2cc 	.word	0x0802f2cc

0800ed0c <fCmdBuild_NoParams>:
#endif /* (SW_DEBUG_VERSION == 1U) */
/* Functions Definition ------------------------------------------------------*/

/* ==========================  Build 3GPP TS 27.007 commands ========================== */
at_status_t fCmdBuild_NoParams(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ed0c:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_atp_ctxt);
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  /* Command as no parameters - STUB function */
  PRINT_API("enter fCmdBuild_NoParams()")
 800ed0e:	4c14      	ldr	r4, [pc, #80]	; (800ed60 <fCmdBuild_NoParams+0x54>)
 800ed10:	4d14      	ldr	r5, [pc, #80]	; (800ed64 <fCmdBuild_NoParams+0x58>)
 800ed12:	f104 0e20 	add.w	lr, r4, #32
 800ed16:	46a4      	mov	ip, r4
 800ed18:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ed1c:	6028      	str	r0, [r5, #0]
 800ed1e:	6069      	str	r1, [r5, #4]
 800ed20:	60aa      	str	r2, [r5, #8]
 800ed22:	60eb      	str	r3, [r5, #12]
 800ed24:	4664      	mov	r4, ip
 800ed26:	3510      	adds	r5, #16
 800ed28:	45f4      	cmp	ip, lr
 800ed2a:	d1f4      	bne.n	800ed16 <fCmdBuild_NoParams+0xa>
 800ed2c:	cc03      	ldmia	r4!, {r0, r1}
 800ed2e:	6028      	str	r0, [r5, #0]
 800ed30:	6069      	str	r1, [r5, #4]
 800ed32:	8823      	ldrh	r3, [r4, #0]
 800ed34:	812b      	strh	r3, [r5, #8]
 800ed36:	4c0b      	ldr	r4, [pc, #44]	; (800ed64 <fCmdBuild_NoParams+0x58>)
 800ed38:	4620      	mov	r0, r4
 800ed3a:	f010 faf6 	bl	801f32a <crs_strlen>
 800ed3e:	b283      	uxth	r3, r0
 800ed40:	4622      	mov	r2, r4
 800ed42:	2104      	movs	r1, #4
 800ed44:	2002      	movs	r0, #2
 800ed46:	f010 fb33 	bl	801f3b0 <traceIF_itmPrint>
 800ed4a:	4620      	mov	r0, r4
 800ed4c:	f010 faed 	bl	801f32a <crs_strlen>
 800ed50:	b283      	uxth	r3, r0
 800ed52:	4622      	mov	r2, r4
 800ed54:	2104      	movs	r1, #4
 800ed56:	2002      	movs	r0, #2
 800ed58:	f010 fb4c 	bl	801f3f4 <traceIF_uartPrint>

  return (retval);
}
 800ed5c:	2000      	movs	r0, #0
 800ed5e:	bd38      	pop	{r3, r4, r5, pc}
 800ed60:	0802f2f4 	.word	0x0802f2f4
 800ed64:	200048dc 	.word	0x200048dc

0800ed68 <fCmdBuild_CGSN>:

at_status_t fCmdBuild_CGSN(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ed68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ed6a:	4606      	mov	r6, r0
 800ed6c:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGSN()")
 800ed6e:	4d1a      	ldr	r5, [pc, #104]	; (800edd8 <fCmdBuild_CGSN+0x70>)
 800ed70:	4c1a      	ldr	r4, [pc, #104]	; (800eddc <fCmdBuild_CGSN+0x74>)
 800ed72:	f105 0e20 	add.w	lr, r5, #32
 800ed76:	46ac      	mov	ip, r5
 800ed78:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ed7c:	6020      	str	r0, [r4, #0]
 800ed7e:	6061      	str	r1, [r4, #4]
 800ed80:	60a2      	str	r2, [r4, #8]
 800ed82:	60e3      	str	r3, [r4, #12]
 800ed84:	4665      	mov	r5, ip
 800ed86:	3410      	adds	r4, #16
 800ed88:	45f4      	cmp	ip, lr
 800ed8a:	d1f4      	bne.n	800ed76 <fCmdBuild_CGSN+0xe>
 800ed8c:	f8dc 0000 	ldr.w	r0, [ip]
 800ed90:	6020      	str	r0, [r4, #0]
 800ed92:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ed96:	80a3      	strh	r3, [r4, #4]
 800ed98:	4c10      	ldr	r4, [pc, #64]	; (800eddc <fCmdBuild_CGSN+0x74>)
 800ed9a:	4620      	mov	r0, r4
 800ed9c:	f010 fac5 	bl	801f32a <crs_strlen>
 800eda0:	b283      	uxth	r3, r0
 800eda2:	4622      	mov	r2, r4
 800eda4:	2104      	movs	r1, #4
 800eda6:	2002      	movs	r0, #2
 800eda8:	f010 fb02 	bl	801f3b0 <traceIF_itmPrint>
 800edac:	4620      	mov	r0, r4
 800edae:	f010 fabc 	bl	801f32a <crs_strlen>
 800edb2:	b283      	uxth	r3, r0
 800edb4:	4622      	mov	r2, r4
 800edb6:	2104      	movs	r1, #4
 800edb8:	2002      	movs	r0, #2
 800edba:	f010 fb1b 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800edbe:	8933      	ldrh	r3, [r6, #8]
 800edc0:	2b03      	cmp	r3, #3
 800edc2:	d001      	beq.n	800edc8 <fCmdBuild_CGSN+0x60>
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
                   p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param);
  }
  return (retval);
}
 800edc4:	2000      	movs	r0, #0
 800edc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800edc8:	f897 272c 	ldrb.w	r2, [r7, #1836]	; 0x72c
 800edcc:	4904      	ldr	r1, [pc, #16]	; (800ede0 <fCmdBuild_CGSN+0x78>)
 800edce:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800edd2:	f017 fd39 	bl	8026848 <sprintf>
 800edd6:	e7f5      	b.n	800edc4 <fCmdBuild_CGSN+0x5c>
 800edd8:	0802f320 	.word	0x0802f320
 800eddc:	200048dc 	.word	0x200048dc
 800ede0:	0802f40c 	.word	0x0802f40c

0800ede4 <fCmdBuild_CMEE>:

at_status_t fCmdBuild_CMEE(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ede4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ede6:	4606      	mov	r6, r0
 800ede8:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CMEE()")
 800edea:	4d1a      	ldr	r5, [pc, #104]	; (800ee54 <fCmdBuild_CMEE+0x70>)
 800edec:	4c1a      	ldr	r4, [pc, #104]	; (800ee58 <fCmdBuild_CMEE+0x74>)
 800edee:	f105 0e20 	add.w	lr, r5, #32
 800edf2:	46ac      	mov	ip, r5
 800edf4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800edf8:	6020      	str	r0, [r4, #0]
 800edfa:	6061      	str	r1, [r4, #4]
 800edfc:	60a2      	str	r2, [r4, #8]
 800edfe:	60e3      	str	r3, [r4, #12]
 800ee00:	4665      	mov	r5, ip
 800ee02:	3410      	adds	r4, #16
 800ee04:	45f4      	cmp	ip, lr
 800ee06:	d1f4      	bne.n	800edf2 <fCmdBuild_CMEE+0xe>
 800ee08:	f8dc 0000 	ldr.w	r0, [ip]
 800ee0c:	6020      	str	r0, [r4, #0]
 800ee0e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ee12:	80a3      	strh	r3, [r4, #4]
 800ee14:	4c10      	ldr	r4, [pc, #64]	; (800ee58 <fCmdBuild_CMEE+0x74>)
 800ee16:	4620      	mov	r0, r4
 800ee18:	f010 fa87 	bl	801f32a <crs_strlen>
 800ee1c:	b283      	uxth	r3, r0
 800ee1e:	4622      	mov	r2, r4
 800ee20:	2104      	movs	r1, #4
 800ee22:	2002      	movs	r0, #2
 800ee24:	f010 fac4 	bl	801f3b0 <traceIF_itmPrint>
 800ee28:	4620      	mov	r0, r4
 800ee2a:	f010 fa7e 	bl	801f32a <crs_strlen>
 800ee2e:	b283      	uxth	r3, r0
 800ee30:	4622      	mov	r2, r4
 800ee32:	2104      	movs	r1, #4
 800ee34:	2002      	movs	r0, #2
 800ee36:	f010 fadd 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800ee3a:	8933      	ldrh	r3, [r6, #8]
 800ee3c:	2b03      	cmp	r3, #3
 800ee3e:	d001      	beq.n	800ee44 <fCmdBuild_CMEE+0x60>
      * 2: <err> result code enabled and verbose <ERR> values used
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", p_modem_ctxt->persist.cmee_level);
  }
  return (retval);
}
 800ee40:	2000      	movs	r0, #0
 800ee42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", p_modem_ctxt->persist.cmee_level);
 800ee44:	f897 2513 	ldrb.w	r2, [r7, #1299]	; 0x513
 800ee48:	4904      	ldr	r1, [pc, #16]	; (800ee5c <fCmdBuild_CMEE+0x78>)
 800ee4a:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ee4e:	f017 fcfb 	bl	8026848 <sprintf>
 800ee52:	e7f5      	b.n	800ee40 <fCmdBuild_CMEE+0x5c>
 800ee54:	0802f348 	.word	0x0802f348
 800ee58:	200048dc 	.word	0x200048dc
 800ee5c:	0802f40c 	.word	0x0802f40c

0800ee60 <fCmdBuild_CPIN>:

at_status_t fCmdBuild_CPIN(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ee60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ee62:	4606      	mov	r6, r0
 800ee64:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CPIN()")
 800ee66:	4d26      	ldr	r5, [pc, #152]	; (800ef00 <fCmdBuild_CPIN+0xa0>)
 800ee68:	4c26      	ldr	r4, [pc, #152]	; (800ef04 <fCmdBuild_CPIN+0xa4>)
 800ee6a:	f105 0e20 	add.w	lr, r5, #32
 800ee6e:	46ac      	mov	ip, r5
 800ee70:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ee74:	6020      	str	r0, [r4, #0]
 800ee76:	6061      	str	r1, [r4, #4]
 800ee78:	60a2      	str	r2, [r4, #8]
 800ee7a:	60e3      	str	r3, [r4, #12]
 800ee7c:	4665      	mov	r5, ip
 800ee7e:	3410      	adds	r4, #16
 800ee80:	45f4      	cmp	ip, lr
 800ee82:	d1f4      	bne.n	800ee6e <fCmdBuild_CPIN+0xe>
 800ee84:	f8dc 0000 	ldr.w	r0, [ip]
 800ee88:	6020      	str	r0, [r4, #0]
 800ee8a:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ee8e:	80a3      	strh	r3, [r4, #4]
 800ee90:	4c1c      	ldr	r4, [pc, #112]	; (800ef04 <fCmdBuild_CPIN+0xa4>)
 800ee92:	4620      	mov	r0, r4
 800ee94:	f010 fa49 	bl	801f32a <crs_strlen>
 800ee98:	b283      	uxth	r3, r0
 800ee9a:	4622      	mov	r2, r4
 800ee9c:	2104      	movs	r1, #4
 800ee9e:	2002      	movs	r0, #2
 800eea0:	f010 fa86 	bl	801f3b0 <traceIF_itmPrint>
 800eea4:	4620      	mov	r0, r4
 800eea6:	f010 fa40 	bl	801f32a <crs_strlen>
 800eeaa:	b283      	uxth	r3, r0
 800eeac:	4622      	mov	r2, r4
 800eeae:	2104      	movs	r1, #4
 800eeb0:	2002      	movs	r0, #2
 800eeb2:	f010 fa9f 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800eeb6:	8933      	ldrh	r3, [r6, #8]
 800eeb8:	2b03      	cmp	r3, #3
 800eeba:	d001      	beq.n	800eec0 <fCmdBuild_CPIN+0x60>

    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\"",
                   p_modem_ctxt->SID_ctxt.modem_init.pincode.pincode);
  }
  return (retval);
}
 800eebc:	2000      	movs	r0, #0
 800eebe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_DBG("pin code= %s", p_modem_ctxt->SID_ctxt.modem_init.pincode.pincode)
 800eec0:	f207 57b3 	addw	r7, r7, #1459	; 0x5b3
 800eec4:	463a      	mov	r2, r7
 800eec6:	4910      	ldr	r1, [pc, #64]	; (800ef08 <fCmdBuild_CPIN+0xa8>)
 800eec8:	4620      	mov	r0, r4
 800eeca:	f017 fcbd 	bl	8026848 <sprintf>
 800eece:	4620      	mov	r0, r4
 800eed0:	f010 fa2b 	bl	801f32a <crs_strlen>
 800eed4:	b283      	uxth	r3, r0
 800eed6:	4622      	mov	r2, r4
 800eed8:	2102      	movs	r1, #2
 800eeda:	4608      	mov	r0, r1
 800eedc:	f010 fa68 	bl	801f3b0 <traceIF_itmPrint>
 800eee0:	4620      	mov	r0, r4
 800eee2:	f010 fa22 	bl	801f32a <crs_strlen>
 800eee6:	b283      	uxth	r3, r0
 800eee8:	4622      	mov	r2, r4
 800eeea:	2102      	movs	r1, #2
 800eeec:	4608      	mov	r0, r1
 800eeee:	f010 fa81 	bl	801f3f4 <traceIF_uartPrint>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"%s\"",
 800eef2:	463a      	mov	r2, r7
 800eef4:	4905      	ldr	r1, [pc, #20]	; (800ef0c <fCmdBuild_CPIN+0xac>)
 800eef6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800eefa:	f017 fca5 	bl	8026848 <sprintf>
 800eefe:	e7dd      	b.n	800eebc <fCmdBuild_CPIN+0x5c>
 800ef00:	0802f370 	.word	0x0802f370
 800ef04:	200048dc 	.word	0x200048dc
 800ef08:	0802f398 	.word	0x0802f398
 800ef0c:	0802b55c 	.word	0x0802b55c

0800ef10 <fCmdBuild_CFUN>:

at_status_t fCmdBuild_CFUN(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ef10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ef12:	4606      	mov	r6, r0
 800ef14:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CFUN()")
 800ef16:	4d26      	ldr	r5, [pc, #152]	; (800efb0 <fCmdBuild_CFUN+0xa0>)
 800ef18:	4c26      	ldr	r4, [pc, #152]	; (800efb4 <fCmdBuild_CFUN+0xa4>)
 800ef1a:	f105 0e20 	add.w	lr, r5, #32
 800ef1e:	46ac      	mov	ip, r5
 800ef20:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ef24:	6020      	str	r0, [r4, #0]
 800ef26:	6061      	str	r1, [r4, #4]
 800ef28:	60a2      	str	r2, [r4, #8]
 800ef2a:	60e3      	str	r3, [r4, #12]
 800ef2c:	4665      	mov	r5, ip
 800ef2e:	3410      	adds	r4, #16
 800ef30:	45f4      	cmp	ip, lr
 800ef32:	d1f4      	bne.n	800ef1e <fCmdBuild_CFUN+0xe>
 800ef34:	f8dc 0000 	ldr.w	r0, [ip]
 800ef38:	6020      	str	r0, [r4, #0]
 800ef3a:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ef3e:	80a3      	strh	r3, [r4, #4]
 800ef40:	4c1c      	ldr	r4, [pc, #112]	; (800efb4 <fCmdBuild_CFUN+0xa4>)
 800ef42:	4620      	mov	r0, r4
 800ef44:	f010 f9f1 	bl	801f32a <crs_strlen>
 800ef48:	b283      	uxth	r3, r0
 800ef4a:	4622      	mov	r2, r4
 800ef4c:	2104      	movs	r1, #4
 800ef4e:	2002      	movs	r0, #2
 800ef50:	f010 fa2e 	bl	801f3b0 <traceIF_itmPrint>
 800ef54:	4620      	mov	r0, r4
 800ef56:	f010 f9e8 	bl	801f32a <crs_strlen>
 800ef5a:	b283      	uxth	r3, r0
 800ef5c:	4622      	mov	r2, r4
 800ef5e:	2104      	movs	r1, #4
 800ef60:	2002      	movs	r0, #2
 800ef62:	f010 fa47 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800ef66:	8933      	ldrh	r3, [r6, #8]
 800ef68:	2b03      	cmp	r3, #3
 800ef6a:	d001      	beq.n	800ef70 <fCmdBuild_CFUN+0x60>
      /* set parameter defined by user */
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,0", p_modem_ctxt->CMD_ctxt.cfun_value);
    }
  }
  return (retval);
}
 800ef6c:	2000      	movs	r0, #0
 800ef6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_INIT_MODEM)
 800ef70:	8833      	ldrh	r3, [r6, #0]
 800ef72:	2b67      	cmp	r3, #103	; 0x67
 800ef74:	d113      	bne.n	800ef9e <fCmdBuild_CFUN+0x8e>
      if (modemInit_struct->init == CS_CMI_FULL)
 800ef76:	f897 25b1 	ldrb.w	r2, [r7, #1457]	; 0x5b1
 800ef7a:	2a01      	cmp	r2, #1
 800ef7c:	d002      	beq.n	800ef84 <fCmdBuild_CFUN+0x74>
      else if (modemInit_struct->init == CS_CMI_SIM_ONLY)
 800ef7e:	2a02      	cmp	r2, #2
 800ef80:	d00b      	beq.n	800ef9a <fCmdBuild_CFUN+0x8a>
        fun = 0U; /* default value, if CS_CMI_MINI */
 800ef82:	2200      	movs	r2, #0
      (modemInit_struct->reset == CELLULAR_TRUE) ? (rst = 1U) : (rst = 0U);
 800ef84:	f897 35b2 	ldrb.w	r3, [r7, #1458]	; 0x5b2
 800ef88:	2b01      	cmp	r3, #1
 800ef8a:	d000      	beq.n	800ef8e <fCmdBuild_CFUN+0x7e>
 800ef8c:	2300      	movs	r3, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d", fun, rst);
 800ef8e:	490a      	ldr	r1, [pc, #40]	; (800efb8 <fCmdBuild_CFUN+0xa8>)
 800ef90:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ef94:	f017 fc58 	bl	8026848 <sprintf>
 800ef98:	e7e8      	b.n	800ef6c <fCmdBuild_CFUN+0x5c>
        fun = 4U;
 800ef9a:	2204      	movs	r2, #4
 800ef9c:	e7f2      	b.n	800ef84 <fCmdBuild_CFUN+0x74>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,0", p_modem_ctxt->CMD_ctxt.cfun_value);
 800ef9e:	f897 273d 	ldrb.w	r2, [r7, #1853]	; 0x73d
 800efa2:	4906      	ldr	r1, [pc, #24]	; (800efbc <fCmdBuild_CFUN+0xac>)
 800efa4:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800efa8:	f017 fc4e 	bl	8026848 <sprintf>
 800efac:	e7de      	b.n	800ef6c <fCmdBuild_CFUN+0x5c>
 800efae:	bf00      	nop
 800efb0:	0802f3b0 	.word	0x0802f3b0
 800efb4:	200048dc 	.word	0x200048dc
 800efb8:	0802b7ec 	.word	0x0802b7ec
 800efbc:	0802f3d8 	.word	0x0802f3d8

0800efc0 <fCmdBuild_COPS>:

at_status_t fCmdBuild_COPS(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800efc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800efc2:	b083      	sub	sp, #12
 800efc4:	4606      	mov	r6, r0
 800efc6:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_COPS()")
 800efc8:	4d4e      	ldr	r5, [pc, #312]	; (800f104 <fCmdBuild_COPS+0x144>)
 800efca:	4c4f      	ldr	r4, [pc, #316]	; (800f108 <fCmdBuild_COPS+0x148>)
 800efcc:	f105 0e20 	add.w	lr, r5, #32
 800efd0:	46ac      	mov	ip, r5
 800efd2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800efd6:	6020      	str	r0, [r4, #0]
 800efd8:	6061      	str	r1, [r4, #4]
 800efda:	60a2      	str	r2, [r4, #8]
 800efdc:	60e3      	str	r3, [r4, #12]
 800efde:	4665      	mov	r5, ip
 800efe0:	3410      	adds	r4, #16
 800efe2:	45f4      	cmp	ip, lr
 800efe4:	d1f4      	bne.n	800efd0 <fCmdBuild_COPS+0x10>
 800efe6:	f8dc 0000 	ldr.w	r0, [ip]
 800efea:	6020      	str	r0, [r4, #0]
 800efec:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800eff0:	80a3      	strh	r3, [r4, #4]
 800eff2:	4c45      	ldr	r4, [pc, #276]	; (800f108 <fCmdBuild_COPS+0x148>)
 800eff4:	4620      	mov	r0, r4
 800eff6:	f010 f998 	bl	801f32a <crs_strlen>
 800effa:	b283      	uxth	r3, r0
 800effc:	4622      	mov	r2, r4
 800effe:	2104      	movs	r1, #4
 800f000:	2002      	movs	r0, #2
 800f002:	f010 f9d5 	bl	801f3b0 <traceIF_itmPrint>
 800f006:	4620      	mov	r0, r4
 800f008:	f010 f98f 	bl	801f32a <crs_strlen>
 800f00c:	b283      	uxth	r3, r0
 800f00e:	4622      	mov	r2, r4
 800f010:	2104      	movs	r1, #4
 800f012:	2002      	movs	r0, #2
 800f014:	f010 f9ee 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f018:	8933      	ldrh	r3, [r6, #8]
 800f01a:	2b03      	cmp	r3, #3
 800f01c:	d003      	beq.n	800f026 <fCmdBuild_COPS+0x66>
  at_status_t retval = ATSTATUS_OK;
 800f01e:	2400      	movs	r4, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
    }
  }

  return (retval);
}
 800f020:	4620      	mov	r0, r4
 800f022:	b003      	add	sp, #12
 800f024:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (operatorSelect->mode == CS_NRM_AUTO)
 800f026:	f8b7 35c8 	ldrh.w	r3, [r7, #1480]	; 0x5c8
 800f02a:	b97b      	cbnz	r3, 800f04c <fCmdBuild_COPS+0x8c>
      if (operatorSelect->AcT_present == CELLULAR_FALSE)
 800f02c:	f897 460c 	ldrb.w	r4, [r7, #1548]	; 0x60c
 800f030:	b91c      	cbnz	r4, 800f03a <fCmdBuild_COPS+0x7a>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f032:	4b36      	ldr	r3, [pc, #216]	; (800f10c <fCmdBuild_COPS+0x14c>)
 800f034:	881b      	ldrh	r3, [r3, #0]
 800f036:	8633      	strh	r3, [r6, #48]	; 0x30
 800f038:	e7f2      	b.n	800f020 <fCmdBuild_COPS+0x60>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0,,,%d",
 800f03a:	f8b7 260e 	ldrh.w	r2, [r7, #1550]	; 0x60e
 800f03e:	4934      	ldr	r1, [pc, #208]	; (800f110 <fCmdBuild_COPS+0x150>)
 800f040:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f044:	f017 fc00 	bl	8026848 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800f048:	2400      	movs	r4, #0
 800f04a:	e7e9      	b.n	800f020 <fCmdBuild_COPS+0x60>
    else if ((operatorSelect->mode == CS_NRM_MANUAL) ||
 800f04c:	2b01      	cmp	r3, #1
 800f04e:	d02f      	beq.n	800f0b0 <fCmdBuild_COPS+0xf0>
 800f050:	2b04      	cmp	r3, #4
 800f052:	d02d      	beq.n	800f0b0 <fCmdBuild_COPS+0xf0>
    else if (operatorSelect->mode == CS_NRM_DEREGISTER)
 800f054:	2b02      	cmp	r3, #2
 800f056:	d04d      	beq.n	800f0f4 <fCmdBuild_COPS+0x134>
      PRINT_ERR("invalid mode value for +COPS")
 800f058:	4d2e      	ldr	r5, [pc, #184]	; (800f114 <fCmdBuild_COPS+0x154>)
 800f05a:	4c2b      	ldr	r4, [pc, #172]	; (800f108 <fCmdBuild_COPS+0x148>)
 800f05c:	f105 0c20 	add.w	ip, r5, #32
 800f060:	462f      	mov	r7, r5
 800f062:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800f064:	6020      	str	r0, [r4, #0]
 800f066:	6061      	str	r1, [r4, #4]
 800f068:	60a2      	str	r2, [r4, #8]
 800f06a:	60e3      	str	r3, [r4, #12]
 800f06c:	463d      	mov	r5, r7
 800f06e:	3410      	adds	r4, #16
 800f070:	4567      	cmp	r7, ip
 800f072:	d1f5      	bne.n	800f060 <fCmdBuild_COPS+0xa0>
 800f074:	cd07      	ldmia	r5!, {r0, r1, r2}
 800f076:	6020      	str	r0, [r4, #0]
 800f078:	6061      	str	r1, [r4, #4]
 800f07a:	60a2      	str	r2, [r4, #8]
 800f07c:	882b      	ldrh	r3, [r5, #0]
 800f07e:	81a3      	strh	r3, [r4, #12]
 800f080:	4c21      	ldr	r4, [pc, #132]	; (800f108 <fCmdBuild_COPS+0x148>)
 800f082:	4620      	mov	r0, r4
 800f084:	f010 f951 	bl	801f32a <crs_strlen>
 800f088:	b283      	uxth	r3, r0
 800f08a:	4622      	mov	r2, r4
 800f08c:	2110      	movs	r1, #16
 800f08e:	2002      	movs	r0, #2
 800f090:	f010 f98e 	bl	801f3b0 <traceIF_itmPrint>
 800f094:	4620      	mov	r0, r4
 800f096:	f010 f948 	bl	801f32a <crs_strlen>
 800f09a:	b283      	uxth	r3, r0
 800f09c:	4622      	mov	r2, r4
 800f09e:	2110      	movs	r1, #16
 800f0a0:	2002      	movs	r0, #2
 800f0a2:	f010 f9a7 	bl	801f3f4 <traceIF_uartPrint>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f0a6:	4b19      	ldr	r3, [pc, #100]	; (800f10c <fCmdBuild_COPS+0x14c>)
 800f0a8:	881b      	ldrh	r3, [r3, #0]
 800f0aa:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f0ac:	2400      	movs	r4, #0
 800f0ae:	e7b7      	b.n	800f020 <fCmdBuild_COPS+0x60>
      if (operatorSelect->mode == CS_NRM_MANUAL)
 800f0b0:	2b01      	cmp	r3, #1
 800f0b2:	d010      	beq.n	800f0d6 <fCmdBuild_COPS+0x116>
        selected_mode = 4U;
 800f0b4:	2204      	movs	r2, #4
      if (operatorSelect->format != CS_ONF_NOT_PRESENT)
 800f0b6:	f8b7 35ca 	ldrh.w	r3, [r7, #1482]	; 0x5ca
 800f0ba:	2b09      	cmp	r3, #9
 800f0bc:	d01f      	beq.n	800f0fe <fCmdBuild_COPS+0x13e>
        if (operatorSelect->AcT_present == CELLULAR_FALSE)
 800f0be:	f897 460c 	ldrb.w	r4, [r7, #1548]	; 0x60c
 800f0c2:	b954      	cbnz	r4, 800f0da <fCmdBuild_COPS+0x11a>
                         operatorSelect->operator_name);
 800f0c4:	f207 57cc 	addw	r7, r7, #1484	; 0x5cc
          (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d,\"%s\"",
 800f0c8:	9700      	str	r7, [sp, #0]
 800f0ca:	4913      	ldr	r1, [pc, #76]	; (800f118 <fCmdBuild_COPS+0x158>)
 800f0cc:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f0d0:	f017 fbba 	bl	8026848 <sprintf>
 800f0d4:	e7a4      	b.n	800f020 <fCmdBuild_COPS+0x60>
        selected_mode = 1U;
 800f0d6:	2201      	movs	r2, #1
 800f0d8:	e7ed      	b.n	800f0b6 <fCmdBuild_COPS+0xf6>
                         operatorSelect->operator_name,
 800f0da:	f207 51cc 	addw	r1, r7, #1484	; 0x5cc
                         operatorSelect->AcT);
 800f0de:	f8b7 060e 	ldrh.w	r0, [r7, #1550]	; 0x60e
          (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d,\"%s\",%d",
 800f0e2:	9001      	str	r0, [sp, #4]
 800f0e4:	9100      	str	r1, [sp, #0]
 800f0e6:	490d      	ldr	r1, [pc, #52]	; (800f11c <fCmdBuild_COPS+0x15c>)
 800f0e8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f0ec:	f017 fbac 	bl	8026848 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800f0f0:	2400      	movs	r4, #0
 800f0f2:	e795      	b.n	800f020 <fCmdBuild_COPS+0x60>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "2");
 800f0f4:	4b0a      	ldr	r3, [pc, #40]	; (800f120 <fCmdBuild_COPS+0x160>)
 800f0f6:	881b      	ldrh	r3, [r3, #0]
 800f0f8:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f0fa:	2400      	movs	r4, #0
 800f0fc:	e790      	b.n	800f020 <fCmdBuild_COPS+0x60>
        retval = ATSTATUS_ERROR;
 800f0fe:	2401      	movs	r4, #1
 800f100:	e78e      	b.n	800f020 <fCmdBuild_COPS+0x60>
 800f102:	bf00      	nop
 800f104:	0802f3e0 	.word	0x0802f3e0
 800f108:	200048dc 	.word	0x200048dc
 800f10c:	080342b8 	.word	0x080342b8
 800f110:	0802f408 	.word	0x0802f408
 800f114:	0802f430 	.word	0x0802f430
 800f118:	0802f410 	.word	0x0802f410
 800f11c:	0802f41c 	.word	0x0802f41c
 800f120:	0802f42c 	.word	0x0802f42c

0800f124 <fCmdBuild_CGATT>:

at_status_t fCmdBuild_CGATT(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f124:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f126:	4606      	mov	r6, r0
 800f128:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGATT()")
 800f12a:	4d37      	ldr	r5, [pc, #220]	; (800f208 <fCmdBuild_CGATT+0xe4>)
 800f12c:	4c37      	ldr	r4, [pc, #220]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f12e:	f105 0e20 	add.w	lr, r5, #32
 800f132:	46ac      	mov	ip, r5
 800f134:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f138:	6020      	str	r0, [r4, #0]
 800f13a:	6061      	str	r1, [r4, #4]
 800f13c:	60a2      	str	r2, [r4, #8]
 800f13e:	60e3      	str	r3, [r4, #12]
 800f140:	4665      	mov	r5, ip
 800f142:	3410      	adds	r4, #16
 800f144:	45f4      	cmp	ip, lr
 800f146:	d1f4      	bne.n	800f132 <fCmdBuild_CGATT+0xe>
 800f148:	f8dc 0000 	ldr.w	r0, [ip]
 800f14c:	6020      	str	r0, [r4, #0]
 800f14e:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f152:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f156:	80a2      	strh	r2, [r4, #4]
 800f158:	71a3      	strb	r3, [r4, #6]
 800f15a:	4c2c      	ldr	r4, [pc, #176]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f15c:	4620      	mov	r0, r4
 800f15e:	f010 f8e4 	bl	801f32a <crs_strlen>
 800f162:	b283      	uxth	r3, r0
 800f164:	4622      	mov	r2, r4
 800f166:	2104      	movs	r1, #4
 800f168:	2002      	movs	r0, #2
 800f16a:	f010 f921 	bl	801f3b0 <traceIF_itmPrint>
 800f16e:	4620      	mov	r0, r4
 800f170:	f010 f8db 	bl	801f32a <crs_strlen>
 800f174:	b283      	uxth	r3, r0
 800f176:	4622      	mov	r2, r4
 800f178:	2104      	movs	r1, #4
 800f17a:	2002      	movs	r0, #2
 800f17c:	f010 f93a 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f180:	8933      	ldrh	r3, [r6, #8]
 800f182:	2b03      	cmp	r3, #3
 800f184:	d001      	beq.n	800f18a <fCmdBuild_CGATT+0x66>
  at_status_t retval = ATSTATUS_OK;
 800f186:	2000      	movs	r0, #0
      retval = ATSTATUS_ERROR;
    }
  }

  return (retval);
}
 800f188:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((p_modem_ctxt->CMD_ctxt.cgatt_write_cmd_param == CGATT_ATTACHED) ||
 800f18a:	f897 372d 	ldrb.w	r3, [r7, #1837]	; 0x72d
 800f18e:	2b01      	cmp	r3, #1
 800f190:	d00a      	beq.n	800f1a8 <fCmdBuild_CGATT+0x84>
        (p_atp_ctxt->current_SID == (at_msg_t) SID_ATTACH_PS_DOMAIN))
 800f192:	8832      	ldrh	r2, [r6, #0]
    if ((p_modem_ctxt->CMD_ctxt.cgatt_write_cmd_param == CGATT_ATTACHED) ||
 800f194:	2a70      	cmp	r2, #112	; 0x70
 800f196:	d007      	beq.n	800f1a8 <fCmdBuild_CGATT+0x84>
    else if ((p_modem_ctxt->CMD_ctxt.cgatt_write_cmd_param == CGATT_DETACHED) ||
 800f198:	b10b      	cbz	r3, 800f19e <fCmdBuild_CGATT+0x7a>
 800f19a:	2a71      	cmp	r2, #113	; 0x71
 800f19c:	d109      	bne.n	800f1b2 <fCmdBuild_CGATT+0x8e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f19e:	4b1c      	ldr	r3, [pc, #112]	; (800f210 <fCmdBuild_CGATT+0xec>)
 800f1a0:	881b      	ldrh	r3, [r3, #0]
 800f1a2:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f1a4:	2000      	movs	r0, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f1a6:	e7ef      	b.n	800f188 <fCmdBuild_CGATT+0x64>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f1a8:	4b1a      	ldr	r3, [pc, #104]	; (800f214 <fCmdBuild_CGATT+0xf0>)
 800f1aa:	881b      	ldrh	r3, [r3, #0]
 800f1ac:	8633      	strh	r3, [r6, #48]	; 0x30
  at_status_t retval = ATSTATUS_OK;
 800f1ae:	2000      	movs	r0, #0
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f1b0:	e7ea      	b.n	800f188 <fCmdBuild_CGATT+0x64>
      PRINT_ERR("CGATT state parameter not set")
 800f1b2:	4d19      	ldr	r5, [pc, #100]	; (800f218 <fCmdBuild_CGATT+0xf4>)
 800f1b4:	4c15      	ldr	r4, [pc, #84]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f1b6:	f105 0720 	add.w	r7, r5, #32
 800f1ba:	462e      	mov	r6, r5
 800f1bc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800f1be:	6020      	str	r0, [r4, #0]
 800f1c0:	6061      	str	r1, [r4, #4]
 800f1c2:	60a2      	str	r2, [r4, #8]
 800f1c4:	60e3      	str	r3, [r4, #12]
 800f1c6:	4635      	mov	r5, r6
 800f1c8:	3410      	adds	r4, #16
 800f1ca:	42be      	cmp	r6, r7
 800f1cc:	d1f5      	bne.n	800f1ba <fCmdBuild_CGATT+0x96>
 800f1ce:	cd07      	ldmia	r5!, {r0, r1, r2}
 800f1d0:	6020      	str	r0, [r4, #0]
 800f1d2:	6061      	str	r1, [r4, #4]
 800f1d4:	60a2      	str	r2, [r4, #8]
 800f1d6:	882a      	ldrh	r2, [r5, #0]
 800f1d8:	78ab      	ldrb	r3, [r5, #2]
 800f1da:	81a2      	strh	r2, [r4, #12]
 800f1dc:	73a3      	strb	r3, [r4, #14]
 800f1de:	4c0b      	ldr	r4, [pc, #44]	; (800f20c <fCmdBuild_CGATT+0xe8>)
 800f1e0:	4620      	mov	r0, r4
 800f1e2:	f010 f8a2 	bl	801f32a <crs_strlen>
 800f1e6:	b283      	uxth	r3, r0
 800f1e8:	4622      	mov	r2, r4
 800f1ea:	2110      	movs	r1, #16
 800f1ec:	2002      	movs	r0, #2
 800f1ee:	f010 f8df 	bl	801f3b0 <traceIF_itmPrint>
 800f1f2:	4620      	mov	r0, r4
 800f1f4:	f010 f899 	bl	801f32a <crs_strlen>
 800f1f8:	b283      	uxth	r3, r0
 800f1fa:	4622      	mov	r2, r4
 800f1fc:	2110      	movs	r1, #16
 800f1fe:	2002      	movs	r0, #2
 800f200:	f010 f8f8 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800f204:	2001      	movs	r0, #1
 800f206:	e7bf      	b.n	800f188 <fCmdBuild_CGATT+0x64>
 800f208:	0802f460 	.word	0x0802f460
 800f20c:	200048dc 	.word	0x200048dc
 800f210:	080342b8 	.word	0x080342b8
 800f214:	080342a4 	.word	0x080342a4
 800f218:	0802f488 	.word	0x0802f488

0800f21c <fCmdBuild_CREG>:

at_status_t fCmdBuild_CREG(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f21c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f21e:	4606      	mov	r6, r0
 800f220:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CREG()")
 800f222:	4d22      	ldr	r5, [pc, #136]	; (800f2ac <fCmdBuild_CREG+0x90>)
 800f224:	4c22      	ldr	r4, [pc, #136]	; (800f2b0 <fCmdBuild_CREG+0x94>)
 800f226:	f105 0e20 	add.w	lr, r5, #32
 800f22a:	46ac      	mov	ip, r5
 800f22c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f230:	6020      	str	r0, [r4, #0]
 800f232:	6061      	str	r1, [r4, #4]
 800f234:	60a2      	str	r2, [r4, #8]
 800f236:	60e3      	str	r3, [r4, #12]
 800f238:	4665      	mov	r5, ip
 800f23a:	3410      	adds	r4, #16
 800f23c:	45f4      	cmp	ip, lr
 800f23e:	d1f4      	bne.n	800f22a <fCmdBuild_CREG+0xe>
 800f240:	f8dc 0000 	ldr.w	r0, [ip]
 800f244:	6020      	str	r0, [r4, #0]
 800f246:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800f24a:	80a3      	strh	r3, [r4, #4]
 800f24c:	4c18      	ldr	r4, [pc, #96]	; (800f2b0 <fCmdBuild_CREG+0x94>)
 800f24e:	4620      	mov	r0, r4
 800f250:	f010 f86b 	bl	801f32a <crs_strlen>
 800f254:	b283      	uxth	r3, r0
 800f256:	4622      	mov	r2, r4
 800f258:	2104      	movs	r1, #4
 800f25a:	2002      	movs	r0, #2
 800f25c:	f010 f8a8 	bl	801f3b0 <traceIF_itmPrint>
 800f260:	4620      	mov	r0, r4
 800f262:	f010 f862 	bl	801f32a <crs_strlen>
 800f266:	b283      	uxth	r3, r0
 800f268:	4622      	mov	r2, r4
 800f26a:	2104      	movs	r1, #4
 800f26c:	2002      	movs	r0, #2
 800f26e:	f010 f8c1 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f272:	8933      	ldrh	r3, [r6, #8]
 800f274:	2b03      	cmp	r3, #3
 800f276:	d001      	beq.n	800f27c <fCmdBuild_CREG+0x60>
                     (uint8_t) p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param);
    }
  }

  return (retval);
}
 800f278:	2000      	movs	r0, #0
 800f27a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT)
 800f27c:	8833      	ldrh	r3, [r6, #0]
 800f27e:	2b6a      	cmp	r3, #106	; 0x6a
 800f280:	d009      	beq.n	800f296 <fCmdBuild_CREG+0x7a>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_UNSUSBCRIBE_NET_EVENT)
 800f282:	2b6b      	cmp	r3, #107	; 0x6b
 800f284:	d00e      	beq.n	800f2a4 <fCmdBuild_CREG+0x88>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800f286:	f897 272e 	ldrb.w	r2, [r7, #1838]	; 0x72e
 800f28a:	490a      	ldr	r1, [pc, #40]	; (800f2b4 <fCmdBuild_CREG+0x98>)
 800f28c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f290:	f017 fada 	bl	8026848 <sprintf>
 800f294:	e7f0      	b.n	800f278 <fCmdBuild_CREG+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", (uint8_t)CXREG_ENABLE_NETWK_REG_LOC_URC);
 800f296:	2202      	movs	r2, #2
 800f298:	4906      	ldr	r1, [pc, #24]	; (800f2b4 <fCmdBuild_CREG+0x98>)
 800f29a:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f29e:	f017 fad3 	bl	8026848 <sprintf>
 800f2a2:	e7e9      	b.n	800f278 <fCmdBuild_CREG+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f2a4:	4b04      	ldr	r3, [pc, #16]	; (800f2b8 <fCmdBuild_CREG+0x9c>)
 800f2a6:	881b      	ldrh	r3, [r3, #0]
 800f2a8:	8633      	strh	r3, [r6, #48]	; 0x30
 800f2aa:	e7e5      	b.n	800f278 <fCmdBuild_CREG+0x5c>
 800f2ac:	0802f4b8 	.word	0x0802f4b8
 800f2b0:	200048dc 	.word	0x200048dc
 800f2b4:	0802f40c 	.word	0x0802f40c
 800f2b8:	080342b8 	.word	0x080342b8

0800f2bc <fCmdBuild_CGREG>:

at_status_t fCmdBuild_CGREG(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f2bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f2be:	4606      	mov	r6, r0
 800f2c0:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGREG()")
 800f2c2:	4d26      	ldr	r5, [pc, #152]	; (800f35c <fCmdBuild_CGREG+0xa0>)
 800f2c4:	4c26      	ldr	r4, [pc, #152]	; (800f360 <fCmdBuild_CGREG+0xa4>)
 800f2c6:	f105 0e20 	add.w	lr, r5, #32
 800f2ca:	46ac      	mov	ip, r5
 800f2cc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f2d0:	6020      	str	r0, [r4, #0]
 800f2d2:	6061      	str	r1, [r4, #4]
 800f2d4:	60a2      	str	r2, [r4, #8]
 800f2d6:	60e3      	str	r3, [r4, #12]
 800f2d8:	4665      	mov	r5, ip
 800f2da:	3410      	adds	r4, #16
 800f2dc:	45f4      	cmp	ip, lr
 800f2de:	d1f4      	bne.n	800f2ca <fCmdBuild_CGREG+0xe>
 800f2e0:	f8dc 0000 	ldr.w	r0, [ip]
 800f2e4:	6020      	str	r0, [r4, #0]
 800f2e6:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f2ea:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f2ee:	80a2      	strh	r2, [r4, #4]
 800f2f0:	71a3      	strb	r3, [r4, #6]
 800f2f2:	4c1b      	ldr	r4, [pc, #108]	; (800f360 <fCmdBuild_CGREG+0xa4>)
 800f2f4:	4620      	mov	r0, r4
 800f2f6:	f010 f818 	bl	801f32a <crs_strlen>
 800f2fa:	b283      	uxth	r3, r0
 800f2fc:	4622      	mov	r2, r4
 800f2fe:	2104      	movs	r1, #4
 800f300:	2002      	movs	r0, #2
 800f302:	f010 f855 	bl	801f3b0 <traceIF_itmPrint>
 800f306:	4620      	mov	r0, r4
 800f308:	f010 f80f 	bl	801f32a <crs_strlen>
 800f30c:	b283      	uxth	r3, r0
 800f30e:	4622      	mov	r2, r4
 800f310:	2104      	movs	r1, #4
 800f312:	2002      	movs	r0, #2
 800f314:	f010 f86e 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f318:	8933      	ldrh	r3, [r6, #8]
 800f31a:	2b03      	cmp	r3, #3
 800f31c:	d001      	beq.n	800f322 <fCmdBuild_CGREG+0x66>
                     (uint8_t) p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param);
    }
  }

  return (retval);
}
 800f31e:	2000      	movs	r0, #0
 800f320:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT)
 800f322:	8833      	ldrh	r3, [r6, #0]
 800f324:	2b6a      	cmp	r3, #106	; 0x6a
 800f326:	d009      	beq.n	800f33c <fCmdBuild_CGREG+0x80>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_UNSUSBCRIBE_NET_EVENT)
 800f328:	2b6b      	cmp	r3, #107	; 0x6b
 800f32a:	d013      	beq.n	800f354 <fCmdBuild_CGREG+0x98>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800f32c:	f897 272e 	ldrb.w	r2, [r7, #1838]	; 0x72e
 800f330:	490c      	ldr	r1, [pc, #48]	; (800f364 <fCmdBuild_CGREG+0xa8>)
 800f332:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f336:	f017 fa87 	bl	8026848 <sprintf>
 800f33a:	e7f0      	b.n	800f31e <fCmdBuild_CGREG+0x62>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800f33c:	f897 350d 	ldrb.w	r3, [r7, #1293]	; 0x50d
 800f340:	b133      	cbz	r3, 800f350 <fCmdBuild_CGREG+0x94>
        param_value = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800f342:	2204      	movs	r2, #4
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", (uint8_t) param_value);
 800f344:	4907      	ldr	r1, [pc, #28]	; (800f364 <fCmdBuild_CGREG+0xa8>)
 800f346:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f34a:	f017 fa7d 	bl	8026848 <sprintf>
 800f34e:	e7e6      	b.n	800f31e <fCmdBuild_CGREG+0x62>
        param_value = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800f350:	2202      	movs	r2, #2
 800f352:	e7f7      	b.n	800f344 <fCmdBuild_CGREG+0x88>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f354:	4b04      	ldr	r3, [pc, #16]	; (800f368 <fCmdBuild_CGREG+0xac>)
 800f356:	881b      	ldrh	r3, [r3, #0]
 800f358:	8633      	strh	r3, [r6, #48]	; 0x30
 800f35a:	e7e0      	b.n	800f31e <fCmdBuild_CGREG+0x62>
 800f35c:	0802f4e0 	.word	0x0802f4e0
 800f360:	200048dc 	.word	0x200048dc
 800f364:	0802f40c 	.word	0x0802f40c
 800f368:	080342b8 	.word	0x080342b8

0800f36c <fCmdBuild_CEREG>:

at_status_t fCmdBuild_CEREG(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f36c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f36e:	4606      	mov	r6, r0
 800f370:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CEREG()")
 800f372:	4d26      	ldr	r5, [pc, #152]	; (800f40c <fCmdBuild_CEREG+0xa0>)
 800f374:	4c26      	ldr	r4, [pc, #152]	; (800f410 <fCmdBuild_CEREG+0xa4>)
 800f376:	f105 0e20 	add.w	lr, r5, #32
 800f37a:	46ac      	mov	ip, r5
 800f37c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f380:	6020      	str	r0, [r4, #0]
 800f382:	6061      	str	r1, [r4, #4]
 800f384:	60a2      	str	r2, [r4, #8]
 800f386:	60e3      	str	r3, [r4, #12]
 800f388:	4665      	mov	r5, ip
 800f38a:	3410      	adds	r4, #16
 800f38c:	45f4      	cmp	ip, lr
 800f38e:	d1f4      	bne.n	800f37a <fCmdBuild_CEREG+0xe>
 800f390:	f8dc 0000 	ldr.w	r0, [ip]
 800f394:	6020      	str	r0, [r4, #0]
 800f396:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f39a:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f39e:	80a2      	strh	r2, [r4, #4]
 800f3a0:	71a3      	strb	r3, [r4, #6]
 800f3a2:	4c1b      	ldr	r4, [pc, #108]	; (800f410 <fCmdBuild_CEREG+0xa4>)
 800f3a4:	4620      	mov	r0, r4
 800f3a6:	f00f ffc0 	bl	801f32a <crs_strlen>
 800f3aa:	b283      	uxth	r3, r0
 800f3ac:	4622      	mov	r2, r4
 800f3ae:	2104      	movs	r1, #4
 800f3b0:	2002      	movs	r0, #2
 800f3b2:	f00f fffd 	bl	801f3b0 <traceIF_itmPrint>
 800f3b6:	4620      	mov	r0, r4
 800f3b8:	f00f ffb7 	bl	801f32a <crs_strlen>
 800f3bc:	b283      	uxth	r3, r0
 800f3be:	4622      	mov	r2, r4
 800f3c0:	2104      	movs	r1, #4
 800f3c2:	2002      	movs	r0, #2
 800f3c4:	f010 f816 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f3c8:	8933      	ldrh	r3, [r6, #8]
 800f3ca:	2b03      	cmp	r3, #3
 800f3cc:	d001      	beq.n	800f3d2 <fCmdBuild_CEREG+0x66>
                     (uint8_t) p_modem_ctxt->CMD_ctxt.cxreg_write_cmd_param);
    }
  }

  return (retval);
}
 800f3ce:	2000      	movs	r0, #0
 800f3d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT)
 800f3d2:	8833      	ldrh	r3, [r6, #0]
 800f3d4:	2b6a      	cmp	r3, #106	; 0x6a
 800f3d6:	d009      	beq.n	800f3ec <fCmdBuild_CEREG+0x80>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_UNSUSBCRIBE_NET_EVENT)
 800f3d8:	2b6b      	cmp	r3, #107	; 0x6b
 800f3da:	d013      	beq.n	800f404 <fCmdBuild_CEREG+0x98>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800f3dc:	f897 272e 	ldrb.w	r2, [r7, #1838]	; 0x72e
 800f3e0:	490c      	ldr	r1, [pc, #48]	; (800f414 <fCmdBuild_CEREG+0xa8>)
 800f3e2:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f3e6:	f017 fa2f 	bl	8026848 <sprintf>
 800f3ea:	e7f0      	b.n	800f3ce <fCmdBuild_CEREG+0x62>
      if (p_modem_ctxt->persist.psm_urc_requested == AT_TRUE)
 800f3ec:	f897 350d 	ldrb.w	r3, [r7, #1293]	; 0x50d
 800f3f0:	b133      	cbz	r3, 800f400 <fCmdBuild_CEREG+0x94>
        param_value = CXREG_ENABLE_PSM_NETWK_REG_LOC_URC;
 800f3f2:	2204      	movs	r2, #4
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", (uint8_t)param_value);
 800f3f4:	4907      	ldr	r1, [pc, #28]	; (800f414 <fCmdBuild_CEREG+0xa8>)
 800f3f6:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f3fa:	f017 fa25 	bl	8026848 <sprintf>
 800f3fe:	e7e6      	b.n	800f3ce <fCmdBuild_CEREG+0x62>
        param_value = CXREG_ENABLE_NETWK_REG_LOC_URC;
 800f400:	2202      	movs	r2, #2
 800f402:	e7f7      	b.n	800f3f4 <fCmdBuild_CEREG+0x88>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f404:	4b04      	ldr	r3, [pc, #16]	; (800f418 <fCmdBuild_CEREG+0xac>)
 800f406:	881b      	ldrh	r3, [r3, #0]
 800f408:	8633      	strh	r3, [r6, #48]	; 0x30
 800f40a:	e7e0      	b.n	800f3ce <fCmdBuild_CEREG+0x62>
 800f40c:	0802f508 	.word	0x0802f508
 800f410:	200048dc 	.word	0x200048dc
 800f414:	0802f40c 	.word	0x0802f40c
 800f418:	080342b8 	.word	0x080342b8

0800f41c <fCmdBuild_CGEREP>:

at_status_t fCmdBuild_CGEREP(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f41c:	b570      	push	{r4, r5, r6, lr}
 800f41e:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGEREP()")
 800f420:	4c1b      	ldr	r4, [pc, #108]	; (800f490 <fCmdBuild_CGEREP+0x74>)
 800f422:	4d1c      	ldr	r5, [pc, #112]	; (800f494 <fCmdBuild_CGEREP+0x78>)
 800f424:	f104 0e20 	add.w	lr, r4, #32
 800f428:	46a4      	mov	ip, r4
 800f42a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f42e:	6028      	str	r0, [r5, #0]
 800f430:	6069      	str	r1, [r5, #4]
 800f432:	60aa      	str	r2, [r5, #8]
 800f434:	60eb      	str	r3, [r5, #12]
 800f436:	4664      	mov	r4, ip
 800f438:	3510      	adds	r5, #16
 800f43a:	45f4      	cmp	ip, lr
 800f43c:	d1f4      	bne.n	800f428 <fCmdBuild_CGEREP+0xc>
 800f43e:	cc03      	ldmia	r4!, {r0, r1}
 800f440:	6028      	str	r0, [r5, #0]
 800f442:	6069      	str	r1, [r5, #4]
 800f444:	4c13      	ldr	r4, [pc, #76]	; (800f494 <fCmdBuild_CGEREP+0x78>)
 800f446:	4620      	mov	r0, r4
 800f448:	f00f ff6f 	bl	801f32a <crs_strlen>
 800f44c:	b283      	uxth	r3, r0
 800f44e:	4622      	mov	r2, r4
 800f450:	2104      	movs	r1, #4
 800f452:	2002      	movs	r0, #2
 800f454:	f00f ffac 	bl	801f3b0 <traceIF_itmPrint>
 800f458:	4620      	mov	r0, r4
 800f45a:	f00f ff66 	bl	801f32a <crs_strlen>
 800f45e:	b283      	uxth	r3, r0
 800f460:	4622      	mov	r2, r4
 800f462:	2104      	movs	r1, #4
 800f464:	2002      	movs	r0, #2
 800f466:	f00f ffc5 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f46a:	8933      	ldrh	r3, [r6, #8]
 800f46c:	2b03      	cmp	r3, #3
 800f46e:	d001      	beq.n	800f474 <fCmdBuild_CGEREP+0x58>
      /* nothing to do */
    }
  }

  return (retval);
}
 800f470:	2000      	movs	r0, #0
 800f472:	bd70      	pop	{r4, r5, r6, pc}
    if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_REGISTER_PDN_EVENT)
 800f474:	8833      	ldrh	r3, [r6, #0]
 800f476:	2b73      	cmp	r3, #115	; 0x73
 800f478:	d005      	beq.n	800f486 <fCmdBuild_CGEREP+0x6a>
    else if (p_atp_ctxt->current_SID == (at_msg_t) SID_CS_DEREGISTER_PDN_EVENT)
 800f47a:	2b74      	cmp	r3, #116	; 0x74
 800f47c:	d1f8      	bne.n	800f470 <fCmdBuild_CGEREP+0x54>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f47e:	4b06      	ldr	r3, [pc, #24]	; (800f498 <fCmdBuild_CGEREP+0x7c>)
 800f480:	881b      	ldrh	r3, [r3, #0]
 800f482:	8633      	strh	r3, [r6, #48]	; 0x30
 800f484:	e7f4      	b.n	800f470 <fCmdBuild_CGEREP+0x54>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1,0");
 800f486:	4b05      	ldr	r3, [pc, #20]	; (800f49c <fCmdBuild_CGEREP+0x80>)
 800f488:	6818      	ldr	r0, [r3, #0]
 800f48a:	6330      	str	r0, [r6, #48]	; 0x30
 800f48c:	e7f0      	b.n	800f470 <fCmdBuild_CGEREP+0x54>
 800f48e:	bf00      	nop
 800f490:	0802f530 	.word	0x0802f530
 800f494:	200048dc 	.word	0x200048dc
 800f498:	080342b8 	.word	0x080342b8
 800f49c:	0802f558 	.word	0x0802f558

0800f4a0 <fCmdBuild_CGDCONT>:

at_status_t fCmdBuild_CGDCONT(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f4a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f4a4:	b082      	sub	sp, #8
 800f4a6:	4607      	mov	r7, r0
 800f4a8:	460e      	mov	r6, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGDCONT()")
 800f4aa:	4c45      	ldr	r4, [pc, #276]	; (800f5c0 <fCmdBuild_CGDCONT+0x120>)
 800f4ac:	4d45      	ldr	r5, [pc, #276]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f4ae:	f104 0e20 	add.w	lr, r4, #32
 800f4b2:	46a4      	mov	ip, r4
 800f4b4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f4b8:	6028      	str	r0, [r5, #0]
 800f4ba:	6069      	str	r1, [r5, #4]
 800f4bc:	60aa      	str	r2, [r5, #8]
 800f4be:	60eb      	str	r3, [r5, #12]
 800f4c0:	4664      	mov	r4, ip
 800f4c2:	3510      	adds	r5, #16
 800f4c4:	45f4      	cmp	ip, lr
 800f4c6:	d1f4      	bne.n	800f4b2 <fCmdBuild_CGDCONT+0x12>
 800f4c8:	cc03      	ldmia	r4!, {r0, r1}
 800f4ca:	6028      	str	r0, [r5, #0]
 800f4cc:	6069      	str	r1, [r5, #4]
 800f4ce:	7823      	ldrb	r3, [r4, #0]
 800f4d0:	722b      	strb	r3, [r5, #8]
 800f4d2:	4c3c      	ldr	r4, [pc, #240]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f4d4:	4620      	mov	r0, r4
 800f4d6:	f00f ff28 	bl	801f32a <crs_strlen>
 800f4da:	b283      	uxth	r3, r0
 800f4dc:	4622      	mov	r2, r4
 800f4de:	2104      	movs	r1, #4
 800f4e0:	2002      	movs	r0, #2
 800f4e2:	f00f ff65 	bl	801f3b0 <traceIF_itmPrint>
 800f4e6:	4620      	mov	r0, r4
 800f4e8:	f00f ff1f 	bl	801f32a <crs_strlen>
 800f4ec:	b283      	uxth	r3, r0
 800f4ee:	4622      	mov	r2, r4
 800f4f0:	2104      	movs	r1, #4
 800f4f2:	2002      	movs	r0, #2
 800f4f4:	f00f ff7e 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f4f8:	893b      	ldrh	r3, [r7, #8]
 800f4fa:	2b03      	cmp	r3, #3
 800f4fc:	d003      	beq.n	800f506 <fCmdBuild_CGDCONT+0x66>
  at_status_t retval = ATSTATUS_OK;
 800f4fe:	2000      	movs	r0, #0
      retval = ATSTATUS_ERROR;
    }
  }

  return (retval);
}
 800f500:	b002      	add	sp, #8
 800f502:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f506:	4630      	mov	r0, r6
 800f508:	f7fd f9d4 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f50c:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f50e:	4601      	mov	r1, r0
 800f510:	f106 000c 	add.w	r0, r6, #12
 800f514:	f7fe fa56 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f518:	4680      	mov	r8, r0
    PRINT_INFO("user cid = %d, modem cid = %d", (uint8_t)current_conf_id, modem_cid)
 800f51a:	4d2a      	ldr	r5, [pc, #168]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f51c:	4603      	mov	r3, r0
 800f51e:	4622      	mov	r2, r4
 800f520:	4929      	ldr	r1, [pc, #164]	; (800f5c8 <fCmdBuild_CGDCONT+0x128>)
 800f522:	4628      	mov	r0, r5
 800f524:	f017 f990 	bl	8026848 <sprintf>
 800f528:	4628      	mov	r0, r5
 800f52a:	f00f fefe 	bl	801f32a <crs_strlen>
 800f52e:	b283      	uxth	r3, r0
 800f530:	462a      	mov	r2, r5
 800f532:	2101      	movs	r1, #1
 800f534:	2002      	movs	r0, #2
 800f536:	f00f ff3b 	bl	801f3b0 <traceIF_itmPrint>
 800f53a:	4628      	mov	r0, r5
 800f53c:	f00f fef5 	bl	801f32a <crs_strlen>
 800f540:	b283      	uxth	r3, r0
 800f542:	462a      	mov	r2, r5
 800f544:	2101      	movs	r1, #1
 800f546:	2002      	movs	r0, #2
 800f548:	f00f ff54 	bl	801f3f4 <traceIF_uartPrint>
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id != CS_PDN_NOT_DEFINED)
 800f54c:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f550:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800f554:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f558:	2b0c      	cmp	r3, #12
 800f55a:	d017      	beq.n	800f58c <fCmdBuild_CGDCONT+0xec>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 800f55c:	3730      	adds	r7, #48	; 0x30
 800f55e:	01a5      	lsls	r5, r4, #6
 800f560:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f564:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800f568:	f893 0091 	ldrb.w	r0, [r3, #145]	; 0x91
 800f56c:	f7fd fa50 	bl	800ca10 <atcm_get_PDPtypeStr>
 800f570:	4603      	mov	r3, r0
                     p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].apn);
 800f572:	4425      	add	r5, r4
 800f574:	006d      	lsls	r5, r5, #1
 800f576:	3548      	adds	r5, #72	; 0x48
 800f578:	442e      	add	r6, r5
 800f57a:	3609      	adds	r6, #9
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,\"%s\",\"%s\"",
 800f57c:	9600      	str	r6, [sp, #0]
 800f57e:	4642      	mov	r2, r8
 800f580:	4912      	ldr	r1, [pc, #72]	; (800f5cc <fCmdBuild_CGDCONT+0x12c>)
 800f582:	4638      	mov	r0, r7
 800f584:	f017 f960 	bl	8026848 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800f588:	2000      	movs	r0, #0
 800f58a:	e7b9      	b.n	800f500 <fCmdBuild_CGDCONT+0x60>
      PRINT_ERR("PDP context not defined for conf_id %d", current_conf_id)
 800f58c:	4d0d      	ldr	r5, [pc, #52]	; (800f5c4 <fCmdBuild_CGDCONT+0x124>)
 800f58e:	4622      	mov	r2, r4
 800f590:	490f      	ldr	r1, [pc, #60]	; (800f5d0 <fCmdBuild_CGDCONT+0x130>)
 800f592:	4628      	mov	r0, r5
 800f594:	f017 f958 	bl	8026848 <sprintf>
 800f598:	4628      	mov	r0, r5
 800f59a:	f00f fec6 	bl	801f32a <crs_strlen>
 800f59e:	b283      	uxth	r3, r0
 800f5a0:	462a      	mov	r2, r5
 800f5a2:	2110      	movs	r1, #16
 800f5a4:	2002      	movs	r0, #2
 800f5a6:	f00f ff03 	bl	801f3b0 <traceIF_itmPrint>
 800f5aa:	4628      	mov	r0, r5
 800f5ac:	f00f febd 	bl	801f32a <crs_strlen>
 800f5b0:	b283      	uxth	r3, r0
 800f5b2:	462a      	mov	r2, r5
 800f5b4:	2110      	movs	r1, #16
 800f5b6:	2002      	movs	r0, #2
 800f5b8:	f00f ff1c 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 800f5bc:	2001      	movs	r0, #1
 800f5be:	e79f      	b.n	800f500 <fCmdBuild_CGDCONT+0x60>
 800f5c0:	0802f55c 	.word	0x0802f55c
 800f5c4:	200048dc 	.word	0x200048dc
 800f5c8:	0802f588 	.word	0x0802f588
 800f5cc:	0802b534 	.word	0x0802b534
 800f5d0:	0802f5b4 	.word	0x0802f5b4

0800f5d4 <fCmdBuild_CGACT>:

at_status_t fCmdBuild_CGACT(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f5d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f5d8:	4606      	mov	r6, r0
 800f5da:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGACT()")
 800f5dc:	4d34      	ldr	r5, [pc, #208]	; (800f6b0 <fCmdBuild_CGACT+0xdc>)
 800f5de:	4c35      	ldr	r4, [pc, #212]	; (800f6b4 <fCmdBuild_CGACT+0xe0>)
 800f5e0:	f105 0e20 	add.w	lr, r5, #32
 800f5e4:	46ac      	mov	ip, r5
 800f5e6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f5ea:	6020      	str	r0, [r4, #0]
 800f5ec:	6061      	str	r1, [r4, #4]
 800f5ee:	60a2      	str	r2, [r4, #8]
 800f5f0:	60e3      	str	r3, [r4, #12]
 800f5f2:	4665      	mov	r5, ip
 800f5f4:	3410      	adds	r4, #16
 800f5f6:	45f4      	cmp	ip, lr
 800f5f8:	d1f4      	bne.n	800f5e4 <fCmdBuild_CGACT+0x10>
 800f5fa:	f8dc 0000 	ldr.w	r0, [ip]
 800f5fe:	6020      	str	r0, [r4, #0]
 800f600:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800f604:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800f608:	80a2      	strh	r2, [r4, #4]
 800f60a:	71a3      	strb	r3, [r4, #6]
 800f60c:	4c29      	ldr	r4, [pc, #164]	; (800f6b4 <fCmdBuild_CGACT+0xe0>)
 800f60e:	4620      	mov	r0, r4
 800f610:	f00f fe8b 	bl	801f32a <crs_strlen>
 800f614:	b283      	uxth	r3, r0
 800f616:	4622      	mov	r2, r4
 800f618:	2104      	movs	r1, #4
 800f61a:	2002      	movs	r0, #2
 800f61c:	f00f fec8 	bl	801f3b0 <traceIF_itmPrint>
 800f620:	4620      	mov	r0, r4
 800f622:	f00f fe82 	bl	801f32a <crs_strlen>
 800f626:	b283      	uxth	r3, r0
 800f628:	4622      	mov	r2, r4
 800f62a:	2104      	movs	r1, #4
 800f62c:	2002      	movs	r0, #2
 800f62e:	f00f fee1 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f632:	8933      	ldrh	r3, [r6, #8]
 800f634:	2b03      	cmp	r3, #3
 800f636:	d002      	beq.n	800f63e <fCmdBuild_CGACT+0x6a>
                   ((p_modem_ctxt->CMD_ctxt.pdn_state == PDN_STATE_ACTIVATE) ? 1 : 0),
                   modem_cid);
  }

  return (retval);
}
 800f638:	2000      	movs	r0, #0
 800f63a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f63e:	4638      	mov	r0, r7
 800f640:	f7fd f938 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f644:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f646:	4601      	mov	r1, r0
 800f648:	f107 000c 	add.w	r0, r7, #12
 800f64c:	f7fe f9ba 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f650:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 800f652:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f656:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 800f65a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f65e:	2b0c      	cmp	r3, #12
 800f660:	d00c      	beq.n	800f67c <fCmdBuild_CGACT+0xa8>
                   ((p_modem_ctxt->CMD_ctxt.pdn_state == PDN_STATE_ACTIVATE) ? 1 : 0),
 800f662:	f897 2731 	ldrb.w	r2, [r7, #1841]	; 0x731
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d",
 800f666:	462b      	mov	r3, r5
 800f668:	2a01      	cmp	r2, #1
 800f66a:	bf14      	ite	ne
 800f66c:	2200      	movne	r2, #0
 800f66e:	2201      	moveq	r2, #1
 800f670:	4911      	ldr	r1, [pc, #68]	; (800f6b8 <fCmdBuild_CGACT+0xe4>)
 800f672:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f676:	f017 f8e7 	bl	8026848 <sprintf>
 800f67a:	e7dd      	b.n	800f638 <fCmdBuild_CGACT+0x64>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 800f67c:	f8df 8034 	ldr.w	r8, [pc, #52]	; 800f6b4 <fCmdBuild_CGACT+0xe0>
 800f680:	4622      	mov	r2, r4
 800f682:	490e      	ldr	r1, [pc, #56]	; (800f6bc <fCmdBuild_CGACT+0xe8>)
 800f684:	4640      	mov	r0, r8
 800f686:	f017 f8df 	bl	8026848 <sprintf>
 800f68a:	4640      	mov	r0, r8
 800f68c:	f00f fe4d 	bl	801f32a <crs_strlen>
 800f690:	b283      	uxth	r3, r0
 800f692:	4642      	mov	r2, r8
 800f694:	2101      	movs	r1, #1
 800f696:	2002      	movs	r0, #2
 800f698:	f00f fe8a 	bl	801f3b0 <traceIF_itmPrint>
 800f69c:	4640      	mov	r0, r8
 800f69e:	f00f fe44 	bl	801f32a <crs_strlen>
 800f6a2:	b283      	uxth	r3, r0
 800f6a4:	4642      	mov	r2, r8
 800f6a6:	2101      	movs	r1, #1
 800f6a8:	2002      	movs	r0, #2
 800f6aa:	f00f fea3 	bl	801f3f4 <traceIF_uartPrint>
 800f6ae:	e7d8      	b.n	800f662 <fCmdBuild_CGACT+0x8e>
 800f6b0:	0802f5ec 	.word	0x0802f5ec
 800f6b4:	200048dc 	.word	0x200048dc
 800f6b8:	0802b7ec 	.word	0x0802b7ec
 800f6bc:	0802f614 	.word	0x0802f614

0800f6c0 <fCmdBuild_CGDATA>:

  return (retval);
}

at_status_t fCmdBuild_CGDATA(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f6c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f6c2:	4606      	mov	r6, r0
 800f6c4:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGDATA()")
 800f6c6:	4c2e      	ldr	r4, [pc, #184]	; (800f780 <fCmdBuild_CGDATA+0xc0>)
 800f6c8:	4d2e      	ldr	r5, [pc, #184]	; (800f784 <fCmdBuild_CGDATA+0xc4>)
 800f6ca:	f104 0e20 	add.w	lr, r4, #32
 800f6ce:	46a4      	mov	ip, r4
 800f6d0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f6d4:	6028      	str	r0, [r5, #0]
 800f6d6:	6069      	str	r1, [r5, #4]
 800f6d8:	60aa      	str	r2, [r5, #8]
 800f6da:	60eb      	str	r3, [r5, #12]
 800f6dc:	4664      	mov	r4, ip
 800f6de:	3510      	adds	r5, #16
 800f6e0:	45f4      	cmp	ip, lr
 800f6e2:	d1f4      	bne.n	800f6ce <fCmdBuild_CGDATA+0xe>
 800f6e4:	cc03      	ldmia	r4!, {r0, r1}
 800f6e6:	6028      	str	r0, [r5, #0]
 800f6e8:	6069      	str	r1, [r5, #4]
 800f6ea:	4c26      	ldr	r4, [pc, #152]	; (800f784 <fCmdBuild_CGDATA+0xc4>)
 800f6ec:	4620      	mov	r0, r4
 800f6ee:	f00f fe1c 	bl	801f32a <crs_strlen>
 800f6f2:	b283      	uxth	r3, r0
 800f6f4:	4622      	mov	r2, r4
 800f6f6:	2104      	movs	r1, #4
 800f6f8:	2002      	movs	r0, #2
 800f6fa:	f00f fe59 	bl	801f3b0 <traceIF_itmPrint>
 800f6fe:	4620      	mov	r0, r4
 800f700:	f00f fe13 	bl	801f32a <crs_strlen>
 800f704:	b283      	uxth	r3, r0
 800f706:	4622      	mov	r2, r4
 800f708:	2104      	movs	r1, #4
 800f70a:	2002      	movs	r0, #2
 800f70c:	f00f fe72 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f710:	8933      	ldrh	r3, [r6, #8]
 800f712:	2b03      	cmp	r3, #3
 800f714:	d001      	beq.n	800f71a <fCmdBuild_CGDATA+0x5a>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"PPP\",%d",
                   modem_cid);
  }

  return (retval);
}
 800f716:	2000      	movs	r0, #0
 800f718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f71a:	4638      	mov	r0, r7
 800f71c:	f7fd f8ca 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f720:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f722:	4601      	mov	r1, r0
 800f724:	f107 000c 	add.w	r0, r7, #12
 800f728:	f7fe f94c 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f72c:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 800f72e:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f732:	eb07 0743 	add.w	r7, r7, r3, lsl #1
 800f736:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800f73a:	2b0c      	cmp	r3, #12
 800f73c:	d006      	beq.n	800f74c <fCmdBuild_CGDATA+0x8c>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "\"PPP\",%d",
 800f73e:	462a      	mov	r2, r5
 800f740:	4911      	ldr	r1, [pc, #68]	; (800f788 <fCmdBuild_CGDATA+0xc8>)
 800f742:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f746:	f017 f87f 	bl	8026848 <sprintf>
 800f74a:	e7e4      	b.n	800f716 <fCmdBuild_CGDATA+0x56>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 800f74c:	4f0d      	ldr	r7, [pc, #52]	; (800f784 <fCmdBuild_CGDATA+0xc4>)
 800f74e:	4622      	mov	r2, r4
 800f750:	490e      	ldr	r1, [pc, #56]	; (800f78c <fCmdBuild_CGDATA+0xcc>)
 800f752:	4638      	mov	r0, r7
 800f754:	f017 f878 	bl	8026848 <sprintf>
 800f758:	4638      	mov	r0, r7
 800f75a:	f00f fde6 	bl	801f32a <crs_strlen>
 800f75e:	b283      	uxth	r3, r0
 800f760:	463a      	mov	r2, r7
 800f762:	2101      	movs	r1, #1
 800f764:	2002      	movs	r0, #2
 800f766:	f00f fe23 	bl	801f3b0 <traceIF_itmPrint>
 800f76a:	4638      	mov	r0, r7
 800f76c:	f00f fddd 	bl	801f32a <crs_strlen>
 800f770:	b283      	uxth	r3, r0
 800f772:	463a      	mov	r2, r7
 800f774:	2101      	movs	r1, #1
 800f776:	2002      	movs	r0, #2
 800f778:	f00f fe3c 	bl	801f3f4 <traceIF_uartPrint>
 800f77c:	e7df      	b.n	800f73e <fCmdBuild_CGDATA+0x7e>
 800f77e:	bf00      	nop
 800f780:	0802f668 	.word	0x0802f668
 800f784:	200048dc 	.word	0x200048dc
 800f788:	0802f690 	.word	0x0802f690
 800f78c:	0802f614 	.word	0x0802f614

0800f790 <fCmdBuild_CGPADDR>:

at_status_t fCmdBuild_CGPADDR(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f792:	4606      	mov	r6, r0
 800f794:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CGPADDR()")
 800f796:	4c2f      	ldr	r4, [pc, #188]	; (800f854 <fCmdBuild_CGPADDR+0xc4>)
 800f798:	4d2f      	ldr	r5, [pc, #188]	; (800f858 <fCmdBuild_CGPADDR+0xc8>)
 800f79a:	f104 0e20 	add.w	lr, r4, #32
 800f79e:	46a4      	mov	ip, r4
 800f7a0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f7a4:	6028      	str	r0, [r5, #0]
 800f7a6:	6069      	str	r1, [r5, #4]
 800f7a8:	60aa      	str	r2, [r5, #8]
 800f7aa:	60eb      	str	r3, [r5, #12]
 800f7ac:	4664      	mov	r4, ip
 800f7ae:	3510      	adds	r5, #16
 800f7b0:	45f4      	cmp	ip, lr
 800f7b2:	d1f4      	bne.n	800f79e <fCmdBuild_CGPADDR+0xe>
 800f7b4:	cc03      	ldmia	r4!, {r0, r1}
 800f7b6:	6028      	str	r0, [r5, #0]
 800f7b8:	6069      	str	r1, [r5, #4]
 800f7ba:	7823      	ldrb	r3, [r4, #0]
 800f7bc:	722b      	strb	r3, [r5, #8]
 800f7be:	4c26      	ldr	r4, [pc, #152]	; (800f858 <fCmdBuild_CGPADDR+0xc8>)
 800f7c0:	4620      	mov	r0, r4
 800f7c2:	f00f fdb2 	bl	801f32a <crs_strlen>
 800f7c6:	b283      	uxth	r3, r0
 800f7c8:	4622      	mov	r2, r4
 800f7ca:	2104      	movs	r1, #4
 800f7cc:	2002      	movs	r0, #2
 800f7ce:	f00f fdef 	bl	801f3b0 <traceIF_itmPrint>
 800f7d2:	4620      	mov	r0, r4
 800f7d4:	f00f fda9 	bl	801f32a <crs_strlen>
 800f7d8:	b283      	uxth	r3, r0
 800f7da:	4622      	mov	r2, r4
 800f7dc:	2104      	movs	r1, #4
 800f7de:	2002      	movs	r0, #2
 800f7e0:	f00f fe08 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800f7e4:	8933      	ldrh	r3, [r6, #8]
 800f7e6:	2b03      	cmp	r3, #3
 800f7e8:	d001      	beq.n	800f7ee <fCmdBuild_CGPADDR+0x5e>
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", modem_cid);
  }

  return (retval);
}
 800f7ea:	2000      	movs	r0, #0
 800f7ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CS_PDN_conf_id_t current_conf_id = atcm_get_cid_current_SID(p_modem_ctxt);
 800f7ee:	4638      	mov	r0, r7
 800f7f0:	f7fd f860 	bl	800c8b4 <atcm_get_cid_current_SID>
 800f7f4:	4604      	mov	r4, r0
    uint8_t modem_cid = atcm_get_affected_modem_cid(&p_modem_ctxt->persist, current_conf_id);
 800f7f6:	4601      	mov	r1, r0
 800f7f8:	f107 000c 	add.w	r0, r7, #12
 800f7fc:	f7fe f8e2 	bl	800d9c4 <atcm_get_affected_modem_cid>
 800f800:	4605      	mov	r5, r0
    if (p_modem_ctxt->persist.pdp_ctxt_infos[current_conf_id].conf_id == CS_PDN_NOT_DEFINED)
 800f802:	eb04 1384 	add.w	r3, r4, r4, lsl #6
 800f806:	eb07 0743 	add.w	r7, r7, r3, lsl #1
 800f80a:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 800f80e:	2b0c      	cmp	r3, #12
 800f810:	d006      	beq.n	800f820 <fCmdBuild_CGPADDR+0x90>
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d", modem_cid);
 800f812:	462a      	mov	r2, r5
 800f814:	4911      	ldr	r1, [pc, #68]	; (800f85c <fCmdBuild_CGPADDR+0xcc>)
 800f816:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800f81a:	f017 f815 	bl	8026848 <sprintf>
 800f81e:	e7e4      	b.n	800f7ea <fCmdBuild_CGPADDR+0x5a>
      PRINT_INFO("PDP context not explicitly defined for conf_id %d (using modem params)", current_conf_id)
 800f820:	4f0d      	ldr	r7, [pc, #52]	; (800f858 <fCmdBuild_CGPADDR+0xc8>)
 800f822:	4622      	mov	r2, r4
 800f824:	490e      	ldr	r1, [pc, #56]	; (800f860 <fCmdBuild_CGPADDR+0xd0>)
 800f826:	4638      	mov	r0, r7
 800f828:	f017 f80e 	bl	8026848 <sprintf>
 800f82c:	4638      	mov	r0, r7
 800f82e:	f00f fd7c 	bl	801f32a <crs_strlen>
 800f832:	b283      	uxth	r3, r0
 800f834:	463a      	mov	r2, r7
 800f836:	2101      	movs	r1, #1
 800f838:	2002      	movs	r0, #2
 800f83a:	f00f fdb9 	bl	801f3b0 <traceIF_itmPrint>
 800f83e:	4638      	mov	r0, r7
 800f840:	f00f fd73 	bl	801f32a <crs_strlen>
 800f844:	b283      	uxth	r3, r0
 800f846:	463a      	mov	r2, r7
 800f848:	2101      	movs	r1, #1
 800f84a:	2002      	movs	r0, #2
 800f84c:	f00f fdd2 	bl	801f3f4 <traceIF_uartPrint>
 800f850:	e7df      	b.n	800f812 <fCmdBuild_CGPADDR+0x82>
 800f852:	bf00      	nop
 800f854:	0802f69c 	.word	0x0802f69c
 800f858:	200048dc 	.word	0x200048dc
 800f85c:	0802f40c 	.word	0x0802f40c
 800f860:	0802f614 	.word	0x0802f614

0800f864 <fCmdBuild_ATE>:
  }
  return (retval);
}

at_status_t fCmdBuild_ATE(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f864:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f866:	4606      	mov	r6, r0
 800f868:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATE()")
 800f86a:	4d1c      	ldr	r5, [pc, #112]	; (800f8dc <fCmdBuild_ATE+0x78>)
 800f86c:	4c1c      	ldr	r4, [pc, #112]	; (800f8e0 <fCmdBuild_ATE+0x7c>)
 800f86e:	f105 0e20 	add.w	lr, r5, #32
 800f872:	46ac      	mov	ip, r5
 800f874:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f878:	6020      	str	r0, [r4, #0]
 800f87a:	6061      	str	r1, [r4, #4]
 800f87c:	60a2      	str	r2, [r4, #8]
 800f87e:	60e3      	str	r3, [r4, #12]
 800f880:	4665      	mov	r5, ip
 800f882:	3410      	adds	r4, #16
 800f884:	45f4      	cmp	ip, lr
 800f886:	d1f4      	bne.n	800f872 <fCmdBuild_ATE+0xe>
 800f888:	f8dc 0000 	ldr.w	r0, [ip]
 800f88c:	6020      	str	r0, [r4, #0]
 800f88e:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800f892:	7123      	strb	r3, [r4, #4]
 800f894:	4c12      	ldr	r4, [pc, #72]	; (800f8e0 <fCmdBuild_ATE+0x7c>)
 800f896:	4620      	mov	r0, r4
 800f898:	f00f fd47 	bl	801f32a <crs_strlen>
 800f89c:	b283      	uxth	r3, r0
 800f89e:	4622      	mov	r2, r4
 800f8a0:	2104      	movs	r1, #4
 800f8a2:	2002      	movs	r0, #2
 800f8a4:	f00f fd84 	bl	801f3b0 <traceIF_itmPrint>
 800f8a8:	4620      	mov	r0, r4
 800f8aa:	f00f fd3e 	bl	801f32a <crs_strlen>
 800f8ae:	b283      	uxth	r3, r0
 800f8b0:	4622      	mov	r2, r4
 800f8b2:	2104      	movs	r1, #4
 800f8b4:	2002      	movs	r0, #2
 800f8b6:	f00f fd9d 	bl	801f3f4 <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800f8ba:	8933      	ldrh	r3, [r6, #8]
 800f8bc:	2b04      	cmp	r3, #4
 800f8be:	d001      	beq.n	800f8c4 <fCmdBuild_ATE+0x60>
    {
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
    }
  }
  return (retval);
}
 800f8c0:	2000      	movs	r0, #0
 800f8c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->CMD_ctxt.command_echo == AT_TRUE)
 800f8c4:	f897 372f 	ldrb.w	r3, [r7, #1839]	; 0x72f
 800f8c8:	b11b      	cbz	r3, 800f8d2 <fCmdBuild_ATE+0x6e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f8ca:	4b06      	ldr	r3, [pc, #24]	; (800f8e4 <fCmdBuild_ATE+0x80>)
 800f8cc:	881b      	ldrh	r3, [r3, #0]
 800f8ce:	8633      	strh	r3, [r6, #48]	; 0x30
 800f8d0:	e7f6      	b.n	800f8c0 <fCmdBuild_ATE+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f8d2:	4b05      	ldr	r3, [pc, #20]	; (800f8e8 <fCmdBuild_ATE+0x84>)
 800f8d4:	881b      	ldrh	r3, [r3, #0]
 800f8d6:	8633      	strh	r3, [r6, #48]	; 0x30
 800f8d8:	e7f2      	b.n	800f8c0 <fCmdBuild_ATE+0x5c>
 800f8da:	bf00      	nop
 800f8dc:	0802f6c8 	.word	0x0802f6c8
 800f8e0:	200048dc 	.word	0x200048dc
 800f8e4:	080342a4 	.word	0x080342a4
 800f8e8:	080342b8 	.word	0x080342b8

0800f8ec <fCmdBuild_ATV>:

at_status_t fCmdBuild_ATV(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f8ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f8ee:	4606      	mov	r6, r0
 800f8f0:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATV()")
 800f8f2:	4d1c      	ldr	r5, [pc, #112]	; (800f964 <fCmdBuild_ATV+0x78>)
 800f8f4:	4c1c      	ldr	r4, [pc, #112]	; (800f968 <fCmdBuild_ATV+0x7c>)
 800f8f6:	f105 0e20 	add.w	lr, r5, #32
 800f8fa:	46ac      	mov	ip, r5
 800f8fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f900:	6020      	str	r0, [r4, #0]
 800f902:	6061      	str	r1, [r4, #4]
 800f904:	60a2      	str	r2, [r4, #8]
 800f906:	60e3      	str	r3, [r4, #12]
 800f908:	4665      	mov	r5, ip
 800f90a:	3410      	adds	r4, #16
 800f90c:	45f4      	cmp	ip, lr
 800f90e:	d1f4      	bne.n	800f8fa <fCmdBuild_ATV+0xe>
 800f910:	f8dc 0000 	ldr.w	r0, [ip]
 800f914:	6020      	str	r0, [r4, #0]
 800f916:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800f91a:	7123      	strb	r3, [r4, #4]
 800f91c:	4c12      	ldr	r4, [pc, #72]	; (800f968 <fCmdBuild_ATV+0x7c>)
 800f91e:	4620      	mov	r0, r4
 800f920:	f00f fd03 	bl	801f32a <crs_strlen>
 800f924:	b283      	uxth	r3, r0
 800f926:	4622      	mov	r2, r4
 800f928:	2104      	movs	r1, #4
 800f92a:	2002      	movs	r0, #2
 800f92c:	f00f fd40 	bl	801f3b0 <traceIF_itmPrint>
 800f930:	4620      	mov	r0, r4
 800f932:	f00f fcfa 	bl	801f32a <crs_strlen>
 800f936:	b283      	uxth	r3, r0
 800f938:	4622      	mov	r2, r4
 800f93a:	2104      	movs	r1, #4
 800f93c:	2002      	movs	r0, #2
 800f93e:	f00f fd59 	bl	801f3f4 <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800f942:	8933      	ldrh	r3, [r6, #8]
 800f944:	2b04      	cmp	r3, #4
 800f946:	d001      	beq.n	800f94c <fCmdBuild_ATV+0x60>
    {
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
    }
  }
  return (retval);
}
 800f948:	2000      	movs	r0, #0
 800f94a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->CMD_ctxt.dce_full_resp_format == AT_TRUE)
 800f94c:	f897 3730 	ldrb.w	r3, [r7, #1840]	; 0x730
 800f950:	b11b      	cbz	r3, 800f95a <fCmdBuild_ATV+0x6e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "1");
 800f952:	4b06      	ldr	r3, [pc, #24]	; (800f96c <fCmdBuild_ATV+0x80>)
 800f954:	881b      	ldrh	r3, [r3, #0]
 800f956:	8633      	strh	r3, [r6, #48]	; 0x30
 800f958:	e7f6      	b.n	800f948 <fCmdBuild_ATV+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f95a:	4b05      	ldr	r3, [pc, #20]	; (800f970 <fCmdBuild_ATV+0x84>)
 800f95c:	881b      	ldrh	r3, [r3, #0]
 800f95e:	8633      	strh	r3, [r6, #48]	; 0x30
 800f960:	e7f2      	b.n	800f948 <fCmdBuild_ATV+0x5c>
 800f962:	bf00      	nop
 800f964:	0802f6f0 	.word	0x0802f6f0
 800f968:	200048dc 	.word	0x200048dc
 800f96c:	080342a4 	.word	0x080342a4
 800f970:	080342b8 	.word	0x080342b8

0800f974 <fCmdBuild_ATX>:

at_status_t fCmdBuild_ATX(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f974:	b570      	push	{r4, r5, r6, lr}
 800f976:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ATX()")
 800f978:	4d18      	ldr	r5, [pc, #96]	; (800f9dc <fCmdBuild_ATX+0x68>)
 800f97a:	4c19      	ldr	r4, [pc, #100]	; (800f9e0 <fCmdBuild_ATX+0x6c>)
 800f97c:	f105 0e20 	add.w	lr, r5, #32
 800f980:	46ac      	mov	ip, r5
 800f982:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f986:	6020      	str	r0, [r4, #0]
 800f988:	6061      	str	r1, [r4, #4]
 800f98a:	60a2      	str	r2, [r4, #8]
 800f98c:	60e3      	str	r3, [r4, #12]
 800f98e:	4665      	mov	r5, ip
 800f990:	3410      	adds	r4, #16
 800f992:	45f4      	cmp	ip, lr
 800f994:	d1f4      	bne.n	800f980 <fCmdBuild_ATX+0xc>
 800f996:	f8dc 0000 	ldr.w	r0, [ip]
 800f99a:	6020      	str	r0, [r4, #0]
 800f99c:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800f9a0:	7123      	strb	r3, [r4, #4]
 800f9a2:	4c0f      	ldr	r4, [pc, #60]	; (800f9e0 <fCmdBuild_ATX+0x6c>)
 800f9a4:	4620      	mov	r0, r4
 800f9a6:	f00f fcc0 	bl	801f32a <crs_strlen>
 800f9aa:	b283      	uxth	r3, r0
 800f9ac:	4622      	mov	r2, r4
 800f9ae:	2104      	movs	r1, #4
 800f9b0:	2002      	movs	r0, #2
 800f9b2:	f00f fcfd 	bl	801f3b0 <traceIF_itmPrint>
 800f9b6:	4620      	mov	r0, r4
 800f9b8:	f00f fcb7 	bl	801f32a <crs_strlen>
 800f9bc:	b283      	uxth	r3, r0
 800f9be:	4622      	mov	r2, r4
 800f9c0:	2104      	movs	r1, #4
 800f9c2:	2002      	movs	r0, #2
 800f9c4:	f00f fd16 	bl	801f3f4 <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800f9c8:	8933      	ldrh	r3, [r6, #8]
 800f9ca:	2b04      	cmp	r3, #4
 800f9cc:	d001      	beq.n	800f9d2 <fCmdBuild_ATX+0x5e>
      *  for the moment, ATX0 to return result code only, dial tone and busy detection are both disabled
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
  }
  return (retval);
}
 800f9ce:	2000      	movs	r0, #0
 800f9d0:	bd70      	pop	{r4, r5, r6, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800f9d2:	4b04      	ldr	r3, [pc, #16]	; (800f9e4 <fCmdBuild_ATX+0x70>)
 800f9d4:	881b      	ldrh	r3, [r3, #0]
 800f9d6:	8633      	strh	r3, [r6, #48]	; 0x30
 800f9d8:	e7f9      	b.n	800f9ce <fCmdBuild_ATX+0x5a>
 800f9da:	bf00      	nop
 800f9dc:	0802f718 	.word	0x0802f718
 800f9e0:	200048dc 	.word	0x200048dc
 800f9e4:	080342b8 	.word	0x080342b8

0800f9e8 <fCmdBuild_IPR>:
  }
  return (retval);
}

at_status_t fCmdBuild_IPR(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800f9e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f9ea:	4606      	mov	r6, r0
 800f9ec:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_IPR()")
 800f9ee:	4d1a      	ldr	r5, [pc, #104]	; (800fa58 <fCmdBuild_IPR+0x70>)
 800f9f0:	4c1a      	ldr	r4, [pc, #104]	; (800fa5c <fCmdBuild_IPR+0x74>)
 800f9f2:	f105 0e20 	add.w	lr, r5, #32
 800f9f6:	46ac      	mov	ip, r5
 800f9f8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800f9fc:	6020      	str	r0, [r4, #0]
 800f9fe:	6061      	str	r1, [r4, #4]
 800fa00:	60a2      	str	r2, [r4, #8]
 800fa02:	60e3      	str	r3, [r4, #12]
 800fa04:	4665      	mov	r5, ip
 800fa06:	3410      	adds	r4, #16
 800fa08:	45f4      	cmp	ip, lr
 800fa0a:	d1f4      	bne.n	800f9f6 <fCmdBuild_IPR+0xe>
 800fa0c:	f8dc 0000 	ldr.w	r0, [ip]
 800fa10:	6020      	str	r0, [r4, #0]
 800fa12:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800fa16:	7123      	strb	r3, [r4, #4]
 800fa18:	4c10      	ldr	r4, [pc, #64]	; (800fa5c <fCmdBuild_IPR+0x74>)
 800fa1a:	4620      	mov	r0, r4
 800fa1c:	f00f fc85 	bl	801f32a <crs_strlen>
 800fa20:	b283      	uxth	r3, r0
 800fa22:	4622      	mov	r2, r4
 800fa24:	2104      	movs	r1, #4
 800fa26:	2002      	movs	r0, #2
 800fa28:	f00f fcc2 	bl	801f3b0 <traceIF_itmPrint>
 800fa2c:	4620      	mov	r0, r4
 800fa2e:	f00f fc7c 	bl	801f32a <crs_strlen>
 800fa32:	b283      	uxth	r3, r0
 800fa34:	4622      	mov	r2, r4
 800fa36:	2104      	movs	r1, #4
 800fa38:	2002      	movs	r0, #2
 800fa3a:	f00f fcdb 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800fa3e:	8933      	ldrh	r3, [r6, #8]
 800fa40:	2b03      	cmp	r3, #3
 800fa42:	d001      	beq.n	800fa48 <fCmdBuild_IPR+0x60>
  {
    /* set baud rate */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%ld", p_modem_ctxt->CMD_ctxt.baud_rate);
  }
  return (retval);
}
 800fa44:	2000      	movs	r0, #0
 800fa46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%ld", p_modem_ctxt->CMD_ctxt.baud_rate);
 800fa48:	f8d7 2738 	ldr.w	r2, [r7, #1848]	; 0x738
 800fa4c:	4904      	ldr	r1, [pc, #16]	; (800fa60 <fCmdBuild_IPR+0x78>)
 800fa4e:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800fa52:	f016 fef9 	bl	8026848 <sprintf>
 800fa56:	e7f5      	b.n	800fa44 <fCmdBuild_IPR+0x5c>
 800fa58:	0802f740 	.word	0x0802f740
 800fa5c:	200048dc 	.word	0x200048dc
 800fa60:	0802f768 	.word	0x0802f768

0800fa64 <fCmdBuild_IFC>:

at_status_t fCmdBuild_IFC(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fa64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800fa66:	4606      	mov	r6, r0
 800fa68:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_IFC()")
 800fa6a:	4d1c      	ldr	r5, [pc, #112]	; (800fadc <fCmdBuild_IFC+0x78>)
 800fa6c:	4c1c      	ldr	r4, [pc, #112]	; (800fae0 <fCmdBuild_IFC+0x7c>)
 800fa6e:	f105 0e20 	add.w	lr, r5, #32
 800fa72:	46ac      	mov	ip, r5
 800fa74:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fa78:	6020      	str	r0, [r4, #0]
 800fa7a:	6061      	str	r1, [r4, #4]
 800fa7c:	60a2      	str	r2, [r4, #8]
 800fa7e:	60e3      	str	r3, [r4, #12]
 800fa80:	4665      	mov	r5, ip
 800fa82:	3410      	adds	r4, #16
 800fa84:	45f4      	cmp	ip, lr
 800fa86:	d1f4      	bne.n	800fa72 <fCmdBuild_IFC+0xe>
 800fa88:	f8dc 0000 	ldr.w	r0, [ip]
 800fa8c:	6020      	str	r0, [r4, #0]
 800fa8e:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800fa92:	7123      	strb	r3, [r4, #4]
 800fa94:	4c12      	ldr	r4, [pc, #72]	; (800fae0 <fCmdBuild_IFC+0x7c>)
 800fa96:	4620      	mov	r0, r4
 800fa98:	f00f fc47 	bl	801f32a <crs_strlen>
 800fa9c:	b283      	uxth	r3, r0
 800fa9e:	4622      	mov	r2, r4
 800faa0:	2104      	movs	r1, #4
 800faa2:	2002      	movs	r0, #2
 800faa4:	f00f fc84 	bl	801f3b0 <traceIF_itmPrint>
 800faa8:	4620      	mov	r0, r4
 800faaa:	f00f fc3e 	bl	801f32a <crs_strlen>
 800faae:	b283      	uxth	r3, r0
 800fab0:	4622      	mov	r2, r4
 800fab2:	2104      	movs	r1, #4
 800fab4:	2002      	movs	r0, #2
 800fab6:	f00f fc9d 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800faba:	8933      	ldrh	r3, [r6, #8]
 800fabc:	2b03      	cmp	r3, #3
 800fabe:	d001      	beq.n	800fac4 <fCmdBuild_IFC+0x60>
      /* CTS/RTS activated */
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "2,2");
    }
  }
  return (retval);
}
 800fac0:	2000      	movs	r0, #0
 800fac2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->CMD_ctxt.flow_control_cts_rts == AT_FALSE)
 800fac4:	f897 373c 	ldrb.w	r3, [r7, #1852]	; 0x73c
 800fac8:	b91b      	cbnz	r3, 800fad2 <fCmdBuild_IFC+0x6e>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0,0");
 800faca:	4b06      	ldr	r3, [pc, #24]	; (800fae4 <fCmdBuild_IFC+0x80>)
 800facc:	6818      	ldr	r0, [r3, #0]
 800face:	6330      	str	r0, [r6, #48]	; 0x30
 800fad0:	e7f6      	b.n	800fac0 <fCmdBuild_IFC+0x5c>
      (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "2,2");
 800fad2:	4b05      	ldr	r3, [pc, #20]	; (800fae8 <fCmdBuild_IFC+0x84>)
 800fad4:	6818      	ldr	r0, [r3, #0]
 800fad6:	6330      	str	r0, [r6, #48]	; 0x30
 800fad8:	e7f2      	b.n	800fac0 <fCmdBuild_IFC+0x5c>
 800fada:	bf00      	nop
 800fadc:	0802f76c 	.word	0x0802f76c
 800fae0:	200048dc 	.word	0x200048dc
 800fae4:	0802f794 	.word	0x0802f794
 800fae8:	0802f798 	.word	0x0802f798

0800faec <fCmdBuild_ESCAPE_CMD>:

at_status_t fCmdBuild_ESCAPE_CMD(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800faec:	b570      	push	{r4, r5, r6, lr}
 800faee:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_ESCAPE_CMD()")
 800faf0:	4c1c      	ldr	r4, [pc, #112]	; (800fb64 <fCmdBuild_ESCAPE_CMD+0x78>)
 800faf2:	4d1d      	ldr	r5, [pc, #116]	; (800fb68 <fCmdBuild_ESCAPE_CMD+0x7c>)
 800faf4:	f104 0e20 	add.w	lr, r4, #32
 800faf8:	46a4      	mov	ip, r4
 800fafa:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fafe:	6028      	str	r0, [r5, #0]
 800fb00:	6069      	str	r1, [r5, #4]
 800fb02:	60aa      	str	r2, [r5, #8]
 800fb04:	60eb      	str	r3, [r5, #12]
 800fb06:	4664      	mov	r4, ip
 800fb08:	3510      	adds	r5, #16
 800fb0a:	45f4      	cmp	ip, lr
 800fb0c:	d1f4      	bne.n	800faf8 <fCmdBuild_ESCAPE_CMD+0xc>
 800fb0e:	cc07      	ldmia	r4!, {r0, r1, r2}
 800fb10:	6028      	str	r0, [r5, #0]
 800fb12:	6069      	str	r1, [r5, #4]
 800fb14:	60aa      	str	r2, [r5, #8]
 800fb16:	4c14      	ldr	r4, [pc, #80]	; (800fb68 <fCmdBuild_ESCAPE_CMD+0x7c>)
 800fb18:	4620      	mov	r0, r4
 800fb1a:	f00f fc06 	bl	801f32a <crs_strlen>
 800fb1e:	b283      	uxth	r3, r0
 800fb20:	4622      	mov	r2, r4
 800fb22:	2104      	movs	r1, #4
 800fb24:	2002      	movs	r0, #2
 800fb26:	f00f fc43 	bl	801f3b0 <traceIF_itmPrint>
 800fb2a:	4620      	mov	r0, r4
 800fb2c:	f00f fbfd 	bl	801f32a <crs_strlen>
 800fb30:	b283      	uxth	r3, r0
 800fb32:	4622      	mov	r2, r4
 800fb34:	2104      	movs	r1, #4
 800fb36:	2002      	movs	r0, #2
 800fb38:	f00f fc5c 	bl	801f3f4 <traceIF_uartPrint>

  /* only for RAW command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD)
 800fb3c:	8933      	ldrh	r3, [r6, #8]
 800fb3e:	2b06      	cmp	r3, #6
 800fb40:	d001      	beq.n	800fb46 <fCmdBuild_ESCAPE_CMD+0x5a>
    /* set raw command size */
    p_atp_ctxt->current_atcmd.raw_cmd_size = strlen((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params);
  }
  else
  {
    retval = ATSTATUS_ERROR;
 800fb42:	2001      	movs	r0, #1
  }
  return (retval);
}
 800fb44:	bd70      	pop	{r4, r5, r6, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%s", p_atp_ctxt->current_atcmd.name);
 800fb46:	f106 0430 	add.w	r4, r6, #48	; 0x30
 800fb4a:	f106 0110 	add.w	r1, r6, #16
 800fb4e:	4620      	mov	r0, r4
 800fb50:	f016 ffc2 	bl	8026ad8 <strcpy>
    p_atp_ctxt->current_atcmd.raw_cmd_size = strlen((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params);
 800fb54:	4620      	mov	r0, r4
 800fb56:	f7f0 fb4d 	bl	80001f4 <strlen>
 800fb5a:	f8c6 0670 	str.w	r0, [r6, #1648]	; 0x670
  at_status_t retval = ATSTATUS_OK;
 800fb5e:	2000      	movs	r0, #0
 800fb60:	e7f0      	b.n	800fb44 <fCmdBuild_ESCAPE_CMD+0x58>
 800fb62:	bf00      	nop
 800fb64:	0802f79c 	.word	0x0802f79c
 800fb68:	200048dc 	.word	0x200048dc

0800fb6c <fCmdBuild_AT_AND_D>:

at_status_t fCmdBuild_AT_AND_D(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fb6c:	b570      	push	{r4, r5, r6, lr}
 800fb6e:	4606      	mov	r6, r0
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_AT_AND_D()")
 800fb70:	4c17      	ldr	r4, [pc, #92]	; (800fbd0 <fCmdBuild_AT_AND_D+0x64>)
 800fb72:	4d18      	ldr	r5, [pc, #96]	; (800fbd4 <fCmdBuild_AT_AND_D+0x68>)
 800fb74:	f104 0e20 	add.w	lr, r4, #32
 800fb78:	46a4      	mov	ip, r4
 800fb7a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fb7e:	6028      	str	r0, [r5, #0]
 800fb80:	6069      	str	r1, [r5, #4]
 800fb82:	60aa      	str	r2, [r5, #8]
 800fb84:	60eb      	str	r3, [r5, #12]
 800fb86:	4664      	mov	r4, ip
 800fb88:	3510      	adds	r5, #16
 800fb8a:	45f4      	cmp	ip, lr
 800fb8c:	d1f4      	bne.n	800fb78 <fCmdBuild_AT_AND_D+0xc>
 800fb8e:	cc03      	ldmia	r4!, {r0, r1}
 800fb90:	6028      	str	r0, [r5, #0]
 800fb92:	6069      	str	r1, [r5, #4]
 800fb94:	8823      	ldrh	r3, [r4, #0]
 800fb96:	812b      	strh	r3, [r5, #8]
 800fb98:	4c0e      	ldr	r4, [pc, #56]	; (800fbd4 <fCmdBuild_AT_AND_D+0x68>)
 800fb9a:	4620      	mov	r0, r4
 800fb9c:	f00f fbc5 	bl	801f32a <crs_strlen>
 800fba0:	b283      	uxth	r3, r0
 800fba2:	4622      	mov	r2, r4
 800fba4:	2104      	movs	r1, #4
 800fba6:	2002      	movs	r0, #2
 800fba8:	f00f fc02 	bl	801f3b0 <traceIF_itmPrint>
 800fbac:	4620      	mov	r0, r4
 800fbae:	f00f fbbc 	bl	801f32a <crs_strlen>
 800fbb2:	b283      	uxth	r3, r0
 800fbb4:	4622      	mov	r2, r4
 800fbb6:	2104      	movs	r1, #4
 800fbb8:	2002      	movs	r0, #2
 800fbba:	f00f fc1b 	bl	801f3f4 <traceIF_uartPrint>

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 800fbbe:	8933      	ldrh	r3, [r6, #8]
 800fbc0:	2b04      	cmp	r3, #4
 800fbc2:	d001      	beq.n	800fbc8 <fCmdBuild_AT_AND_D+0x5c>
      */
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
  }

  return (retval);
}
 800fbc4:	2000      	movs	r0, #0
 800fbc6:	bd70      	pop	{r4, r5, r6, pc}
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800fbc8:	4b03      	ldr	r3, [pc, #12]	; (800fbd8 <fCmdBuild_AT_AND_D+0x6c>)
 800fbca:	881b      	ldrh	r3, [r3, #0]
 800fbcc:	8633      	strh	r3, [r6, #48]	; 0x30
 800fbce:	e7f9      	b.n	800fbc4 <fCmdBuild_AT_AND_D+0x58>
 800fbd0:	0802f7c8 	.word	0x0802f7c8
 800fbd4:	200048dc 	.word	0x200048dc
 800fbd8:	080342b8 	.word	0x080342b8

0800fbdc <fCmdBuild_CPSMS>:

at_status_t fCmdBuild_CPSMS(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fbdc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fbde:	b08f      	sub	sp, #60	; 0x3c
 800fbe0:	4607      	mov	r7, r0
 800fbe2:	460e      	mov	r6, r1
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CPSMS()")
 800fbe4:	4d61      	ldr	r5, [pc, #388]	; (800fd6c <fCmdBuild_CPSMS+0x190>)
 800fbe6:	4c62      	ldr	r4, [pc, #392]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fbe8:	f105 0e20 	add.w	lr, r5, #32
 800fbec:	46ac      	mov	ip, r5
 800fbee:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fbf2:	6020      	str	r0, [r4, #0]
 800fbf4:	6061      	str	r1, [r4, #4]
 800fbf6:	60a2      	str	r2, [r4, #8]
 800fbf8:	60e3      	str	r3, [r4, #12]
 800fbfa:	4665      	mov	r5, ip
 800fbfc:	3410      	adds	r4, #16
 800fbfe:	45f4      	cmp	ip, lr
 800fc00:	d1f4      	bne.n	800fbec <fCmdBuild_CPSMS+0x10>
 800fc02:	f8dc 0000 	ldr.w	r0, [ip]
 800fc06:	6020      	str	r0, [r4, #0]
 800fc08:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 800fc0c:	f89c 3006 	ldrb.w	r3, [ip, #6]
 800fc10:	80a2      	strh	r2, [r4, #4]
 800fc12:	71a3      	strb	r3, [r4, #6]
 800fc14:	4c56      	ldr	r4, [pc, #344]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fc16:	4620      	mov	r0, r4
 800fc18:	f00f fb87 	bl	801f32a <crs_strlen>
 800fc1c:	b283      	uxth	r3, r0
 800fc1e:	4622      	mov	r2, r4
 800fc20:	2104      	movs	r1, #4
 800fc22:	2002      	movs	r0, #2
 800fc24:	f00f fbc4 	bl	801f3b0 <traceIF_itmPrint>
 800fc28:	4620      	mov	r0, r4
 800fc2a:	f00f fb7e 	bl	801f32a <crs_strlen>
 800fc2e:	b283      	uxth	r3, r0
 800fc30:	4622      	mov	r2, r4
 800fc32:	2104      	movs	r1, #4
 800fc34:	2002      	movs	r0, #2
 800fc36:	f00f fbdd 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800fc3a:	893b      	ldrh	r3, [r7, #8]
 800fc3c:	2b03      	cmp	r3, #3
 800fc3e:	d027      	beq.n	800fc90 <fCmdBuild_CPSMS+0xb4>
      atcm_program_SKIP_CMD(p_atp_ctxt);
    }
  }
  else
  {
    PRINT_ERR("invalid pointer to PSM parameters")
 800fc40:	4e4c      	ldr	r6, [pc, #304]	; (800fd74 <fCmdBuild_CPSMS+0x198>)
 800fc42:	4c4b      	ldr	r4, [pc, #300]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fc44:	f106 0730 	add.w	r7, r6, #48	; 0x30
 800fc48:	4635      	mov	r5, r6
 800fc4a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fc4c:	6020      	str	r0, [r4, #0]
 800fc4e:	6061      	str	r1, [r4, #4]
 800fc50:	60a2      	str	r2, [r4, #8]
 800fc52:	60e3      	str	r3, [r4, #12]
 800fc54:	462e      	mov	r6, r5
 800fc56:	3410      	adds	r4, #16
 800fc58:	42bd      	cmp	r5, r7
 800fc5a:	d1f5      	bne.n	800fc48 <fCmdBuild_CPSMS+0x6c>
 800fc5c:	882a      	ldrh	r2, [r5, #0]
 800fc5e:	78ab      	ldrb	r3, [r5, #2]
 800fc60:	8022      	strh	r2, [r4, #0]
 800fc62:	70a3      	strb	r3, [r4, #2]
 800fc64:	4c42      	ldr	r4, [pc, #264]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fc66:	4620      	mov	r0, r4
 800fc68:	f00f fb5f 	bl	801f32a <crs_strlen>
 800fc6c:	b283      	uxth	r3, r0
 800fc6e:	4622      	mov	r2, r4
 800fc70:	2110      	movs	r1, #16
 800fc72:	2002      	movs	r0, #2
 800fc74:	f00f fb9c 	bl	801f3b0 <traceIF_itmPrint>
 800fc78:	4620      	mov	r0, r4
 800fc7a:	f00f fb56 	bl	801f32a <crs_strlen>
 800fc7e:	b283      	uxth	r3, r0
 800fc80:	4622      	mov	r2, r4
 800fc82:	2110      	movs	r1, #16
 800fc84:	2002      	movs	r0, #2
 800fc86:	f00f fbb5 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800fc8a:	2001      	movs	r0, #1
  }

  return (retval);
}
 800fc8c:	b00f      	add	sp, #60	; 0x3c
 800fc8e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t req_periodic_rau[9] = {0U};
 800fc90:	2300      	movs	r3, #0
 800fc92:	9302      	str	r3, [sp, #8]
 800fc94:	9303      	str	r3, [sp, #12]
 800fc96:	f88d 3010 	strb.w	r3, [sp, #16]
    uint8_t req_gprs_ready_time[9] = {0U};
 800fc9a:	9305      	str	r3, [sp, #20]
 800fc9c:	9306      	str	r3, [sp, #24]
 800fc9e:	f88d 301c 	strb.w	r3, [sp, #28]
    uint8_t req_periodic_tau[9] = {0U};
 800fca2:	9308      	str	r3, [sp, #32]
 800fca4:	9309      	str	r3, [sp, #36]	; 0x24
 800fca6:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    uint8_t req_active_time[9] = {0U};
 800fcaa:	930b      	str	r3, [sp, #44]	; 0x2c
 800fcac:	930c      	str	r3, [sp, #48]	; 0x30
 800fcae:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    (void)ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_periodic_RAU,
 800fcb2:	ab02      	add	r3, sp, #8
 800fcb4:	2209      	movs	r2, #9
 800fcb6:	2108      	movs	r1, #8
 800fcb8:	f896 0722 	ldrb.w	r0, [r6, #1826]	; 0x722
 800fcbc:	f005 f8dc 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    (void)ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_GPRS_READY_timer,
 800fcc0:	ab05      	add	r3, sp, #20
 800fcc2:	2209      	movs	r2, #9
 800fcc4:	2108      	movs	r1, #8
 800fcc6:	f896 0723 	ldrb.w	r0, [r6, #1827]	; 0x723
 800fcca:	f005 f8d5 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    (void) ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_periodic_TAU,
 800fcce:	ab08      	add	r3, sp, #32
 800fcd0:	2209      	movs	r2, #9
 800fcd2:	2108      	movs	r1, #8
 800fcd4:	f896 0724 	ldrb.w	r0, [r6, #1828]	; 0x724
 800fcd8:	f005 f8ce 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    (void) ATutil_convert_uint8_to_binary_string((uint32_t)p_psm_params->req_active_time,
 800fcdc:	ab0b      	add	r3, sp, #44	; 0x2c
 800fcde:	2209      	movs	r2, #9
 800fce0:	2108      	movs	r1, #8
 800fce2:	f896 0725 	ldrb.w	r0, [r6, #1829]	; 0x725
 800fce6:	f005 f8c7 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
    if (p_modem_ctxt->SID_ctxt.set_power_config.psm_present == CELLULAR_TRUE)
 800fcea:	f896 371f 	ldrb.w	r3, [r6, #1823]	; 0x71f
 800fcee:	2b01      	cmp	r3, #1
 800fcf0:	d113      	bne.n	800fd1a <fCmdBuild_CPSMS+0x13e>
      if (p_modem_ctxt->SID_ctxt.set_power_config.psm_mode == PSM_MODE_DISABLE)
 800fcf2:	f896 3721 	ldrb.w	r3, [r6, #1825]	; 0x721
 800fcf6:	b933      	cbnz	r3, 800fd06 <fCmdBuild_CPSMS+0x12a>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d",
 800fcf8:	2200      	movs	r2, #0
 800fcfa:	491f      	ldr	r1, [pc, #124]	; (800fd78 <fCmdBuild_CPSMS+0x19c>)
 800fcfc:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800fd00:	f016 fda2 	bl	8026848 <sprintf>
 800fd04:	e030      	b.n	800fd68 <fCmdBuild_CPSMS+0x18c>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,,,\"%s\",\"%s\"",
 800fd06:	ab0b      	add	r3, sp, #44	; 0x2c
 800fd08:	9300      	str	r3, [sp, #0]
 800fd0a:	ab08      	add	r3, sp, #32
 800fd0c:	2201      	movs	r2, #1
 800fd0e:	491b      	ldr	r1, [pc, #108]	; (800fd7c <fCmdBuild_CPSMS+0x1a0>)
 800fd10:	f107 0030 	add.w	r0, r7, #48	; 0x30
 800fd14:	f016 fd98 	bl	8026848 <sprintf>
 800fd18:	e026      	b.n	800fd68 <fCmdBuild_CPSMS+0x18c>
      PRINT_INFO("No PSM parameters available, command skipped")
 800fd1a:	4e19      	ldr	r6, [pc, #100]	; (800fd80 <fCmdBuild_CPSMS+0x1a4>)
 800fd1c:	4c14      	ldr	r4, [pc, #80]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fd1e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 800fd22:	4635      	mov	r5, r6
 800fd24:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800fd26:	6020      	str	r0, [r4, #0]
 800fd28:	6061      	str	r1, [r4, #4]
 800fd2a:	60a2      	str	r2, [r4, #8]
 800fd2c:	60e3      	str	r3, [r4, #12]
 800fd2e:	462e      	mov	r6, r5
 800fd30:	3410      	adds	r4, #16
 800fd32:	4565      	cmp	r5, ip
 800fd34:	d1f5      	bne.n	800fd22 <fCmdBuild_CPSMS+0x146>
 800fd36:	ce03      	ldmia	r6!, {r0, r1}
 800fd38:	6020      	str	r0, [r4, #0]
 800fd3a:	6061      	str	r1, [r4, #4]
 800fd3c:	4c0c      	ldr	r4, [pc, #48]	; (800fd70 <fCmdBuild_CPSMS+0x194>)
 800fd3e:	4620      	mov	r0, r4
 800fd40:	f00f faf3 	bl	801f32a <crs_strlen>
 800fd44:	b283      	uxth	r3, r0
 800fd46:	4622      	mov	r2, r4
 800fd48:	2101      	movs	r1, #1
 800fd4a:	2002      	movs	r0, #2
 800fd4c:	f00f fb30 	bl	801f3b0 <traceIF_itmPrint>
 800fd50:	4620      	mov	r0, r4
 800fd52:	f00f faea 	bl	801f32a <crs_strlen>
 800fd56:	b283      	uxth	r3, r0
 800fd58:	4622      	mov	r2, r4
 800fd5a:	2101      	movs	r1, #1
 800fd5c:	2002      	movs	r0, #2
 800fd5e:	f00f fb49 	bl	801f3f4 <traceIF_uartPrint>
      atcm_program_SKIP_CMD(p_atp_ctxt);
 800fd62:	4638      	mov	r0, r7
 800fd64:	f7fc fedc 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 800fd68:	2000      	movs	r0, #0
 800fd6a:	e78f      	b.n	800fc8c <fCmdBuild_CPSMS+0xb0>
 800fd6c:	0802f7f4 	.word	0x0802f7f4
 800fd70:	200048dc 	.word	0x200048dc
 800fd74:	0802f864 	.word	0x0802f864
 800fd78:	0802f40c 	.word	0x0802f40c
 800fd7c:	0802f81c 	.word	0x0802f81c
 800fd80:	0802f82c 	.word	0x0802f82c

0800fd84 <fCmdBuild_CEDRXS>:

at_status_t fCmdBuild_CEDRXS(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fd84:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fd86:	b085      	sub	sp, #20
 800fd88:	4606      	mov	r6, r0
 800fd8a:	460f      	mov	r7, r1
  UNUSED(p_modem_ctxt);

  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CEDRXS()")
 800fd8c:	4c52      	ldr	r4, [pc, #328]	; (800fed8 <fCmdBuild_CEDRXS+0x154>)
 800fd8e:	4d53      	ldr	r5, [pc, #332]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fd90:	f104 0e20 	add.w	lr, r4, #32
 800fd94:	46a4      	mov	ip, r4
 800fd96:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fd9a:	6028      	str	r0, [r5, #0]
 800fd9c:	6069      	str	r1, [r5, #4]
 800fd9e:	60aa      	str	r2, [r5, #8]
 800fda0:	60eb      	str	r3, [r5, #12]
 800fda2:	4664      	mov	r4, ip
 800fda4:	3510      	adds	r5, #16
 800fda6:	45f4      	cmp	ip, lr
 800fda8:	d1f4      	bne.n	800fd94 <fCmdBuild_CEDRXS+0x10>
 800fdaa:	cc03      	ldmia	r4!, {r0, r1}
 800fdac:	6028      	str	r0, [r5, #0]
 800fdae:	6069      	str	r1, [r5, #4]
 800fdb0:	4c4a      	ldr	r4, [pc, #296]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fdb2:	4620      	mov	r0, r4
 800fdb4:	f00f fab9 	bl	801f32a <crs_strlen>
 800fdb8:	b283      	uxth	r3, r0
 800fdba:	4622      	mov	r2, r4
 800fdbc:	2104      	movs	r1, #4
 800fdbe:	2002      	movs	r0, #2
 800fdc0:	f00f faf6 	bl	801f3b0 <traceIF_itmPrint>
 800fdc4:	4620      	mov	r0, r4
 800fdc6:	f00f fab0 	bl	801f32a <crs_strlen>
 800fdca:	b283      	uxth	r3, r0
 800fdcc:	4622      	mov	r2, r4
 800fdce:	2104      	movs	r1, #4
 800fdd0:	2002      	movs	r0, #2
 800fdd2:	f00f fb0f 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800fdd6:	8933      	ldrh	r3, [r6, #8]
 800fdd8:	2b03      	cmp	r3, #3
 800fdda:	d157      	bne.n	800fe8c <fCmdBuild_CEDRXS+0x108>
     * exple:
     * AT+CEDRX=1,5,0000
     * Set the requested e-I-DRX value to 5.12 second
    */

    if (p_modem_ctxt->SID_ctxt.set_power_config.edrx_present == CELLULAR_TRUE)
 800fddc:	f897 4720 	ldrb.w	r4, [r7, #1824]	; 0x720
 800fde0:	2c01      	cmp	r4, #1
 800fde2:	d02b      	beq.n	800fe3c <fCmdBuild_CEDRXS+0xb8>
      }
    }
    else
    {
      /* no eDRX parameters, skip the command */
      PRINT_INFO("No EDRX parameters available, command skipped")
 800fde4:	4d3e      	ldr	r5, [pc, #248]	; (800fee0 <fCmdBuild_CEDRXS+0x15c>)
 800fde6:	4c3d      	ldr	r4, [pc, #244]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fde8:	f105 0730 	add.w	r7, r5, #48	; 0x30
 800fdec:	46ac      	mov	ip, r5
 800fdee:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800fdf2:	6020      	str	r0, [r4, #0]
 800fdf4:	6061      	str	r1, [r4, #4]
 800fdf6:	60a2      	str	r2, [r4, #8]
 800fdf8:	60e3      	str	r3, [r4, #12]
 800fdfa:	4665      	mov	r5, ip
 800fdfc:	3410      	adds	r4, #16
 800fdfe:	45bc      	cmp	ip, r7
 800fe00:	d1f4      	bne.n	800fdec <fCmdBuild_CEDRXS+0x68>
 800fe02:	cd03      	ldmia	r5!, {r0, r1}
 800fe04:	6020      	str	r0, [r4, #0]
 800fe06:	6061      	str	r1, [r4, #4]
 800fe08:	782b      	ldrb	r3, [r5, #0]
 800fe0a:	7223      	strb	r3, [r4, #8]
 800fe0c:	4c33      	ldr	r4, [pc, #204]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fe0e:	4620      	mov	r0, r4
 800fe10:	f00f fa8b 	bl	801f32a <crs_strlen>
 800fe14:	b283      	uxth	r3, r0
 800fe16:	4622      	mov	r2, r4
 800fe18:	2101      	movs	r1, #1
 800fe1a:	2002      	movs	r0, #2
 800fe1c:	f00f fac8 	bl	801f3b0 <traceIF_itmPrint>
 800fe20:	4620      	mov	r0, r4
 800fe22:	f00f fa82 	bl	801f32a <crs_strlen>
 800fe26:	b283      	uxth	r3, r0
 800fe28:	4622      	mov	r2, r4
 800fe2a:	2101      	movs	r1, #1
 800fe2c:	2002      	movs	r0, #2
 800fe2e:	f00f fae1 	bl	801f3f4 <traceIF_uartPrint>
      atcm_program_SKIP_CMD(p_atp_ctxt);
 800fe32:	4630      	mov	r0, r6
 800fe34:	f7fc fe74 	bl	800cb20 <atcm_program_SKIP_CMD>
  at_status_t retval = ATSTATUS_OK;
 800fe38:	2000      	movs	r0, #0
 800fe3a:	e04b      	b.n	800fed4 <fCmdBuild_CEDRXS+0x150>
      uint8_t edrx_req_value[5] = {0};
 800fe3c:	2300      	movs	r3, #0
 800fe3e:	9302      	str	r3, [sp, #8]
 800fe40:	f88d 300c 	strb.w	r3, [sp, #12]
      (void) ATutil_convert_uint8_to_binary_string((uint32_t) p_modem_ctxt->SID_ctxt.set_power_config.edrx.req_value,
 800fe44:	ab02      	add	r3, sp, #8
 800fe46:	2205      	movs	r2, #5
 800fe48:	2104      	movs	r1, #4
 800fe4a:	f897 0728 	ldrb.w	r0, [r7, #1832]	; 0x728
 800fe4e:	f005 f813 	bl	8014e78 <ATutil_convert_uint8_to_binary_string>
      if (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_DISABLE)
 800fe52:	f897 3726 	ldrb.w	r3, [r7, #1830]	; 0x726
 800fe56:	b17b      	cbz	r3, 800fe78 <fCmdBuild_CEDRXS+0xf4>
      else if (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_DISABLE_AND_RESET)
 800fe58:	2b03      	cmp	r3, #3
 800fe5a:	d011      	beq.n	800fe80 <fCmdBuild_CEDRXS+0xfc>
        edrx_mode = (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_ENABLE_WITH_URC) ? 2U : 1U;
 800fe5c:	2b02      	cmp	r3, #2
 800fe5e:	d013      	beq.n	800fe88 <fCmdBuild_CEDRXS+0x104>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "%d,%d,\"%s\"",
 800fe60:	ab02      	add	r3, sp, #8
 800fe62:	9300      	str	r3, [sp, #0]
 800fe64:	f897 3727 	ldrb.w	r3, [r7, #1831]	; 0x727
 800fe68:	4622      	mov	r2, r4
 800fe6a:	491e      	ldr	r1, [pc, #120]	; (800fee4 <fCmdBuild_CEDRXS+0x160>)
 800fe6c:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800fe70:	f016 fcea 	bl	8026848 <sprintf>
  at_status_t retval = ATSTATUS_OK;
 800fe74:	2000      	movs	r0, #0
 800fe76:	e02d      	b.n	800fed4 <fCmdBuild_CEDRXS+0x150>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "0");
 800fe78:	4b1b      	ldr	r3, [pc, #108]	; (800fee8 <fCmdBuild_CEDRXS+0x164>)
 800fe7a:	881b      	ldrh	r3, [r3, #0]
 800fe7c:	8633      	strh	r3, [r6, #48]	; 0x30
 800fe7e:	e7f9      	b.n	800fe74 <fCmdBuild_CEDRXS+0xf0>
        (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params, "3");
 800fe80:	4b1a      	ldr	r3, [pc, #104]	; (800feec <fCmdBuild_CEDRXS+0x168>)
 800fe82:	881b      	ldrh	r3, [r3, #0]
 800fe84:	8633      	strh	r3, [r6, #48]	; 0x30
 800fe86:	e7f5      	b.n	800fe74 <fCmdBuild_CEDRXS+0xf0>
        edrx_mode = (p_modem_ctxt->SID_ctxt.set_power_config.edrx_mode == EDRX_MODE_ENABLE_WITH_URC) ? 2U : 1U;
 800fe88:	461c      	mov	r4, r3
 800fe8a:	e7e9      	b.n	800fe60 <fCmdBuild_CEDRXS+0xdc>
    }
  }
  else
  {
    PRINT_ERR("invalid pointer to EDRX parameters")
 800fe8c:	4e18      	ldr	r6, [pc, #96]	; (800fef0 <fCmdBuild_CEDRXS+0x16c>)
 800fe8e:	4d13      	ldr	r5, [pc, #76]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800fe90:	f106 0730 	add.w	r7, r6, #48	; 0x30
 800fe94:	4634      	mov	r4, r6
 800fe96:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800fe98:	6028      	str	r0, [r5, #0]
 800fe9a:	6069      	str	r1, [r5, #4]
 800fe9c:	60aa      	str	r2, [r5, #8]
 800fe9e:	60eb      	str	r3, [r5, #12]
 800fea0:	4626      	mov	r6, r4
 800fea2:	3510      	adds	r5, #16
 800fea4:	42bc      	cmp	r4, r7
 800fea6:	d1f5      	bne.n	800fe94 <fCmdBuild_CEDRXS+0x110>
 800fea8:	6820      	ldr	r0, [r4, #0]
 800feaa:	6028      	str	r0, [r5, #0]
 800feac:	4c0b      	ldr	r4, [pc, #44]	; (800fedc <fCmdBuild_CEDRXS+0x158>)
 800feae:	4620      	mov	r0, r4
 800feb0:	f00f fa3b 	bl	801f32a <crs_strlen>
 800feb4:	b283      	uxth	r3, r0
 800feb6:	4622      	mov	r2, r4
 800feb8:	2110      	movs	r1, #16
 800feba:	2002      	movs	r0, #2
 800febc:	f00f fa78 	bl	801f3b0 <traceIF_itmPrint>
 800fec0:	4620      	mov	r0, r4
 800fec2:	f00f fa32 	bl	801f32a <crs_strlen>
 800fec6:	b283      	uxth	r3, r0
 800fec8:	4622      	mov	r2, r4
 800feca:	2110      	movs	r1, #16
 800fecc:	2002      	movs	r0, #2
 800fece:	f00f fa91 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 800fed2:	2001      	movs	r0, #1
  }

  return (retval);
}
 800fed4:	b005      	add	sp, #20
 800fed6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800fed8:	0802f898 	.word	0x0802f898
 800fedc:	200048dc 	.word	0x200048dc
 800fee0:	0802f8c4 	.word	0x0802f8c4
 800fee4:	0802f410 	.word	0x0802f410
 800fee8:	080342b8 	.word	0x080342b8
 800feec:	0802f8c0 	.word	0x0802f8c0
 800fef0:	0802f900 	.word	0x0802f900

0800fef4 <fCmdBuild_CSIM>:

at_status_t fCmdBuild_CSIM(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800fef4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800fef6:	b083      	sub	sp, #12
 800fef8:	4606      	mov	r6, r0
 800fefa:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_CSIM()")
 800fefc:	4d1d      	ldr	r5, [pc, #116]	; (800ff74 <fCmdBuild_CSIM+0x80>)
 800fefe:	4c1e      	ldr	r4, [pc, #120]	; (800ff78 <fCmdBuild_CSIM+0x84>)
 800ff00:	f105 0e20 	add.w	lr, r5, #32
 800ff04:	46ac      	mov	ip, r5
 800ff06:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ff0a:	6020      	str	r0, [r4, #0]
 800ff0c:	6061      	str	r1, [r4, #4]
 800ff0e:	60a2      	str	r2, [r4, #8]
 800ff10:	60e3      	str	r3, [r4, #12]
 800ff12:	4665      	mov	r5, ip
 800ff14:	3410      	adds	r4, #16
 800ff16:	45f4      	cmp	ip, lr
 800ff18:	d1f4      	bne.n	800ff04 <fCmdBuild_CSIM+0x10>
 800ff1a:	f8dc 0000 	ldr.w	r0, [ip]
 800ff1e:	6020      	str	r0, [r4, #0]
 800ff20:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 800ff24:	80a3      	strh	r3, [r4, #4]
 800ff26:	4c14      	ldr	r4, [pc, #80]	; (800ff78 <fCmdBuild_CSIM+0x84>)
 800ff28:	4620      	mov	r0, r4
 800ff2a:	f00f f9fe 	bl	801f32a <crs_strlen>
 800ff2e:	b283      	uxth	r3, r0
 800ff30:	4622      	mov	r2, r4
 800ff32:	2104      	movs	r1, #4
 800ff34:	2002      	movs	r0, #2
 800ff36:	f00f fa3b 	bl	801f3b0 <traceIF_itmPrint>
 800ff3a:	4620      	mov	r0, r4
 800ff3c:	f00f f9f5 	bl	801f32a <crs_strlen>
 800ff40:	b283      	uxth	r3, r0
 800ff42:	4622      	mov	r2, r4
 800ff44:	2104      	movs	r1, #4
 800ff46:	2002      	movs	r0, #2
 800ff48:	f00f fa54 	bl	801f3f4 <traceIF_uartPrint>

  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 800ff4c:	8933      	ldrh	r3, [r6, #8]
 800ff4e:	2b03      	cmp	r3, #3
 800ff50:	d002      	beq.n	800ff58 <fCmdBuild_CSIM+0x64>
                   length, (int16_t)length,
                   (const CS_CHAR_t *)p_modem_ctxt->SID_ctxt.sim_generic_access.data->p_cmd_str);
  }

  return (retval);
}
 800ff52:	2000      	movs	r0, #0
 800ff54:	b003      	add	sp, #12
 800ff56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    length = (uint16_t) p_modem_ctxt->SID_ctxt.sim_generic_access.data->cmd_str_size;
 800ff58:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
 800ff5c:	689a      	ldr	r2, [r3, #8]
    (void) sprintf((CRC_CHAR_t *)p_atp_ctxt->current_atcmd.params,
 800ff5e:	681b      	ldr	r3, [r3, #0]
 800ff60:	9300      	str	r3, [sp, #0]
 800ff62:	b213      	sxth	r3, r2
 800ff64:	b292      	uxth	r2, r2
 800ff66:	4905      	ldr	r1, [pc, #20]	; (800ff7c <fCmdBuild_CSIM+0x88>)
 800ff68:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ff6c:	f016 fc6c 	bl	8026848 <sprintf>
 800ff70:	e7ef      	b.n	800ff52 <fCmdBuild_CSIM+0x5e>
 800ff72:	bf00      	nop
 800ff74:	0802f934 	.word	0x0802f934
 800ff78:	200048dc 	.word	0x200048dc
 800ff7c:	0802f95c 	.word	0x0802f95c

0800ff80 <fCmdBuild_DIRECT_CMD>:

at_status_t fCmdBuild_DIRECT_CMD(atparser_context_t *p_atp_ctxt, atcustom_modem_context_t *p_modem_ctxt)
{
 800ff80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800ff82:	4606      	mov	r6, r0
 800ff84:	460f      	mov	r7, r1
  at_status_t retval = ATSTATUS_OK;
  PRINT_API("enter fCmdBuild_DIRECT_CMD()")
 800ff86:	4c38      	ldr	r4, [pc, #224]	; (8010068 <fCmdBuild_DIRECT_CMD+0xe8>)
 800ff88:	4d38      	ldr	r5, [pc, #224]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 800ff8a:	f104 0e20 	add.w	lr, r4, #32
 800ff8e:	46a4      	mov	ip, r4
 800ff90:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800ff94:	6028      	str	r0, [r5, #0]
 800ff96:	6069      	str	r1, [r5, #4]
 800ff98:	60aa      	str	r2, [r5, #8]
 800ff9a:	60eb      	str	r3, [r5, #12]
 800ff9c:	4664      	mov	r4, ip
 800ff9e:	3510      	adds	r5, #16
 800ffa0:	45f4      	cmp	ip, lr
 800ffa2:	d1f4      	bne.n	800ff8e <fCmdBuild_DIRECT_CMD+0xe>
 800ffa4:	cc07      	ldmia	r4!, {r0, r1, r2}
 800ffa6:	6028      	str	r0, [r5, #0]
 800ffa8:	6069      	str	r1, [r5, #4]
 800ffaa:	60aa      	str	r2, [r5, #8]
 800ffac:	4c2f      	ldr	r4, [pc, #188]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 800ffae:	4620      	mov	r0, r4
 800ffb0:	f00f f9bb 	bl	801f32a <crs_strlen>
 800ffb4:	b283      	uxth	r3, r0
 800ffb6:	4622      	mov	r2, r4
 800ffb8:	2104      	movs	r1, #4
 800ffba:	2002      	movs	r0, #2
 800ffbc:	f00f f9f8 	bl	801f3b0 <traceIF_itmPrint>
 800ffc0:	4620      	mov	r0, r4
 800ffc2:	f00f f9b2 	bl	801f32a <crs_strlen>
 800ffc6:	b283      	uxth	r3, r0
 800ffc8:	4622      	mov	r2, r4
 800ffca:	2104      	movs	r1, #4
 800ffcc:	2002      	movs	r0, #2
 800ffce:	f00f fa11 	bl	801f3f4 <traceIF_uartPrint>

  /* only for RAW command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_RAW_CMD)
 800ffd2:	8933      	ldrh	r3, [r6, #8]
 800ffd4:	2b06      	cmp	r3, #6
 800ffd6:	d001      	beq.n	800ffdc <fCmdBuild_DIRECT_CMD+0x5c>
  at_status_t retval = ATSTATUS_OK;
 800ffd8:	2000      	movs	r0, #0
      PRINT_ERR("ERROR, send buffer is empty")
      retval = ATSTATUS_ERROR;
    }
  }
  return (retval);
}
 800ffda:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_modem_ctxt->SID_ctxt.direct_cmd_tx->cmd_size != 0U)
 800ffdc:	f8d7 1714 	ldr.w	r1, [r7, #1812]	; 0x714
 800ffe0:	f8b1 4076 	ldrh.w	r4, [r1, #118]	; 0x76
 800ffe4:	b1b4      	cbz	r4, 8010014 <fCmdBuild_DIRECT_CMD+0x94>
      (void) memcpy((void *)p_atp_ctxt->current_atcmd.params,
 800ffe6:	4622      	mov	r2, r4
 800ffe8:	f106 0030 	add.w	r0, r6, #48	; 0x30
 800ffec:	f016 fd7c 	bl	8026ae8 <memcpy>
      uint32_t endstr_size = strlen((CRC_CHAR_t *)&p_atp_ctxt->endstr);
 800fff0:	f206 6774 	addw	r7, r6, #1652	; 0x674
 800fff4:	4638      	mov	r0, r7
 800fff6:	f7f0 f8fd 	bl	80001f4 <strlen>
 800fffa:	4605      	mov	r5, r0
      (void) memcpy((void *)&p_atp_ctxt->current_atcmd.params[str_size],
 800fffc:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8010000:	462a      	mov	r2, r5
 8010002:	4639      	mov	r1, r7
 8010004:	4430      	add	r0, r6
 8010006:	f016 fd6f 	bl	8026ae8 <memcpy>
      p_atp_ctxt->current_atcmd.raw_cmd_size = str_size + endstr_size;
 801000a:	442c      	add	r4, r5
 801000c:	f8c6 4670 	str.w	r4, [r6, #1648]	; 0x670
  at_status_t retval = ATSTATUS_OK;
 8010010:	2000      	movs	r0, #0
 8010012:	e7e2      	b.n	800ffda <fCmdBuild_DIRECT_CMD+0x5a>
      PRINT_ERR("ERROR, send buffer is empty")
 8010014:	4d16      	ldr	r5, [pc, #88]	; (8010070 <fCmdBuild_DIRECT_CMD+0xf0>)
 8010016:	4c15      	ldr	r4, [pc, #84]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 8010018:	f105 0720 	add.w	r7, r5, #32
 801001c:	462e      	mov	r6, r5
 801001e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8010020:	6020      	str	r0, [r4, #0]
 8010022:	6061      	str	r1, [r4, #4]
 8010024:	60a2      	str	r2, [r4, #8]
 8010026:	60e3      	str	r3, [r4, #12]
 8010028:	4635      	mov	r5, r6
 801002a:	3410      	adds	r4, #16
 801002c:	42be      	cmp	r6, r7
 801002e:	d1f5      	bne.n	801001c <fCmdBuild_DIRECT_CMD+0x9c>
 8010030:	cd07      	ldmia	r5!, {r0, r1, r2}
 8010032:	6020      	str	r0, [r4, #0]
 8010034:	6061      	str	r1, [r4, #4]
 8010036:	60a2      	str	r2, [r4, #8]
 8010038:	782b      	ldrb	r3, [r5, #0]
 801003a:	7323      	strb	r3, [r4, #12]
 801003c:	4c0b      	ldr	r4, [pc, #44]	; (801006c <fCmdBuild_DIRECT_CMD+0xec>)
 801003e:	4620      	mov	r0, r4
 8010040:	f00f f973 	bl	801f32a <crs_strlen>
 8010044:	b283      	uxth	r3, r0
 8010046:	4622      	mov	r2, r4
 8010048:	2110      	movs	r1, #16
 801004a:	2002      	movs	r0, #2
 801004c:	f00f f9b0 	bl	801f3b0 <traceIF_itmPrint>
 8010050:	4620      	mov	r0, r4
 8010052:	f00f f96a 	bl	801f32a <crs_strlen>
 8010056:	b283      	uxth	r3, r0
 8010058:	4622      	mov	r2, r4
 801005a:	2110      	movs	r1, #16
 801005c:	2002      	movs	r0, #2
 801005e:	f00f f9c9 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATSTATUS_ERROR;
 8010062:	2001      	movs	r0, #1
 8010064:	e7b9      	b.n	800ffda <fCmdBuild_DIRECT_CMD+0x5a>
 8010066:	bf00      	nop
 8010068:	0802f968 	.word	0x0802f968
 801006c:	200048dc 	.word	0x200048dc
 8010070:	0802f994 	.word	0x0802f994

08010074 <fRspAnalyze_None>:

/* ==========================  Analyze 3GPP TS 27.007 commands ========================== */
at_action_rsp_t fRspAnalyze_None(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010074:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_None()")
 8010076:	4c13      	ldr	r4, [pc, #76]	; (80100c4 <fRspAnalyze_None+0x50>)
 8010078:	4d13      	ldr	r5, [pc, #76]	; (80100c8 <fRspAnalyze_None+0x54>)
 801007a:	f104 0e20 	add.w	lr, r4, #32
 801007e:	46a4      	mov	ip, r4
 8010080:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010084:	6028      	str	r0, [r5, #0]
 8010086:	6069      	str	r1, [r5, #4]
 8010088:	60aa      	str	r2, [r5, #8]
 801008a:	60eb      	str	r3, [r5, #12]
 801008c:	4664      	mov	r4, ip
 801008e:	3510      	adds	r5, #16
 8010090:	45f4      	cmp	ip, lr
 8010092:	d1f4      	bne.n	801007e <fRspAnalyze_None+0xa>
 8010094:	cc03      	ldmia	r4!, {r0, r1}
 8010096:	6028      	str	r0, [r5, #0]
 8010098:	6069      	str	r1, [r5, #4]
 801009a:	4c0b      	ldr	r4, [pc, #44]	; (80100c8 <fRspAnalyze_None+0x54>)
 801009c:	4620      	mov	r0, r4
 801009e:	f00f f944 	bl	801f32a <crs_strlen>
 80100a2:	b283      	uxth	r3, r0
 80100a4:	4622      	mov	r2, r4
 80100a6:	2104      	movs	r1, #4
 80100a8:	2002      	movs	r0, #2
 80100aa:	f00f f981 	bl	801f3b0 <traceIF_itmPrint>
 80100ae:	4620      	mov	r0, r4
 80100b0:	f00f f93b 	bl	801f32a <crs_strlen>
 80100b4:	b283      	uxth	r3, r0
 80100b6:	4622      	mov	r2, r4
 80100b8:	2104      	movs	r1, #4
 80100ba:	2002      	movs	r0, #2
 80100bc:	f00f f99a 	bl	801f3f4 <traceIF_uartPrint>

  /* no parameters expected */

  return (retval);
}
 80100c0:	2010      	movs	r0, #16
 80100c2:	bd38      	pop	{r3, r4, r5, pc}
 80100c4:	0802f9c4 	.word	0x0802f9c4
 80100c8:	200048dc 	.word	0x200048dc

080100cc <fRspAnalyze_CmeErr>:
  return (retval);
}

at_action_rsp_t fRspAnalyze_CmeErr(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80100cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80100d0:	4606      	mov	r6, r0
 80100d2:	460f      	mov	r7, r1
 80100d4:	4690      	mov	r8, r2
 80100d6:	4699      	mov	r9, r3
  const atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  /*UNUSED(p_msg_in);*/
  /*UNUSED(element_infos);*/

  at_action_rsp_t retval = ATACTION_RSP_ERROR;
  PRINT_API("enter fRspAnalyze_CmeErr()")
 80100d8:	4cbc      	ldr	r4, [pc, #752]	; (80103cc <fRspAnalyze_CmeErr+0x300>)
 80100da:	4dbd      	ldr	r5, [pc, #756]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80100dc:	f104 0e20 	add.w	lr, r4, #32
 80100e0:	46a4      	mov	ip, r4
 80100e2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80100e6:	6028      	str	r0, [r5, #0]
 80100e8:	6069      	str	r1, [r5, #4]
 80100ea:	60aa      	str	r2, [r5, #8]
 80100ec:	60eb      	str	r3, [r5, #12]
 80100ee:	4664      	mov	r4, ip
 80100f0:	3510      	adds	r5, #16
 80100f2:	45f4      	cmp	ip, lr
 80100f4:	d1f4      	bne.n	80100e0 <fRspAnalyze_CmeErr+0x14>
 80100f6:	cc03      	ldmia	r4!, {r0, r1}
 80100f8:	6028      	str	r0, [r5, #0]
 80100fa:	6069      	str	r1, [r5, #4]
 80100fc:	8823      	ldrh	r3, [r4, #0]
 80100fe:	812b      	strh	r3, [r5, #8]
 8010100:	4cb3      	ldr	r4, [pc, #716]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010102:	4620      	mov	r0, r4
 8010104:	f00f f911 	bl	801f32a <crs_strlen>
 8010108:	b283      	uxth	r3, r0
 801010a:	4622      	mov	r2, r4
 801010c:	2104      	movs	r1, #4
 801010e:	2002      	movs	r0, #2
 8010110:	f00f f94e 	bl	801f3b0 <traceIF_itmPrint>
 8010114:	4620      	mov	r0, r4
 8010116:	f00f f908 	bl	801f32a <crs_strlen>
 801011a:	b283      	uxth	r3, r0
 801011c:	4622      	mov	r2, r4
 801011e:	2104      	movs	r1, #4
 8010120:	2002      	movs	r0, #2
 8010122:	f00f f967 	bl	801f3f4 <traceIF_uartPrint>

  /* Analyze CME error to report it to upper layers */
  (void) analyze_CmeError(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 8010126:	464b      	mov	r3, r9
 8010128:	4642      	mov	r2, r8
 801012a:	4639      	mov	r1, r7
 801012c:	4630      	mov	r0, r6
 801012e:	f7fe fbeb 	bl	800e908 <analyze_CmeError>

  /* specific treatments for +CME ERROR, depending of current command */
  switch (p_atp_ctxt->current_atcmd.id)
 8010132:	69f2      	ldr	r2, [r6, #28]
 8010134:	f1a2 030b 	sub.w	r3, r2, #11
 8010138:	2b25      	cmp	r3, #37	; 0x25
 801013a:	f200 8239 	bhi.w	80105b0 <fRspAnalyze_CmeErr+0x4e4>
 801013e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8010142:	0115      	.short	0x0115
 8010144:	01870157 	.word	0x01870157
 8010148:	00e40026 	.word	0x00e40026
 801014c:	02370237 	.word	0x02370237
 8010150:	02370212 	.word	0x02370212
 8010154:	01b60237 	.word	0x01b60237
 8010158:	02370237 	.word	0x02370237
 801015c:	02370237 	.word	0x02370237
 8010160:	02370237 	.word	0x02370237
 8010164:	02370237 	.word	0x02370237
 8010168:	02370237 	.word	0x02370237
 801016c:	02370237 	.word	0x02370237
 8010170:	02370237 	.word	0x02370237
 8010174:	02370237 	.word	0x02370237
 8010178:	02370237 	.word	0x02370237
 801017c:	02370237 	.word	0x02370237
 8010180:	02370237 	.word	0x02370237
 8010184:	02370237 	.word	0x02370237
 8010188:	02370237 	.word	0x02370237
 801018c:	01e5      	.short	0x01e5
  {
    case CMD_AT_CGSN:
    {
      if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SN)
 801018e:	f897 372c 	ldrb.w	r3, [r7, #1836]	; 0x72c
 8010192:	b36b      	cbz	r3, 80101f0 <fRspAnalyze_CmeErr+0x124>
      {
        PRINT_DBG("Modem Error for CGSN_SN, use unitialized value")
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number), 0, MAX_SIZE_SN);
      }
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEI)
 8010194:	2b01      	cmp	r3, #1
 8010196:	d059      	beq.n	801024c <fRspAnalyze_CmeErr+0x180>
      {
        PRINT_DBG("Modem Error for CGSN_IMEI, use unitialized value")
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei), 0, MAX_SIZE_IMEI);
      }
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEISV)
 8010198:	2b02      	cmp	r3, #2
 801019a:	f000 8084 	beq.w	80102a6 <fRspAnalyze_CmeErr+0x1da>
      {
        PRINT_DBG("Modem Error for CGSN_IMEISV, use unitialized value, parameter ignored")
      }
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SVN)
 801019e:	2b03      	cmp	r3, #3
 80101a0:	f000 809a 	beq.w	80102d8 <fRspAnalyze_CmeErr+0x20c>
      {
        PRINT_DBG("Modem Error for CGSN_SVN, use unitialized value, parameter ignored")
      }
      else
      {
        PRINT_DBG("Modem Error for CGSN, unexpected parameter")
 80101a4:	4e8b      	ldr	r6, [pc, #556]	; (80103d4 <fRspAnalyze_CmeErr+0x308>)
 80101a6:	4c8a      	ldr	r4, [pc, #552]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80101a8:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80101ac:	4635      	mov	r5, r6
 80101ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80101b0:	6020      	str	r0, [r4, #0]
 80101b2:	6061      	str	r1, [r4, #4]
 80101b4:	60a2      	str	r2, [r4, #8]
 80101b6:	60e3      	str	r3, [r4, #12]
 80101b8:	462e      	mov	r6, r5
 80101ba:	3410      	adds	r4, #16
 80101bc:	42bd      	cmp	r5, r7
 80101be:	d1f5      	bne.n	80101ac <fRspAnalyze_CmeErr+0xe0>
 80101c0:	6828      	ldr	r0, [r5, #0]
 80101c2:	6020      	str	r0, [r4, #0]
 80101c4:	88ab      	ldrh	r3, [r5, #4]
 80101c6:	80a3      	strh	r3, [r4, #4]
 80101c8:	4c81      	ldr	r4, [pc, #516]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80101ca:	4620      	mov	r0, r4
 80101cc:	f00f f8ad 	bl	801f32a <crs_strlen>
 80101d0:	b283      	uxth	r3, r0
 80101d2:	4622      	mov	r2, r4
 80101d4:	2102      	movs	r1, #2
 80101d6:	4608      	mov	r0, r1
 80101d8:	f00f f8ea 	bl	801f3b0 <traceIF_itmPrint>
 80101dc:	4620      	mov	r0, r4
 80101de:	f00f f8a4 	bl	801f32a <crs_strlen>
 80101e2:	b283      	uxth	r3, r0
 80101e4:	4622      	mov	r2, r4
 80101e6:	2102      	movs	r1, #2
 80101e8:	4608      	mov	r0, r1
 80101ea:	f00f f903 	bl	801f3f4 <traceIF_uartPrint>
        retval = ATACTION_RSP_ERROR;
 80101ee:	e0ba      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_SN, use unitialized value")
 80101f0:	4d79      	ldr	r5, [pc, #484]	; (80103d8 <fRspAnalyze_CmeErr+0x30c>)
 80101f2:	4c77      	ldr	r4, [pc, #476]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80101f4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80101f8:	462e      	mov	r6, r5
 80101fa:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80101fc:	6020      	str	r0, [r4, #0]
 80101fe:	6061      	str	r1, [r4, #4]
 8010200:	60a2      	str	r2, [r4, #8]
 8010202:	60e3      	str	r3, [r4, #12]
 8010204:	4635      	mov	r5, r6
 8010206:	3410      	adds	r4, #16
 8010208:	4566      	cmp	r6, ip
 801020a:	d1f5      	bne.n	80101f8 <fRspAnalyze_CmeErr+0x12c>
 801020c:	cd03      	ldmia	r5!, {r0, r1}
 801020e:	6020      	str	r0, [r4, #0]
 8010210:	6061      	str	r1, [r4, #4]
 8010212:	882b      	ldrh	r3, [r5, #0]
 8010214:	8123      	strh	r3, [r4, #8]
 8010216:	4c6e      	ldr	r4, [pc, #440]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010218:	4620      	mov	r0, r4
 801021a:	f00f f886 	bl	801f32a <crs_strlen>
 801021e:	b283      	uxth	r3, r0
 8010220:	4622      	mov	r2, r4
 8010222:	2102      	movs	r1, #2
 8010224:	4608      	mov	r0, r1
 8010226:	f00f f8c3 	bl	801f3b0 <traceIF_itmPrint>
 801022a:	4620      	mov	r0, r4
 801022c:	f00f f87d 	bl	801f32a <crs_strlen>
 8010230:	b283      	uxth	r3, r0
 8010232:	4622      	mov	r2, r4
 8010234:	2102      	movs	r1, #2
 8010236:	4608      	mov	r0, r1
 8010238:	f00f f8dc 	bl	801f3f4 <traceIF_uartPrint>
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number), 0, MAX_SIZE_SN);
 801023c:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 8010240:	2240      	movs	r2, #64	; 0x40
 8010242:	2100      	movs	r1, #0
 8010244:	3002      	adds	r0, #2
 8010246:	f016 fb72 	bl	802692e <memset>
 801024a:	e08c      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_IMEI, use unitialized value")
 801024c:	4d63      	ldr	r5, [pc, #396]	; (80103dc <fRspAnalyze_CmeErr+0x310>)
 801024e:	4c60      	ldr	r4, [pc, #384]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010250:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8010254:	462e      	mov	r6, r5
 8010256:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8010258:	6020      	str	r0, [r4, #0]
 801025a:	6061      	str	r1, [r4, #4]
 801025c:	60a2      	str	r2, [r4, #8]
 801025e:	60e3      	str	r3, [r4, #12]
 8010260:	4635      	mov	r5, r6
 8010262:	3410      	adds	r4, #16
 8010264:	4566      	cmp	r6, ip
 8010266:	d1f5      	bne.n	8010254 <fRspAnalyze_CmeErr+0x188>
 8010268:	cd07      	ldmia	r5!, {r0, r1, r2}
 801026a:	6020      	str	r0, [r4, #0]
 801026c:	6061      	str	r1, [r4, #4]
 801026e:	60a2      	str	r2, [r4, #8]
 8010270:	4c57      	ldr	r4, [pc, #348]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010272:	4620      	mov	r0, r4
 8010274:	f00f f859 	bl	801f32a <crs_strlen>
 8010278:	b283      	uxth	r3, r0
 801027a:	4622      	mov	r2, r4
 801027c:	2102      	movs	r1, #2
 801027e:	4608      	mov	r0, r1
 8010280:	f00f f896 	bl	801f3b0 <traceIF_itmPrint>
 8010284:	4620      	mov	r0, r4
 8010286:	f00f f850 	bl	801f32a <crs_strlen>
 801028a:	b283      	uxth	r3, r0
 801028c:	4622      	mov	r2, r4
 801028e:	2102      	movs	r1, #2
 8010290:	4608      	mov	r0, r1
 8010292:	f00f f8af 	bl	801f3f4 <traceIF_uartPrint>
        (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei), 0, MAX_SIZE_IMEI);
 8010296:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 801029a:	2240      	movs	r2, #64	; 0x40
 801029c:	2100      	movs	r1, #0
 801029e:	3002      	adds	r0, #2
 80102a0:	f016 fb45 	bl	802692e <memset>
 80102a4:	e05f      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_IMEISV, use unitialized value, parameter ignored")
 80102a6:	4c4a      	ldr	r4, [pc, #296]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80102a8:	2251      	movs	r2, #81	; 0x51
 80102aa:	494d      	ldr	r1, [pc, #308]	; (80103e0 <fRspAnalyze_CmeErr+0x314>)
 80102ac:	4620      	mov	r0, r4
 80102ae:	f016 fc1b 	bl	8026ae8 <memcpy>
 80102b2:	4620      	mov	r0, r4
 80102b4:	f00f f839 	bl	801f32a <crs_strlen>
 80102b8:	b283      	uxth	r3, r0
 80102ba:	4622      	mov	r2, r4
 80102bc:	2102      	movs	r1, #2
 80102be:	4608      	mov	r0, r1
 80102c0:	f00f f876 	bl	801f3b0 <traceIF_itmPrint>
 80102c4:	4620      	mov	r0, r4
 80102c6:	f00f f830 	bl	801f32a <crs_strlen>
 80102ca:	b283      	uxth	r3, r0
 80102cc:	4622      	mov	r2, r4
 80102ce:	2102      	movs	r1, #2
 80102d0:	4608      	mov	r0, r1
 80102d2:	f00f f88f 	bl	801f3f4 <traceIF_uartPrint>
 80102d6:	e046      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
        PRINT_DBG("Modem Error for CGSN_SVN, use unitialized value, parameter ignored")
 80102d8:	4c3d      	ldr	r4, [pc, #244]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 80102da:	224e      	movs	r2, #78	; 0x4e
 80102dc:	4941      	ldr	r1, [pc, #260]	; (80103e4 <fRspAnalyze_CmeErr+0x318>)
 80102de:	4620      	mov	r0, r4
 80102e0:	f016 fc02 	bl	8026ae8 <memcpy>
 80102e4:	4620      	mov	r0, r4
 80102e6:	f00f f820 	bl	801f32a <crs_strlen>
 80102ea:	b283      	uxth	r3, r0
 80102ec:	4622      	mov	r2, r4
 80102ee:	2102      	movs	r1, #2
 80102f0:	4608      	mov	r0, r1
 80102f2:	f00f f85d 	bl	801f3b0 <traceIF_itmPrint>
 80102f6:	4620      	mov	r0, r4
 80102f8:	f00f f817 	bl	801f32a <crs_strlen>
 80102fc:	b283      	uxth	r3, r0
 80102fe:	4622      	mov	r2, r4
 8010300:	2102      	movs	r1, #2
 8010302:	4608      	mov	r0, r1
 8010304:	f00f f876 	bl	801f3f4 <traceIF_uartPrint>
 8010308:	e02d      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      }
      break;
    }

    case CMD_AT_CIMI:
      PRINT_DBG("Modem Error for CIMI, use unitialized value")
 801030a:	4e37      	ldr	r6, [pc, #220]	; (80103e8 <fRspAnalyze_CmeErr+0x31c>)
 801030c:	4c30      	ldr	r4, [pc, #192]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 801030e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010312:	4635      	mov	r5, r6
 8010314:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010316:	6020      	str	r0, [r4, #0]
 8010318:	6061      	str	r1, [r4, #4]
 801031a:	60a2      	str	r2, [r4, #8]
 801031c:	60e3      	str	r3, [r4, #12]
 801031e:	462e      	mov	r6, r5
 8010320:	3410      	adds	r4, #16
 8010322:	4565      	cmp	r5, ip
 8010324:	d1f5      	bne.n	8010312 <fRspAnalyze_CmeErr+0x246>
 8010326:	6828      	ldr	r0, [r5, #0]
 8010328:	6020      	str	r0, [r4, #0]
 801032a:	88aa      	ldrh	r2, [r5, #4]
 801032c:	79ab      	ldrb	r3, [r5, #6]
 801032e:	80a2      	strh	r2, [r4, #4]
 8010330:	71a3      	strb	r3, [r4, #6]
 8010332:	4c27      	ldr	r4, [pc, #156]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010334:	4620      	mov	r0, r4
 8010336:	f00e fff8 	bl	801f32a <crs_strlen>
 801033a:	b283      	uxth	r3, r0
 801033c:	4622      	mov	r2, r4
 801033e:	2102      	movs	r1, #2
 8010340:	4608      	mov	r0, r1
 8010342:	f00f f835 	bl	801f3b0 <traceIF_itmPrint>
 8010346:	4620      	mov	r0, r4
 8010348:	f00e ffef 	bl	801f32a <crs_strlen>
 801034c:	b283      	uxth	r3, r0
 801034e:	4622      	mov	r2, r4
 8010350:	2102      	movs	r1, #2
 8010352:	4608      	mov	r0, r1
 8010354:	f00f f84e 	bl	801f3f4 <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imsi), 0, MAX_SIZE_IMSI);
 8010358:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 801035c:	2240      	movs	r2, #64	; 0x40
 801035e:	2100      	movs	r1, #0
 8010360:	3002      	adds	r0, #2
 8010362:	f016 fae4 	bl	802692e <memset>
      retval = ATACTION_RSP_ERROR;
      break;
  }

  return (retval);
}
 8010366:	2004      	movs	r0, #4
 8010368:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      PRINT_DBG("Modem Error for CGMI, use unitialized value")
 801036c:	4e1f      	ldr	r6, [pc, #124]	; (80103ec <fRspAnalyze_CmeErr+0x320>)
 801036e:	4c18      	ldr	r4, [pc, #96]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010370:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010374:	4635      	mov	r5, r6
 8010376:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010378:	6020      	str	r0, [r4, #0]
 801037a:	6061      	str	r1, [r4, #4]
 801037c:	60a2      	str	r2, [r4, #8]
 801037e:	60e3      	str	r3, [r4, #12]
 8010380:	462e      	mov	r6, r5
 8010382:	3410      	adds	r4, #16
 8010384:	4565      	cmp	r5, ip
 8010386:	d1f5      	bne.n	8010374 <fRspAnalyze_CmeErr+0x2a8>
 8010388:	6828      	ldr	r0, [r5, #0]
 801038a:	6020      	str	r0, [r4, #0]
 801038c:	88aa      	ldrh	r2, [r5, #4]
 801038e:	79ab      	ldrb	r3, [r5, #6]
 8010390:	80a2      	strh	r2, [r4, #4]
 8010392:	71a3      	strb	r3, [r4, #6]
 8010394:	4c0e      	ldr	r4, [pc, #56]	; (80103d0 <fRspAnalyze_CmeErr+0x304>)
 8010396:	4620      	mov	r0, r4
 8010398:	f00e ffc7 	bl	801f32a <crs_strlen>
 801039c:	b283      	uxth	r3, r0
 801039e:	4622      	mov	r2, r4
 80103a0:	2102      	movs	r1, #2
 80103a2:	4608      	mov	r0, r1
 80103a4:	f00f f804 	bl	801f3b0 <traceIF_itmPrint>
 80103a8:	4620      	mov	r0, r4
 80103aa:	f00e ffbe 	bl	801f32a <crs_strlen>
 80103ae:	b283      	uxth	r3, r0
 80103b0:	4622      	mov	r2, r4
 80103b2:	2102      	movs	r1, #2
 80103b4:	4608      	mov	r0, r1
 80103b6:	f00f f81d 	bl	801f3f4 <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.manufacturer_name), 0, MAX_SIZE_MANUFACT_NAME);
 80103ba:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 80103be:	f44f 7280 	mov.w	r2, #256	; 0x100
 80103c2:	2100      	movs	r1, #0
 80103c4:	3002      	adds	r0, #2
 80103c6:	f016 fab2 	bl	802692e <memset>
      break;
 80103ca:	e7cc      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
 80103cc:	0802f9ec 	.word	0x0802f9ec
 80103d0:	200048dc 	.word	0x200048dc
 80103d4:	0802fb34 	.word	0x0802fb34
 80103d8:	0802fa18 	.word	0x0802fa18
 80103dc:	0802fa54 	.word	0x0802fa54
 80103e0:	0802fa90 	.word	0x0802fa90
 80103e4:	0802fae4 	.word	0x0802fae4
 80103e8:	0802fb6c 	.word	0x0802fb6c
 80103ec:	0802fba4 	.word	0x0802fba4
      PRINT_DBG("Modem Error for CGMM, use unitialized value")
 80103f0:	4e7b      	ldr	r6, [pc, #492]	; (80105e0 <fRspAnalyze_CmeErr+0x514>)
 80103f2:	4c7c      	ldr	r4, [pc, #496]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80103f4:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80103f8:	4635      	mov	r5, r6
 80103fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80103fc:	6020      	str	r0, [r4, #0]
 80103fe:	6061      	str	r1, [r4, #4]
 8010400:	60a2      	str	r2, [r4, #8]
 8010402:	60e3      	str	r3, [r4, #12]
 8010404:	462e      	mov	r6, r5
 8010406:	3410      	adds	r4, #16
 8010408:	4565      	cmp	r5, ip
 801040a:	d1f5      	bne.n	80103f8 <fRspAnalyze_CmeErr+0x32c>
 801040c:	6828      	ldr	r0, [r5, #0]
 801040e:	6020      	str	r0, [r4, #0]
 8010410:	88aa      	ldrh	r2, [r5, #4]
 8010412:	79ab      	ldrb	r3, [r5, #6]
 8010414:	80a2      	strh	r2, [r4, #4]
 8010416:	71a3      	strb	r3, [r4, #6]
 8010418:	4c72      	ldr	r4, [pc, #456]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801041a:	4620      	mov	r0, r4
 801041c:	f00e ff85 	bl	801f32a <crs_strlen>
 8010420:	b283      	uxth	r3, r0
 8010422:	4622      	mov	r2, r4
 8010424:	2102      	movs	r1, #2
 8010426:	4608      	mov	r0, r1
 8010428:	f00e ffc2 	bl	801f3b0 <traceIF_itmPrint>
 801042c:	4620      	mov	r0, r4
 801042e:	f00e ff7c 	bl	801f32a <crs_strlen>
 8010432:	b283      	uxth	r3, r0
 8010434:	4622      	mov	r2, r4
 8010436:	2102      	movs	r1, #2
 8010438:	4608      	mov	r0, r1
 801043a:	f00e ffdb 	bl	801f3f4 <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.model), 0, MAX_SIZE_MODEL);
 801043e:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 8010442:	f44f 7280 	mov.w	r2, #256	; 0x100
 8010446:	2100      	movs	r1, #0
 8010448:	3002      	adds	r0, #2
 801044a:	f016 fa70 	bl	802692e <memset>
      break;
 801044e:	e78a      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for CGMR, use unitialized value")
 8010450:	4e65      	ldr	r6, [pc, #404]	; (80105e8 <fRspAnalyze_CmeErr+0x51c>)
 8010452:	4c64      	ldr	r4, [pc, #400]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 8010454:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010458:	4635      	mov	r5, r6
 801045a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801045c:	6020      	str	r0, [r4, #0]
 801045e:	6061      	str	r1, [r4, #4]
 8010460:	60a2      	str	r2, [r4, #8]
 8010462:	60e3      	str	r3, [r4, #12]
 8010464:	462e      	mov	r6, r5
 8010466:	3410      	adds	r4, #16
 8010468:	4565      	cmp	r5, ip
 801046a:	d1f5      	bne.n	8010458 <fRspAnalyze_CmeErr+0x38c>
 801046c:	6828      	ldr	r0, [r5, #0]
 801046e:	6020      	str	r0, [r4, #0]
 8010470:	88aa      	ldrh	r2, [r5, #4]
 8010472:	79ab      	ldrb	r3, [r5, #6]
 8010474:	80a2      	strh	r2, [r4, #4]
 8010476:	71a3      	strb	r3, [r4, #6]
 8010478:	4c5a      	ldr	r4, [pc, #360]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801047a:	4620      	mov	r0, r4
 801047c:	f00e ff55 	bl	801f32a <crs_strlen>
 8010480:	b283      	uxth	r3, r0
 8010482:	4622      	mov	r2, r4
 8010484:	2102      	movs	r1, #2
 8010486:	4608      	mov	r0, r1
 8010488:	f00e ff92 	bl	801f3b0 <traceIF_itmPrint>
 801048c:	4620      	mov	r0, r4
 801048e:	f00e ff4c 	bl	801f32a <crs_strlen>
 8010492:	b283      	uxth	r3, r0
 8010494:	4622      	mov	r2, r4
 8010496:	2102      	movs	r1, #2
 8010498:	4608      	mov	r0, r1
 801049a:	f00e ffab 	bl	801f3f4 <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.revision), 0, MAX_SIZE_REV);
 801049e:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 80104a2:	2240      	movs	r2, #64	; 0x40
 80104a4:	2100      	movs	r1, #0
 80104a6:	3002      	adds	r0, #2
 80104a8:	f016 fa41 	bl	802692e <memset>
      break;
 80104ac:	e75b      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for CNUM, use unitialized value")
 80104ae:	4e4f      	ldr	r6, [pc, #316]	; (80105ec <fRspAnalyze_CmeErr+0x520>)
 80104b0:	4c4c      	ldr	r4, [pc, #304]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80104b2:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80104b6:	4635      	mov	r5, r6
 80104b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80104ba:	6020      	str	r0, [r4, #0]
 80104bc:	6061      	str	r1, [r4, #4]
 80104be:	60a2      	str	r2, [r4, #8]
 80104c0:	60e3      	str	r3, [r4, #12]
 80104c2:	462e      	mov	r6, r5
 80104c4:	3410      	adds	r4, #16
 80104c6:	4565      	cmp	r5, ip
 80104c8:	d1f5      	bne.n	80104b6 <fRspAnalyze_CmeErr+0x3ea>
 80104ca:	6828      	ldr	r0, [r5, #0]
 80104cc:	6020      	str	r0, [r4, #0]
 80104ce:	88aa      	ldrh	r2, [r5, #4]
 80104d0:	79ab      	ldrb	r3, [r5, #6]
 80104d2:	80a2      	strh	r2, [r4, #4]
 80104d4:	71a3      	strb	r3, [r4, #6]
 80104d6:	4c43      	ldr	r4, [pc, #268]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80104d8:	4620      	mov	r0, r4
 80104da:	f00e ff26 	bl	801f32a <crs_strlen>
 80104de:	b283      	uxth	r3, r0
 80104e0:	4622      	mov	r2, r4
 80104e2:	2102      	movs	r1, #2
 80104e4:	4608      	mov	r0, r1
 80104e6:	f00e ff63 	bl	801f3b0 <traceIF_itmPrint>
 80104ea:	4620      	mov	r0, r4
 80104ec:	f00e ff1d 	bl	801f32a <crs_strlen>
 80104f0:	b283      	uxth	r3, r0
 80104f2:	4622      	mov	r2, r4
 80104f4:	2102      	movs	r1, #2
 80104f6:	4608      	mov	r0, r1
 80104f8:	f00e ff7c 	bl	801f3f4 <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.phone_number), 0, MAX_SIZE_PHONE_NBR);
 80104fc:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 8010500:	2240      	movs	r2, #64	; 0x40
 8010502:	2100      	movs	r1, #0
 8010504:	3002      	adds	r0, #2
 8010506:	f016 fa12 	bl	802692e <memset>
      break;
 801050a:	e72c      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for GSN, use unitialized value")
 801050c:	4e38      	ldr	r6, [pc, #224]	; (80105f0 <fRspAnalyze_CmeErr+0x524>)
 801050e:	4c35      	ldr	r4, [pc, #212]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 8010510:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8010514:	4635      	mov	r5, r6
 8010516:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010518:	6020      	str	r0, [r4, #0]
 801051a:	6061      	str	r1, [r4, #4]
 801051c:	60a2      	str	r2, [r4, #8]
 801051e:	60e3      	str	r3, [r4, #12]
 8010520:	462e      	mov	r6, r5
 8010522:	3410      	adds	r4, #16
 8010524:	4565      	cmp	r5, ip
 8010526:	d1f5      	bne.n	8010514 <fRspAnalyze_CmeErr+0x448>
 8010528:	6828      	ldr	r0, [r5, #0]
 801052a:	6020      	str	r0, [r4, #0]
 801052c:	88ab      	ldrh	r3, [r5, #4]
 801052e:	80a3      	strh	r3, [r4, #4]
 8010530:	4c2c      	ldr	r4, [pc, #176]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 8010532:	4620      	mov	r0, r4
 8010534:	f00e fef9 	bl	801f32a <crs_strlen>
 8010538:	b283      	uxth	r3, r0
 801053a:	4622      	mov	r2, r4
 801053c:	2102      	movs	r1, #2
 801053e:	4608      	mov	r0, r1
 8010540:	f00e ff36 	bl	801f3b0 <traceIF_itmPrint>
 8010544:	4620      	mov	r0, r4
 8010546:	f00e fef0 	bl	801f32a <crs_strlen>
 801054a:	b283      	uxth	r3, r0
 801054c:	4622      	mov	r2, r4
 801054e:	2102      	movs	r1, #2
 8010550:	4608      	mov	r0, r1
 8010552:	f00e ff4f 	bl	801f3f4 <traceIF_uartPrint>
      (void) memset((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei), 0, MAX_SIZE_IMEI);
 8010556:	f8d7 05c4 	ldr.w	r0, [r7, #1476]	; 0x5c4
 801055a:	2240      	movs	r2, #64	; 0x40
 801055c:	2100      	movs	r1, #0
 801055e:	3002      	adds	r0, #2
 8010560:	f016 f9e5 	bl	802692e <memset>
      break;
 8010564:	e6ff      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Analyze Modem Error for CPIN")
 8010566:	4e23      	ldr	r6, [pc, #140]	; (80105f4 <fRspAnalyze_CmeErr+0x528>)
 8010568:	4c1e      	ldr	r4, [pc, #120]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801056a:	f106 0720 	add.w	r7, r6, #32
 801056e:	4635      	mov	r5, r6
 8010570:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010572:	6020      	str	r0, [r4, #0]
 8010574:	6061      	str	r1, [r4, #4]
 8010576:	60a2      	str	r2, [r4, #8]
 8010578:	60e3      	str	r3, [r4, #12]
 801057a:	462e      	mov	r6, r5
 801057c:	3410      	adds	r4, #16
 801057e:	42bd      	cmp	r5, r7
 8010580:	d1f5      	bne.n	801056e <fRspAnalyze_CmeErr+0x4a2>
 8010582:	ce03      	ldmia	r6!, {r0, r1}
 8010584:	6020      	str	r0, [r4, #0]
 8010586:	6061      	str	r1, [r4, #4]
 8010588:	4c16      	ldr	r4, [pc, #88]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 801058a:	4620      	mov	r0, r4
 801058c:	f00e fecd 	bl	801f32a <crs_strlen>
 8010590:	b283      	uxth	r3, r0
 8010592:	4622      	mov	r2, r4
 8010594:	2102      	movs	r1, #2
 8010596:	4608      	mov	r0, r1
 8010598:	f00e ff0a 	bl	801f3b0 <traceIF_itmPrint>
 801059c:	4620      	mov	r0, r4
 801059e:	f00e fec4 	bl	801f32a <crs_strlen>
 80105a2:	b283      	uxth	r3, r0
 80105a4:	4622      	mov	r2, r4
 80105a6:	2102      	movs	r1, #2
 80105a8:	4608      	mov	r0, r1
 80105aa:	f00e ff23 	bl	801f3f4 <traceIF_uartPrint>
      break;
 80105ae:	e6da      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
      PRINT_DBG("Modem Error for cmd (id=%ld)", p_atp_ctxt->current_atcmd.id)
 80105b0:	4c0c      	ldr	r4, [pc, #48]	; (80105e4 <fRspAnalyze_CmeErr+0x518>)
 80105b2:	4911      	ldr	r1, [pc, #68]	; (80105f8 <fRspAnalyze_CmeErr+0x52c>)
 80105b4:	4620      	mov	r0, r4
 80105b6:	f016 f947 	bl	8026848 <sprintf>
 80105ba:	4620      	mov	r0, r4
 80105bc:	f00e feb5 	bl	801f32a <crs_strlen>
 80105c0:	b283      	uxth	r3, r0
 80105c2:	4622      	mov	r2, r4
 80105c4:	2102      	movs	r1, #2
 80105c6:	4608      	mov	r0, r1
 80105c8:	f00e fef2 	bl	801f3b0 <traceIF_itmPrint>
 80105cc:	4620      	mov	r0, r4
 80105ce:	f00e feac 	bl	801f32a <crs_strlen>
 80105d2:	b283      	uxth	r3, r0
 80105d4:	4622      	mov	r2, r4
 80105d6:	2102      	movs	r1, #2
 80105d8:	4608      	mov	r0, r1
 80105da:	f00e ff0b 	bl	801f3f4 <traceIF_uartPrint>
      break;
 80105de:	e6c2      	b.n	8010366 <fRspAnalyze_CmeErr+0x29a>
 80105e0:	0802fbdc 	.word	0x0802fbdc
 80105e4:	200048dc 	.word	0x200048dc
 80105e8:	0802fc14 	.word	0x0802fc14
 80105ec:	0802fc4c 	.word	0x0802fc4c
 80105f0:	0802fc84 	.word	0x0802fc84
 80105f4:	0802fcbc 	.word	0x0802fcbc
 80105f8:	0802fce4 	.word	0x0802fce4

080105fc <fRspAnalyze_Error>:
{
 80105fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010600:	4606      	mov	r6, r0
 8010602:	460f      	mov	r7, r1
 8010604:	4690      	mov	r8, r2
 8010606:	4699      	mov	r9, r3
  PRINT_API("enter fRspAnalyze_Error()")
 8010608:	4c17      	ldr	r4, [pc, #92]	; (8010668 <fRspAnalyze_Error+0x6c>)
 801060a:	4d18      	ldr	r5, [pc, #96]	; (801066c <fRspAnalyze_Error+0x70>)
 801060c:	f104 0e20 	add.w	lr, r4, #32
 8010610:	46a4      	mov	ip, r4
 8010612:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010616:	6028      	str	r0, [r5, #0]
 8010618:	6069      	str	r1, [r5, #4]
 801061a:	60aa      	str	r2, [r5, #8]
 801061c:	60eb      	str	r3, [r5, #12]
 801061e:	4664      	mov	r4, ip
 8010620:	3510      	adds	r5, #16
 8010622:	45f4      	cmp	ip, lr
 8010624:	d1f4      	bne.n	8010610 <fRspAnalyze_Error+0x14>
 8010626:	cc03      	ldmia	r4!, {r0, r1}
 8010628:	6028      	str	r0, [r5, #0]
 801062a:	6069      	str	r1, [r5, #4]
 801062c:	7823      	ldrb	r3, [r4, #0]
 801062e:	722b      	strb	r3, [r5, #8]
 8010630:	4c0e      	ldr	r4, [pc, #56]	; (801066c <fRspAnalyze_Error+0x70>)
 8010632:	4620      	mov	r0, r4
 8010634:	f00e fe79 	bl	801f32a <crs_strlen>
 8010638:	b283      	uxth	r3, r0
 801063a:	4622      	mov	r2, r4
 801063c:	2104      	movs	r1, #4
 801063e:	2002      	movs	r0, #2
 8010640:	f00e feb6 	bl	801f3b0 <traceIF_itmPrint>
 8010644:	4620      	mov	r0, r4
 8010646:	f00e fe70 	bl	801f32a <crs_strlen>
 801064a:	b283      	uxth	r3, r0
 801064c:	4622      	mov	r2, r4
 801064e:	2104      	movs	r1, #4
 8010650:	2002      	movs	r0, #2
 8010652:	f00e fecf 	bl	801f3f4 <traceIF_uartPrint>
  retval = fRspAnalyze_CmeErr(p_at_ctxt, p_modem_ctxt, p_msg_in, element_infos);
 8010656:	464b      	mov	r3, r9
 8010658:	4642      	mov	r2, r8
 801065a:	4639      	mov	r1, r7
 801065c:	4630      	mov	r0, r6
 801065e:	f7ff fd35 	bl	80100cc <fRspAnalyze_CmeErr>
}
 8010662:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010666:	bf00      	nop
 8010668:	0802fd0c 	.word	0x0802fd0c
 801066c:	200048dc 	.word	0x200048dc

08010670 <fRspAnalyze_CmsErr>:

at_action_rsp_t fRspAnalyze_CmsErr(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010670:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CmsErr()")
 8010672:	4c14      	ldr	r4, [pc, #80]	; (80106c4 <fRspAnalyze_CmsErr+0x54>)
 8010674:	4d14      	ldr	r5, [pc, #80]	; (80106c8 <fRspAnalyze_CmsErr+0x58>)
 8010676:	f104 0e20 	add.w	lr, r4, #32
 801067a:	46a4      	mov	ip, r4
 801067c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010680:	6028      	str	r0, [r5, #0]
 8010682:	6069      	str	r1, [r5, #4]
 8010684:	60aa      	str	r2, [r5, #8]
 8010686:	60eb      	str	r3, [r5, #12]
 8010688:	4664      	mov	r4, ip
 801068a:	3510      	adds	r5, #16
 801068c:	45f4      	cmp	ip, lr
 801068e:	d1f4      	bne.n	801067a <fRspAnalyze_CmsErr+0xa>
 8010690:	cc03      	ldmia	r4!, {r0, r1}
 8010692:	6028      	str	r0, [r5, #0]
 8010694:	6069      	str	r1, [r5, #4]
 8010696:	8823      	ldrh	r3, [r4, #0]
 8010698:	812b      	strh	r3, [r5, #8]
 801069a:	4c0b      	ldr	r4, [pc, #44]	; (80106c8 <fRspAnalyze_CmsErr+0x58>)
 801069c:	4620      	mov	r0, r4
 801069e:	f00e fe44 	bl	801f32a <crs_strlen>
 80106a2:	b283      	uxth	r3, r0
 80106a4:	4622      	mov	r2, r4
 80106a6:	2104      	movs	r1, #4
 80106a8:	2002      	movs	r0, #2
 80106aa:	f00e fe81 	bl	801f3b0 <traceIF_itmPrint>
 80106ae:	4620      	mov	r0, r4
 80106b0:	f00e fe3b 	bl	801f32a <crs_strlen>
 80106b4:	b283      	uxth	r3, r0
 80106b6:	4622      	mov	r2, r4
 80106b8:	2104      	movs	r1, #4
 80106ba:	2002      	movs	r0, #2
 80106bc:	f00e fe9a 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +CMS ERROR */
  /* Not implemented */

  return (retval);
}
 80106c0:	2010      	movs	r0, #16
 80106c2:	bd38      	pop	{r3, r4, r5, pc}
 80106c4:	0802fd38 	.word	0x0802fd38
 80106c8:	200048dc 	.word	0x200048dc

080106cc <fRspAnalyze_CGMI>:

at_action_rsp_t fRspAnalyze_CGMI(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80106cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80106d0:	4606      	mov	r6, r0
 80106d2:	4689      	mov	r9, r1
 80106d4:	4690      	mov	r8, r2
 80106d6:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGMI()")
 80106d8:	4c2c      	ldr	r4, [pc, #176]	; (801078c <fRspAnalyze_CGMI+0xc0>)
 80106da:	4d2d      	ldr	r5, [pc, #180]	; (8010790 <fRspAnalyze_CGMI+0xc4>)
 80106dc:	f104 0e20 	add.w	lr, r4, #32
 80106e0:	46a4      	mov	ip, r4
 80106e2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80106e6:	6028      	str	r0, [r5, #0]
 80106e8:	6069      	str	r1, [r5, #4]
 80106ea:	60aa      	str	r2, [r5, #8]
 80106ec:	60eb      	str	r3, [r5, #12]
 80106ee:	4664      	mov	r4, ip
 80106f0:	3510      	adds	r5, #16
 80106f2:	45f4      	cmp	ip, lr
 80106f4:	d1f4      	bne.n	80106e0 <fRspAnalyze_CGMI+0x14>
 80106f6:	cc03      	ldmia	r4!, {r0, r1}
 80106f8:	6028      	str	r0, [r5, #0]
 80106fa:	6069      	str	r1, [r5, #4]
 80106fc:	4c24      	ldr	r4, [pc, #144]	; (8010790 <fRspAnalyze_CGMI+0xc4>)
 80106fe:	4620      	mov	r0, r4
 8010700:	f00e fe13 	bl	801f32a <crs_strlen>
 8010704:	b283      	uxth	r3, r0
 8010706:	4622      	mov	r2, r4
 8010708:	2104      	movs	r1, #4
 801070a:	2002      	movs	r0, #2
 801070c:	f00e fe50 	bl	801f3b0 <traceIF_itmPrint>
 8010710:	4620      	mov	r0, r4
 8010712:	f00e fe0a 	bl	801f32a <crs_strlen>
 8010716:	b283      	uxth	r3, r0
 8010718:	4622      	mov	r2, r4
 801071a:	2104      	movs	r1, #4
 801071c:	2002      	movs	r0, #2
 801071e:	f00e fe69 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +CGMI */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8010722:	8b33      	ldrh	r3, [r6, #24]
 8010724:	2b04      	cmp	r3, #4
 8010726:	d002      	beq.n	801072e <fRspAnalyze_CGMI+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t)element_infos->str_size);
  }

  return (retval);
}
 8010728:	2010      	movs	r0, #16
 801072a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("Manufacturer name:")
 801072e:	4d19      	ldr	r5, [pc, #100]	; (8010794 <fRspAnalyze_CGMI+0xc8>)
 8010730:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010732:	6020      	str	r0, [r4, #0]
 8010734:	6061      	str	r1, [r4, #4]
 8010736:	60a2      	str	r2, [r4, #8]
 8010738:	60e3      	str	r3, [r4, #12]
 801073a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801073c:	6120      	str	r0, [r4, #16]
 801073e:	6161      	str	r1, [r4, #20]
 8010740:	61a2      	str	r2, [r4, #24]
 8010742:	882b      	ldrh	r3, [r5, #0]
 8010744:	83a3      	strh	r3, [r4, #28]
 8010746:	4620      	mov	r0, r4
 8010748:	f00e fdef 	bl	801f32a <crs_strlen>
 801074c:	b283      	uxth	r3, r0
 801074e:	4622      	mov	r2, r4
 8010750:	2102      	movs	r1, #2
 8010752:	4608      	mov	r0, r1
 8010754:	f00e fe2c 	bl	801f3b0 <traceIF_itmPrint>
 8010758:	4620      	mov	r0, r4
 801075a:	f00e fde6 	bl	801f32a <crs_strlen>
 801075e:	b283      	uxth	r3, r0
 8010760:	4622      	mov	r2, r4
 8010762:	2102      	movs	r1, #2
 8010764:	4608      	mov	r0, r1
 8010766:	f00e fe45 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 801076a:	897a      	ldrh	r2, [r7, #10]
 801076c:	89fb      	ldrh	r3, [r7, #14]
 801076e:	4442      	add	r2, r8
 8010770:	2102      	movs	r1, #2
 8010772:	4608      	mov	r0, r1
 8010774:	f00f f90a 	bl	801f98c <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.manufacturer_name),
 8010778:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 801077c:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.manufacturer_name),
 801077e:	89fa      	ldrh	r2, [r7, #14]
 8010780:	4441      	add	r1, r8
 8010782:	3002      	adds	r0, #2
 8010784:	f016 f9b0 	bl	8026ae8 <memcpy>
 8010788:	e7ce      	b.n	8010728 <fRspAnalyze_CGMI+0x5c>
 801078a:	bf00      	nop
 801078c:	0802fd64 	.word	0x0802fd64
 8010790:	200048dc 	.word	0x200048dc
 8010794:	0802fd8c 	.word	0x0802fd8c

08010798 <fRspAnalyze_CGMM>:

at_action_rsp_t fRspAnalyze_CGMM(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010798:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801079c:	4606      	mov	r6, r0
 801079e:	4689      	mov	r9, r1
 80107a0:	4690      	mov	r8, r2
 80107a2:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGMM()")
 80107a4:	4c2a      	ldr	r4, [pc, #168]	; (8010850 <fRspAnalyze_CGMM+0xb8>)
 80107a6:	4d2b      	ldr	r5, [pc, #172]	; (8010854 <fRspAnalyze_CGMM+0xbc>)
 80107a8:	f104 0e20 	add.w	lr, r4, #32
 80107ac:	46a4      	mov	ip, r4
 80107ae:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80107b2:	6028      	str	r0, [r5, #0]
 80107b4:	6069      	str	r1, [r5, #4]
 80107b6:	60aa      	str	r2, [r5, #8]
 80107b8:	60eb      	str	r3, [r5, #12]
 80107ba:	4664      	mov	r4, ip
 80107bc:	3510      	adds	r5, #16
 80107be:	45f4      	cmp	ip, lr
 80107c0:	d1f4      	bne.n	80107ac <fRspAnalyze_CGMM+0x14>
 80107c2:	cc03      	ldmia	r4!, {r0, r1}
 80107c4:	6028      	str	r0, [r5, #0]
 80107c6:	6069      	str	r1, [r5, #4]
 80107c8:	4c22      	ldr	r4, [pc, #136]	; (8010854 <fRspAnalyze_CGMM+0xbc>)
 80107ca:	4620      	mov	r0, r4
 80107cc:	f00e fdad 	bl	801f32a <crs_strlen>
 80107d0:	b283      	uxth	r3, r0
 80107d2:	4622      	mov	r2, r4
 80107d4:	2104      	movs	r1, #4
 80107d6:	2002      	movs	r0, #2
 80107d8:	f00e fdea 	bl	801f3b0 <traceIF_itmPrint>
 80107dc:	4620      	mov	r0, r4
 80107de:	f00e fda4 	bl	801f32a <crs_strlen>
 80107e2:	b283      	uxth	r3, r0
 80107e4:	4622      	mov	r2, r4
 80107e6:	2104      	movs	r1, #4
 80107e8:	2002      	movs	r0, #2
 80107ea:	f00e fe03 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +CGMM */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 80107ee:	8b33      	ldrh	r3, [r6, #24]
 80107f0:	2b04      	cmp	r3, #4
 80107f2:	d002      	beq.n	80107fa <fRspAnalyze_CGMM+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t)element_infos->str_size);
  }

  return (retval);
}
 80107f4:	2010      	movs	r0, #16
 80107f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("Model:")
 80107fa:	4d17      	ldr	r5, [pc, #92]	; (8010858 <fRspAnalyze_CGMM+0xc0>)
 80107fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80107fe:	6020      	str	r0, [r4, #0]
 8010800:	6061      	str	r1, [r4, #4]
 8010802:	60a2      	str	r2, [r4, #8]
 8010804:	60e3      	str	r3, [r4, #12]
 8010806:	882b      	ldrh	r3, [r5, #0]
 8010808:	8223      	strh	r3, [r4, #16]
 801080a:	4620      	mov	r0, r4
 801080c:	f00e fd8d 	bl	801f32a <crs_strlen>
 8010810:	b283      	uxth	r3, r0
 8010812:	4622      	mov	r2, r4
 8010814:	2102      	movs	r1, #2
 8010816:	4608      	mov	r0, r1
 8010818:	f00e fdca 	bl	801f3b0 <traceIF_itmPrint>
 801081c:	4620      	mov	r0, r4
 801081e:	f00e fd84 	bl	801f32a <crs_strlen>
 8010822:	b283      	uxth	r3, r0
 8010824:	4622      	mov	r2, r4
 8010826:	2102      	movs	r1, #2
 8010828:	4608      	mov	r0, r1
 801082a:	f00e fde3 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 801082e:	897a      	ldrh	r2, [r7, #10]
 8010830:	89fb      	ldrh	r3, [r7, #14]
 8010832:	4442      	add	r2, r8
 8010834:	2102      	movs	r1, #2
 8010836:	4608      	mov	r0, r1
 8010838:	f00f f8a8 	bl	801f98c <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.model),
 801083c:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010840:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.model),
 8010842:	89fa      	ldrh	r2, [r7, #14]
 8010844:	4441      	add	r1, r8
 8010846:	3002      	adds	r0, #2
 8010848:	f016 f94e 	bl	8026ae8 <memcpy>
 801084c:	e7d2      	b.n	80107f4 <fRspAnalyze_CGMM+0x5c>
 801084e:	bf00      	nop
 8010850:	0802fdac 	.word	0x0802fdac
 8010854:	200048dc 	.word	0x200048dc
 8010858:	0802fdd4 	.word	0x0802fdd4

0801085c <fRspAnalyze_CGMR>:

at_action_rsp_t fRspAnalyze_CGMR(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 801085c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010860:	4606      	mov	r6, r0
 8010862:	4689      	mov	r9, r1
 8010864:	4690      	mov	r8, r2
 8010866:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGMR()")
 8010868:	4c2b      	ldr	r4, [pc, #172]	; (8010918 <fRspAnalyze_CGMR+0xbc>)
 801086a:	4d2c      	ldr	r5, [pc, #176]	; (801091c <fRspAnalyze_CGMR+0xc0>)
 801086c:	f104 0e20 	add.w	lr, r4, #32
 8010870:	46a4      	mov	ip, r4
 8010872:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010876:	6028      	str	r0, [r5, #0]
 8010878:	6069      	str	r1, [r5, #4]
 801087a:	60aa      	str	r2, [r5, #8]
 801087c:	60eb      	str	r3, [r5, #12]
 801087e:	4664      	mov	r4, ip
 8010880:	3510      	adds	r5, #16
 8010882:	45f4      	cmp	ip, lr
 8010884:	d1f4      	bne.n	8010870 <fRspAnalyze_CGMR+0x14>
 8010886:	cc03      	ldmia	r4!, {r0, r1}
 8010888:	6028      	str	r0, [r5, #0]
 801088a:	6069      	str	r1, [r5, #4]
 801088c:	4c23      	ldr	r4, [pc, #140]	; (801091c <fRspAnalyze_CGMR+0xc0>)
 801088e:	4620      	mov	r0, r4
 8010890:	f00e fd4b 	bl	801f32a <crs_strlen>
 8010894:	b283      	uxth	r3, r0
 8010896:	4622      	mov	r2, r4
 8010898:	2104      	movs	r1, #4
 801089a:	2002      	movs	r0, #2
 801089c:	f00e fd88 	bl	801f3b0 <traceIF_itmPrint>
 80108a0:	4620      	mov	r0, r4
 80108a2:	f00e fd42 	bl	801f32a <crs_strlen>
 80108a6:	b283      	uxth	r3, r0
 80108a8:	4622      	mov	r2, r4
 80108aa:	2104      	movs	r1, #4
 80108ac:	2002      	movs	r0, #2
 80108ae:	f00e fda1 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +CGMR */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 80108b2:	8b33      	ldrh	r3, [r6, #24]
 80108b4:	2b04      	cmp	r3, #4
 80108b6:	d002      	beq.n	80108be <fRspAnalyze_CGMR+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t)element_infos->str_size);
  }

  return (retval);
}
 80108b8:	2010      	movs	r0, #16
 80108ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("Revision:")
 80108be:	4d18      	ldr	r5, [pc, #96]	; (8010920 <fRspAnalyze_CGMR+0xc4>)
 80108c0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80108c2:	6020      	str	r0, [r4, #0]
 80108c4:	6061      	str	r1, [r4, #4]
 80108c6:	60a2      	str	r2, [r4, #8]
 80108c8:	60e3      	str	r3, [r4, #12]
 80108ca:	6828      	ldr	r0, [r5, #0]
 80108cc:	6120      	str	r0, [r4, #16]
 80108ce:	792b      	ldrb	r3, [r5, #4]
 80108d0:	7523      	strb	r3, [r4, #20]
 80108d2:	4620      	mov	r0, r4
 80108d4:	f00e fd29 	bl	801f32a <crs_strlen>
 80108d8:	b283      	uxth	r3, r0
 80108da:	4622      	mov	r2, r4
 80108dc:	2102      	movs	r1, #2
 80108de:	4608      	mov	r0, r1
 80108e0:	f00e fd66 	bl	801f3b0 <traceIF_itmPrint>
 80108e4:	4620      	mov	r0, r4
 80108e6:	f00e fd20 	bl	801f32a <crs_strlen>
 80108ea:	b283      	uxth	r3, r0
 80108ec:	4622      	mov	r2, r4
 80108ee:	2102      	movs	r1, #2
 80108f0:	4608      	mov	r0, r1
 80108f2:	f00e fd7f 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 80108f6:	897a      	ldrh	r2, [r7, #10]
 80108f8:	89fb      	ldrh	r3, [r7, #14]
 80108fa:	4442      	add	r2, r8
 80108fc:	2102      	movs	r1, #2
 80108fe:	4608      	mov	r0, r1
 8010900:	f00f f844 	bl	801f98c <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.revision),
 8010904:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010908:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.revision),
 801090a:	89fa      	ldrh	r2, [r7, #14]
 801090c:	4441      	add	r1, r8
 801090e:	3002      	adds	r0, #2
 8010910:	f016 f8ea 	bl	8026ae8 <memcpy>
 8010914:	e7d0      	b.n	80108b8 <fRspAnalyze_CGMR+0x5c>
 8010916:	bf00      	nop
 8010918:	0802fde8 	.word	0x0802fde8
 801091c:	200048dc 	.word	0x200048dc
 8010920:	0802fe10 	.word	0x0802fe10

08010924 <fRspAnalyze_CGSN>:

at_action_rsp_t fRspAnalyze_CGSN(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010924:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010928:	b091      	sub	sp, #68	; 0x44
 801092a:	4606      	mov	r6, r0
 801092c:	4689      	mov	r9, r1
 801092e:	4690      	mov	r8, r2
 8010930:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGSN()")
 8010932:	4c9e      	ldr	r4, [pc, #632]	; (8010bac <fRspAnalyze_CGSN+0x288>)
 8010934:	4d9e      	ldr	r5, [pc, #632]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010936:	f104 0e20 	add.w	lr, r4, #32
 801093a:	46a4      	mov	ip, r4
 801093c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010940:	6028      	str	r0, [r5, #0]
 8010942:	6069      	str	r1, [r5, #4]
 8010944:	60aa      	str	r2, [r5, #8]
 8010946:	60eb      	str	r3, [r5, #12]
 8010948:	4664      	mov	r4, ip
 801094a:	3510      	adds	r5, #16
 801094c:	45f4      	cmp	ip, lr
 801094e:	d1f4      	bne.n	801093a <fRspAnalyze_CGSN+0x16>
 8010950:	cc03      	ldmia	r4!, {r0, r1}
 8010952:	6028      	str	r0, [r5, #0]
 8010954:	6069      	str	r1, [r5, #4]
 8010956:	4c96      	ldr	r4, [pc, #600]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010958:	4620      	mov	r0, r4
 801095a:	f00e fce6 	bl	801f32a <crs_strlen>
 801095e:	b283      	uxth	r3, r0
 8010960:	4622      	mov	r2, r4
 8010962:	2104      	movs	r1, #4
 8010964:	2002      	movs	r0, #2
 8010966:	f00e fd23 	bl	801f3b0 <traceIF_itmPrint>
 801096a:	4620      	mov	r0, r4
 801096c:	f00e fcdd 	bl	801f32a <crs_strlen>
 8010970:	b283      	uxth	r3, r0
 8010972:	4622      	mov	r2, r4
 8010974:	2104      	movs	r1, #4
 8010976:	2002      	movs	r0, #2
 8010978:	f00e fd3c 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +CGSN */
  /* only for write command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 801097c:	8b33      	ldrh	r3, [r6, #24]
 801097e:	2b03      	cmp	r3, #3
 8010980:	d007      	beq.n	8010992 <fRspAnalyze_CGSN+0x6e>
    }
    END_PARAM_LOOP()
  }

  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8010982:	8b33      	ldrh	r3, [r6, #24]
 8010984:	2b04      	cmp	r3, #4
 8010986:	f000 80e3 	beq.w	8010b50 <fRspAnalyze_CGSN+0x22c>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t) element_infos->str_size);
  }

  return (retval);
}
 801098a:	2010      	movs	r0, #16
 801098c:	b011      	add	sp, #68	; 0x44
 801098e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8010992:	2400      	movs	r4, #0
 8010994:	463a      	mov	r2, r7
 8010996:	4641      	mov	r1, r8
 8010998:	4630      	mov	r0, r6
 801099a:	f7fb fd55 	bl	800c448 <atcc_extractElement>
 801099e:	2801      	cmp	r0, #1
 80109a0:	d000      	beq.n	80109a4 <fRspAnalyze_CGSN+0x80>
 80109a2:	2401      	movs	r4, #1
 80109a4:	89fb      	ldrh	r3, [r7, #14]
 80109a6:	b113      	cbz	r3, 80109ae <fRspAnalyze_CGSN+0x8a>
    if (element_infos->param_rank == 2U)
 80109a8:	893b      	ldrh	r3, [r7, #8]
 80109aa:	2b02      	cmp	r3, #2
 80109ac:	d002      	beq.n	80109b4 <fRspAnalyze_CGSN+0x90>
    END_PARAM_LOOP()
 80109ae:	2c00      	cmp	r4, #0
 80109b0:	d1e7      	bne.n	8010982 <fRspAnalyze_CGSN+0x5e>
 80109b2:	e7ef      	b.n	8010994 <fRspAnalyze_CGSN+0x70>
      if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SN)
 80109b4:	f899 372c 	ldrb.w	r3, [r9, #1836]	; 0x72c
 80109b8:	b39b      	cbz	r3, 8010a22 <fRspAnalyze_CGSN+0xfe>
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEI)
 80109ba:	2b01      	cmp	r3, #1
 80109bc:	d063      	beq.n	8010a86 <fRspAnalyze_CGSN+0x162>
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_IMEISV)
 80109be:	2b02      	cmp	r3, #2
 80109c0:	f000 809b 	beq.w	8010afa <fRspAnalyze_CGSN+0x1d6>
      else if (p_modem_ctxt->CMD_ctxt.cgsn_write_cmd_param == CGSN_SVN)
 80109c4:	2b03      	cmp	r3, #3
 80109c6:	d1f2      	bne.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("SVN (NOT USED):")
 80109c8:	4d79      	ldr	r5, [pc, #484]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 80109ca:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 8010bb8 <fRspAnalyze_CGSN+0x294>
 80109ce:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80109d2:	6028      	str	r0, [r5, #0]
 80109d4:	6069      	str	r1, [r5, #4]
 80109d6:	60aa      	str	r2, [r5, #8]
 80109d8:	60eb      	str	r3, [r5, #12]
 80109da:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 80109de:	6128      	str	r0, [r5, #16]
 80109e0:	6169      	str	r1, [r5, #20]
 80109e2:	f8bc 2000 	ldrh.w	r2, [ip]
 80109e6:	f89c 3002 	ldrb.w	r3, [ip, #2]
 80109ea:	832a      	strh	r2, [r5, #24]
 80109ec:	76ab      	strb	r3, [r5, #26]
 80109ee:	4628      	mov	r0, r5
 80109f0:	f00e fc9b 	bl	801f32a <crs_strlen>
 80109f4:	b283      	uxth	r3, r0
 80109f6:	462a      	mov	r2, r5
 80109f8:	2102      	movs	r1, #2
 80109fa:	4608      	mov	r0, r1
 80109fc:	f00e fcd8 	bl	801f3b0 <traceIF_itmPrint>
 8010a00:	4628      	mov	r0, r5
 8010a02:	f00e fc92 	bl	801f32a <crs_strlen>
 8010a06:	b283      	uxth	r3, r0
 8010a08:	462a      	mov	r2, r5
 8010a0a:	2102      	movs	r1, #2
 8010a0c:	4608      	mov	r0, r1
 8010a0e:	f00e fcf1 	bl	801f3f4 <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010a12:	897a      	ldrh	r2, [r7, #10]
 8010a14:	89fb      	ldrh	r3, [r7, #14]
 8010a16:	4442      	add	r2, r8
 8010a18:	2102      	movs	r1, #2
 8010a1a:	4608      	mov	r0, r1
 8010a1c:	f00e ffb6 	bl	801f98c <traceIF_BufCharPrint>
 8010a20:	e7c5      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("Serial Number:")
 8010a22:	4d63      	ldr	r5, [pc, #396]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010a24:	f8df c18c 	ldr.w	ip, [pc, #396]	; 8010bb4 <fRspAnalyze_CGSN+0x290>
 8010a28:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010a2c:	6028      	str	r0, [r5, #0]
 8010a2e:	6069      	str	r1, [r5, #4]
 8010a30:	60aa      	str	r2, [r5, #8]
 8010a32:	60eb      	str	r3, [r5, #12]
 8010a34:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 8010a38:	6128      	str	r0, [r5, #16]
 8010a3a:	6169      	str	r1, [r5, #20]
 8010a3c:	f8bc 3000 	ldrh.w	r3, [ip]
 8010a40:	832b      	strh	r3, [r5, #24]
 8010a42:	4628      	mov	r0, r5
 8010a44:	f00e fc71 	bl	801f32a <crs_strlen>
 8010a48:	b283      	uxth	r3, r0
 8010a4a:	462a      	mov	r2, r5
 8010a4c:	2102      	movs	r1, #2
 8010a4e:	4608      	mov	r0, r1
 8010a50:	f00e fcae 	bl	801f3b0 <traceIF_itmPrint>
 8010a54:	4628      	mov	r0, r5
 8010a56:	f00e fc68 	bl	801f32a <crs_strlen>
 8010a5a:	b283      	uxth	r3, r0
 8010a5c:	462a      	mov	r2, r5
 8010a5e:	2102      	movs	r1, #2
 8010a60:	4608      	mov	r0, r1
 8010a62:	f00e fcc7 	bl	801f3f4 <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010a66:	897a      	ldrh	r2, [r7, #10]
 8010a68:	89fb      	ldrh	r3, [r7, #14]
 8010a6a:	4442      	add	r2, r8
 8010a6c:	2102      	movs	r1, #2
 8010a6e:	4608      	mov	r0, r1
 8010a70:	f00e ff8c 	bl	801f98c <traceIF_BufCharPrint>
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010a74:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                      (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010a78:	8979      	ldrh	r1, [r7, #10]
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010a7a:	89fa      	ldrh	r2, [r7, #14]
 8010a7c:	4441      	add	r1, r8
 8010a7e:	3002      	adds	r0, #2
 8010a80:	f016 f832 	bl	8026ae8 <memcpy>
 8010a84:	e793      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("IMEI:")
 8010a86:	4d4a      	ldr	r5, [pc, #296]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010a88:	f8df c130 	ldr.w	ip, [pc, #304]	; 8010bbc <fRspAnalyze_CGSN+0x298>
 8010a8c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010a90:	6028      	str	r0, [r5, #0]
 8010a92:	6069      	str	r1, [r5, #4]
 8010a94:	60aa      	str	r2, [r5, #8]
 8010a96:	60eb      	str	r3, [r5, #12]
 8010a98:	f89c 3000 	ldrb.w	r3, [ip]
 8010a9c:	742b      	strb	r3, [r5, #16]
 8010a9e:	4628      	mov	r0, r5
 8010aa0:	f00e fc43 	bl	801f32a <crs_strlen>
 8010aa4:	b283      	uxth	r3, r0
 8010aa6:	462a      	mov	r2, r5
 8010aa8:	2102      	movs	r1, #2
 8010aaa:	4608      	mov	r0, r1
 8010aac:	f00e fc80 	bl	801f3b0 <traceIF_itmPrint>
 8010ab0:	4628      	mov	r0, r5
 8010ab2:	f00e fc3a 	bl	801f32a <crs_strlen>
 8010ab6:	b283      	uxth	r3, r0
 8010ab8:	462a      	mov	r2, r5
 8010aba:	2102      	movs	r1, #2
 8010abc:	4608      	mov	r0, r1
 8010abe:	f00e fc99 	bl	801f3f4 <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010ac2:	897a      	ldrh	r2, [r7, #10]
 8010ac4:	89fb      	ldrh	r3, [r7, #14]
 8010ac6:	4442      	add	r2, r8
 8010ac8:	2102      	movs	r1, #2
 8010aca:	4608      	mov	r0, r1
 8010acc:	f00e ff5e 	bl	801f98c <traceIF_BufCharPrint>
        uint8_t tmp_array[MAX_SIZE_IMEI] = {0};
 8010ad0:	2100      	movs	r1, #0
 8010ad2:	9100      	str	r1, [sp, #0]
 8010ad4:	223c      	movs	r2, #60	; 0x3c
 8010ad6:	a801      	add	r0, sp, #4
 8010ad8:	f015 ff29 	bl	802692e <memset>
        uint16_t real_size = ATutil_remove_quotes((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010adc:	8978      	ldrh	r0, [r7, #10]
 8010ade:	89f9      	ldrh	r1, [r7, #14]
 8010ae0:	460b      	mov	r3, r1
 8010ae2:	466a      	mov	r2, sp
 8010ae4:	4440      	add	r0, r8
 8010ae6:	f004 f9ec 	bl	8014ec2 <ATutil_remove_quotes>
 8010aea:	4602      	mov	r2, r0
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei),
 8010aec:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
 8010af0:	4669      	mov	r1, sp
 8010af2:	3002      	adds	r0, #2
 8010af4:	f015 fff8 	bl	8026ae8 <memcpy>
 8010af8:	e759      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
        PRINT_DBG("IMEISV (NOT USED):")
 8010afa:	4d2d      	ldr	r5, [pc, #180]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010afc:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 8010bc0 <fRspAnalyze_CGSN+0x29c>
 8010b00:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010b04:	6028      	str	r0, [r5, #0]
 8010b06:	6069      	str	r1, [r5, #4]
 8010b08:	60aa      	str	r2, [r5, #8]
 8010b0a:	60eb      	str	r3, [r5, #12]
 8010b0c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010b10:	6128      	str	r0, [r5, #16]
 8010b12:	6169      	str	r1, [r5, #20]
 8010b14:	61aa      	str	r2, [r5, #24]
 8010b16:	f8bc 3000 	ldrh.w	r3, [ip]
 8010b1a:	83ab      	strh	r3, [r5, #28]
 8010b1c:	4628      	mov	r0, r5
 8010b1e:	f00e fc04 	bl	801f32a <crs_strlen>
 8010b22:	b283      	uxth	r3, r0
 8010b24:	462a      	mov	r2, r5
 8010b26:	2102      	movs	r1, #2
 8010b28:	4608      	mov	r0, r1
 8010b2a:	f00e fc41 	bl	801f3b0 <traceIF_itmPrint>
 8010b2e:	4628      	mov	r0, r5
 8010b30:	f00e fbfb 	bl	801f32a <crs_strlen>
 8010b34:	b283      	uxth	r3, r0
 8010b36:	462a      	mov	r2, r5
 8010b38:	2102      	movs	r1, #2
 8010b3a:	4608      	mov	r0, r1
 8010b3c:	f00e fc5a 	bl	801f3f4 <traceIF_uartPrint>
        PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010b40:	897a      	ldrh	r2, [r7, #10]
 8010b42:	89fb      	ldrh	r3, [r7, #14]
 8010b44:	4442      	add	r2, r8
 8010b46:	2102      	movs	r1, #2
 8010b48:	4608      	mov	r0, r1
 8010b4a:	f00e ff1f 	bl	801f98c <traceIF_BufCharPrint>
 8010b4e:	e72e      	b.n	80109ae <fRspAnalyze_CGSN+0x8a>
    PRINT_DBG("Serial Number:")
 8010b50:	4c17      	ldr	r4, [pc, #92]	; (8010bb0 <fRspAnalyze_CGSN+0x28c>)
 8010b52:	4d18      	ldr	r5, [pc, #96]	; (8010bb4 <fRspAnalyze_CGSN+0x290>)
 8010b54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010b56:	6020      	str	r0, [r4, #0]
 8010b58:	6061      	str	r1, [r4, #4]
 8010b5a:	60a2      	str	r2, [r4, #8]
 8010b5c:	60e3      	str	r3, [r4, #12]
 8010b5e:	cd03      	ldmia	r5!, {r0, r1}
 8010b60:	6120      	str	r0, [r4, #16]
 8010b62:	6161      	str	r1, [r4, #20]
 8010b64:	882b      	ldrh	r3, [r5, #0]
 8010b66:	8323      	strh	r3, [r4, #24]
 8010b68:	4620      	mov	r0, r4
 8010b6a:	f00e fbde 	bl	801f32a <crs_strlen>
 8010b6e:	b283      	uxth	r3, r0
 8010b70:	4622      	mov	r2, r4
 8010b72:	2102      	movs	r1, #2
 8010b74:	4608      	mov	r0, r1
 8010b76:	f00e fc1b 	bl	801f3b0 <traceIF_itmPrint>
 8010b7a:	4620      	mov	r0, r4
 8010b7c:	f00e fbd5 	bl	801f32a <crs_strlen>
 8010b80:	b283      	uxth	r3, r0
 8010b82:	4622      	mov	r2, r4
 8010b84:	2102      	movs	r1, #2
 8010b86:	4608      	mov	r0, r1
 8010b88:	f00e fc34 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010b8c:	897a      	ldrh	r2, [r7, #10]
 8010b8e:	89fb      	ldrh	r3, [r7, #14]
 8010b90:	4442      	add	r2, r8
 8010b92:	2102      	movs	r1, #2
 8010b94:	4608      	mov	r0, r1
 8010b96:	f00e fef9 	bl	801f98c <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010b9a:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010b9e:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.serial_number),
 8010ba0:	89fa      	ldrh	r2, [r7, #14]
 8010ba2:	4441      	add	r1, r8
 8010ba4:	3002      	adds	r0, #2
 8010ba6:	f015 ff9f 	bl	8026ae8 <memcpy>
 8010baa:	e6ee      	b.n	801098a <fRspAnalyze_CGSN+0x66>
 8010bac:	0802fe28 	.word	0x0802fe28
 8010bb0:	200048dc 	.word	0x200048dc
 8010bb4:	0802fe50 	.word	0x0802fe50
 8010bb8:	0802fea0 	.word	0x0802fea0
 8010bbc:	0802fe6c 	.word	0x0802fe6c
 8010bc0:	0802fe80 	.word	0x0802fe80

08010bc4 <fRspAnalyze_CIMI>:

at_action_rsp_t fRspAnalyze_CIMI(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010bc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8010bc8:	4606      	mov	r6, r0
 8010bca:	4689      	mov	r9, r1
 8010bcc:	4690      	mov	r8, r2
 8010bce:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CIMI()")
 8010bd0:	4c2a      	ldr	r4, [pc, #168]	; (8010c7c <fRspAnalyze_CIMI+0xb8>)
 8010bd2:	4d2b      	ldr	r5, [pc, #172]	; (8010c80 <fRspAnalyze_CIMI+0xbc>)
 8010bd4:	f104 0e20 	add.w	lr, r4, #32
 8010bd8:	46a4      	mov	ip, r4
 8010bda:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010bde:	6028      	str	r0, [r5, #0]
 8010be0:	6069      	str	r1, [r5, #4]
 8010be2:	60aa      	str	r2, [r5, #8]
 8010be4:	60eb      	str	r3, [r5, #12]
 8010be6:	4664      	mov	r4, ip
 8010be8:	3510      	adds	r5, #16
 8010bea:	45f4      	cmp	ip, lr
 8010bec:	d1f4      	bne.n	8010bd8 <fRspAnalyze_CIMI+0x14>
 8010bee:	cc03      	ldmia	r4!, {r0, r1}
 8010bf0:	6028      	str	r0, [r5, #0]
 8010bf2:	6069      	str	r1, [r5, #4]
 8010bf4:	4c22      	ldr	r4, [pc, #136]	; (8010c80 <fRspAnalyze_CIMI+0xbc>)
 8010bf6:	4620      	mov	r0, r4
 8010bf8:	f00e fb97 	bl	801f32a <crs_strlen>
 8010bfc:	b283      	uxth	r3, r0
 8010bfe:	4622      	mov	r2, r4
 8010c00:	2104      	movs	r1, #4
 8010c02:	2002      	movs	r0, #2
 8010c04:	f00e fbd4 	bl	801f3b0 <traceIF_itmPrint>
 8010c08:	4620      	mov	r0, r4
 8010c0a:	f00e fb8e 	bl	801f32a <crs_strlen>
 8010c0e:	b283      	uxth	r3, r0
 8010c10:	4622      	mov	r2, r4
 8010c12:	2104      	movs	r1, #4
 8010c14:	2002      	movs	r0, #2
 8010c16:	f00e fbed 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +CIMI */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8010c1a:	8b33      	ldrh	r3, [r6, #24]
 8010c1c:	2b04      	cmp	r3, #4
 8010c1e:	d002      	beq.n	8010c26 <fRspAnalyze_CIMI+0x62>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t) element_infos->str_size);
  }

  return (retval);
}
 8010c20:	2010      	movs	r0, #16
 8010c22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("IMSI:")
 8010c26:	4d17      	ldr	r5, [pc, #92]	; (8010c84 <fRspAnalyze_CIMI+0xc0>)
 8010c28:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010c2a:	6020      	str	r0, [r4, #0]
 8010c2c:	6061      	str	r1, [r4, #4]
 8010c2e:	60a2      	str	r2, [r4, #8]
 8010c30:	60e3      	str	r3, [r4, #12]
 8010c32:	782b      	ldrb	r3, [r5, #0]
 8010c34:	7423      	strb	r3, [r4, #16]
 8010c36:	4620      	mov	r0, r4
 8010c38:	f00e fb77 	bl	801f32a <crs_strlen>
 8010c3c:	b283      	uxth	r3, r0
 8010c3e:	4622      	mov	r2, r4
 8010c40:	2102      	movs	r1, #2
 8010c42:	4608      	mov	r0, r1
 8010c44:	f00e fbb4 	bl	801f3b0 <traceIF_itmPrint>
 8010c48:	4620      	mov	r0, r4
 8010c4a:	f00e fb6e 	bl	801f32a <crs_strlen>
 8010c4e:	b283      	uxth	r3, r0
 8010c50:	4622      	mov	r2, r4
 8010c52:	2102      	movs	r1, #2
 8010c54:	4608      	mov	r0, r1
 8010c56:	f00e fbcd 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010c5a:	897a      	ldrh	r2, [r7, #10]
 8010c5c:	89fb      	ldrh	r3, [r7, #14]
 8010c5e:	4442      	add	r2, r8
 8010c60:	2102      	movs	r1, #2
 8010c62:	4608      	mov	r0, r1
 8010c64:	f00e fe92 	bl	801f98c <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imsi),
 8010c68:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8010c6c:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imsi),
 8010c6e:	89fa      	ldrh	r2, [r7, #14]
 8010c70:	4441      	add	r1, r8
 8010c72:	3002      	adds	r0, #2
 8010c74:	f015 ff38 	bl	8026ae8 <memcpy>
 8010c78:	e7d2      	b.n	8010c20 <fRspAnalyze_CIMI+0x5c>
 8010c7a:	bf00      	nop
 8010c7c:	0802febc 	.word	0x0802febc
 8010c80:	200048dc 	.word	0x200048dc
 8010c84:	0802fee4 	.word	0x0802fee4

08010c88 <fRspAnalyze_CEER>:

at_action_rsp_t fRspAnalyze_CEER(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010c88:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEER()")
 8010c8a:	4c13      	ldr	r4, [pc, #76]	; (8010cd8 <fRspAnalyze_CEER+0x50>)
 8010c8c:	4d13      	ldr	r5, [pc, #76]	; (8010cdc <fRspAnalyze_CEER+0x54>)
 8010c8e:	f104 0e20 	add.w	lr, r4, #32
 8010c92:	46a4      	mov	ip, r4
 8010c94:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010c98:	6028      	str	r0, [r5, #0]
 8010c9a:	6069      	str	r1, [r5, #4]
 8010c9c:	60aa      	str	r2, [r5, #8]
 8010c9e:	60eb      	str	r3, [r5, #12]
 8010ca0:	4664      	mov	r4, ip
 8010ca2:	3510      	adds	r5, #16
 8010ca4:	45f4      	cmp	ip, lr
 8010ca6:	d1f4      	bne.n	8010c92 <fRspAnalyze_CEER+0xa>
 8010ca8:	cc03      	ldmia	r4!, {r0, r1}
 8010caa:	6028      	str	r0, [r5, #0]
 8010cac:	6069      	str	r1, [r5, #4]
 8010cae:	4c0b      	ldr	r4, [pc, #44]	; (8010cdc <fRspAnalyze_CEER+0x54>)
 8010cb0:	4620      	mov	r0, r4
 8010cb2:	f00e fb3a 	bl	801f32a <crs_strlen>
 8010cb6:	b283      	uxth	r3, r0
 8010cb8:	4622      	mov	r2, r4
 8010cba:	2104      	movs	r1, #4
 8010cbc:	2002      	movs	r0, #2
 8010cbe:	f00e fb77 	bl	801f3b0 <traceIF_itmPrint>
 8010cc2:	4620      	mov	r0, r4
 8010cc4:	f00e fb31 	bl	801f32a <crs_strlen>
 8010cc8:	b283      	uxth	r3, r0
 8010cca:	4622      	mov	r2, r4
 8010ccc:	2104      	movs	r1, #4
 8010cce:	2002      	movs	r0, #2
 8010cd0:	f00e fb90 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for CEER */

  return (retval);
}
 8010cd4:	2010      	movs	r0, #16
 8010cd6:	bd38      	pop	{r3, r4, r5, pc}
 8010cd8:	0802fef8 	.word	0x0802fef8
 8010cdc:	200048dc 	.word	0x200048dc

08010ce0 <fRspAnalyze_CPIN>:

at_action_rsp_t fRspAnalyze_CPIN(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8010ce0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010ce4:	b088      	sub	sp, #32
 8010ce6:	4680      	mov	r8, r0
 8010ce8:	4689      	mov	r9, r1
 8010cea:	4617      	mov	r7, r2
 8010cec:	461e      	mov	r6, r3
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CPIN()")
 8010cee:	4cbe      	ldr	r4, [pc, #760]	; (8010fe8 <fRspAnalyze_CPIN+0x308>)
 8010cf0:	4dbe      	ldr	r5, [pc, #760]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010cf2:	f104 0e20 	add.w	lr, r4, #32
 8010cf6:	46a4      	mov	ip, r4
 8010cf8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010cfc:	6028      	str	r0, [r5, #0]
 8010cfe:	6069      	str	r1, [r5, #4]
 8010d00:	60aa      	str	r2, [r5, #8]
 8010d02:	60eb      	str	r3, [r5, #12]
 8010d04:	4664      	mov	r4, ip
 8010d06:	3510      	adds	r5, #16
 8010d08:	45f4      	cmp	ip, lr
 8010d0a:	d1f4      	bne.n	8010cf6 <fRspAnalyze_CPIN+0x16>
 8010d0c:	cc03      	ldmia	r4!, {r0, r1}
 8010d0e:	6028      	str	r0, [r5, #0]
 8010d10:	6069      	str	r1, [r5, #4]
 8010d12:	4cb6      	ldr	r4, [pc, #728]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010d14:	4620      	mov	r0, r4
 8010d16:	f00e fb08 	bl	801f32a <crs_strlen>
 8010d1a:	b283      	uxth	r3, r0
 8010d1c:	4622      	mov	r2, r4
 8010d1e:	2104      	movs	r1, #4
 8010d20:	2002      	movs	r0, #2
 8010d22:	f00e fb45 	bl	801f3b0 <traceIF_itmPrint>
 8010d26:	4620      	mov	r0, r4
 8010d28:	f00e faff 	bl	801f32a <crs_strlen>
 8010d2c:	b283      	uxth	r3, r0
 8010d2e:	4622      	mov	r2, r4
 8010d30:	2104      	movs	r1, #4
 8010d32:	2002      	movs	r0, #2
 8010d34:	f00e fb5e 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for CPIN */
  START_PARAM_LOOP()
 8010d38:	2400      	movs	r4, #0
 8010d3a:	4632      	mov	r2, r6
 8010d3c:	4639      	mov	r1, r7
 8010d3e:	4640      	mov	r0, r8
 8010d40:	f7fb fb82 	bl	800c448 <atcc_extractElement>
 8010d44:	2801      	cmp	r0, #1
 8010d46:	d000      	beq.n	8010d4a <fRspAnalyze_CPIN+0x6a>
 8010d48:	2401      	movs	r4, #1
 8010d4a:	89f3      	ldrh	r3, [r6, #14]
 8010d4c:	b113      	cbz	r3, 8010d54 <fRspAnalyze_CPIN+0x74>
  if (element_infos->param_rank == 2U)
 8010d4e:	8933      	ldrh	r3, [r6, #8]
 8010d50:	2b02      	cmp	r3, #2
 8010d52:	d005      	beq.n	8010d60 <fRspAnalyze_CPIN+0x80>
      PRINT_ERR("line exceed maximum size, line ignored...")
      retval = ATACTION_RSP_IGNORED;
    }

  }
  END_PARAM_LOOP()
 8010d54:	2c00      	cmp	r4, #0
 8010d56:	d0f0      	beq.n	8010d3a <fRspAnalyze_CPIN+0x5a>
  return (retval);
}
 8010d58:	2010      	movs	r0, #16
 8010d5a:	b008      	add	sp, #32
 8010d5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    AT_CHAR_t line[32] = {0U};
 8010d60:	2300      	movs	r3, #0
 8010d62:	9300      	str	r3, [sp, #0]
 8010d64:	9301      	str	r3, [sp, #4]
 8010d66:	9302      	str	r3, [sp, #8]
 8010d68:	9303      	str	r3, [sp, #12]
 8010d6a:	9304      	str	r3, [sp, #16]
 8010d6c:	9305      	str	r3, [sp, #20]
 8010d6e:	9306      	str	r3, [sp, #24]
 8010d70:	9307      	str	r3, [sp, #28]
    PRINT_DBG("CPIN parameter received:")
 8010d72:	f8df e290 	ldr.w	lr, [pc, #656]	; 8011004 <fRspAnalyze_CPIN+0x324>
 8010d76:	f8df c274 	ldr.w	ip, [pc, #628]	; 8010fec <fRspAnalyze_CPIN+0x30c>
 8010d7a:	f10e 0a20 	add.w	sl, lr, #32
 8010d7e:	4675      	mov	r5, lr
 8010d80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8010d82:	f8cc 0000 	str.w	r0, [ip]
 8010d86:	f8cc 1004 	str.w	r1, [ip, #4]
 8010d8a:	f8cc 2008 	str.w	r2, [ip, #8]
 8010d8e:	f8cc 300c 	str.w	r3, [ip, #12]
 8010d92:	46ae      	mov	lr, r5
 8010d94:	f10c 0c10 	add.w	ip, ip, #16
 8010d98:	4555      	cmp	r5, sl
 8010d9a:	d1f0      	bne.n	8010d7e <fRspAnalyze_CPIN+0x9e>
 8010d9c:	6828      	ldr	r0, [r5, #0]
 8010d9e:	f8cc 0000 	str.w	r0, [ip]
 8010da2:	4d92      	ldr	r5, [pc, #584]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010da4:	4628      	mov	r0, r5
 8010da6:	f00e fac0 	bl	801f32a <crs_strlen>
 8010daa:	b283      	uxth	r3, r0
 8010dac:	462a      	mov	r2, r5
 8010dae:	2102      	movs	r1, #2
 8010db0:	4608      	mov	r0, r1
 8010db2:	f00e fafd 	bl	801f3b0 <traceIF_itmPrint>
 8010db6:	4628      	mov	r0, r5
 8010db8:	f00e fab7 	bl	801f32a <crs_strlen>
 8010dbc:	b283      	uxth	r3, r0
 8010dbe:	462a      	mov	r2, r5
 8010dc0:	2102      	movs	r1, #2
 8010dc2:	4608      	mov	r0, r1
 8010dc4:	f00e fb16 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8010dc8:	8972      	ldrh	r2, [r6, #10]
 8010dca:	89f3      	ldrh	r3, [r6, #14]
 8010dcc:	443a      	add	r2, r7
 8010dce:	2102      	movs	r1, #2
 8010dd0:	4608      	mov	r0, r1
 8010dd2:	f00e fddb 	bl	801f98c <traceIF_BufCharPrint>
    if (element_infos->str_size <= 32U)
 8010dd6:	89f2      	ldrh	r2, [r6, #14]
 8010dd8:	2a20      	cmp	r2, #32
 8010dda:	f200 8153 	bhi.w	8011084 <fRspAnalyze_CPIN+0x3a4>
                    (const void *) & (p_msg_in->buffer[element_infos->str_start_idx]),
 8010dde:	8971      	ldrh	r1, [r6, #10]
      (void) memcpy((void *)&line[0],
 8010de0:	4439      	add	r1, r7
 8010de2:	4668      	mov	r0, sp
 8010de4:	f015 fe80 	bl	8026ae8 <memcpy>
      if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN") != NULL)
 8010de8:	4981      	ldr	r1, [pc, #516]	; (8010ff0 <fRspAnalyze_CPIN+0x310>)
 8010dea:	4668      	mov	r0, sp
 8010dec:	f015 fdea 	bl	80269c4 <strstr>
 8010df0:	b378      	cbz	r0, 8010e52 <fRspAnalyze_CPIN+0x172>
        PRINT_DBG("waiting for SIM PIN")
 8010df2:	f8df c214 	ldr.w	ip, [pc, #532]	; 8011008 <fRspAnalyze_CPIN+0x328>
 8010df6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010dfa:	6028      	str	r0, [r5, #0]
 8010dfc:	6069      	str	r1, [r5, #4]
 8010dfe:	60aa      	str	r2, [r5, #8]
 8010e00:	60eb      	str	r3, [r5, #12]
 8010e02:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010e06:	6128      	str	r0, [r5, #16]
 8010e08:	6169      	str	r1, [r5, #20]
 8010e0a:	61aa      	str	r2, [r5, #24]
 8010e0c:	f8bc 2000 	ldrh.w	r2, [ip]
 8010e10:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8010e14:	83aa      	strh	r2, [r5, #28]
 8010e16:	77ab      	strb	r3, [r5, #30]
 8010e18:	4628      	mov	r0, r5
 8010e1a:	f00e fa86 	bl	801f32a <crs_strlen>
 8010e1e:	b283      	uxth	r3, r0
 8010e20:	462a      	mov	r2, r5
 8010e22:	2102      	movs	r1, #2
 8010e24:	4608      	mov	r0, r1
 8010e26:	f00e fac3 	bl	801f3b0 <traceIF_itmPrint>
 8010e2a:	4628      	mov	r0, r5
 8010e2c:	f00e fa7d 	bl	801f32a <crs_strlen>
 8010e30:	b283      	uxth	r3, r0
 8010e32:	462a      	mov	r2, r5
 8010e34:	2102      	movs	r1, #2
 8010e36:	4608      	mov	r0, r1
 8010e38:	f00e fadc 	bl	801f3f4 <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010e3c:	2300      	movs	r3, #0
 8010e3e:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PIN_REQUIRED;
 8010e42:	2306      	movs	r3, #6
 8010e44:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010e48:	4649      	mov	r1, r9
 8010e4a:	2001      	movs	r0, #1
 8010e4c:	f7fd fb94 	bl	800e578 <set_error_report>
 8010e50:	e780      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK") != NULL)
 8010e52:	4968      	ldr	r1, [pc, #416]	; (8010ff4 <fRspAnalyze_CPIN+0x314>)
 8010e54:	4668      	mov	r0, sp
 8010e56:	f015 fdb5 	bl	80269c4 <strstr>
 8010e5a:	b380      	cbz	r0, 8010ebe <fRspAnalyze_CPIN+0x1de>
        PRINT_DBG("waiting for SIM PUK")
 8010e5c:	4d63      	ldr	r5, [pc, #396]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010e5e:	f8df c1ac 	ldr.w	ip, [pc, #428]	; 801100c <fRspAnalyze_CPIN+0x32c>
 8010e62:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010e66:	6028      	str	r0, [r5, #0]
 8010e68:	6069      	str	r1, [r5, #4]
 8010e6a:	60aa      	str	r2, [r5, #8]
 8010e6c:	60eb      	str	r3, [r5, #12]
 8010e6e:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010e72:	6128      	str	r0, [r5, #16]
 8010e74:	6169      	str	r1, [r5, #20]
 8010e76:	61aa      	str	r2, [r5, #24]
 8010e78:	f8bc 2000 	ldrh.w	r2, [ip]
 8010e7c:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8010e80:	83aa      	strh	r2, [r5, #28]
 8010e82:	77ab      	strb	r3, [r5, #30]
 8010e84:	4628      	mov	r0, r5
 8010e86:	f00e fa50 	bl	801f32a <crs_strlen>
 8010e8a:	b283      	uxth	r3, r0
 8010e8c:	462a      	mov	r2, r5
 8010e8e:	2102      	movs	r1, #2
 8010e90:	4608      	mov	r0, r1
 8010e92:	f00e fa8d 	bl	801f3b0 <traceIF_itmPrint>
 8010e96:	4628      	mov	r0, r5
 8010e98:	f00e fa47 	bl	801f32a <crs_strlen>
 8010e9c:	b283      	uxth	r3, r0
 8010e9e:	462a      	mov	r2, r5
 8010ea0:	2102      	movs	r1, #2
 8010ea2:	4608      	mov	r0, r1
 8010ea4:	f00e faa6 	bl	801f3f4 <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010ea8:	2300      	movs	r3, #0
 8010eaa:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK_REQUIRED;
 8010eae:	2308      	movs	r3, #8
 8010eb0:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010eb4:	4649      	mov	r1, r9
 8010eb6:	2001      	movs	r0, #1
 8010eb8:	f7fd fb5e 	bl	800e578 <set_error_report>
 8010ebc:	e74a      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PIN2") != NULL)
 8010ebe:	494e      	ldr	r1, [pc, #312]	; (8010ff8 <fRspAnalyze_CPIN+0x318>)
 8010ec0:	4668      	mov	r0, sp
 8010ec2:	f015 fd7f 	bl	80269c4 <strstr>
 8010ec6:	b358      	cbz	r0, 8010f20 <fRspAnalyze_CPIN+0x240>
        PRINT_DBG("waiting for SIM PUK2")
 8010ec8:	4d48      	ldr	r5, [pc, #288]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010eca:	f8df c144 	ldr.w	ip, [pc, #324]	; 8011010 <fRspAnalyze_CPIN+0x330>
 8010ece:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010ed2:	6028      	str	r0, [r5, #0]
 8010ed4:	6069      	str	r1, [r5, #4]
 8010ed6:	60aa      	str	r2, [r5, #8]
 8010ed8:	60eb      	str	r3, [r5, #12]
 8010eda:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010ede:	6128      	str	r0, [r5, #16]
 8010ee0:	6169      	str	r1, [r5, #20]
 8010ee2:	61aa      	str	r2, [r5, #24]
 8010ee4:	61eb      	str	r3, [r5, #28]
 8010ee6:	4628      	mov	r0, r5
 8010ee8:	f00e fa1f 	bl	801f32a <crs_strlen>
 8010eec:	b283      	uxth	r3, r0
 8010eee:	462a      	mov	r2, r5
 8010ef0:	2102      	movs	r1, #2
 8010ef2:	4608      	mov	r0, r1
 8010ef4:	f00e fa5c 	bl	801f3b0 <traceIF_itmPrint>
 8010ef8:	4628      	mov	r0, r5
 8010efa:	f00e fa16 	bl	801f32a <crs_strlen>
 8010efe:	b283      	uxth	r3, r0
 8010f00:	462a      	mov	r2, r5
 8010f02:	2102      	movs	r1, #2
 8010f04:	4608      	mov	r0, r1
 8010f06:	f00e fa75 	bl	801f3f4 <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010f0a:	2300      	movs	r3, #0
 8010f0c:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK2_REQUIRED;
 8010f10:	2309      	movs	r3, #9
 8010f12:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010f16:	4649      	mov	r1, r9
 8010f18:	2001      	movs	r0, #1
 8010f1a:	f7fd fb2d 	bl	800e578 <set_error_report>
 8010f1e:	e719      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "SIM PUK2") != NULL)
 8010f20:	4936      	ldr	r1, [pc, #216]	; (8010ffc <fRspAnalyze_CPIN+0x31c>)
 8010f22:	4668      	mov	r0, sp
 8010f24:	f015 fd4e 	bl	80269c4 <strstr>
 8010f28:	b380      	cbz	r0, 8010f8c <fRspAnalyze_CPIN+0x2ac>
        PRINT_DBG("waiting for SIM PUK")
 8010f2a:	4d30      	ldr	r5, [pc, #192]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010f2c:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 801100c <fRspAnalyze_CPIN+0x32c>
 8010f30:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010f34:	6028      	str	r0, [r5, #0]
 8010f36:	6069      	str	r1, [r5, #4]
 8010f38:	60aa      	str	r2, [r5, #8]
 8010f3a:	60eb      	str	r3, [r5, #12]
 8010f3c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8010f40:	6128      	str	r0, [r5, #16]
 8010f42:	6169      	str	r1, [r5, #20]
 8010f44:	61aa      	str	r2, [r5, #24]
 8010f46:	f8bc 2000 	ldrh.w	r2, [ip]
 8010f4a:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8010f4e:	83aa      	strh	r2, [r5, #28]
 8010f50:	77ab      	strb	r3, [r5, #30]
 8010f52:	4628      	mov	r0, r5
 8010f54:	f00e f9e9 	bl	801f32a <crs_strlen>
 8010f58:	b283      	uxth	r3, r0
 8010f5a:	462a      	mov	r2, r5
 8010f5c:	2102      	movs	r1, #2
 8010f5e:	4608      	mov	r0, r1
 8010f60:	f00e fa26 	bl	801f3b0 <traceIF_itmPrint>
 8010f64:	4628      	mov	r0, r5
 8010f66:	f00e f9e0 	bl	801f32a <crs_strlen>
 8010f6a:	b283      	uxth	r3, r0
 8010f6c:	462a      	mov	r2, r5
 8010f6e:	2102      	movs	r1, #2
 8010f70:	4608      	mov	r0, r1
 8010f72:	f00e fa3f 	bl	801f3f4 <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8010f76:	2300      	movs	r3, #0
 8010f78:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_SIM_PUK_REQUIRED;
 8010f7c:	2308      	movs	r3, #8
 8010f7e:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 8010f82:	4649      	mov	r1, r9
 8010f84:	2001      	movs	r0, #1
 8010f86:	f7fd faf7 	bl	800e578 <set_error_report>
 8010f8a:	e6e3      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      else if ((AT_CHAR_t *) strstr((const CRC_CHAR_t *)&line[0], "READY") != NULL)
 8010f8c:	491c      	ldr	r1, [pc, #112]	; (8011000 <fRspAnalyze_CPIN+0x320>)
 8010f8e:	4668      	mov	r0, sp
 8010f90:	f015 fd18 	bl	80269c4 <strstr>
 8010f94:	2800      	cmp	r0, #0
 8010f96:	d03f      	beq.n	8011018 <fRspAnalyze_CPIN+0x338>
        PRINT_DBG("CPIN READY")
 8010f98:	4d14      	ldr	r5, [pc, #80]	; (8010fec <fRspAnalyze_CPIN+0x30c>)
 8010f9a:	f8df c078 	ldr.w	ip, [pc, #120]	; 8011014 <fRspAnalyze_CPIN+0x334>
 8010f9e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8010fa2:	6028      	str	r0, [r5, #0]
 8010fa4:	6069      	str	r1, [r5, #4]
 8010fa6:	60aa      	str	r2, [r5, #8]
 8010fa8:	60eb      	str	r3, [r5, #12]
 8010faa:	f8dc 0000 	ldr.w	r0, [ip]
 8010fae:	6128      	str	r0, [r5, #16]
 8010fb0:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8010fb4:	82ab      	strh	r3, [r5, #20]
 8010fb6:	4628      	mov	r0, r5
 8010fb8:	f00e f9b7 	bl	801f32a <crs_strlen>
 8010fbc:	b283      	uxth	r3, r0
 8010fbe:	462a      	mov	r2, r5
 8010fc0:	2102      	movs	r1, #2
 8010fc2:	4608      	mov	r0, r1
 8010fc4:	f00e f9f4 	bl	801f3b0 <traceIF_itmPrint>
 8010fc8:	4628      	mov	r0, r5
 8010fca:	f00e f9ae 	bl	801f32a <crs_strlen>
 8010fce:	b283      	uxth	r3, r0
 8010fd0:	462a      	mov	r2, r5
 8010fd2:	2102      	movs	r1, #2
 8010fd4:	4608      	mov	r0, r1
 8010fd6:	f00e fa0d 	bl	801f3f4 <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_TRUE;
 8010fda:	2301      	movs	r3, #1
 8010fdc:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_READY;
 8010fe0:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
 8010fe4:	e6b6      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
 8010fe6:	bf00      	nop
 8010fe8:	0802ff20 	.word	0x0802ff20
 8010fec:	200048dc 	.word	0x200048dc
 8010ff0:	0802ff6c 	.word	0x0802ff6c
 8010ff4:	0802ff94 	.word	0x0802ff94
 8010ff8:	0802ffbc 	.word	0x0802ffbc
 8010ffc:	0802ffe8 	.word	0x0802ffe8
 8011000:	0802fff4 	.word	0x0802fff4
 8011004:	0802ff48 	.word	0x0802ff48
 8011008:	0802ff74 	.word	0x0802ff74
 801100c:	0802ff9c 	.word	0x0802ff9c
 8011010:	0802ffc8 	.word	0x0802ffc8
 8011014:	0802fffc 	.word	0x0802fffc
        PRINT_ERR("UNEXPECTED CPIN STATE")
 8011018:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 80110e4 <fRspAnalyze_CPIN+0x404>
 801101c:	4d30      	ldr	r5, [pc, #192]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 801101e:	f10e 0a20 	add.w	sl, lr, #32
 8011022:	46f4      	mov	ip, lr
 8011024:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011028:	6028      	str	r0, [r5, #0]
 801102a:	6069      	str	r1, [r5, #4]
 801102c:	60aa      	str	r2, [r5, #8]
 801102e:	60eb      	str	r3, [r5, #12]
 8011030:	46e6      	mov	lr, ip
 8011032:	3510      	adds	r5, #16
 8011034:	45d4      	cmp	ip, sl
 8011036:	d1f4      	bne.n	8011022 <fRspAnalyze_CPIN+0x342>
 8011038:	f8dc 0000 	ldr.w	r0, [ip]
 801103c:	6028      	str	r0, [r5, #0]
 801103e:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8011042:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8011046:	80aa      	strh	r2, [r5, #4]
 8011048:	71ab      	strb	r3, [r5, #6]
 801104a:	4d25      	ldr	r5, [pc, #148]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 801104c:	4628      	mov	r0, r5
 801104e:	f00e f96c 	bl	801f32a <crs_strlen>
 8011052:	b283      	uxth	r3, r0
 8011054:	462a      	mov	r2, r5
 8011056:	2110      	movs	r1, #16
 8011058:	2002      	movs	r0, #2
 801105a:	f00e f9a9 	bl	801f3b0 <traceIF_itmPrint>
 801105e:	4628      	mov	r0, r5
 8011060:	f00e f963 	bl	801f32a <crs_strlen>
 8011064:	b283      	uxth	r3, r0
 8011066:	462a      	mov	r2, r5
 8011068:	2110      	movs	r1, #16
 801106a:	2002      	movs	r0, #2
 801106c:	f00e f9c2 	bl	801f3f4 <traceIF_uartPrint>
        p_modem_ctxt->persist.sim_pin_code_ready = AT_FALSE;
 8011070:	2300      	movs	r3, #0
 8011072:	f889 3510 	strb.w	r3, [r9, #1296]	; 0x510
        p_modem_ctxt->persist.sim_state = CS_SIMSTATE_UNKNOWN;
 8011076:	f889 3511 	strb.w	r3, [r9, #1297]	; 0x511
        set_error_report(CSERR_SIM, p_modem_ctxt);
 801107a:	4649      	mov	r1, r9
 801107c:	2001      	movs	r0, #1
 801107e:	f7fd fa7b 	bl	800e578 <set_error_report>
 8011082:	e667      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
      PRINT_ERR("line exceed maximum size, line ignored...")
 8011084:	f8df c060 	ldr.w	ip, [pc, #96]	; 80110e8 <fRspAnalyze_CPIN+0x408>
 8011088:	4d15      	ldr	r5, [pc, #84]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 801108a:	f10c 0a30 	add.w	sl, ip, #48	; 0x30
 801108e:	46e6      	mov	lr, ip
 8011090:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8011094:	6028      	str	r0, [r5, #0]
 8011096:	6069      	str	r1, [r5, #4]
 8011098:	60aa      	str	r2, [r5, #8]
 801109a:	60eb      	str	r3, [r5, #12]
 801109c:	46f4      	mov	ip, lr
 801109e:	3510      	adds	r5, #16
 80110a0:	45d6      	cmp	lr, sl
 80110a2:	d1f4      	bne.n	801108e <fRspAnalyze_CPIN+0x3ae>
 80110a4:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 80110a8:	6028      	str	r0, [r5, #0]
 80110aa:	6069      	str	r1, [r5, #4]
 80110ac:	f8bc 2000 	ldrh.w	r2, [ip]
 80110b0:	f89c 3002 	ldrb.w	r3, [ip, #2]
 80110b4:	812a      	strh	r2, [r5, #8]
 80110b6:	72ab      	strb	r3, [r5, #10]
 80110b8:	4d09      	ldr	r5, [pc, #36]	; (80110e0 <fRspAnalyze_CPIN+0x400>)
 80110ba:	4628      	mov	r0, r5
 80110bc:	f00e f935 	bl	801f32a <crs_strlen>
 80110c0:	b283      	uxth	r3, r0
 80110c2:	462a      	mov	r2, r5
 80110c4:	2110      	movs	r1, #16
 80110c6:	2002      	movs	r0, #2
 80110c8:	f00e f972 	bl	801f3b0 <traceIF_itmPrint>
 80110cc:	4628      	mov	r0, r5
 80110ce:	f00e f92c 	bl	801f32a <crs_strlen>
 80110d2:	b283      	uxth	r3, r0
 80110d4:	462a      	mov	r2, r5
 80110d6:	2110      	movs	r1, #16
 80110d8:	2002      	movs	r0, #2
 80110da:	f00e f98b 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATACTION_RSP_IGNORED;
 80110de:	e639      	b.n	8010d54 <fRspAnalyze_CPIN+0x74>
 80110e0:	200048dc 	.word	0x200048dc
 80110e4:	08030014 	.word	0x08030014
 80110e8:	0802f1b8 	.word	0x0802f1b8

080110ec <fRspAnalyze_COPS>:
  return (retval);
}

at_action_rsp_t fRspAnalyze_COPS(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80110ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80110f0:	4606      	mov	r6, r0
 80110f2:	4689      	mov	r9, r1
 80110f4:	4690      	mov	r8, r2
 80110f6:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_COPS()")
 80110f8:	4cc1      	ldr	r4, [pc, #772]	; (8011400 <fRspAnalyze_COPS+0x314>)
 80110fa:	4dc2      	ldr	r5, [pc, #776]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80110fc:	f104 0e20 	add.w	lr, r4, #32
 8011100:	46a4      	mov	ip, r4
 8011102:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011106:	6028      	str	r0, [r5, #0]
 8011108:	6069      	str	r1, [r5, #4]
 801110a:	60aa      	str	r2, [r5, #8]
 801110c:	60eb      	str	r3, [r5, #12]
 801110e:	4664      	mov	r4, ip
 8011110:	3510      	adds	r5, #16
 8011112:	45f4      	cmp	ip, lr
 8011114:	d1f4      	bne.n	8011100 <fRspAnalyze_COPS+0x14>
 8011116:	cc03      	ldmia	r4!, {r0, r1}
 8011118:	6028      	str	r0, [r5, #0]
 801111a:	6069      	str	r1, [r5, #4]
 801111c:	4cb9      	ldr	r4, [pc, #740]	; (8011404 <fRspAnalyze_COPS+0x318>)
 801111e:	4620      	mov	r0, r4
 8011120:	f00e f903 	bl	801f32a <crs_strlen>
 8011124:	b283      	uxth	r3, r0
 8011126:	4622      	mov	r2, r4
 8011128:	2104      	movs	r1, #4
 801112a:	2002      	movs	r0, #2
 801112c:	f00e f940 	bl	801f3b0 <traceIF_itmPrint>
 8011130:	4620      	mov	r0, r4
 8011132:	f00e f8fa 	bl	801f32a <crs_strlen>
 8011136:	b283      	uxth	r3, r0
 8011138:	4622      	mov	r2, r4
 801113a:	2104      	movs	r1, #4
 801113c:	2002      	movs	r0, #2
 801113e:	f00e f959 	bl	801f3f4 <traceIF_uartPrint>
    *  2/ answer to COPS test command
    *     +COPS: [list of supported (<stat>,long alphanumeric <oper>,
    *            short alphanumeric <oper>,numeric <oper>[,<AcT>])s]
    *            [,,(list ofsupported <mode>s),(list of supported <format>s)]
  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8011142:	8b33      	ldrh	r3, [r6, #24]
 8011144:	2b02      	cmp	r3, #2
 8011146:	d008      	beq.n	801115a <fRspAnalyze_COPS+0x6e>
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
 8011148:	f04f 0a10 	mov.w	sl, #16
      /* parameters ignored */
    }
    END_PARAM_LOOP()
  }

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 801114c:	8b33      	ldrh	r3, [r6, #24]
 801114e:	2b01      	cmp	r3, #1
 8011150:	f000 8225 	beq.w	801159e <fRspAnalyze_COPS+0x4b2>
  {
    PRINT_DBG("+COPS for test cmd NOT IMPLEMENTED")
  }

  return (retval);
}
 8011154:	4650      	mov	r0, sl
 8011156:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    START_PARAM_LOOP()
 801115a:	2400      	movs	r4, #0
 801115c:	463a      	mov	r2, r7
 801115e:	4641      	mov	r1, r8
 8011160:	4630      	mov	r0, r6
 8011162:	f7fb f971 	bl	800c448 <atcc_extractElement>
 8011166:	2801      	cmp	r0, #1
 8011168:	d000      	beq.n	801116c <fRspAnalyze_COPS+0x80>
 801116a:	2401      	movs	r4, #1
 801116c:	89f9      	ldrh	r1, [r7, #14]
 801116e:	b179      	cbz	r1, 8011190 <fRspAnalyze_COPS+0xa4>
    if (element_infos->param_rank == 2U)
 8011170:	f8b7 a008 	ldrh.w	sl, [r7, #8]
 8011174:	f1ba 0f02 	cmp.w	sl, #2
 8011178:	d00f      	beq.n	801119a <fRspAnalyze_COPS+0xae>
    else if (element_infos->param_rank == 3U)
 801117a:	f1ba 0f03 	cmp.w	sl, #3
 801117e:	d06f      	beq.n	8011260 <fRspAnalyze_COPS+0x174>
    else if (element_infos->param_rank == 4U)
 8011180:	f1ba 0f04 	cmp.w	sl, #4
 8011184:	f000 80ce 	beq.w	8011324 <fRspAnalyze_COPS+0x238>
    else if (element_infos->param_rank == 5U)
 8011188:	f1ba 0f05 	cmp.w	sl, #5
 801118c:	f000 811d 	beq.w	80113ca <fRspAnalyze_COPS+0x2de>
    END_PARAM_LOOP()
 8011190:	2c00      	cmp	r4, #0
 8011192:	d0e3      	beq.n	801115c <fRspAnalyze_COPS+0x70>
 8011194:	f04f 0a10 	mov.w	sl, #16
 8011198:	e7d8      	b.n	801114c <fRspAnalyze_COPS+0x60>
      uint32_t mode = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 801119a:	8978      	ldrh	r0, [r7, #10]
 801119c:	4440      	add	r0, r8
 801119e:	f003 fdc9 	bl	8014d34 <ATutil_convertStringToInt>
      switch (mode)
 80111a2:	2804      	cmp	r0, #4
 80111a4:	d814      	bhi.n	80111d0 <fRspAnalyze_COPS+0xe4>
 80111a6:	e8df f000 	tbb	[pc, r0]
 80111aa:	0703      	.short	0x0703
 80111ac:	130b      	.short	0x130b
 80111ae:	0f          	.byte	0x0f
 80111af:	00          	.byte	0x00
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_AUTO;
 80111b0:	2300      	movs	r3, #0
 80111b2:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111b6:	e039      	b.n	801122c <fRspAnalyze_COPS+0x140>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_MANUAL;
 80111b8:	2301      	movs	r3, #1
 80111ba:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111be:	e035      	b.n	801122c <fRspAnalyze_COPS+0x140>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_DEREGISTER;
 80111c0:	2302      	movs	r3, #2
 80111c2:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111c6:	e031      	b.n	801122c <fRspAnalyze_COPS+0x140>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_MANUAL_THEN_AUTO;
 80111c8:	2304      	movs	r3, #4
 80111ca:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
          break;
 80111ce:	e02d      	b.n	801122c <fRspAnalyze_COPS+0x140>
          PRINT_ERR("invalid mode value in +COPS")
 80111d0:	f8df c244 	ldr.w	ip, [pc, #580]	; 8011418 <fRspAnalyze_COPS+0x32c>
 80111d4:	4d8b      	ldr	r5, [pc, #556]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80111d6:	f10c 0a20 	add.w	sl, ip, #32
 80111da:	46e6      	mov	lr, ip
 80111dc:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80111e0:	6028      	str	r0, [r5, #0]
 80111e2:	6069      	str	r1, [r5, #4]
 80111e4:	60aa      	str	r2, [r5, #8]
 80111e6:	60eb      	str	r3, [r5, #12]
 80111e8:	46f4      	mov	ip, lr
 80111ea:	3510      	adds	r5, #16
 80111ec:	45d6      	cmp	lr, sl
 80111ee:	d1f4      	bne.n	80111da <fRspAnalyze_COPS+0xee>
 80111f0:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80111f4:	6028      	str	r0, [r5, #0]
 80111f6:	6069      	str	r1, [r5, #4]
 80111f8:	60aa      	str	r2, [r5, #8]
 80111fa:	f89c 3000 	ldrb.w	r3, [ip]
 80111fe:	732b      	strb	r3, [r5, #12]
 8011200:	4d80      	ldr	r5, [pc, #512]	; (8011404 <fRspAnalyze_COPS+0x318>)
 8011202:	4628      	mov	r0, r5
 8011204:	f00e f891 	bl	801f32a <crs_strlen>
 8011208:	b283      	uxth	r3, r0
 801120a:	462a      	mov	r2, r5
 801120c:	2110      	movs	r1, #16
 801120e:	2002      	movs	r0, #2
 8011210:	f00e f8ce 	bl	801f3b0 <traceIF_itmPrint>
 8011214:	4628      	mov	r0, r5
 8011216:	f00e f888 	bl	801f32a <crs_strlen>
 801121a:	b283      	uxth	r3, r0
 801121c:	462a      	mov	r2, r5
 801121e:	2110      	movs	r1, #16
 8011220:	2002      	movs	r0, #2
 8011222:	f00e f8e7 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.mode = CS_NRM_AUTO;
 8011226:	2300      	movs	r3, #0
 8011228:	f8a9 3610 	strh.w	r3, [r9, #1552]	; 0x610
      PRINT_DBG("+COPS: mode = %d", p_modem_ctxt->SID_ctxt.read_operator_infos.mode)
 801122c:	4d75      	ldr	r5, [pc, #468]	; (8011404 <fRspAnalyze_COPS+0x318>)
 801122e:	f8b9 2610 	ldrh.w	r2, [r9, #1552]	; 0x610
 8011232:	4975      	ldr	r1, [pc, #468]	; (8011408 <fRspAnalyze_COPS+0x31c>)
 8011234:	4628      	mov	r0, r5
 8011236:	f015 fb07 	bl	8026848 <sprintf>
 801123a:	4628      	mov	r0, r5
 801123c:	f00e f875 	bl	801f32a <crs_strlen>
 8011240:	b283      	uxth	r3, r0
 8011242:	462a      	mov	r2, r5
 8011244:	2102      	movs	r1, #2
 8011246:	4608      	mov	r0, r1
 8011248:	f00e f8b2 	bl	801f3b0 <traceIF_itmPrint>
 801124c:	4628      	mov	r0, r5
 801124e:	f00e f86c 	bl	801f32a <crs_strlen>
 8011252:	b283      	uxth	r3, r0
 8011254:	462a      	mov	r2, r5
 8011256:	2102      	movs	r1, #2
 8011258:	4608      	mov	r0, r1
 801125a:	f00e f8cb 	bl	801f3f4 <traceIF_uartPrint>
 801125e:	e797      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
      uint32_t format = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011260:	8978      	ldrh	r0, [r7, #10]
 8011262:	4440      	add	r0, r8
 8011264:	f003 fd66 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->SID_ctxt.read_operator_infos.optional_fields_presence |= CS_RSF_FORMAT_PRESENT; /* bitfield */
 8011268:	f8b9 3618 	ldrh.w	r3, [r9, #1560]	; 0x618
 801126c:	f043 0301 	orr.w	r3, r3, #1
 8011270:	f8a9 3618 	strh.w	r3, [r9, #1560]	; 0x618
      switch (format)
 8011274:	2801      	cmp	r0, #1
 8011276:	d04d      	beq.n	8011314 <fRspAnalyze_COPS+0x228>
 8011278:	2802      	cmp	r0, #2
 801127a:	d04f      	beq.n	801131c <fRspAnalyze_COPS+0x230>
 801127c:	2800      	cmp	r0, #0
 801127e:	d045      	beq.n	801130c <fRspAnalyze_COPS+0x220>
          PRINT_ERR("invalid format value")
 8011280:	f8df e198 	ldr.w	lr, [pc, #408]	; 801141c <fRspAnalyze_COPS+0x330>
 8011284:	4d5f      	ldr	r5, [pc, #380]	; (8011404 <fRspAnalyze_COPS+0x318>)
 8011286:	f10e 0a20 	add.w	sl, lr, #32
 801128a:	46f4      	mov	ip, lr
 801128c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011290:	6028      	str	r0, [r5, #0]
 8011292:	6069      	str	r1, [r5, #4]
 8011294:	60aa      	str	r2, [r5, #8]
 8011296:	60eb      	str	r3, [r5, #12]
 8011298:	46e6      	mov	lr, ip
 801129a:	3510      	adds	r5, #16
 801129c:	45d4      	cmp	ip, sl
 801129e:	d1f4      	bne.n	801128a <fRspAnalyze_COPS+0x19e>
 80112a0:	f8dc 0000 	ldr.w	r0, [ip]
 80112a4:	6028      	str	r0, [r5, #0]
 80112a6:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80112aa:	80ab      	strh	r3, [r5, #4]
 80112ac:	4d55      	ldr	r5, [pc, #340]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80112ae:	4628      	mov	r0, r5
 80112b0:	f00e f83b 	bl	801f32a <crs_strlen>
 80112b4:	b283      	uxth	r3, r0
 80112b6:	462a      	mov	r2, r5
 80112b8:	2110      	movs	r1, #16
 80112ba:	2002      	movs	r0, #2
 80112bc:	f00e f878 	bl	801f3b0 <traceIF_itmPrint>
 80112c0:	4628      	mov	r0, r5
 80112c2:	f00e f832 	bl	801f32a <crs_strlen>
 80112c6:	b283      	uxth	r3, r0
 80112c8:	462a      	mov	r2, r5
 80112ca:	2110      	movs	r1, #16
 80112cc:	2002      	movs	r0, #2
 80112ce:	f00e f891 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_NOT_PRESENT;
 80112d2:	2309      	movs	r3, #9
 80112d4:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
      PRINT_DBG("+COPS: format = %d", p_modem_ctxt->SID_ctxt.read_operator_infos.format)
 80112d8:	4d4a      	ldr	r5, [pc, #296]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80112da:	f8b9 261a 	ldrh.w	r2, [r9, #1562]	; 0x61a
 80112de:	494b      	ldr	r1, [pc, #300]	; (801140c <fRspAnalyze_COPS+0x320>)
 80112e0:	4628      	mov	r0, r5
 80112e2:	f015 fab1 	bl	8026848 <sprintf>
 80112e6:	4628      	mov	r0, r5
 80112e8:	f00e f81f 	bl	801f32a <crs_strlen>
 80112ec:	b283      	uxth	r3, r0
 80112ee:	462a      	mov	r2, r5
 80112f0:	2102      	movs	r1, #2
 80112f2:	4608      	mov	r0, r1
 80112f4:	f00e f85c 	bl	801f3b0 <traceIF_itmPrint>
 80112f8:	4628      	mov	r0, r5
 80112fa:	f00e f816 	bl	801f32a <crs_strlen>
 80112fe:	b283      	uxth	r3, r0
 8011300:	462a      	mov	r2, r5
 8011302:	2102      	movs	r1, #2
 8011304:	4608      	mov	r0, r1
 8011306:	f00e f875 	bl	801f3f4 <traceIF_uartPrint>
 801130a:	e741      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_LONG;
 801130c:	2300      	movs	r3, #0
 801130e:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
          break;
 8011312:	e7e1      	b.n	80112d8 <fRspAnalyze_COPS+0x1ec>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_SHORT;
 8011314:	2301      	movs	r3, #1
 8011316:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
          break;
 801131a:	e7dd      	b.n	80112d8 <fRspAnalyze_COPS+0x1ec>
          p_modem_ctxt->SID_ctxt.read_operator_infos.format = CS_ONF_NUMERIC;
 801131c:	2302      	movs	r3, #2
 801131e:	f8a9 361a 	strh.w	r3, [r9, #1562]	; 0x61a
          break;
 8011322:	e7d9      	b.n	80112d8 <fRspAnalyze_COPS+0x1ec>
      if (element_infos->str_size <= MAX_SIZE_OPERATOR_NAME)
 8011324:	2940      	cmp	r1, #64	; 0x40
 8011326:	d826      	bhi.n	8011376 <fRspAnalyze_COPS+0x28a>
        p_modem_ctxt->SID_ctxt.read_operator_infos.optional_fields_presence |=
 8011328:	f8b9 3618 	ldrh.w	r3, [r9, #1560]	; 0x618
 801132c:	f043 0302 	orr.w	r3, r3, #2
 8011330:	f8a9 3618 	strh.w	r3, [r9, #1560]	; 0x618
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.read_operator_infos.operator_name[0]),
 8011334:	f209 6a1c 	addw	sl, r9, #1564	; 0x61c
                      (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8011338:	8979      	ldrh	r1, [r7, #10]
        (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.read_operator_infos.operator_name[0]),
 801133a:	89fa      	ldrh	r2, [r7, #14]
 801133c:	4441      	add	r1, r8
 801133e:	4650      	mov	r0, sl
 8011340:	f015 fbd2 	bl	8026ae8 <memcpy>
        PRINT_DBG("+COPS: operator name = %s", p_modem_ctxt->SID_ctxt.read_operator_infos.operator_name)
 8011344:	4d2f      	ldr	r5, [pc, #188]	; (8011404 <fRspAnalyze_COPS+0x318>)
 8011346:	4652      	mov	r2, sl
 8011348:	4931      	ldr	r1, [pc, #196]	; (8011410 <fRspAnalyze_COPS+0x324>)
 801134a:	4628      	mov	r0, r5
 801134c:	f015 fa7c 	bl	8026848 <sprintf>
 8011350:	4628      	mov	r0, r5
 8011352:	f00d ffea 	bl	801f32a <crs_strlen>
 8011356:	b283      	uxth	r3, r0
 8011358:	462a      	mov	r2, r5
 801135a:	2102      	movs	r1, #2
 801135c:	4608      	mov	r0, r1
 801135e:	f00e f827 	bl	801f3b0 <traceIF_itmPrint>
 8011362:	4628      	mov	r0, r5
 8011364:	f00d ffe1 	bl	801f32a <crs_strlen>
 8011368:	b283      	uxth	r3, r0
 801136a:	462a      	mov	r2, r5
 801136c:	2102      	movs	r1, #2
 801136e:	4608      	mov	r0, r1
 8011370:	f00e f840 	bl	801f3f4 <traceIF_uartPrint>
 8011374:	e70c      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
        PRINT_ERR("error, operator name too long")
 8011376:	4d27      	ldr	r5, [pc, #156]	; (8011414 <fRspAnalyze_COPS+0x328>)
 8011378:	4c22      	ldr	r4, [pc, #136]	; (8011404 <fRspAnalyze_COPS+0x318>)
 801137a:	f105 0c20 	add.w	ip, r5, #32
 801137e:	462f      	mov	r7, r5
 8011380:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8011382:	6020      	str	r0, [r4, #0]
 8011384:	6061      	str	r1, [r4, #4]
 8011386:	60a2      	str	r2, [r4, #8]
 8011388:	60e3      	str	r3, [r4, #12]
 801138a:	463d      	mov	r5, r7
 801138c:	3410      	adds	r4, #16
 801138e:	4567      	cmp	r7, ip
 8011390:	d1f5      	bne.n	801137e <fRspAnalyze_COPS+0x292>
 8011392:	cd07      	ldmia	r5!, {r0, r1, r2}
 8011394:	6020      	str	r0, [r4, #0]
 8011396:	6061      	str	r1, [r4, #4]
 8011398:	60a2      	str	r2, [r4, #8]
 801139a:	882a      	ldrh	r2, [r5, #0]
 801139c:	78ab      	ldrb	r3, [r5, #2]
 801139e:	81a2      	strh	r2, [r4, #12]
 80113a0:	73a3      	strb	r3, [r4, #14]
 80113a2:	4c18      	ldr	r4, [pc, #96]	; (8011404 <fRspAnalyze_COPS+0x318>)
 80113a4:	4620      	mov	r0, r4
 80113a6:	f00d ffc0 	bl	801f32a <crs_strlen>
 80113aa:	b283      	uxth	r3, r0
 80113ac:	4622      	mov	r2, r4
 80113ae:	2110      	movs	r1, #16
 80113b0:	2002      	movs	r0, #2
 80113b2:	f00d fffd 	bl	801f3b0 <traceIF_itmPrint>
 80113b6:	4620      	mov	r0, r4
 80113b8:	f00d ffb7 	bl	801f32a <crs_strlen>
 80113bc:	b283      	uxth	r3, r0
 80113be:	4622      	mov	r2, r4
 80113c0:	2110      	movs	r1, #16
 80113c2:	2002      	movs	r0, #2
 80113c4:	f00e f816 	bl	801f3f4 <traceIF_uartPrint>
    END_PARAM_LOOP()
 80113c8:	e6c0      	b.n	801114c <fRspAnalyze_COPS+0x60>
      p_modem_ctxt->SID_ctxt.read_operator_infos.optional_fields_presence |= CS_RSF_ACT_PRESENT;  /* bitfield */
 80113ca:	f8b9 3618 	ldrh.w	r3, [r9, #1560]	; 0x618
 80113ce:	f043 0304 	orr.w	r3, r3, #4
 80113d2:	f8a9 3618 	strh.w	r3, [r9, #1560]	; 0x618
      uint32_t AcT = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80113d6:	8978      	ldrh	r0, [r7, #10]
 80113d8:	89f9      	ldrh	r1, [r7, #14]
 80113da:	4440      	add	r0, r8
 80113dc:	f003 fcaa 	bl	8014d34 <ATutil_convertStringToInt>
 80113e0:	4682      	mov	sl, r0
      switch (AcT)
 80113e2:	2809      	cmp	r0, #9
 80113e4:	f200 80b1 	bhi.w	801154a <fRspAnalyze_COPS+0x45e>
 80113e8:	e8df f000 	tbb	[pc, r0]
 80113ec:	221e1a05 	.word	0x221e1a05
 80113f0:	322e2a26 	.word	0x322e2a26
 80113f4:	7d79      	.short	0x7d79
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_GSM;
 80113f6:	2300      	movs	r3, #0
 80113f8:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 80113fc:	e056      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
 80113fe:	bf00      	nop
 8011400:	0803003c 	.word	0x0803003c
 8011404:	200048dc 	.word	0x200048dc
 8011408:	08030094 	.word	0x08030094
 801140c:	080300d8 	.word	0x080300d8
 8011410:	080300f8 	.word	0x080300f8
 8011414:	08030120 	.word	0x08030120
 8011418:	08030064 	.word	0x08030064
 801141c:	080300b0 	.word	0x080300b0
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_GSM_COMPACT;
 8011420:	2301      	movs	r3, #1
 8011422:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011426:	e041      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN;
 8011428:	2302      	movs	r3, #2
 801142a:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 801142e:	e03d      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_GSM_EDGE;
 8011430:	2303      	movs	r3, #3
 8011432:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011436:	e039      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN_HSDPA;
 8011438:	2304      	movs	r3, #4
 801143a:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 801143e:	e035      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN_HSUPA;
 8011440:	2305      	movs	r3, #5
 8011442:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011446:	e031      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_UTRAN_HSDPA_HSUPA;
 8011448:	2306      	movs	r3, #6
 801144a:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 801144e:	e02d      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          PRINT_DBG(">>> Access Technology : LTE Cat.M1 <<<")
 8011450:	f8df e1a8 	ldr.w	lr, [pc, #424]	; 80115fc <fRspAnalyze_COPS+0x510>
 8011454:	f8df c198 	ldr.w	ip, [pc, #408]	; 80115f0 <fRspAnalyze_COPS+0x504>
 8011458:	f10e 0b30 	add.w	fp, lr, #48	; 0x30
 801145c:	4675      	mov	r5, lr
 801145e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8011460:	f8cc 0000 	str.w	r0, [ip]
 8011464:	f8cc 1004 	str.w	r1, [ip, #4]
 8011468:	f8cc 2008 	str.w	r2, [ip, #8]
 801146c:	f8cc 300c 	str.w	r3, [ip, #12]
 8011470:	46ae      	mov	lr, r5
 8011472:	f10c 0c10 	add.w	ip, ip, #16
 8011476:	455d      	cmp	r5, fp
 8011478:	d1f0      	bne.n	801145c <fRspAnalyze_COPS+0x370>
 801147a:	882b      	ldrh	r3, [r5, #0]
 801147c:	f8ac 3000 	strh.w	r3, [ip]
 8011480:	4d5b      	ldr	r5, [pc, #364]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 8011482:	4628      	mov	r0, r5
 8011484:	f00d ff51 	bl	801f32a <crs_strlen>
 8011488:	b283      	uxth	r3, r0
 801148a:	462a      	mov	r2, r5
 801148c:	2102      	movs	r1, #2
 801148e:	4608      	mov	r0, r1
 8011490:	f00d ff8e 	bl	801f3b0 <traceIF_itmPrint>
 8011494:	4628      	mov	r0, r5
 8011496:	f00d ff48 	bl	801f32a <crs_strlen>
 801149a:	b283      	uxth	r3, r0
 801149c:	462a      	mov	r2, r5
 801149e:	2102      	movs	r1, #2
 80114a0:	4608      	mov	r0, r1
 80114a2:	f00d ffa7 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_E_UTRAN;
 80114a6:	2307      	movs	r3, #7
 80114a8:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
      PRINT_DBG("+COPS: Access technology = %ld", AcT)
 80114ac:	4d50      	ldr	r5, [pc, #320]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 80114ae:	4652      	mov	r2, sl
 80114b0:	4950      	ldr	r1, [pc, #320]	; (80115f4 <fRspAnalyze_COPS+0x508>)
 80114b2:	4628      	mov	r0, r5
 80114b4:	f015 f9c8 	bl	8026848 <sprintf>
 80114b8:	4628      	mov	r0, r5
 80114ba:	f00d ff36 	bl	801f32a <crs_strlen>
 80114be:	b283      	uxth	r3, r0
 80114c0:	462a      	mov	r2, r5
 80114c2:	2102      	movs	r1, #2
 80114c4:	4608      	mov	r0, r1
 80114c6:	f00d ff73 	bl	801f3b0 <traceIF_itmPrint>
 80114ca:	4628      	mov	r0, r5
 80114cc:	f00d ff2d 	bl	801f32a <crs_strlen>
 80114d0:	b283      	uxth	r3, r0
 80114d2:	462a      	mov	r2, r5
 80114d4:	2102      	movs	r1, #2
 80114d6:	4608      	mov	r0, r1
 80114d8:	f00d ff8c 	bl	801f3f4 <traceIF_uartPrint>
 80114dc:	e658      	b.n	8011190 <fRspAnalyze_COPS+0xa4>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_EC_GSM_IOT;
 80114de:	2308      	movs	r3, #8
 80114e0:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 80114e4:	e7e2      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          PRINT_DBG(">>> Access Technology : LTE Cat.NB1 <<<")
 80114e6:	f8df e118 	ldr.w	lr, [pc, #280]	; 8011600 <fRspAnalyze_COPS+0x514>
 80114ea:	f8df c104 	ldr.w	ip, [pc, #260]	; 80115f0 <fRspAnalyze_COPS+0x504>
 80114ee:	f10e 0b30 	add.w	fp, lr, #48	; 0x30
 80114f2:	4675      	mov	r5, lr
 80114f4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80114f6:	f8cc 0000 	str.w	r0, [ip]
 80114fa:	f8cc 1004 	str.w	r1, [ip, #4]
 80114fe:	f8cc 2008 	str.w	r2, [ip, #8]
 8011502:	f8cc 300c 	str.w	r3, [ip, #12]
 8011506:	46ae      	mov	lr, r5
 8011508:	f10c 0c10 	add.w	ip, ip, #16
 801150c:	455d      	cmp	r5, fp
 801150e:	d1f0      	bne.n	80114f2 <fRspAnalyze_COPS+0x406>
 8011510:	882a      	ldrh	r2, [r5, #0]
 8011512:	78ab      	ldrb	r3, [r5, #2]
 8011514:	f8ac 2000 	strh.w	r2, [ip]
 8011518:	f88c 3002 	strb.w	r3, [ip, #2]
 801151c:	4d34      	ldr	r5, [pc, #208]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 801151e:	4628      	mov	r0, r5
 8011520:	f00d ff03 	bl	801f32a <crs_strlen>
 8011524:	b283      	uxth	r3, r0
 8011526:	462a      	mov	r2, r5
 8011528:	2102      	movs	r1, #2
 801152a:	4608      	mov	r0, r1
 801152c:	f00d ff40 	bl	801f3b0 <traceIF_itmPrint>
 8011530:	4628      	mov	r0, r5
 8011532:	f00d fefa 	bl	801f32a <crs_strlen>
 8011536:	b283      	uxth	r3, r0
 8011538:	462a      	mov	r2, r5
 801153a:	2102      	movs	r1, #2
 801153c:	4608      	mov	r0, r1
 801153e:	f00d ff59 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->SID_ctxt.read_operator_infos.AcT = CS_ACT_E_UTRAN_NBS1;
 8011542:	2309      	movs	r3, #9
 8011544:	f8a9 365c 	strh.w	r3, [r9, #1628]	; 0x65c
          break;
 8011548:	e7b0      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
          PRINT_ERR("invalid AcT value")
 801154a:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 8011604 <fRspAnalyze_COPS+0x518>
 801154e:	4d28      	ldr	r5, [pc, #160]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 8011550:	f10c 0b20 	add.w	fp, ip, #32
 8011554:	46e6      	mov	lr, ip
 8011556:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801155a:	6028      	str	r0, [r5, #0]
 801155c:	6069      	str	r1, [r5, #4]
 801155e:	60aa      	str	r2, [r5, #8]
 8011560:	60eb      	str	r3, [r5, #12]
 8011562:	46f4      	mov	ip, lr
 8011564:	3510      	adds	r5, #16
 8011566:	45de      	cmp	lr, fp
 8011568:	d1f4      	bne.n	8011554 <fRspAnalyze_COPS+0x468>
 801156a:	f8be 2000 	ldrh.w	r2, [lr]
 801156e:	f89e 3002 	ldrb.w	r3, [lr, #2]
 8011572:	802a      	strh	r2, [r5, #0]
 8011574:	70ab      	strb	r3, [r5, #2]
 8011576:	4d1e      	ldr	r5, [pc, #120]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 8011578:	4628      	mov	r0, r5
 801157a:	f00d fed6 	bl	801f32a <crs_strlen>
 801157e:	b283      	uxth	r3, r0
 8011580:	462a      	mov	r2, r5
 8011582:	2110      	movs	r1, #16
 8011584:	2002      	movs	r0, #2
 8011586:	f00d ff13 	bl	801f3b0 <traceIF_itmPrint>
 801158a:	4628      	mov	r0, r5
 801158c:	f00d fecd 	bl	801f32a <crs_strlen>
 8011590:	b283      	uxth	r3, r0
 8011592:	462a      	mov	r2, r5
 8011594:	2110      	movs	r1, #16
 8011596:	2002      	movs	r0, #2
 8011598:	f00d ff2c 	bl	801f3f4 <traceIF_uartPrint>
          break;
 801159c:	e786      	b.n	80114ac <fRspAnalyze_COPS+0x3c0>
    PRINT_DBG("+COPS for test cmd NOT IMPLEMENTED")
 801159e:	4d16      	ldr	r5, [pc, #88]	; (80115f8 <fRspAnalyze_COPS+0x50c>)
 80115a0:	4c13      	ldr	r4, [pc, #76]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 80115a2:	f105 0720 	add.w	r7, r5, #32
 80115a6:	462e      	mov	r6, r5
 80115a8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80115aa:	6020      	str	r0, [r4, #0]
 80115ac:	6061      	str	r1, [r4, #4]
 80115ae:	60a2      	str	r2, [r4, #8]
 80115b0:	60e3      	str	r3, [r4, #12]
 80115b2:	4635      	mov	r5, r6
 80115b4:	3410      	adds	r4, #16
 80115b6:	42be      	cmp	r6, r7
 80115b8:	d1f5      	bne.n	80115a6 <fRspAnalyze_COPS+0x4ba>
 80115ba:	cd07      	ldmia	r5!, {r0, r1, r2}
 80115bc:	6020      	str	r0, [r4, #0]
 80115be:	6061      	str	r1, [r4, #4]
 80115c0:	60a2      	str	r2, [r4, #8]
 80115c2:	882b      	ldrh	r3, [r5, #0]
 80115c4:	81a3      	strh	r3, [r4, #12]
 80115c6:	4c0a      	ldr	r4, [pc, #40]	; (80115f0 <fRspAnalyze_COPS+0x504>)
 80115c8:	4620      	mov	r0, r4
 80115ca:	f00d feae 	bl	801f32a <crs_strlen>
 80115ce:	b283      	uxth	r3, r0
 80115d0:	4622      	mov	r2, r4
 80115d2:	2102      	movs	r1, #2
 80115d4:	4608      	mov	r0, r1
 80115d6:	f00d feeb 	bl	801f3b0 <traceIF_itmPrint>
 80115da:	4620      	mov	r0, r4
 80115dc:	f00d fea5 	bl	801f32a <crs_strlen>
 80115e0:	b283      	uxth	r3, r0
 80115e2:	4622      	mov	r2, r4
 80115e4:	2102      	movs	r1, #2
 80115e6:	4608      	mov	r0, r1
 80115e8:	f00d ff04 	bl	801f3f4 <traceIF_uartPrint>
 80115ec:	e5b2      	b.n	8011154 <fRspAnalyze_COPS+0x68>
 80115ee:	bf00      	nop
 80115f0:	200048dc 	.word	0x200048dc
 80115f4:	080301dc 	.word	0x080301dc
 80115f8:	08030208 	.word	0x08030208
 80115fc:	08030150 	.word	0x08030150
 8011600:	08030184 	.word	0x08030184
 8011604:	080301b8 	.word	0x080301b8

08011608 <fRspAnalyze_CNUM>:

at_action_rsp_t fRspAnalyze_CNUM(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8011608:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);

  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fCmdBuild_CNUM()")
 801160a:	4d2b      	ldr	r5, [pc, #172]	; (80116b8 <fRspAnalyze_CNUM+0xb0>)
 801160c:	4c2b      	ldr	r4, [pc, #172]	; (80116bc <fRspAnalyze_CNUM+0xb4>)
 801160e:	f105 0e20 	add.w	lr, r5, #32
 8011612:	46ac      	mov	ip, r5
 8011614:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011618:	6020      	str	r0, [r4, #0]
 801161a:	6061      	str	r1, [r4, #4]
 801161c:	60a2      	str	r2, [r4, #8]
 801161e:	60e3      	str	r3, [r4, #12]
 8011620:	4665      	mov	r5, ip
 8011622:	3410      	adds	r4, #16
 8011624:	45f4      	cmp	ip, lr
 8011626:	d1f4      	bne.n	8011612 <fRspAnalyze_CNUM+0xa>
 8011628:	f8dc 0000 	ldr.w	r0, [ip]
 801162c:	6020      	str	r0, [r4, #0]
 801162e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8011632:	80a3      	strh	r3, [r4, #4]
 8011634:	4c21      	ldr	r4, [pc, #132]	; (80116bc <fRspAnalyze_CNUM+0xb4>)
 8011636:	4620      	mov	r0, r4
 8011638:	f00d fe77 	bl	801f32a <crs_strlen>
 801163c:	b283      	uxth	r3, r0
 801163e:	4622      	mov	r2, r4
 8011640:	2104      	movs	r1, #4
 8011642:	2002      	movs	r0, #2
 8011644:	f00d feb4 	bl	801f3b0 <traceIF_itmPrint>
 8011648:	4620      	mov	r0, r4
 801164a:	f00d fe6e 	bl	801f32a <crs_strlen>
 801164e:	b283      	uxth	r3, r0
 8011650:	4622      	mov	r2, r4
 8011652:	2104      	movs	r1, #4
 8011654:	2002      	movs	r0, #2
 8011656:	f00d fecd 	bl	801f3f4 <traceIF_uartPrint>

  PRINT_DBG("+CNUM cmd NOT IMPLEMENTED")
 801165a:	4d19      	ldr	r5, [pc, #100]	; (80116c0 <fRspAnalyze_CNUM+0xb8>)
 801165c:	46a4      	mov	ip, r4
 801165e:	f105 0e20 	add.w	lr, r5, #32
 8011662:	462c      	mov	r4, r5
 8011664:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8011666:	f8cc 0000 	str.w	r0, [ip]
 801166a:	f8cc 1004 	str.w	r1, [ip, #4]
 801166e:	f8cc 2008 	str.w	r2, [ip, #8]
 8011672:	f8cc 300c 	str.w	r3, [ip, #12]
 8011676:	4625      	mov	r5, r4
 8011678:	f10c 0c10 	add.w	ip, ip, #16
 801167c:	4574      	cmp	r4, lr
 801167e:	d1f0      	bne.n	8011662 <fRspAnalyze_CNUM+0x5a>
 8011680:	6820      	ldr	r0, [r4, #0]
 8011682:	f8cc 0000 	str.w	r0, [ip]
 8011686:	7923      	ldrb	r3, [r4, #4]
 8011688:	f88c 3004 	strb.w	r3, [ip, #4]
 801168c:	4c0b      	ldr	r4, [pc, #44]	; (80116bc <fRspAnalyze_CNUM+0xb4>)
 801168e:	4620      	mov	r0, r4
 8011690:	f00d fe4b 	bl	801f32a <crs_strlen>
 8011694:	b283      	uxth	r3, r0
 8011696:	4622      	mov	r2, r4
 8011698:	2102      	movs	r1, #2
 801169a:	4608      	mov	r0, r1
 801169c:	f00d fe88 	bl	801f3b0 <traceIF_itmPrint>
 80116a0:	4620      	mov	r0, r4
 80116a2:	f00d fe42 	bl	801f32a <crs_strlen>
 80116a6:	b283      	uxth	r3, r0
 80116a8:	4622      	mov	r2, r4
 80116aa:	2102      	movs	r1, #2
 80116ac:	4608      	mov	r0, r1
 80116ae:	f00d fea1 	bl	801f3f4 <traceIF_uartPrint>

  return (retval);
}
 80116b2:	2010      	movs	r0, #16
 80116b4:	bd38      	pop	{r3, r4, r5, pc}
 80116b6:	bf00      	nop
 80116b8:	08030238 	.word	0x08030238
 80116bc:	200048dc 	.word	0x200048dc
 80116c0:	08030260 	.word	0x08030260

080116c4 <fRspAnalyze_CGATT>:

at_action_rsp_t fRspAnalyze_CGATT(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80116c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80116c8:	4606      	mov	r6, r0
 80116ca:	4689      	mov	r9, r1
 80116cc:	4690      	mov	r8, r2
 80116ce:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGATT()")
 80116d0:	4c46      	ldr	r4, [pc, #280]	; (80117ec <fRspAnalyze_CGATT+0x128>)
 80116d2:	4d47      	ldr	r5, [pc, #284]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 80116d4:	f104 0e20 	add.w	lr, r4, #32
 80116d8:	46a4      	mov	ip, r4
 80116da:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80116de:	6028      	str	r0, [r5, #0]
 80116e0:	6069      	str	r1, [r5, #4]
 80116e2:	60aa      	str	r2, [r5, #8]
 80116e4:	60eb      	str	r3, [r5, #12]
 80116e6:	4664      	mov	r4, ip
 80116e8:	3510      	adds	r5, #16
 80116ea:	45f4      	cmp	ip, lr
 80116ec:	d1f4      	bne.n	80116d8 <fRspAnalyze_CGATT+0x14>
 80116ee:	cc03      	ldmia	r4!, {r0, r1}
 80116f0:	6028      	str	r0, [r5, #0]
 80116f2:	6069      	str	r1, [r5, #4]
 80116f4:	7823      	ldrb	r3, [r4, #0]
 80116f6:	722b      	strb	r3, [r5, #8]
 80116f8:	4c3d      	ldr	r4, [pc, #244]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 80116fa:	4620      	mov	r0, r4
 80116fc:	f00d fe15 	bl	801f32a <crs_strlen>
 8011700:	b283      	uxth	r3, r0
 8011702:	4622      	mov	r2, r4
 8011704:	2104      	movs	r1, #4
 8011706:	2002      	movs	r0, #2
 8011708:	f00d fe52 	bl	801f3b0 <traceIF_itmPrint>
 801170c:	4620      	mov	r0, r4
 801170e:	f00d fe0c 	bl	801f32a <crs_strlen>
 8011712:	b283      	uxth	r3, r0
 8011714:	4622      	mov	r2, r4
 8011716:	2104      	movs	r1, #4
 8011718:	2002      	movs	r0, #2
 801171a:	f00d fe6b 	bl	801f3f4 <traceIF_uartPrint>
  *  1/ answer to CGATT read command
  *     +CGATT: <state>
  *  2/ answer to CGATT test command
  *     +CGATT: (list of supported <state>s)
  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 801171e:	8b33      	ldrh	r3, [r6, #24]
 8011720:	2b02      	cmp	r3, #2
 8011722:	d005      	beq.n	8011730 <fRspAnalyze_CGATT+0x6c>
      PRINT_DBG("attach status = %d", p_modem_ctxt->SID_ctxt.attach_status)
    }
    END_PARAM_LOOP()
  }

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8011724:	8b33      	ldrh	r3, [r6, #24]
 8011726:	2b01      	cmp	r3, #1
 8011728:	d035      	beq.n	8011796 <fRspAnalyze_CGATT+0xd2>
  {
    PRINT_DBG("+CGATT for test cmd NOT IMPLEMENTED")
  }

  return (retval);
}
 801172a:	2010      	movs	r0, #16
 801172c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8011730:	2400      	movs	r4, #0
 8011732:	463a      	mov	r2, r7
 8011734:	4641      	mov	r1, r8
 8011736:	4630      	mov	r0, r6
 8011738:	f7fa fe86 	bl	800c448 <atcc_extractElement>
 801173c:	2801      	cmp	r0, #1
 801173e:	d000      	beq.n	8011742 <fRspAnalyze_CGATT+0x7e>
 8011740:	2401      	movs	r4, #1
 8011742:	89f9      	ldrh	r1, [r7, #14]
 8011744:	b111      	cbz	r1, 801174c <fRspAnalyze_CGATT+0x88>
    if (element_infos->param_rank == 2U)
 8011746:	893b      	ldrh	r3, [r7, #8]
 8011748:	2b02      	cmp	r3, #2
 801174a:	d002      	beq.n	8011752 <fRspAnalyze_CGATT+0x8e>
    END_PARAM_LOOP()
 801174c:	2c00      	cmp	r4, #0
 801174e:	d1e9      	bne.n	8011724 <fRspAnalyze_CGATT+0x60>
 8011750:	e7ef      	b.n	8011732 <fRspAnalyze_CGATT+0x6e>
      uint32_t attach = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011752:	8978      	ldrh	r0, [r7, #10]
 8011754:	4440      	add	r0, r8
 8011756:	f003 faed 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->SID_ctxt.attach_status = (attach == 1U) ? CS_PS_ATTACHED : CS_PS_DETACHED;
 801175a:	2801      	cmp	r0, #1
 801175c:	bf14      	ite	ne
 801175e:	2200      	movne	r2, #0
 8011760:	2201      	moveq	r2, #1
 8011762:	f889 2665 	strb.w	r2, [r9, #1637]	; 0x665
      PRINT_DBG("attach status = %d", p_modem_ctxt->SID_ctxt.attach_status)
 8011766:	4d22      	ldr	r5, [pc, #136]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 8011768:	4922      	ldr	r1, [pc, #136]	; (80117f4 <fRspAnalyze_CGATT+0x130>)
 801176a:	4628      	mov	r0, r5
 801176c:	f015 f86c 	bl	8026848 <sprintf>
 8011770:	4628      	mov	r0, r5
 8011772:	f00d fdda 	bl	801f32a <crs_strlen>
 8011776:	b283      	uxth	r3, r0
 8011778:	462a      	mov	r2, r5
 801177a:	2102      	movs	r1, #2
 801177c:	4608      	mov	r0, r1
 801177e:	f00d fe17 	bl	801f3b0 <traceIF_itmPrint>
 8011782:	4628      	mov	r0, r5
 8011784:	f00d fdd1 	bl	801f32a <crs_strlen>
 8011788:	b283      	uxth	r3, r0
 801178a:	462a      	mov	r2, r5
 801178c:	2102      	movs	r1, #2
 801178e:	4608      	mov	r0, r1
 8011790:	f00d fe30 	bl	801f3f4 <traceIF_uartPrint>
 8011794:	e7da      	b.n	801174c <fRspAnalyze_CGATT+0x88>
    PRINT_DBG("+CGATT for test cmd NOT IMPLEMENTED")
 8011796:	4d18      	ldr	r5, [pc, #96]	; (80117f8 <fRspAnalyze_CGATT+0x134>)
 8011798:	4c15      	ldr	r4, [pc, #84]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 801179a:	f105 0720 	add.w	r7, r5, #32
 801179e:	462e      	mov	r6, r5
 80117a0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80117a2:	6020      	str	r0, [r4, #0]
 80117a4:	6061      	str	r1, [r4, #4]
 80117a6:	60a2      	str	r2, [r4, #8]
 80117a8:	60e3      	str	r3, [r4, #12]
 80117aa:	4635      	mov	r5, r6
 80117ac:	3410      	adds	r4, #16
 80117ae:	42be      	cmp	r6, r7
 80117b0:	d1f5      	bne.n	801179e <fRspAnalyze_CGATT+0xda>
 80117b2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80117b4:	6020      	str	r0, [r4, #0]
 80117b6:	6061      	str	r1, [r4, #4]
 80117b8:	60a2      	str	r2, [r4, #8]
 80117ba:	882a      	ldrh	r2, [r5, #0]
 80117bc:	78ab      	ldrb	r3, [r5, #2]
 80117be:	81a2      	strh	r2, [r4, #12]
 80117c0:	73a3      	strb	r3, [r4, #14]
 80117c2:	4c0b      	ldr	r4, [pc, #44]	; (80117f0 <fRspAnalyze_CGATT+0x12c>)
 80117c4:	4620      	mov	r0, r4
 80117c6:	f00d fdb0 	bl	801f32a <crs_strlen>
 80117ca:	b283      	uxth	r3, r0
 80117cc:	4622      	mov	r2, r4
 80117ce:	2102      	movs	r1, #2
 80117d0:	4608      	mov	r0, r1
 80117d2:	f00d fded 	bl	801f3b0 <traceIF_itmPrint>
 80117d6:	4620      	mov	r0, r4
 80117d8:	f00d fda7 	bl	801f32a <crs_strlen>
 80117dc:	b283      	uxth	r3, r0
 80117de:	4622      	mov	r2, r4
 80117e0:	2102      	movs	r1, #2
 80117e2:	4608      	mov	r0, r1
 80117e4:	f00d fe06 	bl	801f3f4 <traceIF_uartPrint>
 80117e8:	e79f      	b.n	801172a <fRspAnalyze_CGATT+0x66>
 80117ea:	bf00      	nop
 80117ec:	08030288 	.word	0x08030288
 80117f0:	200048dc 	.word	0x200048dc
 80117f4:	080302b4 	.word	0x080302b4
 80117f8:	080302d4 	.word	0x080302d4

080117fc <fRspAnalyze_CREG>:

at_action_rsp_t fRspAnalyze_CREG(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80117fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011800:	4607      	mov	r7, r0
 8011802:	4689      	mov	r9, r1
 8011804:	4690      	mov	r8, r2
 8011806:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CREG()")
 8011808:	4cb9      	ldr	r4, [pc, #740]	; (8011af0 <fRspAnalyze_CREG+0x2f4>)
 801180a:	4dba      	ldr	r5, [pc, #744]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 801180c:	f104 0e20 	add.w	lr, r4, #32
 8011810:	46a4      	mov	ip, r4
 8011812:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011816:	6028      	str	r0, [r5, #0]
 8011818:	6069      	str	r1, [r5, #4]
 801181a:	60aa      	str	r2, [r5, #8]
 801181c:	60eb      	str	r3, [r5, #12]
 801181e:	4664      	mov	r4, ip
 8011820:	3510      	adds	r5, #16
 8011822:	45f4      	cmp	ip, lr
 8011824:	d1f4      	bne.n	8011810 <fRspAnalyze_CREG+0x14>
 8011826:	cc03      	ldmia	r4!, {r0, r1}
 8011828:	6028      	str	r0, [r5, #0]
 801182a:	6069      	str	r1, [r5, #4]
 801182c:	4cb1      	ldr	r4, [pc, #708]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 801182e:	4620      	mov	r0, r4
 8011830:	f00d fd7b 	bl	801f32a <crs_strlen>
 8011834:	b283      	uxth	r3, r0
 8011836:	4622      	mov	r2, r4
 8011838:	2104      	movs	r1, #4
 801183a:	2002      	movs	r0, #2
 801183c:	f00d fdb8 	bl	801f3b0 <traceIF_itmPrint>
 8011840:	4620      	mov	r0, r4
 8011842:	f00d fd72 	bl	801f32a <crs_strlen>
 8011846:	b283      	uxth	r3, r0
 8011848:	4622      	mov	r2, r4
 801184a:	2104      	movs	r1, #4
 801184c:	2002      	movs	r0, #2
 801184e:	f00d fdd1 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("current cmd = %ld", p_atp_ctxt->current_atcmd.id)
 8011852:	69fa      	ldr	r2, [r7, #28]
 8011854:	49a8      	ldr	r1, [pc, #672]	; (8011af8 <fRspAnalyze_CREG+0x2fc>)
 8011856:	4620      	mov	r0, r4
 8011858:	f014 fff6 	bl	8026848 <sprintf>
 801185c:	4620      	mov	r0, r4
 801185e:	f00d fd64 	bl	801f32a <crs_strlen>
 8011862:	b283      	uxth	r3, r0
 8011864:	4622      	mov	r2, r4
 8011866:	2102      	movs	r1, #2
 8011868:	4608      	mov	r0, r1
 801186a:	f00d fda1 	bl	801f3b0 <traceIF_itmPrint>
 801186e:	4620      	mov	r0, r4
 8011870:	f00d fd5b 	bl	801f32a <crs_strlen>
 8011874:	b283      	uxth	r3, r0
 8011876:	4622      	mov	r2, r4
 8011878:	2102      	movs	r1, #2
 801187a:	4608      	mov	r0, r1
 801187c:	f00d fdba 	bl	801f3f4 <traceIF_uartPrint>
  *  2/ answer to CREG test command
  *     +CREG: (list of supported <n>s)
  *  3/ URC:
  *     +CREG: <stat>[,[<lac>],[<ci>],[<AcT>]]
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CREG)
 8011880:	69fb      	ldr	r3, [r7, #28]
 8011882:	2b17      	cmp	r3, #23
 8011884:	f040 80f2 	bne.w	8011a6c <fRspAnalyze_CREG+0x270>
  {
    /* analyze parameters for +CREG */
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8011888:	8b3b      	ldrh	r3, [r7, #24]
 801188a:	2b02      	cmp	r3, #2
 801188c:	d005      	beq.n	801189a <fRspAnalyze_CREG+0x9e>
      }
      /* other parameters are not supported yet */
      END_PARAM_LOOP()
    }
    /* analyze parameters for +CREG */
    else if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 801188e:	2b01      	cmp	r3, #1
 8011890:	f000 80c4 	beq.w	8011a1c <fRspAnalyze_CREG+0x220>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8011894:	2010      	movs	r0, #16
 8011896:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      START_PARAM_LOOP()
 801189a:	2400      	movs	r4, #0
 801189c:	4632      	mov	r2, r6
 801189e:	4641      	mov	r1, r8
 80118a0:	4638      	mov	r0, r7
 80118a2:	f7fa fdd1 	bl	800c448 <atcc_extractElement>
 80118a6:	2801      	cmp	r0, #1
 80118a8:	d000      	beq.n	80118ac <fRspAnalyze_CREG+0xb0>
 80118aa:	2401      	movs	r4, #1
 80118ac:	89f1      	ldrh	r1, [r6, #14]
 80118ae:	b179      	cbz	r1, 80118d0 <fRspAnalyze_CREG+0xd4>
      if (element_infos->param_rank == 2U)
 80118b0:	8933      	ldrh	r3, [r6, #8]
 80118b2:	2b02      	cmp	r3, #2
 80118b4:	d00f      	beq.n	80118d6 <fRspAnalyze_CREG+0xda>
      if (element_infos->param_rank == 3U)
 80118b6:	8933      	ldrh	r3, [r6, #8]
 80118b8:	2b03      	cmp	r3, #3
 80118ba:	d029      	beq.n	8011910 <fRspAnalyze_CREG+0x114>
      if (element_infos->param_rank == 4U)
 80118bc:	8933      	ldrh	r3, [r6, #8]
 80118be:	2b04      	cmp	r3, #4
 80118c0:	d04a      	beq.n	8011958 <fRspAnalyze_CREG+0x15c>
      if (element_infos->param_rank == 5U)
 80118c2:	8933      	ldrh	r3, [r6, #8]
 80118c4:	2b05      	cmp	r3, #5
 80118c6:	d069      	beq.n	801199c <fRspAnalyze_CREG+0x1a0>
      if (element_infos->param_rank == 6U)
 80118c8:	8933      	ldrh	r3, [r6, #8]
 80118ca:	2b06      	cmp	r3, #6
 80118cc:	f000 8088 	beq.w	80119e0 <fRspAnalyze_CREG+0x1e4>
      END_PARAM_LOOP()
 80118d0:	2c00      	cmp	r4, #0
 80118d2:	d1df      	bne.n	8011894 <fRspAnalyze_CREG+0x98>
 80118d4:	e7e2      	b.n	801189c <fRspAnalyze_CREG+0xa0>
        PRINT_DBG("+CREG: n=%ld",
 80118d6:	8970      	ldrh	r0, [r6, #10]
 80118d8:	4440      	add	r0, r8
 80118da:	f003 fa2b 	bl	8014d34 <ATutil_convertStringToInt>
 80118de:	4602      	mov	r2, r0
 80118e0:	4d84      	ldr	r5, [pc, #528]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 80118e2:	4986      	ldr	r1, [pc, #536]	; (8011afc <fRspAnalyze_CREG+0x300>)
 80118e4:	4628      	mov	r0, r5
 80118e6:	f014 ffaf 	bl	8026848 <sprintf>
 80118ea:	4628      	mov	r0, r5
 80118ec:	f00d fd1d 	bl	801f32a <crs_strlen>
 80118f0:	b283      	uxth	r3, r0
 80118f2:	462a      	mov	r2, r5
 80118f4:	2102      	movs	r1, #2
 80118f6:	4608      	mov	r0, r1
 80118f8:	f00d fd5a 	bl	801f3b0 <traceIF_itmPrint>
 80118fc:	4628      	mov	r0, r5
 80118fe:	f00d fd14 	bl	801f32a <crs_strlen>
 8011902:	b283      	uxth	r3, r0
 8011904:	462a      	mov	r2, r5
 8011906:	2102      	movs	r1, #2
 8011908:	4608      	mov	r0, r1
 801190a:	f00d fd73 	bl	801f3f4 <traceIF_uartPrint>
 801190e:	e7d2      	b.n	80118b6 <fRspAnalyze_CREG+0xba>
        uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011910:	8970      	ldrh	r0, [r6, #10]
 8011912:	89f1      	ldrh	r1, [r6, #14]
 8011914:	4440      	add	r0, r8
 8011916:	f003 fa0d 	bl	8014d34 <ATutil_convertStringToInt>
 801191a:	4682      	mov	sl, r0
        p_modem_ctxt->persist.cs_network_state = convert_NetworkState(stat, CS_NETWORK_TYPE);
 801191c:	2101      	movs	r1, #1
 801191e:	f7fc ffcb 	bl	800e8b8 <convert_NetworkState>
 8011922:	f8a9 0048 	strh.w	r0, [r9, #72]	; 0x48
        PRINT_DBG("+CREG: stat=%ld", stat)
 8011926:	4d73      	ldr	r5, [pc, #460]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011928:	4652      	mov	r2, sl
 801192a:	4975      	ldr	r1, [pc, #468]	; (8011b00 <fRspAnalyze_CREG+0x304>)
 801192c:	4628      	mov	r0, r5
 801192e:	f014 ff8b 	bl	8026848 <sprintf>
 8011932:	4628      	mov	r0, r5
 8011934:	f00d fcf9 	bl	801f32a <crs_strlen>
 8011938:	b283      	uxth	r3, r0
 801193a:	462a      	mov	r2, r5
 801193c:	2102      	movs	r1, #2
 801193e:	4608      	mov	r0, r1
 8011940:	f00d fd36 	bl	801f3b0 <traceIF_itmPrint>
 8011944:	4628      	mov	r0, r5
 8011946:	f00d fcf0 	bl	801f32a <crs_strlen>
 801194a:	b283      	uxth	r3, r0
 801194c:	462a      	mov	r2, r5
 801194e:	2102      	movs	r1, #2
 8011950:	4608      	mov	r0, r1
 8011952:	f00d fd4f 	bl	801f3f4 <traceIF_uartPrint>
 8011956:	e7b1      	b.n	80118bc <fRspAnalyze_CREG+0xc0>
        uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011958:	8970      	ldrh	r0, [r6, #10]
 801195a:	2204      	movs	r2, #4
 801195c:	89f1      	ldrh	r1, [r6, #14]
 801195e:	4440      	add	r0, r8
 8011960:	f7fd f948 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011964:	4602      	mov	r2, r0
        p_modem_ctxt->persist.cs_location_info.lac = (uint16_t)lac;
 8011966:	f8a9 0044 	strh.w	r0, [r9, #68]	; 0x44
        PRINT_INFO("+CREG: lac=%ld =0x%lx", lac, lac)
 801196a:	4d62      	ldr	r5, [pc, #392]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 801196c:	4603      	mov	r3, r0
 801196e:	4965      	ldr	r1, [pc, #404]	; (8011b04 <fRspAnalyze_CREG+0x308>)
 8011970:	4628      	mov	r0, r5
 8011972:	f014 ff69 	bl	8026848 <sprintf>
 8011976:	4628      	mov	r0, r5
 8011978:	f00d fcd7 	bl	801f32a <crs_strlen>
 801197c:	b283      	uxth	r3, r0
 801197e:	462a      	mov	r2, r5
 8011980:	2101      	movs	r1, #1
 8011982:	2002      	movs	r0, #2
 8011984:	f00d fd14 	bl	801f3b0 <traceIF_itmPrint>
 8011988:	4628      	mov	r0, r5
 801198a:	f00d fcce 	bl	801f32a <crs_strlen>
 801198e:	b283      	uxth	r3, r0
 8011990:	462a      	mov	r2, r5
 8011992:	2101      	movs	r1, #1
 8011994:	2002      	movs	r0, #2
 8011996:	f00d fd2d 	bl	801f3f4 <traceIF_uartPrint>
 801199a:	e792      	b.n	80118c2 <fRspAnalyze_CREG+0xc6>
        uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 801199c:	8970      	ldrh	r0, [r6, #10]
 801199e:	2208      	movs	r2, #8
 80119a0:	89f1      	ldrh	r1, [r6, #14]
 80119a2:	4440      	add	r0, r8
 80119a4:	f7fd f926 	bl	800ebf4 <extract_hex_value_from_quotes>
 80119a8:	4602      	mov	r2, r0
        p_modem_ctxt->persist.cs_location_info.ci = (uint32_t)ci;
 80119aa:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
        PRINT_INFO("+CREG: ci=%ld =0x%lx", ci, ci)
 80119ae:	4d51      	ldr	r5, [pc, #324]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 80119b0:	4603      	mov	r3, r0
 80119b2:	4955      	ldr	r1, [pc, #340]	; (8011b08 <fRspAnalyze_CREG+0x30c>)
 80119b4:	4628      	mov	r0, r5
 80119b6:	f014 ff47 	bl	8026848 <sprintf>
 80119ba:	4628      	mov	r0, r5
 80119bc:	f00d fcb5 	bl	801f32a <crs_strlen>
 80119c0:	b283      	uxth	r3, r0
 80119c2:	462a      	mov	r2, r5
 80119c4:	2101      	movs	r1, #1
 80119c6:	2002      	movs	r0, #2
 80119c8:	f00d fcf2 	bl	801f3b0 <traceIF_itmPrint>
 80119cc:	4628      	mov	r0, r5
 80119ce:	f00d fcac 	bl	801f32a <crs_strlen>
 80119d2:	b283      	uxth	r3, r0
 80119d4:	462a      	mov	r2, r5
 80119d6:	2101      	movs	r1, #1
 80119d8:	2002      	movs	r0, #2
 80119da:	f00d fd0b 	bl	801f3f4 <traceIF_uartPrint>
 80119de:	e773      	b.n	80118c8 <fRspAnalyze_CREG+0xcc>
        PRINT_DBG("+CREG: act=%ld",
 80119e0:	8970      	ldrh	r0, [r6, #10]
 80119e2:	89f1      	ldrh	r1, [r6, #14]
 80119e4:	4440      	add	r0, r8
 80119e6:	f003 f9a5 	bl	8014d34 <ATutil_convertStringToInt>
 80119ea:	4602      	mov	r2, r0
 80119ec:	4d41      	ldr	r5, [pc, #260]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 80119ee:	4947      	ldr	r1, [pc, #284]	; (8011b0c <fRspAnalyze_CREG+0x310>)
 80119f0:	4628      	mov	r0, r5
 80119f2:	f014 ff29 	bl	8026848 <sprintf>
 80119f6:	4628      	mov	r0, r5
 80119f8:	f00d fc97 	bl	801f32a <crs_strlen>
 80119fc:	b283      	uxth	r3, r0
 80119fe:	462a      	mov	r2, r5
 8011a00:	2102      	movs	r1, #2
 8011a02:	4608      	mov	r0, r1
 8011a04:	f00d fcd4 	bl	801f3b0 <traceIF_itmPrint>
 8011a08:	4628      	mov	r0, r5
 8011a0a:	f00d fc8e 	bl	801f32a <crs_strlen>
 8011a0e:	b283      	uxth	r3, r0
 8011a10:	462a      	mov	r2, r5
 8011a12:	2102      	movs	r1, #2
 8011a14:	4608      	mov	r0, r1
 8011a16:	f00d fced 	bl	801f3f4 <traceIF_uartPrint>
 8011a1a:	e759      	b.n	80118d0 <fRspAnalyze_CREG+0xd4>
      PRINT_DBG("+CREG for test cmd NOT IMPLEMENTED")
 8011a1c:	4d3c      	ldr	r5, [pc, #240]	; (8011b10 <fRspAnalyze_CREG+0x314>)
 8011a1e:	4c35      	ldr	r4, [pc, #212]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011a20:	f105 0720 	add.w	r7, r5, #32
 8011a24:	462e      	mov	r6, r5
 8011a26:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8011a28:	6020      	str	r0, [r4, #0]
 8011a2a:	6061      	str	r1, [r4, #4]
 8011a2c:	60a2      	str	r2, [r4, #8]
 8011a2e:	60e3      	str	r3, [r4, #12]
 8011a30:	4635      	mov	r5, r6
 8011a32:	3410      	adds	r4, #16
 8011a34:	42be      	cmp	r6, r7
 8011a36:	d1f5      	bne.n	8011a24 <fRspAnalyze_CREG+0x228>
 8011a38:	cd07      	ldmia	r5!, {r0, r1, r2}
 8011a3a:	6020      	str	r0, [r4, #0]
 8011a3c:	6061      	str	r1, [r4, #4]
 8011a3e:	60a2      	str	r2, [r4, #8]
 8011a40:	882b      	ldrh	r3, [r5, #0]
 8011a42:	81a3      	strh	r3, [r4, #12]
 8011a44:	4c2b      	ldr	r4, [pc, #172]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011a46:	4620      	mov	r0, r4
 8011a48:	f00d fc6f 	bl	801f32a <crs_strlen>
 8011a4c:	b283      	uxth	r3, r0
 8011a4e:	4622      	mov	r2, r4
 8011a50:	2102      	movs	r1, #2
 8011a52:	4608      	mov	r0, r1
 8011a54:	f00d fcac 	bl	801f3b0 <traceIF_itmPrint>
 8011a58:	4620      	mov	r0, r4
 8011a5a:	f00d fc66 	bl	801f32a <crs_strlen>
 8011a5e:	b283      	uxth	r3, r0
 8011a60:	4622      	mov	r2, r4
 8011a62:	2102      	movs	r1, #2
 8011a64:	4608      	mov	r0, r1
 8011a66:	f00d fcc5 	bl	801f3f4 <traceIF_uartPrint>
 8011a6a:	e713      	b.n	8011894 <fRspAnalyze_CREG+0x98>
    START_PARAM_LOOP()
 8011a6c:	2400      	movs	r4, #0
 8011a6e:	4632      	mov	r2, r6
 8011a70:	4641      	mov	r1, r8
 8011a72:	4638      	mov	r0, r7
 8011a74:	f7fa fce8 	bl	800c448 <atcc_extractElement>
 8011a78:	2801      	cmp	r0, #1
 8011a7a:	d000      	beq.n	8011a7e <fRspAnalyze_CREG+0x282>
 8011a7c:	2401      	movs	r4, #1
 8011a7e:	89f1      	ldrh	r1, [r6, #14]
 8011a80:	b161      	cbz	r1, 8011a9c <fRspAnalyze_CREG+0x2a0>
    if (element_infos->param_rank == 2U)
 8011a82:	8933      	ldrh	r3, [r6, #8]
 8011a84:	2b02      	cmp	r3, #2
 8011a86:	d00d      	beq.n	8011aa4 <fRspAnalyze_CREG+0x2a8>
    if (element_infos->param_rank == 3U)
 8011a88:	8933      	ldrh	r3, [r6, #8]
 8011a8a:	2b03      	cmp	r3, #3
 8011a8c:	d044      	beq.n	8011b18 <fRspAnalyze_CREG+0x31c>
    if (element_infos->param_rank == 4U)
 8011a8e:	8933      	ldrh	r3, [r6, #8]
 8011a90:	2b04      	cmp	r3, #4
 8011a92:	d067      	beq.n	8011b64 <fRspAnalyze_CREG+0x368>
    if (element_infos->param_rank == 5U)
 8011a94:	8933      	ldrh	r3, [r6, #8]
 8011a96:	2b05      	cmp	r3, #5
 8011a98:	f000 808a 	beq.w	8011bb0 <fRspAnalyze_CREG+0x3b4>
    END_PARAM_LOOP()
 8011a9c:	2c00      	cmp	r4, #0
 8011a9e:	f47f aef9 	bne.w	8011894 <fRspAnalyze_CREG+0x98>
 8011aa2:	e7e4      	b.n	8011a6e <fRspAnalyze_CREG+0x272>
      uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011aa4:	8970      	ldrh	r0, [r6, #10]
 8011aa6:	4440      	add	r0, r8
 8011aa8:	f003 f944 	bl	8014d34 <ATutil_convertStringToInt>
 8011aac:	4682      	mov	sl, r0
      p_modem_ctxt->persist.urc_avail_cs_network_registration = AT_TRUE;
 8011aae:	2101      	movs	r1, #1
 8011ab0:	f889 101a 	strb.w	r1, [r9, #26]
      p_modem_ctxt->persist.cs_network_state = convert_NetworkState(stat, CS_NETWORK_TYPE);
 8011ab4:	f7fc ff00 	bl	800e8b8 <convert_NetworkState>
 8011ab8:	f8a9 0048 	strh.w	r0, [r9, #72]	; 0x48
      PRINT_DBG("+CREG URC: stat=%ld", stat)
 8011abc:	4d0d      	ldr	r5, [pc, #52]	; (8011af4 <fRspAnalyze_CREG+0x2f8>)
 8011abe:	4652      	mov	r2, sl
 8011ac0:	4914      	ldr	r1, [pc, #80]	; (8011b14 <fRspAnalyze_CREG+0x318>)
 8011ac2:	4628      	mov	r0, r5
 8011ac4:	f014 fec0 	bl	8026848 <sprintf>
 8011ac8:	4628      	mov	r0, r5
 8011aca:	f00d fc2e 	bl	801f32a <crs_strlen>
 8011ace:	b283      	uxth	r3, r0
 8011ad0:	462a      	mov	r2, r5
 8011ad2:	2102      	movs	r1, #2
 8011ad4:	4608      	mov	r0, r1
 8011ad6:	f00d fc6b 	bl	801f3b0 <traceIF_itmPrint>
 8011ada:	4628      	mov	r0, r5
 8011adc:	f00d fc25 	bl	801f32a <crs_strlen>
 8011ae0:	b283      	uxth	r3, r0
 8011ae2:	462a      	mov	r2, r5
 8011ae4:	2102      	movs	r1, #2
 8011ae6:	4608      	mov	r0, r1
 8011ae8:	f00d fc84 	bl	801f3f4 <traceIF_uartPrint>
 8011aec:	e7cc      	b.n	8011a88 <fRspAnalyze_CREG+0x28c>
 8011aee:	bf00      	nop
 8011af0:	08030304 	.word	0x08030304
 8011af4:	200048dc 	.word	0x200048dc
 8011af8:	0803032c 	.word	0x0803032c
 8011afc:	0803034c 	.word	0x0803034c
 8011b00:	08030364 	.word	0x08030364
 8011b04:	08030380 	.word	0x08030380
 8011b08:	080303a4 	.word	0x080303a4
 8011b0c:	080303c4 	.word	0x080303c4
 8011b10:	080303e0 	.word	0x080303e0
 8011b14:	08030410 	.word	0x08030410
      uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011b18:	8970      	ldrh	r0, [r6, #10]
 8011b1a:	2204      	movs	r2, #4
 8011b1c:	89f1      	ldrh	r1, [r6, #14]
 8011b1e:	4440      	add	r0, r8
 8011b20:	f7fd f868 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011b24:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_cs_location_info_lac = AT_TRUE;
 8011b26:	f04f 0a01 	mov.w	sl, #1
 8011b2a:	f889 a01b 	strb.w	sl, [r9, #27]
      p_modem_ctxt->persist.cs_location_info.lac = (uint16_t)lac;
 8011b2e:	f8a9 0044 	strh.w	r0, [r9, #68]	; 0x44
      PRINT_INFO("+CREG URC: lac=%ld =0x%lx", lac, lac)
 8011b32:	4d2e      	ldr	r5, [pc, #184]	; (8011bec <fRspAnalyze_CREG+0x3f0>)
 8011b34:	4603      	mov	r3, r0
 8011b36:	492e      	ldr	r1, [pc, #184]	; (8011bf0 <fRspAnalyze_CREG+0x3f4>)
 8011b38:	4628      	mov	r0, r5
 8011b3a:	f014 fe85 	bl	8026848 <sprintf>
 8011b3e:	4628      	mov	r0, r5
 8011b40:	f00d fbf3 	bl	801f32a <crs_strlen>
 8011b44:	b283      	uxth	r3, r0
 8011b46:	462a      	mov	r2, r5
 8011b48:	4651      	mov	r1, sl
 8011b4a:	2002      	movs	r0, #2
 8011b4c:	f00d fc30 	bl	801f3b0 <traceIF_itmPrint>
 8011b50:	4628      	mov	r0, r5
 8011b52:	f00d fbea 	bl	801f32a <crs_strlen>
 8011b56:	b283      	uxth	r3, r0
 8011b58:	462a      	mov	r2, r5
 8011b5a:	4651      	mov	r1, sl
 8011b5c:	2002      	movs	r0, #2
 8011b5e:	f00d fc49 	bl	801f3f4 <traceIF_uartPrint>
 8011b62:	e794      	b.n	8011a8e <fRspAnalyze_CREG+0x292>
      uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011b64:	8970      	ldrh	r0, [r6, #10]
 8011b66:	2208      	movs	r2, #8
 8011b68:	89f1      	ldrh	r1, [r6, #14]
 8011b6a:	4440      	add	r0, r8
 8011b6c:	f7fd f842 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011b70:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_cs_location_info_ci = AT_TRUE;
 8011b72:	f04f 0a01 	mov.w	sl, #1
 8011b76:	f889 a01c 	strb.w	sl, [r9, #28]
      p_modem_ctxt->persist.cs_location_info.ci = (uint32_t)ci;
 8011b7a:	f8c9 0040 	str.w	r0, [r9, #64]	; 0x40
      PRINT_INFO("+CREG URC: ci=%ld =0x%lx", ci, ci)
 8011b7e:	4d1b      	ldr	r5, [pc, #108]	; (8011bec <fRspAnalyze_CREG+0x3f0>)
 8011b80:	4603      	mov	r3, r0
 8011b82:	491c      	ldr	r1, [pc, #112]	; (8011bf4 <fRspAnalyze_CREG+0x3f8>)
 8011b84:	4628      	mov	r0, r5
 8011b86:	f014 fe5f 	bl	8026848 <sprintf>
 8011b8a:	4628      	mov	r0, r5
 8011b8c:	f00d fbcd 	bl	801f32a <crs_strlen>
 8011b90:	b283      	uxth	r3, r0
 8011b92:	462a      	mov	r2, r5
 8011b94:	4651      	mov	r1, sl
 8011b96:	2002      	movs	r0, #2
 8011b98:	f00d fc0a 	bl	801f3b0 <traceIF_itmPrint>
 8011b9c:	4628      	mov	r0, r5
 8011b9e:	f00d fbc4 	bl	801f32a <crs_strlen>
 8011ba2:	b283      	uxth	r3, r0
 8011ba4:	462a      	mov	r2, r5
 8011ba6:	4651      	mov	r1, sl
 8011ba8:	2002      	movs	r0, #2
 8011baa:	f00d fc23 	bl	801f3f4 <traceIF_uartPrint>
 8011bae:	e771      	b.n	8011a94 <fRspAnalyze_CREG+0x298>
      PRINT_DBG("+CREG URC: act=%ld",
 8011bb0:	8970      	ldrh	r0, [r6, #10]
 8011bb2:	89f1      	ldrh	r1, [r6, #14]
 8011bb4:	4440      	add	r0, r8
 8011bb6:	f003 f8bd 	bl	8014d34 <ATutil_convertStringToInt>
 8011bba:	4602      	mov	r2, r0
 8011bbc:	4d0b      	ldr	r5, [pc, #44]	; (8011bec <fRspAnalyze_CREG+0x3f0>)
 8011bbe:	490e      	ldr	r1, [pc, #56]	; (8011bf8 <fRspAnalyze_CREG+0x3fc>)
 8011bc0:	4628      	mov	r0, r5
 8011bc2:	f014 fe41 	bl	8026848 <sprintf>
 8011bc6:	4628      	mov	r0, r5
 8011bc8:	f00d fbaf 	bl	801f32a <crs_strlen>
 8011bcc:	b283      	uxth	r3, r0
 8011bce:	462a      	mov	r2, r5
 8011bd0:	2102      	movs	r1, #2
 8011bd2:	4608      	mov	r0, r1
 8011bd4:	f00d fbec 	bl	801f3b0 <traceIF_itmPrint>
 8011bd8:	4628      	mov	r0, r5
 8011bda:	f00d fba6 	bl	801f32a <crs_strlen>
 8011bde:	b283      	uxth	r3, r0
 8011be0:	462a      	mov	r2, r5
 8011be2:	2102      	movs	r1, #2
 8011be4:	4608      	mov	r0, r1
 8011be6:	f00d fc05 	bl	801f3f4 <traceIF_uartPrint>
 8011bea:	e757      	b.n	8011a9c <fRspAnalyze_CREG+0x2a0>
 8011bec:	200048dc 	.word	0x200048dc
 8011bf0:	08030430 	.word	0x08030430
 8011bf4:	08030458 	.word	0x08030458
 8011bf8:	0803047c 	.word	0x0803047c

08011bfc <fRspAnalyze_CGREG>:

at_action_rsp_t fRspAnalyze_CGREG(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8011bfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011c00:	4607      	mov	r7, r0
 8011c02:	4689      	mov	r9, r1
 8011c04:	4690      	mov	r8, r2
 8011c06:	461d      	mov	r5, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGREG()")
 8011c08:	4cbf      	ldr	r4, [pc, #764]	; (8011f08 <fRspAnalyze_CGREG+0x30c>)
 8011c0a:	4ec0      	ldr	r6, [pc, #768]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011c0c:	f104 0e20 	add.w	lr, r4, #32
 8011c10:	46a4      	mov	ip, r4
 8011c12:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8011c16:	6030      	str	r0, [r6, #0]
 8011c18:	6071      	str	r1, [r6, #4]
 8011c1a:	60b2      	str	r2, [r6, #8]
 8011c1c:	60f3      	str	r3, [r6, #12]
 8011c1e:	4664      	mov	r4, ip
 8011c20:	3610      	adds	r6, #16
 8011c22:	45f4      	cmp	ip, lr
 8011c24:	d1f4      	bne.n	8011c10 <fRspAnalyze_CGREG+0x14>
 8011c26:	cc03      	ldmia	r4!, {r0, r1}
 8011c28:	6030      	str	r0, [r6, #0]
 8011c2a:	6071      	str	r1, [r6, #4]
 8011c2c:	7823      	ldrb	r3, [r4, #0]
 8011c2e:	7233      	strb	r3, [r6, #8]
 8011c30:	4cb6      	ldr	r4, [pc, #728]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011c32:	4620      	mov	r0, r4
 8011c34:	f00d fb79 	bl	801f32a <crs_strlen>
 8011c38:	b283      	uxth	r3, r0
 8011c3a:	4622      	mov	r2, r4
 8011c3c:	2104      	movs	r1, #4
 8011c3e:	2002      	movs	r0, #2
 8011c40:	f00d fbb6 	bl	801f3b0 <traceIF_itmPrint>
 8011c44:	4620      	mov	r0, r4
 8011c46:	f00d fb70 	bl	801f32a <crs_strlen>
 8011c4a:	b283      	uxth	r3, r0
 8011c4c:	4622      	mov	r2, r4
 8011c4e:	2104      	movs	r1, #4
 8011c50:	2002      	movs	r0, #2
 8011c52:	f00d fbcf 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("current cmd = %ld", p_atp_ctxt->current_atcmd.id)
 8011c56:	69fa      	ldr	r2, [r7, #28]
 8011c58:	49ad      	ldr	r1, [pc, #692]	; (8011f10 <fRspAnalyze_CGREG+0x314>)
 8011c5a:	4620      	mov	r0, r4
 8011c5c:	f014 fdf4 	bl	8026848 <sprintf>
 8011c60:	4620      	mov	r0, r4
 8011c62:	f00d fb62 	bl	801f32a <crs_strlen>
 8011c66:	b283      	uxth	r3, r0
 8011c68:	4622      	mov	r2, r4
 8011c6a:	2102      	movs	r1, #2
 8011c6c:	4608      	mov	r0, r1
 8011c6e:	f00d fb9f 	bl	801f3b0 <traceIF_itmPrint>
 8011c72:	4620      	mov	r0, r4
 8011c74:	f00d fb59 	bl	801f32a <crs_strlen>
 8011c78:	b283      	uxth	r3, r0
 8011c7a:	4622      	mov	r2, r4
 8011c7c:	2102      	movs	r1, #2
 8011c7e:	4608      	mov	r0, r1
 8011c80:	f00d fbb8 	bl	801f3f4 <traceIF_uartPrint>
  *  2/ answer to CGREG test command
  *     +CGREG: (list of supported <n>s)
  *  3/ URC:
  *     +CGREG: <stat>[,[<lac>],[<ci>],[<AcT>],[<rac>]]
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CGREG)
 8011c84:	69fb      	ldr	r3, [r7, #28]
 8011c86:	2b18      	cmp	r3, #24
 8011c88:	f040 81db 	bne.w	8012042 <fRspAnalyze_CGREG+0x446>
  {
    /* analyze parameters for +CREG */
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8011c8c:	8b3b      	ldrh	r3, [r7, #24]
 8011c8e:	2b02      	cmp	r3, #2
 8011c90:	d005      	beq.n	8011c9e <fRspAnalyze_CGREG+0xa2>
                                                 element_infos->str_size, 8))
      }
      END_PARAM_LOOP()
    }
    /* analyze parameters for +CGREG */
    else if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8011c92:	2b01      	cmp	r3, #1
 8011c94:	f000 81ab 	beq.w	8011fee <fRspAnalyze_CGREG+0x3f2>
    END_PARAM_LOOP()
  }

  return (retval);

}
 8011c98:	2010      	movs	r0, #16
 8011c9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      START_PARAM_LOOP()
 8011c9e:	2400      	movs	r4, #0
 8011ca0:	462a      	mov	r2, r5
 8011ca2:	4641      	mov	r1, r8
 8011ca4:	4638      	mov	r0, r7
 8011ca6:	f7fa fbcf 	bl	800c448 <atcc_extractElement>
 8011caa:	2801      	cmp	r0, #1
 8011cac:	d000      	beq.n	8011cb0 <fRspAnalyze_CGREG+0xb4>
 8011cae:	2401      	movs	r4, #1
 8011cb0:	89e9      	ldrh	r1, [r5, #14]
 8011cb2:	b341      	cbz	r1, 8011d06 <fRspAnalyze_CGREG+0x10a>
      if (element_infos->param_rank == 2U)
 8011cb4:	892b      	ldrh	r3, [r5, #8]
 8011cb6:	2b02      	cmp	r3, #2
 8011cb8:	d028      	beq.n	8011d0c <fRspAnalyze_CGREG+0x110>
      if (element_infos->param_rank == 3U)
 8011cba:	892b      	ldrh	r3, [r5, #8]
 8011cbc:	2b03      	cmp	r3, #3
 8011cbe:	d042      	beq.n	8011d46 <fRspAnalyze_CGREG+0x14a>
      if (element_infos->param_rank == 4U)
 8011cc0:	892b      	ldrh	r3, [r5, #8]
 8011cc2:	2b04      	cmp	r3, #4
 8011cc4:	d063      	beq.n	8011d8e <fRspAnalyze_CGREG+0x192>
      if (element_infos->param_rank == 5U)
 8011cc6:	892b      	ldrh	r3, [r5, #8]
 8011cc8:	2b05      	cmp	r3, #5
 8011cca:	f000 8082 	beq.w	8011dd2 <fRspAnalyze_CGREG+0x1d6>
      if (element_infos->param_rank == 6U)
 8011cce:	892b      	ldrh	r3, [r5, #8]
 8011cd0:	2b06      	cmp	r3, #6
 8011cd2:	f000 80a0 	beq.w	8011e16 <fRspAnalyze_CGREG+0x21a>
      if (element_infos->param_rank == 7U)
 8011cd6:	892b      	ldrh	r3, [r5, #8]
 8011cd8:	2b07      	cmp	r3, #7
 8011cda:	f000 80ba 	beq.w	8011e52 <fRspAnalyze_CGREG+0x256>
      if (element_infos->param_rank == 8U)
 8011cde:	892b      	ldrh	r3, [r5, #8]
 8011ce0:	2b08      	cmp	r3, #8
 8011ce2:	f000 80d4 	beq.w	8011e8e <fRspAnalyze_CGREG+0x292>
      if (element_infos->param_rank == 9U)
 8011ce6:	892b      	ldrh	r3, [r5, #8]
 8011ce8:	2b09      	cmp	r3, #9
 8011cea:	f000 80ee 	beq.w	8011eca <fRspAnalyze_CGREG+0x2ce>
      if (element_infos->param_rank == 10U)
 8011cee:	892b      	ldrh	r3, [r5, #8]
 8011cf0:	2b0a      	cmp	r3, #10
 8011cf2:	f000 811f 	beq.w	8011f34 <fRspAnalyze_CGREG+0x338>
      if (element_infos->param_rank == 11U)
 8011cf6:	892b      	ldrh	r3, [r5, #8]
 8011cf8:	2b0b      	cmp	r3, #11
 8011cfa:	f000 813a 	beq.w	8011f72 <fRspAnalyze_CGREG+0x376>
      if (element_infos->param_rank == 12U)
 8011cfe:	892b      	ldrh	r3, [r5, #8]
 8011d00:	2b0c      	cmp	r3, #12
 8011d02:	f000 8155 	beq.w	8011fb0 <fRspAnalyze_CGREG+0x3b4>
      END_PARAM_LOOP()
 8011d06:	2c00      	cmp	r4, #0
 8011d08:	d1c6      	bne.n	8011c98 <fRspAnalyze_CGREG+0x9c>
 8011d0a:	e7c9      	b.n	8011ca0 <fRspAnalyze_CGREG+0xa4>
        PRINT_DBG("+CGREG: n=%ld",
 8011d0c:	8968      	ldrh	r0, [r5, #10]
 8011d0e:	4440      	add	r0, r8
 8011d10:	f003 f810 	bl	8014d34 <ATutil_convertStringToInt>
 8011d14:	4602      	mov	r2, r0
 8011d16:	4e7d      	ldr	r6, [pc, #500]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011d18:	497e      	ldr	r1, [pc, #504]	; (8011f14 <fRspAnalyze_CGREG+0x318>)
 8011d1a:	4630      	mov	r0, r6
 8011d1c:	f014 fd94 	bl	8026848 <sprintf>
 8011d20:	4630      	mov	r0, r6
 8011d22:	f00d fb02 	bl	801f32a <crs_strlen>
 8011d26:	b283      	uxth	r3, r0
 8011d28:	4632      	mov	r2, r6
 8011d2a:	2102      	movs	r1, #2
 8011d2c:	4608      	mov	r0, r1
 8011d2e:	f00d fb3f 	bl	801f3b0 <traceIF_itmPrint>
 8011d32:	4630      	mov	r0, r6
 8011d34:	f00d faf9 	bl	801f32a <crs_strlen>
 8011d38:	b283      	uxth	r3, r0
 8011d3a:	4632      	mov	r2, r6
 8011d3c:	2102      	movs	r1, #2
 8011d3e:	4608      	mov	r0, r1
 8011d40:	f00d fb58 	bl	801f3f4 <traceIF_uartPrint>
 8011d44:	e7b9      	b.n	8011cba <fRspAnalyze_CGREG+0xbe>
        uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8011d46:	8968      	ldrh	r0, [r5, #10]
 8011d48:	89e9      	ldrh	r1, [r5, #14]
 8011d4a:	4440      	add	r0, r8
 8011d4c:	f002 fff2 	bl	8014d34 <ATutil_convertStringToInt>
 8011d50:	4682      	mov	sl, r0
        p_modem_ctxt->persist.gprs_network_state = convert_NetworkState(stat, GPRS_NETWORK_TYPE);
 8011d52:	2102      	movs	r1, #2
 8011d54:	f7fc fdb0 	bl	800e8b8 <convert_NetworkState>
 8011d58:	f8a9 003c 	strh.w	r0, [r9, #60]	; 0x3c
        PRINT_DBG("+CGREG: stat=%ld", stat)
 8011d5c:	4e6b      	ldr	r6, [pc, #428]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011d5e:	4652      	mov	r2, sl
 8011d60:	496d      	ldr	r1, [pc, #436]	; (8011f18 <fRspAnalyze_CGREG+0x31c>)
 8011d62:	4630      	mov	r0, r6
 8011d64:	f014 fd70 	bl	8026848 <sprintf>
 8011d68:	4630      	mov	r0, r6
 8011d6a:	f00d fade 	bl	801f32a <crs_strlen>
 8011d6e:	b283      	uxth	r3, r0
 8011d70:	4632      	mov	r2, r6
 8011d72:	2102      	movs	r1, #2
 8011d74:	4608      	mov	r0, r1
 8011d76:	f00d fb1b 	bl	801f3b0 <traceIF_itmPrint>
 8011d7a:	4630      	mov	r0, r6
 8011d7c:	f00d fad5 	bl	801f32a <crs_strlen>
 8011d80:	b283      	uxth	r3, r0
 8011d82:	4632      	mov	r2, r6
 8011d84:	2102      	movs	r1, #2
 8011d86:	4608      	mov	r0, r1
 8011d88:	f00d fb34 	bl	801f3f4 <traceIF_uartPrint>
 8011d8c:	e798      	b.n	8011cc0 <fRspAnalyze_CGREG+0xc4>
        uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011d8e:	8968      	ldrh	r0, [r5, #10]
 8011d90:	2204      	movs	r2, #4
 8011d92:	89e9      	ldrh	r1, [r5, #14]
 8011d94:	4440      	add	r0, r8
 8011d96:	f7fc ff2d 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011d9a:	4602      	mov	r2, r0
        p_modem_ctxt->persist.gprs_location_info.lac = (uint16_t)lac;
 8011d9c:	f8a9 0038 	strh.w	r0, [r9, #56]	; 0x38
        PRINT_INFO("+CGREG: lac=%ld =0x%lx", lac, lac)
 8011da0:	4e5a      	ldr	r6, [pc, #360]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011da2:	4603      	mov	r3, r0
 8011da4:	495d      	ldr	r1, [pc, #372]	; (8011f1c <fRspAnalyze_CGREG+0x320>)
 8011da6:	4630      	mov	r0, r6
 8011da8:	f014 fd4e 	bl	8026848 <sprintf>
 8011dac:	4630      	mov	r0, r6
 8011dae:	f00d fabc 	bl	801f32a <crs_strlen>
 8011db2:	b283      	uxth	r3, r0
 8011db4:	4632      	mov	r2, r6
 8011db6:	2101      	movs	r1, #1
 8011db8:	2002      	movs	r0, #2
 8011dba:	f00d faf9 	bl	801f3b0 <traceIF_itmPrint>
 8011dbe:	4630      	mov	r0, r6
 8011dc0:	f00d fab3 	bl	801f32a <crs_strlen>
 8011dc4:	b283      	uxth	r3, r0
 8011dc6:	4632      	mov	r2, r6
 8011dc8:	2101      	movs	r1, #1
 8011dca:	2002      	movs	r0, #2
 8011dcc:	f00d fb12 	bl	801f3f4 <traceIF_uartPrint>
 8011dd0:	e779      	b.n	8011cc6 <fRspAnalyze_CGREG+0xca>
        uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8011dd2:	8968      	ldrh	r0, [r5, #10]
 8011dd4:	2208      	movs	r2, #8
 8011dd6:	89e9      	ldrh	r1, [r5, #14]
 8011dd8:	4440      	add	r0, r8
 8011dda:	f7fc ff0b 	bl	800ebf4 <extract_hex_value_from_quotes>
 8011dde:	4602      	mov	r2, r0
        p_modem_ctxt->persist.gprs_location_info.ci = (uint32_t)ci;
 8011de0:	f8c9 0034 	str.w	r0, [r9, #52]	; 0x34
        PRINT_INFO("+CGREG: ci=%ld =0x%lx", ci, ci)
 8011de4:	4e49      	ldr	r6, [pc, #292]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011de6:	4603      	mov	r3, r0
 8011de8:	494d      	ldr	r1, [pc, #308]	; (8011f20 <fRspAnalyze_CGREG+0x324>)
 8011dea:	4630      	mov	r0, r6
 8011dec:	f014 fd2c 	bl	8026848 <sprintf>
 8011df0:	4630      	mov	r0, r6
 8011df2:	f00d fa9a 	bl	801f32a <crs_strlen>
 8011df6:	b283      	uxth	r3, r0
 8011df8:	4632      	mov	r2, r6
 8011dfa:	2101      	movs	r1, #1
 8011dfc:	2002      	movs	r0, #2
 8011dfe:	f00d fad7 	bl	801f3b0 <traceIF_itmPrint>
 8011e02:	4630      	mov	r0, r6
 8011e04:	f00d fa91 	bl	801f32a <crs_strlen>
 8011e08:	b283      	uxth	r3, r0
 8011e0a:	4632      	mov	r2, r6
 8011e0c:	2101      	movs	r1, #1
 8011e0e:	2002      	movs	r0, #2
 8011e10:	f00d faf0 	bl	801f3f4 <traceIF_uartPrint>
 8011e14:	e75b      	b.n	8011cce <fRspAnalyze_CGREG+0xd2>
        PRINT_DBG("+CGREG: act=%ld",
 8011e16:	8968      	ldrh	r0, [r5, #10]
 8011e18:	89e9      	ldrh	r1, [r5, #14]
 8011e1a:	4440      	add	r0, r8
 8011e1c:	f002 ff8a 	bl	8014d34 <ATutil_convertStringToInt>
 8011e20:	4602      	mov	r2, r0
 8011e22:	4e3a      	ldr	r6, [pc, #232]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011e24:	493f      	ldr	r1, [pc, #252]	; (8011f24 <fRspAnalyze_CGREG+0x328>)
 8011e26:	4630      	mov	r0, r6
 8011e28:	f014 fd0e 	bl	8026848 <sprintf>
 8011e2c:	4630      	mov	r0, r6
 8011e2e:	f00d fa7c 	bl	801f32a <crs_strlen>
 8011e32:	b283      	uxth	r3, r0
 8011e34:	4632      	mov	r2, r6
 8011e36:	2102      	movs	r1, #2
 8011e38:	4608      	mov	r0, r1
 8011e3a:	f00d fab9 	bl	801f3b0 <traceIF_itmPrint>
 8011e3e:	4630      	mov	r0, r6
 8011e40:	f00d fa73 	bl	801f32a <crs_strlen>
 8011e44:	b283      	uxth	r3, r0
 8011e46:	4632      	mov	r2, r6
 8011e48:	2102      	movs	r1, #2
 8011e4a:	4608      	mov	r0, r1
 8011e4c:	f00d fad2 	bl	801f3f4 <traceIF_uartPrint>
 8011e50:	e741      	b.n	8011cd6 <fRspAnalyze_CGREG+0xda>
        PRINT_DBG("+CGREG: rac=%ld",
 8011e52:	8968      	ldrh	r0, [r5, #10]
 8011e54:	89e9      	ldrh	r1, [r5, #14]
 8011e56:	4440      	add	r0, r8
 8011e58:	f002 ff6c 	bl	8014d34 <ATutil_convertStringToInt>
 8011e5c:	4602      	mov	r2, r0
 8011e5e:	4e2b      	ldr	r6, [pc, #172]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011e60:	4931      	ldr	r1, [pc, #196]	; (8011f28 <fRspAnalyze_CGREG+0x32c>)
 8011e62:	4630      	mov	r0, r6
 8011e64:	f014 fcf0 	bl	8026848 <sprintf>
 8011e68:	4630      	mov	r0, r6
 8011e6a:	f00d fa5e 	bl	801f32a <crs_strlen>
 8011e6e:	b283      	uxth	r3, r0
 8011e70:	4632      	mov	r2, r6
 8011e72:	2102      	movs	r1, #2
 8011e74:	4608      	mov	r0, r1
 8011e76:	f00d fa9b 	bl	801f3b0 <traceIF_itmPrint>
 8011e7a:	4630      	mov	r0, r6
 8011e7c:	f00d fa55 	bl	801f32a <crs_strlen>
 8011e80:	b283      	uxth	r3, r0
 8011e82:	4632      	mov	r2, r6
 8011e84:	2102      	movs	r1, #2
 8011e86:	4608      	mov	r0, r1
 8011e88:	f00d fab4 	bl	801f3f4 <traceIF_uartPrint>
 8011e8c:	e727      	b.n	8011cde <fRspAnalyze_CGREG+0xe2>
        PRINT_DBG("+CGREG: cause_type=%ld",
 8011e8e:	8968      	ldrh	r0, [r5, #10]
 8011e90:	89e9      	ldrh	r1, [r5, #14]
 8011e92:	4440      	add	r0, r8
 8011e94:	f002 ff4e 	bl	8014d34 <ATutil_convertStringToInt>
 8011e98:	4602      	mov	r2, r0
 8011e9a:	4e1c      	ldr	r6, [pc, #112]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011e9c:	4923      	ldr	r1, [pc, #140]	; (8011f2c <fRspAnalyze_CGREG+0x330>)
 8011e9e:	4630      	mov	r0, r6
 8011ea0:	f014 fcd2 	bl	8026848 <sprintf>
 8011ea4:	4630      	mov	r0, r6
 8011ea6:	f00d fa40 	bl	801f32a <crs_strlen>
 8011eaa:	b283      	uxth	r3, r0
 8011eac:	4632      	mov	r2, r6
 8011eae:	2102      	movs	r1, #2
 8011eb0:	4608      	mov	r0, r1
 8011eb2:	f00d fa7d 	bl	801f3b0 <traceIF_itmPrint>
 8011eb6:	4630      	mov	r0, r6
 8011eb8:	f00d fa37 	bl	801f32a <crs_strlen>
 8011ebc:	b283      	uxth	r3, r0
 8011ebe:	4632      	mov	r2, r6
 8011ec0:	2102      	movs	r1, #2
 8011ec2:	4608      	mov	r0, r1
 8011ec4:	f00d fa96 	bl	801f3f4 <traceIF_uartPrint>
 8011ec8:	e70d      	b.n	8011ce6 <fRspAnalyze_CGREG+0xea>
        PRINT_DBG("+CGREG: reject_cause=%ld",
 8011eca:	8968      	ldrh	r0, [r5, #10]
 8011ecc:	89e9      	ldrh	r1, [r5, #14]
 8011ece:	4440      	add	r0, r8
 8011ed0:	f002 ff30 	bl	8014d34 <ATutil_convertStringToInt>
 8011ed4:	4602      	mov	r2, r0
 8011ed6:	4e0d      	ldr	r6, [pc, #52]	; (8011f0c <fRspAnalyze_CGREG+0x310>)
 8011ed8:	4915      	ldr	r1, [pc, #84]	; (8011f30 <fRspAnalyze_CGREG+0x334>)
 8011eda:	4630      	mov	r0, r6
 8011edc:	f014 fcb4 	bl	8026848 <sprintf>
 8011ee0:	4630      	mov	r0, r6
 8011ee2:	f00d fa22 	bl	801f32a <crs_strlen>
 8011ee6:	b283      	uxth	r3, r0
 8011ee8:	4632      	mov	r2, r6
 8011eea:	2102      	movs	r1, #2
 8011eec:	4608      	mov	r0, r1
 8011eee:	f00d fa5f 	bl	801f3b0 <traceIF_itmPrint>
 8011ef2:	4630      	mov	r0, r6
 8011ef4:	f00d fa19 	bl	801f32a <crs_strlen>
 8011ef8:	b283      	uxth	r3, r0
 8011efa:	4632      	mov	r2, r6
 8011efc:	2102      	movs	r1, #2
 8011efe:	4608      	mov	r0, r1
 8011f00:	f00d fa78 	bl	801f3f4 <traceIF_uartPrint>
 8011f04:	e6f3      	b.n	8011cee <fRspAnalyze_CGREG+0xf2>
 8011f06:	bf00      	nop
 8011f08:	0803049c 	.word	0x0803049c
 8011f0c:	200048dc 	.word	0x200048dc
 8011f10:	0803032c 	.word	0x0803032c
 8011f14:	080304c8 	.word	0x080304c8
 8011f18:	080304e4 	.word	0x080304e4
 8011f1c:	08030500 	.word	0x08030500
 8011f20:	08030524 	.word	0x08030524
 8011f24:	08030548 	.word	0x08030548
 8011f28:	08030564 	.word	0x08030564
 8011f2c:	08030580 	.word	0x08030580
 8011f30:	080305a4 	.word	0x080305a4
        PRINT_INFO("+CGREG: active_time= 0x%lx)",
 8011f34:	8968      	ldrh	r0, [r5, #10]
 8011f36:	2208      	movs	r2, #8
 8011f38:	89e9      	ldrh	r1, [r5, #14]
 8011f3a:	4440      	add	r0, r8
 8011f3c:	f7fc fe69 	bl	800ec12 <extract_bin_value_from_quotes>
 8011f40:	4602      	mov	r2, r0
 8011f42:	4ec0      	ldr	r6, [pc, #768]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011f44:	49c0      	ldr	r1, [pc, #768]	; (8012248 <fRspAnalyze_CGREG+0x64c>)
 8011f46:	4630      	mov	r0, r6
 8011f48:	f014 fc7e 	bl	8026848 <sprintf>
 8011f4c:	4630      	mov	r0, r6
 8011f4e:	f00d f9ec 	bl	801f32a <crs_strlen>
 8011f52:	b283      	uxth	r3, r0
 8011f54:	4632      	mov	r2, r6
 8011f56:	2101      	movs	r1, #1
 8011f58:	2002      	movs	r0, #2
 8011f5a:	f00d fa29 	bl	801f3b0 <traceIF_itmPrint>
 8011f5e:	4630      	mov	r0, r6
 8011f60:	f00d f9e3 	bl	801f32a <crs_strlen>
 8011f64:	b283      	uxth	r3, r0
 8011f66:	4632      	mov	r2, r6
 8011f68:	2101      	movs	r1, #1
 8011f6a:	2002      	movs	r0, #2
 8011f6c:	f00d fa42 	bl	801f3f4 <traceIF_uartPrint>
 8011f70:	e6c1      	b.n	8011cf6 <fRspAnalyze_CGREG+0xfa>
        PRINT_INFO("+CGREG: periodic_rau= 0x%lx",
 8011f72:	8968      	ldrh	r0, [r5, #10]
 8011f74:	2208      	movs	r2, #8
 8011f76:	89e9      	ldrh	r1, [r5, #14]
 8011f78:	4440      	add	r0, r8
 8011f7a:	f7fc fe4a 	bl	800ec12 <extract_bin_value_from_quotes>
 8011f7e:	4602      	mov	r2, r0
 8011f80:	4eb0      	ldr	r6, [pc, #704]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011f82:	49b2      	ldr	r1, [pc, #712]	; (801224c <fRspAnalyze_CGREG+0x650>)
 8011f84:	4630      	mov	r0, r6
 8011f86:	f014 fc5f 	bl	8026848 <sprintf>
 8011f8a:	4630      	mov	r0, r6
 8011f8c:	f00d f9cd 	bl	801f32a <crs_strlen>
 8011f90:	b283      	uxth	r3, r0
 8011f92:	4632      	mov	r2, r6
 8011f94:	2101      	movs	r1, #1
 8011f96:	2002      	movs	r0, #2
 8011f98:	f00d fa0a 	bl	801f3b0 <traceIF_itmPrint>
 8011f9c:	4630      	mov	r0, r6
 8011f9e:	f00d f9c4 	bl	801f32a <crs_strlen>
 8011fa2:	b283      	uxth	r3, r0
 8011fa4:	4632      	mov	r2, r6
 8011fa6:	2101      	movs	r1, #1
 8011fa8:	2002      	movs	r0, #2
 8011faa:	f00d fa23 	bl	801f3f4 <traceIF_uartPrint>
 8011fae:	e6a6      	b.n	8011cfe <fRspAnalyze_CGREG+0x102>
        PRINT_INFO("+CGREG: gprs_ready_timer= 0x%lx",
 8011fb0:	8968      	ldrh	r0, [r5, #10]
 8011fb2:	2208      	movs	r2, #8
 8011fb4:	89e9      	ldrh	r1, [r5, #14]
 8011fb6:	4440      	add	r0, r8
 8011fb8:	f7fc fe2b 	bl	800ec12 <extract_bin_value_from_quotes>
 8011fbc:	4602      	mov	r2, r0
 8011fbe:	4ea1      	ldr	r6, [pc, #644]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011fc0:	49a3      	ldr	r1, [pc, #652]	; (8012250 <fRspAnalyze_CGREG+0x654>)
 8011fc2:	4630      	mov	r0, r6
 8011fc4:	f014 fc40 	bl	8026848 <sprintf>
 8011fc8:	4630      	mov	r0, r6
 8011fca:	f00d f9ae 	bl	801f32a <crs_strlen>
 8011fce:	b283      	uxth	r3, r0
 8011fd0:	4632      	mov	r2, r6
 8011fd2:	2101      	movs	r1, #1
 8011fd4:	2002      	movs	r0, #2
 8011fd6:	f00d f9eb 	bl	801f3b0 <traceIF_itmPrint>
 8011fda:	4630      	mov	r0, r6
 8011fdc:	f00d f9a5 	bl	801f32a <crs_strlen>
 8011fe0:	b283      	uxth	r3, r0
 8011fe2:	4632      	mov	r2, r6
 8011fe4:	2101      	movs	r1, #1
 8011fe6:	2002      	movs	r0, #2
 8011fe8:	f00d fa04 	bl	801f3f4 <traceIF_uartPrint>
 8011fec:	e68b      	b.n	8011d06 <fRspAnalyze_CGREG+0x10a>
      PRINT_DBG("+CGREG for test cmd NOT IMPLEMENTED")
 8011fee:	4d99      	ldr	r5, [pc, #612]	; (8012254 <fRspAnalyze_CGREG+0x658>)
 8011ff0:	4c94      	ldr	r4, [pc, #592]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8011ff2:	f105 0720 	add.w	r7, r5, #32
 8011ff6:	462e      	mov	r6, r5
 8011ff8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8011ffa:	6020      	str	r0, [r4, #0]
 8011ffc:	6061      	str	r1, [r4, #4]
 8011ffe:	60a2      	str	r2, [r4, #8]
 8012000:	60e3      	str	r3, [r4, #12]
 8012002:	4635      	mov	r5, r6
 8012004:	3410      	adds	r4, #16
 8012006:	42be      	cmp	r6, r7
 8012008:	d1f5      	bne.n	8011ff6 <fRspAnalyze_CGREG+0x3fa>
 801200a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801200c:	6020      	str	r0, [r4, #0]
 801200e:	6061      	str	r1, [r4, #4]
 8012010:	60a2      	str	r2, [r4, #8]
 8012012:	882a      	ldrh	r2, [r5, #0]
 8012014:	78ab      	ldrb	r3, [r5, #2]
 8012016:	81a2      	strh	r2, [r4, #12]
 8012018:	73a3      	strb	r3, [r4, #14]
 801201a:	4c8a      	ldr	r4, [pc, #552]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 801201c:	4620      	mov	r0, r4
 801201e:	f00d f984 	bl	801f32a <crs_strlen>
 8012022:	b283      	uxth	r3, r0
 8012024:	4622      	mov	r2, r4
 8012026:	2102      	movs	r1, #2
 8012028:	4608      	mov	r0, r1
 801202a:	f00d f9c1 	bl	801f3b0 <traceIF_itmPrint>
 801202e:	4620      	mov	r0, r4
 8012030:	f00d f97b 	bl	801f32a <crs_strlen>
 8012034:	b283      	uxth	r3, r0
 8012036:	4622      	mov	r2, r4
 8012038:	2102      	movs	r1, #2
 801203a:	4608      	mov	r0, r1
 801203c:	f00d f9da 	bl	801f3f4 <traceIF_uartPrint>
 8012040:	e62a      	b.n	8011c98 <fRspAnalyze_CGREG+0x9c>
    START_PARAM_LOOP()
 8012042:	2400      	movs	r4, #0
 8012044:	462a      	mov	r2, r5
 8012046:	4641      	mov	r1, r8
 8012048:	4638      	mov	r0, r7
 801204a:	f7fa f9fd 	bl	800c448 <atcc_extractElement>
 801204e:	2801      	cmp	r0, #1
 8012050:	d000      	beq.n	8012054 <fRspAnalyze_CGREG+0x458>
 8012052:	2401      	movs	r4, #1
 8012054:	89e9      	ldrh	r1, [r5, #14]
 8012056:	b321      	cbz	r1, 80120a2 <fRspAnalyze_CGREG+0x4a6>
    if (element_infos->param_rank == 2U)
 8012058:	892b      	ldrh	r3, [r5, #8]
 801205a:	2b02      	cmp	r3, #2
 801205c:	d025      	beq.n	80120aa <fRspAnalyze_CGREG+0x4ae>
    if (element_infos->param_rank == 3U)
 801205e:	892b      	ldrh	r3, [r5, #8]
 8012060:	2b03      	cmp	r3, #3
 8012062:	d048      	beq.n	80120f6 <fRspAnalyze_CGREG+0x4fa>
    if (element_infos->param_rank == 4U)
 8012064:	892b      	ldrh	r3, [r5, #8]
 8012066:	2b04      	cmp	r3, #4
 8012068:	d06b      	beq.n	8012142 <fRspAnalyze_CGREG+0x546>
    if (element_infos->param_rank == 5U)
 801206a:	892b      	ldrh	r3, [r5, #8]
 801206c:	2b05      	cmp	r3, #5
 801206e:	f000 808e 	beq.w	801218e <fRspAnalyze_CGREG+0x592>
    if (element_infos->param_rank == 6U)
 8012072:	892b      	ldrh	r3, [r5, #8]
 8012074:	2b06      	cmp	r3, #6
 8012076:	f000 80a8 	beq.w	80121ca <fRspAnalyze_CGREG+0x5ce>
    if (element_infos->param_rank == 7U)
 801207a:	892b      	ldrh	r3, [r5, #8]
 801207c:	2b07      	cmp	r3, #7
 801207e:	f000 80c3 	beq.w	8012208 <fRspAnalyze_CGREG+0x60c>
    if (element_infos->param_rank == 8U)
 8012082:	892b      	ldrh	r3, [r5, #8]
 8012084:	2b08      	cmp	r3, #8
 8012086:	f000 80f3 	beq.w	8012270 <fRspAnalyze_CGREG+0x674>
    if (element_infos->param_rank == 9U)
 801208a:	892b      	ldrh	r3, [r5, #8]
 801208c:	2b09      	cmp	r3, #9
 801208e:	f000 810d 	beq.w	80122ac <fRspAnalyze_CGREG+0x6b0>
    if (element_infos->param_rank == 10U)
 8012092:	892b      	ldrh	r3, [r5, #8]
 8012094:	2b0a      	cmp	r3, #10
 8012096:	f000 8128 	beq.w	80122ea <fRspAnalyze_CGREG+0x6ee>
    if (element_infos->param_rank == 11U)
 801209a:	892b      	ldrh	r3, [r5, #8]
 801209c:	2b0b      	cmp	r3, #11
 801209e:	f000 8143 	beq.w	8012328 <fRspAnalyze_CGREG+0x72c>
    END_PARAM_LOOP()
 80120a2:	2c00      	cmp	r4, #0
 80120a4:	f47f adf8 	bne.w	8011c98 <fRspAnalyze_CGREG+0x9c>
 80120a8:	e7cc      	b.n	8012044 <fRspAnalyze_CGREG+0x448>
      uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80120aa:	8968      	ldrh	r0, [r5, #10]
 80120ac:	4440      	add	r0, r8
 80120ae:	f002 fe41 	bl	8014d34 <ATutil_convertStringToInt>
 80120b2:	4682      	mov	sl, r0
      p_modem_ctxt->persist.urc_avail_gprs_network_registration = AT_TRUE;
 80120b4:	2301      	movs	r3, #1
 80120b6:	f889 3017 	strb.w	r3, [r9, #23]
      p_modem_ctxt->persist.gprs_network_state = convert_NetworkState(stat, GPRS_NETWORK_TYPE);
 80120ba:	2102      	movs	r1, #2
 80120bc:	f7fc fbfc 	bl	800e8b8 <convert_NetworkState>
 80120c0:	f8a9 003c 	strh.w	r0, [r9, #60]	; 0x3c
      PRINT_DBG("+CGREG URC: stat=%ld", stat)
 80120c4:	4e5f      	ldr	r6, [pc, #380]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 80120c6:	4652      	mov	r2, sl
 80120c8:	4963      	ldr	r1, [pc, #396]	; (8012258 <fRspAnalyze_CGREG+0x65c>)
 80120ca:	4630      	mov	r0, r6
 80120cc:	f014 fbbc 	bl	8026848 <sprintf>
 80120d0:	4630      	mov	r0, r6
 80120d2:	f00d f92a 	bl	801f32a <crs_strlen>
 80120d6:	b283      	uxth	r3, r0
 80120d8:	4632      	mov	r2, r6
 80120da:	2102      	movs	r1, #2
 80120dc:	4608      	mov	r0, r1
 80120de:	f00d f967 	bl	801f3b0 <traceIF_itmPrint>
 80120e2:	4630      	mov	r0, r6
 80120e4:	f00d f921 	bl	801f32a <crs_strlen>
 80120e8:	b283      	uxth	r3, r0
 80120ea:	4632      	mov	r2, r6
 80120ec:	2102      	movs	r1, #2
 80120ee:	4608      	mov	r0, r1
 80120f0:	f00d f980 	bl	801f3f4 <traceIF_uartPrint>
 80120f4:	e7b3      	b.n	801205e <fRspAnalyze_CGREG+0x462>
      uint32_t lac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 80120f6:	8968      	ldrh	r0, [r5, #10]
 80120f8:	2204      	movs	r2, #4
 80120fa:	89e9      	ldrh	r1, [r5, #14]
 80120fc:	4440      	add	r0, r8
 80120fe:	f7fc fd79 	bl	800ebf4 <extract_hex_value_from_quotes>
 8012102:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_gprs_location_info_lac = AT_TRUE;
 8012104:	f04f 0a01 	mov.w	sl, #1
 8012108:	f889 a018 	strb.w	sl, [r9, #24]
      p_modem_ctxt->persist.gprs_location_info.lac = (uint16_t)lac;
 801210c:	f8a9 0038 	strh.w	r0, [r9, #56]	; 0x38
      PRINT_INFO("+CGREG URC: lac=%ld =0x%lx", lac, lac)
 8012110:	4e4c      	ldr	r6, [pc, #304]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8012112:	4603      	mov	r3, r0
 8012114:	4951      	ldr	r1, [pc, #324]	; (801225c <fRspAnalyze_CGREG+0x660>)
 8012116:	4630      	mov	r0, r6
 8012118:	f014 fb96 	bl	8026848 <sprintf>
 801211c:	4630      	mov	r0, r6
 801211e:	f00d f904 	bl	801f32a <crs_strlen>
 8012122:	b283      	uxth	r3, r0
 8012124:	4632      	mov	r2, r6
 8012126:	4651      	mov	r1, sl
 8012128:	2002      	movs	r0, #2
 801212a:	f00d f941 	bl	801f3b0 <traceIF_itmPrint>
 801212e:	4630      	mov	r0, r6
 8012130:	f00d f8fb 	bl	801f32a <crs_strlen>
 8012134:	b283      	uxth	r3, r0
 8012136:	4632      	mov	r2, r6
 8012138:	4651      	mov	r1, sl
 801213a:	2002      	movs	r0, #2
 801213c:	f00d f95a 	bl	801f3f4 <traceIF_uartPrint>
 8012140:	e790      	b.n	8012064 <fRspAnalyze_CGREG+0x468>
      uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8012142:	8968      	ldrh	r0, [r5, #10]
 8012144:	2208      	movs	r2, #8
 8012146:	89e9      	ldrh	r1, [r5, #14]
 8012148:	4440      	add	r0, r8
 801214a:	f7fc fd53 	bl	800ebf4 <extract_hex_value_from_quotes>
 801214e:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_gprs_location_info_ci = AT_TRUE;
 8012150:	f04f 0a01 	mov.w	sl, #1
 8012154:	f889 a019 	strb.w	sl, [r9, #25]
      p_modem_ctxt->persist.gprs_location_info.ci = (uint32_t)ci;
 8012158:	f8c9 0034 	str.w	r0, [r9, #52]	; 0x34
      PRINT_INFO("+CGREG URC: ci=%ld =0x%lx", ci, ci)
 801215c:	4e39      	ldr	r6, [pc, #228]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 801215e:	4603      	mov	r3, r0
 8012160:	493f      	ldr	r1, [pc, #252]	; (8012260 <fRspAnalyze_CGREG+0x664>)
 8012162:	4630      	mov	r0, r6
 8012164:	f014 fb70 	bl	8026848 <sprintf>
 8012168:	4630      	mov	r0, r6
 801216a:	f00d f8de 	bl	801f32a <crs_strlen>
 801216e:	b283      	uxth	r3, r0
 8012170:	4632      	mov	r2, r6
 8012172:	4651      	mov	r1, sl
 8012174:	2002      	movs	r0, #2
 8012176:	f00d f91b 	bl	801f3b0 <traceIF_itmPrint>
 801217a:	4630      	mov	r0, r6
 801217c:	f00d f8d5 	bl	801f32a <crs_strlen>
 8012180:	b283      	uxth	r3, r0
 8012182:	4632      	mov	r2, r6
 8012184:	4651      	mov	r1, sl
 8012186:	2002      	movs	r0, #2
 8012188:	f00d f934 	bl	801f3f4 <traceIF_uartPrint>
 801218c:	e76d      	b.n	801206a <fRspAnalyze_CGREG+0x46e>
      PRINT_DBG("+CGREG URC: act=%ld",
 801218e:	8968      	ldrh	r0, [r5, #10]
 8012190:	89e9      	ldrh	r1, [r5, #14]
 8012192:	4440      	add	r0, r8
 8012194:	f002 fdce 	bl	8014d34 <ATutil_convertStringToInt>
 8012198:	4602      	mov	r2, r0
 801219a:	4e2a      	ldr	r6, [pc, #168]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 801219c:	4931      	ldr	r1, [pc, #196]	; (8012264 <fRspAnalyze_CGREG+0x668>)
 801219e:	4630      	mov	r0, r6
 80121a0:	f014 fb52 	bl	8026848 <sprintf>
 80121a4:	4630      	mov	r0, r6
 80121a6:	f00d f8c0 	bl	801f32a <crs_strlen>
 80121aa:	b283      	uxth	r3, r0
 80121ac:	4632      	mov	r2, r6
 80121ae:	2102      	movs	r1, #2
 80121b0:	4608      	mov	r0, r1
 80121b2:	f00d f8fd 	bl	801f3b0 <traceIF_itmPrint>
 80121b6:	4630      	mov	r0, r6
 80121b8:	f00d f8b7 	bl	801f32a <crs_strlen>
 80121bc:	b283      	uxth	r3, r0
 80121be:	4632      	mov	r2, r6
 80121c0:	2102      	movs	r1, #2
 80121c2:	4608      	mov	r0, r1
 80121c4:	f00d f916 	bl	801f3f4 <traceIF_uartPrint>
 80121c8:	e753      	b.n	8012072 <fRspAnalyze_CGREG+0x476>
      PRINT_DBG("+CGREG URC: rac=%ld",
 80121ca:	8968      	ldrh	r0, [r5, #10]
 80121cc:	2202      	movs	r2, #2
 80121ce:	89e9      	ldrh	r1, [r5, #14]
 80121d0:	4440      	add	r0, r8
 80121d2:	f7fc fd0f 	bl	800ebf4 <extract_hex_value_from_quotes>
 80121d6:	4602      	mov	r2, r0
 80121d8:	4e1a      	ldr	r6, [pc, #104]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 80121da:	4923      	ldr	r1, [pc, #140]	; (8012268 <fRspAnalyze_CGREG+0x66c>)
 80121dc:	4630      	mov	r0, r6
 80121de:	f014 fb33 	bl	8026848 <sprintf>
 80121e2:	4630      	mov	r0, r6
 80121e4:	f00d f8a1 	bl	801f32a <crs_strlen>
 80121e8:	b283      	uxth	r3, r0
 80121ea:	4632      	mov	r2, r6
 80121ec:	2102      	movs	r1, #2
 80121ee:	4608      	mov	r0, r1
 80121f0:	f00d f8de 	bl	801f3b0 <traceIF_itmPrint>
 80121f4:	4630      	mov	r0, r6
 80121f6:	f00d f898 	bl	801f32a <crs_strlen>
 80121fa:	b283      	uxth	r3, r0
 80121fc:	4632      	mov	r2, r6
 80121fe:	2102      	movs	r1, #2
 8012200:	4608      	mov	r0, r1
 8012202:	f00d f8f7 	bl	801f3f4 <traceIF_uartPrint>
 8012206:	e738      	b.n	801207a <fRspAnalyze_CGREG+0x47e>
      PRINT_DBG("+CGREG URC: cause_type=%ld",
 8012208:	8968      	ldrh	r0, [r5, #10]
 801220a:	89e9      	ldrh	r1, [r5, #14]
 801220c:	4440      	add	r0, r8
 801220e:	f002 fd91 	bl	8014d34 <ATutil_convertStringToInt>
 8012212:	4602      	mov	r2, r0
 8012214:	4e0b      	ldr	r6, [pc, #44]	; (8012244 <fRspAnalyze_CGREG+0x648>)
 8012216:	4915      	ldr	r1, [pc, #84]	; (801226c <fRspAnalyze_CGREG+0x670>)
 8012218:	4630      	mov	r0, r6
 801221a:	f014 fb15 	bl	8026848 <sprintf>
 801221e:	4630      	mov	r0, r6
 8012220:	f00d f883 	bl	801f32a <crs_strlen>
 8012224:	b283      	uxth	r3, r0
 8012226:	4632      	mov	r2, r6
 8012228:	2102      	movs	r1, #2
 801222a:	4608      	mov	r0, r1
 801222c:	f00d f8c0 	bl	801f3b0 <traceIF_itmPrint>
 8012230:	4630      	mov	r0, r6
 8012232:	f00d f87a 	bl	801f32a <crs_strlen>
 8012236:	b283      	uxth	r3, r0
 8012238:	4632      	mov	r2, r6
 801223a:	2102      	movs	r1, #2
 801223c:	4608      	mov	r0, r1
 801223e:	f00d f8d9 	bl	801f3f4 <traceIF_uartPrint>
 8012242:	e71e      	b.n	8012082 <fRspAnalyze_CGREG+0x486>
 8012244:	200048dc 	.word	0x200048dc
 8012248:	080305c8 	.word	0x080305c8
 801224c:	080305f0 	.word	0x080305f0
 8012250:	08030618 	.word	0x08030618
 8012254:	08030644 	.word	0x08030644
 8012258:	08030674 	.word	0x08030674
 801225c:	08030694 	.word	0x08030694
 8012260:	080306bc 	.word	0x080306bc
 8012264:	080306e4 	.word	0x080306e4
 8012268:	08030704 	.word	0x08030704
 801226c:	08030724 	.word	0x08030724
      PRINT_DBG("+CGREG URC: reject_cause=%ld",
 8012270:	8968      	ldrh	r0, [r5, #10]
 8012272:	89e9      	ldrh	r1, [r5, #14]
 8012274:	4440      	add	r0, r8
 8012276:	f002 fd5d 	bl	8014d34 <ATutil_convertStringToInt>
 801227a:	4602      	mov	r2, r0
 801227c:	4e3a      	ldr	r6, [pc, #232]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 801227e:	493b      	ldr	r1, [pc, #236]	; (801236c <fRspAnalyze_CGREG+0x770>)
 8012280:	4630      	mov	r0, r6
 8012282:	f014 fae1 	bl	8026848 <sprintf>
 8012286:	4630      	mov	r0, r6
 8012288:	f00d f84f 	bl	801f32a <crs_strlen>
 801228c:	b283      	uxth	r3, r0
 801228e:	4632      	mov	r2, r6
 8012290:	2102      	movs	r1, #2
 8012292:	4608      	mov	r0, r1
 8012294:	f00d f88c 	bl	801f3b0 <traceIF_itmPrint>
 8012298:	4630      	mov	r0, r6
 801229a:	f00d f846 	bl	801f32a <crs_strlen>
 801229e:	b283      	uxth	r3, r0
 80122a0:	4632      	mov	r2, r6
 80122a2:	2102      	movs	r1, #2
 80122a4:	4608      	mov	r0, r1
 80122a6:	f00d f8a5 	bl	801f3f4 <traceIF_uartPrint>
 80122aa:	e6ee      	b.n	801208a <fRspAnalyze_CGREG+0x48e>
      PRINT_INFO("+CGREG URC: active_time= 0x%lx",
 80122ac:	8968      	ldrh	r0, [r5, #10]
 80122ae:	2208      	movs	r2, #8
 80122b0:	89e9      	ldrh	r1, [r5, #14]
 80122b2:	4440      	add	r0, r8
 80122b4:	f7fc fcad 	bl	800ec12 <extract_bin_value_from_quotes>
 80122b8:	4602      	mov	r2, r0
 80122ba:	4e2b      	ldr	r6, [pc, #172]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 80122bc:	492c      	ldr	r1, [pc, #176]	; (8012370 <fRspAnalyze_CGREG+0x774>)
 80122be:	4630      	mov	r0, r6
 80122c0:	f014 fac2 	bl	8026848 <sprintf>
 80122c4:	4630      	mov	r0, r6
 80122c6:	f00d f830 	bl	801f32a <crs_strlen>
 80122ca:	b283      	uxth	r3, r0
 80122cc:	4632      	mov	r2, r6
 80122ce:	2101      	movs	r1, #1
 80122d0:	2002      	movs	r0, #2
 80122d2:	f00d f86d 	bl	801f3b0 <traceIF_itmPrint>
 80122d6:	4630      	mov	r0, r6
 80122d8:	f00d f827 	bl	801f32a <crs_strlen>
 80122dc:	b283      	uxth	r3, r0
 80122de:	4632      	mov	r2, r6
 80122e0:	2101      	movs	r1, #1
 80122e2:	2002      	movs	r0, #2
 80122e4:	f00d f886 	bl	801f3f4 <traceIF_uartPrint>
 80122e8:	e6d3      	b.n	8012092 <fRspAnalyze_CGREG+0x496>
      PRINT_INFO("+CGREG URC: periodic_rau= 0x%lx",
 80122ea:	8968      	ldrh	r0, [r5, #10]
 80122ec:	2208      	movs	r2, #8
 80122ee:	89e9      	ldrh	r1, [r5, #14]
 80122f0:	4440      	add	r0, r8
 80122f2:	f7fc fc8e 	bl	800ec12 <extract_bin_value_from_quotes>
 80122f6:	4602      	mov	r2, r0
 80122f8:	4e1b      	ldr	r6, [pc, #108]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 80122fa:	491e      	ldr	r1, [pc, #120]	; (8012374 <fRspAnalyze_CGREG+0x778>)
 80122fc:	4630      	mov	r0, r6
 80122fe:	f014 faa3 	bl	8026848 <sprintf>
 8012302:	4630      	mov	r0, r6
 8012304:	f00d f811 	bl	801f32a <crs_strlen>
 8012308:	b283      	uxth	r3, r0
 801230a:	4632      	mov	r2, r6
 801230c:	2101      	movs	r1, #1
 801230e:	2002      	movs	r0, #2
 8012310:	f00d f84e 	bl	801f3b0 <traceIF_itmPrint>
 8012314:	4630      	mov	r0, r6
 8012316:	f00d f808 	bl	801f32a <crs_strlen>
 801231a:	b283      	uxth	r3, r0
 801231c:	4632      	mov	r2, r6
 801231e:	2101      	movs	r1, #1
 8012320:	2002      	movs	r0, #2
 8012322:	f00d f867 	bl	801f3f4 <traceIF_uartPrint>
 8012326:	e6b8      	b.n	801209a <fRspAnalyze_CGREG+0x49e>
      PRINT_INFO("+CGREG URC: gprs_ready_timer= 0x%lx",
 8012328:	8968      	ldrh	r0, [r5, #10]
 801232a:	2208      	movs	r2, #8
 801232c:	89e9      	ldrh	r1, [r5, #14]
 801232e:	4440      	add	r0, r8
 8012330:	f7fc fc6f 	bl	800ec12 <extract_bin_value_from_quotes>
 8012334:	4602      	mov	r2, r0
 8012336:	4e0c      	ldr	r6, [pc, #48]	; (8012368 <fRspAnalyze_CGREG+0x76c>)
 8012338:	490f      	ldr	r1, [pc, #60]	; (8012378 <fRspAnalyze_CGREG+0x77c>)
 801233a:	4630      	mov	r0, r6
 801233c:	f014 fa84 	bl	8026848 <sprintf>
 8012340:	4630      	mov	r0, r6
 8012342:	f00c fff2 	bl	801f32a <crs_strlen>
 8012346:	b283      	uxth	r3, r0
 8012348:	4632      	mov	r2, r6
 801234a:	2101      	movs	r1, #1
 801234c:	2002      	movs	r0, #2
 801234e:	f00d f82f 	bl	801f3b0 <traceIF_itmPrint>
 8012352:	4630      	mov	r0, r6
 8012354:	f00c ffe9 	bl	801f32a <crs_strlen>
 8012358:	b283      	uxth	r3, r0
 801235a:	4632      	mov	r2, r6
 801235c:	2101      	movs	r1, #1
 801235e:	2002      	movs	r0, #2
 8012360:	f00d f848 	bl	801f3f4 <traceIF_uartPrint>
 8012364:	e69d      	b.n	80120a2 <fRspAnalyze_CGREG+0x4a6>
 8012366:	bf00      	nop
 8012368:	200048dc 	.word	0x200048dc
 801236c:	0803074c 	.word	0x0803074c
 8012370:	08030774 	.word	0x08030774
 8012374:	080307a0 	.word	0x080307a0
 8012378:	080307cc 	.word	0x080307cc

0801237c <fRspAnalyze_CEREG>:

at_action_rsp_t fRspAnalyze_CEREG(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 801237c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012380:	4607      	mov	r7, r0
 8012382:	4689      	mov	r9, r1
 8012384:	4690      	mov	r8, r2
 8012386:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEREG()")
 8012388:	4cc6      	ldr	r4, [pc, #792]	; (80126a4 <fRspAnalyze_CEREG+0x328>)
 801238a:	4dc7      	ldr	r5, [pc, #796]	; (80126a8 <fRspAnalyze_CEREG+0x32c>)
 801238c:	f104 0e20 	add.w	lr, r4, #32
 8012390:	46a4      	mov	ip, r4
 8012392:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012396:	6028      	str	r0, [r5, #0]
 8012398:	6069      	str	r1, [r5, #4]
 801239a:	60aa      	str	r2, [r5, #8]
 801239c:	60eb      	str	r3, [r5, #12]
 801239e:	4664      	mov	r4, ip
 80123a0:	3510      	adds	r5, #16
 80123a2:	45f4      	cmp	ip, lr
 80123a4:	d1f4      	bne.n	8012390 <fRspAnalyze_CEREG+0x14>
 80123a6:	cc03      	ldmia	r4!, {r0, r1}
 80123a8:	6028      	str	r0, [r5, #0]
 80123aa:	6069      	str	r1, [r5, #4]
 80123ac:	7823      	ldrb	r3, [r4, #0]
 80123ae:	722b      	strb	r3, [r5, #8]
 80123b0:	4cbd      	ldr	r4, [pc, #756]	; (80126a8 <fRspAnalyze_CEREG+0x32c>)
 80123b2:	4620      	mov	r0, r4
 80123b4:	f00c ffb9 	bl	801f32a <crs_strlen>
 80123b8:	b283      	uxth	r3, r0
 80123ba:	4622      	mov	r2, r4
 80123bc:	2104      	movs	r1, #4
 80123be:	2002      	movs	r0, #2
 80123c0:	f00c fff6 	bl	801f3b0 <traceIF_itmPrint>
 80123c4:	4620      	mov	r0, r4
 80123c6:	f00c ffb0 	bl	801f32a <crs_strlen>
 80123ca:	b283      	uxth	r3, r0
 80123cc:	4622      	mov	r2, r4
 80123ce:	2104      	movs	r1, #4
 80123d0:	2002      	movs	r0, #2
 80123d2:	f00d f80f 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("current cmd = %ld", p_atp_ctxt->current_atcmd.id)
 80123d6:	69fa      	ldr	r2, [r7, #28]
 80123d8:	49b4      	ldr	r1, [pc, #720]	; (80126ac <fRspAnalyze_CEREG+0x330>)
 80123da:	4620      	mov	r0, r4
 80123dc:	f014 fa34 	bl	8026848 <sprintf>
 80123e0:	4620      	mov	r0, r4
 80123e2:	f00c ffa2 	bl	801f32a <crs_strlen>
 80123e6:	b283      	uxth	r3, r0
 80123e8:	4622      	mov	r2, r4
 80123ea:	2102      	movs	r1, #2
 80123ec:	4608      	mov	r0, r1
 80123ee:	f00c ffdf 	bl	801f3b0 <traceIF_itmPrint>
 80123f2:	4620      	mov	r0, r4
 80123f4:	f00c ff99 	bl	801f32a <crs_strlen>
 80123f8:	b283      	uxth	r3, r0
 80123fa:	4622      	mov	r2, r4
 80123fc:	2102      	movs	r1, #2
 80123fe:	4608      	mov	r0, r1
 8012400:	f00c fff8 	bl	801f3f4 <traceIF_uartPrint>
  *  2/ answer to CEREG test command
  *    +CEREG: (list of supported <n>s)
  *  3/ URC:
  *    +CEREG: <stat>[,[<tac>],[<ci>],[<AcT>]]
  */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CEREG)
 8012404:	69fb      	ldr	r3, [r7, #28]
 8012406:	2b19      	cmp	r3, #25
 8012408:	f040 81ea 	bne.w	80127e0 <fRspAnalyze_CEREG+0x464>
  {
    /* analyze parameters for +CEREG */
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 801240c:	8b3b      	ldrh	r3, [r7, #24]
 801240e:	2b02      	cmp	r3, #2
 8012410:	d005      	beq.n	801241e <fRspAnalyze_CEREG+0xa2>
      else
      { /* unexpecetd n value, ignore it */}
      END_PARAM_LOOP()
    }
    /* analyze parameters for +CEREG */
    else if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8012412:	2b01      	cmp	r3, #1
 8012414:	f000 81ba 	beq.w	801278c <fRspAnalyze_CEREG+0x410>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8012418:	2010      	movs	r0, #16
 801241a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      START_PARAM_LOOP()
 801241e:	2400      	movs	r4, #0
      uint32_t n_val = 0U;
 8012420:	4625      	mov	r5, r4
      START_PARAM_LOOP()
 8012422:	4632      	mov	r2, r6
 8012424:	4641      	mov	r1, r8
 8012426:	4638      	mov	r0, r7
 8012428:	f7fa f80e 	bl	800c448 <atcc_extractElement>
 801242c:	2801      	cmp	r0, #1
 801242e:	d000      	beq.n	8012432 <fRspAnalyze_CEREG+0xb6>
 8012430:	2401      	movs	r4, #1
 8012432:	89f1      	ldrh	r1, [r6, #14]
 8012434:	b1d1      	cbz	r1, 801246c <fRspAnalyze_CEREG+0xf0>
      if (element_infos->param_rank == 2U)
 8012436:	8933      	ldrh	r3, [r6, #8]
 8012438:	2b02      	cmp	r3, #2
 801243a:	d01a      	beq.n	8012472 <fRspAnalyze_CEREG+0xf6>
      if (element_infos->param_rank == 3U)
 801243c:	8933      	ldrh	r3, [r6, #8]
 801243e:	2b03      	cmp	r3, #3
 8012440:	d036      	beq.n	80124b0 <fRspAnalyze_CEREG+0x134>
      if (element_infos->param_rank == 4U)
 8012442:	8933      	ldrh	r3, [r6, #8]
 8012444:	2b04      	cmp	r3, #4
 8012446:	d058      	beq.n	80124fa <fRspAnalyze_CEREG+0x17e>
      if (element_infos->param_rank == 5U)
 8012448:	8933      	ldrh	r3, [r6, #8]
 801244a:	2b05      	cmp	r3, #5
 801244c:	d078      	beq.n	8012540 <fRspAnalyze_CEREG+0x1c4>
      if (element_infos->param_rank == 6U)
 801244e:	8933      	ldrh	r3, [r6, #8]
 8012450:	2b06      	cmp	r3, #6
 8012452:	f000 8098 	beq.w	8012586 <fRspAnalyze_CEREG+0x20a>
      if (n_val <= 3U)
 8012456:	2d03      	cmp	r5, #3
 8012458:	f200 80f2 	bhi.w	8012640 <fRspAnalyze_CEREG+0x2c4>
        if (element_infos->param_rank == 7U)
 801245c:	8933      	ldrh	r3, [r6, #8]
 801245e:	2b07      	cmp	r3, #7
 8012460:	f000 80b0 	beq.w	80125c4 <fRspAnalyze_CEREG+0x248>
        if (element_infos->param_rank == 8U)
 8012464:	8933      	ldrh	r3, [r6, #8]
 8012466:	2b08      	cmp	r3, #8
 8012468:	f000 80cb 	beq.w	8012602 <fRspAnalyze_CEREG+0x286>
      END_PARAM_LOOP()
 801246c:	2c00      	cmp	r4, #0
 801246e:	d1d3      	bne.n	8012418 <fRspAnalyze_CEREG+0x9c>
 8012470:	e7d7      	b.n	8012422 <fRspAnalyze_CEREG+0xa6>
        n_val = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size);
 8012472:	8970      	ldrh	r0, [r6, #10]
 8012474:	4440      	add	r0, r8
 8012476:	f002 fc5d 	bl	8014d34 <ATutil_convertStringToInt>
 801247a:	4605      	mov	r5, r0
        PRINT_DBG("+CEREG: n=%ld", n_val)
 801247c:	f8df a228 	ldr.w	sl, [pc, #552]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012480:	4602      	mov	r2, r0
 8012482:	498b      	ldr	r1, [pc, #556]	; (80126b0 <fRspAnalyze_CEREG+0x334>)
 8012484:	4650      	mov	r0, sl
 8012486:	f014 f9df 	bl	8026848 <sprintf>
 801248a:	4650      	mov	r0, sl
 801248c:	f00c ff4d 	bl	801f32a <crs_strlen>
 8012490:	b283      	uxth	r3, r0
 8012492:	4652      	mov	r2, sl
 8012494:	2102      	movs	r1, #2
 8012496:	4608      	mov	r0, r1
 8012498:	f00c ff8a 	bl	801f3b0 <traceIF_itmPrint>
 801249c:	4650      	mov	r0, sl
 801249e:	f00c ff44 	bl	801f32a <crs_strlen>
 80124a2:	b283      	uxth	r3, r0
 80124a4:	4652      	mov	r2, sl
 80124a6:	2102      	movs	r1, #2
 80124a8:	4608      	mov	r0, r1
 80124aa:	f00c ffa3 	bl	801f3f4 <traceIF_uartPrint>
 80124ae:	e7c5      	b.n	801243c <fRspAnalyze_CEREG+0xc0>
        uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80124b0:	8970      	ldrh	r0, [r6, #10]
 80124b2:	89f1      	ldrh	r1, [r6, #14]
 80124b4:	4440      	add	r0, r8
 80124b6:	f002 fc3d 	bl	8014d34 <ATutil_convertStringToInt>
 80124ba:	4683      	mov	fp, r0
        p_modem_ctxt->persist.eps_network_state = convert_NetworkState(stat, EPS_NETWORK_TYPE);
 80124bc:	2103      	movs	r1, #3
 80124be:	f7fc f9fb 	bl	800e8b8 <convert_NetworkState>
 80124c2:	f8a9 0030 	strh.w	r0, [r9, #48]	; 0x30
        PRINT_DBG("+CEREG: stat=%ld", stat)
 80124c6:	f8df a1e0 	ldr.w	sl, [pc, #480]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 80124ca:	465a      	mov	r2, fp
 80124cc:	4979      	ldr	r1, [pc, #484]	; (80126b4 <fRspAnalyze_CEREG+0x338>)
 80124ce:	4650      	mov	r0, sl
 80124d0:	f014 f9ba 	bl	8026848 <sprintf>
 80124d4:	4650      	mov	r0, sl
 80124d6:	f00c ff28 	bl	801f32a <crs_strlen>
 80124da:	b283      	uxth	r3, r0
 80124dc:	4652      	mov	r2, sl
 80124de:	2102      	movs	r1, #2
 80124e0:	4608      	mov	r0, r1
 80124e2:	f00c ff65 	bl	801f3b0 <traceIF_itmPrint>
 80124e6:	4650      	mov	r0, sl
 80124e8:	f00c ff1f 	bl	801f32a <crs_strlen>
 80124ec:	b283      	uxth	r3, r0
 80124ee:	4652      	mov	r2, sl
 80124f0:	2102      	movs	r1, #2
 80124f2:	4608      	mov	r0, r1
 80124f4:	f00c ff7e 	bl	801f3f4 <traceIF_uartPrint>
 80124f8:	e7a3      	b.n	8012442 <fRspAnalyze_CEREG+0xc6>
        uint32_t tac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 80124fa:	8970      	ldrh	r0, [r6, #10]
 80124fc:	2204      	movs	r2, #4
 80124fe:	89f1      	ldrh	r1, [r6, #14]
 8012500:	4440      	add	r0, r8
 8012502:	f7fc fb77 	bl	800ebf4 <extract_hex_value_from_quotes>
 8012506:	4602      	mov	r2, r0
        p_modem_ctxt->persist.eps_location_info.lac = (uint16_t)tac;
 8012508:	f8a9 002c 	strh.w	r0, [r9, #44]	; 0x2c
        PRINT_INFO("+CEREG: tac=%ld =0x%lx", tac, tac)
 801250c:	f8df a198 	ldr.w	sl, [pc, #408]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012510:	4603      	mov	r3, r0
 8012512:	4969      	ldr	r1, [pc, #420]	; (80126b8 <fRspAnalyze_CEREG+0x33c>)
 8012514:	4650      	mov	r0, sl
 8012516:	f014 f997 	bl	8026848 <sprintf>
 801251a:	4650      	mov	r0, sl
 801251c:	f00c ff05 	bl	801f32a <crs_strlen>
 8012520:	b283      	uxth	r3, r0
 8012522:	4652      	mov	r2, sl
 8012524:	2101      	movs	r1, #1
 8012526:	2002      	movs	r0, #2
 8012528:	f00c ff42 	bl	801f3b0 <traceIF_itmPrint>
 801252c:	4650      	mov	r0, sl
 801252e:	f00c fefc 	bl	801f32a <crs_strlen>
 8012532:	b283      	uxth	r3, r0
 8012534:	4652      	mov	r2, sl
 8012536:	2101      	movs	r1, #1
 8012538:	2002      	movs	r0, #2
 801253a:	f00c ff5b 	bl	801f3f4 <traceIF_uartPrint>
 801253e:	e783      	b.n	8012448 <fRspAnalyze_CEREG+0xcc>
        uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8012540:	8970      	ldrh	r0, [r6, #10]
 8012542:	2208      	movs	r2, #8
 8012544:	89f1      	ldrh	r1, [r6, #14]
 8012546:	4440      	add	r0, r8
 8012548:	f7fc fb54 	bl	800ebf4 <extract_hex_value_from_quotes>
 801254c:	4602      	mov	r2, r0
        p_modem_ctxt->persist.eps_location_info.ci = (uint32_t)ci;
 801254e:	f8c9 0028 	str.w	r0, [r9, #40]	; 0x28
        PRINT_INFO("+CEREG: ci=%ld =0x%lx", ci, ci)
 8012552:	f8df a154 	ldr.w	sl, [pc, #340]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012556:	4603      	mov	r3, r0
 8012558:	4958      	ldr	r1, [pc, #352]	; (80126bc <fRspAnalyze_CEREG+0x340>)
 801255a:	4650      	mov	r0, sl
 801255c:	f014 f974 	bl	8026848 <sprintf>
 8012560:	4650      	mov	r0, sl
 8012562:	f00c fee2 	bl	801f32a <crs_strlen>
 8012566:	b283      	uxth	r3, r0
 8012568:	4652      	mov	r2, sl
 801256a:	2101      	movs	r1, #1
 801256c:	2002      	movs	r0, #2
 801256e:	f00c ff1f 	bl	801f3b0 <traceIF_itmPrint>
 8012572:	4650      	mov	r0, sl
 8012574:	f00c fed9 	bl	801f32a <crs_strlen>
 8012578:	b283      	uxth	r3, r0
 801257a:	4652      	mov	r2, sl
 801257c:	2101      	movs	r1, #1
 801257e:	2002      	movs	r0, #2
 8012580:	f00c ff38 	bl	801f3f4 <traceIF_uartPrint>
 8012584:	e763      	b.n	801244e <fRspAnalyze_CEREG+0xd2>
        PRINT_INFO("+CEREG: act=%ld",
 8012586:	8970      	ldrh	r0, [r6, #10]
 8012588:	89f1      	ldrh	r1, [r6, #14]
 801258a:	4440      	add	r0, r8
 801258c:	f002 fbd2 	bl	8014d34 <ATutil_convertStringToInt>
 8012590:	4602      	mov	r2, r0
 8012592:	f8df a114 	ldr.w	sl, [pc, #276]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012596:	494a      	ldr	r1, [pc, #296]	; (80126c0 <fRspAnalyze_CEREG+0x344>)
 8012598:	4650      	mov	r0, sl
 801259a:	f014 f955 	bl	8026848 <sprintf>
 801259e:	4650      	mov	r0, sl
 80125a0:	f00c fec3 	bl	801f32a <crs_strlen>
 80125a4:	b283      	uxth	r3, r0
 80125a6:	4652      	mov	r2, sl
 80125a8:	2101      	movs	r1, #1
 80125aa:	2002      	movs	r0, #2
 80125ac:	f00c ff00 	bl	801f3b0 <traceIF_itmPrint>
 80125b0:	4650      	mov	r0, sl
 80125b2:	f00c feba 	bl	801f32a <crs_strlen>
 80125b6:	b283      	uxth	r3, r0
 80125b8:	4652      	mov	r2, sl
 80125ba:	2101      	movs	r1, #1
 80125bc:	2002      	movs	r0, #2
 80125be:	f00c ff19 	bl	801f3f4 <traceIF_uartPrint>
 80125c2:	e748      	b.n	8012456 <fRspAnalyze_CEREG+0xda>
          PRINT_DBG("+CEREG: cause_type=%ld",
 80125c4:	8970      	ldrh	r0, [r6, #10]
 80125c6:	89f1      	ldrh	r1, [r6, #14]
 80125c8:	4440      	add	r0, r8
 80125ca:	f002 fbb3 	bl	8014d34 <ATutil_convertStringToInt>
 80125ce:	4602      	mov	r2, r0
 80125d0:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 80125d4:	493b      	ldr	r1, [pc, #236]	; (80126c4 <fRspAnalyze_CEREG+0x348>)
 80125d6:	4650      	mov	r0, sl
 80125d8:	f014 f936 	bl	8026848 <sprintf>
 80125dc:	4650      	mov	r0, sl
 80125de:	f00c fea4 	bl	801f32a <crs_strlen>
 80125e2:	b283      	uxth	r3, r0
 80125e4:	4652      	mov	r2, sl
 80125e6:	2102      	movs	r1, #2
 80125e8:	4608      	mov	r0, r1
 80125ea:	f00c fee1 	bl	801f3b0 <traceIF_itmPrint>
 80125ee:	4650      	mov	r0, sl
 80125f0:	f00c fe9b 	bl	801f32a <crs_strlen>
 80125f4:	b283      	uxth	r3, r0
 80125f6:	4652      	mov	r2, sl
 80125f8:	2102      	movs	r1, #2
 80125fa:	4608      	mov	r0, r1
 80125fc:	f00c fefa 	bl	801f3f4 <traceIF_uartPrint>
 8012600:	e730      	b.n	8012464 <fRspAnalyze_CEREG+0xe8>
          PRINT_DBG("+CEREG: reject_cause=%ld",
 8012602:	8970      	ldrh	r0, [r6, #10]
 8012604:	89f1      	ldrh	r1, [r6, #14]
 8012606:	4440      	add	r0, r8
 8012608:	f002 fb94 	bl	8014d34 <ATutil_convertStringToInt>
 801260c:	4602      	mov	r2, r0
 801260e:	f8df a098 	ldr.w	sl, [pc, #152]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012612:	492d      	ldr	r1, [pc, #180]	; (80126c8 <fRspAnalyze_CEREG+0x34c>)
 8012614:	4650      	mov	r0, sl
 8012616:	f014 f917 	bl	8026848 <sprintf>
 801261a:	4650      	mov	r0, sl
 801261c:	f00c fe85 	bl	801f32a <crs_strlen>
 8012620:	b283      	uxth	r3, r0
 8012622:	4652      	mov	r2, sl
 8012624:	2102      	movs	r1, #2
 8012626:	4608      	mov	r0, r1
 8012628:	f00c fec2 	bl	801f3b0 <traceIF_itmPrint>
 801262c:	4650      	mov	r0, sl
 801262e:	f00c fe7c 	bl	801f32a <crs_strlen>
 8012632:	b283      	uxth	r3, r0
 8012634:	4652      	mov	r2, sl
 8012636:	2102      	movs	r1, #2
 8012638:	4608      	mov	r0, r1
 801263a:	f00c fedb 	bl	801f3f4 <traceIF_uartPrint>
 801263e:	e715      	b.n	801246c <fRspAnalyze_CEREG+0xf0>
      else if ((n_val == 4U) || (n_val == 5U))
 8012640:	1f2b      	subs	r3, r5, #4
 8012642:	2b01      	cmp	r3, #1
 8012644:	f63f af12 	bhi.w	801246c <fRspAnalyze_CEREG+0xf0>
        if (element_infos->param_rank == 7U)
 8012648:	8933      	ldrh	r3, [r6, #8]
 801264a:	2b07      	cmp	r3, #7
 801264c:	d040      	beq.n	80126d0 <fRspAnalyze_CEREG+0x354>
        if (element_infos->param_rank == 8U)
 801264e:	8933      	ldrh	r3, [r6, #8]
 8012650:	2b08      	cmp	r3, #8
 8012652:	d05c      	beq.n	801270e <fRspAnalyze_CEREG+0x392>
        if (element_infos->param_rank == 9U)
 8012654:	8933      	ldrh	r3, [r6, #8]
 8012656:	2b09      	cmp	r3, #9
 8012658:	d078      	beq.n	801274c <fRspAnalyze_CEREG+0x3d0>
        if (element_infos->param_rank == 10U)
 801265a:	8933      	ldrh	r3, [r6, #8]
 801265c:	2b0a      	cmp	r3, #10
 801265e:	f47f af05 	bne.w	801246c <fRspAnalyze_CEREG+0xf0>
          PRINT_INFO("+CEREG: periodic_tau= 0x%lx",
 8012662:	8970      	ldrh	r0, [r6, #10]
 8012664:	2208      	movs	r2, #8
 8012666:	89f1      	ldrh	r1, [r6, #14]
 8012668:	4440      	add	r0, r8
 801266a:	f7fc fad2 	bl	800ec12 <extract_bin_value_from_quotes>
 801266e:	4602      	mov	r2, r0
 8012670:	f8df a034 	ldr.w	sl, [pc, #52]	; 80126a8 <fRspAnalyze_CEREG+0x32c>
 8012674:	4915      	ldr	r1, [pc, #84]	; (80126cc <fRspAnalyze_CEREG+0x350>)
 8012676:	4650      	mov	r0, sl
 8012678:	f014 f8e6 	bl	8026848 <sprintf>
 801267c:	4650      	mov	r0, sl
 801267e:	f00c fe54 	bl	801f32a <crs_strlen>
 8012682:	b283      	uxth	r3, r0
 8012684:	4652      	mov	r2, sl
 8012686:	2101      	movs	r1, #1
 8012688:	2002      	movs	r0, #2
 801268a:	f00c fe91 	bl	801f3b0 <traceIF_itmPrint>
 801268e:	4650      	mov	r0, sl
 8012690:	f00c fe4b 	bl	801f32a <crs_strlen>
 8012694:	b283      	uxth	r3, r0
 8012696:	4652      	mov	r2, sl
 8012698:	2101      	movs	r1, #1
 801269a:	2002      	movs	r0, #2
 801269c:	f00c feaa 	bl	801f3f4 <traceIF_uartPrint>
 80126a0:	e6e4      	b.n	801246c <fRspAnalyze_CEREG+0xf0>
 80126a2:	bf00      	nop
 80126a4:	080307fc 	.word	0x080307fc
 80126a8:	200048dc 	.word	0x200048dc
 80126ac:	0803032c 	.word	0x0803032c
 80126b0:	08030828 	.word	0x08030828
 80126b4:	08030844 	.word	0x08030844
 80126b8:	08030860 	.word	0x08030860
 80126bc:	08030884 	.word	0x08030884
 80126c0:	080308a8 	.word	0x080308a8
 80126c4:	080308c4 	.word	0x080308c4
 80126c8:	080308e8 	.word	0x080308e8
 80126cc:	08030934 	.word	0x08030934
          PRINT_DBG("+CEREG: cause_type=%ld",
 80126d0:	8970      	ldrh	r0, [r6, #10]
 80126d2:	89f1      	ldrh	r1, [r6, #14]
 80126d4:	4440      	add	r0, r8
 80126d6:	f002 fb2d 	bl	8014d34 <ATutil_convertStringToInt>
 80126da:	4602      	mov	r2, r0
 80126dc:	f8df a300 	ldr.w	sl, [pc, #768]	; 80129e0 <fRspAnalyze_CEREG+0x664>
 80126e0:	49bb      	ldr	r1, [pc, #748]	; (80129d0 <fRspAnalyze_CEREG+0x654>)
 80126e2:	4650      	mov	r0, sl
 80126e4:	f014 f8b0 	bl	8026848 <sprintf>
 80126e8:	4650      	mov	r0, sl
 80126ea:	f00c fe1e 	bl	801f32a <crs_strlen>
 80126ee:	b283      	uxth	r3, r0
 80126f0:	4652      	mov	r2, sl
 80126f2:	2102      	movs	r1, #2
 80126f4:	4608      	mov	r0, r1
 80126f6:	f00c fe5b 	bl	801f3b0 <traceIF_itmPrint>
 80126fa:	4650      	mov	r0, sl
 80126fc:	f00c fe15 	bl	801f32a <crs_strlen>
 8012700:	b283      	uxth	r3, r0
 8012702:	4652      	mov	r2, sl
 8012704:	2102      	movs	r1, #2
 8012706:	4608      	mov	r0, r1
 8012708:	f00c fe74 	bl	801f3f4 <traceIF_uartPrint>
 801270c:	e79f      	b.n	801264e <fRspAnalyze_CEREG+0x2d2>
          PRINT_DBG("+CEREG: reject_cause=%ld",
 801270e:	8970      	ldrh	r0, [r6, #10]
 8012710:	89f1      	ldrh	r1, [r6, #14]
 8012712:	4440      	add	r0, r8
 8012714:	f002 fb0e 	bl	8014d34 <ATutil_convertStringToInt>
 8012718:	4602      	mov	r2, r0
 801271a:	f8df a2c4 	ldr.w	sl, [pc, #708]	; 80129e0 <fRspAnalyze_CEREG+0x664>
 801271e:	49ad      	ldr	r1, [pc, #692]	; (80129d4 <fRspAnalyze_CEREG+0x658>)
 8012720:	4650      	mov	r0, sl
 8012722:	f014 f891 	bl	8026848 <sprintf>
 8012726:	4650      	mov	r0, sl
 8012728:	f00c fdff 	bl	801f32a <crs_strlen>
 801272c:	b283      	uxth	r3, r0
 801272e:	4652      	mov	r2, sl
 8012730:	2102      	movs	r1, #2
 8012732:	4608      	mov	r0, r1
 8012734:	f00c fe3c 	bl	801f3b0 <traceIF_itmPrint>
 8012738:	4650      	mov	r0, sl
 801273a:	f00c fdf6 	bl	801f32a <crs_strlen>
 801273e:	b283      	uxth	r3, r0
 8012740:	4652      	mov	r2, sl
 8012742:	2102      	movs	r1, #2
 8012744:	4608      	mov	r0, r1
 8012746:	f00c fe55 	bl	801f3f4 <traceIF_uartPrint>
 801274a:	e783      	b.n	8012654 <fRspAnalyze_CEREG+0x2d8>
          PRINT_INFO("+CEREG: active_time= 0x%lx",
 801274c:	8970      	ldrh	r0, [r6, #10]
 801274e:	2208      	movs	r2, #8
 8012750:	89f1      	ldrh	r1, [r6, #14]
 8012752:	4440      	add	r0, r8
 8012754:	f7fc fa5d 	bl	800ec12 <extract_bin_value_from_quotes>
 8012758:	4602      	mov	r2, r0
 801275a:	f8df a284 	ldr.w	sl, [pc, #644]	; 80129e0 <fRspAnalyze_CEREG+0x664>
 801275e:	499e      	ldr	r1, [pc, #632]	; (80129d8 <fRspAnalyze_CEREG+0x65c>)
 8012760:	4650      	mov	r0, sl
 8012762:	f014 f871 	bl	8026848 <sprintf>
 8012766:	4650      	mov	r0, sl
 8012768:	f00c fddf 	bl	801f32a <crs_strlen>
 801276c:	b283      	uxth	r3, r0
 801276e:	4652      	mov	r2, sl
 8012770:	2101      	movs	r1, #1
 8012772:	2002      	movs	r0, #2
 8012774:	f00c fe1c 	bl	801f3b0 <traceIF_itmPrint>
 8012778:	4650      	mov	r0, sl
 801277a:	f00c fdd6 	bl	801f32a <crs_strlen>
 801277e:	b283      	uxth	r3, r0
 8012780:	4652      	mov	r2, sl
 8012782:	2101      	movs	r1, #1
 8012784:	2002      	movs	r0, #2
 8012786:	f00c fe35 	bl	801f3f4 <traceIF_uartPrint>
 801278a:	e766      	b.n	801265a <fRspAnalyze_CEREG+0x2de>
      PRINT_DBG("+CEREG for test cmd NOT IMPLEMENTED")
 801278c:	4d93      	ldr	r5, [pc, #588]	; (80129dc <fRspAnalyze_CEREG+0x660>)
 801278e:	4c94      	ldr	r4, [pc, #592]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 8012790:	f105 0720 	add.w	r7, r5, #32
 8012794:	462e      	mov	r6, r5
 8012796:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8012798:	6020      	str	r0, [r4, #0]
 801279a:	6061      	str	r1, [r4, #4]
 801279c:	60a2      	str	r2, [r4, #8]
 801279e:	60e3      	str	r3, [r4, #12]
 80127a0:	4635      	mov	r5, r6
 80127a2:	3410      	adds	r4, #16
 80127a4:	42be      	cmp	r6, r7
 80127a6:	d1f5      	bne.n	8012794 <fRspAnalyze_CEREG+0x418>
 80127a8:	cd07      	ldmia	r5!, {r0, r1, r2}
 80127aa:	6020      	str	r0, [r4, #0]
 80127ac:	6061      	str	r1, [r4, #4]
 80127ae:	60a2      	str	r2, [r4, #8]
 80127b0:	882a      	ldrh	r2, [r5, #0]
 80127b2:	78ab      	ldrb	r3, [r5, #2]
 80127b4:	81a2      	strh	r2, [r4, #12]
 80127b6:	73a3      	strb	r3, [r4, #14]
 80127b8:	4c89      	ldr	r4, [pc, #548]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80127ba:	4620      	mov	r0, r4
 80127bc:	f00c fdb5 	bl	801f32a <crs_strlen>
 80127c0:	b283      	uxth	r3, r0
 80127c2:	4622      	mov	r2, r4
 80127c4:	2102      	movs	r1, #2
 80127c6:	4608      	mov	r0, r1
 80127c8:	f00c fdf2 	bl	801f3b0 <traceIF_itmPrint>
 80127cc:	4620      	mov	r0, r4
 80127ce:	f00c fdac 	bl	801f32a <crs_strlen>
 80127d2:	b283      	uxth	r3, r0
 80127d4:	4622      	mov	r2, r4
 80127d6:	2102      	movs	r1, #2
 80127d8:	4608      	mov	r0, r1
 80127da:	f00c fe0b 	bl	801f3f4 <traceIF_uartPrint>
 80127de:	e61b      	b.n	8012418 <fRspAnalyze_CEREG+0x9c>
    START_PARAM_LOOP()
 80127e0:	2400      	movs	r4, #0
 80127e2:	4632      	mov	r2, r6
 80127e4:	4641      	mov	r1, r8
 80127e6:	4638      	mov	r0, r7
 80127e8:	f7f9 fe2e 	bl	800c448 <atcc_extractElement>
 80127ec:	2801      	cmp	r0, #1
 80127ee:	d000      	beq.n	80127f2 <fRspAnalyze_CEREG+0x476>
 80127f0:	2401      	movs	r4, #1
 80127f2:	89f1      	ldrh	r1, [r6, #14]
 80127f4:	b1e1      	cbz	r1, 8012830 <fRspAnalyze_CEREG+0x4b4>
    if (element_infos->param_rank == 2U)
 80127f6:	8933      	ldrh	r3, [r6, #8]
 80127f8:	2b02      	cmp	r3, #2
 80127fa:	d01d      	beq.n	8012838 <fRspAnalyze_CEREG+0x4bc>
    if (element_infos->param_rank == 3U)
 80127fc:	8933      	ldrh	r3, [r6, #8]
 80127fe:	2b03      	cmp	r3, #3
 8012800:	d040      	beq.n	8012884 <fRspAnalyze_CEREG+0x508>
    if (element_infos->param_rank == 4U)
 8012802:	8933      	ldrh	r3, [r6, #8]
 8012804:	2b04      	cmp	r3, #4
 8012806:	d063      	beq.n	80128d0 <fRspAnalyze_CEREG+0x554>
    if (element_infos->param_rank == 5U)
 8012808:	8933      	ldrh	r3, [r6, #8]
 801280a:	2b05      	cmp	r3, #5
 801280c:	f000 8086 	beq.w	801291c <fRspAnalyze_CEREG+0x5a0>
    if (element_infos->param_rank == 6U)
 8012810:	8933      	ldrh	r3, [r6, #8]
 8012812:	2b06      	cmp	r3, #6
 8012814:	f000 80a0 	beq.w	8012958 <fRspAnalyze_CEREG+0x5dc>
    if (element_infos->param_rank == 7U)
 8012818:	8933      	ldrh	r3, [r6, #8]
 801281a:	2b07      	cmp	r3, #7
 801281c:	f000 80ba 	beq.w	8012994 <fRspAnalyze_CEREG+0x618>
    if (element_infos->param_rank == 8U)
 8012820:	8933      	ldrh	r3, [r6, #8]
 8012822:	2b08      	cmp	r3, #8
 8012824:	f000 80ea 	beq.w	80129fc <fRspAnalyze_CEREG+0x680>
    if (element_infos->param_rank == 9U)
 8012828:	8933      	ldrh	r3, [r6, #8]
 801282a:	2b09      	cmp	r3, #9
 801282c:	f000 8105 	beq.w	8012a3a <fRspAnalyze_CEREG+0x6be>
    END_PARAM_LOOP()
 8012830:	2c00      	cmp	r4, #0
 8012832:	f47f adf1 	bne.w	8012418 <fRspAnalyze_CEREG+0x9c>
 8012836:	e7d4      	b.n	80127e2 <fRspAnalyze_CEREG+0x466>
      uint32_t stat = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8012838:	8970      	ldrh	r0, [r6, #10]
 801283a:	4440      	add	r0, r8
 801283c:	f002 fa7a 	bl	8014d34 <ATutil_convertStringToInt>
 8012840:	4682      	mov	sl, r0
      p_modem_ctxt->persist.urc_avail_eps_network_registration = AT_TRUE;
 8012842:	2301      	movs	r3, #1
 8012844:	f889 3014 	strb.w	r3, [r9, #20]
      p_modem_ctxt->persist.eps_network_state = convert_NetworkState(stat, EPS_NETWORK_TYPE);
 8012848:	2103      	movs	r1, #3
 801284a:	f7fc f835 	bl	800e8b8 <convert_NetworkState>
 801284e:	f8a9 0030 	strh.w	r0, [r9, #48]	; 0x30
      PRINT_DBG("+CEREG URC: stat=%ld", stat)
 8012852:	4d63      	ldr	r5, [pc, #396]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 8012854:	4652      	mov	r2, sl
 8012856:	4963      	ldr	r1, [pc, #396]	; (80129e4 <fRspAnalyze_CEREG+0x668>)
 8012858:	4628      	mov	r0, r5
 801285a:	f013 fff5 	bl	8026848 <sprintf>
 801285e:	4628      	mov	r0, r5
 8012860:	f00c fd63 	bl	801f32a <crs_strlen>
 8012864:	b283      	uxth	r3, r0
 8012866:	462a      	mov	r2, r5
 8012868:	2102      	movs	r1, #2
 801286a:	4608      	mov	r0, r1
 801286c:	f00c fda0 	bl	801f3b0 <traceIF_itmPrint>
 8012870:	4628      	mov	r0, r5
 8012872:	f00c fd5a 	bl	801f32a <crs_strlen>
 8012876:	b283      	uxth	r3, r0
 8012878:	462a      	mov	r2, r5
 801287a:	2102      	movs	r1, #2
 801287c:	4608      	mov	r0, r1
 801287e:	f00c fdb9 	bl	801f3f4 <traceIF_uartPrint>
 8012882:	e7bb      	b.n	80127fc <fRspAnalyze_CEREG+0x480>
      uint32_t tac = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 8012884:	8970      	ldrh	r0, [r6, #10]
 8012886:	2204      	movs	r2, #4
 8012888:	89f1      	ldrh	r1, [r6, #14]
 801288a:	4440      	add	r0, r8
 801288c:	f7fc f9b2 	bl	800ebf4 <extract_hex_value_from_quotes>
 8012890:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_eps_location_info_tac = AT_TRUE;
 8012892:	f04f 0a01 	mov.w	sl, #1
 8012896:	f889 a015 	strb.w	sl, [r9, #21]
      p_modem_ctxt->persist.eps_location_info.lac = (uint16_t)tac;
 801289a:	f8a9 002c 	strh.w	r0, [r9, #44]	; 0x2c
      PRINT_INFO("+CEREG URC: tac=%ld =0x%lx", tac, tac)
 801289e:	4d50      	ldr	r5, [pc, #320]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80128a0:	4603      	mov	r3, r0
 80128a2:	4951      	ldr	r1, [pc, #324]	; (80129e8 <fRspAnalyze_CEREG+0x66c>)
 80128a4:	4628      	mov	r0, r5
 80128a6:	f013 ffcf 	bl	8026848 <sprintf>
 80128aa:	4628      	mov	r0, r5
 80128ac:	f00c fd3d 	bl	801f32a <crs_strlen>
 80128b0:	b283      	uxth	r3, r0
 80128b2:	462a      	mov	r2, r5
 80128b4:	4651      	mov	r1, sl
 80128b6:	2002      	movs	r0, #2
 80128b8:	f00c fd7a 	bl	801f3b0 <traceIF_itmPrint>
 80128bc:	4628      	mov	r0, r5
 80128be:	f00c fd34 	bl	801f32a <crs_strlen>
 80128c2:	b283      	uxth	r3, r0
 80128c4:	462a      	mov	r2, r5
 80128c6:	4651      	mov	r1, sl
 80128c8:	2002      	movs	r0, #2
 80128ca:	f00c fd93 	bl	801f3f4 <traceIF_uartPrint>
 80128ce:	e798      	b.n	8012802 <fRspAnalyze_CEREG+0x486>
      uint32_t ci = extract_hex_value_from_quotes(&p_msg_in->buffer[element_infos->str_start_idx],
 80128d0:	8970      	ldrh	r0, [r6, #10]
 80128d2:	2208      	movs	r2, #8
 80128d4:	89f1      	ldrh	r1, [r6, #14]
 80128d6:	4440      	add	r0, r8
 80128d8:	f7fc f98c 	bl	800ebf4 <extract_hex_value_from_quotes>
 80128dc:	4602      	mov	r2, r0
      p_modem_ctxt->persist.urc_avail_eps_location_info_ci = AT_TRUE;
 80128de:	f04f 0a01 	mov.w	sl, #1
 80128e2:	f889 a016 	strb.w	sl, [r9, #22]
      p_modem_ctxt->persist.eps_location_info.ci = (uint32_t)ci;
 80128e6:	f8c9 0028 	str.w	r0, [r9, #40]	; 0x28
      PRINT_INFO("+CEREG URC: ci=%ld =0x%lx", ci, ci)
 80128ea:	4d3d      	ldr	r5, [pc, #244]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80128ec:	4603      	mov	r3, r0
 80128ee:	493f      	ldr	r1, [pc, #252]	; (80129ec <fRspAnalyze_CEREG+0x670>)
 80128f0:	4628      	mov	r0, r5
 80128f2:	f013 ffa9 	bl	8026848 <sprintf>
 80128f6:	4628      	mov	r0, r5
 80128f8:	f00c fd17 	bl	801f32a <crs_strlen>
 80128fc:	b283      	uxth	r3, r0
 80128fe:	462a      	mov	r2, r5
 8012900:	4651      	mov	r1, sl
 8012902:	2002      	movs	r0, #2
 8012904:	f00c fd54 	bl	801f3b0 <traceIF_itmPrint>
 8012908:	4628      	mov	r0, r5
 801290a:	f00c fd0e 	bl	801f32a <crs_strlen>
 801290e:	b283      	uxth	r3, r0
 8012910:	462a      	mov	r2, r5
 8012912:	4651      	mov	r1, sl
 8012914:	2002      	movs	r0, #2
 8012916:	f00c fd6d 	bl	801f3f4 <traceIF_uartPrint>
 801291a:	e775      	b.n	8012808 <fRspAnalyze_CEREG+0x48c>
      PRINT_DBG("+CEREG URC: act=%ld",
 801291c:	8970      	ldrh	r0, [r6, #10]
 801291e:	89f1      	ldrh	r1, [r6, #14]
 8012920:	4440      	add	r0, r8
 8012922:	f002 fa07 	bl	8014d34 <ATutil_convertStringToInt>
 8012926:	4602      	mov	r2, r0
 8012928:	4d2d      	ldr	r5, [pc, #180]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 801292a:	4931      	ldr	r1, [pc, #196]	; (80129f0 <fRspAnalyze_CEREG+0x674>)
 801292c:	4628      	mov	r0, r5
 801292e:	f013 ff8b 	bl	8026848 <sprintf>
 8012932:	4628      	mov	r0, r5
 8012934:	f00c fcf9 	bl	801f32a <crs_strlen>
 8012938:	b283      	uxth	r3, r0
 801293a:	462a      	mov	r2, r5
 801293c:	2102      	movs	r1, #2
 801293e:	4608      	mov	r0, r1
 8012940:	f00c fd36 	bl	801f3b0 <traceIF_itmPrint>
 8012944:	4628      	mov	r0, r5
 8012946:	f00c fcf0 	bl	801f32a <crs_strlen>
 801294a:	b283      	uxth	r3, r0
 801294c:	462a      	mov	r2, r5
 801294e:	2102      	movs	r1, #2
 8012950:	4608      	mov	r0, r1
 8012952:	f00c fd4f 	bl	801f3f4 <traceIF_uartPrint>
 8012956:	e75b      	b.n	8012810 <fRspAnalyze_CEREG+0x494>
      PRINT_DBG("+CEREG URC: cause_type=%ld",
 8012958:	8970      	ldrh	r0, [r6, #10]
 801295a:	89f1      	ldrh	r1, [r6, #14]
 801295c:	4440      	add	r0, r8
 801295e:	f002 f9e9 	bl	8014d34 <ATutil_convertStringToInt>
 8012962:	4602      	mov	r2, r0
 8012964:	4d1e      	ldr	r5, [pc, #120]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 8012966:	4923      	ldr	r1, [pc, #140]	; (80129f4 <fRspAnalyze_CEREG+0x678>)
 8012968:	4628      	mov	r0, r5
 801296a:	f013 ff6d 	bl	8026848 <sprintf>
 801296e:	4628      	mov	r0, r5
 8012970:	f00c fcdb 	bl	801f32a <crs_strlen>
 8012974:	b283      	uxth	r3, r0
 8012976:	462a      	mov	r2, r5
 8012978:	2102      	movs	r1, #2
 801297a:	4608      	mov	r0, r1
 801297c:	f00c fd18 	bl	801f3b0 <traceIF_itmPrint>
 8012980:	4628      	mov	r0, r5
 8012982:	f00c fcd2 	bl	801f32a <crs_strlen>
 8012986:	b283      	uxth	r3, r0
 8012988:	462a      	mov	r2, r5
 801298a:	2102      	movs	r1, #2
 801298c:	4608      	mov	r0, r1
 801298e:	f00c fd31 	bl	801f3f4 <traceIF_uartPrint>
 8012992:	e741      	b.n	8012818 <fRspAnalyze_CEREG+0x49c>
      PRINT_DBG("+CEREG URC: reject_cause=%ld",
 8012994:	8970      	ldrh	r0, [r6, #10]
 8012996:	89f1      	ldrh	r1, [r6, #14]
 8012998:	4440      	add	r0, r8
 801299a:	f002 f9cb 	bl	8014d34 <ATutil_convertStringToInt>
 801299e:	4602      	mov	r2, r0
 80129a0:	4d0f      	ldr	r5, [pc, #60]	; (80129e0 <fRspAnalyze_CEREG+0x664>)
 80129a2:	4915      	ldr	r1, [pc, #84]	; (80129f8 <fRspAnalyze_CEREG+0x67c>)
 80129a4:	4628      	mov	r0, r5
 80129a6:	f013 ff4f 	bl	8026848 <sprintf>
 80129aa:	4628      	mov	r0, r5
 80129ac:	f00c fcbd 	bl	801f32a <crs_strlen>
 80129b0:	b283      	uxth	r3, r0
 80129b2:	462a      	mov	r2, r5
 80129b4:	2102      	movs	r1, #2
 80129b6:	4608      	mov	r0, r1
 80129b8:	f00c fcfa 	bl	801f3b0 <traceIF_itmPrint>
 80129bc:	4628      	mov	r0, r5
 80129be:	f00c fcb4 	bl	801f32a <crs_strlen>
 80129c2:	b283      	uxth	r3, r0
 80129c4:	462a      	mov	r2, r5
 80129c6:	2102      	movs	r1, #2
 80129c8:	4608      	mov	r0, r1
 80129ca:	f00c fd13 	bl	801f3f4 <traceIF_uartPrint>
 80129ce:	e727      	b.n	8012820 <fRspAnalyze_CEREG+0x4a4>
 80129d0:	080308c4 	.word	0x080308c4
 80129d4:	080308e8 	.word	0x080308e8
 80129d8:	0803090c 	.word	0x0803090c
 80129dc:	0803095c 	.word	0x0803095c
 80129e0:	200048dc 	.word	0x200048dc
 80129e4:	0803098c 	.word	0x0803098c
 80129e8:	080309ac 	.word	0x080309ac
 80129ec:	080309d4 	.word	0x080309d4
 80129f0:	080309fc 	.word	0x080309fc
 80129f4:	08030a1c 	.word	0x08030a1c
 80129f8:	08030a44 	.word	0x08030a44
      PRINT_INFO("+CEREG URC: active_time= 0x%lx",
 80129fc:	8970      	ldrh	r0, [r6, #10]
 80129fe:	2208      	movs	r2, #8
 8012a00:	89f1      	ldrh	r1, [r6, #14]
 8012a02:	4440      	add	r0, r8
 8012a04:	f7fc f905 	bl	800ec12 <extract_bin_value_from_quotes>
 8012a08:	4602      	mov	r2, r0
 8012a0a:	4d1b      	ldr	r5, [pc, #108]	; (8012a78 <fRspAnalyze_CEREG+0x6fc>)
 8012a0c:	491b      	ldr	r1, [pc, #108]	; (8012a7c <fRspAnalyze_CEREG+0x700>)
 8012a0e:	4628      	mov	r0, r5
 8012a10:	f013 ff1a 	bl	8026848 <sprintf>
 8012a14:	4628      	mov	r0, r5
 8012a16:	f00c fc88 	bl	801f32a <crs_strlen>
 8012a1a:	b283      	uxth	r3, r0
 8012a1c:	462a      	mov	r2, r5
 8012a1e:	2101      	movs	r1, #1
 8012a20:	2002      	movs	r0, #2
 8012a22:	f00c fcc5 	bl	801f3b0 <traceIF_itmPrint>
 8012a26:	4628      	mov	r0, r5
 8012a28:	f00c fc7f 	bl	801f32a <crs_strlen>
 8012a2c:	b283      	uxth	r3, r0
 8012a2e:	462a      	mov	r2, r5
 8012a30:	2101      	movs	r1, #1
 8012a32:	2002      	movs	r0, #2
 8012a34:	f00c fcde 	bl	801f3f4 <traceIF_uartPrint>
 8012a38:	e6f6      	b.n	8012828 <fRspAnalyze_CEREG+0x4ac>
      PRINT_INFO("+CEREG URC: periodic_tau= 0x%lx",
 8012a3a:	8970      	ldrh	r0, [r6, #10]
 8012a3c:	2208      	movs	r2, #8
 8012a3e:	89f1      	ldrh	r1, [r6, #14]
 8012a40:	4440      	add	r0, r8
 8012a42:	f7fc f8e6 	bl	800ec12 <extract_bin_value_from_quotes>
 8012a46:	4602      	mov	r2, r0
 8012a48:	4d0b      	ldr	r5, [pc, #44]	; (8012a78 <fRspAnalyze_CEREG+0x6fc>)
 8012a4a:	490d      	ldr	r1, [pc, #52]	; (8012a80 <fRspAnalyze_CEREG+0x704>)
 8012a4c:	4628      	mov	r0, r5
 8012a4e:	f013 fefb 	bl	8026848 <sprintf>
 8012a52:	4628      	mov	r0, r5
 8012a54:	f00c fc69 	bl	801f32a <crs_strlen>
 8012a58:	b283      	uxth	r3, r0
 8012a5a:	462a      	mov	r2, r5
 8012a5c:	2101      	movs	r1, #1
 8012a5e:	2002      	movs	r0, #2
 8012a60:	f00c fca6 	bl	801f3b0 <traceIF_itmPrint>
 8012a64:	4628      	mov	r0, r5
 8012a66:	f00c fc60 	bl	801f32a <crs_strlen>
 8012a6a:	b283      	uxth	r3, r0
 8012a6c:	462a      	mov	r2, r5
 8012a6e:	2101      	movs	r1, #1
 8012a70:	2002      	movs	r0, #2
 8012a72:	f00c fcbf 	bl	801f3f4 <traceIF_uartPrint>
 8012a76:	e6db      	b.n	8012830 <fRspAnalyze_CEREG+0x4b4>
 8012a78:	200048dc 	.word	0x200048dc
 8012a7c:	08030a6c 	.word	0x08030a6c
 8012a80:	08030a98 	.word	0x08030a98

08012a84 <fRspAnalyze_CGEV>:

at_action_rsp_t fRspAnalyze_CGEV(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8012a84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8012a88:	b095      	sub	sp, #84	; 0x54
 8012a8a:	4680      	mov	r8, r0
 8012a8c:	460e      	mov	r6, r1
 8012a8e:	4617      	mov	r7, r2
 8012a90:	461d      	mov	r5, r3
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGEV()")
 8012a92:	4cc9      	ldr	r4, [pc, #804]	; (8012db8 <fRspAnalyze_CGEV+0x334>)
 8012a94:	f8df c324 	ldr.w	ip, [pc, #804]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012a98:	f104 0920 	add.w	r9, r4, #32
 8012a9c:	46a6      	mov	lr, r4
 8012a9e:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8012aa2:	f8cc 0000 	str.w	r0, [ip]
 8012aa6:	f8cc 1004 	str.w	r1, [ip, #4]
 8012aaa:	f8cc 2008 	str.w	r2, [ip, #8]
 8012aae:	f8cc 300c 	str.w	r3, [ip, #12]
 8012ab2:	4674      	mov	r4, lr
 8012ab4:	f10c 0c10 	add.w	ip, ip, #16
 8012ab8:	45ce      	cmp	lr, r9
 8012aba:	d1ef      	bne.n	8012a9c <fRspAnalyze_CGEV+0x18>
 8012abc:	cc03      	ldmia	r4!, {r0, r1}
 8012abe:	f8cc 0000 	str.w	r0, [ip]
 8012ac2:	f8cc 1004 	str.w	r1, [ip, #4]
 8012ac6:	4cbd      	ldr	r4, [pc, #756]	; (8012dbc <fRspAnalyze_CGEV+0x338>)
 8012ac8:	4620      	mov	r0, r4
 8012aca:	f00c fc2e 	bl	801f32a <crs_strlen>
 8012ace:	b283      	uxth	r3, r0
 8012ad0:	4622      	mov	r2, r4
 8012ad2:	2104      	movs	r1, #4
 8012ad4:	2002      	movs	r0, #2
 8012ad6:	f00c fc6b 	bl	801f3b0 <traceIF_itmPrint>
 8012ada:	4620      	mov	r0, r4
 8012adc:	f00c fc25 	bl	801f32a <crs_strlen>
 8012ae0:	b283      	uxth	r3, r0
 8012ae2:	4622      	mov	r2, r4
 8012ae4:	2104      	movs	r1, #4
 8012ae6:	2002      	movs	r0, #2
 8012ae8:	f00c fc84 	bl	801f3f4 <traceIF_uartPrint>

  /* cf 3GPP TS 27.007 */
  /* this is an URC */
  START_PARAM_LOOP()
 8012aec:	f04f 0900 	mov.w	r9, #0
 8012af0:	462a      	mov	r2, r5
 8012af2:	4639      	mov	r1, r7
 8012af4:	4640      	mov	r0, r8
 8012af6:	f7f9 fca7 	bl	800c448 <atcc_extractElement>
 8012afa:	2801      	cmp	r0, #1
 8012afc:	d001      	beq.n	8012b02 <fRspAnalyze_CGEV+0x7e>
 8012afe:	f04f 0901 	mov.w	r9, #1
 8012b02:	89eb      	ldrh	r3, [r5, #14]
 8012b04:	2b00      	cmp	r3, #0
 8012b06:	f000 8370 	beq.w	80131ea <fRspAnalyze_CGEV+0x766>
  if (element_infos->param_rank == 2U)
 8012b0a:	892a      	ldrh	r2, [r5, #8]
 8012b0c:	2a02      	cmp	r2, #2
 8012b0e:	d024      	beq.n	8012b5a <fRspAnalyze_CGEV+0xd6>
      PRINT_ERR("an +CGEV URC still not reported, ignore this one")
      retval = ATACTION_RSP_ERROR;
    }

  }
  else if (element_infos->param_rank == 3U)
 8012b10:	2a03      	cmp	r2, #3
 8012b12:	f000 8308 	beq.w	8013126 <fRspAnalyze_CGEV+0x6a2>
    else
    {
      PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
    }
  }
  else if (element_infos->param_rank == 4U)
 8012b16:	2a04      	cmp	r2, #4
 8012b18:	f040 8350 	bne.w	80131bc <fRspAnalyze_CGEV+0x738>
  {
    if ((p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8012b1c:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8012b1e:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8012b22:	49a7      	ldr	r1, [pc, #668]	; (8012dc0 <fRspAnalyze_CGEV+0x33c>)
 8012b24:	428b      	cmp	r3, r1
 8012b26:	f000 8360 	beq.w	80131ea <fRspAnalyze_CGEV+0x766>
      */
      /* CID not used: we could use it if problem with <PDP_addr> occured */
    }
    else
    {
      PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
 8012b2a:	4ca4      	ldr	r4, [pc, #656]	; (8012dbc <fRspAnalyze_CGEV+0x338>)
 8012b2c:	49a5      	ldr	r1, [pc, #660]	; (8012dc4 <fRspAnalyze_CGEV+0x340>)
 8012b2e:	4620      	mov	r0, r4
 8012b30:	f013 fe8a 	bl	8026848 <sprintf>
 8012b34:	4620      	mov	r0, r4
 8012b36:	f00c fbf8 	bl	801f32a <crs_strlen>
 8012b3a:	b283      	uxth	r3, r0
 8012b3c:	4622      	mov	r2, r4
 8012b3e:	2102      	movs	r1, #2
 8012b40:	4608      	mov	r0, r1
 8012b42:	f00c fc35 	bl	801f3b0 <traceIF_itmPrint>
 8012b46:	4620      	mov	r0, r4
 8012b48:	f00c fbef 	bl	801f32a <crs_strlen>
 8012b4c:	b283      	uxth	r3, r0
 8012b4e:	4622      	mov	r2, r4
 8012b50:	2102      	movs	r1, #2
 8012b52:	4608      	mov	r0, r1
 8012b54:	f00c fc4e 	bl	801f3f4 <traceIF_uartPrint>
 8012b58:	e347      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
    if (p_modem_ctxt->persist.urc_avail_pdn_event != AT_TRUE)
 8012b5a:	f896 3020 	ldrb.w	r3, [r6, #32]
 8012b5e:	2b00      	cmp	r3, #0
 8012b60:	f040 82c7 	bne.w	80130f2 <fRspAnalyze_CGEV+0x66e>
      reset_pdn_event(&p_modem_ctxt->persist);
 8012b64:	f106 0a0c 	add.w	sl, r6, #12
 8012b68:	4650      	mov	r0, sl
 8012b6a:	f7fa ffdf 	bl	800db2c <reset_pdn_event>
      uint8_t copy_params[MAX_CGEV_PARAM_SIZE] = {0};
 8012b6e:	2300      	movs	r3, #0
 8012b70:	9303      	str	r3, [sp, #12]
 8012b72:	9304      	str	r3, [sp, #16]
 8012b74:	9305      	str	r3, [sp, #20]
 8012b76:	9306      	str	r3, [sp, #24]
 8012b78:	9307      	str	r3, [sp, #28]
 8012b7a:	9308      	str	r3, [sp, #32]
 8012b7c:	9309      	str	r3, [sp, #36]	; 0x24
 8012b7e:	930a      	str	r3, [sp, #40]	; 0x28
      size_t size_mini = ATC_GET_MINIMUM_SIZE(element_infos->str_size, MAX_CGEV_PARAM_SIZE);
 8012b80:	89ea      	ldrh	r2, [r5, #14]
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8012b82:	8969      	ldrh	r1, [r5, #10]
      (void) memcpy((void *)copy_params,
 8012b84:	2a20      	cmp	r2, #32
 8012b86:	bf28      	it	cs
 8012b88:	2220      	movcs	r2, #32
 8012b8a:	4439      	add	r1, r7
 8012b8c:	a803      	add	r0, sp, #12
 8012b8e:	f013 ffab 	bl	8026ae8 <memcpy>
      found = (AT_CHAR_t *)strtok((CRC_CHAR_t *)copy_params, " ");
 8012b92:	498d      	ldr	r1, [pc, #564]	; (8012dc8 <fRspAnalyze_CGEV+0x344>)
 8012b94:	a803      	add	r0, sp, #12
 8012b96:	f013 fee5 	bl	8026964 <strtok>
 8012b9a:	4604      	mov	r4, r0
      while (found  != NULL)
 8012b9c:	e044      	b.n	8012c28 <fRspAnalyze_CGEV+0x1a4>
          PRINT_DBG("<NW>")
 8012b9e:	f8df b21c 	ldr.w	fp, [pc, #540]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012ba2:	f8df c254 	ldr.w	ip, [pc, #596]	; 8012df8 <fRspAnalyze_CGEV+0x374>
 8012ba6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012baa:	f8cb 0000 	str.w	r0, [fp]
 8012bae:	f8cb 1004 	str.w	r1, [fp, #4]
 8012bb2:	f8cb 2008 	str.w	r2, [fp, #8]
 8012bb6:	f8cb 300c 	str.w	r3, [fp, #12]
 8012bba:	4658      	mov	r0, fp
 8012bbc:	f00c fbb5 	bl	801f32a <crs_strlen>
 8012bc0:	b283      	uxth	r3, r0
 8012bc2:	465a      	mov	r2, fp
 8012bc4:	2102      	movs	r1, #2
 8012bc6:	4608      	mov	r0, r1
 8012bc8:	f00c fbf2 	bl	801f3b0 <traceIF_itmPrint>
 8012bcc:	4658      	mov	r0, fp
 8012bce:	f00c fbac 	bl	801f32a <crs_strlen>
 8012bd2:	b283      	uxth	r3, r0
 8012bd4:	465a      	mov	r2, fp
 8012bd6:	2102      	movs	r1, #2
 8012bd8:	4608      	mov	r0, r1
 8012bda:	f00c fc0b 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_origine = CGEV_EVENT_ORIGINE_NW;
 8012bde:	2301      	movs	r3, #1
 8012be0:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
        PRINT_DBG("(%d) ---> %s", strlen((CRC_CHAR_t *)found), (uint8_t *) found)
 8012be4:	4620      	mov	r0, r4
 8012be6:	f7ed fb05 	bl	80001f4 <strlen>
 8012bea:	4602      	mov	r2, r0
 8012bec:	f8df b1cc 	ldr.w	fp, [pc, #460]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012bf0:	4623      	mov	r3, r4
 8012bf2:	4976      	ldr	r1, [pc, #472]	; (8012dcc <fRspAnalyze_CGEV+0x348>)
 8012bf4:	4658      	mov	r0, fp
 8012bf6:	f013 fe27 	bl	8026848 <sprintf>
 8012bfa:	4658      	mov	r0, fp
 8012bfc:	f00c fb95 	bl	801f32a <crs_strlen>
 8012c00:	b283      	uxth	r3, r0
 8012c02:	465a      	mov	r2, fp
 8012c04:	2102      	movs	r1, #2
 8012c06:	4608      	mov	r0, r1
 8012c08:	f00c fbd2 	bl	801f3b0 <traceIF_itmPrint>
 8012c0c:	4658      	mov	r0, fp
 8012c0e:	f00c fb8c 	bl	801f32a <crs_strlen>
 8012c12:	b283      	uxth	r3, r0
 8012c14:	465a      	mov	r2, fp
 8012c16:	2102      	movs	r1, #2
 8012c18:	4608      	mov	r0, r1
 8012c1a:	f00c fbeb 	bl	801f3f4 <traceIF_uartPrint>
        found = (AT_CHAR_t *)strtok(NULL, " ");
 8012c1e:	496a      	ldr	r1, [pc, #424]	; (8012dc8 <fRspAnalyze_CGEV+0x344>)
 8012c20:	2000      	movs	r0, #0
 8012c22:	f013 fe9f 	bl	8026964 <strtok>
 8012c26:	4604      	mov	r4, r0
      while (found  != NULL)
 8012c28:	2c00      	cmp	r4, #0
 8012c2a:	f000 825e 	beq.w	80130ea <fRspAnalyze_CGEV+0x666>
        if (0 == strcmp((CRC_CHAR_t *)found, "NW"))
 8012c2e:	4968      	ldr	r1, [pc, #416]	; (8012dd0 <fRspAnalyze_CGEV+0x34c>)
 8012c30:	4620      	mov	r0, r4
 8012c32:	f7ed fad5 	bl	80001e0 <strcmp>
 8012c36:	2800      	cmp	r0, #0
 8012c38:	d0b1      	beq.n	8012b9e <fRspAnalyze_CGEV+0x11a>
        else if (0 == strcmp((CRC_CHAR_t *)found, "ME"))
 8012c3a:	4966      	ldr	r1, [pc, #408]	; (8012dd4 <fRspAnalyze_CGEV+0x350>)
 8012c3c:	4620      	mov	r0, r4
 8012c3e:	f7ed facf 	bl	80001e0 <strcmp>
 8012c42:	2800      	cmp	r0, #0
 8012c44:	d06b      	beq.n	8012d1e <fRspAnalyze_CGEV+0x29a>
        else if (0 == strcmp((CRC_CHAR_t *)found, "PDN"))
 8012c46:	4964      	ldr	r1, [pc, #400]	; (8012dd8 <fRspAnalyze_CGEV+0x354>)
 8012c48:	4620      	mov	r0, r4
 8012c4a:	f7ed fac9 	bl	80001e0 <strcmp>
 8012c4e:	2800      	cmp	r0, #0
 8012c50:	f000 8089 	beq.w	8012d66 <fRspAnalyze_CGEV+0x2e2>
        else if (0 == strcmp((CRC_CHAR_t *)found, "ACT"))
 8012c54:	4961      	ldr	r1, [pc, #388]	; (8012ddc <fRspAnalyze_CGEV+0x358>)
 8012c56:	4620      	mov	r0, r4
 8012c58:	f7ed fac2 	bl	80001e0 <strcmp>
 8012c5c:	2800      	cmp	r0, #0
 8012c5e:	f000 80d1 	beq.w	8012e04 <fRspAnalyze_CGEV+0x380>
        else if (0 == strcmp((CRC_CHAR_t *)found, "DEACT"))
 8012c62:	495f      	ldr	r1, [pc, #380]	; (8012de0 <fRspAnalyze_CGEV+0x35c>)
 8012c64:	4620      	mov	r0, r4
 8012c66:	f7ed fabb 	bl	80001e0 <strcmp>
 8012c6a:	2800      	cmp	r0, #0
 8012c6c:	f000 80f2 	beq.w	8012e54 <fRspAnalyze_CGEV+0x3d0>
        else if (0 == strcmp((CRC_CHAR_t *)found, "REJECT"))
 8012c70:	495c      	ldr	r1, [pc, #368]	; (8012de4 <fRspAnalyze_CGEV+0x360>)
 8012c72:	4620      	mov	r0, r4
 8012c74:	f7ed fab4 	bl	80001e0 <strcmp>
 8012c78:	2800      	cmp	r0, #0
 8012c7a:	f000 8117 	beq.w	8012eac <fRspAnalyze_CGEV+0x428>
        else if (0 == strcmp((CRC_CHAR_t *)found, "DETACH"))
 8012c7e:	495a      	ldr	r1, [pc, #360]	; (8012de8 <fRspAnalyze_CGEV+0x364>)
 8012c80:	4620      	mov	r0, r4
 8012c82:	f7ed faad 	bl	80001e0 <strcmp>
 8012c86:	2800      	cmp	r0, #0
 8012c88:	f000 8138 	beq.w	8012efc <fRspAnalyze_CGEV+0x478>
        else if (0 == strcmp((CRC_CHAR_t *)found, "CLASS"))
 8012c8c:	4957      	ldr	r1, [pc, #348]	; (8012dec <fRspAnalyze_CGEV+0x368>)
 8012c8e:	4620      	mov	r0, r4
 8012c90:	f7ed faa6 	bl	80001e0 <strcmp>
 8012c94:	2800      	cmp	r0, #0
 8012c96:	f000 815c 	beq.w	8012f52 <fRspAnalyze_CGEV+0x4ce>
        else if (0 == strcmp((CRC_CHAR_t *)found, "MODIFY"))
 8012c9a:	4955      	ldr	r1, [pc, #340]	; (8012df0 <fRspAnalyze_CGEV+0x36c>)
 8012c9c:	4620      	mov	r0, r4
 8012c9e:	f7ed fa9f 	bl	80001e0 <strcmp>
 8012ca2:	2800      	cmp	r0, #0
 8012ca4:	f000 8181 	beq.w	8012faa <fRspAnalyze_CGEV+0x526>
          if (p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW)
 8012ca8:	f896 304c 	ldrb.w	r3, [r6, #76]	; 0x4c
 8012cac:	2b01      	cmp	r3, #1
 8012cae:	f040 81ef 	bne.w	8013090 <fRspAnalyze_CGEV+0x60c>
            if (p_modem_ctxt->persist.pdn_event.event_type == CGEV_EVENT_TYPE_DETACH)
 8012cb2:	f896 204e 	ldrb.w	r2, [r6, #78]	; 0x4e
 8012cb6:	2a0f      	cmp	r2, #15
 8012cb8:	f000 819f 	beq.w	8012ffa <fRspAnalyze_CGEV+0x576>
            else if (p_modem_ctxt->persist.pdn_event.event_type == CGEV_EVENT_TYPE_DEACTIVATION)
 8012cbc:	2a0d      	cmp	r2, #13
 8012cbe:	f040 81ce 	bne.w	801305e <fRspAnalyze_CGEV+0x5da>
              if (p_modem_ctxt->persist.pdn_event.event_scope == CGEV_EVENT_SCOPE_PDN)
 8012cc2:	f896 304d 	ldrb.w	r3, [r6, #77]	; 0x4d
 8012cc6:	2b0a      	cmp	r3, #10
 8012cc8:	d18c      	bne.n	8012be4 <fRspAnalyze_CGEV+0x160>
                                                              (uint16_t)strlen((CRC_CHAR_t *)found));
 8012cca:	4620      	mov	r0, r4
 8012ccc:	f7ed fa92 	bl	80001f4 <strlen>
                uint32_t cgev_cid = ATutil_convertStringToInt((uint8_t *)found,
 8012cd0:	b281      	uxth	r1, r0
 8012cd2:	4620      	mov	r0, r4
 8012cd4:	f002 f82e 	bl	8014d34 <ATutil_convertStringToInt>
                p_modem_ctxt->persist.pdn_event.conf_id = atcm_get_configID_for_modem_cid(&p_modem_ctxt->persist,
 8012cd8:	9001      	str	r0, [sp, #4]
 8012cda:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8012cde:	4650      	mov	r0, sl
 8012ce0:	f7fa feae 	bl	800da40 <atcm_get_configID_for_modem_cid>
 8012ce4:	4603      	mov	r3, r0
 8012ce6:	f886 004f 	strb.w	r0, [r6, #79]	; 0x4f
                PRINT_DBG("+CGEV modem cid=%ld (user conf Id =%d)", cgev_cid, p_modem_ctxt->persist.pdn_event.conf_id)
 8012cea:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012cee:	9a01      	ldr	r2, [sp, #4]
 8012cf0:	4940      	ldr	r1, [pc, #256]	; (8012df4 <fRspAnalyze_CGEV+0x370>)
 8012cf2:	4658      	mov	r0, fp
 8012cf4:	f013 fda8 	bl	8026848 <sprintf>
 8012cf8:	4658      	mov	r0, fp
 8012cfa:	f00c fb16 	bl	801f32a <crs_strlen>
 8012cfe:	b283      	uxth	r3, r0
 8012d00:	465a      	mov	r2, fp
 8012d02:	2102      	movs	r1, #2
 8012d04:	4608      	mov	r0, r1
 8012d06:	f00c fb53 	bl	801f3b0 <traceIF_itmPrint>
 8012d0a:	4658      	mov	r0, fp
 8012d0c:	f00c fb0d 	bl	801f32a <crs_strlen>
 8012d10:	b283      	uxth	r3, r0
 8012d12:	465a      	mov	r2, fp
 8012d14:	2102      	movs	r1, #2
 8012d16:	4608      	mov	r0, r1
 8012d18:	f00c fb6c 	bl	801f3f4 <traceIF_uartPrint>
 8012d1c:	e762      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<ME>")
 8012d1e:	f8df b09c 	ldr.w	fp, [pc, #156]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012d22:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 8012dfc <fRspAnalyze_CGEV+0x378>
 8012d26:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012d2a:	f8cb 0000 	str.w	r0, [fp]
 8012d2e:	f8cb 1004 	str.w	r1, [fp, #4]
 8012d32:	f8cb 2008 	str.w	r2, [fp, #8]
 8012d36:	f8cb 300c 	str.w	r3, [fp, #12]
 8012d3a:	4658      	mov	r0, fp
 8012d3c:	f00c faf5 	bl	801f32a <crs_strlen>
 8012d40:	b283      	uxth	r3, r0
 8012d42:	465a      	mov	r2, fp
 8012d44:	2102      	movs	r1, #2
 8012d46:	4608      	mov	r0, r1
 8012d48:	f00c fb32 	bl	801f3b0 <traceIF_itmPrint>
 8012d4c:	4658      	mov	r0, fp
 8012d4e:	f00c faec 	bl	801f32a <crs_strlen>
 8012d52:	b283      	uxth	r3, r0
 8012d54:	465a      	mov	r2, fp
 8012d56:	2102      	movs	r1, #2
 8012d58:	4608      	mov	r0, r1
 8012d5a:	f00c fb4b 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_origine = CGEV_EVENT_ORIGINE_ME;
 8012d5e:	2302      	movs	r3, #2
 8012d60:	f886 304c 	strb.w	r3, [r6, #76]	; 0x4c
 8012d64:	e73e      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<PDN>")
 8012d66:	f8df b054 	ldr.w	fp, [pc, #84]	; 8012dbc <fRspAnalyze_CGEV+0x338>
 8012d6a:	f8df c094 	ldr.w	ip, [pc, #148]	; 8012e00 <fRspAnalyze_CGEV+0x37c>
 8012d6e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012d72:	f8cb 0000 	str.w	r0, [fp]
 8012d76:	f8cb 1004 	str.w	r1, [fp, #4]
 8012d7a:	f8cb 2008 	str.w	r2, [fp, #8]
 8012d7e:	f8cb 300c 	str.w	r3, [fp, #12]
 8012d82:	f89c 3000 	ldrb.w	r3, [ip]
 8012d86:	f88b 3010 	strb.w	r3, [fp, #16]
 8012d8a:	4658      	mov	r0, fp
 8012d8c:	f00c facd 	bl	801f32a <crs_strlen>
 8012d90:	b283      	uxth	r3, r0
 8012d92:	465a      	mov	r2, fp
 8012d94:	2102      	movs	r1, #2
 8012d96:	4608      	mov	r0, r1
 8012d98:	f00c fb0a 	bl	801f3b0 <traceIF_itmPrint>
 8012d9c:	4658      	mov	r0, fp
 8012d9e:	f00c fac4 	bl	801f32a <crs_strlen>
 8012da2:	b283      	uxth	r3, r0
 8012da4:	465a      	mov	r2, fp
 8012da6:	2102      	movs	r1, #2
 8012da8:	4608      	mov	r0, r1
 8012daa:	f00c fb23 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_scope = CGEV_EVENT_SCOPE_PDN;
 8012dae:	230a      	movs	r3, #10
 8012db0:	f886 304d 	strb.w	r3, [r6, #77]	; 0x4d
 8012db4:	e716      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
 8012db6:	bf00      	nop
 8012db8:	08030ac4 	.word	0x08030ac4
 8012dbc:	200048dc 	.word	0x200048dc
 8012dc0:	000d0001 	.word	0x000d0001
 8012dc4:	08030d00 	.word	0x08030d00
 8012dc8:	08030aec 	.word	0x08030aec
 8012dcc:	08030c88 	.word	0x08030c88
 8012dd0:	08030af0 	.word	0x08030af0
 8012dd4:	08030b04 	.word	0x08030b04
 8012dd8:	08030b18 	.word	0x08030b18
 8012ddc:	08030b30 	.word	0x08030b30
 8012de0:	08030b48 	.word	0x08030b48
 8012de4:	08030b64 	.word	0x08030b64
 8012de8:	08030b80 	.word	0x08030b80
 8012dec:	08030b9c 	.word	0x08030b9c
 8012df0:	08030bb8 	.word	0x08030bb8
 8012df4:	08030c0c 	.word	0x08030c0c
 8012df8:	08030af4 	.word	0x08030af4
 8012dfc:	08030b08 	.word	0x08030b08
 8012e00:	08030b1c 	.word	0x08030b1c
          PRINT_DBG("<ACT>")
 8012e04:	f8df b3fc 	ldr.w	fp, [pc, #1020]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012e08:	f8df c40c 	ldr.w	ip, [pc, #1036]	; 8013218 <fRspAnalyze_CGEV+0x794>
 8012e0c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012e10:	f8cb 0000 	str.w	r0, [fp]
 8012e14:	f8cb 1004 	str.w	r1, [fp, #4]
 8012e18:	f8cb 2008 	str.w	r2, [fp, #8]
 8012e1c:	f8cb 300c 	str.w	r3, [fp, #12]
 8012e20:	f89c 3000 	ldrb.w	r3, [ip]
 8012e24:	f88b 3010 	strb.w	r3, [fp, #16]
 8012e28:	4658      	mov	r0, fp
 8012e2a:	f00c fa7e 	bl	801f32a <crs_strlen>
 8012e2e:	b283      	uxth	r3, r0
 8012e30:	465a      	mov	r2, fp
 8012e32:	2102      	movs	r1, #2
 8012e34:	4608      	mov	r0, r1
 8012e36:	f00c fabb 	bl	801f3b0 <traceIF_itmPrint>
 8012e3a:	4658      	mov	r0, fp
 8012e3c:	f00c fa75 	bl	801f32a <crs_strlen>
 8012e40:	b283      	uxth	r3, r0
 8012e42:	465a      	mov	r2, fp
 8012e44:	2102      	movs	r1, #2
 8012e46:	4608      	mov	r0, r1
 8012e48:	f00c fad4 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_ACTIVATION;
 8012e4c:	230c      	movs	r3, #12
 8012e4e:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012e52:	e6c7      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<DEACT>")
 8012e54:	f8df b3ac 	ldr.w	fp, [pc, #940]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012e58:	f8df c3c0 	ldr.w	ip, [pc, #960]	; 801321c <fRspAnalyze_CGEV+0x798>
 8012e5c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012e60:	f8cb 0000 	str.w	r0, [fp]
 8012e64:	f8cb 1004 	str.w	r1, [fp, #4]
 8012e68:	f8cb 2008 	str.w	r2, [fp, #8]
 8012e6c:	f8cb 300c 	str.w	r3, [fp, #12]
 8012e70:	f8bc 2000 	ldrh.w	r2, [ip]
 8012e74:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8012e78:	f8ab 2010 	strh.w	r2, [fp, #16]
 8012e7c:	f88b 3012 	strb.w	r3, [fp, #18]
 8012e80:	4658      	mov	r0, fp
 8012e82:	f00c fa52 	bl	801f32a <crs_strlen>
 8012e86:	b283      	uxth	r3, r0
 8012e88:	465a      	mov	r2, fp
 8012e8a:	2102      	movs	r1, #2
 8012e8c:	4608      	mov	r0, r1
 8012e8e:	f00c fa8f 	bl	801f3b0 <traceIF_itmPrint>
 8012e92:	4658      	mov	r0, fp
 8012e94:	f00c fa49 	bl	801f32a <crs_strlen>
 8012e98:	b283      	uxth	r3, r0
 8012e9a:	465a      	mov	r2, fp
 8012e9c:	2102      	movs	r1, #2
 8012e9e:	4608      	mov	r0, r1
 8012ea0:	f00c faa8 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_DEACTIVATION;
 8012ea4:	230d      	movs	r3, #13
 8012ea6:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012eaa:	e69b      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<REJECT>")
 8012eac:	f8df b354 	ldr.w	fp, [pc, #852]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012eb0:	f8df c36c 	ldr.w	ip, [pc, #876]	; 8013220 <fRspAnalyze_CGEV+0x79c>
 8012eb4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012eb8:	f8cb 0000 	str.w	r0, [fp]
 8012ebc:	f8cb 1004 	str.w	r1, [fp, #4]
 8012ec0:	f8cb 2008 	str.w	r2, [fp, #8]
 8012ec4:	f8cb 300c 	str.w	r3, [fp, #12]
 8012ec8:	f8dc 0000 	ldr.w	r0, [ip]
 8012ecc:	f8cb 0010 	str.w	r0, [fp, #16]
 8012ed0:	4658      	mov	r0, fp
 8012ed2:	f00c fa2a 	bl	801f32a <crs_strlen>
 8012ed6:	b283      	uxth	r3, r0
 8012ed8:	465a      	mov	r2, fp
 8012eda:	2102      	movs	r1, #2
 8012edc:	4608      	mov	r0, r1
 8012ede:	f00c fa67 	bl	801f3b0 <traceIF_itmPrint>
 8012ee2:	4658      	mov	r0, fp
 8012ee4:	f00c fa21 	bl	801f32a <crs_strlen>
 8012ee8:	b283      	uxth	r3, r0
 8012eea:	465a      	mov	r2, fp
 8012eec:	2102      	movs	r1, #2
 8012eee:	4608      	mov	r0, r1
 8012ef0:	f00c fa80 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_REJECT;
 8012ef4:	230e      	movs	r3, #14
 8012ef6:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012efa:	e673      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<DETACH>")
 8012efc:	f8df b304 	ldr.w	fp, [pc, #772]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012f00:	f8df c320 	ldr.w	ip, [pc, #800]	; 8013224 <fRspAnalyze_CGEV+0x7a0>
 8012f04:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012f08:	f8cb 0000 	str.w	r0, [fp]
 8012f0c:	f8cb 1004 	str.w	r1, [fp, #4]
 8012f10:	f8cb 2008 	str.w	r2, [fp, #8]
 8012f14:	f8cb 300c 	str.w	r3, [fp, #12]
 8012f18:	f8dc 0000 	ldr.w	r0, [ip]
 8012f1c:	f8cb 0010 	str.w	r0, [fp, #16]
 8012f20:	4658      	mov	r0, fp
 8012f22:	f00c fa02 	bl	801f32a <crs_strlen>
 8012f26:	b283      	uxth	r3, r0
 8012f28:	465a      	mov	r2, fp
 8012f2a:	2102      	movs	r1, #2
 8012f2c:	4608      	mov	r0, r1
 8012f2e:	f00c fa3f 	bl	801f3b0 <traceIF_itmPrint>
 8012f32:	4658      	mov	r0, fp
 8012f34:	f00c f9f9 	bl	801f32a <crs_strlen>
 8012f38:	b283      	uxth	r3, r0
 8012f3a:	465a      	mov	r2, fp
 8012f3c:	2102      	movs	r1, #2
 8012f3e:	4608      	mov	r0, r1
 8012f40:	f00c fa58 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_DETACH;
 8012f44:	230f      	movs	r3, #15
 8012f46:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
          p_modem_ctxt->persist.pdn_event.conf_id = CS_PDN_ALL;
 8012f4a:	230d      	movs	r3, #13
 8012f4c:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
 8012f50:	e648      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<CLASS>")
 8012f52:	f8df b2b0 	ldr.w	fp, [pc, #688]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012f56:	f8df c2d0 	ldr.w	ip, [pc, #720]	; 8013228 <fRspAnalyze_CGEV+0x7a4>
 8012f5a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012f5e:	f8cb 0000 	str.w	r0, [fp]
 8012f62:	f8cb 1004 	str.w	r1, [fp, #4]
 8012f66:	f8cb 2008 	str.w	r2, [fp, #8]
 8012f6a:	f8cb 300c 	str.w	r3, [fp, #12]
 8012f6e:	f8bc 2000 	ldrh.w	r2, [ip]
 8012f72:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8012f76:	f8ab 2010 	strh.w	r2, [fp, #16]
 8012f7a:	f88b 3012 	strb.w	r3, [fp, #18]
 8012f7e:	4658      	mov	r0, fp
 8012f80:	f00c f9d3 	bl	801f32a <crs_strlen>
 8012f84:	b283      	uxth	r3, r0
 8012f86:	465a      	mov	r2, fp
 8012f88:	2102      	movs	r1, #2
 8012f8a:	4608      	mov	r0, r1
 8012f8c:	f00c fa10 	bl	801f3b0 <traceIF_itmPrint>
 8012f90:	4658      	mov	r0, fp
 8012f92:	f00c f9ca 	bl	801f32a <crs_strlen>
 8012f96:	b283      	uxth	r3, r0
 8012f98:	465a      	mov	r2, fp
 8012f9a:	2102      	movs	r1, #2
 8012f9c:	4608      	mov	r0, r1
 8012f9e:	f00c fa29 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_CLASS;
 8012fa2:	2310      	movs	r3, #16
 8012fa4:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012fa8:	e61c      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
          PRINT_DBG("<MODIFY>")
 8012faa:	f8df b258 	ldr.w	fp, [pc, #600]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8012fae:	f8df c27c 	ldr.w	ip, [pc, #636]	; 801322c <fRspAnalyze_CGEV+0x7a8>
 8012fb2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8012fb6:	f8cb 0000 	str.w	r0, [fp]
 8012fba:	f8cb 1004 	str.w	r1, [fp, #4]
 8012fbe:	f8cb 2008 	str.w	r2, [fp, #8]
 8012fc2:	f8cb 300c 	str.w	r3, [fp, #12]
 8012fc6:	f8dc 0000 	ldr.w	r0, [ip]
 8012fca:	f8cb 0010 	str.w	r0, [fp, #16]
 8012fce:	4658      	mov	r0, fp
 8012fd0:	f00c f9ab 	bl	801f32a <crs_strlen>
 8012fd4:	b283      	uxth	r3, r0
 8012fd6:	465a      	mov	r2, fp
 8012fd8:	2102      	movs	r1, #2
 8012fda:	4608      	mov	r0, r1
 8012fdc:	f00c f9e8 	bl	801f3b0 <traceIF_itmPrint>
 8012fe0:	4658      	mov	r0, fp
 8012fe2:	f00c f9a2 	bl	801f32a <crs_strlen>
 8012fe6:	b283      	uxth	r3, r0
 8012fe8:	465a      	mov	r2, fp
 8012fea:	2102      	movs	r1, #2
 8012fec:	4608      	mov	r0, r1
 8012fee:	f00c fa01 	bl	801f3f4 <traceIF_uartPrint>
          p_modem_ctxt->persist.pdn_event.event_type = CGEV_EVENT_TYPE_MODIFY;
 8012ff2:	2311      	movs	r3, #17
 8012ff4:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
 8012ff8:	e5f4      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
              PRINT_ERR("No parameter expected for  NW DETACH")
 8012ffa:	f8df e234 	ldr.w	lr, [pc, #564]	; 8013230 <fRspAnalyze_CGEV+0x7ac>
 8012ffe:	f8df b204 	ldr.w	fp, [pc, #516]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013002:	46f4      	mov	ip, lr
 8013004:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013008:	f8cb 0000 	str.w	r0, [fp]
 801300c:	f8cb 1004 	str.w	r1, [fp, #4]
 8013010:	f8cb 2008 	str.w	r2, [fp, #8]
 8013014:	f8cb 300c 	str.w	r3, [fp, #12]
 8013018:	46e6      	mov	lr, ip
 801301a:	f10b 0b10 	add.w	fp, fp, #16
 801301e:	4b77      	ldr	r3, [pc, #476]	; (80131fc <fRspAnalyze_CGEV+0x778>)
 8013020:	459c      	cmp	ip, r3
 8013022:	d1ee      	bne.n	8013002 <fRspAnalyze_CGEV+0x57e>
 8013024:	f8dc 0000 	ldr.w	r0, [ip]
 8013028:	f8cb 0000 	str.w	r0, [fp]
 801302c:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8013030:	f8ab 3004 	strh.w	r3, [fp, #4]
 8013034:	f8df b1cc 	ldr.w	fp, [pc, #460]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013038:	4658      	mov	r0, fp
 801303a:	f00c f976 	bl	801f32a <crs_strlen>
 801303e:	b283      	uxth	r3, r0
 8013040:	465a      	mov	r2, fp
 8013042:	2110      	movs	r1, #16
 8013044:	2002      	movs	r0, #2
 8013046:	f00c f9b3 	bl	801f3b0 <traceIF_itmPrint>
 801304a:	4658      	mov	r0, fp
 801304c:	f00c f96d 	bl	801f32a <crs_strlen>
 8013050:	b283      	uxth	r3, r0
 8013052:	465a      	mov	r2, fp
 8013054:	2110      	movs	r1, #16
 8013056:	2002      	movs	r0, #2
 8013058:	f00c f9cc 	bl	801f3f4 <traceIF_uartPrint>
 801305c:	e5c2      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
              PRINT_DBG("event type (= %d) ignored", p_modem_ctxt->persist.pdn_event.event_type)
 801305e:	f8df b1a4 	ldr.w	fp, [pc, #420]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013062:	4967      	ldr	r1, [pc, #412]	; (8013200 <fRspAnalyze_CGEV+0x77c>)
 8013064:	4658      	mov	r0, fp
 8013066:	f013 fbef 	bl	8026848 <sprintf>
 801306a:	4658      	mov	r0, fp
 801306c:	f00c f95d 	bl	801f32a <crs_strlen>
 8013070:	b283      	uxth	r3, r0
 8013072:	465a      	mov	r2, fp
 8013074:	2102      	movs	r1, #2
 8013076:	4608      	mov	r0, r1
 8013078:	f00c f99a 	bl	801f3b0 <traceIF_itmPrint>
 801307c:	4658      	mov	r0, fp
 801307e:	f00c f954 	bl	801f32a <crs_strlen>
 8013082:	b283      	uxth	r3, r0
 8013084:	465a      	mov	r2, fp
 8013086:	2102      	movs	r1, #2
 8013088:	4608      	mov	r0, r1
 801308a:	f00c f9b3 	bl	801f3f4 <traceIF_uartPrint>
 801308e:	e5a9      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
            PRINT_DBG("ME events ignored")
 8013090:	f8df b170 	ldr.w	fp, [pc, #368]	; 8013204 <fRspAnalyze_CGEV+0x780>
 8013094:	f8df c19c 	ldr.w	ip, [pc, #412]	; 8013234 <fRspAnalyze_CGEV+0x7b0>
 8013098:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801309c:	f8cb 0000 	str.w	r0, [fp]
 80130a0:	f8cb 1004 	str.w	r1, [fp, #4]
 80130a4:	f8cb 2008 	str.w	r2, [fp, #8]
 80130a8:	f8cb 300c 	str.w	r3, [fp, #12]
 80130ac:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 80130b0:	f8cb 0010 	str.w	r0, [fp, #16]
 80130b4:	f8cb 1014 	str.w	r1, [fp, #20]
 80130b8:	f8cb 2018 	str.w	r2, [fp, #24]
 80130bc:	f89c 3000 	ldrb.w	r3, [ip]
 80130c0:	f88b 301c 	strb.w	r3, [fp, #28]
 80130c4:	4658      	mov	r0, fp
 80130c6:	f00c f930 	bl	801f32a <crs_strlen>
 80130ca:	b283      	uxth	r3, r0
 80130cc:	465a      	mov	r2, fp
 80130ce:	2102      	movs	r1, #2
 80130d0:	4608      	mov	r0, r1
 80130d2:	f00c f96d 	bl	801f3b0 <traceIF_itmPrint>
 80130d6:	4658      	mov	r0, fp
 80130d8:	f00c f927 	bl	801f32a <crs_strlen>
 80130dc:	b283      	uxth	r3, r0
 80130de:	465a      	mov	r2, fp
 80130e0:	2102      	movs	r1, #2
 80130e2:	4608      	mov	r0, r1
 80130e4:	f00c f986 	bl	801f3f4 <traceIF_uartPrint>
 80130e8:	e57c      	b.n	8012be4 <fRspAnalyze_CGEV+0x160>
      p_modem_ctxt->persist.urc_avail_pdn_event = AT_TRUE;
 80130ea:	2301      	movs	r3, #1
 80130ec:	f886 3020 	strb.w	r3, [r6, #32]
 80130f0:	e07b      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
      PRINT_ERR("an +CGEV URC still not reported, ignore this one")
 80130f2:	4c44      	ldr	r4, [pc, #272]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 80130f4:	2242      	movs	r2, #66	; 0x42
 80130f6:	4944      	ldr	r1, [pc, #272]	; (8013208 <fRspAnalyze_CGEV+0x784>)
 80130f8:	4620      	mov	r0, r4
 80130fa:	f013 fcf5 	bl	8026ae8 <memcpy>
 80130fe:	4620      	mov	r0, r4
 8013100:	f00c f913 	bl	801f32a <crs_strlen>
 8013104:	b283      	uxth	r3, r0
 8013106:	4622      	mov	r2, r4
 8013108:	2110      	movs	r1, #16
 801310a:	2002      	movs	r0, #2
 801310c:	f00c f950 	bl	801f3b0 <traceIF_itmPrint>
 8013110:	4620      	mov	r0, r4
 8013112:	f00c f90a 	bl	801f32a <crs_strlen>
 8013116:	b283      	uxth	r3, r0
 8013118:	4622      	mov	r2, r4
 801311a:	2110      	movs	r1, #16
 801311c:	2002      	movs	r0, #2
 801311e:	f00c f969 	bl	801f3f4 <traceIF_uartPrint>
      retval = ATACTION_RSP_ERROR;
 8013122:	2004      	movs	r0, #4
 8013124:	e066      	b.n	80131f4 <fRspAnalyze_CGEV+0x770>
    if ((p_modem_ctxt->persist.pdn_event.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8013126:	6cf3      	ldr	r3, [r6, #76]	; 0x4c
 8013128:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 801312c:	4937      	ldr	r1, [pc, #220]	; (801320c <fRspAnalyze_CGEV+0x788>)
 801312e:	428b      	cmp	r3, r1
 8013130:	d017      	beq.n	8013162 <fRspAnalyze_CGEV+0x6de>
      PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
 8013132:	4c34      	ldr	r4, [pc, #208]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 8013134:	4936      	ldr	r1, [pc, #216]	; (8013210 <fRspAnalyze_CGEV+0x78c>)
 8013136:	4620      	mov	r0, r4
 8013138:	f013 fb86 	bl	8026848 <sprintf>
 801313c:	4620      	mov	r0, r4
 801313e:	f00c f8f4 	bl	801f32a <crs_strlen>
 8013142:	b283      	uxth	r3, r0
 8013144:	4622      	mov	r2, r4
 8013146:	2102      	movs	r1, #2
 8013148:	4608      	mov	r0, r1
 801314a:	f00c f931 	bl	801f3b0 <traceIF_itmPrint>
 801314e:	4620      	mov	r0, r4
 8013150:	f00c f8eb 	bl	801f32a <crs_strlen>
 8013154:	b283      	uxth	r3, r0
 8013156:	4622      	mov	r2, r4
 8013158:	2102      	movs	r1, #2
 801315a:	4608      	mov	r0, r1
 801315c:	f00c f94a 	bl	801f3f4 <traceIF_uartPrint>
 8013160:	e043      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 8013162:	2241      	movs	r2, #65	; 0x41
 8013164:	2100      	movs	r1, #0
 8013166:	a803      	add	r0, sp, #12
 8013168:	f013 fbe1 	bl	802692e <memset>
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 801316c:	8969      	ldrh	r1, [r5, #10]
      (void) memcpy((void *) & (ip_addr_info.ip_addr_value),
 801316e:	89ea      	ldrh	r2, [r5, #14]
 8013170:	4439      	add	r1, r7
 8013172:	f10d 000d 	add.w	r0, sp, #13
 8013176:	f013 fcb7 	bl	8026ae8 <memcpy>
      PRINT_DBG("<PDP_addr>=%s", (AT_CHAR_t *)&ip_addr_info.ip_addr_value)
 801317a:	4c22      	ldr	r4, [pc, #136]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 801317c:	f10d 020d 	add.w	r2, sp, #13
 8013180:	4924      	ldr	r1, [pc, #144]	; (8013214 <fRspAnalyze_CGEV+0x790>)
 8013182:	4620      	mov	r0, r4
 8013184:	f013 fb60 	bl	8026848 <sprintf>
 8013188:	4620      	mov	r0, r4
 801318a:	f00c f8ce 	bl	801f32a <crs_strlen>
 801318e:	b283      	uxth	r3, r0
 8013190:	4622      	mov	r2, r4
 8013192:	2102      	movs	r1, #2
 8013194:	4608      	mov	r0, r1
 8013196:	f00c f90b 	bl	801f3b0 <traceIF_itmPrint>
 801319a:	4620      	mov	r0, r4
 801319c:	f00c f8c5 	bl	801f32a <crs_strlen>
 80131a0:	b283      	uxth	r3, r0
 80131a2:	4622      	mov	r2, r4
 80131a4:	2102      	movs	r1, #2
 80131a6:	4608      	mov	r0, r1
 80131a8:	f00c f924 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->persist.pdn_event.conf_id = find_user_cid_with_matching_ip_addr(&p_modem_ctxt->persist,
 80131ac:	a903      	add	r1, sp, #12
 80131ae:	f106 000c 	add.w	r0, r6, #12
 80131b2:	f7fb fd3d 	bl	800ec30 <find_user_cid_with_matching_ip_addr>
 80131b6:	f886 004f 	strb.w	r0, [r6, #79]	; 0x4f
 80131ba:	e016      	b.n	80131ea <fRspAnalyze_CGEV+0x766>
    }
  }
  else
  {
    PRINT_DBG("+CGEV parameter rank %d ignored", element_infos->param_rank)
 80131bc:	4c11      	ldr	r4, [pc, #68]	; (8013204 <fRspAnalyze_CGEV+0x780>)
 80131be:	4914      	ldr	r1, [pc, #80]	; (8013210 <fRspAnalyze_CGEV+0x78c>)
 80131c0:	4620      	mov	r0, r4
 80131c2:	f013 fb41 	bl	8026848 <sprintf>
 80131c6:	4620      	mov	r0, r4
 80131c8:	f00c f8af 	bl	801f32a <crs_strlen>
 80131cc:	b283      	uxth	r3, r0
 80131ce:	4622      	mov	r2, r4
 80131d0:	2102      	movs	r1, #2
 80131d2:	4608      	mov	r0, r1
 80131d4:	f00c f8ec 	bl	801f3b0 <traceIF_itmPrint>
 80131d8:	4620      	mov	r0, r4
 80131da:	f00c f8a6 	bl	801f32a <crs_strlen>
 80131de:	b283      	uxth	r3, r0
 80131e0:	4622      	mov	r2, r4
 80131e2:	2102      	movs	r1, #2
 80131e4:	4608      	mov	r0, r1
 80131e6:	f00c f905 	bl	801f3f4 <traceIF_uartPrint>
  }
  END_PARAM_LOOP()
 80131ea:	f1b9 0f00 	cmp.w	r9, #0
 80131ee:	f43f ac7f 	beq.w	8012af0 <fRspAnalyze_CGEV+0x6c>
 80131f2:	2010      	movs	r0, #16

  return (retval);
}
 80131f4:	b015      	add	sp, #84	; 0x54
 80131f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80131fa:	bf00      	nop
 80131fc:	08030c04 	.word	0x08030c04
 8013200:	08030c40 	.word	0x08030c40
 8013204:	200048dc 	.word	0x200048dc
 8013208:	08030ca0 	.word	0x08030ca0
 801320c:	000d0001 	.word	0x000d0001
 8013210:	08030d00 	.word	0x08030d00
 8013214:	08030ce4 	.word	0x08030ce4
 8013218:	08030b34 	.word	0x08030b34
 801321c:	08030b50 	.word	0x08030b50
 8013220:	08030b6c 	.word	0x08030b6c
 8013224:	08030b88 	.word	0x08030b88
 8013228:	08030ba4 	.word	0x08030ba4
 801322c:	08030bc0 	.word	0x08030bc0
 8013230:	08030bd4 	.word	0x08030bd4
 8013234:	08030c68 	.word	0x08030c68

08013238 <fRspAnalyze_CSQ>:

at_action_rsp_t fRspAnalyze_CSQ(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801323c:	4607      	mov	r7, r0
 801323e:	4689      	mov	r9, r1
 8013240:	4690      	mov	r8, r2
 8013242:	461e      	mov	r6, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CSQ()")
 8013244:	4d44      	ldr	r5, [pc, #272]	; (8013358 <fRspAnalyze_CSQ+0x120>)
 8013246:	4c45      	ldr	r4, [pc, #276]	; (801335c <fRspAnalyze_CSQ+0x124>)
 8013248:	f105 0e20 	add.w	lr, r5, #32
 801324c:	46ac      	mov	ip, r5
 801324e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013252:	6020      	str	r0, [r4, #0]
 8013254:	6061      	str	r1, [r4, #4]
 8013256:	60a2      	str	r2, [r4, #8]
 8013258:	60e3      	str	r3, [r4, #12]
 801325a:	4665      	mov	r5, ip
 801325c:	3410      	adds	r4, #16
 801325e:	45f4      	cmp	ip, lr
 8013260:	d1f4      	bne.n	801324c <fRspAnalyze_CSQ+0x14>
 8013262:	f8dc 0000 	ldr.w	r0, [ip]
 8013266:	6020      	str	r0, [r4, #0]
 8013268:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 801326c:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013270:	80a2      	strh	r2, [r4, #4]
 8013272:	71a3      	strb	r3, [r4, #6]
 8013274:	4c39      	ldr	r4, [pc, #228]	; (801335c <fRspAnalyze_CSQ+0x124>)
 8013276:	4620      	mov	r0, r4
 8013278:	f00c f857 	bl	801f32a <crs_strlen>
 801327c:	b283      	uxth	r3, r0
 801327e:	4622      	mov	r2, r4
 8013280:	2104      	movs	r1, #4
 8013282:	2002      	movs	r0, #2
 8013284:	f00c f894 	bl	801f3b0 <traceIF_itmPrint>
 8013288:	4620      	mov	r0, r4
 801328a:	f00c f84e 	bl	801f32a <crs_strlen>
 801328e:	b283      	uxth	r3, r0
 8013290:	4622      	mov	r2, r4
 8013292:	2104      	movs	r1, #4
 8013294:	2002      	movs	r0, #2
 8013296:	f00c f8ad 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for CSQ */
  /* for EXECUTION COMMAND only  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 801329a:	8b3b      	ldrh	r3, [r7, #24]
 801329c:	2b04      	cmp	r3, #4
 801329e:	d002      	beq.n	80132a6 <fRspAnalyze_CSQ+0x6e>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 80132a0:	2010      	movs	r0, #16
 80132a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    START_PARAM_LOOP()
 80132a6:	2400      	movs	r4, #0
 80132a8:	4632      	mov	r2, r6
 80132aa:	4641      	mov	r1, r8
 80132ac:	4638      	mov	r0, r7
 80132ae:	f7f9 f8cb 	bl	800c448 <atcc_extractElement>
 80132b2:	2801      	cmp	r0, #1
 80132b4:	d000      	beq.n	80132b8 <fRspAnalyze_CSQ+0x80>
 80132b6:	2401      	movs	r4, #1
 80132b8:	89f1      	ldrh	r1, [r6, #14]
 80132ba:	b129      	cbz	r1, 80132c8 <fRspAnalyze_CSQ+0x90>
    if (element_infos->param_rank == 2U)
 80132bc:	8933      	ldrh	r3, [r6, #8]
 80132be:	2b02      	cmp	r3, #2
 80132c0:	d005      	beq.n	80132ce <fRspAnalyze_CSQ+0x96>
    if (element_infos->param_rank == 3U)
 80132c2:	8933      	ldrh	r3, [r6, #8]
 80132c4:	2b03      	cmp	r3, #3
 80132c6:	d024      	beq.n	8013312 <fRspAnalyze_CSQ+0xda>
    END_PARAM_LOOP()
 80132c8:	2c00      	cmp	r4, #0
 80132ca:	d1e9      	bne.n	80132a0 <fRspAnalyze_CSQ+0x68>
 80132cc:	e7ec      	b.n	80132a8 <fRspAnalyze_CSQ+0x70>
      uint32_t rssi = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 80132ce:	8970      	ldrh	r0, [r6, #10]
 80132d0:	4440      	add	r0, r8
 80132d2:	f001 fd2f 	bl	8014d34 <ATutil_convertStringToInt>
 80132d6:	4682      	mov	sl, r0
      PRINT_DBG("+CSQ rssi=%ld", rssi)
 80132d8:	4d20      	ldr	r5, [pc, #128]	; (801335c <fRspAnalyze_CSQ+0x124>)
 80132da:	4602      	mov	r2, r0
 80132dc:	4920      	ldr	r1, [pc, #128]	; (8013360 <fRspAnalyze_CSQ+0x128>)
 80132de:	4628      	mov	r0, r5
 80132e0:	f013 fab2 	bl	8026848 <sprintf>
 80132e4:	4628      	mov	r0, r5
 80132e6:	f00c f820 	bl	801f32a <crs_strlen>
 80132ea:	b283      	uxth	r3, r0
 80132ec:	462a      	mov	r2, r5
 80132ee:	2102      	movs	r1, #2
 80132f0:	4608      	mov	r0, r1
 80132f2:	f00c f85d 	bl	801f3b0 <traceIF_itmPrint>
 80132f6:	4628      	mov	r0, r5
 80132f8:	f00c f817 	bl	801f32a <crs_strlen>
 80132fc:	b283      	uxth	r3, r0
 80132fe:	462a      	mov	r2, r5
 8013300:	2102      	movs	r1, #2
 8013302:	4608      	mov	r0, r1
 8013304:	f00c f876 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->SID_ctxt.signal_quality->rssi = (uint8_t)rssi;
 8013308:	f8d9 3660 	ldr.w	r3, [r9, #1632]	; 0x660
 801330c:	f883 a000 	strb.w	sl, [r3]
 8013310:	e7d7      	b.n	80132c2 <fRspAnalyze_CSQ+0x8a>
      uint32_t ber = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013312:	8970      	ldrh	r0, [r6, #10]
 8013314:	89f1      	ldrh	r1, [r6, #14]
 8013316:	4440      	add	r0, r8
 8013318:	f001 fd0c 	bl	8014d34 <ATutil_convertStringToInt>
 801331c:	4682      	mov	sl, r0
      PRINT_DBG("+CSQ ber=%ld", ber)
 801331e:	4d0f      	ldr	r5, [pc, #60]	; (801335c <fRspAnalyze_CSQ+0x124>)
 8013320:	4602      	mov	r2, r0
 8013322:	4910      	ldr	r1, [pc, #64]	; (8013364 <fRspAnalyze_CSQ+0x12c>)
 8013324:	4628      	mov	r0, r5
 8013326:	f013 fa8f 	bl	8026848 <sprintf>
 801332a:	4628      	mov	r0, r5
 801332c:	f00b fffd 	bl	801f32a <crs_strlen>
 8013330:	b283      	uxth	r3, r0
 8013332:	462a      	mov	r2, r5
 8013334:	2102      	movs	r1, #2
 8013336:	4608      	mov	r0, r1
 8013338:	f00c f83a 	bl	801f3b0 <traceIF_itmPrint>
 801333c:	4628      	mov	r0, r5
 801333e:	f00b fff4 	bl	801f32a <crs_strlen>
 8013342:	b283      	uxth	r3, r0
 8013344:	462a      	mov	r2, r5
 8013346:	2102      	movs	r1, #2
 8013348:	4608      	mov	r0, r1
 801334a:	f00c f853 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->SID_ctxt.signal_quality->ber = (uint8_t)ber;
 801334e:	f8d9 3660 	ldr.w	r3, [r9, #1632]	; 0x660
 8013352:	f883 a001 	strb.w	sl, [r3, #1]
 8013356:	e7b7      	b.n	80132c8 <fRspAnalyze_CSQ+0x90>
 8013358:	08030d2c 	.word	0x08030d2c
 801335c:	200048dc 	.word	0x200048dc
 8013360:	08030d54 	.word	0x08030d54
 8013364:	08030d70 	.word	0x08030d70

08013368 <fRspAnalyze_CGPADDR>:

at_action_rsp_t fRspAnalyze_CGPADDR(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                    const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013368:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801336c:	b092      	sub	sp, #72	; 0x48
 801336e:	4606      	mov	r6, r0
 8013370:	4689      	mov	r9, r1
 8013372:	4690      	mov	r8, r2
 8013374:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CGPADDR()")
 8013376:	4c59      	ldr	r4, [pc, #356]	; (80134dc <fRspAnalyze_CGPADDR+0x174>)
 8013378:	4d59      	ldr	r5, [pc, #356]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 801337a:	f104 0e20 	add.w	lr, r4, #32
 801337e:	46a4      	mov	ip, r4
 8013380:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013384:	6028      	str	r0, [r5, #0]
 8013386:	6069      	str	r1, [r5, #4]
 8013388:	60aa      	str	r2, [r5, #8]
 801338a:	60eb      	str	r3, [r5, #12]
 801338c:	4664      	mov	r4, ip
 801338e:	3510      	adds	r5, #16
 8013390:	45f4      	cmp	ip, lr
 8013392:	d1f4      	bne.n	801337e <fRspAnalyze_CGPADDR+0x16>
 8013394:	cc03      	ldmia	r4!, {r0, r1}
 8013396:	6028      	str	r0, [r5, #0]
 8013398:	6069      	str	r1, [r5, #4]
 801339a:	8822      	ldrh	r2, [r4, #0]
 801339c:	78a3      	ldrb	r3, [r4, #2]
 801339e:	812a      	strh	r2, [r5, #8]
 80133a0:	72ab      	strb	r3, [r5, #10]
 80133a2:	4c4f      	ldr	r4, [pc, #316]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 80133a4:	4620      	mov	r0, r4
 80133a6:	f00b ffc0 	bl	801f32a <crs_strlen>
 80133aa:	b283      	uxth	r3, r0
 80133ac:	4622      	mov	r2, r4
 80133ae:	2104      	movs	r1, #4
 80133b0:	2002      	movs	r0, #2
 80133b2:	f00b fffd 	bl	801f3b0 <traceIF_itmPrint>
 80133b6:	4620      	mov	r0, r4
 80133b8:	f00b ffb7 	bl	801f32a <crs_strlen>
 80133bc:	b283      	uxth	r3, r0
 80133be:	4622      	mov	r2, r4
 80133c0:	2104      	movs	r1, #4
 80133c2:	2002      	movs	r0, #2
 80133c4:	f00c f816 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for CGPADDR */
  /* for WRITE COMMAND only  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 80133c8:	8b33      	ldrh	r3, [r6, #24]
 80133ca:	2b03      	cmp	r3, #3
 80133cc:	d003      	beq.n	80133d6 <fRspAnalyze_CGPADDR+0x6e>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 80133ce:	2010      	movs	r0, #16
 80133d0:	b012      	add	sp, #72	; 0x48
 80133d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    START_PARAM_LOOP()
 80133d6:	2400      	movs	r4, #0
 80133d8:	463a      	mov	r2, r7
 80133da:	4641      	mov	r1, r8
 80133dc:	4630      	mov	r0, r6
 80133de:	f7f9 f833 	bl	800c448 <atcc_extractElement>
 80133e2:	2801      	cmp	r0, #1
 80133e4:	d000      	beq.n	80133e8 <fRspAnalyze_CGPADDR+0x80>
 80133e6:	2401      	movs	r4, #1
 80133e8:	89fb      	ldrh	r3, [r7, #14]
 80133ea:	b913      	cbnz	r3, 80133f2 <fRspAnalyze_CGPADDR+0x8a>
    END_PARAM_LOOP()
 80133ec:	2c00      	cmp	r4, #0
 80133ee:	d1ee      	bne.n	80133ce <fRspAnalyze_CGPADDR+0x66>
 80133f0:	e7f2      	b.n	80133d8 <fRspAnalyze_CGPADDR+0x70>
    PRINT_DBG("+CGPADDR param_rank = %d", element_infos->param_rank)
 80133f2:	4d3b      	ldr	r5, [pc, #236]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 80133f4:	893a      	ldrh	r2, [r7, #8]
 80133f6:	493b      	ldr	r1, [pc, #236]	; (80134e4 <fRspAnalyze_CGPADDR+0x17c>)
 80133f8:	4628      	mov	r0, r5
 80133fa:	f013 fa25 	bl	8026848 <sprintf>
 80133fe:	4628      	mov	r0, r5
 8013400:	f00b ff93 	bl	801f32a <crs_strlen>
 8013404:	b283      	uxth	r3, r0
 8013406:	462a      	mov	r2, r5
 8013408:	2102      	movs	r1, #2
 801340a:	4608      	mov	r0, r1
 801340c:	f00b ffd0 	bl	801f3b0 <traceIF_itmPrint>
 8013410:	4628      	mov	r0, r5
 8013412:	f00b ff8a 	bl	801f32a <crs_strlen>
 8013416:	b283      	uxth	r3, r0
 8013418:	462a      	mov	r2, r5
 801341a:	2102      	movs	r1, #2
 801341c:	4608      	mov	r0, r1
 801341e:	f00b ffe9 	bl	801f3f4 <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 8013422:	893b      	ldrh	r3, [r7, #8]
 8013424:	2b02      	cmp	r3, #2
 8013426:	d039      	beq.n	801349c <fRspAnalyze_CGPADDR+0x134>
    else if ((element_infos->param_rank == 3U) || (element_infos->param_rank == 4U))
 8013428:	3b03      	subs	r3, #3
 801342a:	b29b      	uxth	r3, r3
 801342c:	2b01      	cmp	r3, #1
 801342e:	d8dd      	bhi.n	80133ec <fRspAnalyze_CGPADDR+0x84>
      (void) memset((void *)&ip_addr_info, 0, sizeof(csint_ip_addr_info_t));
 8013430:	2241      	movs	r2, #65	; 0x41
 8013432:	2100      	movs	r1, #0
 8013434:	a801      	add	r0, sp, #4
 8013436:	f013 fa7a 	bl	802692e <memset>
                    (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 801343a:	8979      	ldrh	r1, [r7, #10]
      (void) memcpy((void *) & (ip_addr_info.ip_addr_value),
 801343c:	89fa      	ldrh	r2, [r7, #14]
 801343e:	4441      	add	r1, r8
 8013440:	f10d 0005 	add.w	r0, sp, #5
 8013444:	f013 fb50 	bl	8026ae8 <memcpy>
      PRINT_DBG("+CGPADDR addr=%s", (AT_CHAR_t *)&ip_addr_info.ip_addr_value)
 8013448:	4d25      	ldr	r5, [pc, #148]	; (80134e0 <fRspAnalyze_CGPADDR+0x178>)
 801344a:	f10d 0205 	add.w	r2, sp, #5
 801344e:	4926      	ldr	r1, [pc, #152]	; (80134e8 <fRspAnalyze_CGPADDR+0x180>)
 8013450:	4628      	mov	r0, r5
 8013452:	f013 f9f9 	bl	8026848 <sprintf>
 8013456:	4628      	mov	r0, r5
 8013458:	f00b ff67 	bl	801f32a <crs_strlen>
 801345c:	b283      	uxth	r3, r0
 801345e:	462a      	mov	r2, r5
 8013460:	2102      	movs	r1, #2
 8013462:	4608      	mov	r0, r1
 8013464:	f00b ffa4 	bl	801f3b0 <traceIF_itmPrint>
 8013468:	4628      	mov	r0, r5
 801346a:	f00b ff5e 	bl	801f32a <crs_strlen>
 801346e:	b283      	uxth	r3, r0
 8013470:	462a      	mov	r2, r5
 8013472:	2102      	movs	r1, #2
 8013474:	4608      	mov	r0, r1
 8013476:	f00b ffbd 	bl	801f3f4 <traceIF_uartPrint>
      ip_addr_info.ip_addr_type = atcm_get_ip_address_type((AT_CHAR_t *)&ip_addr_info.ip_addr_value);
 801347a:	f10d 0005 	add.w	r0, sp, #5
 801347e:	f7f9 f9cb 	bl	800c818 <atcm_get_ip_address_type>
 8013482:	f88d 0004 	strb.w	r0, [sp, #4]
      if (element_infos->param_rank == 3U)
 8013486:	893b      	ldrh	r3, [r7, #8]
 8013488:	2b03      	cmp	r3, #3
 801348a:	d1af      	bne.n	80133ec <fRspAnalyze_CGPADDR+0x84>
        atcm_put_IP_address_infos(&p_modem_ctxt->persist, (uint8_t)p_modem_ctxt->CMD_ctxt.modem_cid, &ip_addr_info);
 801348c:	aa01      	add	r2, sp, #4
 801348e:	f899 1734 	ldrb.w	r1, [r9, #1844]	; 0x734
 8013492:	f109 000c 	add.w	r0, r9, #12
 8013496:	f7f9 f97d 	bl	800c794 <atcm_put_IP_address_infos>
 801349a:	e7a7      	b.n	80133ec <fRspAnalyze_CGPADDR+0x84>
      uint32_t modem_cid = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 801349c:	8978      	ldrh	r0, [r7, #10]
 801349e:	89f9      	ldrh	r1, [r7, #14]
 80134a0:	4440      	add	r0, r8
 80134a2:	f001 fc47 	bl	8014d34 <ATutil_convertStringToInt>
 80134a6:	4682      	mov	sl, r0
      PRINT_DBG("+CGPADDR cid=%ld", modem_cid)
 80134a8:	4602      	mov	r2, r0
 80134aa:	4910      	ldr	r1, [pc, #64]	; (80134ec <fRspAnalyze_CGPADDR+0x184>)
 80134ac:	4628      	mov	r0, r5
 80134ae:	f013 f9cb 	bl	8026848 <sprintf>
 80134b2:	4628      	mov	r0, r5
 80134b4:	f00b ff39 	bl	801f32a <crs_strlen>
 80134b8:	b283      	uxth	r3, r0
 80134ba:	462a      	mov	r2, r5
 80134bc:	2102      	movs	r1, #2
 80134be:	4608      	mov	r0, r1
 80134c0:	f00b ff76 	bl	801f3b0 <traceIF_itmPrint>
 80134c4:	4628      	mov	r0, r5
 80134c6:	f00b ff30 	bl	801f32a <crs_strlen>
 80134ca:	b283      	uxth	r3, r0
 80134cc:	462a      	mov	r2, r5
 80134ce:	2102      	movs	r1, #2
 80134d0:	4608      	mov	r0, r1
 80134d2:	f00b ff8f 	bl	801f3f4 <traceIF_uartPrint>
      p_modem_ctxt->CMD_ctxt.modem_cid = modem_cid;
 80134d6:	f8c9 a734 	str.w	sl, [r9, #1844]	; 0x734
 80134da:	e787      	b.n	80133ec <fRspAnalyze_CGPADDR+0x84>
 80134dc:	08030d88 	.word	0x08030d88
 80134e0:	200048dc 	.word	0x200048dc
 80134e4:	08030db4 	.word	0x08030db4
 80134e8:	08030df4 	.word	0x08030df4
 80134ec:	08030dd8 	.word	0x08030dd8

080134f0 <fRspAnalyze_CPSMS>:

at_action_rsp_t fRspAnalyze_CPSMS(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                  const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 80134f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80134f4:	4607      	mov	r7, r0
 80134f6:	4690      	mov	r8, r2
 80134f8:	461e      	mov	r6, r3
  UNUSED(p_modem_ctxt);
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CPSMS()")
 80134fa:	4c7b      	ldr	r4, [pc, #492]	; (80136e8 <fRspAnalyze_CPSMS+0x1f8>)
 80134fc:	4d7b      	ldr	r5, [pc, #492]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 80134fe:	f104 0e20 	add.w	lr, r4, #32
 8013502:	46a4      	mov	ip, r4
 8013504:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013508:	6028      	str	r0, [r5, #0]
 801350a:	6069      	str	r1, [r5, #4]
 801350c:	60aa      	str	r2, [r5, #8]
 801350e:	60eb      	str	r3, [r5, #12]
 8013510:	4664      	mov	r4, ip
 8013512:	3510      	adds	r5, #16
 8013514:	45f4      	cmp	ip, lr
 8013516:	d1f4      	bne.n	8013502 <fRspAnalyze_CPSMS+0x12>
 8013518:	cc03      	ldmia	r4!, {r0, r1}
 801351a:	6028      	str	r0, [r5, #0]
 801351c:	6069      	str	r1, [r5, #4]
 801351e:	7823      	ldrb	r3, [r4, #0]
 8013520:	722b      	strb	r3, [r5, #8]
 8013522:	4c72      	ldr	r4, [pc, #456]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 8013524:	4620      	mov	r0, r4
 8013526:	f00b ff00 	bl	801f32a <crs_strlen>
 801352a:	b283      	uxth	r3, r0
 801352c:	4622      	mov	r2, r4
 801352e:	2104      	movs	r1, #4
 8013530:	2002      	movs	r0, #2
 8013532:	f00b ff3d 	bl	801f3b0 <traceIF_itmPrint>
 8013536:	4620      	mov	r0, r4
 8013538:	f00b fef7 	bl	801f32a <crs_strlen>
 801353c:	b283      	uxth	r3, r0
 801353e:	4622      	mov	r2, r4
 8013540:	2104      	movs	r1, #4
 8013542:	2002      	movs	r0, #2
 8013544:	f00b ff56 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for CPSMS */
  /* for READ COMMAND only  */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8013548:	8b3b      	ldrh	r3, [r7, #24]
 801354a:	2b02      	cmp	r3, #2
 801354c:	d002      	beq.n	8013554 <fRspAnalyze_CPSMS+0x64>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 801354e:	2010      	movs	r0, #16
 8013550:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    START_PARAM_LOOP()
 8013554:	2400      	movs	r4, #0
 8013556:	4632      	mov	r2, r6
 8013558:	4641      	mov	r1, r8
 801355a:	4638      	mov	r0, r7
 801355c:	f7f8 ff74 	bl	800c448 <atcc_extractElement>
 8013560:	2801      	cmp	r0, #1
 8013562:	d000      	beq.n	8013566 <fRspAnalyze_CPSMS+0x76>
 8013564:	2401      	movs	r4, #1
 8013566:	89f3      	ldrh	r3, [r6, #14]
 8013568:	b913      	cbnz	r3, 8013570 <fRspAnalyze_CPSMS+0x80>
    END_PARAM_LOOP()
 801356a:	2c00      	cmp	r4, #0
 801356c:	d1ef      	bne.n	801354e <fRspAnalyze_CPSMS+0x5e>
 801356e:	e7f2      	b.n	8013556 <fRspAnalyze_CPSMS+0x66>
    PRINT_DBG("+CPSMS param_rank = %d", element_infos->param_rank)
 8013570:	4d5e      	ldr	r5, [pc, #376]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 8013572:	8932      	ldrh	r2, [r6, #8]
 8013574:	495e      	ldr	r1, [pc, #376]	; (80136f0 <fRspAnalyze_CPSMS+0x200>)
 8013576:	4628      	mov	r0, r5
 8013578:	f013 f966 	bl	8026848 <sprintf>
 801357c:	4628      	mov	r0, r5
 801357e:	f00b fed4 	bl	801f32a <crs_strlen>
 8013582:	b283      	uxth	r3, r0
 8013584:	462a      	mov	r2, r5
 8013586:	2102      	movs	r1, #2
 8013588:	4608      	mov	r0, r1
 801358a:	f00b ff11 	bl	801f3b0 <traceIF_itmPrint>
 801358e:	4628      	mov	r0, r5
 8013590:	f00b fecb 	bl	801f32a <crs_strlen>
 8013594:	b283      	uxth	r3, r0
 8013596:	462a      	mov	r2, r5
 8013598:	2102      	movs	r1, #2
 801359a:	4608      	mov	r0, r1
 801359c:	f00b ff2a 	bl	801f3f4 <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 80135a0:	8933      	ldrh	r3, [r6, #8]
 80135a2:	2b02      	cmp	r3, #2
 80135a4:	d006      	beq.n	80135b4 <fRspAnalyze_CPSMS+0xc4>
    else if (element_infos->param_rank == 3U)
 80135a6:	3b03      	subs	r3, #3
 80135a8:	2b03      	cmp	r3, #3
 80135aa:	d8de      	bhi.n	801356a <fRspAnalyze_CPSMS+0x7a>
 80135ac:	e8df f003 	tbb	[pc, r3]
 80135b0:	7c5d3e1f 	.word	0x7c5d3e1f
      PRINT_INFO("+CPSMS: mode= %ld",
 80135b4:	8970      	ldrh	r0, [r6, #10]
 80135b6:	89f1      	ldrh	r1, [r6, #14]
 80135b8:	4440      	add	r0, r8
 80135ba:	f001 fbbb 	bl	8014d34 <ATutil_convertStringToInt>
 80135be:	4602      	mov	r2, r0
 80135c0:	494c      	ldr	r1, [pc, #304]	; (80136f4 <fRspAnalyze_CPSMS+0x204>)
 80135c2:	4628      	mov	r0, r5
 80135c4:	f013 f940 	bl	8026848 <sprintf>
 80135c8:	4628      	mov	r0, r5
 80135ca:	f00b feae 	bl	801f32a <crs_strlen>
 80135ce:	b283      	uxth	r3, r0
 80135d0:	462a      	mov	r2, r5
 80135d2:	2101      	movs	r1, #1
 80135d4:	2002      	movs	r0, #2
 80135d6:	f00b feeb 	bl	801f3b0 <traceIF_itmPrint>
 80135da:	4628      	mov	r0, r5
 80135dc:	f00b fea5 	bl	801f32a <crs_strlen>
 80135e0:	b283      	uxth	r3, r0
 80135e2:	462a      	mov	r2, r5
 80135e4:	2101      	movs	r1, #1
 80135e6:	2002      	movs	r0, #2
 80135e8:	f00b ff04 	bl	801f3f4 <traceIF_uartPrint>
 80135ec:	e7bd      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_periodic_rau= 0x%lx",
 80135ee:	8970      	ldrh	r0, [r6, #10]
 80135f0:	2208      	movs	r2, #8
 80135f2:	89f1      	ldrh	r1, [r6, #14]
 80135f4:	4440      	add	r0, r8
 80135f6:	f7fb fb0c 	bl	800ec12 <extract_bin_value_from_quotes>
 80135fa:	4602      	mov	r2, r0
 80135fc:	4d3b      	ldr	r5, [pc, #236]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 80135fe:	493e      	ldr	r1, [pc, #248]	; (80136f8 <fRspAnalyze_CPSMS+0x208>)
 8013600:	4628      	mov	r0, r5
 8013602:	f013 f921 	bl	8026848 <sprintf>
 8013606:	4628      	mov	r0, r5
 8013608:	f00b fe8f 	bl	801f32a <crs_strlen>
 801360c:	b283      	uxth	r3, r0
 801360e:	462a      	mov	r2, r5
 8013610:	2101      	movs	r1, #1
 8013612:	2002      	movs	r0, #2
 8013614:	f00b fecc 	bl	801f3b0 <traceIF_itmPrint>
 8013618:	4628      	mov	r0, r5
 801361a:	f00b fe86 	bl	801f32a <crs_strlen>
 801361e:	b283      	uxth	r3, r0
 8013620:	462a      	mov	r2, r5
 8013622:	2101      	movs	r1, #1
 8013624:	2002      	movs	r0, #2
 8013626:	f00b fee5 	bl	801f3f4 <traceIF_uartPrint>
 801362a:	e79e      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_gprs_ready_timer= 0x%lx",
 801362c:	8970      	ldrh	r0, [r6, #10]
 801362e:	2208      	movs	r2, #8
 8013630:	89f1      	ldrh	r1, [r6, #14]
 8013632:	4440      	add	r0, r8
 8013634:	f7fb faed 	bl	800ec12 <extract_bin_value_from_quotes>
 8013638:	4602      	mov	r2, r0
 801363a:	4d2c      	ldr	r5, [pc, #176]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 801363c:	492f      	ldr	r1, [pc, #188]	; (80136fc <fRspAnalyze_CPSMS+0x20c>)
 801363e:	4628      	mov	r0, r5
 8013640:	f013 f902 	bl	8026848 <sprintf>
 8013644:	4628      	mov	r0, r5
 8013646:	f00b fe70 	bl	801f32a <crs_strlen>
 801364a:	b283      	uxth	r3, r0
 801364c:	462a      	mov	r2, r5
 801364e:	2101      	movs	r1, #1
 8013650:	2002      	movs	r0, #2
 8013652:	f00b fead 	bl	801f3b0 <traceIF_itmPrint>
 8013656:	4628      	mov	r0, r5
 8013658:	f00b fe67 	bl	801f32a <crs_strlen>
 801365c:	b283      	uxth	r3, r0
 801365e:	462a      	mov	r2, r5
 8013660:	2101      	movs	r1, #1
 8013662:	2002      	movs	r0, #2
 8013664:	f00b fec6 	bl	801f3f4 <traceIF_uartPrint>
 8013668:	e77f      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_periodic_tau= 0x%lx",
 801366a:	8970      	ldrh	r0, [r6, #10]
 801366c:	2208      	movs	r2, #8
 801366e:	89f1      	ldrh	r1, [r6, #14]
 8013670:	4440      	add	r0, r8
 8013672:	f7fb face 	bl	800ec12 <extract_bin_value_from_quotes>
 8013676:	4602      	mov	r2, r0
 8013678:	4d1c      	ldr	r5, [pc, #112]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 801367a:	4921      	ldr	r1, [pc, #132]	; (8013700 <fRspAnalyze_CPSMS+0x210>)
 801367c:	4628      	mov	r0, r5
 801367e:	f013 f8e3 	bl	8026848 <sprintf>
 8013682:	4628      	mov	r0, r5
 8013684:	f00b fe51 	bl	801f32a <crs_strlen>
 8013688:	b283      	uxth	r3, r0
 801368a:	462a      	mov	r2, r5
 801368c:	2101      	movs	r1, #1
 801368e:	2002      	movs	r0, #2
 8013690:	f00b fe8e 	bl	801f3b0 <traceIF_itmPrint>
 8013694:	4628      	mov	r0, r5
 8013696:	f00b fe48 	bl	801f32a <crs_strlen>
 801369a:	b283      	uxth	r3, r0
 801369c:	462a      	mov	r2, r5
 801369e:	2101      	movs	r1, #1
 80136a0:	2002      	movs	r0, #2
 80136a2:	f00b fea7 	bl	801f3f4 <traceIF_uartPrint>
 80136a6:	e760      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
      PRINT_INFO("+CPSMS: req_active_time= 0x%lx",
 80136a8:	8970      	ldrh	r0, [r6, #10]
 80136aa:	2208      	movs	r2, #8
 80136ac:	89f1      	ldrh	r1, [r6, #14]
 80136ae:	4440      	add	r0, r8
 80136b0:	f7fb faaf 	bl	800ec12 <extract_bin_value_from_quotes>
 80136b4:	4602      	mov	r2, r0
 80136b6:	4d0d      	ldr	r5, [pc, #52]	; (80136ec <fRspAnalyze_CPSMS+0x1fc>)
 80136b8:	4912      	ldr	r1, [pc, #72]	; (8013704 <fRspAnalyze_CPSMS+0x214>)
 80136ba:	4628      	mov	r0, r5
 80136bc:	f013 f8c4 	bl	8026848 <sprintf>
 80136c0:	4628      	mov	r0, r5
 80136c2:	f00b fe32 	bl	801f32a <crs_strlen>
 80136c6:	b283      	uxth	r3, r0
 80136c8:	462a      	mov	r2, r5
 80136ca:	2101      	movs	r1, #1
 80136cc:	2002      	movs	r0, #2
 80136ce:	f00b fe6f 	bl	801f3b0 <traceIF_itmPrint>
 80136d2:	4628      	mov	r0, r5
 80136d4:	f00b fe29 	bl	801f32a <crs_strlen>
 80136d8:	b283      	uxth	r3, r0
 80136da:	462a      	mov	r2, r5
 80136dc:	2101      	movs	r1, #1
 80136de:	2002      	movs	r0, #2
 80136e0:	f00b fe88 	bl	801f3f4 <traceIF_uartPrint>
 80136e4:	e741      	b.n	801356a <fRspAnalyze_CPSMS+0x7a>
 80136e6:	bf00      	nop
 80136e8:	08030e10 	.word	0x08030e10
 80136ec:	200048dc 	.word	0x200048dc
 80136f0:	08030e3c 	.word	0x08030e3c
 80136f4:	08030e60 	.word	0x08030e60
 80136f8:	08030e80 	.word	0x08030e80
 80136fc:	08030eac 	.word	0x08030eac
 8013700:	08030edc 	.word	0x08030edc
 8013704:	08030f08 	.word	0x08030f08

08013708 <fRspAnalyze_CEDRXS>:

at_action_rsp_t fRspAnalyze_CEDRXS(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013708:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801370c:	4606      	mov	r6, r0
 801370e:	4690      	mov	r8, r2
 8013710:	461f      	mov	r7, r3
  UNUSED(p_modem_ctxt);
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEDRXS()")
 8013712:	4c4b      	ldr	r4, [pc, #300]	; (8013840 <fRspAnalyze_CEDRXS+0x138>)
 8013714:	4d4b      	ldr	r5, [pc, #300]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 8013716:	f104 0e20 	add.w	lr, r4, #32
 801371a:	46a4      	mov	ip, r4
 801371c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013720:	6028      	str	r0, [r5, #0]
 8013722:	6069      	str	r1, [r5, #4]
 8013724:	60aa      	str	r2, [r5, #8]
 8013726:	60eb      	str	r3, [r5, #12]
 8013728:	4664      	mov	r4, ip
 801372a:	3510      	adds	r5, #16
 801372c:	45f4      	cmp	ip, lr
 801372e:	d1f4      	bne.n	801371a <fRspAnalyze_CEDRXS+0x12>
 8013730:	cc03      	ldmia	r4!, {r0, r1}
 8013732:	6028      	str	r0, [r5, #0]
 8013734:	6069      	str	r1, [r5, #4]
 8013736:	8823      	ldrh	r3, [r4, #0]
 8013738:	812b      	strh	r3, [r5, #8]
 801373a:	4c42      	ldr	r4, [pc, #264]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 801373c:	4620      	mov	r0, r4
 801373e:	f00b fdf4 	bl	801f32a <crs_strlen>
 8013742:	b283      	uxth	r3, r0
 8013744:	4622      	mov	r2, r4
 8013746:	2104      	movs	r1, #4
 8013748:	2002      	movs	r0, #2
 801374a:	f00b fe31 	bl	801f3b0 <traceIF_itmPrint>
 801374e:	4620      	mov	r0, r4
 8013750:	f00b fdeb 	bl	801f32a <crs_strlen>
 8013754:	b283      	uxth	r3, r0
 8013756:	4622      	mov	r2, r4
 8013758:	2104      	movs	r1, #4
 801375a:	2002      	movs	r0, #2
 801375c:	f00b fe4a 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for CEDRXS */
  if (p_atp_ctxt->current_atcmd.id == (CMD_ID_t) CMD_AT_CEDRXS)
 8013760:	69f3      	ldr	r3, [r6, #28]
 8013762:	2b23      	cmp	r3, #35	; 0x23
 8013764:	d002      	beq.n	801376c <fRspAnalyze_CEDRXS+0x64>
      END_PARAM_LOOP()
    }
  }

  return (retval);
}
 8013766:	2010      	movs	r0, #16
 8013768:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 801376c:	8b33      	ldrh	r3, [r6, #24]
 801376e:	2b02      	cmp	r3, #2
 8013770:	d1f9      	bne.n	8013766 <fRspAnalyze_CEDRXS+0x5e>
      START_PARAM_LOOP()
 8013772:	2400      	movs	r4, #0
 8013774:	463a      	mov	r2, r7
 8013776:	4641      	mov	r1, r8
 8013778:	4630      	mov	r0, r6
 801377a:	f7f8 fe65 	bl	800c448 <atcc_extractElement>
 801377e:	2801      	cmp	r0, #1
 8013780:	d000      	beq.n	8013784 <fRspAnalyze_CEDRXS+0x7c>
 8013782:	2401      	movs	r4, #1
 8013784:	89fb      	ldrh	r3, [r7, #14]
 8013786:	b913      	cbnz	r3, 801378e <fRspAnalyze_CEDRXS+0x86>
      END_PARAM_LOOP()
 8013788:	2c00      	cmp	r4, #0
 801378a:	d1ec      	bne.n	8013766 <fRspAnalyze_CEDRXS+0x5e>
 801378c:	e7f2      	b.n	8013774 <fRspAnalyze_CEDRXS+0x6c>
      PRINT_DBG("+CEDRXS param_rank = %d", element_infos->param_rank)
 801378e:	4d2d      	ldr	r5, [pc, #180]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 8013790:	893a      	ldrh	r2, [r7, #8]
 8013792:	492d      	ldr	r1, [pc, #180]	; (8013848 <fRspAnalyze_CEDRXS+0x140>)
 8013794:	4628      	mov	r0, r5
 8013796:	f013 f857 	bl	8026848 <sprintf>
 801379a:	4628      	mov	r0, r5
 801379c:	f00b fdc5 	bl	801f32a <crs_strlen>
 80137a0:	b283      	uxth	r3, r0
 80137a2:	462a      	mov	r2, r5
 80137a4:	2102      	movs	r1, #2
 80137a6:	4608      	mov	r0, r1
 80137a8:	f00b fe02 	bl	801f3b0 <traceIF_itmPrint>
 80137ac:	4628      	mov	r0, r5
 80137ae:	f00b fdbc 	bl	801f32a <crs_strlen>
 80137b2:	b283      	uxth	r3, r0
 80137b4:	462a      	mov	r2, r5
 80137b6:	2102      	movs	r1, #2
 80137b8:	4608      	mov	r0, r1
 80137ba:	f00b fe1b 	bl	801f3f4 <traceIF_uartPrint>
      if (element_infos->param_rank == 2U)
 80137be:	893b      	ldrh	r3, [r7, #8]
 80137c0:	2b02      	cmp	r3, #2
 80137c2:	d020      	beq.n	8013806 <fRspAnalyze_CEDRXS+0xfe>
      else if (element_infos->param_rank == 3U)
 80137c4:	2b03      	cmp	r3, #3
 80137c6:	d1df      	bne.n	8013788 <fRspAnalyze_CEDRXS+0x80>
        PRINT_INFO("+CEDRXS: req_edrx_value= 0x%lx",
 80137c8:	8978      	ldrh	r0, [r7, #10]
 80137ca:	2204      	movs	r2, #4
 80137cc:	89f9      	ldrh	r1, [r7, #14]
 80137ce:	4440      	add	r0, r8
 80137d0:	f7fb fa1f 	bl	800ec12 <extract_bin_value_from_quotes>
 80137d4:	4602      	mov	r2, r0
 80137d6:	4d1b      	ldr	r5, [pc, #108]	; (8013844 <fRspAnalyze_CEDRXS+0x13c>)
 80137d8:	491c      	ldr	r1, [pc, #112]	; (801384c <fRspAnalyze_CEDRXS+0x144>)
 80137da:	4628      	mov	r0, r5
 80137dc:	f013 f834 	bl	8026848 <sprintf>
 80137e0:	4628      	mov	r0, r5
 80137e2:	f00b fda2 	bl	801f32a <crs_strlen>
 80137e6:	b283      	uxth	r3, r0
 80137e8:	462a      	mov	r2, r5
 80137ea:	2101      	movs	r1, #1
 80137ec:	2002      	movs	r0, #2
 80137ee:	f00b fddf 	bl	801f3b0 <traceIF_itmPrint>
 80137f2:	4628      	mov	r0, r5
 80137f4:	f00b fd99 	bl	801f32a <crs_strlen>
 80137f8:	b283      	uxth	r3, r0
 80137fa:	462a      	mov	r2, r5
 80137fc:	2101      	movs	r1, #1
 80137fe:	2002      	movs	r0, #2
 8013800:	f00b fdf8 	bl	801f3f4 <traceIF_uartPrint>
 8013804:	e7c0      	b.n	8013788 <fRspAnalyze_CEDRXS+0x80>
        PRINT_DBG("+CEDRXS: act_type= %ld",
 8013806:	8978      	ldrh	r0, [r7, #10]
 8013808:	89f9      	ldrh	r1, [r7, #14]
 801380a:	4440      	add	r0, r8
 801380c:	f001 fa92 	bl	8014d34 <ATutil_convertStringToInt>
 8013810:	4602      	mov	r2, r0
 8013812:	490f      	ldr	r1, [pc, #60]	; (8013850 <fRspAnalyze_CEDRXS+0x148>)
 8013814:	4628      	mov	r0, r5
 8013816:	f013 f817 	bl	8026848 <sprintf>
 801381a:	4628      	mov	r0, r5
 801381c:	f00b fd85 	bl	801f32a <crs_strlen>
 8013820:	b283      	uxth	r3, r0
 8013822:	462a      	mov	r2, r5
 8013824:	2102      	movs	r1, #2
 8013826:	4608      	mov	r0, r1
 8013828:	f00b fdc2 	bl	801f3b0 <traceIF_itmPrint>
 801382c:	4628      	mov	r0, r5
 801382e:	f00b fd7c 	bl	801f32a <crs_strlen>
 8013832:	b283      	uxth	r3, r0
 8013834:	462a      	mov	r2, r5
 8013836:	2102      	movs	r1, #2
 8013838:	4608      	mov	r0, r1
 801383a:	f00b fddb 	bl	801f3f4 <traceIF_uartPrint>
 801383e:	e7a3      	b.n	8013788 <fRspAnalyze_CEDRXS+0x80>
 8013840:	08030f34 	.word	0x08030f34
 8013844:	200048dc 	.word	0x200048dc
 8013848:	08030f60 	.word	0x08030f60
 801384c:	08030fa8 	.word	0x08030fa8
 8013850:	08030f84 	.word	0x08030f84

08013854 <fRspAnalyze_CEDRXP>:

at_action_rsp_t fRspAnalyze_CEDRXP(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                   const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013854:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013858:	4680      	mov	r8, r0
 801385a:	4617      	mov	r7, r2
 801385c:	461e      	mov	r6, r3
  UNUSED(p_modem_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEDRXP()")
 801385e:	4c69      	ldr	r4, [pc, #420]	; (8013a04 <fRspAnalyze_CEDRXP+0x1b0>)
 8013860:	4d69      	ldr	r5, [pc, #420]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 8013862:	f104 0e20 	add.w	lr, r4, #32
 8013866:	46a4      	mov	ip, r4
 8013868:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801386c:	6028      	str	r0, [r5, #0]
 801386e:	6069      	str	r1, [r5, #4]
 8013870:	60aa      	str	r2, [r5, #8]
 8013872:	60eb      	str	r3, [r5, #12]
 8013874:	4664      	mov	r4, ip
 8013876:	3510      	adds	r5, #16
 8013878:	45f4      	cmp	ip, lr
 801387a:	d1f4      	bne.n	8013866 <fRspAnalyze_CEDRXP+0x12>
 801387c:	cc03      	ldmia	r4!, {r0, r1}
 801387e:	6028      	str	r0, [r5, #0]
 8013880:	6069      	str	r1, [r5, #4]
 8013882:	8823      	ldrh	r3, [r4, #0]
 8013884:	812b      	strh	r3, [r5, #8]
 8013886:	4c60      	ldr	r4, [pc, #384]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 8013888:	4620      	mov	r0, r4
 801388a:	f00b fd4e 	bl	801f32a <crs_strlen>
 801388e:	b283      	uxth	r3, r0
 8013890:	4622      	mov	r2, r4
 8013892:	2104      	movs	r1, #4
 8013894:	2002      	movs	r0, #2
 8013896:	f00b fd8b 	bl	801f3b0 <traceIF_itmPrint>
 801389a:	4620      	mov	r0, r4
 801389c:	f00b fd45 	bl	801f32a <crs_strlen>
 80138a0:	b283      	uxth	r3, r0
 80138a2:	4622      	mov	r2, r4
 80138a4:	2104      	movs	r1, #4
 80138a6:	2002      	movs	r0, #2
 80138a8:	f00b fda4 	bl	801f3f4 <traceIF_uartPrint>
  /* 3GP TS27.007
  *  format: +CEDRXP: <AcT-type>[,<Requested_eDRX_value>[,<NW-provided_eDRX_value>[,<Paging_time_window>]]]
  *
  */

  START_PARAM_LOOP()
 80138ac:	2400      	movs	r4, #0
 80138ae:	4632      	mov	r2, r6
 80138b0:	4639      	mov	r1, r7
 80138b2:	4640      	mov	r0, r8
 80138b4:	f7f8 fdc8 	bl	800c448 <atcc_extractElement>
 80138b8:	2801      	cmp	r0, #1
 80138ba:	d000      	beq.n	80138be <fRspAnalyze_CEDRXP+0x6a>
 80138bc:	2401      	movs	r4, #1
 80138be:	89f3      	ldrh	r3, [r6, #14]
 80138c0:	b923      	cbnz	r3, 80138cc <fRspAnalyze_CEDRXP+0x78>
  }
  else
  {
    /* parameters ignored */
  }
  END_PARAM_LOOP()
 80138c2:	2c00      	cmp	r4, #0
 80138c4:	d0f3      	beq.n	80138ae <fRspAnalyze_CEDRXP+0x5a>


  return (retval);
}
 80138c6:	2010      	movs	r0, #16
 80138c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  PRINT_DBG("+CEDRXS param_rank = %d", element_infos->param_rank)
 80138cc:	4d4e      	ldr	r5, [pc, #312]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 80138ce:	8932      	ldrh	r2, [r6, #8]
 80138d0:	494e      	ldr	r1, [pc, #312]	; (8013a0c <fRspAnalyze_CEDRXP+0x1b8>)
 80138d2:	4628      	mov	r0, r5
 80138d4:	f012 ffb8 	bl	8026848 <sprintf>
 80138d8:	4628      	mov	r0, r5
 80138da:	f00b fd26 	bl	801f32a <crs_strlen>
 80138de:	b283      	uxth	r3, r0
 80138e0:	462a      	mov	r2, r5
 80138e2:	2102      	movs	r1, #2
 80138e4:	4608      	mov	r0, r1
 80138e6:	f00b fd63 	bl	801f3b0 <traceIF_itmPrint>
 80138ea:	4628      	mov	r0, r5
 80138ec:	f00b fd1d 	bl	801f32a <crs_strlen>
 80138f0:	b283      	uxth	r3, r0
 80138f2:	462a      	mov	r2, r5
 80138f4:	2102      	movs	r1, #2
 80138f6:	4608      	mov	r0, r1
 80138f8:	f00b fd7c 	bl	801f3f4 <traceIF_uartPrint>
  if (element_infos->param_rank == 2U)
 80138fc:	8933      	ldrh	r3, [r6, #8]
 80138fe:	2b02      	cmp	r3, #2
 8013900:	d024      	beq.n	801394c <fRspAnalyze_CEDRXP+0xf8>
  else if (element_infos->param_rank == 3U)
 8013902:	2b03      	cmp	r3, #3
 8013904:	d03f      	beq.n	8013986 <fRspAnalyze_CEDRXP+0x132>
  else if (element_infos->param_rank == 4U)
 8013906:	2b04      	cmp	r3, #4
 8013908:	d05c      	beq.n	80139c4 <fRspAnalyze_CEDRXP+0x170>
  else if (element_infos->param_rank == 5U)
 801390a:	2b05      	cmp	r3, #5
 801390c:	d1d9      	bne.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_INFO("+CEDRXP URC: paging_time_window= 0x%lx",
 801390e:	8970      	ldrh	r0, [r6, #10]
 8013910:	2204      	movs	r2, #4
 8013912:	89f1      	ldrh	r1, [r6, #14]
 8013914:	4438      	add	r0, r7
 8013916:	f7fb f97c 	bl	800ec12 <extract_bin_value_from_quotes>
 801391a:	4602      	mov	r2, r0
 801391c:	4d3a      	ldr	r5, [pc, #232]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 801391e:	493c      	ldr	r1, [pc, #240]	; (8013a10 <fRspAnalyze_CEDRXP+0x1bc>)
 8013920:	4628      	mov	r0, r5
 8013922:	f012 ff91 	bl	8026848 <sprintf>
 8013926:	4628      	mov	r0, r5
 8013928:	f00b fcff 	bl	801f32a <crs_strlen>
 801392c:	b283      	uxth	r3, r0
 801392e:	462a      	mov	r2, r5
 8013930:	2101      	movs	r1, #1
 8013932:	2002      	movs	r0, #2
 8013934:	f00b fd3c 	bl	801f3b0 <traceIF_itmPrint>
 8013938:	4628      	mov	r0, r5
 801393a:	f00b fcf6 	bl	801f32a <crs_strlen>
 801393e:	b283      	uxth	r3, r0
 8013940:	462a      	mov	r2, r5
 8013942:	2101      	movs	r1, #1
 8013944:	2002      	movs	r0, #2
 8013946:	f00b fd55 	bl	801f3f4 <traceIF_uartPrint>
 801394a:	e7ba      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_DBG("+CEDRXP URC: act_type= %ld",
 801394c:	8970      	ldrh	r0, [r6, #10]
 801394e:	89f1      	ldrh	r1, [r6, #14]
 8013950:	4438      	add	r0, r7
 8013952:	f001 f9ef 	bl	8014d34 <ATutil_convertStringToInt>
 8013956:	4602      	mov	r2, r0
 8013958:	492e      	ldr	r1, [pc, #184]	; (8013a14 <fRspAnalyze_CEDRXP+0x1c0>)
 801395a:	4628      	mov	r0, r5
 801395c:	f012 ff74 	bl	8026848 <sprintf>
 8013960:	4628      	mov	r0, r5
 8013962:	f00b fce2 	bl	801f32a <crs_strlen>
 8013966:	b283      	uxth	r3, r0
 8013968:	462a      	mov	r2, r5
 801396a:	2102      	movs	r1, #2
 801396c:	4608      	mov	r0, r1
 801396e:	f00b fd1f 	bl	801f3b0 <traceIF_itmPrint>
 8013972:	4628      	mov	r0, r5
 8013974:	f00b fcd9 	bl	801f32a <crs_strlen>
 8013978:	b283      	uxth	r3, r0
 801397a:	462a      	mov	r2, r5
 801397c:	2102      	movs	r1, #2
 801397e:	4608      	mov	r0, r1
 8013980:	f00b fd38 	bl	801f3f4 <traceIF_uartPrint>
 8013984:	e79d      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_INFO("+CEDRXP URC: req_edrx_value= 0x%lx",
 8013986:	8970      	ldrh	r0, [r6, #10]
 8013988:	2204      	movs	r2, #4
 801398a:	89f1      	ldrh	r1, [r6, #14]
 801398c:	4438      	add	r0, r7
 801398e:	f7fb f940 	bl	800ec12 <extract_bin_value_from_quotes>
 8013992:	4602      	mov	r2, r0
 8013994:	4d1c      	ldr	r5, [pc, #112]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 8013996:	4920      	ldr	r1, [pc, #128]	; (8013a18 <fRspAnalyze_CEDRXP+0x1c4>)
 8013998:	4628      	mov	r0, r5
 801399a:	f012 ff55 	bl	8026848 <sprintf>
 801399e:	4628      	mov	r0, r5
 80139a0:	f00b fcc3 	bl	801f32a <crs_strlen>
 80139a4:	b283      	uxth	r3, r0
 80139a6:	462a      	mov	r2, r5
 80139a8:	2101      	movs	r1, #1
 80139aa:	2002      	movs	r0, #2
 80139ac:	f00b fd00 	bl	801f3b0 <traceIF_itmPrint>
 80139b0:	4628      	mov	r0, r5
 80139b2:	f00b fcba 	bl	801f32a <crs_strlen>
 80139b6:	b283      	uxth	r3, r0
 80139b8:	462a      	mov	r2, r5
 80139ba:	2101      	movs	r1, #1
 80139bc:	2002      	movs	r0, #2
 80139be:	f00b fd19 	bl	801f3f4 <traceIF_uartPrint>
 80139c2:	e77e      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
    PRINT_INFO("+CEDRXP URC: nw_provided_edrx_value= 0x%lx",
 80139c4:	8970      	ldrh	r0, [r6, #10]
 80139c6:	2204      	movs	r2, #4
 80139c8:	89f1      	ldrh	r1, [r6, #14]
 80139ca:	4438      	add	r0, r7
 80139cc:	f7fb f921 	bl	800ec12 <extract_bin_value_from_quotes>
 80139d0:	4602      	mov	r2, r0
 80139d2:	4d0d      	ldr	r5, [pc, #52]	; (8013a08 <fRspAnalyze_CEDRXP+0x1b4>)
 80139d4:	4911      	ldr	r1, [pc, #68]	; (8013a1c <fRspAnalyze_CEDRXP+0x1c8>)
 80139d6:	4628      	mov	r0, r5
 80139d8:	f012 ff36 	bl	8026848 <sprintf>
 80139dc:	4628      	mov	r0, r5
 80139de:	f00b fca4 	bl	801f32a <crs_strlen>
 80139e2:	b283      	uxth	r3, r0
 80139e4:	462a      	mov	r2, r5
 80139e6:	2101      	movs	r1, #1
 80139e8:	2002      	movs	r0, #2
 80139ea:	f00b fce1 	bl	801f3b0 <traceIF_itmPrint>
 80139ee:	4628      	mov	r0, r5
 80139f0:	f00b fc9b 	bl	801f32a <crs_strlen>
 80139f4:	b283      	uxth	r3, r0
 80139f6:	462a      	mov	r2, r5
 80139f8:	2101      	movs	r1, #1
 80139fa:	2002      	movs	r0, #2
 80139fc:	f00b fcfa 	bl	801f3f4 <traceIF_uartPrint>
 8013a00:	e75f      	b.n	80138c2 <fRspAnalyze_CEDRXP+0x6e>
 8013a02:	bf00      	nop
 8013a04:	08030fd4 	.word	0x08030fd4
 8013a08:	200048dc 	.word	0x200048dc
 8013a0c:	08030f60 	.word	0x08030f60
 8013a10:	08031090 	.word	0x08031090
 8013a14:	08031000 	.word	0x08031000
 8013a18:	08031028 	.word	0x08031028
 8013a1c:	08031058 	.word	0x08031058

08013a20 <fRspAnalyze_CEDRXRDP>:

at_action_rsp_t fRspAnalyze_CEDRXRDP(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                     const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013a20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013a24:	4680      	mov	r8, r0
 8013a26:	4617      	mov	r7, r2
 8013a28:	461e      	mov	r6, r3
  UNUSED(p_modem_ctxt);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CEDRXRDP()")
 8013a2a:	4c68      	ldr	r4, [pc, #416]	; (8013bcc <fRspAnalyze_CEDRXRDP+0x1ac>)
 8013a2c:	4d68      	ldr	r5, [pc, #416]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013a2e:	f104 0e20 	add.w	lr, r4, #32
 8013a32:	46a4      	mov	ip, r4
 8013a34:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013a38:	6028      	str	r0, [r5, #0]
 8013a3a:	6069      	str	r1, [r5, #4]
 8013a3c:	60aa      	str	r2, [r5, #8]
 8013a3e:	60eb      	str	r3, [r5, #12]
 8013a40:	4664      	mov	r4, ip
 8013a42:	3510      	adds	r5, #16
 8013a44:	45f4      	cmp	ip, lr
 8013a46:	d1f4      	bne.n	8013a32 <fRspAnalyze_CEDRXRDP+0x12>
 8013a48:	cc07      	ldmia	r4!, {r0, r1, r2}
 8013a4a:	6028      	str	r0, [r5, #0]
 8013a4c:	6069      	str	r1, [r5, #4]
 8013a4e:	60aa      	str	r2, [r5, #8]
 8013a50:	4c5f      	ldr	r4, [pc, #380]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013a52:	4620      	mov	r0, r4
 8013a54:	f00b fc69 	bl	801f32a <crs_strlen>
 8013a58:	b283      	uxth	r3, r0
 8013a5a:	4622      	mov	r2, r4
 8013a5c:	2104      	movs	r1, #4
 8013a5e:	2002      	movs	r0, #2
 8013a60:	f00b fca6 	bl	801f3b0 <traceIF_itmPrint>
 8013a64:	4620      	mov	r0, r4
 8013a66:	f00b fc60 	bl	801f32a <crs_strlen>
 8013a6a:	b283      	uxth	r3, r0
 8013a6c:	4622      	mov	r2, r4
 8013a6e:	2104      	movs	r1, #4
 8013a70:	2002      	movs	r0, #2
 8013a72:	f00b fcbf 	bl	801f3f4 <traceIF_uartPrint>
  *
  *  format: +CEDRXRDP: <AcT-type>[,<Requested_eDRX_value>[,<NW-provided_eDRX_value>[,<Paging_time_window>]]]
  *
  */

  START_PARAM_LOOP()
 8013a76:	2400      	movs	r4, #0
 8013a78:	4632      	mov	r2, r6
 8013a7a:	4639      	mov	r1, r7
 8013a7c:	4640      	mov	r0, r8
 8013a7e:	f7f8 fce3 	bl	800c448 <atcc_extractElement>
 8013a82:	2801      	cmp	r0, #1
 8013a84:	d000      	beq.n	8013a88 <fRspAnalyze_CEDRXRDP+0x68>
 8013a86:	2401      	movs	r4, #1
 8013a88:	89f3      	ldrh	r3, [r6, #14]
 8013a8a:	b923      	cbnz	r3, 8013a96 <fRspAnalyze_CEDRXRDP+0x76>
  }
  else
  {
    /* parameters ignored */
  }
  END_PARAM_LOOP()
 8013a8c:	2c00      	cmp	r4, #0
 8013a8e:	d0f3      	beq.n	8013a78 <fRspAnalyze_CEDRXRDP+0x58>


  return (retval);
}
 8013a90:	2010      	movs	r0, #16
 8013a92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  PRINT_DBG("+CEDRXDP param_rank = %d", element_infos->param_rank)
 8013a96:	4d4e      	ldr	r5, [pc, #312]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013a98:	8932      	ldrh	r2, [r6, #8]
 8013a9a:	494e      	ldr	r1, [pc, #312]	; (8013bd4 <fRspAnalyze_CEDRXRDP+0x1b4>)
 8013a9c:	4628      	mov	r0, r5
 8013a9e:	f012 fed3 	bl	8026848 <sprintf>
 8013aa2:	4628      	mov	r0, r5
 8013aa4:	f00b fc41 	bl	801f32a <crs_strlen>
 8013aa8:	b283      	uxth	r3, r0
 8013aaa:	462a      	mov	r2, r5
 8013aac:	2102      	movs	r1, #2
 8013aae:	4608      	mov	r0, r1
 8013ab0:	f00b fc7e 	bl	801f3b0 <traceIF_itmPrint>
 8013ab4:	4628      	mov	r0, r5
 8013ab6:	f00b fc38 	bl	801f32a <crs_strlen>
 8013aba:	b283      	uxth	r3, r0
 8013abc:	462a      	mov	r2, r5
 8013abe:	2102      	movs	r1, #2
 8013ac0:	4608      	mov	r0, r1
 8013ac2:	f00b fc97 	bl	801f3f4 <traceIF_uartPrint>
  if (element_infos->param_rank == 2U)
 8013ac6:	8933      	ldrh	r3, [r6, #8]
 8013ac8:	2b02      	cmp	r3, #2
 8013aca:	d024      	beq.n	8013b16 <fRspAnalyze_CEDRXRDP+0xf6>
  else if (element_infos->param_rank == 3U)
 8013acc:	2b03      	cmp	r3, #3
 8013ace:	d03f      	beq.n	8013b50 <fRspAnalyze_CEDRXRDP+0x130>
  else if (element_infos->param_rank == 4U)
 8013ad0:	2b04      	cmp	r3, #4
 8013ad2:	d05c      	beq.n	8013b8e <fRspAnalyze_CEDRXRDP+0x16e>
  else if (element_infos->param_rank == 5U)
 8013ad4:	2b05      	cmp	r3, #5
 8013ad6:	d1d9      	bne.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_INFO("+CEDRXRDP: paging_time_window= 0x%lx",
 8013ad8:	8970      	ldrh	r0, [r6, #10]
 8013ada:	2204      	movs	r2, #4
 8013adc:	89f1      	ldrh	r1, [r6, #14]
 8013ade:	4438      	add	r0, r7
 8013ae0:	f7fb f897 	bl	800ec12 <extract_bin_value_from_quotes>
 8013ae4:	4602      	mov	r2, r0
 8013ae6:	4d3a      	ldr	r5, [pc, #232]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013ae8:	493b      	ldr	r1, [pc, #236]	; (8013bd8 <fRspAnalyze_CEDRXRDP+0x1b8>)
 8013aea:	4628      	mov	r0, r5
 8013aec:	f012 feac 	bl	8026848 <sprintf>
 8013af0:	4628      	mov	r0, r5
 8013af2:	f00b fc1a 	bl	801f32a <crs_strlen>
 8013af6:	b283      	uxth	r3, r0
 8013af8:	462a      	mov	r2, r5
 8013afa:	2101      	movs	r1, #1
 8013afc:	2002      	movs	r0, #2
 8013afe:	f00b fc57 	bl	801f3b0 <traceIF_itmPrint>
 8013b02:	4628      	mov	r0, r5
 8013b04:	f00b fc11 	bl	801f32a <crs_strlen>
 8013b08:	b283      	uxth	r3, r0
 8013b0a:	462a      	mov	r2, r5
 8013b0c:	2101      	movs	r1, #1
 8013b0e:	2002      	movs	r0, #2
 8013b10:	f00b fc70 	bl	801f3f4 <traceIF_uartPrint>
 8013b14:	e7ba      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_DBG("+CEDRXRDP: act_type= %ld",
 8013b16:	8970      	ldrh	r0, [r6, #10]
 8013b18:	89f1      	ldrh	r1, [r6, #14]
 8013b1a:	4438      	add	r0, r7
 8013b1c:	f001 f90a 	bl	8014d34 <ATutil_convertStringToInt>
 8013b20:	4602      	mov	r2, r0
 8013b22:	492e      	ldr	r1, [pc, #184]	; (8013bdc <fRspAnalyze_CEDRXRDP+0x1bc>)
 8013b24:	4628      	mov	r0, r5
 8013b26:	f012 fe8f 	bl	8026848 <sprintf>
 8013b2a:	4628      	mov	r0, r5
 8013b2c:	f00b fbfd 	bl	801f32a <crs_strlen>
 8013b30:	b283      	uxth	r3, r0
 8013b32:	462a      	mov	r2, r5
 8013b34:	2102      	movs	r1, #2
 8013b36:	4608      	mov	r0, r1
 8013b38:	f00b fc3a 	bl	801f3b0 <traceIF_itmPrint>
 8013b3c:	4628      	mov	r0, r5
 8013b3e:	f00b fbf4 	bl	801f32a <crs_strlen>
 8013b42:	b283      	uxth	r3, r0
 8013b44:	462a      	mov	r2, r5
 8013b46:	2102      	movs	r1, #2
 8013b48:	4608      	mov	r0, r1
 8013b4a:	f00b fc53 	bl	801f3f4 <traceIF_uartPrint>
 8013b4e:	e79d      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_INFO("+CEDRXRDP: req_edrx_value= 0x%lx",
 8013b50:	8970      	ldrh	r0, [r6, #10]
 8013b52:	2204      	movs	r2, #4
 8013b54:	89f1      	ldrh	r1, [r6, #14]
 8013b56:	4438      	add	r0, r7
 8013b58:	f7fb f85b 	bl	800ec12 <extract_bin_value_from_quotes>
 8013b5c:	4602      	mov	r2, r0
 8013b5e:	4d1c      	ldr	r5, [pc, #112]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013b60:	491f      	ldr	r1, [pc, #124]	; (8013be0 <fRspAnalyze_CEDRXRDP+0x1c0>)
 8013b62:	4628      	mov	r0, r5
 8013b64:	f012 fe70 	bl	8026848 <sprintf>
 8013b68:	4628      	mov	r0, r5
 8013b6a:	f00b fbde 	bl	801f32a <crs_strlen>
 8013b6e:	b283      	uxth	r3, r0
 8013b70:	462a      	mov	r2, r5
 8013b72:	2101      	movs	r1, #1
 8013b74:	2002      	movs	r0, #2
 8013b76:	f00b fc1b 	bl	801f3b0 <traceIF_itmPrint>
 8013b7a:	4628      	mov	r0, r5
 8013b7c:	f00b fbd5 	bl	801f32a <crs_strlen>
 8013b80:	b283      	uxth	r3, r0
 8013b82:	462a      	mov	r2, r5
 8013b84:	2101      	movs	r1, #1
 8013b86:	2002      	movs	r0, #2
 8013b88:	f00b fc34 	bl	801f3f4 <traceIF_uartPrint>
 8013b8c:	e77e      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
    PRINT_INFO("+CEDRXRDP: nw_provided_edrx_value= 0x%lx",
 8013b8e:	8970      	ldrh	r0, [r6, #10]
 8013b90:	2204      	movs	r2, #4
 8013b92:	89f1      	ldrh	r1, [r6, #14]
 8013b94:	4438      	add	r0, r7
 8013b96:	f7fb f83c 	bl	800ec12 <extract_bin_value_from_quotes>
 8013b9a:	4602      	mov	r2, r0
 8013b9c:	4d0c      	ldr	r5, [pc, #48]	; (8013bd0 <fRspAnalyze_CEDRXRDP+0x1b0>)
 8013b9e:	4911      	ldr	r1, [pc, #68]	; (8013be4 <fRspAnalyze_CEDRXRDP+0x1c4>)
 8013ba0:	4628      	mov	r0, r5
 8013ba2:	f012 fe51 	bl	8026848 <sprintf>
 8013ba6:	4628      	mov	r0, r5
 8013ba8:	f00b fbbf 	bl	801f32a <crs_strlen>
 8013bac:	b283      	uxth	r3, r0
 8013bae:	462a      	mov	r2, r5
 8013bb0:	2101      	movs	r1, #1
 8013bb2:	2002      	movs	r0, #2
 8013bb4:	f00b fbfc 	bl	801f3b0 <traceIF_itmPrint>
 8013bb8:	4628      	mov	r0, r5
 8013bba:	f00b fbb6 	bl	801f32a <crs_strlen>
 8013bbe:	b283      	uxth	r3, r0
 8013bc0:	462a      	mov	r2, r5
 8013bc2:	2101      	movs	r1, #1
 8013bc4:	2002      	movs	r0, #2
 8013bc6:	f00b fc15 	bl	801f3f4 <traceIF_uartPrint>
 8013bca:	e75f      	b.n	8013a8c <fRspAnalyze_CEDRXRDP+0x6c>
 8013bcc:	080310c4 	.word	0x080310c4
 8013bd0:	200048dc 	.word	0x200048dc
 8013bd4:	080310f0 	.word	0x080310f0
 8013bd8:	08031198 	.word	0x08031198
 8013bdc:	08031114 	.word	0x08031114
 8013be0:	08031138 	.word	0x08031138
 8013be4:	08031164 	.word	0x08031164

08013be8 <fRspAnalyze_CSIM>:

at_action_rsp_t fRspAnalyze_CSIM(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                 const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013be8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013bec:	4606      	mov	r6, r0
 8013bee:	4689      	mov	r9, r1
 8013bf0:	4690      	mov	r8, r2
 8013bf2:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_CSIM()")
 8013bf4:	4c42      	ldr	r4, [pc, #264]	; (8013d00 <fRspAnalyze_CSIM+0x118>)
 8013bf6:	4d43      	ldr	r5, [pc, #268]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013bf8:	f104 0e20 	add.w	lr, r4, #32
 8013bfc:	46a4      	mov	ip, r4
 8013bfe:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013c02:	6028      	str	r0, [r5, #0]
 8013c04:	6069      	str	r1, [r5, #4]
 8013c06:	60aa      	str	r2, [r5, #8]
 8013c08:	60eb      	str	r3, [r5, #12]
 8013c0a:	4664      	mov	r4, ip
 8013c0c:	3510      	adds	r5, #16
 8013c0e:	45f4      	cmp	ip, lr
 8013c10:	d1f4      	bne.n	8013bfc <fRspAnalyze_CSIM+0x14>
 8013c12:	cc03      	ldmia	r4!, {r0, r1}
 8013c14:	6028      	str	r0, [r5, #0]
 8013c16:	6069      	str	r1, [r5, #4]
 8013c18:	4c3a      	ldr	r4, [pc, #232]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013c1a:	4620      	mov	r0, r4
 8013c1c:	f00b fb85 	bl	801f32a <crs_strlen>
 8013c20:	b283      	uxth	r3, r0
 8013c22:	4622      	mov	r2, r4
 8013c24:	2104      	movs	r1, #4
 8013c26:	2002      	movs	r0, #2
 8013c28:	f00b fbc2 	bl	801f3b0 <traceIF_itmPrint>
 8013c2c:	4620      	mov	r0, r4
 8013c2e:	f00b fb7c 	bl	801f32a <crs_strlen>
 8013c32:	b283      	uxth	r3, r0
 8013c34:	4622      	mov	r2, r4
 8013c36:	2104      	movs	r1, #4
 8013c38:	2002      	movs	r0, #2
 8013c3a:	f00b fbdb 	bl	801f3f4 <traceIF_uartPrint>
  /* analyze parameters for +CSIM
   *  answer to CSIM write command
   *     +CSIM: <length>,<response>
   */

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_WRITE_CMD)
 8013c3e:	8b33      	ldrh	r3, [r6, #24]
 8013c40:	2b03      	cmp	r3, #3
 8013c42:	d005      	beq.n	8013c50 <fRspAnalyze_CSIM+0x68>
    }

    END_PARAM_LOOP()
  }

  if (p_atp_ctxt->current_atcmd.type == ATTYPE_TEST_CMD)
 8013c44:	8b33      	ldrh	r3, [r6, #24]
 8013c46:	2b01      	cmp	r3, #1
 8013c48:	d032      	beq.n	8013cb0 <fRspAnalyze_CSIM+0xc8>
  {
    PRINT_DBG("+CSIM for test cmd NOT IMPLEMENTED")
  }

  return (retval);
}
 8013c4a:	2010      	movs	r0, #16
 8013c4c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8013c50:	2400      	movs	r4, #0
 8013c52:	463a      	mov	r2, r7
 8013c54:	4641      	mov	r1, r8
 8013c56:	4630      	mov	r0, r6
 8013c58:	f7f8 fbf6 	bl	800c448 <atcc_extractElement>
 8013c5c:	2801      	cmp	r0, #1
 8013c5e:	d000      	beq.n	8013c62 <fRspAnalyze_CSIM+0x7a>
 8013c60:	2401      	movs	r4, #1
 8013c62:	89f9      	ldrh	r1, [r7, #14]
 8013c64:	b121      	cbz	r1, 8013c70 <fRspAnalyze_CSIM+0x88>
    if (element_infos->param_rank == 2U)
 8013c66:	893b      	ldrh	r3, [r7, #8]
 8013c68:	2b02      	cmp	r3, #2
 8013c6a:	d004      	beq.n	8013c76 <fRspAnalyze_CSIM+0x8e>
    else if (element_infos->param_rank == 3U)
 8013c6c:	2b03      	cmp	r3, #3
 8013c6e:	d009      	beq.n	8013c84 <fRspAnalyze_CSIM+0x9c>
    END_PARAM_LOOP()
 8013c70:	2c00      	cmp	r4, #0
 8013c72:	d1e7      	bne.n	8013c44 <fRspAnalyze_CSIM+0x5c>
 8013c74:	e7ed      	b.n	8013c52 <fRspAnalyze_CSIM+0x6a>
      uint32_t rsp_length = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013c76:	8978      	ldrh	r0, [r7, #10]
 8013c78:	4440      	add	r0, r8
 8013c7a:	f001 f85b 	bl	8014d34 <ATutil_convertStringToInt>
      p_modem_ctxt->SID_ctxt.sim_generic_access.bytes_received = rsp_length;
 8013c7e:	f8c9 066c 	str.w	r0, [r9, #1644]	; 0x66c
 8013c82:	e7f5      	b.n	8013c70 <fRspAnalyze_CSIM+0x88>
      length_to_copy = ATC_GET_MINIMUM_SIZE(p_modem_ctxt->SID_ctxt.sim_generic_access.bytes_received,
 8013c84:	f8d9 3668 	ldr.w	r3, [r9, #1640]	; 0x668
 8013c88:	68dd      	ldr	r5, [r3, #12]
 8013c8a:	3d01      	subs	r5, #1
 8013c8c:	f8d9 266c 	ldr.w	r2, [r9, #1644]	; 0x66c
 8013c90:	4295      	cmp	r5, r2
 8013c92:	bf28      	it	cs
 8013c94:	4615      	movcs	r5, r2
                   (const CS_CHAR_t *)&p_msg_in->buffer[element_infos->str_start_idx + 1U],  /* skip '"' */
 8013c96:	8979      	ldrh	r1, [r7, #10]
 8013c98:	3101      	adds	r1, #1
      (void)memcpy((CRC_CHAR_t *)p_modem_ctxt->SID_ctxt.sim_generic_access.data->p_rsp_str,
 8013c9a:	462a      	mov	r2, r5
 8013c9c:	4441      	add	r1, r8
 8013c9e:	6858      	ldr	r0, [r3, #4]
 8013ca0:	f012 ff22 	bl	8026ae8 <memcpy>
      p_end = (uint8_t *)&p_modem_ctxt->SID_ctxt.sim_generic_access.data->p_rsp_str[length_to_copy];
 8013ca4:	f8d9 3668 	ldr.w	r3, [r9, #1640]	; 0x668
 8013ca8:	685b      	ldr	r3, [r3, #4]
      *p_end = (uint8_t)'\0';
 8013caa:	2200      	movs	r2, #0
 8013cac:	555a      	strb	r2, [r3, r5]
 8013cae:	e7df      	b.n	8013c70 <fRspAnalyze_CSIM+0x88>
    PRINT_DBG("+CSIM for test cmd NOT IMPLEMENTED")
 8013cb0:	4d15      	ldr	r5, [pc, #84]	; (8013d08 <fRspAnalyze_CSIM+0x120>)
 8013cb2:	4c14      	ldr	r4, [pc, #80]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013cb4:	f105 0720 	add.w	r7, r5, #32
 8013cb8:	462e      	mov	r6, r5
 8013cba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8013cbc:	6020      	str	r0, [r4, #0]
 8013cbe:	6061      	str	r1, [r4, #4]
 8013cc0:	60a2      	str	r2, [r4, #8]
 8013cc2:	60e3      	str	r3, [r4, #12]
 8013cc4:	4635      	mov	r5, r6
 8013cc6:	3410      	adds	r4, #16
 8013cc8:	42be      	cmp	r6, r7
 8013cca:	d1f5      	bne.n	8013cb8 <fRspAnalyze_CSIM+0xd0>
 8013ccc:	cd07      	ldmia	r5!, {r0, r1, r2}
 8013cce:	6020      	str	r0, [r4, #0]
 8013cd0:	6061      	str	r1, [r4, #4]
 8013cd2:	60a2      	str	r2, [r4, #8]
 8013cd4:	882b      	ldrh	r3, [r5, #0]
 8013cd6:	81a3      	strh	r3, [r4, #12]
 8013cd8:	4c0a      	ldr	r4, [pc, #40]	; (8013d04 <fRspAnalyze_CSIM+0x11c>)
 8013cda:	4620      	mov	r0, r4
 8013cdc:	f00b fb25 	bl	801f32a <crs_strlen>
 8013ce0:	b283      	uxth	r3, r0
 8013ce2:	4622      	mov	r2, r4
 8013ce4:	2102      	movs	r1, #2
 8013ce6:	4608      	mov	r0, r1
 8013ce8:	f00b fb62 	bl	801f3b0 <traceIF_itmPrint>
 8013cec:	4620      	mov	r0, r4
 8013cee:	f00b fb1c 	bl	801f32a <crs_strlen>
 8013cf2:	b283      	uxth	r3, r0
 8013cf4:	4622      	mov	r2, r4
 8013cf6:	2102      	movs	r1, #2
 8013cf8:	4608      	mov	r0, r1
 8013cfa:	f00b fb7b 	bl	801f3f4 <traceIF_uartPrint>
 8013cfe:	e7a4      	b.n	8013c4a <fRspAnalyze_CSIM+0x62>
 8013d00:	080311c8 	.word	0x080311c8
 8013d04:	200048dc 	.word	0x200048dc
 8013d08:	080311f0 	.word	0x080311f0

08013d0c <fRspAnalyze_GSN>:
/* ==========================  Analyze V.25ter commands ========================== */
at_action_rsp_t fRspAnalyze_GSN(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013d0c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013d10:	4606      	mov	r6, r0
 8013d12:	4689      	mov	r9, r1
 8013d14:	4690      	mov	r8, r2
 8013d16:	461f      	mov	r7, r3
  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_GSN()")
 8013d18:	4d2d      	ldr	r5, [pc, #180]	; (8013dd0 <fRspAnalyze_GSN+0xc4>)
 8013d1a:	4c2e      	ldr	r4, [pc, #184]	; (8013dd4 <fRspAnalyze_GSN+0xc8>)
 8013d1c:	f105 0e20 	add.w	lr, r5, #32
 8013d20:	46ac      	mov	ip, r5
 8013d22:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013d26:	6020      	str	r0, [r4, #0]
 8013d28:	6061      	str	r1, [r4, #4]
 8013d2a:	60a2      	str	r2, [r4, #8]
 8013d2c:	60e3      	str	r3, [r4, #12]
 8013d2e:	4665      	mov	r5, ip
 8013d30:	3410      	adds	r4, #16
 8013d32:	45f4      	cmp	ip, lr
 8013d34:	d1f4      	bne.n	8013d20 <fRspAnalyze_GSN+0x14>
 8013d36:	f8dc 0000 	ldr.w	r0, [ip]
 8013d3a:	6020      	str	r0, [r4, #0]
 8013d3c:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8013d40:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013d44:	80a2      	strh	r2, [r4, #4]
 8013d46:	71a3      	strb	r3, [r4, #6]
 8013d48:	4c22      	ldr	r4, [pc, #136]	; (8013dd4 <fRspAnalyze_GSN+0xc8>)
 8013d4a:	4620      	mov	r0, r4
 8013d4c:	f00b faed 	bl	801f32a <crs_strlen>
 8013d50:	b283      	uxth	r3, r0
 8013d52:	4622      	mov	r2, r4
 8013d54:	2104      	movs	r1, #4
 8013d56:	2002      	movs	r0, #2
 8013d58:	f00b fb2a 	bl	801f3b0 <traceIF_itmPrint>
 8013d5c:	4620      	mov	r0, r4
 8013d5e:	f00b fae4 	bl	801f32a <crs_strlen>
 8013d62:	b283      	uxth	r3, r0
 8013d64:	4622      	mov	r2, r4
 8013d66:	2104      	movs	r1, #4
 8013d68:	2002      	movs	r0, #2
 8013d6a:	f00b fb43 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +GSN */
  /* only for execution command, set parameters */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_EXECUTION_CMD)
 8013d6e:	8b33      	ldrh	r3, [r6, #24]
 8013d70:	2b04      	cmp	r3, #4
 8013d72:	d002      	beq.n	8013d7a <fRspAnalyze_GSN+0x6e>
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
                  (size_t) element_infos->str_size);
  }

  return (retval);
}
 8013d74:	2010      	movs	r0, #16
 8013d76:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_DBG("IMEI:")
 8013d7a:	4d17      	ldr	r5, [pc, #92]	; (8013dd8 <fRspAnalyze_GSN+0xcc>)
 8013d7c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013d7e:	6020      	str	r0, [r4, #0]
 8013d80:	6061      	str	r1, [r4, #4]
 8013d82:	60a2      	str	r2, [r4, #8]
 8013d84:	60e3      	str	r3, [r4, #12]
 8013d86:	782b      	ldrb	r3, [r5, #0]
 8013d88:	7423      	strb	r3, [r4, #16]
 8013d8a:	4620      	mov	r0, r4
 8013d8c:	f00b facd 	bl	801f32a <crs_strlen>
 8013d90:	b283      	uxth	r3, r0
 8013d92:	4622      	mov	r2, r4
 8013d94:	2102      	movs	r1, #2
 8013d96:	4608      	mov	r0, r1
 8013d98:	f00b fb0a 	bl	801f3b0 <traceIF_itmPrint>
 8013d9c:	4620      	mov	r0, r4
 8013d9e:	f00b fac4 	bl	801f32a <crs_strlen>
 8013da2:	b283      	uxth	r3, r0
 8013da4:	4622      	mov	r2, r4
 8013da6:	2102      	movs	r1, #2
 8013da8:	4608      	mov	r0, r1
 8013daa:	f00b fb23 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_BUF((const uint8_t *)&p_msg_in->buffer[element_infos->str_start_idx], element_infos->str_size)
 8013dae:	897a      	ldrh	r2, [r7, #10]
 8013db0:	89fb      	ldrh	r3, [r7, #14]
 8013db2:	4442      	add	r2, r8
 8013db4:	2102      	movs	r1, #2
 8013db6:	4608      	mov	r0, r1
 8013db8:	f00b fde8 	bl	801f98c <traceIF_BufCharPrint>
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei),
 8013dbc:	f8d9 05c4 	ldr.w	r0, [r9, #1476]	; 0x5c4
                  (const void *)&p_msg_in->buffer[element_infos->str_start_idx],
 8013dc0:	8979      	ldrh	r1, [r7, #10]
    (void) memcpy((void *) & (p_modem_ctxt->SID_ctxt.device_info->u.imei),
 8013dc2:	89fa      	ldrh	r2, [r7, #14]
 8013dc4:	4441      	add	r1, r8
 8013dc6:	3002      	adds	r0, #2
 8013dc8:	f012 fe8e 	bl	8026ae8 <memcpy>
 8013dcc:	e7d2      	b.n	8013d74 <fRspAnalyze_GSN+0x68>
 8013dce:	bf00      	nop
 8013dd0:	08031220 	.word	0x08031220
 8013dd4:	200048dc 	.word	0x200048dc
 8013dd8:	0802fe6c 	.word	0x0802fe6c

08013ddc <fRspAnalyze_IPR>:

at_action_rsp_t fRspAnalyze_IPR(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013ddc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8013de0:	4606      	mov	r6, r0
 8013de2:	4690      	mov	r8, r2
 8013de4:	461f      	mov	r7, r3
  UNUSED(p_msg_in); /* for MISRA-2012 */
#endif /* USE_TRACE_ATCUSTOM_MODEM */

  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_IPR()")
 8013de6:	4d3f      	ldr	r5, [pc, #252]	; (8013ee4 <fRspAnalyze_IPR+0x108>)
 8013de8:	4c3f      	ldr	r4, [pc, #252]	; (8013ee8 <fRspAnalyze_IPR+0x10c>)
 8013dea:	f105 0e20 	add.w	lr, r5, #32
 8013dee:	46ac      	mov	ip, r5
 8013df0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013df4:	6020      	str	r0, [r4, #0]
 8013df6:	6061      	str	r1, [r4, #4]
 8013df8:	60a2      	str	r2, [r4, #8]
 8013dfa:	60e3      	str	r3, [r4, #12]
 8013dfc:	4665      	mov	r5, ip
 8013dfe:	3410      	adds	r4, #16
 8013e00:	45f4      	cmp	ip, lr
 8013e02:	d1f4      	bne.n	8013dee <fRspAnalyze_IPR+0x12>
 8013e04:	f8dc 0000 	ldr.w	r0, [ip]
 8013e08:	6020      	str	r0, [r4, #0]
 8013e0a:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8013e0e:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013e12:	80a2      	strh	r2, [r4, #4]
 8013e14:	71a3      	strb	r3, [r4, #6]
 8013e16:	4c34      	ldr	r4, [pc, #208]	; (8013ee8 <fRspAnalyze_IPR+0x10c>)
 8013e18:	4620      	mov	r0, r4
 8013e1a:	f00b fa86 	bl	801f32a <crs_strlen>
 8013e1e:	b283      	uxth	r3, r0
 8013e20:	4622      	mov	r2, r4
 8013e22:	2104      	movs	r1, #4
 8013e24:	2002      	movs	r0, #2
 8013e26:	f00b fac3 	bl	801f3b0 <traceIF_itmPrint>
 8013e2a:	4620      	mov	r0, r4
 8013e2c:	f00b fa7d 	bl	801f32a <crs_strlen>
 8013e30:	b283      	uxth	r3, r0
 8013e32:	4622      	mov	r2, r4
 8013e34:	2104      	movs	r1, #4
 8013e36:	2002      	movs	r0, #2
 8013e38:	f00b fadc 	bl	801f3f4 <traceIF_uartPrint>

  /* analyze parameters for +IPR */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8013e3c:	8b33      	ldrh	r3, [r6, #24]
 8013e3e:	2b02      	cmp	r3, #2
 8013e40:	d002      	beq.n	8013e48 <fRspAnalyze_IPR+0x6c>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8013e42:	2010      	movs	r0, #16
 8013e44:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    START_PARAM_LOOP()
 8013e48:	f04f 0900 	mov.w	r9, #0
 8013e4c:	463a      	mov	r2, r7
 8013e4e:	4641      	mov	r1, r8
 8013e50:	4630      	mov	r0, r6
 8013e52:	f7f8 faf9 	bl	800c448 <atcc_extractElement>
 8013e56:	2801      	cmp	r0, #1
 8013e58:	d001      	beq.n	8013e5e <fRspAnalyze_IPR+0x82>
 8013e5a:	f04f 0901 	mov.w	r9, #1
 8013e5e:	89fb      	ldrh	r3, [r7, #14]
 8013e60:	b91b      	cbnz	r3, 8013e6a <fRspAnalyze_IPR+0x8e>
    END_PARAM_LOOP()
 8013e62:	f1b9 0f00 	cmp.w	r9, #0
 8013e66:	d1ec      	bne.n	8013e42 <fRspAnalyze_IPR+0x66>
 8013e68:	e7f0      	b.n	8013e4c <fRspAnalyze_IPR+0x70>
    PRINT_DBG("BAUD RATE:")
 8013e6a:	4c1f      	ldr	r4, [pc, #124]	; (8013ee8 <fRspAnalyze_IPR+0x10c>)
 8013e6c:	4d1f      	ldr	r5, [pc, #124]	; (8013eec <fRspAnalyze_IPR+0x110>)
 8013e6e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8013e70:	6020      	str	r0, [r4, #0]
 8013e72:	6061      	str	r1, [r4, #4]
 8013e74:	60a2      	str	r2, [r4, #8]
 8013e76:	60e3      	str	r3, [r4, #12]
 8013e78:	6828      	ldr	r0, [r5, #0]
 8013e7a:	6120      	str	r0, [r4, #16]
 8013e7c:	88ab      	ldrh	r3, [r5, #4]
 8013e7e:	82a3      	strh	r3, [r4, #20]
 8013e80:	4620      	mov	r0, r4
 8013e82:	f00b fa52 	bl	801f32a <crs_strlen>
 8013e86:	b283      	uxth	r3, r0
 8013e88:	4622      	mov	r2, r4
 8013e8a:	2102      	movs	r1, #2
 8013e8c:	4608      	mov	r0, r1
 8013e8e:	f00b fa8f 	bl	801f3b0 <traceIF_itmPrint>
 8013e92:	4620      	mov	r0, r4
 8013e94:	f00b fa49 	bl	801f32a <crs_strlen>
 8013e98:	b283      	uxth	r3, r0
 8013e9a:	4622      	mov	r2, r4
 8013e9c:	2102      	movs	r1, #2
 8013e9e:	4608      	mov	r0, r1
 8013ea0:	f00b faa8 	bl	801f3f4 <traceIF_uartPrint>
    if (element_infos->param_rank == 2U)
 8013ea4:	893b      	ldrh	r3, [r7, #8]
 8013ea6:	2b02      	cmp	r3, #2
 8013ea8:	d1db      	bne.n	8013e62 <fRspAnalyze_IPR+0x86>
      PRINT_INFO("+IPR baud rate=%ld",
 8013eaa:	8978      	ldrh	r0, [r7, #10]
 8013eac:	89f9      	ldrh	r1, [r7, #14]
 8013eae:	4440      	add	r0, r8
 8013eb0:	f000 ff40 	bl	8014d34 <ATutil_convertStringToInt>
 8013eb4:	4602      	mov	r2, r0
 8013eb6:	490e      	ldr	r1, [pc, #56]	; (8013ef0 <fRspAnalyze_IPR+0x114>)
 8013eb8:	4620      	mov	r0, r4
 8013eba:	f012 fcc5 	bl	8026848 <sprintf>
 8013ebe:	4620      	mov	r0, r4
 8013ec0:	f00b fa33 	bl	801f32a <crs_strlen>
 8013ec4:	b283      	uxth	r3, r0
 8013ec6:	4622      	mov	r2, r4
 8013ec8:	2101      	movs	r1, #1
 8013eca:	2002      	movs	r0, #2
 8013ecc:	f00b fa70 	bl	801f3b0 <traceIF_itmPrint>
 8013ed0:	4620      	mov	r0, r4
 8013ed2:	f00b fa2a 	bl	801f32a <crs_strlen>
 8013ed6:	b283      	uxth	r3, r0
 8013ed8:	4622      	mov	r2, r4
 8013eda:	2101      	movs	r1, #1
 8013edc:	2002      	movs	r0, #2
 8013ede:	f00b fa89 	bl	801f3f4 <traceIF_uartPrint>
 8013ee2:	e7be      	b.n	8013e62 <fRspAnalyze_IPR+0x86>
 8013ee4:	08031248 	.word	0x08031248
 8013ee8:	200048dc 	.word	0x200048dc
 8013eec:	08031270 	.word	0x08031270
 8013ef0:	08031288 	.word	0x08031288

08013ef4 <fRspAnalyze_IFC>:

at_action_rsp_t fRspAnalyze_IFC(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8013ef4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8013ef8:	4680      	mov	r8, r0
 8013efa:	460e      	mov	r6, r1
 8013efc:	4691      	mov	r9, r2
 8013efe:	461f      	mov	r7, r3
  UNUSED(p_msg_in); /* for MISRA-2012 */
#endif /* USE_TRACE_ATCUSTOM_MODEM */

  atparser_context_t *p_atp_ctxt = &(p_at_ctxt->parser);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_IFC()")
 8013f00:	4d50      	ldr	r5, [pc, #320]	; (8014044 <fRspAnalyze_IFC+0x150>)
 8013f02:	4c51      	ldr	r4, [pc, #324]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013f04:	f105 0e20 	add.w	lr, r5, #32
 8013f08:	46ac      	mov	ip, r5
 8013f0a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8013f0e:	6020      	str	r0, [r4, #0]
 8013f10:	6061      	str	r1, [r4, #4]
 8013f12:	60a2      	str	r2, [r4, #8]
 8013f14:	60e3      	str	r3, [r4, #12]
 8013f16:	4665      	mov	r5, ip
 8013f18:	3410      	adds	r4, #16
 8013f1a:	45f4      	cmp	ip, lr
 8013f1c:	d1f4      	bne.n	8013f08 <fRspAnalyze_IFC+0x14>
 8013f1e:	f8dc 0000 	ldr.w	r0, [ip]
 8013f22:	6020      	str	r0, [r4, #0]
 8013f24:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8013f28:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8013f2c:	80a2      	strh	r2, [r4, #4]
 8013f2e:	71a3      	strb	r3, [r4, #6]
 8013f30:	4c45      	ldr	r4, [pc, #276]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013f32:	4620      	mov	r0, r4
 8013f34:	f00b f9f9 	bl	801f32a <crs_strlen>
 8013f38:	b283      	uxth	r3, r0
 8013f3a:	4622      	mov	r2, r4
 8013f3c:	2104      	movs	r1, #4
 8013f3e:	2002      	movs	r0, #2
 8013f40:	f00b fa36 	bl	801f3b0 <traceIF_itmPrint>
 8013f44:	4620      	mov	r0, r4
 8013f46:	f00b f9f0 	bl	801f32a <crs_strlen>
 8013f4a:	b283      	uxth	r3, r0
 8013f4c:	4622      	mov	r2, r4
 8013f4e:	2104      	movs	r1, #4
 8013f50:	2002      	movs	r0, #2
 8013f52:	f00b fa4f 	bl	801f3f4 <traceIF_uartPrint>

  /* initialize RTS and CTS with invalid values */
  p_modem_ctxt->persist.flowCtrl_RTS = 0xFF;
 8013f56:	23ff      	movs	r3, #255	; 0xff
 8013f58:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
  p_modem_ctxt->persist.flowCtrl_CTS = 0xFF;
 8013f5c:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515

  /* analyze parameters for +IFC */
  if (p_atp_ctxt->current_atcmd.type == ATTYPE_READ_CMD)
 8013f60:	f8b8 3018 	ldrh.w	r3, [r8, #24]
 8013f64:	2b02      	cmp	r3, #2
 8013f66:	d002      	beq.n	8013f6e <fRspAnalyze_IFC+0x7a>
    }
    END_PARAM_LOOP()
  }

  return (retval);
}
 8013f68:	2010      	movs	r0, #16
 8013f6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    START_PARAM_LOOP()
 8013f6e:	2400      	movs	r4, #0
 8013f70:	463a      	mov	r2, r7
 8013f72:	4649      	mov	r1, r9
 8013f74:	4640      	mov	r0, r8
 8013f76:	f7f8 fa67 	bl	800c448 <atcc_extractElement>
 8013f7a:	2801      	cmp	r0, #1
 8013f7c:	d000      	beq.n	8013f80 <fRspAnalyze_IFC+0x8c>
 8013f7e:	2401      	movs	r4, #1
 8013f80:	89f9      	ldrh	r1, [r7, #14]
 8013f82:	b129      	cbz	r1, 8013f90 <fRspAnalyze_IFC+0x9c>
    if (element_infos->param_rank == 2U)
 8013f84:	893b      	ldrh	r3, [r7, #8]
 8013f86:	2b02      	cmp	r3, #2
 8013f88:	d005      	beq.n	8013f96 <fRspAnalyze_IFC+0xa2>
    if (element_infos->param_rank == 3U)
 8013f8a:	893b      	ldrh	r3, [r7, #8]
 8013f8c:	2b03      	cmp	r3, #3
 8013f8e:	d02d      	beq.n	8013fec <fRspAnalyze_IFC+0xf8>
    END_PARAM_LOOP()
 8013f90:	2c00      	cmp	r4, #0
 8013f92:	d1e9      	bne.n	8013f68 <fRspAnalyze_IFC+0x74>
 8013f94:	e7ec      	b.n	8013f70 <fRspAnalyze_IFC+0x7c>
      uint32_t rts_fc = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013f96:	8978      	ldrh	r0, [r7, #10]
 8013f98:	4448      	add	r0, r9
 8013f9a:	f000 fecb 	bl	8014d34 <ATutil_convertStringToInt>
 8013f9e:	4682      	mov	sl, r0
      PRINT_DBG("+IFC: RTS flow control=%ld", rts_fc)
 8013fa0:	4d29      	ldr	r5, [pc, #164]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013fa2:	4602      	mov	r2, r0
 8013fa4:	4929      	ldr	r1, [pc, #164]	; (801404c <fRspAnalyze_IFC+0x158>)
 8013fa6:	4628      	mov	r0, r5
 8013fa8:	f012 fc4e 	bl	8026848 <sprintf>
 8013fac:	4628      	mov	r0, r5
 8013fae:	f00b f9bc 	bl	801f32a <crs_strlen>
 8013fb2:	b283      	uxth	r3, r0
 8013fb4:	462a      	mov	r2, r5
 8013fb6:	2102      	movs	r1, #2
 8013fb8:	4608      	mov	r0, r1
 8013fba:	f00b f9f9 	bl	801f3b0 <traceIF_itmPrint>
 8013fbe:	4628      	mov	r0, r5
 8013fc0:	f00b f9b3 	bl	801f32a <crs_strlen>
 8013fc4:	b283      	uxth	r3, r0
 8013fc6:	462a      	mov	r2, r5
 8013fc8:	2102      	movs	r1, #2
 8013fca:	4608      	mov	r0, r1
 8013fcc:	f00b fa12 	bl	801f3f4 <traceIF_uartPrint>
      if (rts_fc == 2U)
 8013fd0:	f1ba 0f02 	cmp.w	sl, #2
 8013fd4:	d006      	beq.n	8013fe4 <fRspAnalyze_IFC+0xf0>
      else if (rts_fc == 0U)
 8013fd6:	f1ba 0f00 	cmp.w	sl, #0
 8013fda:	d1d6      	bne.n	8013f8a <fRspAnalyze_IFC+0x96>
        p_modem_ctxt->persist.flowCtrl_RTS = 0U;
 8013fdc:	2300      	movs	r3, #0
 8013fde:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
 8013fe2:	e7d2      	b.n	8013f8a <fRspAnalyze_IFC+0x96>
        p_modem_ctxt->persist.flowCtrl_RTS = 2U;
 8013fe4:	2302      	movs	r3, #2
 8013fe6:	f886 3514 	strb.w	r3, [r6, #1300]	; 0x514
 8013fea:	e7ce      	b.n	8013f8a <fRspAnalyze_IFC+0x96>
      uint32_t cts_fc = ATutil_convertStringToInt(&p_msg_in->buffer[element_infos->str_start_idx],
 8013fec:	8978      	ldrh	r0, [r7, #10]
 8013fee:	89f9      	ldrh	r1, [r7, #14]
 8013ff0:	4448      	add	r0, r9
 8013ff2:	f000 fe9f 	bl	8014d34 <ATutil_convertStringToInt>
 8013ff6:	4682      	mov	sl, r0
      PRINT_DBG("+IFC: CTS flow control=%ld", cts_fc)
 8013ff8:	4d13      	ldr	r5, [pc, #76]	; (8014048 <fRspAnalyze_IFC+0x154>)
 8013ffa:	4602      	mov	r2, r0
 8013ffc:	4914      	ldr	r1, [pc, #80]	; (8014050 <fRspAnalyze_IFC+0x15c>)
 8013ffe:	4628      	mov	r0, r5
 8014000:	f012 fc22 	bl	8026848 <sprintf>
 8014004:	4628      	mov	r0, r5
 8014006:	f00b f990 	bl	801f32a <crs_strlen>
 801400a:	b283      	uxth	r3, r0
 801400c:	462a      	mov	r2, r5
 801400e:	2102      	movs	r1, #2
 8014010:	4608      	mov	r0, r1
 8014012:	f00b f9cd 	bl	801f3b0 <traceIF_itmPrint>
 8014016:	4628      	mov	r0, r5
 8014018:	f00b f987 	bl	801f32a <crs_strlen>
 801401c:	b283      	uxth	r3, r0
 801401e:	462a      	mov	r2, r5
 8014020:	2102      	movs	r1, #2
 8014022:	4608      	mov	r0, r1
 8014024:	f00b f9e6 	bl	801f3f4 <traceIF_uartPrint>
      if (cts_fc == 2U)
 8014028:	f1ba 0f02 	cmp.w	sl, #2
 801402c:	d006      	beq.n	801403c <fRspAnalyze_IFC+0x148>
      else if (cts_fc == 0U)
 801402e:	f1ba 0f00 	cmp.w	sl, #0
 8014032:	d1ad      	bne.n	8013f90 <fRspAnalyze_IFC+0x9c>
        p_modem_ctxt->persist.flowCtrl_CTS = 0U;
 8014034:	2300      	movs	r3, #0
 8014036:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 801403a:	e7a9      	b.n	8013f90 <fRspAnalyze_IFC+0x9c>
        p_modem_ctxt->persist.flowCtrl_CTS = 2U;
 801403c:	2302      	movs	r3, #2
 801403e:	f886 3515 	strb.w	r3, [r6, #1301]	; 0x515
 8014042:	e7a5      	b.n	8013f90 <fRspAnalyze_IFC+0x9c>
 8014044:	080312a8 	.word	0x080312a8
 8014048:	200048dc 	.word	0x200048dc
 801404c:	080312d0 	.word	0x080312d0
 8014050:	080312f8 	.word	0x080312f8

08014054 <fRspAnalyze_DIRECT_CMD>:

at_action_rsp_t fRspAnalyze_DIRECT_CMD(at_context_t *p_at_ctxt, atcustom_modem_context_t *p_modem_ctxt,
                                       const IPC_RxMessage_t *p_msg_in, at_element_info_t *element_infos)
{
 8014054:	b538      	push	{r3, r4, r5, lr}
  UNUSED(p_at_ctxt);
  UNUSED(p_modem_ctxt);
  UNUSED(p_msg_in);
  UNUSED(element_infos);
  at_action_rsp_t retval = ATACTION_RSP_IGNORED;
  PRINT_API("enter fRspAnalyze_DIRECT_CMD()")
 8014056:	4c15      	ldr	r4, [pc, #84]	; (80140ac <fRspAnalyze_DIRECT_CMD+0x58>)
 8014058:	4d15      	ldr	r5, [pc, #84]	; (80140b0 <fRspAnalyze_DIRECT_CMD+0x5c>)
 801405a:	f104 0e20 	add.w	lr, r4, #32
 801405e:	46a4      	mov	ip, r4
 8014060:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014064:	6028      	str	r0, [r5, #0]
 8014066:	6069      	str	r1, [r5, #4]
 8014068:	60aa      	str	r2, [r5, #8]
 801406a:	60eb      	str	r3, [r5, #12]
 801406c:	4664      	mov	r4, ip
 801406e:	3510      	adds	r5, #16
 8014070:	45f4      	cmp	ip, lr
 8014072:	d1f4      	bne.n	801405e <fRspAnalyze_DIRECT_CMD+0xa>
 8014074:	cc07      	ldmia	r4!, {r0, r1, r2}
 8014076:	6028      	str	r0, [r5, #0]
 8014078:	6069      	str	r1, [r5, #4]
 801407a:	60aa      	str	r2, [r5, #8]
 801407c:	8823      	ldrh	r3, [r4, #0]
 801407e:	81ab      	strh	r3, [r5, #12]
 8014080:	4c0b      	ldr	r4, [pc, #44]	; (80140b0 <fRspAnalyze_DIRECT_CMD+0x5c>)
 8014082:	4620      	mov	r0, r4
 8014084:	f00b f951 	bl	801f32a <crs_strlen>
 8014088:	b283      	uxth	r3, r0
 801408a:	4622      	mov	r2, r4
 801408c:	2104      	movs	r1, #4
 801408e:	2002      	movs	r0, #2
 8014090:	f00b f98e 	bl	801f3b0 <traceIF_itmPrint>
 8014094:	4620      	mov	r0, r4
 8014096:	f00b f948 	bl	801f32a <crs_strlen>
 801409a:	b283      	uxth	r3, r0
 801409c:	4622      	mov	r2, r4
 801409e:	2104      	movs	r1, #4
 80140a0:	2002      	movs	r0, #2
 80140a2:	f00b f9a7 	bl	801f3f4 <traceIF_uartPrint>

  /* NOT IMPLEMENTED YET */

  return (retval);
}
 80140a6:	2010      	movs	r0, #16
 80140a8:	bd38      	pop	{r3, r4, r5, pc}
 80140aa:	bf00      	nop
 80140ac:	08031320 	.word	0x08031320
 80140b0:	200048dc 	.word	0x200048dc

080140b4 <atcm_socket_release_modem_cid>:
/**
  * @brief  This function release a modem connection Id (ID shared between at-custom and the modem)
  *         to a socket handle (ID shared between upper layers and at-custom)
  */
at_status_t atcm_socket_release_modem_cid(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 80140b4:	b570      	push	{r4, r5, r6, lr}
 80140b6:	b082      	sub	sp, #8
 80140b8:	460c      	mov	r4, r1
  at_status_t retval;

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 80140ba:	f1b1 3fff 	cmp.w	r1, #4294967295
 80140be:	d034      	beq.n	801412a <atcm_socket_release_modem_cid+0x76>
 80140c0:	4605      	mov	r5, r0
    PRINT_INFO("socket handle %ld not valid", sockHandle)
    retval = ATSTATUS_ERROR;
  }
  else
  {
    if ((p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc == AT_TRUE) ||
 80140c2:	f501 739e 	add.w	r3, r1, #316	; 0x13c
 80140c6:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 80140ca:	79db      	ldrb	r3, [r3, #7]
 80140cc:	b92b      	cbnz	r3, 80140da <atcm_socket_release_modem_cid+0x26>
        (p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc == AT_TRUE))
 80140ce:	f501 729e 	add.w	r2, r1, #316	; 0x13c
 80140d2:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 80140d6:	7a12      	ldrb	r2, [r2, #8]
    if ((p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc == AT_TRUE) ||
 80140d8:	b1ea      	cbz	r2, 8014116 <atcm_socket_release_modem_cid+0x62>
    {
      /* Trace only */
      PRINT_INFO("Warning, there was pending URC for socket handle %ld: (%d)data pending urc,(%d) closed by remote urc",
 80140da:	f504 729e 	add.w	r2, r4, #316	; 0x13c
 80140de:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 80140e2:	7a12      	ldrb	r2, [r2, #8]
 80140e4:	4e1e      	ldr	r6, [pc, #120]	; (8014160 <atcm_socket_release_modem_cid+0xac>)
 80140e6:	9200      	str	r2, [sp, #0]
 80140e8:	4622      	mov	r2, r4
 80140ea:	491e      	ldr	r1, [pc, #120]	; (8014164 <atcm_socket_release_modem_cid+0xb0>)
 80140ec:	4630      	mov	r0, r6
 80140ee:	f012 fbab 	bl	8026848 <sprintf>
 80140f2:	4630      	mov	r0, r6
 80140f4:	f00b f919 	bl	801f32a <crs_strlen>
 80140f8:	b283      	uxth	r3, r0
 80140fa:	4632      	mov	r2, r6
 80140fc:	2101      	movs	r1, #1
 80140fe:	2002      	movs	r0, #2
 8014100:	f00b f956 	bl	801f3b0 <traceIF_itmPrint>
 8014104:	4630      	mov	r0, r6
 8014106:	f00b f910 	bl	801f32a <crs_strlen>
 801410a:	b283      	uxth	r3, r0
 801410c:	4632      	mov	r2, r6
 801410e:	2101      	movs	r1, #1
 8014110:	2002      	movs	r0, #2
 8014112:	f00b f96f 	bl	801f3f4 <traceIF_uartPrint>
                 sockHandle,
                 p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc,
                 p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc)
    }

    p_modem_ctxt->persist.socket[sockHandle].socket_connected = AT_FALSE;
 8014116:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 801411a:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 801411e:	2000      	movs	r0, #0
 8014120:	71a8      	strb	r0, [r5, #6]
    p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc = AT_FALSE;
 8014122:	71e8      	strb	r0, [r5, #7]
    p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc = AT_FALSE;
 8014124:	7228      	strb	r0, [r5, #8]
    retval = ATSTATUS_OK;
  }

  return (retval);
}
 8014126:	b002      	add	sp, #8
 8014128:	bd70      	pop	{r4, r5, r6, pc}
    PRINT_INFO("socket handle %ld not valid", sockHandle)
 801412a:	4d0d      	ldr	r5, [pc, #52]	; (8014160 <atcm_socket_release_modem_cid+0xac>)
 801412c:	460a      	mov	r2, r1
 801412e:	490e      	ldr	r1, [pc, #56]	; (8014168 <atcm_socket_release_modem_cid+0xb4>)
 8014130:	4628      	mov	r0, r5
 8014132:	f012 fb89 	bl	8026848 <sprintf>
 8014136:	4628      	mov	r0, r5
 8014138:	f00b f8f7 	bl	801f32a <crs_strlen>
 801413c:	b283      	uxth	r3, r0
 801413e:	462a      	mov	r2, r5
 8014140:	2101      	movs	r1, #1
 8014142:	2002      	movs	r0, #2
 8014144:	f00b f934 	bl	801f3b0 <traceIF_itmPrint>
 8014148:	4628      	mov	r0, r5
 801414a:	f00b f8ee 	bl	801f32a <crs_strlen>
 801414e:	b283      	uxth	r3, r0
 8014150:	462a      	mov	r2, r5
 8014152:	2101      	movs	r1, #1
 8014154:	2002      	movs	r0, #2
 8014156:	f00b f94d 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 801415a:	2001      	movs	r0, #1
 801415c:	e7e3      	b.n	8014126 <atcm_socket_release_modem_cid+0x72>
 801415e:	bf00      	nop
 8014160:	200048dc 	.word	0x200048dc
 8014164:	080313b8 	.word	0x080313b8
 8014168:	08031390 	.word	0x08031390

0801416c <atcm_socket_get_modem_cid>:
  */
uint32_t atcm_socket_get_modem_cid(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
  uint32_t cid;

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 801416c:	f1b1 3fff 	cmp.w	r1, #4294967295
 8014170:	d005      	beq.n	801417e <atcm_socket_get_modem_cid+0x12>
    cid = 0U;
  }
  else
  {
    /* find  connectid corresponding to this socket_handle */
    cid = (uint32_t)(p_modem_ctxt->persist.socket[sockHandle].socket_connId_value);
 8014172:	f501 719e 	add.w	r1, r1, #316	; 0x13c
 8014176:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 801417a:	7940      	ldrb	r0, [r0, #5]
  }

  return (cid);
}
 801417c:	4770      	bx	lr
{
 801417e:	b510      	push	{r4, lr}
    PRINT_INFO("socket handle %ld not valid", sockHandle)
 8014180:	4c0c      	ldr	r4, [pc, #48]	; (80141b4 <atcm_socket_get_modem_cid+0x48>)
 8014182:	460a      	mov	r2, r1
 8014184:	490c      	ldr	r1, [pc, #48]	; (80141b8 <atcm_socket_get_modem_cid+0x4c>)
 8014186:	4620      	mov	r0, r4
 8014188:	f012 fb5e 	bl	8026848 <sprintf>
 801418c:	4620      	mov	r0, r4
 801418e:	f00b f8cc 	bl	801f32a <crs_strlen>
 8014192:	b283      	uxth	r3, r0
 8014194:	4622      	mov	r2, r4
 8014196:	2101      	movs	r1, #1
 8014198:	2002      	movs	r0, #2
 801419a:	f00b f909 	bl	801f3b0 <traceIF_itmPrint>
 801419e:	4620      	mov	r0, r4
 80141a0:	f00b f8c3 	bl	801f32a <crs_strlen>
 80141a4:	b283      	uxth	r3, r0
 80141a6:	4622      	mov	r2, r4
 80141a8:	2101      	movs	r1, #1
 80141aa:	2002      	movs	r0, #2
 80141ac:	f00b f922 	bl	801f3f4 <traceIF_uartPrint>
    cid = 0U;
 80141b0:	2000      	movs	r0, #0
}
 80141b2:	bd10      	pop	{r4, pc}
 80141b4:	200048dc 	.word	0x200048dc
 80141b8:	08031390 	.word	0x08031390

080141bc <atcm_socket_set_modem_cid>:
at_status_t atcm_socket_set_modem_cid(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle,
                                      uint32_t modemcid)
{
  at_status_t retval;

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 80141bc:	f1b1 3fff 	cmp.w	r1, #4294967295
 80141c0:	d006      	beq.n	80141d0 <atcm_socket_set_modem_cid+0x14>
    PRINT_INFO("socket handle %ld not valid", sockHandle)
    retval = ATSTATUS_ERROR;
  }
  else
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_connId_value = (uint8_t) modemcid;
 80141c2:	f501 719e 	add.w	r1, r1, #316	; 0x13c
 80141c6:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 80141ca:	7142      	strb	r2, [r0, #5]
    retval = ATSTATUS_OK;
 80141cc:	2000      	movs	r0, #0
  }

  return (retval);
}
 80141ce:	4770      	bx	lr
{
 80141d0:	b510      	push	{r4, lr}
    PRINT_INFO("socket handle %ld not valid", sockHandle)
 80141d2:	4c0d      	ldr	r4, [pc, #52]	; (8014208 <atcm_socket_set_modem_cid+0x4c>)
 80141d4:	460a      	mov	r2, r1
 80141d6:	490d      	ldr	r1, [pc, #52]	; (801420c <atcm_socket_set_modem_cid+0x50>)
 80141d8:	4620      	mov	r0, r4
 80141da:	f012 fb35 	bl	8026848 <sprintf>
 80141de:	4620      	mov	r0, r4
 80141e0:	f00b f8a3 	bl	801f32a <crs_strlen>
 80141e4:	b283      	uxth	r3, r0
 80141e6:	4622      	mov	r2, r4
 80141e8:	2101      	movs	r1, #1
 80141ea:	2002      	movs	r0, #2
 80141ec:	f00b f8e0 	bl	801f3b0 <traceIF_itmPrint>
 80141f0:	4620      	mov	r0, r4
 80141f2:	f00b f89a 	bl	801f32a <crs_strlen>
 80141f6:	b283      	uxth	r3, r0
 80141f8:	4622      	mov	r2, r4
 80141fa:	2101      	movs	r1, #1
 80141fc:	2002      	movs	r0, #2
 80141fe:	f00b f8f9 	bl	801f3f4 <traceIF_uartPrint>
    retval = ATSTATUS_ERROR;
 8014202:	2001      	movs	r0, #1
}
 8014204:	bd10      	pop	{r4, pc}
 8014206:	bf00      	nop
 8014208:	200048dc 	.word	0x200048dc
 801420c:	08031390 	.word	0x08031390

08014210 <atcm_socket_get_socket_handle>:
/**
  * @brief  This function returns the socket handle (ID shared between upper layers and at-custom)
  *         corresponding to modem connection Id (ID shared between at-custom and the modem)
  */
socket_handle_t atcm_socket_get_socket_handle(const atcustom_modem_context_t *p_modem_ctxt, uint32_t modemCID)
{
 8014210:	b538      	push	{r3, r4, r5, lr}
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8014212:	2300      	movs	r3, #0
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;
 8014214:	f04f 34ff 	mov.w	r4, #4294967295
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8014218:	e001      	b.n	801421e <atcm_socket_get_socket_handle+0xe>
 801421a:	3301      	adds	r3, #1
 801421c:	b2db      	uxtb	r3, r3
 801421e:	2b05      	cmp	r3, #5
 8014220:	d809      	bhi.n	8014236 <atcm_socket_get_socket_handle+0x26>
  {
    const atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
    if (p_tmp->socket_connId_value == modemCID)
 8014222:	f503 7c9e 	add.w	ip, r3, #316	; 0x13c
 8014226:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 801422a:	f89c c005 	ldrb.w	ip, [ip, #5]
 801422e:	458c      	cmp	ip, r1
 8014230:	d1f3      	bne.n	801421a <atcm_socket_get_socket_handle+0xa>
    {
      sockHandle = (socket_handle_t)i;
 8014232:	461c      	mov	r4, r3
 8014234:	e7f1      	b.n	801421a <atcm_socket_get_socket_handle+0xa>
    }
  }

  if (sockHandle == CS_INVALID_SOCKET_HANDLE)
 8014236:	f1b4 3fff 	cmp.w	r4, #4294967295
 801423a:	d001      	beq.n	8014240 <atcm_socket_get_socket_handle+0x30>
    /* Trace only */
    PRINT_INFO("Can not find valid socket handle for modem CID=%ld", modemCID)
  }

  return (sockHandle);
}
 801423c:	4620      	mov	r0, r4
 801423e:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_INFO("Can not find valid socket handle for modem CID=%ld", modemCID)
 8014240:	4d0c      	ldr	r5, [pc, #48]	; (8014274 <atcm_socket_get_socket_handle+0x64>)
 8014242:	460a      	mov	r2, r1
 8014244:	490c      	ldr	r1, [pc, #48]	; (8014278 <atcm_socket_get_socket_handle+0x68>)
 8014246:	4628      	mov	r0, r5
 8014248:	f012 fafe 	bl	8026848 <sprintf>
 801424c:	4628      	mov	r0, r5
 801424e:	f00b f86c 	bl	801f32a <crs_strlen>
 8014252:	b283      	uxth	r3, r0
 8014254:	462a      	mov	r2, r5
 8014256:	2101      	movs	r1, #1
 8014258:	2002      	movs	r0, #2
 801425a:	f00b f8a9 	bl	801f3b0 <traceIF_itmPrint>
 801425e:	4628      	mov	r0, r5
 8014260:	f00b f863 	bl	801f32a <crs_strlen>
 8014264:	b283      	uxth	r3, r0
 8014266:	462a      	mov	r2, r5
 8014268:	2101      	movs	r1, #1
 801426a:	2002      	movs	r0, #2
 801426c:	f00b f8c2 	bl	801f3f4 <traceIF_uartPrint>
  return (sockHandle);
 8014270:	e7e4      	b.n	801423c <atcm_socket_get_socket_handle+0x2c>
 8014272:	bf00      	nop
 8014274:	200048dc 	.word	0x200048dc
 8014278:	08031428 	.word	0x08031428

0801427c <atcm_socket_set_urc_data_pending>:
/**
  * @brief  This function set the "socket data received" URC for a
  *         socket handle (ID shared between upper layers and at-custom)
  */
at_status_t atcm_socket_set_urc_data_pending(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 801427c:	b570      	push	{r4, r5, r6, lr}
 801427e:	4606      	mov	r6, r0
 8014280:	460c      	mov	r4, r1
  at_status_t retval = ATSTATUS_OK;

  PRINT_API("enter atcm_socket_set_urc_data_pending sockHandle=%ld", sockHandle)
 8014282:	4d13      	ldr	r5, [pc, #76]	; (80142d0 <atcm_socket_set_urc_data_pending+0x54>)
 8014284:	460a      	mov	r2, r1
 8014286:	4913      	ldr	r1, [pc, #76]	; (80142d4 <atcm_socket_set_urc_data_pending+0x58>)
 8014288:	4628      	mov	r0, r5
 801428a:	f012 fadd 	bl	8026848 <sprintf>
 801428e:	4628      	mov	r0, r5
 8014290:	f00b f84b 	bl	801f32a <crs_strlen>
 8014294:	b283      	uxth	r3, r0
 8014296:	462a      	mov	r2, r5
 8014298:	2104      	movs	r1, #4
 801429a:	2002      	movs	r0, #2
 801429c:	f00b f888 	bl	801f3b0 <traceIF_itmPrint>
 80142a0:	4628      	mov	r0, r5
 80142a2:	f00b f842 	bl	801f32a <crs_strlen>
 80142a6:	b283      	uxth	r3, r0
 80142a8:	462a      	mov	r2, r5
 80142aa:	2104      	movs	r1, #4
 80142ac:	2002      	movs	r0, #2
 80142ae:	f00b f8a1 	bl	801f3f4 <traceIF_uartPrint>

  if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 80142b2:	f1b4 3fff 	cmp.w	r4, #4294967295
 80142b6:	d008      	beq.n	80142ca <atcm_socket_set_urc_data_pending+0x4e>
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_data_pending_urc = AT_TRUE;
 80142b8:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 80142bc:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 80142c0:	2301      	movs	r3, #1
 80142c2:	71e3      	strb	r3, [r4, #7]
    p_modem_ctxt->persist.urc_avail_socket_data_pending = AT_TRUE;
 80142c4:	77b3      	strb	r3, [r6, #30]
  at_status_t retval = ATSTATUS_OK;
 80142c6:	2000      	movs	r0, #0
  {
    retval = ATSTATUS_ERROR;
  }

  return (retval);
}
 80142c8:	bd70      	pop	{r4, r5, r6, pc}
    retval = ATSTATUS_ERROR;
 80142ca:	2001      	movs	r0, #1
 80142cc:	e7fc      	b.n	80142c8 <atcm_socket_set_urc_data_pending+0x4c>
 80142ce:	bf00      	nop
 80142d0:	200048dc 	.word	0x200048dc
 80142d4:	08031468 	.word	0x08031468

080142d8 <atcm_socket_set_urc_closed_by_remote>:
/**
  * @brief  This function set the "socket closed by remote" URC for a
  *         socket handle (ID shared between upper layers and at-custom)
  */
at_status_t atcm_socket_set_urc_closed_by_remote(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 80142d8:	b570      	push	{r4, r5, r6, lr}
 80142da:	4606      	mov	r6, r0
 80142dc:	460c      	mov	r4, r1
  at_status_t retval = ATSTATUS_OK;

  PRINT_API("enter atcm_socket_set_urc_closed_by_remote sockHandle=%ld", sockHandle)
 80142de:	4d13      	ldr	r5, [pc, #76]	; (801432c <atcm_socket_set_urc_closed_by_remote+0x54>)
 80142e0:	460a      	mov	r2, r1
 80142e2:	4913      	ldr	r1, [pc, #76]	; (8014330 <atcm_socket_set_urc_closed_by_remote+0x58>)
 80142e4:	4628      	mov	r0, r5
 80142e6:	f012 faaf 	bl	8026848 <sprintf>
 80142ea:	4628      	mov	r0, r5
 80142ec:	f00b f81d 	bl	801f32a <crs_strlen>
 80142f0:	b283      	uxth	r3, r0
 80142f2:	462a      	mov	r2, r5
 80142f4:	2104      	movs	r1, #4
 80142f6:	2002      	movs	r0, #2
 80142f8:	f00b f85a 	bl	801f3b0 <traceIF_itmPrint>
 80142fc:	4628      	mov	r0, r5
 80142fe:	f00b f814 	bl	801f32a <crs_strlen>
 8014302:	b283      	uxth	r3, r0
 8014304:	462a      	mov	r2, r5
 8014306:	2104      	movs	r1, #4
 8014308:	2002      	movs	r0, #2
 801430a:	f00b f873 	bl	801f3f4 <traceIF_uartPrint>

  if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 801430e:	f1b4 3fff 	cmp.w	r4, #4294967295
 8014312:	d008      	beq.n	8014326 <atcm_socket_set_urc_closed_by_remote+0x4e>
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_closed_pending_urc = AT_TRUE;
 8014314:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 8014318:	eb06 0484 	add.w	r4, r6, r4, lsl #2
 801431c:	2301      	movs	r3, #1
 801431e:	7223      	strb	r3, [r4, #8]
    p_modem_ctxt->persist.urc_avail_socket_closed_by_remote = AT_TRUE;
 8014320:	77f3      	strb	r3, [r6, #31]
  at_status_t retval = ATSTATUS_OK;
 8014322:	2000      	movs	r0, #0
  {
    retval = ATSTATUS_ERROR;
  }

  return (retval);
}
 8014324:	bd70      	pop	{r4, r5, r6, pc}
    retval = ATSTATUS_ERROR;
 8014326:	2001      	movs	r0, #1
 8014328:	e7fc      	b.n	8014324 <atcm_socket_set_urc_closed_by_remote+0x4c>
 801432a:	bf00      	nop
 801432c:	200048dc 	.word	0x200048dc
 8014330:	080314b0 	.word	0x080314b0

08014334 <atcm_socket_get_hdle_urc_data_pending>:
/**
  * @brief  This function returns the socket handle of "socket data received" URC
  *         and clears it
  */
socket_handle_t atcm_socket_get_hdle_urc_data_pending(atcustom_modem_context_t *p_modem_ctxt)
{
 8014334:	b570      	push	{r4, r5, r6, lr}
 8014336:	4606      	mov	r6, r0
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;

  PRINT_API("enter atcm_socket_get_hdle_urc_data_pending")
 8014338:	4d1f      	ldr	r5, [pc, #124]	; (80143b8 <atcm_socket_get_hdle_urc_data_pending+0x84>)
 801433a:	4c20      	ldr	r4, [pc, #128]	; (80143bc <atcm_socket_get_hdle_urc_data_pending+0x88>)
 801433c:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8014340:	46ac      	mov	ip, r5
 8014342:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014346:	6020      	str	r0, [r4, #0]
 8014348:	6061      	str	r1, [r4, #4]
 801434a:	60a2      	str	r2, [r4, #8]
 801434c:	60e3      	str	r3, [r4, #12]
 801434e:	4665      	mov	r5, ip
 8014350:	3410      	adds	r4, #16
 8014352:	45f4      	cmp	ip, lr
 8014354:	d1f4      	bne.n	8014340 <atcm_socket_get_hdle_urc_data_pending+0xc>
 8014356:	cd03      	ldmia	r5!, {r0, r1}
 8014358:	6020      	str	r0, [r4, #0]
 801435a:	6061      	str	r1, [r4, #4]
 801435c:	882a      	ldrh	r2, [r5, #0]
 801435e:	78ab      	ldrb	r3, [r5, #2]
 8014360:	8122      	strh	r2, [r4, #8]
 8014362:	72a3      	strb	r3, [r4, #10]
 8014364:	4c15      	ldr	r4, [pc, #84]	; (80143bc <atcm_socket_get_hdle_urc_data_pending+0x88>)
 8014366:	4620      	mov	r0, r4
 8014368:	f00a ffdf 	bl	801f32a <crs_strlen>
 801436c:	b283      	uxth	r3, r0
 801436e:	4622      	mov	r2, r4
 8014370:	2104      	movs	r1, #4
 8014372:	2002      	movs	r0, #2
 8014374:	f00b f81c 	bl	801f3b0 <traceIF_itmPrint>
 8014378:	4620      	mov	r0, r4
 801437a:	f00a ffd6 	bl	801f32a <crs_strlen>
 801437e:	b283      	uxth	r3, r0
 8014380:	4622      	mov	r2, r4
 8014382:	2104      	movs	r1, #4
 8014384:	2002      	movs	r0, #2
 8014386:	f00b f835 	bl	801f3f4 <traceIF_uartPrint>

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801438a:	2300      	movs	r3, #0
 801438c:	2b05      	cmp	r3, #5
 801438e:	d810      	bhi.n	80143b2 <atcm_socket_get_hdle_urc_data_pending+0x7e>
  {
    atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
 8014390:	4618      	mov	r0, r3
    if (p_tmp->socket_data_pending_urc == AT_TRUE)
 8014392:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8014396:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 801439a:	79d2      	ldrb	r2, [r2, #7]
 801439c:	b912      	cbnz	r2, 80143a4 <atcm_socket_get_hdle_urc_data_pending+0x70>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801439e:	3301      	adds	r3, #1
 80143a0:	b2db      	uxtb	r3, r3
 80143a2:	e7f3      	b.n	801438c <atcm_socket_get_hdle_urc_data_pending+0x58>
    {
      sockHandle = (socket_handle_t)i;
      /* clear this URC */
      p_tmp->socket_data_pending_urc = AT_FALSE;
 80143a4:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80143a8:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 80143ac:	2300      	movs	r3, #0
 80143ae:	71f3      	strb	r3, [r6, #7]
      break;
 80143b0:	e001      	b.n	80143b6 <atcm_socket_get_hdle_urc_data_pending+0x82>
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;
 80143b2:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (sockHandle);
}
 80143b6:	bd70      	pop	{r4, r5, r6, pc}
 80143b8:	080314fc 	.word	0x080314fc
 80143bc:	200048dc 	.word	0x200048dc

080143c0 <atcm_socket_get_hdlr_urc_closed_by_remote>:
/**
  * @brief  This function returns the socket handle of "socket closed by remote" URC
  *         and clears it
  */
socket_handle_t atcm_socket_get_hdlr_urc_closed_by_remote(atcustom_modem_context_t *p_modem_ctxt)
{
 80143c0:	b570      	push	{r4, r5, r6, lr}
 80143c2:	4606      	mov	r6, r0
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;

  PRINT_API("enter atcm_socket_get_hdlr_urc_closed_by_remote")
 80143c4:	4d20      	ldr	r5, [pc, #128]	; (8014448 <atcm_socket_get_hdlr_urc_closed_by_remote+0x88>)
 80143c6:	4c21      	ldr	r4, [pc, #132]	; (801444c <atcm_socket_get_hdlr_urc_closed_by_remote+0x8c>)
 80143c8:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80143cc:	46ac      	mov	ip, r5
 80143ce:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80143d2:	6020      	str	r0, [r4, #0]
 80143d4:	6061      	str	r1, [r4, #4]
 80143d6:	60a2      	str	r2, [r4, #8]
 80143d8:	60e3      	str	r3, [r4, #12]
 80143da:	4665      	mov	r5, ip
 80143dc:	3410      	adds	r4, #16
 80143de:	45f4      	cmp	ip, lr
 80143e0:	d1f4      	bne.n	80143cc <atcm_socket_get_hdlr_urc_closed_by_remote+0xc>
 80143e2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80143e4:	6020      	str	r0, [r4, #0]
 80143e6:	6061      	str	r1, [r4, #4]
 80143e8:	60a2      	str	r2, [r4, #8]
 80143ea:	882a      	ldrh	r2, [r5, #0]
 80143ec:	78ab      	ldrb	r3, [r5, #2]
 80143ee:	81a2      	strh	r2, [r4, #12]
 80143f0:	73a3      	strb	r3, [r4, #14]
 80143f2:	4c16      	ldr	r4, [pc, #88]	; (801444c <atcm_socket_get_hdlr_urc_closed_by_remote+0x8c>)
 80143f4:	4620      	mov	r0, r4
 80143f6:	f00a ff98 	bl	801f32a <crs_strlen>
 80143fa:	b283      	uxth	r3, r0
 80143fc:	4622      	mov	r2, r4
 80143fe:	2104      	movs	r1, #4
 8014400:	2002      	movs	r0, #2
 8014402:	f00a ffd5 	bl	801f3b0 <traceIF_itmPrint>
 8014406:	4620      	mov	r0, r4
 8014408:	f00a ff8f 	bl	801f32a <crs_strlen>
 801440c:	b283      	uxth	r3, r0
 801440e:	4622      	mov	r2, r4
 8014410:	2104      	movs	r1, #4
 8014412:	2002      	movs	r0, #2
 8014414:	f00a ffee 	bl	801f3f4 <traceIF_uartPrint>

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 8014418:	2300      	movs	r3, #0
 801441a:	2b05      	cmp	r3, #5
 801441c:	d810      	bhi.n	8014440 <atcm_socket_get_hdlr_urc_closed_by_remote+0x80>
  {
    atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
 801441e:	4618      	mov	r0, r3
    if (p_tmp->socket_closed_pending_urc == AT_TRUE)
 8014420:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8014424:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8014428:	7a12      	ldrb	r2, [r2, #8]
 801442a:	b912      	cbnz	r2, 8014432 <atcm_socket_get_hdlr_urc_closed_by_remote+0x72>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801442c:	3301      	adds	r3, #1
 801442e:	b2db      	uxtb	r3, r3
 8014430:	e7f3      	b.n	801441a <atcm_socket_get_hdlr_urc_closed_by_remote+0x5a>
    {
      sockHandle = (socket_handle_t)i;
      /* clear this URC */
      p_tmp->socket_closed_pending_urc = AT_FALSE;
 8014432:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8014436:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 801443a:	2300      	movs	r3, #0
 801443c:	7233      	strb	r3, [r6, #8]
      break;
 801443e:	e001      	b.n	8014444 <atcm_socket_get_hdlr_urc_closed_by_remote+0x84>
  socket_handle_t sockHandle = CS_INVALID_SOCKET_HANDLE;
 8014440:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (sockHandle);
}
 8014444:	bd70      	pop	{r4, r5, r6, pc}
 8014446:	bf00      	nop
 8014448:	08031538 	.word	0x08031538
 801444c:	200048dc 	.word	0x200048dc

08014450 <atcm_socket_remaining_urc_data_pending>:

/**
  * @brief  This function returns if there are pending "socket data received" URC
  */
at_bool_t atcm_socket_remaining_urc_data_pending(const atcustom_modem_context_t *p_modem_ctxt)
{
 8014450:	b570      	push	{r4, r5, r6, lr}
 8014452:	4606      	mov	r6, r0
  PRINT_API("enter atcm_socket_remaining_urc_data_pending")
 8014454:	4d19      	ldr	r5, [pc, #100]	; (80144bc <atcm_socket_remaining_urc_data_pending+0x6c>)
 8014456:	4c1a      	ldr	r4, [pc, #104]	; (80144c0 <atcm_socket_remaining_urc_data_pending+0x70>)
 8014458:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801445c:	46ac      	mov	ip, r5
 801445e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014462:	6020      	str	r0, [r4, #0]
 8014464:	6061      	str	r1, [r4, #4]
 8014466:	60a2      	str	r2, [r4, #8]
 8014468:	60e3      	str	r3, [r4, #12]
 801446a:	4665      	mov	r5, ip
 801446c:	3410      	adds	r4, #16
 801446e:	45f4      	cmp	ip, lr
 8014470:	d1f4      	bne.n	801445c <atcm_socket_remaining_urc_data_pending+0xc>
 8014472:	cd07      	ldmia	r5!, {r0, r1, r2}
 8014474:	6020      	str	r0, [r4, #0]
 8014476:	6061      	str	r1, [r4, #4]
 8014478:	60a2      	str	r2, [r4, #8]
 801447a:	4c11      	ldr	r4, [pc, #68]	; (80144c0 <atcm_socket_remaining_urc_data_pending+0x70>)
 801447c:	4620      	mov	r0, r4
 801447e:	f00a ff54 	bl	801f32a <crs_strlen>
 8014482:	b283      	uxth	r3, r0
 8014484:	4622      	mov	r2, r4
 8014486:	2104      	movs	r1, #4
 8014488:	2002      	movs	r0, #2
 801448a:	f00a ff91 	bl	801f3b0 <traceIF_itmPrint>
 801448e:	4620      	mov	r0, r4
 8014490:	f00a ff4b 	bl	801f32a <crs_strlen>
 8014494:	b283      	uxth	r3, r0
 8014496:	4622      	mov	r2, r4
 8014498:	2104      	movs	r1, #4
 801449a:	2002      	movs	r0, #2
 801449c:	f00a ffaa 	bl	801f3f4 <traceIF_uartPrint>
  at_bool_t remain = AT_FALSE;

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 80144a0:	2300      	movs	r3, #0
 80144a2:	2b05      	cmp	r3, #5
 80144a4:	d808      	bhi.n	80144b8 <atcm_socket_remaining_urc_data_pending+0x68>
  {
    const atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
    if (p_tmp->socket_data_pending_urc == AT_TRUE)
 80144a6:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 80144aa:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 80144ae:	79d0      	ldrb	r0, [r2, #7]
 80144b0:	b918      	cbnz	r0, 80144ba <atcm_socket_remaining_urc_data_pending+0x6a>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 80144b2:	3301      	adds	r3, #1
 80144b4:	b2db      	uxtb	r3, r3
 80144b6:	e7f4      	b.n	80144a2 <atcm_socket_remaining_urc_data_pending+0x52>
  at_bool_t remain = AT_FALSE;
 80144b8:	2000      	movs	r0, #0
      break;
    }
  }

  return (remain);
}
 80144ba:	bd70      	pop	{r4, r5, r6, pc}
 80144bc:	08031578 	.word	0x08031578
 80144c0:	200048dc 	.word	0x200048dc

080144c4 <atcm_socket_remaining_urc_closed_by_remote>:

/**
  * @brief  This function returns if there are pending "socket closed by remote" URC
  */
at_bool_t atcm_socket_remaining_urc_closed_by_remote(const atcustom_modem_context_t *p_modem_ctxt)
{
 80144c4:	b570      	push	{r4, r5, r6, lr}
 80144c6:	4606      	mov	r6, r0
  PRINT_API("enter atcm_socket_remaining_urc_closed_by_remote")
 80144c8:	4d17      	ldr	r5, [pc, #92]	; (8014528 <atcm_socket_remaining_urc_closed_by_remote+0x64>)
 80144ca:	4c18      	ldr	r4, [pc, #96]	; (801452c <atcm_socket_remaining_urc_closed_by_remote+0x68>)
 80144cc:	f105 0e40 	add.w	lr, r5, #64	; 0x40
 80144d0:	46ac      	mov	ip, r5
 80144d2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80144d6:	6020      	str	r0, [r4, #0]
 80144d8:	6061      	str	r1, [r4, #4]
 80144da:	60a2      	str	r2, [r4, #8]
 80144dc:	60e3      	str	r3, [r4, #12]
 80144de:	4665      	mov	r5, ip
 80144e0:	3410      	adds	r4, #16
 80144e2:	45f4      	cmp	ip, lr
 80144e4:	d1f4      	bne.n	80144d0 <atcm_socket_remaining_urc_closed_by_remote+0xc>
 80144e6:	4c11      	ldr	r4, [pc, #68]	; (801452c <atcm_socket_remaining_urc_closed_by_remote+0x68>)
 80144e8:	4620      	mov	r0, r4
 80144ea:	f00a ff1e 	bl	801f32a <crs_strlen>
 80144ee:	b283      	uxth	r3, r0
 80144f0:	4622      	mov	r2, r4
 80144f2:	2104      	movs	r1, #4
 80144f4:	2002      	movs	r0, #2
 80144f6:	f00a ff5b 	bl	801f3b0 <traceIF_itmPrint>
 80144fa:	4620      	mov	r0, r4
 80144fc:	f00a ff15 	bl	801f32a <crs_strlen>
 8014500:	b283      	uxth	r3, r0
 8014502:	4622      	mov	r2, r4
 8014504:	2104      	movs	r1, #4
 8014506:	2002      	movs	r0, #2
 8014508:	f00a ff74 	bl	801f3f4 <traceIF_uartPrint>

  at_bool_t remain = AT_FALSE;

  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801450c:	2300      	movs	r3, #0
 801450e:	2b05      	cmp	r3, #5
 8014510:	d808      	bhi.n	8014524 <atcm_socket_remaining_urc_closed_by_remote+0x60>
  {
    const atcustom_persistent_SOCKET_context_t *p_tmp;
    p_tmp = &p_modem_ctxt->persist.socket[i];
    if (p_tmp->socket_closed_pending_urc == AT_TRUE)
 8014512:	f503 729e 	add.w	r2, r3, #316	; 0x13c
 8014516:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 801451a:	7a10      	ldrb	r0, [r2, #8]
 801451c:	b918      	cbnz	r0, 8014526 <atcm_socket_remaining_urc_closed_by_remote+0x62>
  for (uint8_t i = 0U; i < CELLULAR_MAX_SOCKETS; i++)
 801451e:	3301      	adds	r3, #1
 8014520:	b2db      	uxtb	r3, r3
 8014522:	e7f4      	b.n	801450e <atcm_socket_remaining_urc_closed_by_remote+0x4a>
  at_bool_t remain = AT_FALSE;
 8014524:	2000      	movs	r0, #0
      break;
    }
  }

  return (remain);
}
 8014526:	bd70      	pop	{r4, r5, r6, pc}
 8014528:	080315b4 	.word	0x080315b4
 801452c:	200048dc 	.word	0x200048dc

08014530 <atcm_socket_set_connected>:

  return (retval);
}

at_status_t atcm_socket_set_connected(atcustom_modem_context_t *p_modem_ctxt, socket_handle_t sockHandle)
{
 8014530:	b570      	push	{r4, r5, r6, lr}
 8014532:	4606      	mov	r6, r0
 8014534:	460c      	mov	r4, r1
  at_status_t retval = ATSTATUS_OK;

  PRINT_API("enter atcm_socket_set_connected sockHandle=%ld", sockHandle)
 8014536:	4d11      	ldr	r5, [pc, #68]	; (801457c <atcm_socket_set_connected+0x4c>)
 8014538:	460a      	mov	r2, r1
 801453a:	4911      	ldr	r1, [pc, #68]	; (8014580 <atcm_socket_set_connected+0x50>)
 801453c:	4628      	mov	r0, r5
 801453e:	f012 f983 	bl	8026848 <sprintf>
 8014542:	4628      	mov	r0, r5
 8014544:	f00a fef1 	bl	801f32a <crs_strlen>
 8014548:	b283      	uxth	r3, r0
 801454a:	462a      	mov	r2, r5
 801454c:	2104      	movs	r1, #4
 801454e:	2002      	movs	r0, #2
 8014550:	f00a ff2e 	bl	801f3b0 <traceIF_itmPrint>
 8014554:	4628      	mov	r0, r5
 8014556:	f00a fee8 	bl	801f32a <crs_strlen>
 801455a:	b283      	uxth	r3, r0
 801455c:	462a      	mov	r2, r5
 801455e:	2104      	movs	r1, #4
 8014560:	2002      	movs	r0, #2
 8014562:	f00a ff47 	bl	801f3f4 <traceIF_uartPrint>

  if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 8014566:	f1b4 3fff 	cmp.w	r4, #4294967295
 801456a:	d005      	beq.n	8014578 <atcm_socket_set_connected+0x48>
  {
    p_modem_ctxt->persist.socket[sockHandle].socket_connected = AT_TRUE;
 801456c:	f504 749e 	add.w	r4, r4, #316	; 0x13c
 8014570:	eb06 0084 	add.w	r0, r6, r4, lsl #2
 8014574:	2301      	movs	r3, #1
 8014576:	7183      	strb	r3, [r0, #6]
  }

  return (retval);
}
 8014578:	2000      	movs	r0, #0
 801457a:	bd70      	pop	{r4, r5, r6, pc}
 801457c:	200048dc 	.word	0x200048dc
 8014580:	080315f4 	.word	0x080315f4

08014584 <reset_current_command>:

  p_atp_ctxt->p_cmd_input = NULL;
}

static void reset_current_command(atparser_context_t *p_atp_ctxt)
{
 8014584:	b538      	push	{r3, r4, r5, lr}
 8014586:	4604      	mov	r4, r0
  p_atp_ctxt->current_atcmd.id = CMD_AT_INVALID;
 8014588:	f04f 33ff 	mov.w	r3, #4294967295
 801458c:	60c3      	str	r3, [r0, #12]
  p_atp_ctxt->current_atcmd.type = ATTYPE_UNKNOWN_CMD;
 801458e:	2500      	movs	r5, #0
 8014590:	8105      	strh	r5, [r0, #8]
  (void) memset((void *)&p_atp_ctxt->current_atcmd.name[0], 0, sizeof(uint8_t) * (ATCMD_MAX_NAME_SIZE));
 8014592:	2220      	movs	r2, #32
 8014594:	4629      	mov	r1, r5
 8014596:	3010      	adds	r0, #16
 8014598:	f012 f9c9 	bl	802692e <memset>
  (void) memset((void *)&p_atp_ctxt->current_atcmd.params[0], 0, sizeof(uint8_t) * (ATCMD_MAX_CMD_SIZE));
 801459c:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 80145a0:	4629      	mov	r1, r5
 80145a2:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80145a6:	f012 f9c2 	bl	802692e <memset>
  p_atp_ctxt->current_atcmd.raw_cmd_size = 0U;
 80145aa:	f8c4 5670 	str.w	r5, [r4, #1648]	; 0x670
}
 80145ae:	bd38      	pop	{r3, r4, r5, pc}

080145b0 <reset_parser_context>:
{
 80145b0:	b538      	push	{r3, r4, r5, lr}
 80145b2:	4604      	mov	r4, r0
  p_atp_ctxt->current_SID = SID_INVALID;
 80145b4:	2500      	movs	r5, #0
 80145b6:	8005      	strh	r5, [r0, #0]
  p_atp_ctxt->step = 0U;
 80145b8:	7085      	strb	r5, [r0, #2]
  p_atp_ctxt->answer_expected = CMD_MANDATORY_ANSWER_EXPECTED;
 80145ba:	70c5      	strb	r5, [r0, #3]
  p_atp_ctxt->is_final_cmd = 1U;
 80145bc:	2301      	movs	r3, #1
 80145be:	7103      	strb	r3, [r0, #4]
  p_atp_ctxt->cmd_timeout = 0U;
 80145c0:	f8c0 5678 	str.w	r5, [r0, #1656]	; 0x678
  reset_current_command(p_atp_ctxt);
 80145c4:	f7ff ffde 	bl	8014584 <reset_current_command>
  p_atp_ctxt->p_cmd_input = NULL;
 80145c8:	f8c4 567c 	str.w	r5, [r4, #1660]	; 0x67c
}
 80145cc:	bd38      	pop	{r3, r4, r5, pc}

080145ce <write_data2buffer>:
  if ((str_size > 0U) && (str_size < *p_remaining_size))
 80145ce:	b1b2      	cbz	r2, 80145fe <write_data2buffer+0x30>
{
 80145d0:	b538      	push	{r3, r4, r5, lr}
 80145d2:	461c      	mov	r4, r3
 80145d4:	4615      	mov	r5, r2
  if ((str_size > 0U) && (str_size < *p_remaining_size))
 80145d6:	9b04      	ldr	r3, [sp, #16]
 80145d8:	881b      	ldrh	r3, [r3, #0]
 80145da:	4293      	cmp	r3, r2
 80145dc:	d801      	bhi.n	80145e2 <write_data2buffer+0x14>
    retval = false;
 80145de:	2000      	movs	r0, #0
}
 80145e0:	bd38      	pop	{r3, r4, r5, pc}
    (void) memcpy((void *) &p_ATcmdBuf[*p_cmd_total_length],
 80145e2:	8823      	ldrh	r3, [r4, #0]
 80145e4:	4418      	add	r0, r3
 80145e6:	f012 fa7f 	bl	8026ae8 <memcpy>
    *p_cmd_total_length += str_size;
 80145ea:	8823      	ldrh	r3, [r4, #0]
 80145ec:	442b      	add	r3, r5
 80145ee:	8023      	strh	r3, [r4, #0]
    *p_remaining_size -= str_size;
 80145f0:	9b04      	ldr	r3, [sp, #16]
 80145f2:	881b      	ldrh	r3, [r3, #0]
 80145f4:	1b5b      	subs	r3, r3, r5
 80145f6:	9a04      	ldr	r2, [sp, #16]
 80145f8:	8013      	strh	r3, [r2, #0]
    retval = true;
 80145fa:	2001      	movs	r0, #1
 80145fc:	e7f0      	b.n	80145e0 <write_data2buffer+0x12>
    retval = false;
 80145fe:	2000      	movs	r0, #0
}
 8014600:	4770      	bx	lr
	...

08014604 <build_command>:
{
 8014604:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014608:	b084      	sub	sp, #16
 801460a:	4604      	mov	r4, r0
 801460c:	460e      	mov	r6, r1
  at_type_t cmd_type = p_at_ctxt->parser.current_atcmd.type;
 801460e:	8b05      	ldrh	r5, [r0, #24]
      (cmd_type == ATTYPE_WRITE_CMD) ||
 8014610:	1e6b      	subs	r3, r5, #1
 8014612:	b29b      	uxth	r3, r3
  if ((cmd_type == ATTYPE_TEST_CMD) ||
 8014614:	2b03      	cmp	r3, #3
 8014616:	d931      	bls.n	801467c <build_command+0x78>
  else if (cmd_type == ATTYPE_RAW_CMD)
 8014618:	2d06      	cmp	r5, #6
 801461a:	f000 8081 	beq.w	8014720 <build_command+0x11c>
  else if (cmd_type == ATTYPE_NO_CMD)
 801461e:	2d05      	cmp	r5, #5
 8014620:	f000 80aa 	beq.w	8014778 <build_command+0x174>
    cmd_total_length = 0U;
 8014624:	2300      	movs	r3, #0
 8014626:	f8ad 300e 	strh.w	r3, [sp, #14]
    PRINT_ERR("invalid command type")
 801462a:	4d65      	ldr	r5, [pc, #404]	; (80147c0 <build_command+0x1bc>)
 801462c:	4c65      	ldr	r4, [pc, #404]	; (80147c4 <build_command+0x1c0>)
 801462e:	f105 0620 	add.w	r6, r5, #32
 8014632:	46ac      	mov	ip, r5
 8014634:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014638:	6020      	str	r0, [r4, #0]
 801463a:	6061      	str	r1, [r4, #4]
 801463c:	60a2      	str	r2, [r4, #8]
 801463e:	60e3      	str	r3, [r4, #12]
 8014640:	4665      	mov	r5, ip
 8014642:	3410      	adds	r4, #16
 8014644:	45b4      	cmp	ip, r6
 8014646:	d1f4      	bne.n	8014632 <build_command+0x2e>
 8014648:	f8dc 0000 	ldr.w	r0, [ip]
 801464c:	6020      	str	r0, [r4, #0]
 801464e:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 8014652:	80a3      	strh	r3, [r4, #4]
 8014654:	4c5b      	ldr	r4, [pc, #364]	; (80147c4 <build_command+0x1c0>)
 8014656:	4620      	mov	r0, r4
 8014658:	f00a fe67 	bl	801f32a <crs_strlen>
 801465c:	b283      	uxth	r3, r0
 801465e:	4622      	mov	r2, r4
 8014660:	2110      	movs	r1, #16
 8014662:	2002      	movs	r0, #2
 8014664:	f00a fea4 	bl	801f3b0 <traceIF_itmPrint>
 8014668:	4620      	mov	r0, r4
 801466a:	f00a fe5e 	bl	801f32a <crs_strlen>
 801466e:	b283      	uxth	r3, r0
 8014670:	4622      	mov	r2, r4
 8014672:	2110      	movs	r1, #16
 8014674:	2002      	movs	r0, #2
 8014676:	f00a febd 	bl	801f3f4 <traceIF_uartPrint>
 801467a:	e04c      	b.n	8014716 <build_command+0x112>
    cmd_total_length = 0;
 801467c:	2300      	movs	r3, #0
 801467e:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint16_t remaining_size = ATcmdBuf_maxSize;
 8014682:	f8ad 200c 	strh.w	r2, [sp, #12]
    p_str = CMD_FORMAT[cmd_type].cmd_prefix;
 8014686:	f8df 8148 	ldr.w	r8, [pc, #328]	; 80147d0 <build_command+0x1cc>
 801468a:	ea4f 0985 	mov.w	r9, r5, lsl #2
 801468e:	eb05 0185 	add.w	r1, r5, r5, lsl #2
 8014692:	eb08 0181 	add.w	r1, r8, r1, lsl #2
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 8014696:	af03      	add	r7, sp, #12
 8014698:	9700      	str	r7, [sp, #0]
 801469a:	f10d 030e 	add.w	r3, sp, #14
 801469e:	890a      	ldrh	r2, [r1, #8]
 80146a0:	4630      	mov	r0, r6
 80146a2:	f7ff ff94 	bl	80145ce <write_data2buffer>
    p_str = p_at_ctxt->parser.current_atcmd.name;
 80146a6:	f104 0a20 	add.w	sl, r4, #32
    str_size = (uint16_t) strlen((CRC_CHAR_t *) &p_at_ctxt->parser.current_atcmd.name);
 80146aa:	4650      	mov	r0, sl
 80146ac:	f7eb fda2 	bl	80001f4 <strlen>
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 80146b0:	9700      	str	r7, [sp, #0]
 80146b2:	f10d 030e 	add.w	r3, sp, #14
 80146b6:	b282      	uxth	r2, r0
 80146b8:	4651      	mov	r1, sl
 80146ba:	4630      	mov	r0, r6
 80146bc:	f7ff ff87 	bl	80145ce <write_data2buffer>
    p_str = &CMD_FORMAT[cmd_type].cmd_separator[0];
 80146c0:	eb09 0105 	add.w	r1, r9, r5
 80146c4:	0089      	lsls	r1, r1, #2
 80146c6:	3108      	adds	r1, #8
 80146c8:	4441      	add	r1, r8
    str_size = CMD_FORMAT[cmd_type].cmd_separator_size;
 80146ca:	44a9      	add	r9, r5
 80146cc:	eb08 0889 	add.w	r8, r8, r9, lsl #2
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 80146d0:	9700      	str	r7, [sp, #0]
 80146d2:	f10d 030e 	add.w	r3, sp, #14
 80146d6:	f8b8 2012 	ldrh.w	r2, [r8, #18]
 80146da:	3102      	adds	r1, #2
 80146dc:	4630      	mov	r0, r6
 80146de:	f7ff ff76 	bl	80145ce <write_data2buffer>
    p_str = p_at_ctxt->parser.current_atcmd.params;
 80146e2:	f104 0540 	add.w	r5, r4, #64	; 0x40
    str_size = (uint16_t) strlen((CRC_CHAR_t *) &p_at_ctxt->parser.current_atcmd.params);
 80146e6:	4628      	mov	r0, r5
 80146e8:	f7eb fd84 	bl	80001f4 <strlen>
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 80146ec:	9700      	str	r7, [sp, #0]
 80146ee:	f10d 030e 	add.w	r3, sp, #14
 80146f2:	b282      	uxth	r2, r0
 80146f4:	4629      	mov	r1, r5
 80146f6:	4630      	mov	r0, r6
 80146f8:	f7ff ff69 	bl	80145ce <write_data2buffer>
    p_str = p_at_ctxt->parser.endstr;
 80146fc:	f204 6484 	addw	r4, r4, #1668	; 0x684
    str_size = (uint16_t) strlen((CRC_CHAR_t *) &p_at_ctxt->parser.endstr);
 8014700:	4620      	mov	r0, r4
 8014702:	f7eb fd77 	bl	80001f4 <strlen>
    (void) write_data2buffer(p_ATcmdBuf, p_str, str_size, &cmd_total_length, &remaining_size);
 8014706:	9700      	str	r7, [sp, #0]
 8014708:	f10d 030e 	add.w	r3, sp, #14
 801470c:	b282      	uxth	r2, r0
 801470e:	4621      	mov	r1, r4
 8014710:	4630      	mov	r0, r6
 8014712:	f7ff ff5c 	bl	80145ce <write_data2buffer>
}
 8014716:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 801471a:	b004      	add	sp, #16
 801471c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((p_at_ctxt->parser.current_atcmd.raw_cmd_size != 0U)
 8014720:	f8d0 3680 	ldr.w	r3, [r0, #1664]	; 0x680
 8014724:	b10b      	cbz	r3, 801472a <build_command+0x126>
        && (p_at_ctxt->parser.current_atcmd.raw_cmd_size <= ATcmdBuf_maxSize))
 8014726:	4293      	cmp	r3, r2
 8014728:	d91b      	bls.n	8014762 <build_command+0x15e>
      PRINT_ERR("Error with RAW command size = %ld", p_at_ctxt->parser.current_atcmd.raw_cmd_size)
 801472a:	4c26      	ldr	r4, [pc, #152]	; (80147c4 <build_command+0x1c0>)
 801472c:	461a      	mov	r2, r3
 801472e:	4926      	ldr	r1, [pc, #152]	; (80147c8 <build_command+0x1c4>)
 8014730:	4620      	mov	r0, r4
 8014732:	f012 f889 	bl	8026848 <sprintf>
 8014736:	4620      	mov	r0, r4
 8014738:	f00a fdf7 	bl	801f32a <crs_strlen>
 801473c:	b283      	uxth	r3, r0
 801473e:	4622      	mov	r2, r4
 8014740:	2110      	movs	r1, #16
 8014742:	2002      	movs	r0, #2
 8014744:	f00a fe34 	bl	801f3b0 <traceIF_itmPrint>
 8014748:	4620      	mov	r0, r4
 801474a:	f00a fdee 	bl	801f32a <crs_strlen>
 801474e:	b283      	uxth	r3, r0
 8014750:	4622      	mov	r2, r4
 8014752:	2110      	movs	r1, #16
 8014754:	2002      	movs	r0, #2
 8014756:	f00a fe4d 	bl	801f3f4 <traceIF_uartPrint>
      cmd_total_length = 0U;
 801475a:	2300      	movs	r3, #0
 801475c:	f8ad 300e 	strh.w	r3, [sp, #14]
 8014760:	e7d9      	b.n	8014716 <build_command+0x112>
      (void) memcpy((void *)p_ATcmdBuf,
 8014762:	461a      	mov	r2, r3
 8014764:	f100 0140 	add.w	r1, r0, #64	; 0x40
 8014768:	4630      	mov	r0, r6
 801476a:	f012 f9bd 	bl	8026ae8 <memcpy>
      cmd_total_length = (uint16_t)p_at_ctxt->parser.current_atcmd.raw_cmd_size;
 801476e:	f8b4 3680 	ldrh.w	r3, [r4, #1664]	; 0x680
 8014772:	f8ad 300e 	strh.w	r3, [sp, #14]
 8014776:	e7ce      	b.n	8014716 <build_command+0x112>
    cmd_total_length = 0U;
 8014778:	2300      	movs	r3, #0
 801477a:	f8ad 300e 	strh.w	r3, [sp, #14]
    PRINT_DBG("no command to send")
 801477e:	4c11      	ldr	r4, [pc, #68]	; (80147c4 <build_command+0x1c0>)
 8014780:	4d12      	ldr	r5, [pc, #72]	; (80147cc <build_command+0x1c8>)
 8014782:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8014784:	6020      	str	r0, [r4, #0]
 8014786:	6061      	str	r1, [r4, #4]
 8014788:	60a2      	str	r2, [r4, #8]
 801478a:	60e3      	str	r3, [r4, #12]
 801478c:	cd07      	ldmia	r5!, {r0, r1, r2}
 801478e:	6120      	str	r0, [r4, #16]
 8014790:	6161      	str	r1, [r4, #20]
 8014792:	61a2      	str	r2, [r4, #24]
 8014794:	882b      	ldrh	r3, [r5, #0]
 8014796:	83a3      	strh	r3, [r4, #28]
 8014798:	4620      	mov	r0, r4
 801479a:	f00a fdc6 	bl	801f32a <crs_strlen>
 801479e:	b283      	uxth	r3, r0
 80147a0:	4622      	mov	r2, r4
 80147a2:	2102      	movs	r1, #2
 80147a4:	4608      	mov	r0, r1
 80147a6:	f00a fe03 	bl	801f3b0 <traceIF_itmPrint>
 80147aa:	4620      	mov	r0, r4
 80147ac:	f00a fdbd 	bl	801f32a <crs_strlen>
 80147b0:	b283      	uxth	r3, r0
 80147b2:	4622      	mov	r2, r4
 80147b4:	2102      	movs	r1, #2
 80147b6:	4608      	mov	r0, r1
 80147b8:	f00a fe1c 	bl	801f3f4 <traceIF_uartPrint>
 80147bc:	e7ab      	b.n	8014716 <build_command+0x112>
 80147be:	bf00      	nop
 80147c0:	08031688 	.word	0x08031688
 80147c4:	200048dc 	.word	0x200048dc
 80147c8:	08031634 	.word	0x08031634
 80147cc:	08031668 	.word	0x08031668
 80147d0:	0803186c 	.word	0x0803186c

080147d4 <display_buffer>:

static void display_buffer(const at_context_t *p_at_ctxt, const uint8_t *p_buf, uint16_t buf_size, uint8_t is_TX_buf)
{
 80147d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80147d8:	4680      	mov	r8, r0
 80147da:	460f      	mov	r7, r1
 80147dc:	4616      	mov	r6, r2
 80147de:	461d      	mov	r5, r3
#if (USE_TRACE_ATPARSER == 0U)
  UNUSED(p_buf); /* for MISRA-2012 */
#endif /* USE_TRACE_ATPARSER */

  /* print header */
  PRINT_INDENT()
 80147e0:	4c3e      	ldr	r4, [pc, #248]	; (80148dc <display_buffer+0x108>)
 80147e2:	4b3f      	ldr	r3, [pc, #252]	; (80148e0 <display_buffer+0x10c>)
 80147e4:	6818      	ldr	r0, [r3, #0]
 80147e6:	6020      	str	r0, [r4, #0]
 80147e8:	791b      	ldrb	r3, [r3, #4]
 80147ea:	7123      	strb	r3, [r4, #4]
 80147ec:	4620      	mov	r0, r4
 80147ee:	f00a fd9c 	bl	801f32a <crs_strlen>
 80147f2:	b283      	uxth	r3, r0
 80147f4:	4622      	mov	r2, r4
 80147f6:	2101      	movs	r1, #1
 80147f8:	2002      	movs	r0, #2
 80147fa:	f00a fdd9 	bl	801f3b0 <traceIF_itmPrint>
 80147fe:	4620      	mov	r0, r4
 8014800:	f00a fd93 	bl	801f32a <crs_strlen>
 8014804:	b283      	uxth	r3, r0
 8014806:	4622      	mov	r2, r4
 8014808:	2101      	movs	r1, #1
 801480a:	2002      	movs	r0, #2
 801480c:	f00a fdf2 	bl	801f3f4 <traceIF_uartPrint>
  if (is_TX_buf == 1U)
 8014810:	2d01      	cmp	r5, #1
 8014812:	d00d      	beq.n	8014830 <display_buffer+0x5c>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 8014814:	2500      	movs	r5, #0
      }
    }
  }
  /* PRINT_INDENT() */

  if (buf_size != 0U)
 8014816:	b14e      	cbz	r6, 801482c <display_buffer+0x58>
  {
#if (FILTER_SOCKET_TRACES == 1U)
    if (buf_size > FILTER_DEFAULT_LENGH)
 8014818:	2e50      	cmp	r6, #80	; 0x50
 801481a:	d82f      	bhi.n	801487c <display_buffer+0xa8>
    {
      PRINT_INFO(" Big frame (display deactivated) ")
    }
    else
    {
      if (print_in_hexa == 1U)
 801481c:	2d01      	cmp	r5, #1
 801481e:	d055      	beq.n	80148cc <display_buffer+0xf8>
      {
        PRINT_BUF_HEXA((const uint8_t *)p_buf, buf_size)
      }
      else
      {
        PRINT_BUF((const uint8_t *)p_buf, buf_size)
 8014820:	4633      	mov	r3, r6
 8014822:	463a      	mov	r2, r7
 8014824:	2101      	movs	r1, #1
 8014826:	2002      	movs	r0, #2
 8014828:	f00b f8b0 	bl	801f98c <traceIF_BufCharPrint>
    {
      PRINT_BUF((const CRC_CHAR_t *)p_buf, buf_size)
    }
#endif /* FILTER_SOCKET_TRACES */
  }
}
 801482c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (buf_size > 0U)
 8014830:	b90e      	cbnz	r6, 8014836 <display_buffer+0x62>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 8014832:	2500      	movs	r5, #0
 8014834:	e7ef      	b.n	8014816 <display_buffer+0x42>
      PRINT_INFO("*** SEND (size=%d) ***", buf_size)
 8014836:	4632      	mov	r2, r6
 8014838:	492a      	ldr	r1, [pc, #168]	; (80148e4 <display_buffer+0x110>)
 801483a:	4620      	mov	r0, r4
 801483c:	f012 f804 	bl	8026848 <sprintf>
 8014840:	4620      	mov	r0, r4
 8014842:	f00a fd72 	bl	801f32a <crs_strlen>
 8014846:	b283      	uxth	r3, r0
 8014848:	4622      	mov	r2, r4
 801484a:	2101      	movs	r1, #1
 801484c:	2002      	movs	r0, #2
 801484e:	f00a fdaf 	bl	801f3b0 <traceIF_itmPrint>
 8014852:	4620      	mov	r0, r4
 8014854:	f00a fd69 	bl	801f32a <crs_strlen>
 8014858:	b283      	uxth	r3, r0
 801485a:	4622      	mov	r2, r4
 801485c:	2101      	movs	r1, #1
 801485e:	2002      	movs	r0, #2
 8014860:	f00a fdc8 	bl	801f3f4 <traceIF_uartPrint>
      if ((p_at_ctxt->parser.current_atcmd.type == ATTYPE_RAW_CMD) &&
 8014864:	f8b8 3018 	ldrh.w	r3, [r8, #24]
 8014868:	2b06      	cmp	r3, #6
 801486a:	d001      	beq.n	8014870 <display_buffer+0x9c>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 801486c:	2500      	movs	r5, #0
 801486e:	e7d2      	b.n	8014816 <display_buffer+0x42>
          (p_at_ctxt->parser.current_atcmd.id != (CMD_ID_t) CMD_AT_DIRECT_CMD))
 8014870:	f8d8 301c 	ldr.w	r3, [r8, #28]
      if ((p_at_ctxt->parser.current_atcmd.type == ATTYPE_RAW_CMD) &&
 8014874:	2b34      	cmp	r3, #52	; 0x34
 8014876:	d1ce      	bne.n	8014816 <display_buffer+0x42>
  uint8_t print_in_hexa = 0U; /* set default value (if 1, print in hexa otherwise, print in ascii) */
 8014878:	2500      	movs	r5, #0
 801487a:	e7cc      	b.n	8014816 <display_buffer+0x42>
      PRINT_INFO(" Big frame (display deactivated) ")
 801487c:	4d1a      	ldr	r5, [pc, #104]	; (80148e8 <display_buffer+0x114>)
 801487e:	4c17      	ldr	r4, [pc, #92]	; (80148dc <display_buffer+0x108>)
 8014880:	f105 0720 	add.w	r7, r5, #32
 8014884:	462e      	mov	r6, r5
 8014886:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8014888:	6020      	str	r0, [r4, #0]
 801488a:	6061      	str	r1, [r4, #4]
 801488c:	60a2      	str	r2, [r4, #8]
 801488e:	60e3      	str	r3, [r4, #12]
 8014890:	4635      	mov	r5, r6
 8014892:	3410      	adds	r4, #16
 8014894:	42be      	cmp	r6, r7
 8014896:	d1f5      	bne.n	8014884 <display_buffer+0xb0>
 8014898:	cd07      	ldmia	r5!, {r0, r1, r2}
 801489a:	6020      	str	r0, [r4, #0]
 801489c:	6061      	str	r1, [r4, #4]
 801489e:	60a2      	str	r2, [r4, #8]
 80148a0:	782b      	ldrb	r3, [r5, #0]
 80148a2:	7323      	strb	r3, [r4, #12]
 80148a4:	4c0d      	ldr	r4, [pc, #52]	; (80148dc <display_buffer+0x108>)
 80148a6:	4620      	mov	r0, r4
 80148a8:	f00a fd3f 	bl	801f32a <crs_strlen>
 80148ac:	b283      	uxth	r3, r0
 80148ae:	4622      	mov	r2, r4
 80148b0:	2101      	movs	r1, #1
 80148b2:	2002      	movs	r0, #2
 80148b4:	f00a fd7c 	bl	801f3b0 <traceIF_itmPrint>
 80148b8:	4620      	mov	r0, r4
 80148ba:	f00a fd36 	bl	801f32a <crs_strlen>
 80148be:	b283      	uxth	r3, r0
 80148c0:	4622      	mov	r2, r4
 80148c2:	2101      	movs	r1, #1
 80148c4:	2002      	movs	r0, #2
 80148c6:	f00a fd95 	bl	801f3f4 <traceIF_uartPrint>
 80148ca:	e7af      	b.n	801482c <display_buffer+0x58>
        PRINT_BUF_HEXA((const uint8_t *)p_buf, buf_size)
 80148cc:	4633      	mov	r3, r6
 80148ce:	463a      	mov	r2, r7
 80148d0:	2101      	movs	r1, #1
 80148d2:	2002      	movs	r0, #2
 80148d4:	f00b f94e 	bl	801fb74 <traceIF_BufHexPrint>
 80148d8:	e7a8      	b.n	801482c <display_buffer+0x58>
 80148da:	bf00      	nop
 80148dc:	200048dc 	.word	0x200048dc
 80148e0:	080316b0 	.word	0x080316b0
 80148e4:	080316b8 	.word	0x080316b8
 80148e8:	080316dc 	.word	0x080316dc

080148ec <ATParser_initParsers>:
{
 80148ec:	b508      	push	{r3, lr}
  return (atcc_initParsers(device_type));
 80148ee:	f7f7 fd33 	bl	800c358 <atcc_initParsers>
}
 80148f2:	bd08      	pop	{r3, pc}

080148f4 <ATParser_init>:
{
 80148f4:	b538      	push	{r3, r4, r5, lr}
 80148f6:	4604      	mov	r4, r0
 80148f8:	460d      	mov	r5, r1
  reset_parser_context(&p_at_ctxt->parser);
 80148fa:	3010      	adds	r0, #16
 80148fc:	f7ff fe58 	bl	80145b0 <reset_parser_context>
  *p_checkEndOfMsgCallback = atcc_checkEndOfMsgCallback(p_at_ctxt);
 8014900:	4620      	mov	r0, r4
 8014902:	f7f7 fd6d 	bl	800c3e0 <atcc_checkEndOfMsgCallback>
 8014906:	6028      	str	r0, [r5, #0]
  (void) memset((AT_CHAR_t *)p_at_ctxt->parser.endstr, 0, AT_CMD_MAX_END_STR_SIZE);
 8014908:	2300      	movs	r3, #0
 801490a:	f8a4 3684 	strh.w	r3, [r4, #1668]	; 0x684
 801490e:	f884 3686 	strb.w	r3, [r4, #1670]	; 0x686
  (void) sprintf((CRC_CHAR_t *)p_at_ctxt->parser.endstr, "\r");
 8014912:	4b04      	ldr	r3, [pc, #16]	; (8014924 <ATParser_init+0x30>)
 8014914:	881b      	ldrh	r3, [r3, #0]
 8014916:	f8a4 3684 	strh.w	r3, [r4, #1668]	; 0x684
  atcc_init(p_at_ctxt);
 801491a:	4620      	mov	r0, r4
 801491c:	f7f7 fd52 	bl	800c3c4 <atcc_init>
}
 8014920:	bd38      	pop	{r3, r4, r5, pc}
 8014922:	bf00      	nop
 8014924:	08033828 	.word	0x08033828

08014928 <ATParser_process_request>:
{
 8014928:	b570      	push	{r4, r5, r6, lr}
 801492a:	4604      	mov	r4, r0
 801492c:	460d      	mov	r5, r1
 801492e:	4616      	mov	r6, r2
  reset_parser_context(&p_at_ctxt->parser);
 8014930:	3010      	adds	r0, #16
 8014932:	f7ff fe3d 	bl	80145b0 <reset_parser_context>
  p_at_ctxt->parser.p_cmd_input = p_cmd_buf;
 8014936:	f8c4 668c 	str.w	r6, [r4, #1676]	; 0x68c
  p_at_ctxt->parser.current_SID = msg_id;
 801493a:	8225      	strh	r5, [r4, #16]
}
 801493c:	bd70      	pop	{r4, r5, r6, pc}
	...

08014940 <ATParser_get_ATcmd>:
{
 8014940:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014944:	4604      	mov	r4, r0
 8014946:	4688      	mov	r8, r1
 8014948:	4615      	mov	r5, r2
 801494a:	461f      	mov	r7, r3
  *p_ATcmdSize = 0U;
 801494c:	2300      	movs	r3, #0
 801494e:	803b      	strh	r3, [r7, #0]
  reset_current_command(&p_at_ctxt->parser);
 8014950:	3010      	adds	r0, #16
 8014952:	f7ff fe17 	bl	8014584 <reset_current_command>
  if (atcc_getCmd(p_at_ctxt, p_ATcmdTimeout) != ATSTATUS_OK)
 8014956:	9906      	ldr	r1, [sp, #24]
 8014958:	4620      	mov	r0, r4
 801495a:	f7f7 fd4b 	bl	800c3f4 <atcc_getCmd>
 801495e:	b958      	cbnz	r0, 8014978 <ATParser_get_ATcmd+0x38>
    if (p_at_ctxt->parser.current_atcmd.id != CMD_AT_INVALID)
 8014960:	69e3      	ldr	r3, [r4, #28]
 8014962:	f1b3 3fff 	cmp.w	r3, #4294967295
 8014966:	d153      	bne.n	8014a10 <ATParser_get_ATcmd+0xd0>
    if (p_at_ctxt->parser.answer_expected == CMD_MANDATORY_ANSWER_EXPECTED)
 8014968:	7ce3      	ldrb	r3, [r4, #19]
 801496a:	2b00      	cmp	r3, #0
 801496c:	f000 8082 	beq.w	8014a74 <ATParser_get_ATcmd+0x134>
    else if (p_at_ctxt->parser.answer_expected == CMD_OPTIONAL_ANSWER_EXPECTED)
 8014970:	2b01      	cmp	r3, #1
 8014972:	d154      	bne.n	8014a1e <ATParser_get_ATcmd+0xde>
      action |= ATACTION_SEND_TEMPO;
 8014974:	2502      	movs	r5, #2
 8014976:	e025      	b.n	80149c4 <ATParser_get_ATcmd+0x84>
    PRINT_DBG("parser f_getCmd error")
 8014978:	4e41      	ldr	r6, [pc, #260]	; (8014a80 <ATParser_get_ATcmd+0x140>)
 801497a:	4d42      	ldr	r5, [pc, #264]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 801497c:	f106 0e20 	add.w	lr, r6, #32
 8014980:	46b4      	mov	ip, r6
 8014982:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014986:	6028      	str	r0, [r5, #0]
 8014988:	6069      	str	r1, [r5, #4]
 801498a:	60aa      	str	r2, [r5, #8]
 801498c:	60eb      	str	r3, [r5, #12]
 801498e:	4666      	mov	r6, ip
 8014990:	3510      	adds	r5, #16
 8014992:	45f4      	cmp	ip, lr
 8014994:	d1f4      	bne.n	8014980 <ATParser_get_ATcmd+0x40>
 8014996:	f89c 3000 	ldrb.w	r3, [ip]
 801499a:	702b      	strb	r3, [r5, #0]
 801499c:	4d39      	ldr	r5, [pc, #228]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 801499e:	4628      	mov	r0, r5
 80149a0:	f00a fcc3 	bl	801f32a <crs_strlen>
 80149a4:	b283      	uxth	r3, r0
 80149a6:	462a      	mov	r2, r5
 80149a8:	2102      	movs	r1, #2
 80149aa:	4608      	mov	r0, r1
 80149ac:	f00a fd00 	bl	801f3b0 <traceIF_itmPrint>
 80149b0:	4628      	mov	r0, r5
 80149b2:	f00a fcba 	bl	801f32a <crs_strlen>
 80149b6:	b283      	uxth	r3, r0
 80149b8:	462a      	mov	r2, r5
 80149ba:	2102      	movs	r1, #2
 80149bc:	4608      	mov	r0, r1
 80149be:	f00a fd19 	bl	801f3f4 <traceIF_uartPrint>
    action = ATACTION_SEND_ERROR;
 80149c2:	2504      	movs	r5, #4
  if (action != ATACTION_SEND_ERROR)
 80149c4:	2d04      	cmp	r5, #4
 80149c6:	d008      	beq.n	80149da <ATParser_get_ATcmd+0x9a>
    if (p_at_ctxt->parser.is_final_cmd == 1U)
 80149c8:	7d23      	ldrb	r3, [r4, #20]
 80149ca:	2b01      	cmp	r3, #1
 80149cc:	d054      	beq.n	8014a78 <ATParser_get_ATcmd+0x138>
    display_buffer(p_at_ctxt,
 80149ce:	2301      	movs	r3, #1
 80149d0:	883a      	ldrh	r2, [r7, #0]
 80149d2:	4641      	mov	r1, r8
 80149d4:	4620      	mov	r0, r4
 80149d6:	f7ff fefd 	bl	80147d4 <display_buffer>
  PRINT_DBG("ATParser_get_ATcmd returned action = 0x%x", action)
 80149da:	4c2a      	ldr	r4, [pc, #168]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 80149dc:	462a      	mov	r2, r5
 80149de:	492a      	ldr	r1, [pc, #168]	; (8014a88 <ATParser_get_ATcmd+0x148>)
 80149e0:	4620      	mov	r0, r4
 80149e2:	f011 ff31 	bl	8026848 <sprintf>
 80149e6:	4620      	mov	r0, r4
 80149e8:	f00a fc9f 	bl	801f32a <crs_strlen>
 80149ec:	b283      	uxth	r3, r0
 80149ee:	4622      	mov	r2, r4
 80149f0:	2102      	movs	r1, #2
 80149f2:	4608      	mov	r0, r1
 80149f4:	f00a fcdc 	bl	801f3b0 <traceIF_itmPrint>
 80149f8:	4620      	mov	r0, r4
 80149fa:	f00a fc96 	bl	801f32a <crs_strlen>
 80149fe:	b283      	uxth	r3, r0
 8014a00:	4622      	mov	r2, r4
 8014a02:	2102      	movs	r1, #2
 8014a04:	4608      	mov	r0, r1
 8014a06:	f00a fcf5 	bl	801f3f4 <traceIF_uartPrint>
}
 8014a0a:	4628      	mov	r0, r5
 8014a0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *p_ATcmdSize = build_command(p_at_ctxt, p_ATcmdBuf, ATcmdBuf_maxSize);
 8014a10:	462a      	mov	r2, r5
 8014a12:	4641      	mov	r1, r8
 8014a14:	4620      	mov	r0, r4
 8014a16:	f7ff fdf5 	bl	8014604 <build_command>
 8014a1a:	8038      	strh	r0, [r7, #0]
 8014a1c:	e7a4      	b.n	8014968 <ATParser_get_ATcmd+0x28>
      PRINT_ERR("Invalid answer_expected value")
 8014a1e:	4d1b      	ldr	r5, [pc, #108]	; (8014a8c <ATParser_get_ATcmd+0x14c>)
 8014a20:	4c18      	ldr	r4, [pc, #96]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 8014a22:	f105 0720 	add.w	r7, r5, #32
 8014a26:	462e      	mov	r6, r5
 8014a28:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8014a2a:	6020      	str	r0, [r4, #0]
 8014a2c:	6061      	str	r1, [r4, #4]
 8014a2e:	60a2      	str	r2, [r4, #8]
 8014a30:	60e3      	str	r3, [r4, #12]
 8014a32:	4635      	mov	r5, r6
 8014a34:	3410      	adds	r4, #16
 8014a36:	42be      	cmp	r6, r7
 8014a38:	d1f5      	bne.n	8014a26 <ATParser_get_ATcmd+0xe6>
 8014a3a:	cd07      	ldmia	r5!, {r0, r1, r2}
 8014a3c:	6020      	str	r0, [r4, #0]
 8014a3e:	6061      	str	r1, [r4, #4]
 8014a40:	60a2      	str	r2, [r4, #8]
 8014a42:	882a      	ldrh	r2, [r5, #0]
 8014a44:	78ab      	ldrb	r3, [r5, #2]
 8014a46:	81a2      	strh	r2, [r4, #12]
 8014a48:	73a3      	strb	r3, [r4, #14]
 8014a4a:	4c0e      	ldr	r4, [pc, #56]	; (8014a84 <ATParser_get_ATcmd+0x144>)
 8014a4c:	4620      	mov	r0, r4
 8014a4e:	f00a fc6c 	bl	801f32a <crs_strlen>
 8014a52:	b283      	uxth	r3, r0
 8014a54:	4622      	mov	r2, r4
 8014a56:	2110      	movs	r1, #16
 8014a58:	2002      	movs	r0, #2
 8014a5a:	f00a fca9 	bl	801f3b0 <traceIF_itmPrint>
 8014a5e:	4620      	mov	r0, r4
 8014a60:	f00a fc63 	bl	801f32a <crs_strlen>
 8014a64:	b283      	uxth	r3, r0
 8014a66:	4622      	mov	r2, r4
 8014a68:	2110      	movs	r1, #16
 8014a6a:	2002      	movs	r0, #2
 8014a6c:	f00a fcc2 	bl	801f3f4 <traceIF_uartPrint>
      action = ATACTION_SEND_ERROR;
 8014a70:	2504      	movs	r5, #4
 8014a72:	e7b2      	b.n	80149da <ATParser_get_ATcmd+0x9a>
      action |= ATACTION_SEND_WAIT_MANDATORY_RSP;
 8014a74:	2501      	movs	r5, #1
 8014a76:	e7a5      	b.n	80149c4 <ATParser_get_ATcmd+0x84>
      action |= ATACTION_SEND_FLAG_LAST_CMD;
 8014a78:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
 8014a7c:	e7a7      	b.n	80149ce <ATParser_get_ATcmd+0x8e>
 8014a7e:	bf00      	nop
 8014a80:	0803170c 	.word	0x0803170c
 8014a84:	200048dc 	.word	0x200048dc
 8014a88:	08031760 	.word	0x08031760
 8014a8c:	08031730 	.word	0x08031730

08014a90 <ATParser_parse_rsp>:
{
 8014a90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014a94:	b086      	sub	sp, #24
 8014a96:	4607      	mov	r7, r0
 8014a98:	460d      	mov	r5, r1
  at_element_info_t element_infos = { .current_parse_idx = 0, .cmd_id_received = CMD_AT_INVALID, .param_rank = 0U,
 8014a9a:	2300      	movs	r3, #0
 8014a9c:	f8ad 3008 	strh.w	r3, [sp, #8]
 8014aa0:	f04f 32ff 	mov.w	r2, #4294967295
 8014aa4:	9203      	str	r2, [sp, #12]
 8014aa6:	f8ad 3010 	strh.w	r3, [sp, #16]
 8014aaa:	f8ad 3012 	strh.w	r3, [sp, #18]
 8014aae:	f8ad 3014 	strh.w	r3, [sp, #20]
 8014ab2:	f8ad 3016 	strh.w	r3, [sp, #22]
  display_buffer(p_at_ctxt,
 8014ab6:	f8b1 27d0 	ldrh.w	r2, [r1, #2000]	; 0x7d0
 8014aba:	f7ff fe8b 	bl	80147d4 <display_buffer>
  msg_end = atcc_extractElement(p_at_ctxt, p_message, &element_infos);
 8014abe:	aa02      	add	r2, sp, #8
 8014ac0:	4629      	mov	r1, r5
 8014ac2:	4638      	mov	r0, r7
 8014ac4:	f7f7 fcc0 	bl	800c448 <atcc_extractElement>
 8014ac8:	4681      	mov	r9, r0
  cmd_retval = atcc_analyzeCmd(p_at_ctxt, p_message, &element_infos);
 8014aca:	aa02      	add	r2, sp, #8
 8014acc:	4629      	mov	r1, r5
 8014ace:	4638      	mov	r0, r7
 8014ad0:	f7f7 fd08 	bl	800c4e4 <atcc_analyzeCmd>
 8014ad4:	4680      	mov	r8, r0
  clean_retval = (at_action_rsp_t)(cmd_retval & ~(at_action_rsp_t)ATACTION_RSP_FLAG_DATA_MODE);
 8014ad6:	f3c0 040e 	ubfx	r4, r0, #0, #15
  data_mode = (((uint16_t)cmd_retval & (uint16_t)ATACTION_RSP_FLAG_DATA_MODE) != 0U) ? (uint16_t)1U : (uint16_t)0U;
 8014ada:	f3c0 3acf 	ubfx	sl, r0, #15, #16
  PRINT_DBG("analyzeCmd retval = %d (DATA mode=%d) msg_end = %d", clean_retval, data_mode, (msg_end == ATENDMSG_YES))
 8014ade:	4e4f      	ldr	r6, [pc, #316]	; (8014c1c <ATParser_parse_rsp+0x18c>)
 8014ae0:	fab9 f389 	clz	r3, r9
 8014ae4:	095b      	lsrs	r3, r3, #5
 8014ae6:	9300      	str	r3, [sp, #0]
 8014ae8:	4653      	mov	r3, sl
 8014aea:	4622      	mov	r2, r4
 8014aec:	494c      	ldr	r1, [pc, #304]	; (8014c20 <ATParser_parse_rsp+0x190>)
 8014aee:	4630      	mov	r0, r6
 8014af0:	f011 feaa 	bl	8026848 <sprintf>
 8014af4:	4630      	mov	r0, r6
 8014af6:	f00a fc18 	bl	801f32a <crs_strlen>
 8014afa:	b283      	uxth	r3, r0
 8014afc:	4632      	mov	r2, r6
 8014afe:	2102      	movs	r1, #2
 8014b00:	4608      	mov	r0, r1
 8014b02:	f00a fc55 	bl	801f3b0 <traceIF_itmPrint>
 8014b06:	4630      	mov	r0, r6
 8014b08:	f00a fc0f 	bl	801f32a <crs_strlen>
 8014b0c:	b283      	uxth	r3, r0
 8014b0e:	4632      	mov	r2, r6
 8014b10:	2102      	movs	r1, #2
 8014b12:	4608      	mov	r0, r1
 8014b14:	f00a fc6e 	bl	801f3f4 <traceIF_uartPrint>
  if ((msg_end != ATENDMSG_YES) && (cmd_retval != ATACTION_RSP_ERROR))
 8014b18:	f1b9 0f00 	cmp.w	r9, #0
 8014b1c:	d002      	beq.n	8014b24 <ATParser_parse_rsp+0x94>
 8014b1e:	f1b8 0f04 	cmp.w	r8, #4
 8014b22:	d120      	bne.n	8014b66 <ATParser_parse_rsp+0xd6>
  if (clean_retval == ATACTION_RSP_FRC_END)
 8014b24:	2c01      	cmp	r4, #1
 8014b26:	d062      	beq.n	8014bee <ATParser_parse_rsp+0x15e>
  if (data_mode == 1U)
 8014b28:	f1ba 0f01 	cmp.w	sl, #1
 8014b2c:	d06f      	beq.n	8014c0e <ATParser_parse_rsp+0x17e>
  PRINT_DBG("ATParser_parse_rsp returned action = 0x%x", cmd_retval)
 8014b2e:	4d3b      	ldr	r5, [pc, #236]	; (8014c1c <ATParser_parse_rsp+0x18c>)
 8014b30:	4622      	mov	r2, r4
 8014b32:	493c      	ldr	r1, [pc, #240]	; (8014c24 <ATParser_parse_rsp+0x194>)
 8014b34:	4628      	mov	r0, r5
 8014b36:	f011 fe87 	bl	8026848 <sprintf>
 8014b3a:	4628      	mov	r0, r5
 8014b3c:	f00a fbf5 	bl	801f32a <crs_strlen>
 8014b40:	b283      	uxth	r3, r0
 8014b42:	462a      	mov	r2, r5
 8014b44:	2102      	movs	r1, #2
 8014b46:	4608      	mov	r0, r1
 8014b48:	f00a fc32 	bl	801f3b0 <traceIF_itmPrint>
 8014b4c:	4628      	mov	r0, r5
 8014b4e:	f00a fbec 	bl	801f32a <crs_strlen>
 8014b52:	b283      	uxth	r3, r0
 8014b54:	462a      	mov	r2, r5
 8014b56:	2102      	movs	r1, #2
 8014b58:	4608      	mov	r0, r1
 8014b5a:	f00a fc4b 	bl	801f3f4 <traceIF_uartPrint>
}
 8014b5e:	4620      	mov	r0, r4
 8014b60:	b006      	add	sp, #24
 8014b62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    PRINT_DBG("proceed to params")
 8014b66:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 8014c2c <ATParser_parse_rsp+0x19c>
 8014b6a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8014b6e:	6030      	str	r0, [r6, #0]
 8014b70:	6071      	str	r1, [r6, #4]
 8014b72:	60b2      	str	r2, [r6, #8]
 8014b74:	60f3      	str	r3, [r6, #12]
 8014b76:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8014b7a:	6130      	str	r0, [r6, #16]
 8014b7c:	6171      	str	r1, [r6, #20]
 8014b7e:	61b2      	str	r2, [r6, #24]
 8014b80:	f89c 3000 	ldrb.w	r3, [ip]
 8014b84:	7733      	strb	r3, [r6, #28]
 8014b86:	4630      	mov	r0, r6
 8014b88:	f00a fbcf 	bl	801f32a <crs_strlen>
 8014b8c:	b283      	uxth	r3, r0
 8014b8e:	4632      	mov	r2, r6
 8014b90:	2102      	movs	r1, #2
 8014b92:	4608      	mov	r0, r1
 8014b94:	f00a fc0c 	bl	801f3b0 <traceIF_itmPrint>
 8014b98:	4630      	mov	r0, r6
 8014b9a:	f00a fbc6 	bl	801f32a <crs_strlen>
 8014b9e:	b283      	uxth	r3, r0
 8014ba0:	4632      	mov	r2, r6
 8014ba2:	2102      	movs	r1, #2
 8014ba4:	4608      	mov	r0, r1
 8014ba6:	f00a fc25 	bl	801f3f4 <traceIF_uartPrint>
    param_retval = atcc_analyzeParam(p_at_ctxt, p_message, &element_infos);
 8014baa:	aa02      	add	r2, sp, #8
 8014bac:	4629      	mov	r1, r5
 8014bae:	4638      	mov	r0, r7
 8014bb0:	f7f7 fcc2 	bl	800c538 <atcc_analyzeParam>
 8014bb4:	4605      	mov	r5, r0
    if (param_retval != ATACTION_RSP_IGNORED)
 8014bb6:	2810      	cmp	r0, #16
 8014bb8:	d0b4      	beq.n	8014b24 <ATParser_parse_rsp+0x94>
      PRINT_DBG("action modified by analysis of params: %d to %d", cmd_retval, param_retval)
 8014bba:	4603      	mov	r3, r0
 8014bbc:	4642      	mov	r2, r8
 8014bbe:	491a      	ldr	r1, [pc, #104]	; (8014c28 <ATParser_parse_rsp+0x198>)
 8014bc0:	4630      	mov	r0, r6
 8014bc2:	f011 fe41 	bl	8026848 <sprintf>
 8014bc6:	4630      	mov	r0, r6
 8014bc8:	f00a fbaf 	bl	801f32a <crs_strlen>
 8014bcc:	b283      	uxth	r3, r0
 8014bce:	4632      	mov	r2, r6
 8014bd0:	2102      	movs	r1, #2
 8014bd2:	4608      	mov	r0, r1
 8014bd4:	f00a fbec 	bl	801f3b0 <traceIF_itmPrint>
 8014bd8:	4630      	mov	r0, r6
 8014bda:	f00a fba6 	bl	801f32a <crs_strlen>
 8014bde:	b283      	uxth	r3, r0
 8014be0:	4632      	mov	r2, r6
 8014be2:	2102      	movs	r1, #2
 8014be4:	4608      	mov	r0, r1
 8014be6:	f00a fc05 	bl	801f3f4 <traceIF_uartPrint>
      clean_retval = param_retval;
 8014bea:	462c      	mov	r4, r5
 8014bec:	e79a      	b.n	8014b24 <ATParser_parse_rsp+0x94>
    final_retval = atcc_terminateCmd(p_at_ctxt, &element_infos);
 8014bee:	a902      	add	r1, sp, #8
 8014bf0:	4638      	mov	r0, r7
 8014bf2:	f7f7 fccb 	bl	800c58c <atcc_terminateCmd>
    if (final_retval == ATACTION_RSP_ERROR)
 8014bf6:	2804      	cmp	r0, #4
 8014bf8:	d003      	beq.n	8014c02 <ATParser_parse_rsp+0x172>
    else if (p_at_ctxt->parser.is_final_cmd == 0U)
 8014bfa:	7d3b      	ldrb	r3, [r7, #20]
 8014bfc:	b913      	cbnz	r3, 8014c04 <ATParser_parse_rsp+0x174>
      clean_retval = ATACTION_RSP_FRC_CONTINUE;
 8014bfe:	2402      	movs	r4, #2
 8014c00:	e000      	b.n	8014c04 <ATParser_parse_rsp+0x174>
      clean_retval = ATACTION_RSP_ERROR;
 8014c02:	4604      	mov	r4, r0
    reset_current_command(&p_at_ctxt->parser);
 8014c04:	f107 0010 	add.w	r0, r7, #16
 8014c08:	f7ff fcbc 	bl	8014584 <reset_current_command>
 8014c0c:	e78c      	b.n	8014b28 <ATParser_parse_rsp+0x98>
    cmd_retval = (at_action_rsp_t)(clean_retval | ATACTION_RSP_FLAG_DATA_MODE);
 8014c0e:	ea6f 4444 	mvn.w	r4, r4, lsl #17
 8014c12:	ea6f 4454 	mvn.w	r4, r4, lsr #17
 8014c16:	b2a4      	uxth	r4, r4
 8014c18:	e789      	b.n	8014b2e <ATParser_parse_rsp+0x9e>
 8014c1a:	bf00      	nop
 8014c1c:	200048dc 	.word	0x200048dc
 8014c20:	08031798 	.word	0x08031798
 8014c24:	08031834 	.word	0x08031834
 8014c28:	080317f8 	.word	0x080317f8
 8014c2c:	080317d8 	.word	0x080317d8

08014c30 <ATParser_get_rsp>:
{
 8014c30:	b538      	push	{r3, r4, r5, lr}
 8014c32:	4605      	mov	r5, r0
  retval = atcc_get_rsp(p_at_ctxt, p_rsp_buf);
 8014c34:	f7f7 fcd6 	bl	800c5e4 <atcc_get_rsp>
 8014c38:	4604      	mov	r4, r0
  reset_parser_context(&p_at_ctxt->parser);
 8014c3a:	f105 0010 	add.w	r0, r5, #16
 8014c3e:	f7ff fcb7 	bl	80145b0 <reset_parser_context>
}
 8014c42:	4620      	mov	r0, r4
 8014c44:	bd38      	pop	{r3, r4, r5, pc}

08014c46 <ATParser_get_urc>:
{
 8014c46:	b508      	push	{r3, lr}
  retval = atcc_get_urc(p_at_ctxt, p_rsp_buf);
 8014c48:	f7f7 fcf8 	bl	800c63c <atcc_get_urc>
}
 8014c4c:	bd08      	pop	{r3, pc}

08014c4e <ATParser_get_error>:
{
 8014c4e:	b508      	push	{r3, lr}
  retval = atcc_get_error(p_at_ctxt, p_rsp_buf);
 8014c50:	f7f7 fd20 	bl	800c694 <atcc_get_error>
}
 8014c54:	bd08      	pop	{r3, pc}

08014c56 <ATParser_abort_request>:
{
 8014c56:	b508      	push	{r3, lr}
  reset_parser_context(&p_at_ctxt->parser);
 8014c58:	3010      	adds	r0, #16
 8014c5a:	f7ff fca9 	bl	80145b0 <reset_parser_context>
}
 8014c5e:	bd08      	pop	{r3, pc}

08014c60 <ATutil_ipow>:
/* Global variables ----------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/

/* Functions Definition ------------------------------------------------------*/
uint32_t ATutil_ipow(uint32_t base, uint16_t exp)
{
 8014c60:	4603      	mov	r3, r0
  uint16_t local_exp = exp;
  uint32_t local_base = base;

  /* implementation of power function */
  uint32_t result = 1U;
 8014c62:	2001      	movs	r0, #1
  while (local_exp != 0U)
 8014c64:	e002      	b.n	8014c6c <ATutil_ipow+0xc>
  {
    if ((local_exp & 1U) != 0U)
    {
      result *= local_base;
    }
    local_exp >>= 1;
 8014c66:	0849      	lsrs	r1, r1, #1
    local_base *= local_base;
 8014c68:	fb03 f303 	mul.w	r3, r3, r3
  while (local_exp != 0U)
 8014c6c:	b129      	cbz	r1, 8014c7a <ATutil_ipow+0x1a>
    if ((local_exp & 1U) != 0U)
 8014c6e:	f011 0f01 	tst.w	r1, #1
 8014c72:	d0f8      	beq.n	8014c66 <ATutil_ipow+0x6>
      result *= local_base;
 8014c74:	fb03 f000 	mul.w	r0, r3, r0
 8014c78:	e7f5      	b.n	8014c66 <ATutil_ipow+0x6>
  }

  return result;
}
 8014c7a:	4770      	bx	lr

08014c7c <ATutil_convertHexaStringToInt32>:

  return (conv_nbr);
}

uint32_t ATutil_convertHexaStringToInt32(const uint8_t *p_string, uint16_t size)
{
 8014c7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014c80:	4681      	mov	r9, r0
 8014c82:	460e      	mov	r6, r1
   * implicit input string format from "W" to "WWWWXXXX"
   * where X,Y,W and Z are characters from '0' to 'F'
   */

  /* auto-detect if 0x is present */
  if ((size > 2U) && (p_string[1] == 120U)) /* ASCII value 120 = 'x' */
 8014c84:	2902      	cmp	r1, #2
 8014c86:	d904      	bls.n	8014c92 <ATutil_convertHexaStringToInt32+0x16>
 8014c88:	7843      	ldrb	r3, [r0, #1]
 8014c8a:	2b78      	cmp	r3, #120	; 0x78
 8014c8c:	d00b      	beq.n	8014ca6 <ATutil_convertHexaStringToInt32+0x2a>
    nb_digit_ignored = 2U;
  }
  else
  {
    /* 0x is not present */
    nb_digit_ignored = 0U;
 8014c8e:	2400      	movs	r4, #0
 8014c90:	e000      	b.n	8014c94 <ATutil_convertHexaStringToInt32+0x18>
 8014c92:	2400      	movs	r4, #0
  }

  /* if 0x is present, we can skip it */
  str_size_to_convert = size - nb_digit_ignored;
 8014c94:	1b33      	subs	r3, r6, r4
 8014c96:	b29b      	uxth	r3, r3

  /* check maximum string size */
  if (str_size_to_convert <= MAX_32BITS_STRING_SIZE)
 8014c98:	2b08      	cmp	r3, #8
 8014c9a:	d947      	bls.n	8014d2c <ATutil_convertHexaStringToInt32+0xb0>
  uint32_t conv_nbr = 0U; /* returned value = converted numder (0 if an error occurs) */
 8014c9c:	f04f 0800 	mov.w	r8, #0
      }
    }
  }

  return (conv_nbr);
}
 8014ca0:	4640      	mov	r0, r8
 8014ca2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    nb_digit_ignored = 2U;
 8014ca6:	2402      	movs	r4, #2
 8014ca8:	e7f4      	b.n	8014c94 <ATutil_convertHexaStringToInt32+0x18>
        loop++;
 8014caa:	3501      	adds	r5, #1
 8014cac:	b2ad      	uxth	r5, r5
                   (((uint32_t)p_string[idx] - 48U) * ATutil_ipow(16U, (size - loop - nb_digit_ignored)));
 8014cae:	f1a2 0a30 	sub.w	sl, r2, #48	; 0x30
 8014cb2:	1b71      	subs	r1, r6, r5
 8014cb4:	b289      	uxth	r1, r1
 8014cb6:	1bc9      	subs	r1, r1, r7
 8014cb8:	b289      	uxth	r1, r1
 8014cba:	2010      	movs	r0, #16
 8014cbc:	f7ff ffd0 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014cc0:	fb00 880a 	mla	r8, r0, sl, r8
    for (idx = nb_digit_ignored; idx < size; idx++)
 8014cc4:	3401      	adds	r4, #1
 8014cc6:	b2a4      	uxth	r4, r4
 8014cc8:	42b4      	cmp	r4, r6
 8014cca:	d2e9      	bcs.n	8014ca0 <ATutil_convertHexaStringToInt32+0x24>
      if ((p_string[idx] >= 48U) && (p_string[idx] <= 57U))
 8014ccc:	f819 2004 	ldrb.w	r2, [r9, r4]
 8014cd0:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8014cd4:	b2db      	uxtb	r3, r3
 8014cd6:	2b09      	cmp	r3, #9
 8014cd8:	d9e7      	bls.n	8014caa <ATutil_convertHexaStringToInt32+0x2e>
      else if ((p_string[idx] >= 97U) && (p_string[idx] <= 102U))
 8014cda:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 8014cde:	b2db      	uxtb	r3, r3
 8014ce0:	2b05      	cmp	r3, #5
 8014ce2:	d907      	bls.n	8014cf4 <ATutil_convertHexaStringToInt32+0x78>
      else if ((p_string[idx] >= 65U) && (p_string[idx] <= 70U))
 8014ce4:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 8014ce8:	b2db      	uxtb	r3, r3
 8014cea:	2b05      	cmp	r3, #5
 8014cec:	d910      	bls.n	8014d10 <ATutil_convertHexaStringToInt32+0x94>
        nb_digit_ignored++;
 8014cee:	3701      	adds	r7, #1
 8014cf0:	b2bf      	uxth	r7, r7
 8014cf2:	e7e7      	b.n	8014cc4 <ATutil_convertHexaStringToInt32+0x48>
        loop++;
 8014cf4:	3501      	adds	r5, #1
 8014cf6:	b2ad      	uxth	r5, r5
                   (((uint32_t)p_string[idx] - 97U + 10U) * ATutil_ipow(16U, (size - loop - nb_digit_ignored)));
 8014cf8:	f1a2 0a57 	sub.w	sl, r2, #87	; 0x57
 8014cfc:	1b71      	subs	r1, r6, r5
 8014cfe:	b289      	uxth	r1, r1
 8014d00:	1bc9      	subs	r1, r1, r7
 8014d02:	b289      	uxth	r1, r1
 8014d04:	2010      	movs	r0, #16
 8014d06:	f7ff ffab 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014d0a:	fb00 880a 	mla	r8, r0, sl, r8
 8014d0e:	e7d9      	b.n	8014cc4 <ATutil_convertHexaStringToInt32+0x48>
        loop++;
 8014d10:	3501      	adds	r5, #1
 8014d12:	b2ad      	uxth	r5, r5
                   (((uint32_t)p_string[idx] - 65U + 10U) * ATutil_ipow(16U, (size - loop - nb_digit_ignored)));
 8014d14:	f1a2 0a37 	sub.w	sl, r2, #55	; 0x37
 8014d18:	1b71      	subs	r1, r6, r5
 8014d1a:	b289      	uxth	r1, r1
 8014d1c:	1bc9      	subs	r1, r1, r7
 8014d1e:	b289      	uxth	r1, r1
 8014d20:	2010      	movs	r0, #16
 8014d22:	f7ff ff9d 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014d26:	fb00 880a 	mla	r8, r0, sl, r8
 8014d2a:	e7cb      	b.n	8014cc4 <ATutil_convertHexaStringToInt32+0x48>
 8014d2c:	4627      	mov	r7, r4
  uint16_t loop = 0U;
 8014d2e:	2500      	movs	r5, #0
  uint32_t conv_nbr = 0U; /* returned value = converted numder (0 if an error occurs) */
 8014d30:	46a8      	mov	r8, r5
 8014d32:	e7c9      	b.n	8014cc8 <ATutil_convertHexaStringToInt32+0x4c>

08014d34 <ATutil_convertStringToInt>:
{
 8014d34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014d38:	4680      	mov	r8, r0
 8014d3a:	460f      	mov	r7, r1
  if ((size > 2U) && (p_string[1] == 120U)) /* ASCII value 120 = 'x' */
 8014d3c:	2902      	cmp	r1, #2
 8014d3e:	d804      	bhi.n	8014d4a <ATutil_convertStringToInt+0x16>
 8014d40:	2600      	movs	r6, #0
 8014d42:	4635      	mov	r5, r6
 8014d44:	4634      	mov	r4, r6
 8014d46:	46b1      	mov	r9, r6
 8014d48:	e011      	b.n	8014d6e <ATutil_convertStringToInt+0x3a>
 8014d4a:	7843      	ldrb	r3, [r0, #1]
 8014d4c:	2b78      	cmp	r3, #120	; 0x78
 8014d4e:	d004      	beq.n	8014d5a <ATutil_convertStringToInt+0x26>
 8014d50:	2600      	movs	r6, #0
 8014d52:	4635      	mov	r5, r6
 8014d54:	4634      	mov	r4, r6
 8014d56:	46b1      	mov	r9, r6
 8014d58:	e009      	b.n	8014d6e <ATutil_convertStringToInt+0x3a>
    conv_nbr = ATutil_convertHexaStringToInt32(p_string, size);
 8014d5a:	f7ff ff8f 	bl	8014c7c <ATutil_convertHexaStringToInt32>
 8014d5e:	4681      	mov	r9, r0
}
 8014d60:	4648      	mov	r0, r9
 8014d62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        nb_digit_ignored++;
 8014d66:	3501      	adds	r5, #1
 8014d68:	b2ad      	uxth	r5, r5
    for (idx = 0U; idx < size; idx++)
 8014d6a:	3401      	adds	r4, #1
 8014d6c:	b2a4      	uxth	r4, r4
 8014d6e:	42bc      	cmp	r4, r7
 8014d70:	d2f6      	bcs.n	8014d60 <ATutil_convertStringToInt+0x2c>
      if ((p_string[idx] >= 48U) && (p_string[idx] <= 57U))
 8014d72:	f818 2004 	ldrb.w	r2, [r8, r4]
 8014d76:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8014d7a:	b2db      	uxtb	r3, r3
 8014d7c:	2b09      	cmp	r3, #9
 8014d7e:	d8f2      	bhi.n	8014d66 <ATutil_convertStringToInt+0x32>
        loop++;
 8014d80:	3601      	adds	r6, #1
 8014d82:	b2b6      	uxth	r6, r6
                   (((uint32_t) p_string[idx] - 48U) * ATutil_ipow(10U, (size - loop - nb_digit_ignored)));
 8014d84:	f1a2 0a30 	sub.w	sl, r2, #48	; 0x30
 8014d88:	1bb9      	subs	r1, r7, r6
 8014d8a:	b289      	uxth	r1, r1
 8014d8c:	1b49      	subs	r1, r1, r5
 8014d8e:	b289      	uxth	r1, r1
 8014d90:	200a      	movs	r0, #10
 8014d92:	f7ff ff65 	bl	8014c60 <ATutil_ipow>
        conv_nbr = conv_nbr +
 8014d96:	fb00 990a 	mla	r9, r0, sl, r9
 8014d9a:	e7e6      	b.n	8014d6a <ATutil_convertStringToInt+0x36>

08014d9c <ATutil_convertHexaStringToInt64>:

uint8_t ATutil_convertHexaStringToInt64(const uint8_t *p_string, uint16_t size, uint32_t *high_part_value,
                                        uint32_t *low_part_value)
{
 8014d9c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8014da0:	4606      	mov	r6, r0
 8014da2:	4617      	mov	r7, r2
 8014da4:	461d      	mov	r5, r3
   * implicit input string format from "W" to "WWWWXXXXYYYYZZZZ"
   * where X,Y,W and Z are characters from '0' to 'F'
   */

  /* init decoded values */
  *high_part_value = 0U;
 8014da6:	2300      	movs	r3, #0
 8014da8:	6013      	str	r3, [r2, #0]
  *low_part_value = 0U;
 8014daa:	602b      	str	r3, [r5, #0]

  /* auto-detect if 0x is present */
  if ((size > 2U) && (p_string[1] == 120U)) /* ASCII value 120 = 'x' */
 8014dac:	2902      	cmp	r1, #2
 8014dae:	d905      	bls.n	8014dbc <ATutil_convertHexaStringToInt64+0x20>
 8014db0:	7843      	ldrb	r3, [r0, #1]
 8014db2:	2b78      	cmp	r3, #120	; 0x78
 8014db4:	d019      	beq.n	8014dea <ATutil_convertHexaStringToInt64+0x4e>
    nb_digit_ignored = 2U;
  }
  else
  {
    /* 0x is not present */
    nb_digit_ignored = 0U;
 8014db6:	f04f 0800 	mov.w	r8, #0
 8014dba:	e001      	b.n	8014dc0 <ATutil_convertHexaStringToInt64+0x24>
 8014dbc:	f04f 0800 	mov.w	r8, #0
  }

  /* if 0x is present, we can skip it */
  str_size_to_convert = size - nb_digit_ignored;
 8014dc0:	eba1 0108 	sub.w	r1, r1, r8
 8014dc4:	b28c      	uxth	r4, r1

  /* check maximum string size */
  if (str_size_to_convert > MAX_64BITS_STRING_SIZE)
 8014dc6:	2c10      	cmp	r4, #16
 8014dc8:	d81d      	bhi.n	8014e06 <ATutil_convertHexaStringToInt64+0x6a>
    /* conversion error */
    retval = 0U;
  }
  else
  {
    if (str_size_to_convert > 8U)
 8014dca:	2c08      	cmp	r4, #8
 8014dcc:	d810      	bhi.n	8014df0 <ATutil_convertHexaStringToInt64+0x54>
      *high_part_value = ATutil_convertHexaStringToInt32((const uint8_t *)(p_string + nb_digit_ignored),
                                                         high_part_size);
    }
    else
    {
      high_part_size = 0U;
 8014dce:	f04f 0900 	mov.w	r9, #0
    }

    /* convert lower part */
    low_part_size = str_size_to_convert - high_part_size;
 8014dd2:	eba4 0109 	sub.w	r1, r4, r9
    *low_part_value =  ATutil_convertHexaStringToInt32((const uint8_t *)(p_string + nb_digit_ignored + high_part_size),
 8014dd6:	eb08 0009 	add.w	r0, r8, r9
 8014dda:	b289      	uxth	r1, r1
 8014ddc:	4430      	add	r0, r6
 8014dde:	f7ff ff4d 	bl	8014c7c <ATutil_convertHexaStringToInt32>
 8014de2:	6028      	str	r0, [r5, #0]
                                                       low_part_size);

    /* string successfully converted */
    retval = 1U;
 8014de4:	2001      	movs	r0, #1
  }

  return (retval);
}
 8014de6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    nb_digit_ignored = 2U;
 8014dea:	f04f 0802 	mov.w	r8, #2
 8014dee:	e7e7      	b.n	8014dc0 <ATutil_convertHexaStringToInt64+0x24>
      high_part_size = str_size_to_convert - 8U;
 8014df0:	f1a4 0908 	sub.w	r9, r4, #8
 8014df4:	fa1f f989 	uxth.w	r9, r9
      *high_part_value = ATutil_convertHexaStringToInt32((const uint8_t *)(p_string + nb_digit_ignored),
 8014df8:	4649      	mov	r1, r9
 8014dfa:	eb06 0008 	add.w	r0, r6, r8
 8014dfe:	f7ff ff3d 	bl	8014c7c <ATutil_convertHexaStringToInt32>
 8014e02:	6038      	str	r0, [r7, #0]
 8014e04:	e7e5      	b.n	8014dd2 <ATutil_convertHexaStringToInt64+0x36>
    retval = 0U;
 8014e06:	2000      	movs	r0, #0
 8014e08:	e7ed      	b.n	8014de6 <ATutil_convertHexaStringToInt64+0x4a>

08014e0a <ATutil_convertBinStringToInt32>:

uint32_t ATutil_convertBinStringToInt32(const uint8_t *p_string, uint16_t size)
{
 8014e0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014e0e:	4607      	mov	r7, r0
 8014e10:	460d      	mov	r5, r1
  uint32_t conv_nbr = 0U; /* returned value = converted numder (returns 0 if an error occurs) */

  for (uint16_t i = 0; i < size; i++)
 8014e12:	2400      	movs	r4, #0
  uint32_t conv_nbr = 0U; /* returned value = converted numder (returns 0 if an error occurs) */
 8014e14:	4626      	mov	r6, r4
  for (uint16_t i = 0; i < size; i++)
 8014e16:	e009      	b.n	8014e2c <ATutil_convertBinStringToInt32+0x22>
  {
    /* convert ASCII character to its value (0x31 for 1, 0x30 for 0) */
    uint32_t bit = (p_string[size - i - 1U] == 0x31U) ? 1U : 0U;
 8014e18:	f04f 0801 	mov.w	r8, #1
    /* bit weight */
    uint32_t weight = ATutil_ipow(2U, i);
 8014e1c:	4621      	mov	r1, r4
 8014e1e:	2002      	movs	r0, #2
 8014e20:	f7ff ff1e 	bl	8014c60 <ATutil_ipow>
    conv_nbr += bit * weight;
 8014e24:	fb00 6608 	mla	r6, r0, r8, r6
  for (uint16_t i = 0; i < size; i++)
 8014e28:	3401      	adds	r4, #1
 8014e2a:	b2a4      	uxth	r4, r4
 8014e2c:	42ac      	cmp	r4, r5
 8014e2e:	d208      	bcs.n	8014e42 <ATutil_convertBinStringToInt32+0x38>
    uint32_t bit = (p_string[size - i - 1U] == 0x31U) ? 1U : 0U;
 8014e30:	1b2b      	subs	r3, r5, r4
 8014e32:	443b      	add	r3, r7
 8014e34:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 8014e38:	2b31      	cmp	r3, #49	; 0x31
 8014e3a:	d0ed      	beq.n	8014e18 <ATutil_convertBinStringToInt32+0xe>
 8014e3c:	f04f 0800 	mov.w	r8, #0
 8014e40:	e7ec      	b.n	8014e1c <ATutil_convertBinStringToInt32+0x12>
  }

  return (conv_nbr);
}
 8014e42:	4630      	mov	r0, r6
 8014e44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08014e48 <ATutil_convertStringToUpperCase>:
  }
  return (isneg);
}

void ATutil_convertStringToUpperCase(uint8_t *p_string, uint16_t size)
{
 8014e48:	b500      	push	{lr}
  uint16_t idx = 0U;
 8014e4a:	2300      	movs	r3, #0
  while ((p_string[idx] != 0U) && (idx < size))
 8014e4c:	e001      	b.n	8014e52 <ATutil_convertStringToUpperCase+0xa>
    if ((p_string[idx] >= 97U) && (p_string[idx] <= 122U))
    {
      /* ...convert it to uppercase character */
      p_string[idx] -= 32U;
    }
    idx++;
 8014e4e:	3301      	adds	r3, #1
 8014e50:	b29b      	uxth	r3, r3
  while ((p_string[idx] != 0U) && (idx < size))
 8014e52:	eb00 0e03 	add.w	lr, r0, r3
 8014e56:	5cc2      	ldrb	r2, [r0, r3]
 8014e58:	b162      	cbz	r2, 8014e74 <ATutil_convertStringToUpperCase+0x2c>
 8014e5a:	428b      	cmp	r3, r1
 8014e5c:	d20a      	bcs.n	8014e74 <ATutil_convertStringToUpperCase+0x2c>
    if ((p_string[idx] >= 97U) && (p_string[idx] <= 122U))
 8014e5e:	f1a2 0c61 	sub.w	ip, r2, #97	; 0x61
 8014e62:	fa5f fc8c 	uxtb.w	ip, ip
 8014e66:	f1bc 0f19 	cmp.w	ip, #25
 8014e6a:	d8f0      	bhi.n	8014e4e <ATutil_convertStringToUpperCase+0x6>
      p_string[idx] -= 32U;
 8014e6c:	3a20      	subs	r2, #32
 8014e6e:	f88e 2000 	strb.w	r2, [lr]
 8014e72:	e7ec      	b.n	8014e4e <ATutil_convertStringToUpperCase+0x6>
  }
}
 8014e74:	f85d fb04 	ldr.w	pc, [sp], #4

08014e78 <ATutil_convert_uint8_to_binary_string>:
uint8_t ATutil_convert_uint8_to_binary_string(uint32_t value, uint8_t nbBits, uint8_t sizeStr, uint8_t *binStr)
{
  uint8_t retval;

  /* String need to be at least one character more than the number of bits */
  if (sizeStr > nbBits)
 8014e78:	428a      	cmp	r2, r1
 8014e7a:	d81a      	bhi.n	8014eb2 <ATutil_convert_uint8_to_binary_string+0x3a>
    binStr[nbBits] = 0U;
    retval = 0U;
  }
  else
  {
    retval = 1U;
 8014e7c:	2001      	movs	r0, #1
 8014e7e:	4770      	bx	lr
      binStr[nbBits - i - 1U] = (((value >> i) % 2U) == 0U) ? 0x30U : 0x31U;
 8014e80:	f04f 0e31 	mov.w	lr, #49	; 0x31
 8014e84:	eba1 0c0c 	sub.w	ip, r1, ip
 8014e88:	f10c 3cff 	add.w	ip, ip, #4294967295
 8014e8c:	f803 e00c 	strb.w	lr, [r3, ip]
    for (uint8_t i = 0U; i < nbBits; i++)
 8014e90:	3201      	adds	r2, #1
 8014e92:	b2d2      	uxtb	r2, r2
 8014e94:	428a      	cmp	r2, r1
 8014e96:	d208      	bcs.n	8014eaa <ATutil_convert_uint8_to_binary_string+0x32>
      binStr[nbBits - i - 1U] = (((value >> i) % 2U) == 0U) ? 0x30U : 0x31U;
 8014e98:	4694      	mov	ip, r2
 8014e9a:	fa20 fe02 	lsr.w	lr, r0, r2
 8014e9e:	f01e 0f01 	tst.w	lr, #1
 8014ea2:	d1ed      	bne.n	8014e80 <ATutil_convert_uint8_to_binary_string+0x8>
 8014ea4:	f04f 0e30 	mov.w	lr, #48	; 0x30
 8014ea8:	e7ec      	b.n	8014e84 <ATutil_convert_uint8_to_binary_string+0xc>
    binStr[nbBits] = 0U;
 8014eaa:	2000      	movs	r0, #0
 8014eac:	5458      	strb	r0, [r3, r1]
  }

  return (retval);
}
 8014eae:	f85d fb04 	ldr.w	pc, [sp], #4
    for (uint8_t i = 0U; i < nbBits; i++)
 8014eb2:	2200      	movs	r2, #0
 8014eb4:	428a      	cmp	r2, r1
 8014eb6:	d201      	bcs.n	8014ebc <ATutil_convert_uint8_to_binary_string+0x44>
{
 8014eb8:	b500      	push	{lr}
 8014eba:	e7ed      	b.n	8014e98 <ATutil_convert_uint8_to_binary_string+0x20>
    binStr[nbBits] = 0U;
 8014ebc:	2000      	movs	r0, #0
 8014ebe:	5458      	strb	r0, [r3, r1]
}
 8014ec0:	4770      	bx	lr

08014ec2 <ATutil_remove_quotes>:
  * @param  p_Dst ptr to Destination Buffer (string without quotes)
  * @param  dstSize of p_Dst buffer
  * @retval size of destination string (util part).
  */
uint16_t ATutil_remove_quotes(const uint8_t *p_Src, uint16_t srcSize, uint8_t *p_Dst, uint16_t dstSize)
{
 8014ec2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014ec4:	4606      	mov	r6, r0
 8014ec6:	460d      	mov	r5, r1
 8014ec8:	4617      	mov	r7, r2
 8014eca:	461c      	mov	r4, r3
  uint16_t src_idx;
  uint16_t dest_idx = 0U;

  /* reset p_Dst buffer */
  (void) memset((void *)p_Dst, 0, dstSize);
 8014ecc:	461a      	mov	r2, r3
 8014ece:	2100      	movs	r1, #0
 8014ed0:	4638      	mov	r0, r7
 8014ed2:	f011 fd2c 	bl	802692e <memset>
  uint16_t dest_idx = 0U;
 8014ed6:	2000      	movs	r0, #0

  /* parse p_Src */
  for (src_idx = 0; ((src_idx < srcSize) && (dest_idx < dstSize)); src_idx++)
 8014ed8:	4684      	mov	ip, r0
 8014eda:	e003      	b.n	8014ee4 <ATutil_remove_quotes+0x22>
 8014edc:	f10c 0c01 	add.w	ip, ip, #1
 8014ee0:	fa1f fc8c 	uxth.w	ip, ip
 8014ee4:	45ac      	cmp	ip, r5
 8014ee6:	d209      	bcs.n	8014efc <ATutil_remove_quotes+0x3a>
 8014ee8:	42a0      	cmp	r0, r4
 8014eea:	d207      	bcs.n	8014efc <ATutil_remove_quotes+0x3a>
  {
    /* remove quotes from the string */
    if (p_Src[src_idx] != 0x22U)
 8014eec:	f816 300c 	ldrb.w	r3, [r6, ip]
 8014ef0:	2b22      	cmp	r3, #34	; 0x22
 8014ef2:	d0f3      	beq.n	8014edc <ATutil_remove_quotes+0x1a>
    {
      /* write to p_Dst*/
      p_Dst[dest_idx] = p_Src[src_idx];
 8014ef4:	543b      	strb	r3, [r7, r0]
      dest_idx++;
 8014ef6:	3001      	adds	r0, #1
 8014ef8:	b280      	uxth	r0, r0
 8014efa:	e7ef      	b.n	8014edc <ATutil_remove_quotes+0x1a>
    }
  }

  return (dest_idx);
}
 8014efc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08014f00 <SysCtrl_getDeviceDescriptor>:
sysctrl_status_t SysCtrl_getDeviceDescriptor(sysctrl_device_type_t device_type, sysctrl_info_t *p_devices_list)
{
  sysctrl_status_t retval;

  /* check input parameters validity */
  if (p_devices_list == NULL)
 8014f00:	b1b9      	cbz	r1, 8014f32 <SysCtrl_getDeviceDescriptor+0x32>
{
 8014f02:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014f04:	4604      	mov	r4, r0
 8014f06:	460d      	mov	r5, r1
    retval = SCSTATUS_ERROR;
  }
  else
  {
    /* check if device is already initialized */
    if (sysctrl_custom_func[device_type].initialized == 0U)
 8014f08:	0143      	lsls	r3, r0, #5
 8014f0a:	4a0b      	ldr	r2, [pc, #44]	; (8014f38 <SysCtrl_getDeviceDescriptor+0x38>)
 8014f0c:	5cd3      	ldrb	r3, [r2, r3]
 8014f0e:	b13b      	cbz	r3, 8014f20 <SysCtrl_getDeviceDescriptor+0x20>
      (void) atcma_init_sysctrl_func_ptrs(&sysctrl_custom_func[device_type]);

      /* device is initialized now */
      sysctrl_custom_func[device_type].initialized = 1U;
    }
    retval = (*sysctrl_custom_func[device_type].f_getDeviceDescriptor)(device_type, p_devices_list);
 8014f10:	4b09      	ldr	r3, [pc, #36]	; (8014f38 <SysCtrl_getDeviceDescriptor+0x38>)
 8014f12:	eb03 1344 	add.w	r3, r3, r4, lsl #5
 8014f16:	685b      	ldr	r3, [r3, #4]
 8014f18:	4629      	mov	r1, r5
 8014f1a:	4620      	mov	r0, r4
 8014f1c:	4798      	blx	r3
  }

  return (retval);
}
 8014f1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      (void) atcma_init_sysctrl_func_ptrs(&sysctrl_custom_func[device_type]);
 8014f20:	4617      	mov	r7, r2
 8014f22:	0146      	lsls	r6, r0, #5
 8014f24:	eb02 1040 	add.w	r0, r2, r0, lsl #5
 8014f28:	f7ed f98e 	bl	8002248 <atcma_init_sysctrl_func_ptrs>
      sysctrl_custom_func[device_type].initialized = 1U;
 8014f2c:	2301      	movs	r3, #1
 8014f2e:	55bb      	strb	r3, [r7, r6]
 8014f30:	e7ee      	b.n	8014f10 <SysCtrl_getDeviceDescriptor+0x10>
    retval = SCSTATUS_ERROR;
 8014f32:	2001      	movs	r0, #1
}
 8014f34:	4770      	bx	lr
 8014f36:	bf00      	nop
 8014f38:	200035fc 	.word	0x200035fc

08014f3c <SysCtrl_open_channel>:
  * @brief  SysCtrl_open_channel
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_open_channel(sysctrl_device_type_t device_type)
{
 8014f3c:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8014f3e:	0143      	lsls	r3, r0, #5
 8014f40:	4a11      	ldr	r2, [pc, #68]	; (8014f88 <SysCtrl_open_channel+0x4c>)
 8014f42:	5cd3      	ldrb	r3, [r2, r3]
 8014f44:	2b01      	cmp	r3, #1
 8014f46:	d104      	bne.n	8014f52 <SysCtrl_open_channel+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_open_channel)(device_type);
 8014f48:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8014f4c:	689b      	ldr	r3, [r3, #8]
 8014f4e:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8014f50:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 8014f52:	4c0e      	ldr	r4, [pc, #56]	; (8014f8c <SysCtrl_open_channel+0x50>)
 8014f54:	4602      	mov	r2, r0
 8014f56:	490e      	ldr	r1, [pc, #56]	; (8014f90 <SysCtrl_open_channel+0x54>)
 8014f58:	4620      	mov	r0, r4
 8014f5a:	f011 fc75 	bl	8026848 <sprintf>
 8014f5e:	4620      	mov	r0, r4
 8014f60:	f00a f9e3 	bl	801f32a <crs_strlen>
 8014f64:	b283      	uxth	r3, r0
 8014f66:	4622      	mov	r2, r4
 8014f68:	2110      	movs	r1, #16
 8014f6a:	2002      	movs	r0, #2
 8014f6c:	f00a fa20 	bl	801f3b0 <traceIF_itmPrint>
 8014f70:	4620      	mov	r0, r4
 8014f72:	f00a f9da 	bl	801f32a <crs_strlen>
 8014f76:	b283      	uxth	r3, r0
 8014f78:	4622      	mov	r2, r4
 8014f7a:	2110      	movs	r1, #16
 8014f7c:	2002      	movs	r0, #2
 8014f7e:	f00a fa39 	bl	801f3f4 <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 8014f82:	2001      	movs	r0, #1
 8014f84:	e7e4      	b.n	8014f50 <SysCtrl_open_channel+0x14>
 8014f86:	bf00      	nop
 8014f88:	200035fc 	.word	0x200035fc
 8014f8c:	200048dc 	.word	0x200048dc
 8014f90:	080318f8 	.word	0x080318f8

08014f94 <SysCtrl_close_channel>:
  * @brief  SysCtrl_close_channel
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_close_channel(sysctrl_device_type_t device_type)
{
 8014f94:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8014f96:	0143      	lsls	r3, r0, #5
 8014f98:	4a11      	ldr	r2, [pc, #68]	; (8014fe0 <SysCtrl_close_channel+0x4c>)
 8014f9a:	5cd3      	ldrb	r3, [r2, r3]
 8014f9c:	2b01      	cmp	r3, #1
 8014f9e:	d104      	bne.n	8014faa <SysCtrl_close_channel+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_close_channel)(device_type);
 8014fa0:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8014fa4:	68db      	ldr	r3, [r3, #12]
 8014fa6:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8014fa8:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 8014faa:	4c0e      	ldr	r4, [pc, #56]	; (8014fe4 <SysCtrl_close_channel+0x50>)
 8014fac:	4602      	mov	r2, r0
 8014fae:	490e      	ldr	r1, [pc, #56]	; (8014fe8 <SysCtrl_close_channel+0x54>)
 8014fb0:	4620      	mov	r0, r4
 8014fb2:	f011 fc49 	bl	8026848 <sprintf>
 8014fb6:	4620      	mov	r0, r4
 8014fb8:	f00a f9b7 	bl	801f32a <crs_strlen>
 8014fbc:	b283      	uxth	r3, r0
 8014fbe:	4622      	mov	r2, r4
 8014fc0:	2110      	movs	r1, #16
 8014fc2:	2002      	movs	r0, #2
 8014fc4:	f00a f9f4 	bl	801f3b0 <traceIF_itmPrint>
 8014fc8:	4620      	mov	r0, r4
 8014fca:	f00a f9ae 	bl	801f32a <crs_strlen>
 8014fce:	b283      	uxth	r3, r0
 8014fd0:	4622      	mov	r2, r4
 8014fd2:	2110      	movs	r1, #16
 8014fd4:	2002      	movs	r0, #2
 8014fd6:	f00a fa0d 	bl	801f3f4 <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 8014fda:	2001      	movs	r0, #1
 8014fdc:	e7e4      	b.n	8014fa8 <SysCtrl_close_channel+0x14>
 8014fde:	bf00      	nop
 8014fe0:	200035fc 	.word	0x200035fc
 8014fe4:	200048dc 	.word	0x200048dc
 8014fe8:	080318f8 	.word	0x080318f8

08014fec <SysCtrl_power_on>:
  * @brief  SysCtrl_power_on
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_power_on(sysctrl_device_type_t device_type)
{
 8014fec:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8014fee:	0143      	lsls	r3, r0, #5
 8014ff0:	4a11      	ldr	r2, [pc, #68]	; (8015038 <SysCtrl_power_on+0x4c>)
 8014ff2:	5cd3      	ldrb	r3, [r2, r3]
 8014ff4:	2b01      	cmp	r3, #1
 8014ff6:	d104      	bne.n	8015002 <SysCtrl_power_on+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_power_on)(device_type);
 8014ff8:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8014ffc:	691b      	ldr	r3, [r3, #16]
 8014ffe:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8015000:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 8015002:	4c0e      	ldr	r4, [pc, #56]	; (801503c <SysCtrl_power_on+0x50>)
 8015004:	4602      	mov	r2, r0
 8015006:	490e      	ldr	r1, [pc, #56]	; (8015040 <SysCtrl_power_on+0x54>)
 8015008:	4620      	mov	r0, r4
 801500a:	f011 fc1d 	bl	8026848 <sprintf>
 801500e:	4620      	mov	r0, r4
 8015010:	f00a f98b 	bl	801f32a <crs_strlen>
 8015014:	b283      	uxth	r3, r0
 8015016:	4622      	mov	r2, r4
 8015018:	2110      	movs	r1, #16
 801501a:	2002      	movs	r0, #2
 801501c:	f00a f9c8 	bl	801f3b0 <traceIF_itmPrint>
 8015020:	4620      	mov	r0, r4
 8015022:	f00a f982 	bl	801f32a <crs_strlen>
 8015026:	b283      	uxth	r3, r0
 8015028:	4622      	mov	r2, r4
 801502a:	2110      	movs	r1, #16
 801502c:	2002      	movs	r0, #2
 801502e:	f00a f9e1 	bl	801f3f4 <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 8015032:	2001      	movs	r0, #1
 8015034:	e7e4      	b.n	8015000 <SysCtrl_power_on+0x14>
 8015036:	bf00      	nop
 8015038:	200035fc 	.word	0x200035fc
 801503c:	200048dc 	.word	0x200048dc
 8015040:	080318f8 	.word	0x080318f8

08015044 <SysCtrl_power_off>:
  * @brief  SysCtrl_power_off
  * @param  device_type
  * @retval sysctrl_status_t
  */
sysctrl_status_t SysCtrl_power_off(sysctrl_device_type_t device_type)
{
 8015044:	b510      	push	{r4, lr}
  sysctrl_status_t retval = SCSTATUS_ERROR;

  /* check if device is initialized */
  if (sysctrl_custom_func[device_type].initialized == 1U)
 8015046:	0143      	lsls	r3, r0, #5
 8015048:	4a11      	ldr	r2, [pc, #68]	; (8015090 <SysCtrl_power_off+0x4c>)
 801504a:	5cd3      	ldrb	r3, [r2, r3]
 801504c:	2b01      	cmp	r3, #1
 801504e:	d104      	bne.n	801505a <SysCtrl_power_off+0x16>
  {
    retval = (*sysctrl_custom_func[device_type].f_power_off)(device_type);
 8015050:	eb02 1340 	add.w	r3, r2, r0, lsl #5
 8015054:	695b      	ldr	r3, [r3, #20]
 8015056:	4798      	blx	r3
  {
    PRINT_ERR("Device type %d is not initialized", device_type)
  }

  return (retval);
}
 8015058:	bd10      	pop	{r4, pc}
    PRINT_ERR("Device type %d is not initialized", device_type)
 801505a:	4c0e      	ldr	r4, [pc, #56]	; (8015094 <SysCtrl_power_off+0x50>)
 801505c:	4602      	mov	r2, r0
 801505e:	490e      	ldr	r1, [pc, #56]	; (8015098 <SysCtrl_power_off+0x54>)
 8015060:	4620      	mov	r0, r4
 8015062:	f011 fbf1 	bl	8026848 <sprintf>
 8015066:	4620      	mov	r0, r4
 8015068:	f00a f95f 	bl	801f32a <crs_strlen>
 801506c:	b283      	uxth	r3, r0
 801506e:	4622      	mov	r2, r4
 8015070:	2110      	movs	r1, #16
 8015072:	2002      	movs	r0, #2
 8015074:	f00a f99c 	bl	801f3b0 <traceIF_itmPrint>
 8015078:	4620      	mov	r0, r4
 801507a:	f00a f956 	bl	801f32a <crs_strlen>
 801507e:	b283      	uxth	r3, r0
 8015080:	4622      	mov	r2, r4
 8015082:	2110      	movs	r1, #16
 8015084:	2002      	movs	r0, #2
 8015086:	f00a f9b5 	bl	801f3f4 <traceIF_uartPrint>
  sysctrl_status_t retval = SCSTATUS_ERROR;
 801508a:	2001      	movs	r0, #1
 801508c:	e7e4      	b.n	8015058 <SysCtrl_power_off+0x14>
 801508e:	bf00      	nop
 8015090:	200035fc 	.word	0x200035fc
 8015094:	200048dc 	.word	0x200048dc
 8015098:	080318f8 	.word	0x080318f8

0801509c <SysCtrl_delay>:
  * @param  timeMs
  * @retval none
  */
void SysCtrl_delay(uint32_t timeMs)
{
  if (timeMs != 0U)
 801509c:	b900      	cbnz	r0, 80150a0 <SysCtrl_delay+0x4>
 801509e:	4770      	bx	lr
{
 80150a0:	b508      	push	{r3, lr}
  {
#if (RTOS_USED == 1)
    (void) rtosalDelay(timeMs);
 80150a2:	f00a f89a 	bl	801f1da <rtosalDelay>
#else
    HAL_Delay(timeMs);
#endif /* RTOS_USED */
  }
}
 80150a6:	bd08      	pop	{r3, pc}

080150a8 <CELLULAR_reset_context>:
}

static void CELLULAR_reset_context(void)
{
  /* init cs_ctxt_urc_subscription */
  cs_ctxt_urc_subscription.eps_network_registration = CELLULAR_FALSE;
 80150a8:	4a10      	ldr	r2, [pc, #64]	; (80150ec <CELLULAR_reset_context+0x44>)
 80150aa:	2300      	movs	r3, #0
 80150ac:	7013      	strb	r3, [r2, #0]
  cs_ctxt_urc_subscription.gprs_network_registration = CELLULAR_FALSE;
 80150ae:	7053      	strb	r3, [r2, #1]
  cs_ctxt_urc_subscription.cs_network_registration = CELLULAR_FALSE;
 80150b0:	7093      	strb	r3, [r2, #2]
  cs_ctxt_urc_subscription.eps_location_info = CELLULAR_FALSE;
 80150b2:	70d3      	strb	r3, [r2, #3]
  cs_ctxt_urc_subscription.gprs_location_info = CELLULAR_FALSE;
 80150b4:	7113      	strb	r3, [r2, #4]
  cs_ctxt_urc_subscription.cs_location_info = CELLULAR_FALSE;
 80150b6:	7153      	strb	r3, [r2, #5]
  cs_ctxt_urc_subscription.signal_quality = CELLULAR_FALSE;
 80150b8:	7193      	strb	r3, [r2, #6]
  cs_ctxt_urc_subscription.packet_domain_event = CELLULAR_FALSE;
 80150ba:	71d3      	strb	r3, [r2, #7]
  cs_ctxt_urc_subscription.ping_rsp = CELLULAR_FALSE;
 80150bc:	7213      	strb	r3, [r2, #8]

  /* init cs_ctxt_eps_location_info */
  cs_ctxt_eps_location_info.ci = 0U;
 80150be:	4a0c      	ldr	r2, [pc, #48]	; (80150f0 <CELLULAR_reset_context+0x48>)
 80150c0:	6013      	str	r3, [r2, #0]
  cs_ctxt_eps_location_info.lac = 0U;
 80150c2:	8093      	strh	r3, [r2, #4]
  cs_ctxt_eps_location_info.ci_updated = CELLULAR_FALSE;
 80150c4:	7193      	strb	r3, [r2, #6]
  cs_ctxt_eps_location_info.lac_updated = CELLULAR_FALSE;
 80150c6:	71d3      	strb	r3, [r2, #7]

  /* init cs_ctxt_gprs_location_info */
  cs_ctxt_gprs_location_info.ci = 0U;
 80150c8:	4a0a      	ldr	r2, [pc, #40]	; (80150f4 <CELLULAR_reset_context+0x4c>)
 80150ca:	6013      	str	r3, [r2, #0]
  cs_ctxt_gprs_location_info.lac = 0U;
 80150cc:	8093      	strh	r3, [r2, #4]
  cs_ctxt_gprs_location_info.ci_updated = CELLULAR_FALSE;
 80150ce:	7193      	strb	r3, [r2, #6]
  cs_ctxt_gprs_location_info.lac_updated = CELLULAR_FALSE;
 80150d0:	71d3      	strb	r3, [r2, #7]

  /* init cs_ctxt_cs_location_info */
  cs_ctxt_cs_location_info.ci = 0U;
 80150d2:	4a09      	ldr	r2, [pc, #36]	; (80150f8 <CELLULAR_reset_context+0x50>)
 80150d4:	6013      	str	r3, [r2, #0]
  cs_ctxt_cs_location_info.lac = 0U;
 80150d6:	8093      	strh	r3, [r2, #4]
  cs_ctxt_cs_location_info.ci_updated = CELLULAR_FALSE;
 80150d8:	7193      	strb	r3, [r2, #6]
  cs_ctxt_cs_location_info.lac_updated = CELLULAR_FALSE;
 80150da:	71d3      	strb	r3, [r2, #7]

  /* init network states */
  cs_ctxt_eps_network_reg_state = CS_NRS_UNKNOWN;
 80150dc:	2304      	movs	r3, #4
 80150de:	4a07      	ldr	r2, [pc, #28]	; (80150fc <CELLULAR_reset_context+0x54>)
 80150e0:	8013      	strh	r3, [r2, #0]
  cs_ctxt_gprs_network_reg_state = CS_NRS_UNKNOWN;
 80150e2:	4a07      	ldr	r2, [pc, #28]	; (8015100 <CELLULAR_reset_context+0x58>)
 80150e4:	8013      	strh	r3, [r2, #0]
  cs_ctxt_cs_network_reg_state = CS_NRS_UNKNOWN;
 80150e6:	4a07      	ldr	r2, [pc, #28]	; (8015104 <CELLULAR_reset_context+0x5c>)
 80150e8:	8013      	strh	r3, [r2, #0]
}
 80150ea:	4770      	bx	lr
 80150ec:	20003804 	.word	0x20003804
 80150f0:	200037ac 	.word	0x200037ac
 80150f4:	200037b4 	.word	0x200037b4
 80150f8:	200036a0 	.word	0x200036a0
 80150fc:	20000042 	.word	0x20000042
 8015100:	20000044 	.word	0x20000044
 8015104:	20000040 	.word	0x20000040

08015108 <CELLULAR_idle_event_notif>:
  {
    /* inform client that an event has been received */
    (* register_event_callback)(eventReceived);
  }
#endif /* RTOS_USED */
}
 8015108:	4770      	bx	lr

0801510a <convert_SIM_error>:
static CS_Status_t convert_SIM_error(const csint_error_report_t *p_error_report)
{
  CS_Status_t retval;

  /* convert SIM state to Cellular Service error returned to the client */
  switch (p_error_report->sim_state)
 801510a:	7840      	ldrb	r0, [r0, #1]
 801510c:	1e83      	subs	r3, r0, #2
 801510e:	2b08      	cmp	r3, #8
 8015110:	d80e      	bhi.n	8015130 <convert_SIM_error+0x26>
 8015112:	e8df f003 	tbb	[pc, r3]
 8015116:	0e05      	.short	0x0e05
 8015118:	09090707 	.word	0x09090707
 801511c:	0909      	.short	0x0909
 801511e:	0b          	.byte	0x0b
 801511f:	00          	.byte	0x00
 8015120:	2004      	movs	r0, #4
 8015122:	4770      	bx	lr
    case CS_SIMSTATE_SIM_BUSY:
      retval = CELLULAR_SIM_BUSY;
      break;
    case CS_SIMSTATE_SIM_WRONG:
    case CS_SIMSTATE_SIM_FAILURE:
      retval = CELLULAR_SIM_ERROR;
 8015124:	2007      	movs	r0, #7
      break;
 8015126:	4770      	bx	lr
    case CS_SIMSTATE_SIM_PIN_REQUIRED:
    case CS_SIMSTATE_SIM_PIN2_REQUIRED:
    case CS_SIMSTATE_SIM_PUK_REQUIRED:
    case CS_SIMSTATE_SIM_PUK2_REQUIRED:
      retval = CELLULAR_SIM_PIN_OR_PUK_LOCKED;
 8015128:	2005      	movs	r0, #5
      break;
 801512a:	4770      	bx	lr
    case CS_SIMSTATE_INCORRECT_PASSWORD:
      retval = CELLULAR_SIM_INCORRECT_PASSWORD;
 801512c:	2006      	movs	r0, #6
      break;
 801512e:	4770      	bx	lr
    default:
      retval = CELLULAR_SIM_ERROR;
 8015130:	2007      	movs	r0, #7
      break;
  }
  return (retval);
}
 8015132:	4770      	bx	lr

08015134 <convert_to_PDN_event>:

static CS_PDN_event_t convert_to_PDN_event(csint_PDN_event_desc_t event_desc)
{
 8015134:	b082      	sub	sp, #8
 8015136:	9001      	str	r0, [sp, #4]
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;

  if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015138:	f89d 0004 	ldrb.w	r0, [sp, #4]
 801513c:	2801      	cmp	r0, #1
 801513e:	d006      	beq.n	801514e <convert_to_PDN_event+0x1a>
      (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
      (event_desc.event_type == CGEV_EVENT_TYPE_DETACH))
  {
    ret = CS_PDN_EVENT_NW_DETACH;
  }
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015140:	2801      	cmp	r0, #1
 8015142:	d00d      	beq.n	8015160 <convert_to_PDN_event+0x2c>
           (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
           (event_desc.event_type == CGEV_EVENT_TYPE_DEACTIVATION))
  {
    ret = CS_PDN_EVENT_NW_DEACT;
  }
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015144:	2801      	cmp	r0, #1
 8015146:	d015      	beq.n	8015174 <convert_to_PDN_event+0x40>
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;
 8015148:	2000      	movs	r0, #0
  {
    /* ignored */
  }

  return (ret);
}
 801514a:	b002      	add	sp, #8
 801514c:	4770      	bx	lr
      (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 801514e:	f89d 3005 	ldrb.w	r3, [sp, #5]
  if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015152:	2b0b      	cmp	r3, #11
 8015154:	d1f4      	bne.n	8015140 <convert_to_PDN_event+0xc>
      (event_desc.event_type == CGEV_EVENT_TYPE_DETACH))
 8015156:	f89d 3006 	ldrb.w	r3, [sp, #6]
      (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 801515a:	2b0f      	cmp	r3, #15
 801515c:	d1f0      	bne.n	8015140 <convert_to_PDN_event+0xc>
 801515e:	e7f4      	b.n	801514a <convert_to_PDN_event+0x16>
           (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 8015160:	f89d 3005 	ldrb.w	r3, [sp, #5]
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015164:	2b0b      	cmp	r3, #11
 8015166:	d1ed      	bne.n	8015144 <convert_to_PDN_event+0x10>
           (event_desc.event_type == CGEV_EVENT_TYPE_DEACTIVATION))
 8015168:	f89d 3006 	ldrb.w	r3, [sp, #6]
           (event_desc.event_scope == CGEV_EVENT_SCOPE_GLOBAL) &&
 801516c:	2b0d      	cmp	r3, #13
 801516e:	d1e9      	bne.n	8015144 <convert_to_PDN_event+0x10>
    ret = CS_PDN_EVENT_NW_DEACT;
 8015170:	2002      	movs	r0, #2
 8015172:	e7ea      	b.n	801514a <convert_to_PDN_event+0x16>
           (event_desc.event_scope == CGEV_EVENT_SCOPE_PDN) &&
 8015174:	f89d 3005 	ldrb.w	r3, [sp, #5]
  else if ((event_desc.event_origine == CGEV_EVENT_ORIGINE_NW) &&
 8015178:	2b0a      	cmp	r3, #10
 801517a:	d001      	beq.n	8015180 <convert_to_PDN_event+0x4c>
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;
 801517c:	2000      	movs	r0, #0
 801517e:	e7e4      	b.n	801514a <convert_to_PDN_event+0x16>
           (event_desc.event_type == CGEV_EVENT_TYPE_DEACTIVATION))
 8015180:	f89d 3006 	ldrb.w	r3, [sp, #6]
           (event_desc.event_scope == CGEV_EVENT_SCOPE_PDN) &&
 8015184:	2b0d      	cmp	r3, #13
 8015186:	d001      	beq.n	801518c <convert_to_PDN_event+0x58>
  CS_PDN_event_t ret = CS_PDN_EVENT_OTHER;
 8015188:	2000      	movs	r0, #0
 801518a:	e7de      	b.n	801514a <convert_to_PDN_event+0x16>
    ret = CS_PDN_EVENT_NW_PDN_DEACT;
 801518c:	2003      	movs	r0, #3
 801518e:	e7dc      	b.n	801514a <convert_to_PDN_event+0x16>

08015190 <convert_index_to_PDN_conf>:

static CS_PDN_conf_id_t convert_index_to_PDN_conf(uint8_t index)
{
  CS_PDN_conf_id_t PDNconf;
  switch (index)
 8015190:	2805      	cmp	r0, #5
 8015192:	d804      	bhi.n	801519e <convert_index_to_PDN_conf+0xe>
 8015194:	e8df f000 	tbb	[pc, r0]
 8015198:	04040404 	.word	0x04040404
 801519c:	0404      	.short	0x0404
      break;
    case 5:
      PDNconf = CS_PDN_USER_CONFIG_5;
      break;
    default:
      PDNconf = CS_PDN_NOT_DEFINED;
 801519e:	200c      	movs	r0, #12
      break;
  }
  return (PDNconf);
}
 80151a0:	4770      	bx	lr
	...

080151a4 <CELLULAR_urc_notif>:
{
 80151a4:	b570      	push	{r4, r5, r6, lr}
 80151a6:	b0a4      	sub	sp, #144	; 0x90
 80151a8:	4606      	mov	r6, r0
  PRINT_API("<Cellular_Service> CELLULAR_urc_notif")
 80151aa:	4cbf      	ldr	r4, [pc, #764]	; (80154a8 <CELLULAR_urc_notif+0x304>)
 80151ac:	4dbf      	ldr	r5, [pc, #764]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80151ae:	f104 0e20 	add.w	lr, r4, #32
 80151b2:	46a4      	mov	ip, r4
 80151b4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80151b8:	6028      	str	r0, [r5, #0]
 80151ba:	6069      	str	r1, [r5, #4]
 80151bc:	60aa      	str	r2, [r5, #8]
 80151be:	60eb      	str	r3, [r5, #12]
 80151c0:	4664      	mov	r4, ip
 80151c2:	3510      	adds	r5, #16
 80151c4:	45f4      	cmp	ip, lr
 80151c6:	d1f4      	bne.n	80151b2 <CELLULAR_urc_notif+0xe>
 80151c8:	4663      	mov	r3, ip
 80151ca:	cb07      	ldmia	r3!, {r0, r1, r2}
 80151cc:	6028      	str	r0, [r5, #0]
 80151ce:	6069      	str	r1, [r5, #4]
 80151d0:	60aa      	str	r2, [r5, #8]
 80151d2:	881a      	ldrh	r2, [r3, #0]
 80151d4:	789b      	ldrb	r3, [r3, #2]
 80151d6:	81aa      	strh	r2, [r5, #12]
 80151d8:	73ab      	strb	r3, [r5, #14]
 80151da:	4cb4      	ldr	r4, [pc, #720]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80151dc:	4620      	mov	r0, r4
 80151de:	f00a f8a4 	bl	801f32a <crs_strlen>
 80151e2:	b283      	uxth	r3, r0
 80151e4:	4622      	mov	r2, r4
 80151e6:	2104      	movs	r1, #4
 80151e8:	2001      	movs	r0, #1
 80151ea:	f00a f8e1 	bl	801f3b0 <traceIF_itmPrint>
 80151ee:	4620      	mov	r0, r4
 80151f0:	f00a f89b 	bl	801f32a <crs_strlen>
 80151f4:	b283      	uxth	r3, r0
 80151f6:	4622      	mov	r2, r4
 80151f8:	2104      	movs	r1, #4
 80151fa:	2001      	movs	r0, #1
 80151fc:	f00a f8fa 	bl	801f3f4 <traceIF_uartPrint>
  msgtype = DATAPACK_readMsgType(p_rsp_buf);
 8015200:	4630      	mov	r0, r6
 8015202:	f7f6 ffc5 	bl	800c190 <DATAPACK_readMsgType>
  if ((msgtype == (uint16_t) CSMT_URC_EPS_NETWORK_REGISTRATION_STATUS) &&
 8015206:	2805      	cmp	r0, #5
 8015208:	d03a      	beq.n	8015280 <CELLULAR_urc_notif+0xdc>
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_NETWORK_REGISTRATION_STATUS) &&
 801520a:	2807      	cmp	r0, #7
 801520c:	f000 8093 	beq.w	8015336 <CELLULAR_urc_notif+0x192>
  else if ((msgtype == (uint16_t) CSMT_URC_CS_NETWORK_REGISTRATION_STATUS) &&
 8015210:	2809      	cmp	r0, #9
 8015212:	f000 80eb 	beq.w	80153ec <CELLULAR_urc_notif+0x248>
  else if ((msgtype == (uint16_t) CSMT_URC_EPS_LOCATION_INFO) &&
 8015216:	2806      	cmp	r0, #6
 8015218:	f000 8166 	beq.w	80154e8 <CELLULAR_urc_notif+0x344>
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_LOCATION_INFO) &&
 801521c:	2808      	cmp	r0, #8
 801521e:	f000 81ea 	beq.w	80155f6 <CELLULAR_urc_notif+0x452>
  else if ((msgtype == (uint16_t) CSMT_URC_CS_LOCATION_INFO) &&
 8015222:	280a      	cmp	r0, #10
 8015224:	f000 826b 	beq.w	80156fe <CELLULAR_urc_notif+0x55a>
  else if ((msgtype == (uint16_t) CSMT_URC_SIGNAL_QUALITY) &&
 8015228:	280b      	cmp	r0, #11
 801522a:	f000 8307 	beq.w	801583c <CELLULAR_urc_notif+0x698>
  else if (msgtype == (uint16_t) CSMT_URC_SOCKET_DATA_PENDING)
 801522e:	280d      	cmp	r0, #13
 8015230:	f000 8336 	beq.w	80158a0 <CELLULAR_urc_notif+0x6fc>
  else if (msgtype == (uint16_t) CSMT_URC_SOCKET_CLOSED)
 8015234:	280e      	cmp	r0, #14
 8015236:	f000 834b 	beq.w	80158d0 <CELLULAR_urc_notif+0x72c>
  else if ((msgtype == (uint16_t) CSMT_URC_PACKET_DOMAIN_EVENT) &&
 801523a:	280c      	cmp	r0, #12
 801523c:	f000 8360 	beq.w	8015900 <CELLULAR_urc_notif+0x75c>
  else if (msgtype == (uint16_t) CSMT_URC_PING_RSP)
 8015240:	2810      	cmp	r0, #16
 8015242:	f000 83d2 	beq.w	80159ea <CELLULAR_urc_notif+0x846>
  else if (msgtype == (uint16_t) CSMT_URC_MODEM_EVENT)
 8015246:	280f      	cmp	r0, #15
 8015248:	f000 8412 	beq.w	8015a70 <CELLULAR_urc_notif+0x8cc>
    PRINT_DBG("ignore received URC (type=%d)", msgtype)
 801524c:	4c97      	ldr	r4, [pc, #604]	; (80154ac <CELLULAR_urc_notif+0x308>)
 801524e:	4602      	mov	r2, r0
 8015250:	4997      	ldr	r1, [pc, #604]	; (80154b0 <CELLULAR_urc_notif+0x30c>)
 8015252:	4620      	mov	r0, r4
 8015254:	f011 faf8 	bl	8026848 <sprintf>
 8015258:	4620      	mov	r0, r4
 801525a:	f00a f866 	bl	801f32a <crs_strlen>
 801525e:	b283      	uxth	r3, r0
 8015260:	4622      	mov	r2, r4
 8015262:	2102      	movs	r1, #2
 8015264:	2001      	movs	r0, #1
 8015266:	f00a f8a3 	bl	801f3b0 <traceIF_itmPrint>
 801526a:	4620      	mov	r0, r4
 801526c:	f00a f85d 	bl	801f32a <crs_strlen>
 8015270:	b283      	uxth	r3, r0
 8015272:	4622      	mov	r2, r4
 8015274:	2102      	movs	r1, #2
 8015276:	2001      	movs	r0, #1
 8015278:	f00a f8bc 	bl	801f3f4 <traceIF_uartPrint>
}
 801527c:	b024      	add	sp, #144	; 0x90
 801527e:	bd70      	pop	{r4, r5, r6, pc}
      (cs_ctxt_urc_subscription.eps_network_registration == CELLULAR_TRUE))
 8015280:	4b8c      	ldr	r3, [pc, #560]	; (80154b4 <CELLULAR_urc_notif+0x310>)
 8015282:	781b      	ldrb	r3, [r3, #0]
  if ((msgtype == (uint16_t) CSMT_URC_EPS_NETWORK_REGISTRATION_STATUS) &&
 8015284:	2b01      	cmp	r3, #1
 8015286:	d1c0      	bne.n	801520a <CELLULAR_urc_notif+0x66>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015288:	ab10      	add	r3, sp, #64	; 0x40
 801528a:	2202      	movs	r2, #2
 801528c:	2105      	movs	r1, #5
 801528e:	4630      	mov	r0, r6
 8015290:	f7f7 f830 	bl	800c2f4 <DATAPACK_readStruct>
 8015294:	2800      	cmp	r0, #0
 8015296:	d1f1      	bne.n	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_state != cs_ctxt_eps_network_reg_state)
 8015298:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 801529c:	4b86      	ldr	r3, [pc, #536]	; (80154b8 <CELLULAR_urc_notif+0x314>)
 801529e:	881b      	ldrh	r3, [r3, #0]
 80152a0:	429a      	cmp	r2, r3
 80152a2:	d01f      	beq.n	80152e4 <CELLULAR_urc_notif+0x140>
        PRINT_DBG("<Cellular_Service> EPS network registration updated: %d", rx_state)
 80152a4:	4985      	ldr	r1, [pc, #532]	; (80154bc <CELLULAR_urc_notif+0x318>)
 80152a6:	4620      	mov	r0, r4
 80152a8:	f011 face 	bl	8026848 <sprintf>
 80152ac:	4620      	mov	r0, r4
 80152ae:	f00a f83c 	bl	801f32a <crs_strlen>
 80152b2:	b283      	uxth	r3, r0
 80152b4:	4622      	mov	r2, r4
 80152b6:	2102      	movs	r1, #2
 80152b8:	2001      	movs	r0, #1
 80152ba:	f00a f879 	bl	801f3b0 <traceIF_itmPrint>
 80152be:	4620      	mov	r0, r4
 80152c0:	f00a f833 	bl	801f32a <crs_strlen>
 80152c4:	b283      	uxth	r3, r0
 80152c6:	4622      	mov	r2, r4
 80152c8:	2102      	movs	r1, #2
 80152ca:	2001      	movs	r0, #1
 80152cc:	f00a f892 	bl	801f3f4 <traceIF_uartPrint>
        cs_ctxt_eps_network_reg_state = rx_state;
 80152d0:	4b79      	ldr	r3, [pc, #484]	; (80154b8 <CELLULAR_urc_notif+0x314>)
 80152d2:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 80152d6:	801a      	strh	r2, [r3, #0]
        if (urc_eps_network_registration_callback != NULL)
 80152d8:	4b79      	ldr	r3, [pc, #484]	; (80154c0 <CELLULAR_urc_notif+0x31c>)
 80152da:	681b      	ldr	r3, [r3, #0]
 80152dc:	2b00      	cmp	r3, #0
 80152de:	d0cd      	beq.n	801527c <CELLULAR_urc_notif+0xd8>
          (* urc_eps_network_registration_callback)();
 80152e0:	4798      	blx	r3
 80152e2:	e7cb      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_DBG("<Cellular_Service> EPS network registration unchanged")
 80152e4:	4d77      	ldr	r5, [pc, #476]	; (80154c4 <CELLULAR_urc_notif+0x320>)
 80152e6:	4c71      	ldr	r4, [pc, #452]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80152e8:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80152ec:	462e      	mov	r6, r5
 80152ee:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80152f0:	6020      	str	r0, [r4, #0]
 80152f2:	6061      	str	r1, [r4, #4]
 80152f4:	60a2      	str	r2, [r4, #8]
 80152f6:	60e3      	str	r3, [r4, #12]
 80152f8:	4635      	mov	r5, r6
 80152fa:	3410      	adds	r4, #16
 80152fc:	4566      	cmp	r6, ip
 80152fe:	d1f5      	bne.n	80152ec <CELLULAR_urc_notif+0x148>
 8015300:	cd03      	ldmia	r5!, {r0, r1}
 8015302:	6020      	str	r0, [r4, #0]
 8015304:	6061      	str	r1, [r4, #4]
 8015306:	882a      	ldrh	r2, [r5, #0]
 8015308:	78ab      	ldrb	r3, [r5, #2]
 801530a:	8122      	strh	r2, [r4, #8]
 801530c:	72a3      	strb	r3, [r4, #10]
 801530e:	4c67      	ldr	r4, [pc, #412]	; (80154ac <CELLULAR_urc_notif+0x308>)
 8015310:	4620      	mov	r0, r4
 8015312:	f00a f80a 	bl	801f32a <crs_strlen>
 8015316:	b283      	uxth	r3, r0
 8015318:	4622      	mov	r2, r4
 801531a:	2102      	movs	r1, #2
 801531c:	2001      	movs	r0, #1
 801531e:	f00a f847 	bl	801f3b0 <traceIF_itmPrint>
 8015322:	4620      	mov	r0, r4
 8015324:	f00a f801 	bl	801f32a <crs_strlen>
 8015328:	b283      	uxth	r3, r0
 801532a:	4622      	mov	r2, r4
 801532c:	2102      	movs	r1, #2
 801532e:	2001      	movs	r0, #1
 8015330:	f00a f860 	bl	801f3f4 <traceIF_uartPrint>
  {
 8015334:	e7a2      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.gprs_network_registration == CELLULAR_TRUE))
 8015336:	4b5f      	ldr	r3, [pc, #380]	; (80154b4 <CELLULAR_urc_notif+0x310>)
 8015338:	785b      	ldrb	r3, [r3, #1]
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_NETWORK_REGISTRATION_STATUS) &&
 801533a:	2b01      	cmp	r3, #1
 801533c:	f47f af68 	bne.w	8015210 <CELLULAR_urc_notif+0x6c>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015340:	ab10      	add	r3, sp, #64	; 0x40
 8015342:	2202      	movs	r2, #2
 8015344:	2107      	movs	r1, #7
 8015346:	4630      	mov	r0, r6
 8015348:	f7f6 ffd4 	bl	800c2f4 <DATAPACK_readStruct>
 801534c:	2800      	cmp	r0, #0
 801534e:	d195      	bne.n	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_state != cs_ctxt_gprs_network_reg_state)
 8015350:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015354:	4b5c      	ldr	r3, [pc, #368]	; (80154c8 <CELLULAR_urc_notif+0x324>)
 8015356:	881b      	ldrh	r3, [r3, #0]
 8015358:	429a      	cmp	r2, r3
 801535a:	d021      	beq.n	80153a0 <CELLULAR_urc_notif+0x1fc>
        PRINT_DBG("<Cellular_Service> GPRS network registration updated: %d", rx_state)
 801535c:	4c53      	ldr	r4, [pc, #332]	; (80154ac <CELLULAR_urc_notif+0x308>)
 801535e:	495b      	ldr	r1, [pc, #364]	; (80154cc <CELLULAR_urc_notif+0x328>)
 8015360:	4620      	mov	r0, r4
 8015362:	f011 fa71 	bl	8026848 <sprintf>
 8015366:	4620      	mov	r0, r4
 8015368:	f009 ffdf 	bl	801f32a <crs_strlen>
 801536c:	b283      	uxth	r3, r0
 801536e:	4622      	mov	r2, r4
 8015370:	2102      	movs	r1, #2
 8015372:	2001      	movs	r0, #1
 8015374:	f00a f81c 	bl	801f3b0 <traceIF_itmPrint>
 8015378:	4620      	mov	r0, r4
 801537a:	f009 ffd6 	bl	801f32a <crs_strlen>
 801537e:	b283      	uxth	r3, r0
 8015380:	4622      	mov	r2, r4
 8015382:	2102      	movs	r1, #2
 8015384:	2001      	movs	r0, #1
 8015386:	f00a f835 	bl	801f3f4 <traceIF_uartPrint>
        cs_ctxt_gprs_network_reg_state = rx_state;
 801538a:	4b4f      	ldr	r3, [pc, #316]	; (80154c8 <CELLULAR_urc_notif+0x324>)
 801538c:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015390:	801a      	strh	r2, [r3, #0]
        if (urc_gprs_network_registration_callback != NULL)
 8015392:	4b4f      	ldr	r3, [pc, #316]	; (80154d0 <CELLULAR_urc_notif+0x32c>)
 8015394:	681b      	ldr	r3, [r3, #0]
 8015396:	2b00      	cmp	r3, #0
 8015398:	f43f af70 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* urc_gprs_network_registration_callback)();
 801539c:	4798      	blx	r3
 801539e:	e76d      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_DBG("<Cellular_Service> GPRS network registration unchanged")
 80153a0:	4d4c      	ldr	r5, [pc, #304]	; (80154d4 <CELLULAR_urc_notif+0x330>)
 80153a2:	4c42      	ldr	r4, [pc, #264]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80153a4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80153a8:	462e      	mov	r6, r5
 80153aa:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80153ac:	6020      	str	r0, [r4, #0]
 80153ae:	6061      	str	r1, [r4, #4]
 80153b0:	60a2      	str	r2, [r4, #8]
 80153b2:	60e3      	str	r3, [r4, #12]
 80153b4:	4635      	mov	r5, r6
 80153b6:	3410      	adds	r4, #16
 80153b8:	4566      	cmp	r6, ip
 80153ba:	d1f5      	bne.n	80153a8 <CELLULAR_urc_notif+0x204>
 80153bc:	cd07      	ldmia	r5!, {r0, r1, r2}
 80153be:	6020      	str	r0, [r4, #0]
 80153c0:	6061      	str	r1, [r4, #4]
 80153c2:	60a2      	str	r2, [r4, #8]
 80153c4:	4c39      	ldr	r4, [pc, #228]	; (80154ac <CELLULAR_urc_notif+0x308>)
 80153c6:	4620      	mov	r0, r4
 80153c8:	f009 ffaf 	bl	801f32a <crs_strlen>
 80153cc:	b283      	uxth	r3, r0
 80153ce:	4622      	mov	r2, r4
 80153d0:	2102      	movs	r1, #2
 80153d2:	2001      	movs	r0, #1
 80153d4:	f009 ffec 	bl	801f3b0 <traceIF_itmPrint>
 80153d8:	4620      	mov	r0, r4
 80153da:	f009 ffa6 	bl	801f32a <crs_strlen>
 80153de:	b283      	uxth	r3, r0
 80153e0:	4622      	mov	r2, r4
 80153e2:	2102      	movs	r1, #2
 80153e4:	2001      	movs	r0, #1
 80153e6:	f00a f805 	bl	801f3f4 <traceIF_uartPrint>
  {
 80153ea:	e747      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.cs_network_registration == CELLULAR_TRUE))
 80153ec:	4b31      	ldr	r3, [pc, #196]	; (80154b4 <CELLULAR_urc_notif+0x310>)
 80153ee:	789b      	ldrb	r3, [r3, #2]
  else if ((msgtype == (uint16_t) CSMT_URC_CS_NETWORK_REGISTRATION_STATUS) &&
 80153f0:	2b01      	cmp	r3, #1
 80153f2:	f47f af10 	bne.w	8015216 <CELLULAR_urc_notif+0x72>
    if (DATAPACK_readStruct(p_rsp_buf,
 80153f6:	ab10      	add	r3, sp, #64	; 0x40
 80153f8:	2202      	movs	r2, #2
 80153fa:	2109      	movs	r1, #9
 80153fc:	4630      	mov	r0, r6
 80153fe:	f7f6 ff79 	bl	800c2f4 <DATAPACK_readStruct>
 8015402:	2800      	cmp	r0, #0
 8015404:	f47f af3a 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_state != cs_ctxt_cs_network_reg_state)
 8015408:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 801540c:	4b32      	ldr	r3, [pc, #200]	; (80154d8 <CELLULAR_urc_notif+0x334>)
 801540e:	881b      	ldrh	r3, [r3, #0]
 8015410:	429a      	cmp	r2, r3
 8015412:	d021      	beq.n	8015458 <CELLULAR_urc_notif+0x2b4>
        PRINT_DBG("<Cellular_Service> CS network registration updated: %d", rx_state)
 8015414:	4c25      	ldr	r4, [pc, #148]	; (80154ac <CELLULAR_urc_notif+0x308>)
 8015416:	4931      	ldr	r1, [pc, #196]	; (80154dc <CELLULAR_urc_notif+0x338>)
 8015418:	4620      	mov	r0, r4
 801541a:	f011 fa15 	bl	8026848 <sprintf>
 801541e:	4620      	mov	r0, r4
 8015420:	f009 ff83 	bl	801f32a <crs_strlen>
 8015424:	b283      	uxth	r3, r0
 8015426:	4622      	mov	r2, r4
 8015428:	2102      	movs	r1, #2
 801542a:	2001      	movs	r0, #1
 801542c:	f009 ffc0 	bl	801f3b0 <traceIF_itmPrint>
 8015430:	4620      	mov	r0, r4
 8015432:	f009 ff7a 	bl	801f32a <crs_strlen>
 8015436:	b283      	uxth	r3, r0
 8015438:	4622      	mov	r2, r4
 801543a:	2102      	movs	r1, #2
 801543c:	2001      	movs	r0, #1
 801543e:	f009 ffd9 	bl	801f3f4 <traceIF_uartPrint>
        cs_ctxt_cs_network_reg_state = rx_state;
 8015442:	4b25      	ldr	r3, [pc, #148]	; (80154d8 <CELLULAR_urc_notif+0x334>)
 8015444:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015448:	801a      	strh	r2, [r3, #0]
        if (urc_cs_network_registration_callback != NULL)
 801544a:	4b25      	ldr	r3, [pc, #148]	; (80154e0 <CELLULAR_urc_notif+0x33c>)
 801544c:	681b      	ldr	r3, [r3, #0]
 801544e:	2b00      	cmp	r3, #0
 8015450:	f43f af14 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* urc_cs_network_registration_callback)();
 8015454:	4798      	blx	r3
 8015456:	e711      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_DBG("<Cellular_Service> CS network registration unchanged")
 8015458:	4d22      	ldr	r5, [pc, #136]	; (80154e4 <CELLULAR_urc_notif+0x340>)
 801545a:	4c14      	ldr	r4, [pc, #80]	; (80154ac <CELLULAR_urc_notif+0x308>)
 801545c:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8015460:	462e      	mov	r6, r5
 8015462:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015464:	6020      	str	r0, [r4, #0]
 8015466:	6061      	str	r1, [r4, #4]
 8015468:	60a2      	str	r2, [r4, #8]
 801546a:	60e3      	str	r3, [r4, #12]
 801546c:	4635      	mov	r5, r6
 801546e:	3410      	adds	r4, #16
 8015470:	4566      	cmp	r6, ip
 8015472:	d1f5      	bne.n	8015460 <CELLULAR_urc_notif+0x2bc>
 8015474:	cd03      	ldmia	r5!, {r0, r1}
 8015476:	6020      	str	r0, [r4, #0]
 8015478:	6061      	str	r1, [r4, #4]
 801547a:	882b      	ldrh	r3, [r5, #0]
 801547c:	8123      	strh	r3, [r4, #8]
 801547e:	4c0b      	ldr	r4, [pc, #44]	; (80154ac <CELLULAR_urc_notif+0x308>)
 8015480:	4620      	mov	r0, r4
 8015482:	f009 ff52 	bl	801f32a <crs_strlen>
 8015486:	b283      	uxth	r3, r0
 8015488:	4622      	mov	r2, r4
 801548a:	2102      	movs	r1, #2
 801548c:	2001      	movs	r0, #1
 801548e:	f009 ff8f 	bl	801f3b0 <traceIF_itmPrint>
 8015492:	4620      	mov	r0, r4
 8015494:	f009 ff49 	bl	801f32a <crs_strlen>
 8015498:	b283      	uxth	r3, r0
 801549a:	4622      	mov	r2, r4
 801549c:	2102      	movs	r1, #2
 801549e:	2001      	movs	r0, #1
 80154a0:	f009 ffa8 	bl	801f3f4 <traceIF_uartPrint>
  {
 80154a4:	e6ea      	b.n	801527c <CELLULAR_urc_notif+0xd8>
 80154a6:	bf00      	nop
 80154a8:	0803192c 	.word	0x0803192c
 80154ac:	200047dc 	.word	0x200047dc
 80154b0:	08031d54 	.word	0x08031d54
 80154b4:	20003804 	.word	0x20003804
 80154b8:	20000042 	.word	0x20000042
 80154bc:	0803195c 	.word	0x0803195c
 80154c0:	200038a0 	.word	0x200038a0
 80154c4:	0803199c 	.word	0x0803199c
 80154c8:	20000044 	.word	0x20000044
 80154cc:	080319d8 	.word	0x080319d8
 80154d0:	200038a8 	.word	0x200038a8
 80154d4:	08031a18 	.word	0x08031a18
 80154d8:	20000040 	.word	0x20000040
 80154dc:	08031a54 	.word	0x08031a54
 80154e0:	20003898 	.word	0x20003898
 80154e4:	08031a90 	.word	0x08031a90
           (cs_ctxt_urc_subscription.eps_location_info == CELLULAR_TRUE))
 80154e8:	4bab      	ldr	r3, [pc, #684]	; (8015798 <CELLULAR_urc_notif+0x5f4>)
 80154ea:	78db      	ldrb	r3, [r3, #3]
  else if ((msgtype == (uint16_t) CSMT_URC_EPS_LOCATION_INFO) &&
 80154ec:	2b01      	cmp	r3, #1
 80154ee:	f47f ae95 	bne.w	801521c <CELLULAR_urc_notif+0x78>
    if (DATAPACK_readStruct(p_rsp_buf,
 80154f2:	ab10      	add	r3, sp, #64	; 0x40
 80154f4:	2208      	movs	r2, #8
 80154f6:	2106      	movs	r1, #6
 80154f8:	4630      	mov	r0, r6
 80154fa:	f7f6 fefb 	bl	800c2f4 <DATAPACK_readStruct>
 80154fe:	4603      	mov	r3, r0
 8015500:	2800      	cmp	r0, #0
 8015502:	f47f aebb 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_loc.ci_updated == CELLULAR_TRUE)
 8015506:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
 801550a:	2a01      	cmp	r2, #1
 801550c:	d028      	beq.n	8015560 <CELLULAR_urc_notif+0x3bc>
      if (rx_loc.lac_updated == CELLULAR_TRUE)
 801550e:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 8015512:	2a01      	cmp	r2, #1
 8015514:	d035      	beq.n	8015582 <CELLULAR_urc_notif+0x3de>
      if (loc_update == CELLULAR_TRUE)
 8015516:	2b01      	cmp	r3, #1
 8015518:	d144      	bne.n	80155a4 <CELLULAR_urc_notif+0x400>
        if (urc_eps_location_info_callback != NULL)
 801551a:	4ba0      	ldr	r3, [pc, #640]	; (801579c <CELLULAR_urc_notif+0x5f8>)
 801551c:	681b      	ldr	r3, [r3, #0]
 801551e:	2b00      	cmp	r3, #0
 8015520:	f43f aeac 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          PRINT_DBG("<Cellular_Service> EPS location information info updated: lac=%d, ci=%ld", rx_loc.lac, rx_loc.ci)
 8015524:	4c9e      	ldr	r4, [pc, #632]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 8015526:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8015528:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 801552c:	499d      	ldr	r1, [pc, #628]	; (80157a4 <CELLULAR_urc_notif+0x600>)
 801552e:	4620      	mov	r0, r4
 8015530:	f011 f98a 	bl	8026848 <sprintf>
 8015534:	4620      	mov	r0, r4
 8015536:	f009 fef8 	bl	801f32a <crs_strlen>
 801553a:	b283      	uxth	r3, r0
 801553c:	4622      	mov	r2, r4
 801553e:	2102      	movs	r1, #2
 8015540:	2001      	movs	r0, #1
 8015542:	f009 ff35 	bl	801f3b0 <traceIF_itmPrint>
 8015546:	4620      	mov	r0, r4
 8015548:	f009 feef 	bl	801f32a <crs_strlen>
 801554c:	b283      	uxth	r3, r0
 801554e:	4622      	mov	r2, r4
 8015550:	2102      	movs	r1, #2
 8015552:	2001      	movs	r0, #1
 8015554:	f009 ff4e 	bl	801f3f4 <traceIF_uartPrint>
          (* urc_eps_location_info_callback)();
 8015558:	4b90      	ldr	r3, [pc, #576]	; (801579c <CELLULAR_urc_notif+0x5f8>)
 801555a:	681b      	ldr	r3, [r3, #0]
 801555c:	4798      	blx	r3
 801555e:	e68d      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        if (rx_loc.ci != cs_ctxt_eps_location_info.ci)
 8015560:	9910      	ldr	r1, [sp, #64]	; 0x40
 8015562:	4891      	ldr	r0, [pc, #580]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015564:	6800      	ldr	r0, [r0, #0]
 8015566:	4281      	cmp	r1, r0
 8015568:	d002      	beq.n	8015570 <CELLULAR_urc_notif+0x3cc>
          cs_ctxt_eps_location_info.ci = rx_loc.ci;
 801556a:	4b8f      	ldr	r3, [pc, #572]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 801556c:	6019      	str	r1, [r3, #0]
          loc_update = CELLULAR_TRUE;
 801556e:	4613      	mov	r3, r2
        if (cs_ctxt_eps_location_info.ci_updated == CELLULAR_FALSE)
 8015570:	498d      	ldr	r1, [pc, #564]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015572:	7989      	ldrb	r1, [r1, #6]
 8015574:	2900      	cmp	r1, #0
 8015576:	d1ca      	bne.n	801550e <CELLULAR_urc_notif+0x36a>
          cs_ctxt_eps_location_info.ci_updated = CELLULAR_TRUE;
 8015578:	4b8b      	ldr	r3, [pc, #556]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 801557a:	2101      	movs	r1, #1
 801557c:	7199      	strb	r1, [r3, #6]
          loc_update = CELLULAR_TRUE;
 801557e:	4613      	mov	r3, r2
 8015580:	e7c5      	b.n	801550e <CELLULAR_urc_notif+0x36a>
        if (rx_loc.lac != cs_ctxt_eps_location_info.lac)
 8015582:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
 8015586:	4888      	ldr	r0, [pc, #544]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015588:	8880      	ldrh	r0, [r0, #4]
 801558a:	4281      	cmp	r1, r0
 801558c:	d002      	beq.n	8015594 <CELLULAR_urc_notif+0x3f0>
          cs_ctxt_eps_location_info.lac = rx_loc.lac;
 801558e:	4b86      	ldr	r3, [pc, #536]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015590:	8099      	strh	r1, [r3, #4]
          loc_update = CELLULAR_TRUE;
 8015592:	4613      	mov	r3, r2
        if (cs_ctxt_eps_location_info.lac_updated == CELLULAR_FALSE)
 8015594:	4a84      	ldr	r2, [pc, #528]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 8015596:	79d2      	ldrb	r2, [r2, #7]
 8015598:	2a00      	cmp	r2, #0
 801559a:	d1bc      	bne.n	8015516 <CELLULAR_urc_notif+0x372>
          cs_ctxt_eps_location_info.lac_updated = CELLULAR_TRUE;
 801559c:	4b82      	ldr	r3, [pc, #520]	; (80157a8 <CELLULAR_urc_notif+0x604>)
 801559e:	2201      	movs	r2, #1
 80155a0:	71da      	strb	r2, [r3, #7]
      if (loc_update == CELLULAR_TRUE)
 80155a2:	e7ba      	b.n	801551a <CELLULAR_urc_notif+0x376>
        PRINT_DBG("<Cellular_Service> EPS location information unchanged")
 80155a4:	4d81      	ldr	r5, [pc, #516]	; (80157ac <CELLULAR_urc_notif+0x608>)
 80155a6:	4c7e      	ldr	r4, [pc, #504]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80155a8:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80155ac:	462e      	mov	r6, r5
 80155ae:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80155b0:	6020      	str	r0, [r4, #0]
 80155b2:	6061      	str	r1, [r4, #4]
 80155b4:	60a2      	str	r2, [r4, #8]
 80155b6:	60e3      	str	r3, [r4, #12]
 80155b8:	4635      	mov	r5, r6
 80155ba:	3410      	adds	r4, #16
 80155bc:	4566      	cmp	r6, ip
 80155be:	d1f5      	bne.n	80155ac <CELLULAR_urc_notif+0x408>
 80155c0:	cd03      	ldmia	r5!, {r0, r1}
 80155c2:	6020      	str	r0, [r4, #0]
 80155c4:	6061      	str	r1, [r4, #4]
 80155c6:	882a      	ldrh	r2, [r5, #0]
 80155c8:	78ab      	ldrb	r3, [r5, #2]
 80155ca:	8122      	strh	r2, [r4, #8]
 80155cc:	72a3      	strb	r3, [r4, #10]
 80155ce:	4c74      	ldr	r4, [pc, #464]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80155d0:	4620      	mov	r0, r4
 80155d2:	f009 feaa 	bl	801f32a <crs_strlen>
 80155d6:	b283      	uxth	r3, r0
 80155d8:	4622      	mov	r2, r4
 80155da:	2102      	movs	r1, #2
 80155dc:	2001      	movs	r0, #1
 80155de:	f009 fee7 	bl	801f3b0 <traceIF_itmPrint>
 80155e2:	4620      	mov	r0, r4
 80155e4:	f009 fea1 	bl	801f32a <crs_strlen>
 80155e8:	b283      	uxth	r3, r0
 80155ea:	4622      	mov	r2, r4
 80155ec:	2102      	movs	r1, #2
 80155ee:	2001      	movs	r0, #1
 80155f0:	f009 ff00 	bl	801f3f4 <traceIF_uartPrint>
  {
 80155f4:	e642      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.gprs_location_info == CELLULAR_TRUE))
 80155f6:	4b68      	ldr	r3, [pc, #416]	; (8015798 <CELLULAR_urc_notif+0x5f4>)
 80155f8:	791b      	ldrb	r3, [r3, #4]
  else if ((msgtype == (uint16_t) CSMT_URC_GPRS_LOCATION_INFO) &&
 80155fa:	2b01      	cmp	r3, #1
 80155fc:	f47f ae11 	bne.w	8015222 <CELLULAR_urc_notif+0x7e>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015600:	ab10      	add	r3, sp, #64	; 0x40
 8015602:	2208      	movs	r2, #8
 8015604:	4611      	mov	r1, r2
 8015606:	4630      	mov	r0, r6
 8015608:	f7f6 fe74 	bl	800c2f4 <DATAPACK_readStruct>
 801560c:	4603      	mov	r3, r0
 801560e:	2800      	cmp	r0, #0
 8015610:	f47f ae34 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_loc.ci_updated == CELLULAR_TRUE)
 8015614:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
 8015618:	2a01      	cmp	r2, #1
 801561a:	d028      	beq.n	801566e <CELLULAR_urc_notif+0x4ca>
      if (rx_loc.lac_updated == CELLULAR_TRUE)
 801561c:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 8015620:	2a01      	cmp	r2, #1
 8015622:	d035      	beq.n	8015690 <CELLULAR_urc_notif+0x4ec>
      if (loc_update == CELLULAR_TRUE)
 8015624:	2b01      	cmp	r3, #1
 8015626:	d144      	bne.n	80156b2 <CELLULAR_urc_notif+0x50e>
        if (urc_gprs_location_info_callback != NULL)
 8015628:	4b61      	ldr	r3, [pc, #388]	; (80157b0 <CELLULAR_urc_notif+0x60c>)
 801562a:	681b      	ldr	r3, [r3, #0]
 801562c:	2b00      	cmp	r3, #0
 801562e:	f43f ae25 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          PRINT_DBG("<Cellular_Service> GPRS location information info updated: lac=%d, ci=%ld", rx_loc.lac, rx_loc.ci)
 8015632:	4c5b      	ldr	r4, [pc, #364]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 8015634:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8015636:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 801563a:	495e      	ldr	r1, [pc, #376]	; (80157b4 <CELLULAR_urc_notif+0x610>)
 801563c:	4620      	mov	r0, r4
 801563e:	f011 f903 	bl	8026848 <sprintf>
 8015642:	4620      	mov	r0, r4
 8015644:	f009 fe71 	bl	801f32a <crs_strlen>
 8015648:	b283      	uxth	r3, r0
 801564a:	4622      	mov	r2, r4
 801564c:	2102      	movs	r1, #2
 801564e:	2001      	movs	r0, #1
 8015650:	f009 feae 	bl	801f3b0 <traceIF_itmPrint>
 8015654:	4620      	mov	r0, r4
 8015656:	f009 fe68 	bl	801f32a <crs_strlen>
 801565a:	b283      	uxth	r3, r0
 801565c:	4622      	mov	r2, r4
 801565e:	2102      	movs	r1, #2
 8015660:	2001      	movs	r0, #1
 8015662:	f009 fec7 	bl	801f3f4 <traceIF_uartPrint>
          (* urc_gprs_location_info_callback)();
 8015666:	4b52      	ldr	r3, [pc, #328]	; (80157b0 <CELLULAR_urc_notif+0x60c>)
 8015668:	681b      	ldr	r3, [r3, #0]
 801566a:	4798      	blx	r3
 801566c:	e606      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        if (rx_loc.ci != cs_ctxt_gprs_location_info.ci)
 801566e:	9910      	ldr	r1, [sp, #64]	; 0x40
 8015670:	4851      	ldr	r0, [pc, #324]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015672:	6800      	ldr	r0, [r0, #0]
 8015674:	4281      	cmp	r1, r0
 8015676:	d002      	beq.n	801567e <CELLULAR_urc_notif+0x4da>
          cs_ctxt_gprs_location_info.ci = rx_loc.ci;
 8015678:	4b4f      	ldr	r3, [pc, #316]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 801567a:	6019      	str	r1, [r3, #0]
          loc_update = CELLULAR_TRUE;
 801567c:	4613      	mov	r3, r2
        if (cs_ctxt_gprs_location_info.ci_updated == CELLULAR_FALSE)
 801567e:	494e      	ldr	r1, [pc, #312]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015680:	7989      	ldrb	r1, [r1, #6]
 8015682:	2900      	cmp	r1, #0
 8015684:	d1ca      	bne.n	801561c <CELLULAR_urc_notif+0x478>
          cs_ctxt_gprs_location_info.ci_updated = CELLULAR_TRUE;
 8015686:	4b4c      	ldr	r3, [pc, #304]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015688:	2101      	movs	r1, #1
 801568a:	7199      	strb	r1, [r3, #6]
          loc_update = CELLULAR_TRUE;
 801568c:	4613      	mov	r3, r2
 801568e:	e7c5      	b.n	801561c <CELLULAR_urc_notif+0x478>
        if (rx_loc.lac != cs_ctxt_gprs_location_info.lac)
 8015690:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
 8015694:	4848      	ldr	r0, [pc, #288]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 8015696:	8880      	ldrh	r0, [r0, #4]
 8015698:	4281      	cmp	r1, r0
 801569a:	d002      	beq.n	80156a2 <CELLULAR_urc_notif+0x4fe>
          cs_ctxt_gprs_location_info.lac = rx_loc.lac;
 801569c:	4b46      	ldr	r3, [pc, #280]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 801569e:	8099      	strh	r1, [r3, #4]
          loc_update = CELLULAR_TRUE;
 80156a0:	4613      	mov	r3, r2
        if (cs_ctxt_gprs_location_info.lac_updated == CELLULAR_FALSE)
 80156a2:	4a45      	ldr	r2, [pc, #276]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 80156a4:	79d2      	ldrb	r2, [r2, #7]
 80156a6:	2a00      	cmp	r2, #0
 80156a8:	d1bc      	bne.n	8015624 <CELLULAR_urc_notif+0x480>
          cs_ctxt_gprs_location_info.lac_updated = CELLULAR_TRUE;
 80156aa:	4b43      	ldr	r3, [pc, #268]	; (80157b8 <CELLULAR_urc_notif+0x614>)
 80156ac:	2201      	movs	r2, #1
 80156ae:	71da      	strb	r2, [r3, #7]
      if (loc_update == CELLULAR_TRUE)
 80156b0:	e7ba      	b.n	8015628 <CELLULAR_urc_notif+0x484>
        PRINT_DBG("<Cellular_Service> GPRS location information unchanged")
 80156b2:	4e42      	ldr	r6, [pc, #264]	; (80157bc <CELLULAR_urc_notif+0x618>)
 80156b4:	4c3a      	ldr	r4, [pc, #232]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80156b6:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 80156ba:	4635      	mov	r5, r6
 80156bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80156be:	6020      	str	r0, [r4, #0]
 80156c0:	6061      	str	r1, [r4, #4]
 80156c2:	60a2      	str	r2, [r4, #8]
 80156c4:	60e3      	str	r3, [r4, #12]
 80156c6:	462e      	mov	r6, r5
 80156c8:	3410      	adds	r4, #16
 80156ca:	4565      	cmp	r5, ip
 80156cc:	d1f5      	bne.n	80156ba <CELLULAR_urc_notif+0x516>
 80156ce:	ce07      	ldmia	r6!, {r0, r1, r2}
 80156d0:	6020      	str	r0, [r4, #0]
 80156d2:	6061      	str	r1, [r4, #4]
 80156d4:	60a2      	str	r2, [r4, #8]
 80156d6:	4c32      	ldr	r4, [pc, #200]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 80156d8:	4620      	mov	r0, r4
 80156da:	f009 fe26 	bl	801f32a <crs_strlen>
 80156de:	b283      	uxth	r3, r0
 80156e0:	4622      	mov	r2, r4
 80156e2:	2102      	movs	r1, #2
 80156e4:	2001      	movs	r0, #1
 80156e6:	f009 fe63 	bl	801f3b0 <traceIF_itmPrint>
 80156ea:	4620      	mov	r0, r4
 80156ec:	f009 fe1d 	bl	801f32a <crs_strlen>
 80156f0:	b283      	uxth	r3, r0
 80156f2:	4622      	mov	r2, r4
 80156f4:	2102      	movs	r1, #2
 80156f6:	2001      	movs	r0, #1
 80156f8:	f009 fe7c 	bl	801f3f4 <traceIF_uartPrint>
  {
 80156fc:	e5be      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.cs_location_info == CELLULAR_TRUE))
 80156fe:	4b26      	ldr	r3, [pc, #152]	; (8015798 <CELLULAR_urc_notif+0x5f4>)
 8015700:	795b      	ldrb	r3, [r3, #5]
  else if ((msgtype == (uint16_t) CSMT_URC_CS_LOCATION_INFO) &&
 8015702:	2b01      	cmp	r3, #1
 8015704:	f47f ad90 	bne.w	8015228 <CELLULAR_urc_notif+0x84>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015708:	ab10      	add	r3, sp, #64	; 0x40
 801570a:	2208      	movs	r2, #8
 801570c:	210a      	movs	r1, #10
 801570e:	4630      	mov	r0, r6
 8015710:	f7f6 fdf0 	bl	800c2f4 <DATAPACK_readStruct>
 8015714:	4603      	mov	r3, r0
 8015716:	2800      	cmp	r0, #0
 8015718:	f47f adb0 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (rx_loc.ci_updated == CELLULAR_TRUE)
 801571c:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
 8015720:	2a01      	cmp	r2, #1
 8015722:	d028      	beq.n	8015776 <CELLULAR_urc_notif+0x5d2>
      if (rx_loc.lac_updated == CELLULAR_TRUE)
 8015724:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 8015728:	2a01      	cmp	r2, #1
 801572a:	d04f      	beq.n	80157cc <CELLULAR_urc_notif+0x628>
      if (loc_update == CELLULAR_TRUE)
 801572c:	2b01      	cmp	r3, #1
 801572e:	d15e      	bne.n	80157ee <CELLULAR_urc_notif+0x64a>
        if (urc_cs_location_info_callback != NULL)
 8015730:	4b23      	ldr	r3, [pc, #140]	; (80157c0 <CELLULAR_urc_notif+0x61c>)
 8015732:	681b      	ldr	r3, [r3, #0]
 8015734:	2b00      	cmp	r3, #0
 8015736:	f43f ada1 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          PRINT_DBG("<Cellular_Service> CS location information info updated: lac=%d, ci=%ld", rx_loc.lac, rx_loc.ci)
 801573a:	4c19      	ldr	r4, [pc, #100]	; (80157a0 <CELLULAR_urc_notif+0x5fc>)
 801573c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 801573e:	f8bd 2044 	ldrh.w	r2, [sp, #68]	; 0x44
 8015742:	4920      	ldr	r1, [pc, #128]	; (80157c4 <CELLULAR_urc_notif+0x620>)
 8015744:	4620      	mov	r0, r4
 8015746:	f011 f87f 	bl	8026848 <sprintf>
 801574a:	4620      	mov	r0, r4
 801574c:	f009 fded 	bl	801f32a <crs_strlen>
 8015750:	b283      	uxth	r3, r0
 8015752:	4622      	mov	r2, r4
 8015754:	2102      	movs	r1, #2
 8015756:	2001      	movs	r0, #1
 8015758:	f009 fe2a 	bl	801f3b0 <traceIF_itmPrint>
 801575c:	4620      	mov	r0, r4
 801575e:	f009 fde4 	bl	801f32a <crs_strlen>
 8015762:	b283      	uxth	r3, r0
 8015764:	4622      	mov	r2, r4
 8015766:	2102      	movs	r1, #2
 8015768:	2001      	movs	r0, #1
 801576a:	f009 fe43 	bl	801f3f4 <traceIF_uartPrint>
          (* urc_cs_location_info_callback)();
 801576e:	4b14      	ldr	r3, [pc, #80]	; (80157c0 <CELLULAR_urc_notif+0x61c>)
 8015770:	681b      	ldr	r3, [r3, #0]
 8015772:	4798      	blx	r3
 8015774:	e582      	b.n	801527c <CELLULAR_urc_notif+0xd8>
        if (rx_loc.ci != cs_ctxt_cs_location_info.ci)
 8015776:	9910      	ldr	r1, [sp, #64]	; 0x40
 8015778:	4813      	ldr	r0, [pc, #76]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 801577a:	6800      	ldr	r0, [r0, #0]
 801577c:	4281      	cmp	r1, r0
 801577e:	d002      	beq.n	8015786 <CELLULAR_urc_notif+0x5e2>
          cs_ctxt_cs_location_info.ci = rx_loc.ci;
 8015780:	4b11      	ldr	r3, [pc, #68]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 8015782:	6019      	str	r1, [r3, #0]
          loc_update = CELLULAR_TRUE;
 8015784:	4613      	mov	r3, r2
        if (cs_ctxt_cs_location_info.ci_updated == CELLULAR_FALSE)
 8015786:	4910      	ldr	r1, [pc, #64]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 8015788:	7989      	ldrb	r1, [r1, #6]
 801578a:	2900      	cmp	r1, #0
 801578c:	d1ca      	bne.n	8015724 <CELLULAR_urc_notif+0x580>
          cs_ctxt_cs_location_info.ci_updated = CELLULAR_TRUE;
 801578e:	4b0e      	ldr	r3, [pc, #56]	; (80157c8 <CELLULAR_urc_notif+0x624>)
 8015790:	2101      	movs	r1, #1
 8015792:	7199      	strb	r1, [r3, #6]
          loc_update = CELLULAR_TRUE;
 8015794:	4613      	mov	r3, r2
 8015796:	e7c5      	b.n	8015724 <CELLULAR_urc_notif+0x580>
 8015798:	20003804 	.word	0x20003804
 801579c:	2000389c 	.word	0x2000389c
 80157a0:	200047dc 	.word	0x200047dc
 80157a4:	08031acc 	.word	0x08031acc
 80157a8:	200037ac 	.word	0x200037ac
 80157ac:	08031b1c 	.word	0x08031b1c
 80157b0:	200038a4 	.word	0x200038a4
 80157b4:	08031b58 	.word	0x08031b58
 80157b8:	200037b4 	.word	0x200037b4
 80157bc:	08031ba8 	.word	0x08031ba8
 80157c0:	20003894 	.word	0x20003894
 80157c4:	08031be4 	.word	0x08031be4
 80157c8:	200036a0 	.word	0x200036a0
        if (rx_loc.lac != cs_ctxt_cs_location_info.lac)
 80157cc:	f8bd 1044 	ldrh.w	r1, [sp, #68]	; 0x44
 80157d0:	48bd      	ldr	r0, [pc, #756]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157d2:	8880      	ldrh	r0, [r0, #4]
 80157d4:	4281      	cmp	r1, r0
 80157d6:	d002      	beq.n	80157de <CELLULAR_urc_notif+0x63a>
          cs_ctxt_cs_location_info.lac = rx_loc.lac;
 80157d8:	4bbb      	ldr	r3, [pc, #748]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157da:	8099      	strh	r1, [r3, #4]
          loc_update = CELLULAR_TRUE;
 80157dc:	4613      	mov	r3, r2
        if (cs_ctxt_cs_location_info.lac_updated == CELLULAR_FALSE)
 80157de:	4aba      	ldr	r2, [pc, #744]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157e0:	79d2      	ldrb	r2, [r2, #7]
 80157e2:	2a00      	cmp	r2, #0
 80157e4:	d1a2      	bne.n	801572c <CELLULAR_urc_notif+0x588>
          cs_ctxt_cs_location_info.lac_updated = CELLULAR_TRUE;
 80157e6:	4bb8      	ldr	r3, [pc, #736]	; (8015ac8 <CELLULAR_urc_notif+0x924>)
 80157e8:	2201      	movs	r2, #1
 80157ea:	71da      	strb	r2, [r3, #7]
      if (loc_update == CELLULAR_TRUE)
 80157ec:	e7a0      	b.n	8015730 <CELLULAR_urc_notif+0x58c>
        PRINT_DBG("<Cellular_Service> CS location information unchanged")
 80157ee:	4db7      	ldr	r5, [pc, #732]	; (8015acc <CELLULAR_urc_notif+0x928>)
 80157f0:	4cb7      	ldr	r4, [pc, #732]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 80157f2:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80157f6:	462e      	mov	r6, r5
 80157f8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80157fa:	6020      	str	r0, [r4, #0]
 80157fc:	6061      	str	r1, [r4, #4]
 80157fe:	60a2      	str	r2, [r4, #8]
 8015800:	60e3      	str	r3, [r4, #12]
 8015802:	4635      	mov	r5, r6
 8015804:	3410      	adds	r4, #16
 8015806:	4566      	cmp	r6, ip
 8015808:	d1f5      	bne.n	80157f6 <CELLULAR_urc_notif+0x652>
 801580a:	cd03      	ldmia	r5!, {r0, r1}
 801580c:	6020      	str	r0, [r4, #0]
 801580e:	6061      	str	r1, [r4, #4]
 8015810:	882b      	ldrh	r3, [r5, #0]
 8015812:	8123      	strh	r3, [r4, #8]
 8015814:	4cae      	ldr	r4, [pc, #696]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015816:	4620      	mov	r0, r4
 8015818:	f009 fd87 	bl	801f32a <crs_strlen>
 801581c:	b283      	uxth	r3, r0
 801581e:	4622      	mov	r2, r4
 8015820:	2102      	movs	r1, #2
 8015822:	2001      	movs	r0, #1
 8015824:	f009 fdc4 	bl	801f3b0 <traceIF_itmPrint>
 8015828:	4620      	mov	r0, r4
 801582a:	f009 fd7e 	bl	801f32a <crs_strlen>
 801582e:	b283      	uxth	r3, r0
 8015830:	4622      	mov	r2, r4
 8015832:	2102      	movs	r1, #2
 8015834:	2001      	movs	r0, #1
 8015836:	f009 fddd 	bl	801f3f4 <traceIF_uartPrint>
  {
 801583a:	e51f      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.signal_quality == CELLULAR_TRUE))
 801583c:	4ba5      	ldr	r3, [pc, #660]	; (8015ad4 <CELLULAR_urc_notif+0x930>)
 801583e:	799b      	ldrb	r3, [r3, #6]
  else if ((msgtype == (uint16_t) CSMT_URC_SIGNAL_QUALITY) &&
 8015840:	2b01      	cmp	r3, #1
 8015842:	f47f acf4 	bne.w	801522e <CELLULAR_urc_notif+0x8a>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015846:	ab10      	add	r3, sp, #64	; 0x40
 8015848:	2202      	movs	r2, #2
 801584a:	210b      	movs	r1, #11
 801584c:	4630      	mov	r0, r6
 801584e:	f7f6 fd51 	bl	800c2f4 <DATAPACK_readStruct>
 8015852:	2800      	cmp	r0, #0
 8015854:	f47f ad12 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (urc_signal_quality_callback != NULL)
 8015858:	4b9f      	ldr	r3, [pc, #636]	; (8015ad8 <CELLULAR_urc_notif+0x934>)
 801585a:	681b      	ldr	r3, [r3, #0]
 801585c:	2b00      	cmp	r3, #0
 801585e:	f43f ad0d 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        PRINT_INFO("<Cellular_Service> CS signal quality info updated: rssi=%d, ber=%d", local_sig_qual.rssi,
 8015862:	4c9b      	ldr	r4, [pc, #620]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015864:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 8015868:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 801586c:	499b      	ldr	r1, [pc, #620]	; (8015adc <CELLULAR_urc_notif+0x938>)
 801586e:	4620      	mov	r0, r4
 8015870:	f010 ffea 	bl	8026848 <sprintf>
 8015874:	4620      	mov	r0, r4
 8015876:	f009 fd58 	bl	801f32a <crs_strlen>
 801587a:	b283      	uxth	r3, r0
 801587c:	4622      	mov	r2, r4
 801587e:	2101      	movs	r1, #1
 8015880:	4608      	mov	r0, r1
 8015882:	f009 fd95 	bl	801f3b0 <traceIF_itmPrint>
 8015886:	4620      	mov	r0, r4
 8015888:	f009 fd4f 	bl	801f32a <crs_strlen>
 801588c:	b283      	uxth	r3, r0
 801588e:	4622      	mov	r2, r4
 8015890:	2101      	movs	r1, #1
 8015892:	4608      	mov	r0, r1
 8015894:	f009 fdae 	bl	801f3f4 <traceIF_uartPrint>
        (* urc_signal_quality_callback)();
 8015898:	4b8f      	ldr	r3, [pc, #572]	; (8015ad8 <CELLULAR_urc_notif+0x934>)
 801589a:	681b      	ldr	r3, [r3, #0]
 801589c:	4798      	blx	r3
  {
 801589e:	e4ed      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 80158a0:	ab10      	add	r3, sp, #64	; 0x40
 80158a2:	2204      	movs	r2, #4
 80158a4:	210d      	movs	r1, #13
 80158a6:	4630      	mov	r0, r6
 80158a8:	f7f6 fd24 	bl	800c2f4 <DATAPACK_readStruct>
 80158ac:	2800      	cmp	r0, #0
 80158ae:	f47f ace5 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 80158b2:	9810      	ldr	r0, [sp, #64]	; 0x40
 80158b4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80158b8:	f43f ace0 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        if (cs_ctxt_sockets_info[sockHandle].socket_data_ready_callback != NULL)
 80158bc:	4b88      	ldr	r3, [pc, #544]	; (8015ae0 <CELLULAR_urc_notif+0x93c>)
 80158be:	226c      	movs	r2, #108	; 0x6c
 80158c0:	fb02 3300 	mla	r3, r2, r0, r3
 80158c4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80158c6:	2b00      	cmp	r3, #0
 80158c8:	f43f acd8 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* cs_ctxt_sockets_info[sockHandle].socket_data_ready_callback)(sockHandle);
 80158cc:	4798      	blx	r3
 80158ce:	e4d5      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 80158d0:	ab10      	add	r3, sp, #64	; 0x40
 80158d2:	2204      	movs	r2, #4
 80158d4:	210e      	movs	r1, #14
 80158d6:	4630      	mov	r0, r6
 80158d8:	f7f6 fd0c 	bl	800c2f4 <DATAPACK_readStruct>
 80158dc:	2800      	cmp	r0, #0
 80158de:	f47f accd 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      if (sockHandle != CS_INVALID_SOCKET_HANDLE)
 80158e2:	9810      	ldr	r0, [sp, #64]	; 0x40
 80158e4:	f1b0 3fff 	cmp.w	r0, #4294967295
 80158e8:	f43f acc8 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        if (cs_ctxt_sockets_info[sockHandle].socket_remote_close_callback != NULL)
 80158ec:	4b7c      	ldr	r3, [pc, #496]	; (8015ae0 <CELLULAR_urc_notif+0x93c>)
 80158ee:	226c      	movs	r2, #108	; 0x6c
 80158f0:	fb02 3300 	mla	r3, r2, r0, r3
 80158f4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80158f6:	2b00      	cmp	r3, #0
 80158f8:	f43f acc0 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          (* cs_ctxt_sockets_info[sockHandle].socket_remote_close_callback)(sockHandle);
 80158fc:	4798      	blx	r3
 80158fe:	e4bd      	b.n	801527c <CELLULAR_urc_notif+0xd8>
           (cs_ctxt_urc_subscription.packet_domain_event == CELLULAR_TRUE))
 8015900:	4b74      	ldr	r3, [pc, #464]	; (8015ad4 <CELLULAR_urc_notif+0x930>)
 8015902:	79db      	ldrb	r3, [r3, #7]
  else if ((msgtype == (uint16_t) CSMT_URC_PACKET_DOMAIN_EVENT) &&
 8015904:	2b01      	cmp	r3, #1
 8015906:	f47f ac9b 	bne.w	8015240 <CELLULAR_urc_notif+0x9c>
    if (DATAPACK_readStruct(p_rsp_buf,
 801590a:	ab10      	add	r3, sp, #64	; 0x40
 801590c:	2204      	movs	r2, #4
 801590e:	210c      	movs	r1, #12
 8015910:	4630      	mov	r0, r6
 8015912:	f7f6 fcef 	bl	800c2f4 <DATAPACK_readStruct>
 8015916:	4604      	mov	r4, r0
 8015918:	2800      	cmp	r0, #0
 801591a:	f47f acaf 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      PRINT_DBG("PDN event: origine=%d scope=%d type=%d (user cid=%d) ",
 801591e:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 8015922:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
 8015926:	4d6a      	ldr	r5, [pc, #424]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015928:	9201      	str	r2, [sp, #4]
 801592a:	9300      	str	r3, [sp, #0]
 801592c:	f89d 3041 	ldrb.w	r3, [sp, #65]	; 0x41
 8015930:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 8015934:	496b      	ldr	r1, [pc, #428]	; (8015ae4 <CELLULAR_urc_notif+0x940>)
 8015936:	4628      	mov	r0, r5
 8015938:	f010 ff86 	bl	8026848 <sprintf>
 801593c:	4628      	mov	r0, r5
 801593e:	f009 fcf4 	bl	801f32a <crs_strlen>
 8015942:	b283      	uxth	r3, r0
 8015944:	462a      	mov	r2, r5
 8015946:	2102      	movs	r1, #2
 8015948:	2001      	movs	r0, #1
 801594a:	f009 fd31 	bl	801f3b0 <traceIF_itmPrint>
 801594e:	4628      	mov	r0, r5
 8015950:	f009 fceb 	bl	801f32a <crs_strlen>
 8015954:	b283      	uxth	r3, r0
 8015956:	462a      	mov	r2, r5
 8015958:	2102      	movs	r1, #2
 801595a:	2001      	movs	r0, #1
 801595c:	f009 fd4a 	bl	801f3f4 <traceIF_uartPrint>
      if ((pdn_event.conf_id == CS_PDN_USER_CONFIG_1) ||
 8015960:	f89d 5043 	ldrb.w	r5, [sp, #67]	; 0x43
 8015964:	2d05      	cmp	r5, #5
 8015966:	d80c      	bhi.n	8015982 <CELLULAR_urc_notif+0x7de>
        if (urc_packet_domain_event_callback[pdn_event.conf_id] != NULL)
 8015968:	4b5f      	ldr	r3, [pc, #380]	; (8015ae8 <CELLULAR_urc_notif+0x944>)
 801596a:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
 801596e:	2c00      	cmp	r4, #0
 8015970:	f43f ac84 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
          CS_PDN_event_t conv_pdn_event = convert_to_PDN_event(pdn_event);
 8015974:	9810      	ldr	r0, [sp, #64]	; 0x40
 8015976:	f7ff fbdd 	bl	8015134 <convert_to_PDN_event>
 801597a:	4601      	mov	r1, r0
          (* urc_packet_domain_event_callback[pdn_event.conf_id])(pdn_event.conf_id, conv_pdn_event);
 801597c:	4628      	mov	r0, r5
 801597e:	47a0      	blx	r4
 8015980:	e47c      	b.n	801527c <CELLULAR_urc_notif+0xd8>
      else if (pdn_event.conf_id == CS_PDN_ALL)
 8015982:	2d0d      	cmp	r5, #13
 8015984:	d114      	bne.n	80159b0 <CELLULAR_urc_notif+0x80c>
        CS_PDN_event_t conv_pdn_event = convert_to_PDN_event(pdn_event);
 8015986:	9810      	ldr	r0, [sp, #64]	; 0x40
 8015988:	f7ff fbd4 	bl	8015134 <convert_to_PDN_event>
 801598c:	4606      	mov	r6, r0
        for (uint8_t loop = 0U; loop < CS_MAX_NB_PDP_CTXT; loop++)
 801598e:	e001      	b.n	8015994 <CELLULAR_urc_notif+0x7f0>
 8015990:	3401      	adds	r4, #1
 8015992:	b2e4      	uxtb	r4, r4
 8015994:	2c05      	cmp	r4, #5
 8015996:	f63f ac71 	bhi.w	801527c <CELLULAR_urc_notif+0xd8>
          if (urc_packet_domain_event_callback[loop] != NULL)
 801599a:	4b53      	ldr	r3, [pc, #332]	; (8015ae8 <CELLULAR_urc_notif+0x944>)
 801599c:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
 80159a0:	2d00      	cmp	r5, #0
 80159a2:	d0f5      	beq.n	8015990 <CELLULAR_urc_notif+0x7ec>
            CS_PDN_conf_id_t pdn_cid = convert_index_to_PDN_conf(loop);
 80159a4:	4620      	mov	r0, r4
 80159a6:	f7ff fbf3 	bl	8015190 <convert_index_to_PDN_conf>
            (* urc_packet_domain_event_callback[loop])(pdn_cid, conv_pdn_event);
 80159aa:	4631      	mov	r1, r6
 80159ac:	47a8      	blx	r5
 80159ae:	e7ef      	b.n	8015990 <CELLULAR_urc_notif+0x7ec>
        PRINT_INFO("PDN not identified")
 80159b0:	4c47      	ldr	r4, [pc, #284]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 80159b2:	4d4e      	ldr	r5, [pc, #312]	; (8015aec <CELLULAR_urc_notif+0x948>)
 80159b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80159b6:	6020      	str	r0, [r4, #0]
 80159b8:	6061      	str	r1, [r4, #4]
 80159ba:	60a2      	str	r2, [r4, #8]
 80159bc:	60e3      	str	r3, [r4, #12]
 80159be:	cd03      	ldmia	r5!, {r0, r1}
 80159c0:	6120      	str	r0, [r4, #16]
 80159c2:	6161      	str	r1, [r4, #20]
 80159c4:	4620      	mov	r0, r4
 80159c6:	f009 fcb0 	bl	801f32a <crs_strlen>
 80159ca:	b283      	uxth	r3, r0
 80159cc:	4622      	mov	r2, r4
 80159ce:	2101      	movs	r1, #1
 80159d0:	4608      	mov	r0, r1
 80159d2:	f009 fced 	bl	801f3b0 <traceIF_itmPrint>
 80159d6:	4620      	mov	r0, r4
 80159d8:	f009 fca7 	bl	801f32a <crs_strlen>
 80159dc:	b283      	uxth	r3, r0
 80159de:	4622      	mov	r2, r4
 80159e0:	2101      	movs	r1, #1
 80159e2:	4608      	mov	r0, r1
 80159e4:	f009 fd06 	bl	801f3f4 <traceIF_uartPrint>
  {
 80159e8:	e448      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 80159ea:	ab10      	add	r3, sp, #64	; 0x40
 80159ec:	2250      	movs	r2, #80	; 0x50
 80159ee:	2110      	movs	r1, #16
 80159f0:	4630      	mov	r0, r6
 80159f2:	f7f6 fc7f 	bl	800c2f4 <DATAPACK_readStruct>
 80159f6:	2800      	cmp	r0, #0
 80159f8:	f47f ac40 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      PRINT_INFO("ping URC received at CS level")
 80159fc:	4e3c      	ldr	r6, [pc, #240]	; (8015af0 <CELLULAR_urc_notif+0x94c>)
 80159fe:	4c34      	ldr	r4, [pc, #208]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015a00:	f106 0c20 	add.w	ip, r6, #32
 8015a04:	4635      	mov	r5, r6
 8015a06:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a08:	6020      	str	r0, [r4, #0]
 8015a0a:	6061      	str	r1, [r4, #4]
 8015a0c:	60a2      	str	r2, [r4, #8]
 8015a0e:	60e3      	str	r3, [r4, #12]
 8015a10:	462e      	mov	r6, r5
 8015a12:	3410      	adds	r4, #16
 8015a14:	4565      	cmp	r5, ip
 8015a16:	d1f5      	bne.n	8015a04 <CELLULAR_urc_notif+0x860>
 8015a18:	882a      	ldrh	r2, [r5, #0]
 8015a1a:	78ab      	ldrb	r3, [r5, #2]
 8015a1c:	8022      	strh	r2, [r4, #0]
 8015a1e:	70a3      	strb	r3, [r4, #2]
 8015a20:	4c2b      	ldr	r4, [pc, #172]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015a22:	4620      	mov	r0, r4
 8015a24:	f009 fc81 	bl	801f32a <crs_strlen>
 8015a28:	b283      	uxth	r3, r0
 8015a2a:	4622      	mov	r2, r4
 8015a2c:	2101      	movs	r1, #1
 8015a2e:	4608      	mov	r0, r1
 8015a30:	f009 fcbe 	bl	801f3b0 <traceIF_itmPrint>
 8015a34:	4620      	mov	r0, r4
 8015a36:	f009 fc78 	bl	801f32a <crs_strlen>
 8015a3a:	b283      	uxth	r3, r0
 8015a3c:	4622      	mov	r2, r4
 8015a3e:	2101      	movs	r1, #1
 8015a40:	4608      	mov	r0, r1
 8015a42:	f009 fcd7 	bl	801f3f4 <traceIF_uartPrint>
      if (urc_ping_rsp_callback != NULL)
 8015a46:	4b2b      	ldr	r3, [pc, #172]	; (8015af4 <CELLULAR_urc_notif+0x950>)
 8015a48:	681e      	ldr	r6, [r3, #0]
 8015a4a:	2e00      	cmp	r6, #0
 8015a4c:	f43f ac16 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        (* urc_ping_rsp_callback)(ping_rsp);
 8015a50:	466c      	mov	r4, sp
 8015a52:	ad14      	add	r5, sp, #80	; 0x50
 8015a54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a56:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015a58:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a5a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015a5c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015a5e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015a60:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8015a64:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 8015a68:	ab10      	add	r3, sp, #64	; 0x40
 8015a6a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8015a6c:	47b0      	blx	r6
 8015a6e:	e405      	b.n	801527c <CELLULAR_urc_notif+0xd8>
    if (DATAPACK_readStruct(p_rsp_buf,
 8015a70:	ab10      	add	r3, sp, #64	; 0x40
 8015a72:	2202      	movs	r2, #2
 8015a74:	210f      	movs	r1, #15
 8015a76:	4630      	mov	r0, r6
 8015a78:	f7f6 fc3c 	bl	800c2f4 <DATAPACK_readStruct>
 8015a7c:	2800      	cmp	r0, #0
 8015a7e:	f47f abfd 	bne.w	801527c <CELLULAR_urc_notif+0xd8>
      PRINT_DBG("MODEM events received= 0x%x", modem_events)
 8015a82:	4c13      	ldr	r4, [pc, #76]	; (8015ad0 <CELLULAR_urc_notif+0x92c>)
 8015a84:	f8bd 2040 	ldrh.w	r2, [sp, #64]	; 0x40
 8015a88:	491b      	ldr	r1, [pc, #108]	; (8015af8 <CELLULAR_urc_notif+0x954>)
 8015a8a:	4620      	mov	r0, r4
 8015a8c:	f010 fedc 	bl	8026848 <sprintf>
 8015a90:	4620      	mov	r0, r4
 8015a92:	f009 fc4a 	bl	801f32a <crs_strlen>
 8015a96:	b283      	uxth	r3, r0
 8015a98:	4622      	mov	r2, r4
 8015a9a:	2102      	movs	r1, #2
 8015a9c:	2001      	movs	r0, #1
 8015a9e:	f009 fc87 	bl	801f3b0 <traceIF_itmPrint>
 8015aa2:	4620      	mov	r0, r4
 8015aa4:	f009 fc41 	bl	801f32a <crs_strlen>
 8015aa8:	b283      	uxth	r3, r0
 8015aaa:	4622      	mov	r2, r4
 8015aac:	2102      	movs	r1, #2
 8015aae:	2001      	movs	r0, #1
 8015ab0:	f009 fca0 	bl	801f3f4 <traceIF_uartPrint>
      if (urc_modem_event_callback != NULL)
 8015ab4:	4b11      	ldr	r3, [pc, #68]	; (8015afc <CELLULAR_urc_notif+0x958>)
 8015ab6:	681b      	ldr	r3, [r3, #0]
 8015ab8:	2b00      	cmp	r3, #0
 8015aba:	f43f abdf 	beq.w	801527c <CELLULAR_urc_notif+0xd8>
        (* urc_modem_event_callback)(modem_events);
 8015abe:	f8bd 0040 	ldrh.w	r0, [sp, #64]	; 0x40
 8015ac2:	4798      	blx	r3
 8015ac4:	f7ff bbda 	b.w	801527c <CELLULAR_urc_notif+0xd8>
 8015ac8:	200036a0 	.word	0x200036a0
 8015acc:	08031c34 	.word	0x08031c34
 8015ad0:	200047dc 	.word	0x200047dc
 8015ad4:	20003804 	.word	0x20003804
 8015ad8:	200038cc 	.word	0x200038cc
 8015adc:	08031c70 	.word	0x08031c70
 8015ae0:	20003d18 	.word	0x20003d18
 8015ae4:	08031cb8 	.word	0x08031cb8
 8015ae8:	200038b0 	.word	0x200038b0
 8015aec:	08031cf4 	.word	0x08031cf4
 8015af0:	08031d0c 	.word	0x08031d0c
 8015af4:	200038c8 	.word	0x200038c8
 8015af8:	08031d30 	.word	0x08031d30
 8015afc:	200038ac 	.word	0x200038ac

08015b00 <CELLULAR_analyze_error_report>:
{
 8015b00:	b570      	push	{r4, r5, r6, lr}
 8015b02:	b082      	sub	sp, #8
 8015b04:	4606      	mov	r6, r0
  PRINT_API("<Cellular_Service> CELLULAR_analyze_error_report")
 8015b06:	4c2e      	ldr	r4, [pc, #184]	; (8015bc0 <CELLULAR_analyze_error_report+0xc0>)
 8015b08:	4d2e      	ldr	r5, [pc, #184]	; (8015bc4 <CELLULAR_analyze_error_report+0xc4>)
 8015b0a:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8015b0e:	46a4      	mov	ip, r4
 8015b10:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015b14:	6028      	str	r0, [r5, #0]
 8015b16:	6069      	str	r1, [r5, #4]
 8015b18:	60aa      	str	r2, [r5, #8]
 8015b1a:	60eb      	str	r3, [r5, #12]
 8015b1c:	4664      	mov	r4, ip
 8015b1e:	3510      	adds	r5, #16
 8015b20:	45f4      	cmp	ip, lr
 8015b22:	d1f4      	bne.n	8015b0e <CELLULAR_analyze_error_report+0xe>
 8015b24:	cc03      	ldmia	r4!, {r0, r1}
 8015b26:	6028      	str	r0, [r5, #0]
 8015b28:	6069      	str	r1, [r5, #4]
 8015b2a:	8823      	ldrh	r3, [r4, #0]
 8015b2c:	812b      	strh	r3, [r5, #8]
 8015b2e:	4c25      	ldr	r4, [pc, #148]	; (8015bc4 <CELLULAR_analyze_error_report+0xc4>)
 8015b30:	4620      	mov	r0, r4
 8015b32:	f009 fbfa 	bl	801f32a <crs_strlen>
 8015b36:	b283      	uxth	r3, r0
 8015b38:	4622      	mov	r2, r4
 8015b3a:	2104      	movs	r1, #4
 8015b3c:	2001      	movs	r0, #1
 8015b3e:	f009 fc37 	bl	801f3b0 <traceIF_itmPrint>
 8015b42:	4620      	mov	r0, r4
 8015b44:	f009 fbf1 	bl	801f32a <crs_strlen>
 8015b48:	b283      	uxth	r3, r0
 8015b4a:	4622      	mov	r2, r4
 8015b4c:	2104      	movs	r1, #4
 8015b4e:	2001      	movs	r0, #1
 8015b50:	f009 fc50 	bl	801f3f4 <traceIF_uartPrint>
  msgtype = DATAPACK_readMsgType(p_rsp_buf);
 8015b54:	4630      	mov	r0, r6
 8015b56:	f7f6 fb1b 	bl	800c190 <DATAPACK_readMsgType>
  if (msgtype == (uint16_t) CSMT_ERROR_REPORT)
 8015b5a:	282a      	cmp	r0, #42	; 0x2a
 8015b5c:	d01b      	beq.n	8015b96 <CELLULAR_analyze_error_report+0x96>
  retval = CELLULAR_ERROR;
 8015b5e:	2501      	movs	r5, #1
  PRINT_DBG("CS returned modified value after error report analysis = %d", retval)
 8015b60:	4c18      	ldr	r4, [pc, #96]	; (8015bc4 <CELLULAR_analyze_error_report+0xc4>)
 8015b62:	462a      	mov	r2, r5
 8015b64:	4918      	ldr	r1, [pc, #96]	; (8015bc8 <CELLULAR_analyze_error_report+0xc8>)
 8015b66:	4620      	mov	r0, r4
 8015b68:	f010 fe6e 	bl	8026848 <sprintf>
 8015b6c:	4620      	mov	r0, r4
 8015b6e:	f009 fbdc 	bl	801f32a <crs_strlen>
 8015b72:	b283      	uxth	r3, r0
 8015b74:	4622      	mov	r2, r4
 8015b76:	2102      	movs	r1, #2
 8015b78:	2001      	movs	r0, #1
 8015b7a:	f009 fc19 	bl	801f3b0 <traceIF_itmPrint>
 8015b7e:	4620      	mov	r0, r4
 8015b80:	f009 fbd3 	bl	801f32a <crs_strlen>
 8015b84:	b283      	uxth	r3, r0
 8015b86:	4622      	mov	r2, r4
 8015b88:	2102      	movs	r1, #2
 8015b8a:	2001      	movs	r0, #1
 8015b8c:	f009 fc32 	bl	801f3f4 <traceIF_uartPrint>
}
 8015b90:	4628      	mov	r0, r5
 8015b92:	b002      	add	sp, #8
 8015b94:	bd70      	pop	{r4, r5, r6, pc}
    if (DATAPACK_readStruct(p_rsp_buf,
 8015b96:	ab01      	add	r3, sp, #4
 8015b98:	2202      	movs	r2, #2
 8015b9a:	212a      	movs	r1, #42	; 0x2a
 8015b9c:	4630      	mov	r0, r6
 8015b9e:	f7f6 fba9 	bl	800c2f4 <DATAPACK_readStruct>
 8015ba2:	b950      	cbnz	r0, 8015bba <CELLULAR_analyze_error_report+0xba>
      if (error_report.error_type == CSERR_SIM)
 8015ba4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8015ba8:	2b01      	cmp	r3, #1
 8015baa:	d001      	beq.n	8015bb0 <CELLULAR_analyze_error_report+0xb0>
  retval = CELLULAR_ERROR;
 8015bac:	2501      	movs	r5, #1
 8015bae:	e7d7      	b.n	8015b60 <CELLULAR_analyze_error_report+0x60>
        retval = convert_SIM_error(&error_report);
 8015bb0:	a801      	add	r0, sp, #4
 8015bb2:	f7ff faaa 	bl	801510a <convert_SIM_error>
 8015bb6:	4605      	mov	r5, r0
 8015bb8:	e7d2      	b.n	8015b60 <CELLULAR_analyze_error_report+0x60>
  retval = CELLULAR_ERROR;
 8015bba:	2501      	movs	r5, #1
 8015bbc:	e7d0      	b.n	8015b60 <CELLULAR_analyze_error_report+0x60>
 8015bbe:	bf00      	nop
 8015bc0:	08031d78 	.word	0x08031d78
 8015bc4:	200047dc 	.word	0x200047dc
 8015bc8:	08031db4 	.word	0x08031db4

08015bcc <CELLULAR_reset_socket_context>:
{
 8015bcc:	b538      	push	{r3, r4, r5, lr}
  PRINT_DBG("CELLULAR_reset_socket_context")
 8015bce:	4d19      	ldr	r5, [pc, #100]	; (8015c34 <CELLULAR_reset_socket_context+0x68>)
 8015bd0:	4c19      	ldr	r4, [pc, #100]	; (8015c38 <CELLULAR_reset_socket_context+0x6c>)
 8015bd2:	f105 0e20 	add.w	lr, r5, #32
 8015bd6:	46ac      	mov	ip, r5
 8015bd8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015bdc:	6020      	str	r0, [r4, #0]
 8015bde:	6061      	str	r1, [r4, #4]
 8015be0:	60a2      	str	r2, [r4, #8]
 8015be2:	60e3      	str	r3, [r4, #12]
 8015be4:	4665      	mov	r5, ip
 8015be6:	3410      	adds	r4, #16
 8015be8:	45f4      	cmp	ip, lr
 8015bea:	d1f4      	bne.n	8015bd6 <CELLULAR_reset_socket_context+0xa>
 8015bec:	f8bc 2000 	ldrh.w	r2, [ip]
 8015bf0:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8015bf4:	8022      	strh	r2, [r4, #0]
 8015bf6:	70a3      	strb	r3, [r4, #2]
 8015bf8:	4c0f      	ldr	r4, [pc, #60]	; (8015c38 <CELLULAR_reset_socket_context+0x6c>)
 8015bfa:	4620      	mov	r0, r4
 8015bfc:	f009 fb95 	bl	801f32a <crs_strlen>
 8015c00:	b283      	uxth	r3, r0
 8015c02:	4622      	mov	r2, r4
 8015c04:	2102      	movs	r1, #2
 8015c06:	2001      	movs	r0, #1
 8015c08:	f009 fbd2 	bl	801f3b0 <traceIF_itmPrint>
 8015c0c:	4620      	mov	r0, r4
 8015c0e:	f009 fb8c 	bl	801f32a <crs_strlen>
 8015c12:	b283      	uxth	r3, r0
 8015c14:	4622      	mov	r2, r4
 8015c16:	2102      	movs	r1, #2
 8015c18:	2001      	movs	r0, #1
 8015c1a:	f009 fbeb 	bl	801f3f4 <traceIF_uartPrint>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt ++)
 8015c1e:	2400      	movs	r4, #0
 8015c20:	e004      	b.n	8015c2c <CELLULAR_reset_socket_context+0x60>
    csint_socket_init((socket_handle_t)cpt);
 8015c22:	4620      	mov	r0, r4
 8015c24:	f004 fcbc 	bl	801a5a0 <csint_socket_init>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt ++)
 8015c28:	3401      	adds	r4, #1
 8015c2a:	b2e4      	uxtb	r4, r4
 8015c2c:	2c05      	cmp	r4, #5
 8015c2e:	d9f8      	bls.n	8015c22 <CELLULAR_reset_socket_context+0x56>
}
 8015c30:	bd38      	pop	{r3, r4, r5, pc}
 8015c32:	bf00      	nop
 8015c34:	08031df8 	.word	0x08031df8
 8015c38:	200047dc 	.word	0x200047dc

08015c3c <CELLULAR_init>:
{
 8015c3c:	b510      	push	{r4, lr}
  if (SysCtrl_getDeviceDescriptor(DEVTYPE_MODEM_CELLULAR, &modem_device_infos) == SCSTATUS_OK)
 8015c3e:	490e      	ldr	r1, [pc, #56]	; (8015c78 <CELLULAR_init+0x3c>)
 8015c40:	2000      	movs	r0, #0
 8015c42:	f7ff f95d 	bl	8014f00 <SysCtrl_getDeviceDescriptor>
 8015c46:	b110      	cbz	r0, 8015c4e <CELLULAR_init+0x12>
  CS_Status_t retval = CELLULAR_ERROR;
 8015c48:	2401      	movs	r4, #1
}
 8015c4a:	4620      	mov	r0, r4
 8015c4c:	bd10      	pop	{r4, pc}
 8015c4e:	4604      	mov	r4, r0
    (void) AT_init();
 8015c50:	f7f5 fe06 	bl	800b860 <AT_init>
    _Adapter_Handle = AT_open(&modem_device_infos, CELLULAR_idle_event_notif, CELLULAR_urc_notif);
 8015c54:	4a09      	ldr	r2, [pc, #36]	; (8015c7c <CELLULAR_init+0x40>)
 8015c56:	490a      	ldr	r1, [pc, #40]	; (8015c80 <CELLULAR_init+0x44>)
 8015c58:	4807      	ldr	r0, [pc, #28]	; (8015c78 <CELLULAR_init+0x3c>)
 8015c5a:	f7f5 fe3f 	bl	800b8dc <AT_open>
 8015c5e:	4b09      	ldr	r3, [pc, #36]	; (8015c84 <CELLULAR_init+0x48>)
 8015c60:	8018      	strh	r0, [r3, #0]
    if (_Adapter_Handle != AT_HANDLE_INVALID)
 8015c62:	f1b0 3fff 	cmp.w	r0, #4294967295
 8015c66:	d101      	bne.n	8015c6c <CELLULAR_init+0x30>
  CS_Status_t retval = CELLULAR_ERROR;
 8015c68:	2401      	movs	r4, #1
 8015c6a:	e7ee      	b.n	8015c4a <CELLULAR_init+0xe>
      CELLULAR_reset_context();
 8015c6c:	f7ff fa1c 	bl	80150a8 <CELLULAR_reset_context>
      CELLULAR_reset_socket_context();
 8015c70:	f7ff ffac 	bl	8015bcc <CELLULAR_reset_socket_context>
      retval = CELLULAR_OK;
 8015c74:	e7e9      	b.n	8015c4a <CELLULAR_init+0xe>
 8015c76:	bf00      	nop
 8015c78:	20003810 	.word	0x20003810
 8015c7c:	080151a5 	.word	0x080151a5
 8015c80:	08015109 	.word	0x08015109
 8015c84:	2000361c 	.word	0x2000361c

08015c88 <CS_init>:
{
 8015c88:	b538      	push	{r3, r4, r5, lr}
  PRINT_API("CS_init")
 8015c8a:	4c0f      	ldr	r4, [pc, #60]	; (8015cc8 <CS_init+0x40>)
 8015c8c:	4d0f      	ldr	r5, [pc, #60]	; (8015ccc <CS_init+0x44>)
 8015c8e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015c90:	6020      	str	r0, [r4, #0]
 8015c92:	6061      	str	r1, [r4, #4]
 8015c94:	60a2      	str	r2, [r4, #8]
 8015c96:	60e3      	str	r3, [r4, #12]
 8015c98:	782b      	ldrb	r3, [r5, #0]
 8015c9a:	7423      	strb	r3, [r4, #16]
 8015c9c:	4620      	mov	r0, r4
 8015c9e:	f009 fb44 	bl	801f32a <crs_strlen>
 8015ca2:	b283      	uxth	r3, r0
 8015ca4:	4622      	mov	r2, r4
 8015ca6:	2104      	movs	r1, #4
 8015ca8:	2001      	movs	r0, #1
 8015caa:	f009 fb81 	bl	801f3b0 <traceIF_itmPrint>
 8015cae:	4620      	mov	r0, r4
 8015cb0:	f009 fb3b 	bl	801f32a <crs_strlen>
 8015cb4:	b283      	uxth	r3, r0
 8015cb6:	4622      	mov	r2, r4
 8015cb8:	2104      	movs	r1, #4
 8015cba:	2001      	movs	r0, #1
 8015cbc:	f009 fb9a 	bl	801f3f4 <traceIF_uartPrint>
  retval = CELLULAR_init();
 8015cc0:	f7ff ffbc 	bl	8015c3c <CELLULAR_init>
}
 8015cc4:	bd38      	pop	{r3, r4, r5, pc}
 8015cc6:	bf00      	nop
 8015cc8:	200047dc 	.word	0x200047dc
 8015ccc:	08031e1c 	.word	0x08031e1c

08015cd0 <CS_power_on>:
{
 8015cd0:	b570      	push	{r4, r5, r6, lr}
  PRINT_API("CS_power_on")
 8015cd2:	4c43      	ldr	r4, [pc, #268]	; (8015de0 <CS_power_on+0x110>)
 8015cd4:	4d43      	ldr	r5, [pc, #268]	; (8015de4 <CS_power_on+0x114>)
 8015cd6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015cd8:	6020      	str	r0, [r4, #0]
 8015cda:	6061      	str	r1, [r4, #4]
 8015cdc:	60a2      	str	r2, [r4, #8]
 8015cde:	60e3      	str	r3, [r4, #12]
 8015ce0:	6828      	ldr	r0, [r5, #0]
 8015ce2:	6120      	str	r0, [r4, #16]
 8015ce4:	792b      	ldrb	r3, [r5, #4]
 8015ce6:	7523      	strb	r3, [r4, #20]
 8015ce8:	4620      	mov	r0, r4
 8015cea:	f009 fb1e 	bl	801f32a <crs_strlen>
 8015cee:	b283      	uxth	r3, r0
 8015cf0:	4622      	mov	r2, r4
 8015cf2:	2104      	movs	r1, #4
 8015cf4:	2001      	movs	r0, #1
 8015cf6:	f009 fb5b 	bl	801f3b0 <traceIF_itmPrint>
 8015cfa:	4620      	mov	r0, r4
 8015cfc:	f009 fb15 	bl	801f32a <crs_strlen>
 8015d00:	b283      	uxth	r3, r0
 8015d02:	4622      	mov	r2, r4
 8015d04:	2104      	movs	r1, #4
 8015d06:	2001      	movs	r0, #1
 8015d08:	f009 fb74 	bl	801f3f4 <traceIF_uartPrint>
  if (SysCtrl_power_on(DEVTYPE_MODEM_CELLULAR) == SCSTATUS_OK)
 8015d0c:	2000      	movs	r0, #0
 8015d0e:	f7ff f96d 	bl	8014fec <SysCtrl_power_on>
 8015d12:	b910      	cbnz	r0, 8015d1a <CS_power_on+0x4a>
    if (SysCtrl_open_channel(DEVTYPE_MODEM_CELLULAR) == SCSTATUS_OK)
 8015d14:	f7ff f912 	bl	8014f3c <SysCtrl_open_channel>
 8015d18:	b348      	cbz	r0, 8015d6e <CS_power_on+0x9e>
    PRINT_ERR("<Cellular_Service> error when power on process")
 8015d1a:	4c33      	ldr	r4, [pc, #204]	; (8015de8 <CS_power_on+0x118>)
 8015d1c:	4d30      	ldr	r5, [pc, #192]	; (8015de0 <CS_power_on+0x110>)
 8015d1e:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8015d22:	46a4      	mov	ip, r4
 8015d24:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015d28:	6028      	str	r0, [r5, #0]
 8015d2a:	6069      	str	r1, [r5, #4]
 8015d2c:	60aa      	str	r2, [r5, #8]
 8015d2e:	60eb      	str	r3, [r5, #12]
 8015d30:	4664      	mov	r4, ip
 8015d32:	3510      	adds	r5, #16
 8015d34:	45f4      	cmp	ip, lr
 8015d36:	d1f4      	bne.n	8015d22 <CS_power_on+0x52>
 8015d38:	cc03      	ldmia	r4!, {r0, r1}
 8015d3a:	6028      	str	r0, [r5, #0]
 8015d3c:	6069      	str	r1, [r5, #4]
 8015d3e:	8823      	ldrh	r3, [r4, #0]
 8015d40:	812b      	strh	r3, [r5, #8]
 8015d42:	4c27      	ldr	r4, [pc, #156]	; (8015de0 <CS_power_on+0x110>)
 8015d44:	4620      	mov	r0, r4
 8015d46:	f009 faf0 	bl	801f32a <crs_strlen>
 8015d4a:	b283      	uxth	r3, r0
 8015d4c:	4622      	mov	r2, r4
 8015d4e:	2110      	movs	r1, #16
 8015d50:	2001      	movs	r0, #1
 8015d52:	f009 fb2d 	bl	801f3b0 <traceIF_itmPrint>
 8015d56:	4620      	mov	r0, r4
 8015d58:	f009 fae7 	bl	801f32a <crs_strlen>
 8015d5c:	b283      	uxth	r3, r0
 8015d5e:	4622      	mov	r2, r4
 8015d60:	2110      	movs	r1, #16
 8015d62:	2001      	movs	r0, #1
 8015d64:	f009 fb46 	bl	801f3f4 <traceIF_uartPrint>
 8015d68:	2401      	movs	r4, #1
}
 8015d6a:	4620      	mov	r0, r4
 8015d6c:	bd70      	pop	{r4, r5, r6, pc}
      if (AT_open_channel(_Adapter_Handle) == ATSTATUS_OK)
 8015d6e:	4b1f      	ldr	r3, [pc, #124]	; (8015dec <CS_power_on+0x11c>)
 8015d70:	f9b3 0000 	ldrsh.w	r0, [r3]
 8015d74:	f7f5 fe34 	bl	800b9e0 <AT_open_channel>
 8015d78:	2800      	cmp	r0, #0
 8015d7a:	d1ce      	bne.n	8015d1a <CS_power_on+0x4a>
        if (DATAPACK_writeStruct(&cmd_buf[0],
 8015d7c:	2300      	movs	r3, #0
 8015d7e:	461a      	mov	r2, r3
 8015d80:	2104      	movs	r1, #4
 8015d82:	481b      	ldr	r0, [pc, #108]	; (8015df0 <CS_power_on+0x120>)
 8015d84:	f7f6 f996 	bl	800c0b4 <DATAPACK_writeStruct>
 8015d88:	2800      	cmp	r0, #0
 8015d8a:	d1c6      	bne.n	8015d1a <CS_power_on+0x4a>
          err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_POWER_ON, &cmd_buf[0], &rsp_buf[0]);
 8015d8c:	4b19      	ldr	r3, [pc, #100]	; (8015df4 <CS_power_on+0x124>)
 8015d8e:	4a18      	ldr	r2, [pc, #96]	; (8015df0 <CS_power_on+0x120>)
 8015d90:	2165      	movs	r1, #101	; 0x65
 8015d92:	4816      	ldr	r0, [pc, #88]	; (8015dec <CS_power_on+0x11c>)
 8015d94:	f9b0 0000 	ldrsh.w	r0, [r0]
 8015d98:	f7f5 ff24 	bl	800bbe4 <AT_sendcmd>
          if (err == ATSTATUS_OK)
 8015d9c:	4604      	mov	r4, r0
 8015d9e:	2800      	cmp	r0, #0
 8015da0:	d1bb      	bne.n	8015d1a <CS_power_on+0x4a>
            PRINT_DBG("Cellular started and ready")
 8015da2:	4d0f      	ldr	r5, [pc, #60]	; (8015de0 <CS_power_on+0x110>)
 8015da4:	4e14      	ldr	r6, [pc, #80]	; (8015df8 <CS_power_on+0x128>)
 8015da6:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015da8:	6028      	str	r0, [r5, #0]
 8015daa:	6069      	str	r1, [r5, #4]
 8015dac:	60aa      	str	r2, [r5, #8]
 8015dae:	60eb      	str	r3, [r5, #12]
 8015db0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015db2:	6128      	str	r0, [r5, #16]
 8015db4:	6169      	str	r1, [r5, #20]
 8015db6:	61aa      	str	r2, [r5, #24]
 8015db8:	61eb      	str	r3, [r5, #28]
 8015dba:	4628      	mov	r0, r5
 8015dbc:	f009 fab5 	bl	801f32a <crs_strlen>
 8015dc0:	b283      	uxth	r3, r0
 8015dc2:	462a      	mov	r2, r5
 8015dc4:	2102      	movs	r1, #2
 8015dc6:	2001      	movs	r0, #1
 8015dc8:	f009 faf2 	bl	801f3b0 <traceIF_itmPrint>
 8015dcc:	4628      	mov	r0, r5
 8015dce:	f009 faac 	bl	801f32a <crs_strlen>
 8015dd2:	b283      	uxth	r3, r0
 8015dd4:	462a      	mov	r2, r5
 8015dd6:	2102      	movs	r1, #2
 8015dd8:	2001      	movs	r0, #1
 8015dda:	f009 fb0b 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8015dde:	e7c4      	b.n	8015d6a <CS_power_on+0x9a>
 8015de0:	200047dc 	.word	0x200047dc
 8015de4:	08031e30 	.word	0x08031e30
 8015de8:	08031e68 	.word	0x08031e68
 8015dec:	2000361c 	.word	0x2000361c
 8015df0:	20003620 	.word	0x20003620
 8015df4:	20003814 	.word	0x20003814
 8015df8:	08031e48 	.word	0x08031e48

08015dfc <CS_power_off>:
{
 8015dfc:	b570      	push	{r4, r5, r6, lr}
  PRINT_API("CS_power_off")
 8015dfe:	4c43      	ldr	r4, [pc, #268]	; (8015f0c <CS_power_off+0x110>)
 8015e00:	4d43      	ldr	r5, [pc, #268]	; (8015f10 <CS_power_off+0x114>)
 8015e02:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015e04:	6020      	str	r0, [r4, #0]
 8015e06:	6061      	str	r1, [r4, #4]
 8015e08:	60a2      	str	r2, [r4, #8]
 8015e0a:	60e3      	str	r3, [r4, #12]
 8015e0c:	6828      	ldr	r0, [r5, #0]
 8015e0e:	6120      	str	r0, [r4, #16]
 8015e10:	88ab      	ldrh	r3, [r5, #4]
 8015e12:	82a3      	strh	r3, [r4, #20]
 8015e14:	4620      	mov	r0, r4
 8015e16:	f009 fa88 	bl	801f32a <crs_strlen>
 8015e1a:	b283      	uxth	r3, r0
 8015e1c:	4622      	mov	r2, r4
 8015e1e:	2104      	movs	r1, #4
 8015e20:	2001      	movs	r0, #1
 8015e22:	f009 fac5 	bl	801f3b0 <traceIF_itmPrint>
 8015e26:	4620      	mov	r0, r4
 8015e28:	f009 fa7f 	bl	801f32a <crs_strlen>
 8015e2c:	b283      	uxth	r3, r0
 8015e2e:	4622      	mov	r2, r4
 8015e30:	2104      	movs	r1, #4
 8015e32:	2001      	movs	r0, #1
 8015e34:	f009 fade 	bl	801f3f4 <traceIF_uartPrint>
  CELLULAR_reset_context();
 8015e38:	f7ff f936 	bl	80150a8 <CELLULAR_reset_context>
  csint_modem_reset_update_socket_state();
 8015e3c:	f004 fb66 	bl	801a50c <csint_modem_reset_update_socket_state>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8015e40:	2300      	movs	r3, #0
 8015e42:	461a      	mov	r2, r3
 8015e44:	2104      	movs	r1, #4
 8015e46:	4833      	ldr	r0, [pc, #204]	; (8015f14 <CS_power_off+0x118>)
 8015e48:	f7f6 f934 	bl	800c0b4 <DATAPACK_writeStruct>
 8015e4c:	b998      	cbnz	r0, 8015e76 <CS_power_off+0x7a>
    (void) AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_POWER_OFF, &cmd_buf[0], &rsp_buf[0]);
 8015e4e:	4c32      	ldr	r4, [pc, #200]	; (8015f18 <CS_power_off+0x11c>)
 8015e50:	4b32      	ldr	r3, [pc, #200]	; (8015f1c <CS_power_off+0x120>)
 8015e52:	4a30      	ldr	r2, [pc, #192]	; (8015f14 <CS_power_off+0x118>)
 8015e54:	2166      	movs	r1, #102	; 0x66
 8015e56:	f9b4 0000 	ldrsh.w	r0, [r4]
 8015e5a:	f7f5 fec3 	bl	800bbe4 <AT_sendcmd>
    (void) AT_close_channel(_Adapter_Handle);
 8015e5e:	f9b4 0000 	ldrsh.w	r0, [r4]
 8015e62:	f7f5 fe5f 	bl	800bb24 <AT_close_channel>
    (void) SysCtrl_close_channel(DEVTYPE_MODEM_CELLULAR);
 8015e66:	2000      	movs	r0, #0
 8015e68:	f7ff f894 	bl	8014f94 <SysCtrl_close_channel>
    if (SysCtrl_power_off(DEVTYPE_MODEM_CELLULAR) == SCSTATUS_OK)
 8015e6c:	2000      	movs	r0, #0
 8015e6e:	f7ff f8e9 	bl	8015044 <SysCtrl_power_off>
 8015e72:	4604      	mov	r4, r0
 8015e74:	b350      	cbz	r0, 8015ecc <CS_power_off+0xd0>
    PRINT_ERR("<Cellular_Service> error during power off process")
 8015e76:	4c2a      	ldr	r4, [pc, #168]	; (8015f20 <CS_power_off+0x124>)
 8015e78:	4d24      	ldr	r5, [pc, #144]	; (8015f0c <CS_power_off+0x110>)
 8015e7a:	f104 0630 	add.w	r6, r4, #48	; 0x30
 8015e7e:	46a4      	mov	ip, r4
 8015e80:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015e84:	6028      	str	r0, [r5, #0]
 8015e86:	6069      	str	r1, [r5, #4]
 8015e88:	60aa      	str	r2, [r5, #8]
 8015e8a:	60eb      	str	r3, [r5, #12]
 8015e8c:	4664      	mov	r4, ip
 8015e8e:	3510      	adds	r5, #16
 8015e90:	45b4      	cmp	ip, r6
 8015e92:	d1f4      	bne.n	8015e7e <CS_power_off+0x82>
 8015e94:	cc07      	ldmia	r4!, {r0, r1, r2}
 8015e96:	6028      	str	r0, [r5, #0]
 8015e98:	6069      	str	r1, [r5, #4]
 8015e9a:	60aa      	str	r2, [r5, #8]
 8015e9c:	7823      	ldrb	r3, [r4, #0]
 8015e9e:	732b      	strb	r3, [r5, #12]
 8015ea0:	4c1a      	ldr	r4, [pc, #104]	; (8015f0c <CS_power_off+0x110>)
 8015ea2:	4620      	mov	r0, r4
 8015ea4:	f009 fa41 	bl	801f32a <crs_strlen>
 8015ea8:	b283      	uxth	r3, r0
 8015eaa:	4622      	mov	r2, r4
 8015eac:	2110      	movs	r1, #16
 8015eae:	2001      	movs	r0, #1
 8015eb0:	f009 fa7e 	bl	801f3b0 <traceIF_itmPrint>
 8015eb4:	4620      	mov	r0, r4
 8015eb6:	f009 fa38 	bl	801f32a <crs_strlen>
 8015eba:	b283      	uxth	r3, r0
 8015ebc:	4622      	mov	r2, r4
 8015ebe:	2110      	movs	r1, #16
 8015ec0:	2001      	movs	r0, #1
 8015ec2:	f009 fa97 	bl	801f3f4 <traceIF_uartPrint>
 8015ec6:	2401      	movs	r4, #1
}
 8015ec8:	4620      	mov	r0, r4
 8015eca:	bd70      	pop	{r4, r5, r6, pc}
      PRINT_DBG("<Cellular_Service> Stopped")
 8015ecc:	4d0f      	ldr	r5, [pc, #60]	; (8015f0c <CS_power_off+0x110>)
 8015ece:	4e15      	ldr	r6, [pc, #84]	; (8015f24 <CS_power_off+0x128>)
 8015ed0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015ed2:	6028      	str	r0, [r5, #0]
 8015ed4:	6069      	str	r1, [r5, #4]
 8015ed6:	60aa      	str	r2, [r5, #8]
 8015ed8:	60eb      	str	r3, [r5, #12]
 8015eda:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8015edc:	6128      	str	r0, [r5, #16]
 8015ede:	6169      	str	r1, [r5, #20]
 8015ee0:	61aa      	str	r2, [r5, #24]
 8015ee2:	61eb      	str	r3, [r5, #28]
 8015ee4:	4628      	mov	r0, r5
 8015ee6:	f009 fa20 	bl	801f32a <crs_strlen>
 8015eea:	b283      	uxth	r3, r0
 8015eec:	462a      	mov	r2, r5
 8015eee:	2102      	movs	r1, #2
 8015ef0:	2001      	movs	r0, #1
 8015ef2:	f009 fa5d 	bl	801f3b0 <traceIF_itmPrint>
 8015ef6:	4628      	mov	r0, r5
 8015ef8:	f009 fa17 	bl	801f32a <crs_strlen>
 8015efc:	b283      	uxth	r3, r0
 8015efe:	462a      	mov	r2, r5
 8015f00:	2102      	movs	r1, #2
 8015f02:	2001      	movs	r0, #1
 8015f04:	f009 fa76 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8015f08:	e7de      	b.n	8015ec8 <CS_power_off+0xcc>
 8015f0a:	bf00      	nop
 8015f0c:	200047dc 	.word	0x200047dc
 8015f10:	08031ea4 	.word	0x08031ea4
 8015f14:	20003620 	.word	0x20003620
 8015f18:	2000361c 	.word	0x2000361c
 8015f1c:	20003814 	.word	0x20003814
 8015f20:	08031edc 	.word	0x08031edc
 8015f24:	08031ebc 	.word	0x08031ebc

08015f28 <CS_sim_select>:
{
 8015f28:	b530      	push	{r4, r5, lr}
 8015f2a:	b083      	sub	sp, #12
 8015f2c:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_sim_select")
 8015f30:	4c3c      	ldr	r4, [pc, #240]	; (8016024 <CS_sim_select+0xfc>)
 8015f32:	4d3d      	ldr	r5, [pc, #244]	; (8016028 <CS_sim_select+0x100>)
 8015f34:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015f36:	6020      	str	r0, [r4, #0]
 8015f38:	6061      	str	r1, [r4, #4]
 8015f3a:	60a2      	str	r2, [r4, #8]
 8015f3c:	60e3      	str	r3, [r4, #12]
 8015f3e:	6828      	ldr	r0, [r5, #0]
 8015f40:	6120      	str	r0, [r4, #16]
 8015f42:	88aa      	ldrh	r2, [r5, #4]
 8015f44:	79ab      	ldrb	r3, [r5, #6]
 8015f46:	82a2      	strh	r2, [r4, #20]
 8015f48:	75a3      	strb	r3, [r4, #22]
 8015f4a:	4620      	mov	r0, r4
 8015f4c:	f009 f9ed 	bl	801f32a <crs_strlen>
 8015f50:	b283      	uxth	r3, r0
 8015f52:	4622      	mov	r2, r4
 8015f54:	2104      	movs	r1, #4
 8015f56:	2001      	movs	r0, #1
 8015f58:	f009 fa2a 	bl	801f3b0 <traceIF_itmPrint>
 8015f5c:	4620      	mov	r0, r4
 8015f5e:	f009 f9e4 	bl	801f32a <crs_strlen>
 8015f62:	b283      	uxth	r3, r0
 8015f64:	4622      	mov	r2, r4
 8015f66:	2104      	movs	r1, #4
 8015f68:	2001      	movs	r0, #1
 8015f6a:	f009 fa43 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8015f6e:	f10d 0307 	add.w	r3, sp, #7
 8015f72:	2201      	movs	r2, #1
 8015f74:	212c      	movs	r1, #44	; 0x2c
 8015f76:	482d      	ldr	r0, [pc, #180]	; (801602c <CS_sim_select+0x104>)
 8015f78:	f7f6 f89c 	bl	800c0b4 <DATAPACK_writeStruct>
 8015f7c:	b948      	cbnz	r0, 8015f92 <CS_sim_select+0x6a>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SIM_SELECT, &cmd_buf[0], &rsp_buf[0]);
 8015f7e:	4b2c      	ldr	r3, [pc, #176]	; (8016030 <CS_sim_select+0x108>)
 8015f80:	4a2a      	ldr	r2, [pc, #168]	; (801602c <CS_sim_select+0x104>)
 8015f82:	2187      	movs	r1, #135	; 0x87
 8015f84:	482b      	ldr	r0, [pc, #172]	; (8016034 <CS_sim_select+0x10c>)
 8015f86:	f9b0 0000 	ldrsh.w	r0, [r0]
 8015f8a:	f7f5 fe2b 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8015f8e:	4604      	mov	r4, r0
 8015f90:	b370      	cbz	r0, 8015ff0 <CS_sim_select+0xc8>
    PRINT_ERR("<Cellular_Service> error with sim selection")
 8015f92:	4d29      	ldr	r5, [pc, #164]	; (8016038 <CS_sim_select+0x110>)
 8015f94:	4c23      	ldr	r4, [pc, #140]	; (8016024 <CS_sim_select+0xfc>)
 8015f96:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8015f9a:	46ac      	mov	ip, r5
 8015f9c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8015fa0:	6020      	str	r0, [r4, #0]
 8015fa2:	6061      	str	r1, [r4, #4]
 8015fa4:	60a2      	str	r2, [r4, #8]
 8015fa6:	60e3      	str	r3, [r4, #12]
 8015fa8:	4665      	mov	r5, ip
 8015faa:	3410      	adds	r4, #16
 8015fac:	45f4      	cmp	ip, lr
 8015fae:	d1f4      	bne.n	8015f9a <CS_sim_select+0x72>
 8015fb0:	f8dc 0000 	ldr.w	r0, [ip]
 8015fb4:	6020      	str	r0, [r4, #0]
 8015fb6:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8015fba:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8015fbe:	80a2      	strh	r2, [r4, #4]
 8015fc0:	71a3      	strb	r3, [r4, #6]
 8015fc2:	4c18      	ldr	r4, [pc, #96]	; (8016024 <CS_sim_select+0xfc>)
 8015fc4:	4620      	mov	r0, r4
 8015fc6:	f009 f9b0 	bl	801f32a <crs_strlen>
 8015fca:	b283      	uxth	r3, r0
 8015fcc:	4622      	mov	r2, r4
 8015fce:	2110      	movs	r1, #16
 8015fd0:	2001      	movs	r0, #1
 8015fd2:	f009 f9ed 	bl	801f3b0 <traceIF_itmPrint>
 8015fd6:	4620      	mov	r0, r4
 8015fd8:	f009 f9a7 	bl	801f32a <crs_strlen>
 8015fdc:	b283      	uxth	r3, r0
 8015fde:	4622      	mov	r2, r4
 8015fe0:	2110      	movs	r1, #16
 8015fe2:	2001      	movs	r0, #1
 8015fe4:	f009 fa06 	bl	801f3f4 <traceIF_uartPrint>
 8015fe8:	2401      	movs	r4, #1
}
 8015fea:	4620      	mov	r0, r4
 8015fec:	b003      	add	sp, #12
 8015fee:	bd30      	pop	{r4, r5, pc}
      PRINT_DBG("<Cellular_Service> SIM %d selected", simSelected)
 8015ff0:	4d0c      	ldr	r5, [pc, #48]	; (8016024 <CS_sim_select+0xfc>)
 8015ff2:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8015ff6:	4911      	ldr	r1, [pc, #68]	; (801603c <CS_sim_select+0x114>)
 8015ff8:	4628      	mov	r0, r5
 8015ffa:	f010 fc25 	bl	8026848 <sprintf>
 8015ffe:	4628      	mov	r0, r5
 8016000:	f009 f993 	bl	801f32a <crs_strlen>
 8016004:	b283      	uxth	r3, r0
 8016006:	462a      	mov	r2, r5
 8016008:	2102      	movs	r1, #2
 801600a:	2001      	movs	r0, #1
 801600c:	f009 f9d0 	bl	801f3b0 <traceIF_itmPrint>
 8016010:	4628      	mov	r0, r5
 8016012:	f009 f98a 	bl	801f32a <crs_strlen>
 8016016:	b283      	uxth	r3, r0
 8016018:	462a      	mov	r2, r5
 801601a:	2102      	movs	r1, #2
 801601c:	2001      	movs	r0, #1
 801601e:	f009 f9e9 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016022:	e7e2      	b.n	8015fea <CS_sim_select+0xc2>
 8016024:	200047dc 	.word	0x200047dc
 8016028:	08031f1c 	.word	0x08031f1c
 801602c:	20003620 	.word	0x20003620
 8016030:	20003814 	.word	0x20003814
 8016034:	2000361c 	.word	0x2000361c
 8016038:	08031f5c 	.word	0x08031f5c
 801603c:	08031f34 	.word	0x08031f34

08016040 <CS_init_modem>:
{
 8016040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016044:	b086      	sub	sp, #24
 8016046:	4680      	mov	r8, r0
 8016048:	460f      	mov	r7, r1
 801604a:	4616      	mov	r6, r2
  PRINT_API("CS_init_modem")
 801604c:	4c4d      	ldr	r4, [pc, #308]	; (8016184 <CS_init_modem+0x144>)
 801604e:	4d4e      	ldr	r5, [pc, #312]	; (8016188 <CS_init_modem+0x148>)
 8016050:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016052:	6020      	str	r0, [r4, #0]
 8016054:	6061      	str	r1, [r4, #4]
 8016056:	60a2      	str	r2, [r4, #8]
 8016058:	60e3      	str	r3, [r4, #12]
 801605a:	6828      	ldr	r0, [r5, #0]
 801605c:	6120      	str	r0, [r4, #16]
 801605e:	88aa      	ldrh	r2, [r5, #4]
 8016060:	79ab      	ldrb	r3, [r5, #6]
 8016062:	82a2      	strh	r2, [r4, #20]
 8016064:	75a3      	strb	r3, [r4, #22]
 8016066:	4620      	mov	r0, r4
 8016068:	f009 f95f 	bl	801f32a <crs_strlen>
 801606c:	b283      	uxth	r3, r0
 801606e:	4622      	mov	r2, r4
 8016070:	2104      	movs	r1, #4
 8016072:	2001      	movs	r0, #1
 8016074:	f009 f99c 	bl	801f3b0 <traceIF_itmPrint>
 8016078:	4620      	mov	r0, r4
 801607a:	f009 f956 	bl	801f32a <crs_strlen>
 801607e:	b283      	uxth	r3, r0
 8016080:	4622      	mov	r2, r4
 8016082:	2104      	movs	r1, #4
 8016084:	2001      	movs	r0, #1
 8016086:	f009 f9b5 	bl	801f3f4 <traceIF_uartPrint>
  (void) memset((void *)&modemInit_struct, 0, sizeof(modemInit_struct));
 801608a:	2300      	movs	r3, #0
 801608c:	9301      	str	r3, [sp, #4]
 801608e:	9302      	str	r3, [sp, #8]
 8016090:	9303      	str	r3, [sp, #12]
 8016092:	9304      	str	r3, [sp, #16]
 8016094:	f8ad 3014 	strh.w	r3, [sp, #20]
  modemInit_struct.init = init;
 8016098:	f88d 8004 	strb.w	r8, [sp, #4]
  modemInit_struct.reset = reset;
 801609c:	f88d 7005 	strb.w	r7, [sp, #5]
  (void) memcpy((void *)&modemInit_struct.pincode.pincode[0],
 80160a0:	4630      	mov	r0, r6
 80160a2:	f7ea f8a7 	bl	80001f4 <strlen>
 80160a6:	4602      	mov	r2, r0
 80160a8:	4631      	mov	r1, r6
 80160aa:	f10d 0006 	add.w	r0, sp, #6
 80160ae:	f010 fd1b 	bl	8026ae8 <memcpy>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 80160b2:	ab01      	add	r3, sp, #4
 80160b4:	2212      	movs	r2, #18
 80160b6:	4611      	mov	r1, r2
 80160b8:	4834      	ldr	r0, [pc, #208]	; (801618c <CS_init_modem+0x14c>)
 80160ba:	f7f5 fffb 	bl	800c0b4 <DATAPACK_writeStruct>
 80160be:	2800      	cmp	r0, #0
 80160c0:	d13a      	bne.n	8016138 <CS_init_modem+0xf8>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_INIT_MODEM, &cmd_buf[0], &rsp_buf[0]);
 80160c2:	4b33      	ldr	r3, [pc, #204]	; (8016190 <CS_init_modem+0x150>)
 80160c4:	4a31      	ldr	r2, [pc, #196]	; (801618c <CS_init_modem+0x14c>)
 80160c6:	2167      	movs	r1, #103	; 0x67
 80160c8:	4832      	ldr	r0, [pc, #200]	; (8016194 <CS_init_modem+0x154>)
 80160ca:	f9b0 0000 	ldrsh.w	r0, [r0]
 80160ce:	f7f5 fd89 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 80160d2:	4607      	mov	r7, r0
 80160d4:	bb48      	cbnz	r0, 801612a <CS_init_modem+0xea>
      PRINT_DBG("<Cellular_Service> Init done successfully")
 80160d6:	4d30      	ldr	r5, [pc, #192]	; (8016198 <CS_init_modem+0x158>)
 80160d8:	f105 0620 	add.w	r6, r5, #32
 80160dc:	46ac      	mov	ip, r5
 80160de:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80160e2:	6020      	str	r0, [r4, #0]
 80160e4:	6061      	str	r1, [r4, #4]
 80160e6:	60a2      	str	r2, [r4, #8]
 80160e8:	60e3      	str	r3, [r4, #12]
 80160ea:	4665      	mov	r5, ip
 80160ec:	3410      	adds	r4, #16
 80160ee:	45b4      	cmp	ip, r6
 80160f0:	d1f4      	bne.n	80160dc <CS_init_modem+0x9c>
 80160f2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80160f4:	6020      	str	r0, [r4, #0]
 80160f6:	6061      	str	r1, [r4, #4]
 80160f8:	60a2      	str	r2, [r4, #8]
 80160fa:	882a      	ldrh	r2, [r5, #0]
 80160fc:	78ab      	ldrb	r3, [r5, #2]
 80160fe:	81a2      	strh	r2, [r4, #12]
 8016100:	73a3      	strb	r3, [r4, #14]
 8016102:	4c20      	ldr	r4, [pc, #128]	; (8016184 <CS_init_modem+0x144>)
 8016104:	4620      	mov	r0, r4
 8016106:	f009 f910 	bl	801f32a <crs_strlen>
 801610a:	b283      	uxth	r3, r0
 801610c:	4622      	mov	r2, r4
 801610e:	2102      	movs	r1, #2
 8016110:	2001      	movs	r0, #1
 8016112:	f009 f94d 	bl	801f3b0 <traceIF_itmPrint>
 8016116:	4620      	mov	r0, r4
 8016118:	f009 f907 	bl	801f32a <crs_strlen>
 801611c:	b283      	uxth	r3, r0
 801611e:	4622      	mov	r2, r4
 8016120:	2102      	movs	r1, #2
 8016122:	2001      	movs	r0, #1
 8016124:	f009 f966 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016128:	e028      	b.n	801617c <CS_init_modem+0x13c>
      retval = CELLULAR_analyze_error_report(&rsp_buf[0]);
 801612a:	4819      	ldr	r0, [pc, #100]	; (8016190 <CS_init_modem+0x150>)
 801612c:	f7ff fce8 	bl	8015b00 <CELLULAR_analyze_error_report>
 8016130:	4607      	mov	r7, r0
  if (retval == CELLULAR_ERROR)
 8016132:	2801      	cmp	r0, #1
 8016134:	d122      	bne.n	801617c <CS_init_modem+0x13c>
 8016136:	e000      	b.n	801613a <CS_init_modem+0xfa>
  CS_Status_t retval = CELLULAR_ERROR;
 8016138:	2701      	movs	r7, #1
    PRINT_ERR("<Cellular_Service> error during init")
 801613a:	4e18      	ldr	r6, [pc, #96]	; (801619c <CS_init_modem+0x15c>)
 801613c:	4d11      	ldr	r5, [pc, #68]	; (8016184 <CS_init_modem+0x144>)
 801613e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8016142:	4634      	mov	r4, r6
 8016144:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8016146:	6028      	str	r0, [r5, #0]
 8016148:	6069      	str	r1, [r5, #4]
 801614a:	60aa      	str	r2, [r5, #8]
 801614c:	60eb      	str	r3, [r5, #12]
 801614e:	4626      	mov	r6, r4
 8016150:	3510      	adds	r5, #16
 8016152:	4564      	cmp	r4, ip
 8016154:	d1f5      	bne.n	8016142 <CS_init_modem+0x102>
 8016156:	4c0b      	ldr	r4, [pc, #44]	; (8016184 <CS_init_modem+0x144>)
 8016158:	4620      	mov	r0, r4
 801615a:	f009 f8e6 	bl	801f32a <crs_strlen>
 801615e:	b283      	uxth	r3, r0
 8016160:	4622      	mov	r2, r4
 8016162:	2110      	movs	r1, #16
 8016164:	2001      	movs	r0, #1
 8016166:	f009 f923 	bl	801f3b0 <traceIF_itmPrint>
 801616a:	4620      	mov	r0, r4
 801616c:	f009 f8dd 	bl	801f32a <crs_strlen>
 8016170:	b283      	uxth	r3, r0
 8016172:	4622      	mov	r2, r4
 8016174:	2110      	movs	r1, #16
 8016176:	2001      	movs	r0, #1
 8016178:	f009 f93c 	bl	801f3f4 <traceIF_uartPrint>
}
 801617c:	4638      	mov	r0, r7
 801617e:	b006      	add	sp, #24
 8016180:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8016184:	200047dc 	.word	0x200047dc
 8016188:	08031f94 	.word	0x08031f94
 801618c:	20003620 	.word	0x20003620
 8016190:	20003814 	.word	0x20003814
 8016194:	2000361c 	.word	0x2000361c
 8016198:	08031fac 	.word	0x08031fac
 801619c:	08031fdc 	.word	0x08031fdc

080161a0 <CS_get_device_info>:
{
 80161a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80161a2:	4607      	mov	r7, r0
  PRINT_API("CS_get_device_info")
 80161a4:	4c4b      	ldr	r4, [pc, #300]	; (80162d4 <CS_get_device_info+0x134>)
 80161a6:	4d4c      	ldr	r5, [pc, #304]	; (80162d8 <CS_get_device_info+0x138>)
 80161a8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80161aa:	6020      	str	r0, [r4, #0]
 80161ac:	6061      	str	r1, [r4, #4]
 80161ae:	60a2      	str	r2, [r4, #8]
 80161b0:	60e3      	str	r3, [r4, #12]
 80161b2:	cd07      	ldmia	r5!, {r0, r1, r2}
 80161b4:	6120      	str	r0, [r4, #16]
 80161b6:	6161      	str	r1, [r4, #20]
 80161b8:	61a2      	str	r2, [r4, #24]
 80161ba:	4620      	mov	r0, r4
 80161bc:	f009 f8b5 	bl	801f32a <crs_strlen>
 80161c0:	b283      	uxth	r3, r0
 80161c2:	4622      	mov	r2, r4
 80161c4:	2104      	movs	r1, #4
 80161c6:	2001      	movs	r0, #1
 80161c8:	f009 f8f2 	bl	801f3b0 <traceIF_itmPrint>
 80161cc:	4620      	mov	r0, r4
 80161ce:	f009 f8ac 	bl	801f32a <crs_strlen>
 80161d2:	b283      	uxth	r3, r0
 80161d4:	4622      	mov	r2, r4
 80161d6:	2104      	movs	r1, #4
 80161d8:	2001      	movs	r0, #1
 80161da:	f009 f90b 	bl	801f3f4 <traceIF_uartPrint>
  (void) memset((void *)&cs_ctxt_device_info, 0, sizeof(cs_ctxt_device_info));
 80161de:	4c3f      	ldr	r4, [pc, #252]	; (80162dc <CS_get_device_info+0x13c>)
 80161e0:	f44f 7281 	mov.w	r2, #258	; 0x102
 80161e4:	2100      	movs	r1, #0
 80161e6:	4620      	mov	r0, r4
 80161e8:	f010 fba1 	bl	802692e <memset>
  cs_ctxt_device_info. field_requested = p_devinfo->field_requested;
 80161ec:	883b      	ldrh	r3, [r7, #0]
 80161ee:	8023      	strh	r3, [r4, #0]
  if (DATAPACK_writePtr(&cmd_buf[0],
 80161f0:	4622      	mov	r2, r4
 80161f2:	2117      	movs	r1, #23
 80161f4:	483a      	ldr	r0, [pc, #232]	; (80162e0 <CS_get_device_info+0x140>)
 80161f6:	f7f5 ff2d 	bl	800c054 <DATAPACK_writePtr>
 80161fa:	2800      	cmp	r0, #0
 80161fc:	d13f      	bne.n	801627e <CS_get_device_info+0xde>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_DEVICE_INFO, &cmd_buf[0], &rsp_buf[0]);
 80161fe:	4b39      	ldr	r3, [pc, #228]	; (80162e4 <CS_get_device_info+0x144>)
 8016200:	4a37      	ldr	r2, [pc, #220]	; (80162e0 <CS_get_device_info+0x140>)
 8016202:	2168      	movs	r1, #104	; 0x68
 8016204:	4838      	ldr	r0, [pc, #224]	; (80162e8 <CS_get_device_info+0x148>)
 8016206:	f9b0 0000 	ldrsh.w	r0, [r0]
 801620a:	f7f5 fceb 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 801620e:	4606      	mov	r6, r0
 8016210:	bb70      	cbnz	r0, 8016270 <CS_get_device_info+0xd0>
      PRINT_DBG("<Cellular_Service> Device infos received")
 8016212:	4d36      	ldr	r5, [pc, #216]	; (80162ec <CS_get_device_info+0x14c>)
 8016214:	4c2f      	ldr	r4, [pc, #188]	; (80162d4 <CS_get_device_info+0x134>)
 8016216:	f105 0e20 	add.w	lr, r5, #32
 801621a:	46ac      	mov	ip, r5
 801621c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016220:	6020      	str	r0, [r4, #0]
 8016222:	6061      	str	r1, [r4, #4]
 8016224:	60a2      	str	r2, [r4, #8]
 8016226:	60e3      	str	r3, [r4, #12]
 8016228:	4665      	mov	r5, ip
 801622a:	3410      	adds	r4, #16
 801622c:	45f4      	cmp	ip, lr
 801622e:	d1f4      	bne.n	801621a <CS_get_device_info+0x7a>
 8016230:	cd07      	ldmia	r5!, {r0, r1, r2}
 8016232:	6020      	str	r0, [r4, #0]
 8016234:	6061      	str	r1, [r4, #4]
 8016236:	60a2      	str	r2, [r4, #8]
 8016238:	882b      	ldrh	r3, [r5, #0]
 801623a:	81a3      	strh	r3, [r4, #12]
 801623c:	4c25      	ldr	r4, [pc, #148]	; (80162d4 <CS_get_device_info+0x134>)
 801623e:	4620      	mov	r0, r4
 8016240:	f009 f873 	bl	801f32a <crs_strlen>
 8016244:	b283      	uxth	r3, r0
 8016246:	4622      	mov	r2, r4
 8016248:	2102      	movs	r1, #2
 801624a:	2001      	movs	r0, #1
 801624c:	f009 f8b0 	bl	801f3b0 <traceIF_itmPrint>
 8016250:	4620      	mov	r0, r4
 8016252:	f009 f86a 	bl	801f32a <crs_strlen>
 8016256:	b283      	uxth	r3, r0
 8016258:	4622      	mov	r2, r4
 801625a:	2102      	movs	r1, #2
 801625c:	2001      	movs	r0, #1
 801625e:	f009 f8c9 	bl	801f3f4 <traceIF_uartPrint>
      (void) memcpy((void *)p_devinfo, (void *)&cs_ctxt_device_info, sizeof(CS_DeviceInfo_t));
 8016262:	f44f 7281 	mov.w	r2, #258	; 0x102
 8016266:	491d      	ldr	r1, [pc, #116]	; (80162dc <CS_get_device_info+0x13c>)
 8016268:	4638      	mov	r0, r7
 801626a:	f010 fc3d 	bl	8026ae8 <memcpy>
  if (retval == CELLULAR_ERROR)
 801626e:	e02f      	b.n	80162d0 <CS_get_device_info+0x130>
      retval = CELLULAR_analyze_error_report(&rsp_buf[0]);
 8016270:	481c      	ldr	r0, [pc, #112]	; (80162e4 <CS_get_device_info+0x144>)
 8016272:	f7ff fc45 	bl	8015b00 <CELLULAR_analyze_error_report>
 8016276:	4606      	mov	r6, r0
  if (retval == CELLULAR_ERROR)
 8016278:	2801      	cmp	r0, #1
 801627a:	d129      	bne.n	80162d0 <CS_get_device_info+0x130>
 801627c:	e000      	b.n	8016280 <CS_get_device_info+0xe0>
  CS_Status_t retval = CELLULAR_ERROR;
 801627e:	2601      	movs	r6, #1
    PRINT_ERR("<Cellular_Service> error when getting device infos")
 8016280:	4c1b      	ldr	r4, [pc, #108]	; (80162f0 <CS_get_device_info+0x150>)
 8016282:	4d14      	ldr	r5, [pc, #80]	; (80162d4 <CS_get_device_info+0x134>)
 8016284:	f104 0730 	add.w	r7, r4, #48	; 0x30
 8016288:	46a4      	mov	ip, r4
 801628a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801628e:	6028      	str	r0, [r5, #0]
 8016290:	6069      	str	r1, [r5, #4]
 8016292:	60aa      	str	r2, [r5, #8]
 8016294:	60eb      	str	r3, [r5, #12]
 8016296:	4664      	mov	r4, ip
 8016298:	3510      	adds	r5, #16
 801629a:	45bc      	cmp	ip, r7
 801629c:	d1f4      	bne.n	8016288 <CS_get_device_info+0xe8>
 801629e:	cc07      	ldmia	r4!, {r0, r1, r2}
 80162a0:	6028      	str	r0, [r5, #0]
 80162a2:	6069      	str	r1, [r5, #4]
 80162a4:	60aa      	str	r2, [r5, #8]
 80162a6:	8823      	ldrh	r3, [r4, #0]
 80162a8:	81ab      	strh	r3, [r5, #12]
 80162aa:	4c0a      	ldr	r4, [pc, #40]	; (80162d4 <CS_get_device_info+0x134>)
 80162ac:	4620      	mov	r0, r4
 80162ae:	f009 f83c 	bl	801f32a <crs_strlen>
 80162b2:	b283      	uxth	r3, r0
 80162b4:	4622      	mov	r2, r4
 80162b6:	2110      	movs	r1, #16
 80162b8:	2001      	movs	r0, #1
 80162ba:	f009 f879 	bl	801f3b0 <traceIF_itmPrint>
 80162be:	4620      	mov	r0, r4
 80162c0:	f009 f833 	bl	801f32a <crs_strlen>
 80162c4:	b283      	uxth	r3, r0
 80162c6:	4622      	mov	r2, r4
 80162c8:	2110      	movs	r1, #16
 80162ca:	2001      	movs	r0, #1
 80162cc:	f009 f892 	bl	801f3f4 <traceIF_uartPrint>
}
 80162d0:	4630      	mov	r0, r6
 80162d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80162d4:	200047dc 	.word	0x200047dc
 80162d8:	0803200c 	.word	0x0803200c
 80162dc:	200036a8 	.word	0x200036a8
 80162e0:	20003620 	.word	0x20003620
 80162e4:	20003814 	.word	0x20003814
 80162e8:	2000361c 	.word	0x2000361c
 80162ec:	08032028 	.word	0x08032028
 80162f0:	08032058 	.word	0x08032058

080162f4 <CS_register_net>:
{
 80162f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80162f6:	4607      	mov	r7, r0
 80162f8:	460e      	mov	r6, r1
  PRINT_API("CS_register_net")
 80162fa:	4c41      	ldr	r4, [pc, #260]	; (8016400 <CS_register_net+0x10c>)
 80162fc:	4d41      	ldr	r5, [pc, #260]	; (8016404 <CS_register_net+0x110>)
 80162fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016300:	6020      	str	r0, [r4, #0]
 8016302:	6061      	str	r1, [r4, #4]
 8016304:	60a2      	str	r2, [r4, #8]
 8016306:	60e3      	str	r3, [r4, #12]
 8016308:	cd03      	ldmia	r5!, {r0, r1}
 801630a:	6120      	str	r0, [r4, #16]
 801630c:	6161      	str	r1, [r4, #20]
 801630e:	782b      	ldrb	r3, [r5, #0]
 8016310:	7623      	strb	r3, [r4, #24]
 8016312:	4620      	mov	r0, r4
 8016314:	f009 f809 	bl	801f32a <crs_strlen>
 8016318:	b283      	uxth	r3, r0
 801631a:	4622      	mov	r2, r4
 801631c:	2104      	movs	r1, #4
 801631e:	2001      	movs	r0, #1
 8016320:	f009 f846 	bl	801f3b0 <traceIF_itmPrint>
 8016324:	4620      	mov	r0, r4
 8016326:	f009 f800 	bl	801f32a <crs_strlen>
 801632a:	b283      	uxth	r3, r0
 801632c:	4622      	mov	r2, r4
 801632e:	2104      	movs	r1, #4
 8016330:	2001      	movs	r0, #1
 8016332:	f009 f85f 	bl	801f3f4 <traceIF_uartPrint>
  p_reg_status->optional_fields_presence = CS_RSF_NONE;
 8016336:	2300      	movs	r3, #0
 8016338:	8133      	strh	r3, [r6, #8]
  p_reg_status->CS_NetworkRegState = CS_NRS_UNKNOWN;
 801633a:	2304      	movs	r3, #4
 801633c:	80f3      	strh	r3, [r6, #6]
  p_reg_status->GPRS_NetworkRegState = CS_NRS_UNKNOWN;
 801633e:	80b3      	strh	r3, [r6, #4]
  p_reg_status->EPS_NetworkRegState = CS_NRS_UNKNOWN;
 8016340:	8073      	strh	r3, [r6, #2]
  (void) memcpy((void *)&cs_ctxt_operator, (void *)p_operator, sizeof(CS_OperatorSelector_t));
 8016342:	4d31      	ldr	r5, [pc, #196]	; (8016408 <CS_register_net+0x114>)
 8016344:	2448      	movs	r4, #72	; 0x48
 8016346:	4622      	mov	r2, r4
 8016348:	4639      	mov	r1, r7
 801634a:	4628      	mov	r0, r5
 801634c:	f010 fbcc 	bl	8026ae8 <memcpy>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016350:	462b      	mov	r3, r5
 8016352:	4622      	mov	r2, r4
 8016354:	2114      	movs	r1, #20
 8016356:	482d      	ldr	r0, [pc, #180]	; (801640c <CS_register_net+0x118>)
 8016358:	f7f5 feac 	bl	800c0b4 <DATAPACK_writeStruct>
 801635c:	b940      	cbnz	r0, 8016370 <CS_register_net+0x7c>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_REGISTER_NET, &cmd_buf[0], &rsp_buf[0]);
 801635e:	4b2c      	ldr	r3, [pc, #176]	; (8016410 <CS_register_net+0x11c>)
 8016360:	4a2a      	ldr	r2, [pc, #168]	; (801640c <CS_register_net+0x118>)
 8016362:	2169      	movs	r1, #105	; 0x69
 8016364:	482b      	ldr	r0, [pc, #172]	; (8016414 <CS_register_net+0x120>)
 8016366:	f9b0 0000 	ldrsh.w	r0, [r0]
 801636a:	f7f5 fc3b 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 801636e:	b1d0      	cbz	r0, 80163a6 <CS_register_net+0xb2>
    PRINT_ERR("<Cellular_Service> error during network registration ")
 8016370:	4c23      	ldr	r4, [pc, #140]	; (8016400 <CS_register_net+0x10c>)
 8016372:	2241      	movs	r2, #65	; 0x41
 8016374:	4928      	ldr	r1, [pc, #160]	; (8016418 <CS_register_net+0x124>)
 8016376:	4620      	mov	r0, r4
 8016378:	f010 fbb6 	bl	8026ae8 <memcpy>
 801637c:	4620      	mov	r0, r4
 801637e:	f008 ffd4 	bl	801f32a <crs_strlen>
 8016382:	b283      	uxth	r3, r0
 8016384:	4622      	mov	r2, r4
 8016386:	2110      	movs	r1, #16
 8016388:	2001      	movs	r0, #1
 801638a:	f009 f811 	bl	801f3b0 <traceIF_itmPrint>
 801638e:	4620      	mov	r0, r4
 8016390:	f008 ffcb 	bl	801f32a <crs_strlen>
 8016394:	b283      	uxth	r3, r0
 8016396:	4622      	mov	r2, r4
 8016398:	2110      	movs	r1, #16
 801639a:	2001      	movs	r0, #1
 801639c:	f009 f82a 	bl	801f3f4 <traceIF_uartPrint>
 80163a0:	2401      	movs	r4, #1
}
 80163a2:	4620      	mov	r0, r4
 80163a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 80163a6:	4633      	mov	r3, r6
 80163a8:	224e      	movs	r2, #78	; 0x4e
 80163aa:	2115      	movs	r1, #21
 80163ac:	4818      	ldr	r0, [pc, #96]	; (8016410 <CS_register_net+0x11c>)
 80163ae:	f7f5 ffa1 	bl	800c2f4 <DATAPACK_readStruct>
 80163b2:	4604      	mov	r4, r0
 80163b4:	2800      	cmp	r0, #0
 80163b6:	d1db      	bne.n	8016370 <CS_register_net+0x7c>
        PRINT_DBG("<Cellular_Service> Network registration done")
 80163b8:	4f18      	ldr	r7, [pc, #96]	; (801641c <CS_register_net+0x128>)
 80163ba:	4e11      	ldr	r6, [pc, #68]	; (8016400 <CS_register_net+0x10c>)
 80163bc:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 80163c0:	463d      	mov	r5, r7
 80163c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80163c4:	6030      	str	r0, [r6, #0]
 80163c6:	6071      	str	r1, [r6, #4]
 80163c8:	60b2      	str	r2, [r6, #8]
 80163ca:	60f3      	str	r3, [r6, #12]
 80163cc:	462f      	mov	r7, r5
 80163ce:	3610      	adds	r6, #16
 80163d0:	4565      	cmp	r5, ip
 80163d2:	d1f5      	bne.n	80163c0 <CS_register_net+0xcc>
 80163d4:	882b      	ldrh	r3, [r5, #0]
 80163d6:	8033      	strh	r3, [r6, #0]
 80163d8:	4d09      	ldr	r5, [pc, #36]	; (8016400 <CS_register_net+0x10c>)
 80163da:	4628      	mov	r0, r5
 80163dc:	f008 ffa5 	bl	801f32a <crs_strlen>
 80163e0:	b283      	uxth	r3, r0
 80163e2:	462a      	mov	r2, r5
 80163e4:	2102      	movs	r1, #2
 80163e6:	2001      	movs	r0, #1
 80163e8:	f008 ffe2 	bl	801f3b0 <traceIF_itmPrint>
 80163ec:	4628      	mov	r0, r5
 80163ee:	f008 ff9c 	bl	801f32a <crs_strlen>
 80163f2:	b283      	uxth	r3, r0
 80163f4:	462a      	mov	r2, r5
 80163f6:	2102      	movs	r1, #2
 80163f8:	2001      	movs	r0, #1
 80163fa:	f008 fffb 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80163fe:	e7d0      	b.n	80163a2 <CS_register_net+0xae>
 8016400:	200047dc 	.word	0x200047dc
 8016404:	08032098 	.word	0x08032098
 8016408:	200037bc 	.word	0x200037bc
 801640c:	20003620 	.word	0x20003620
 8016410:	20003814 	.word	0x20003814
 8016414:	2000361c 	.word	0x2000361c
 8016418:	080320e8 	.word	0x080320e8
 801641c:	080320b4 	.word	0x080320b4

08016420 <CS_subscribe_net_event>:
{
 8016420:	b570      	push	{r4, r5, r6, lr}
 8016422:	b082      	sub	sp, #8
 8016424:	460e      	mov	r6, r1
 8016426:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_subscribe_net_event")
 801642a:	4c5f      	ldr	r4, [pc, #380]	; (80165a8 <CS_subscribe_net_event+0x188>)
 801642c:	4d5f      	ldr	r5, [pc, #380]	; (80165ac <CS_subscribe_net_event+0x18c>)
 801642e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016430:	6020      	str	r0, [r4, #0]
 8016432:	6061      	str	r1, [r4, #4]
 8016434:	60a2      	str	r2, [r4, #8]
 8016436:	60e3      	str	r3, [r4, #12]
 8016438:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801643a:	6120      	str	r0, [r4, #16]
 801643c:	6161      	str	r1, [r4, #20]
 801643e:	61a2      	str	r2, [r4, #24]
 8016440:	61e3      	str	r3, [r4, #28]
 8016442:	4620      	mov	r0, r4
 8016444:	f008 ff71 	bl	801f32a <crs_strlen>
 8016448:	b283      	uxth	r3, r0
 801644a:	4622      	mov	r2, r4
 801644c:	2104      	movs	r1, #4
 801644e:	2001      	movs	r0, #1
 8016450:	f008 ffae 	bl	801f3b0 <traceIF_itmPrint>
 8016454:	4620      	mov	r0, r4
 8016456:	f008 ff68 	bl	801f32a <crs_strlen>
 801645a:	b283      	uxth	r3, r0
 801645c:	4622      	mov	r2, r4
 801645e:	2104      	movs	r1, #4
 8016460:	2001      	movs	r0, #1
 8016462:	f008 ffc7 	bl	801f3f4 <traceIF_uartPrint>
  if (event == CS_URCEVENT_EPS_NETWORK_REG_STAT)
 8016466:	f89d 3007 	ldrb.w	r3, [sp, #7]
 801646a:	2b01      	cmp	r3, #1
 801646c:	d007      	beq.n	801647e <CS_subscribe_net_event+0x5e>
  else if (event == CS_URCEVENT_GPRS_NETWORK_REG_STAT)
 801646e:	3b02      	subs	r3, #2
 8016470:	2b05      	cmp	r3, #5
 8016472:	d863      	bhi.n	801653c <CS_subscribe_net_event+0x11c>
 8016474:	e8df f003 	tbb	[pc, r3]
 8016478:	44503e4a 	.word	0x44503e4a
 801647c:	5c56      	.short	0x5c56
    urc_eps_network_registration_callback = urc_callback;
 801647e:	4b4c      	ldr	r3, [pc, #304]	; (80165b0 <CS_subscribe_net_event+0x190>)
 8016480:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.eps_network_registration = CELLULAR_TRUE;
 8016482:	4b4c      	ldr	r3, [pc, #304]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016484:	2201      	movs	r2, #1
 8016486:	701a      	strb	r2, [r3, #0]
    if (DATAPACK_writeStruct(&cmd_buf[0],
 8016488:	f10d 0307 	add.w	r3, sp, #7
 801648c:	2201      	movs	r2, #1
 801648e:	2116      	movs	r1, #22
 8016490:	4849      	ldr	r0, [pc, #292]	; (80165b8 <CS_subscribe_net_event+0x198>)
 8016492:	f7f5 fe0f 	bl	800c0b4 <DATAPACK_writeStruct>
 8016496:	2800      	cmp	r0, #0
 8016498:	d077      	beq.n	801658a <CS_subscribe_net_event+0x16a>
      retval = CELLULAR_ERROR;
 801649a:	2601      	movs	r6, #1
    PRINT_ERR("<Cellular_Service> error when subscribing event")
 801649c:	4c47      	ldr	r4, [pc, #284]	; (80165bc <CS_subscribe_net_event+0x19c>)
 801649e:	4d42      	ldr	r5, [pc, #264]	; (80165a8 <CS_subscribe_net_event+0x188>)
 80164a0:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 80164a4:	46a4      	mov	ip, r4
 80164a6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80164aa:	6028      	str	r0, [r5, #0]
 80164ac:	6069      	str	r1, [r5, #4]
 80164ae:	60aa      	str	r2, [r5, #8]
 80164b0:	60eb      	str	r3, [r5, #12]
 80164b2:	4664      	mov	r4, ip
 80164b4:	3510      	adds	r5, #16
 80164b6:	45f4      	cmp	ip, lr
 80164b8:	d1f4      	bne.n	80164a4 <CS_subscribe_net_event+0x84>
 80164ba:	cc03      	ldmia	r4!, {r0, r1}
 80164bc:	6028      	str	r0, [r5, #0]
 80164be:	6069      	str	r1, [r5, #4]
 80164c0:	8822      	ldrh	r2, [r4, #0]
 80164c2:	78a3      	ldrb	r3, [r4, #2]
 80164c4:	812a      	strh	r2, [r5, #8]
 80164c6:	72ab      	strb	r3, [r5, #10]
 80164c8:	4c37      	ldr	r4, [pc, #220]	; (80165a8 <CS_subscribe_net_event+0x188>)
 80164ca:	4620      	mov	r0, r4
 80164cc:	f008 ff2d 	bl	801f32a <crs_strlen>
 80164d0:	b283      	uxth	r3, r0
 80164d2:	4622      	mov	r2, r4
 80164d4:	2110      	movs	r1, #16
 80164d6:	2001      	movs	r0, #1
 80164d8:	f008 ff6a 	bl	801f3b0 <traceIF_itmPrint>
 80164dc:	4620      	mov	r0, r4
 80164de:	f008 ff24 	bl	801f32a <crs_strlen>
 80164e2:	b283      	uxth	r3, r0
 80164e4:	4622      	mov	r2, r4
 80164e6:	2110      	movs	r1, #16
 80164e8:	2001      	movs	r0, #1
 80164ea:	f008 ff83 	bl	801f3f4 <traceIF_uartPrint>
}
 80164ee:	4630      	mov	r0, r6
 80164f0:	b002      	add	sp, #8
 80164f2:	bd70      	pop	{r4, r5, r6, pc}
    urc_gprs_network_registration_callback = urc_callback;
 80164f4:	4b32      	ldr	r3, [pc, #200]	; (80165c0 <CS_subscribe_net_event+0x1a0>)
 80164f6:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.gprs_network_registration = CELLULAR_TRUE;
 80164f8:	4b2e      	ldr	r3, [pc, #184]	; (80165b4 <CS_subscribe_net_event+0x194>)
 80164fa:	2201      	movs	r2, #1
 80164fc:	705a      	strb	r2, [r3, #1]
  if (retval != CELLULAR_ERROR)
 80164fe:	e7c3      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_cs_network_registration_callback = urc_callback;
 8016500:	4b30      	ldr	r3, [pc, #192]	; (80165c4 <CS_subscribe_net_event+0x1a4>)
 8016502:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.cs_network_registration = CELLULAR_TRUE;
 8016504:	4b2b      	ldr	r3, [pc, #172]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016506:	2201      	movs	r2, #1
 8016508:	709a      	strb	r2, [r3, #2]
  if (retval != CELLULAR_ERROR)
 801650a:	e7bd      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_eps_location_info_callback = urc_callback;
 801650c:	4b2e      	ldr	r3, [pc, #184]	; (80165c8 <CS_subscribe_net_event+0x1a8>)
 801650e:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.eps_location_info = CELLULAR_TRUE;
 8016510:	4b28      	ldr	r3, [pc, #160]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016512:	2201      	movs	r2, #1
 8016514:	70da      	strb	r2, [r3, #3]
  if (retval != CELLULAR_ERROR)
 8016516:	e7b7      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_gprs_location_info_callback = urc_callback;
 8016518:	4b2c      	ldr	r3, [pc, #176]	; (80165cc <CS_subscribe_net_event+0x1ac>)
 801651a:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.gprs_location_info = CELLULAR_TRUE;
 801651c:	4b25      	ldr	r3, [pc, #148]	; (80165b4 <CS_subscribe_net_event+0x194>)
 801651e:	2201      	movs	r2, #1
 8016520:	711a      	strb	r2, [r3, #4]
  if (retval != CELLULAR_ERROR)
 8016522:	e7b1      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_cs_location_info_callback = urc_callback;
 8016524:	4b2a      	ldr	r3, [pc, #168]	; (80165d0 <CS_subscribe_net_event+0x1b0>)
 8016526:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.cs_location_info = CELLULAR_TRUE;
 8016528:	4b22      	ldr	r3, [pc, #136]	; (80165b4 <CS_subscribe_net_event+0x194>)
 801652a:	2201      	movs	r2, #1
 801652c:	715a      	strb	r2, [r3, #5]
  if (retval != CELLULAR_ERROR)
 801652e:	e7ab      	b.n	8016488 <CS_subscribe_net_event+0x68>
    urc_signal_quality_callback = urc_callback;
 8016530:	4b28      	ldr	r3, [pc, #160]	; (80165d4 <CS_subscribe_net_event+0x1b4>)
 8016532:	601e      	str	r6, [r3, #0]
    cs_ctxt_urc_subscription.signal_quality = CELLULAR_TRUE;
 8016534:	4b1f      	ldr	r3, [pc, #124]	; (80165b4 <CS_subscribe_net_event+0x194>)
 8016536:	2201      	movs	r2, #1
 8016538:	719a      	strb	r2, [r3, #6]
  if (retval != CELLULAR_ERROR)
 801653a:	e7a5      	b.n	8016488 <CS_subscribe_net_event+0x68>
    PRINT_ERR("<Cellular_Service> invalid event")
 801653c:	4c26      	ldr	r4, [pc, #152]	; (80165d8 <CS_subscribe_net_event+0x1b8>)
 801653e:	4d1a      	ldr	r5, [pc, #104]	; (80165a8 <CS_subscribe_net_event+0x188>)
 8016540:	f104 0c20 	add.w	ip, r4, #32
 8016544:	4626      	mov	r6, r4
 8016546:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8016548:	6028      	str	r0, [r5, #0]
 801654a:	6069      	str	r1, [r5, #4]
 801654c:	60aa      	str	r2, [r5, #8]
 801654e:	60eb      	str	r3, [r5, #12]
 8016550:	4634      	mov	r4, r6
 8016552:	3510      	adds	r5, #16
 8016554:	4566      	cmp	r6, ip
 8016556:	d1f5      	bne.n	8016544 <CS_subscribe_net_event+0x124>
 8016558:	cc07      	ldmia	r4!, {r0, r1, r2}
 801655a:	6028      	str	r0, [r5, #0]
 801655c:	6069      	str	r1, [r5, #4]
 801655e:	60aa      	str	r2, [r5, #8]
 8016560:	4c11      	ldr	r4, [pc, #68]	; (80165a8 <CS_subscribe_net_event+0x188>)
 8016562:	4620      	mov	r0, r4
 8016564:	f008 fee1 	bl	801f32a <crs_strlen>
 8016568:	b283      	uxth	r3, r0
 801656a:	4622      	mov	r2, r4
 801656c:	2110      	movs	r1, #16
 801656e:	2001      	movs	r0, #1
 8016570:	f008 ff1e 	bl	801f3b0 <traceIF_itmPrint>
 8016574:	4620      	mov	r0, r4
 8016576:	f008 fed8 	bl	801f32a <crs_strlen>
 801657a:	b283      	uxth	r3, r0
 801657c:	4622      	mov	r2, r4
 801657e:	2110      	movs	r1, #16
 8016580:	2001      	movs	r0, #1
 8016582:	f008 ff37 	bl	801f3f4 <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 8016586:	2601      	movs	r6, #1
 8016588:	e009      	b.n	801659e <CS_subscribe_net_event+0x17e>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SUSBCRIBE_NET_EVENT, &cmd_buf[0], &rsp_buf[0]);
 801658a:	4b14      	ldr	r3, [pc, #80]	; (80165dc <CS_subscribe_net_event+0x1bc>)
 801658c:	4a0a      	ldr	r2, [pc, #40]	; (80165b8 <CS_subscribe_net_event+0x198>)
 801658e:	216a      	movs	r1, #106	; 0x6a
 8016590:	4813      	ldr	r0, [pc, #76]	; (80165e0 <CS_subscribe_net_event+0x1c0>)
 8016592:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016596:	f7f5 fb25 	bl	800bbe4 <AT_sendcmd>
      if (err != ATSTATUS_OK)
 801659a:	4606      	mov	r6, r0
 801659c:	b910      	cbnz	r0, 80165a4 <CS_subscribe_net_event+0x184>
  if (retval == CELLULAR_ERROR)
 801659e:	2e01      	cmp	r6, #1
 80165a0:	d1a5      	bne.n	80164ee <CS_subscribe_net_event+0xce>
 80165a2:	e77b      	b.n	801649c <CS_subscribe_net_event+0x7c>
        retval = CELLULAR_ERROR;
 80165a4:	2601      	movs	r6, #1
 80165a6:	e779      	b.n	801649c <CS_subscribe_net_event+0x7c>
 80165a8:	200047dc 	.word	0x200047dc
 80165ac:	0803212c 	.word	0x0803212c
 80165b0:	200038a0 	.word	0x200038a0
 80165b4:	20003804 	.word	0x20003804
 80165b8:	20003620 	.word	0x20003620
 80165bc:	08032178 	.word	0x08032178
 80165c0:	200038a8 	.word	0x200038a8
 80165c4:	20003898 	.word	0x20003898
 80165c8:	2000389c 	.word	0x2000389c
 80165cc:	200038a4 	.word	0x200038a4
 80165d0:	20003894 	.word	0x20003894
 80165d4:	200038cc 	.word	0x200038cc
 80165d8:	0803214c 	.word	0x0803214c
 80165dc:	20003814 	.word	0x20003814
 80165e0:	2000361c 	.word	0x2000361c

080165e4 <CS_attach_PS_domain>:
{
 80165e4:	b570      	push	{r4, r5, r6, lr}
  PRINT_API("CS_attach_PS_domain")
 80165e6:	4c41      	ldr	r4, [pc, #260]	; (80166ec <CS_attach_PS_domain+0x108>)
 80165e8:	4d41      	ldr	r5, [pc, #260]	; (80166f0 <CS_attach_PS_domain+0x10c>)
 80165ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80165ec:	6020      	str	r0, [r4, #0]
 80165ee:	6061      	str	r1, [r4, #4]
 80165f0:	60a2      	str	r2, [r4, #8]
 80165f2:	60e3      	str	r3, [r4, #12]
 80165f4:	cd07      	ldmia	r5!, {r0, r1, r2}
 80165f6:	6120      	str	r0, [r4, #16]
 80165f8:	6161      	str	r1, [r4, #20]
 80165fa:	61a2      	str	r2, [r4, #24]
 80165fc:	782b      	ldrb	r3, [r5, #0]
 80165fe:	7723      	strb	r3, [r4, #28]
 8016600:	4620      	mov	r0, r4
 8016602:	f008 fe92 	bl	801f32a <crs_strlen>
 8016606:	b283      	uxth	r3, r0
 8016608:	4622      	mov	r2, r4
 801660a:	2104      	movs	r1, #4
 801660c:	2001      	movs	r0, #1
 801660e:	f008 fecf 	bl	801f3b0 <traceIF_itmPrint>
 8016612:	4620      	mov	r0, r4
 8016614:	f008 fe89 	bl	801f32a <crs_strlen>
 8016618:	b283      	uxth	r3, r0
 801661a:	4622      	mov	r2, r4
 801661c:	2104      	movs	r1, #4
 801661e:	2001      	movs	r0, #1
 8016620:	f008 fee8 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016624:	2300      	movs	r3, #0
 8016626:	461a      	mov	r2, r3
 8016628:	211e      	movs	r1, #30
 801662a:	4832      	ldr	r0, [pc, #200]	; (80166f4 <CS_attach_PS_domain+0x110>)
 801662c:	f7f5 fd42 	bl	800c0b4 <DATAPACK_writeStruct>
 8016630:	b948      	cbnz	r0, 8016646 <CS_attach_PS_domain+0x62>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_ATTACH_PS_DOMAIN, &cmd_buf[0], &rsp_buf[0]);
 8016632:	4b31      	ldr	r3, [pc, #196]	; (80166f8 <CS_attach_PS_domain+0x114>)
 8016634:	4a2f      	ldr	r2, [pc, #188]	; (80166f4 <CS_attach_PS_domain+0x110>)
 8016636:	2170      	movs	r1, #112	; 0x70
 8016638:	4830      	ldr	r0, [pc, #192]	; (80166fc <CS_attach_PS_domain+0x118>)
 801663a:	f9b0 0000 	ldrsh.w	r0, [r0]
 801663e:	f7f5 fad1 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016642:	4606      	mov	r6, r0
 8016644:	b350      	cbz	r0, 801669c <CS_attach_PS_domain+0xb8>
    PRINT_ERR("<Cellular_Service> error when attaching PS domain")
 8016646:	4c2e      	ldr	r4, [pc, #184]	; (8016700 <CS_attach_PS_domain+0x11c>)
 8016648:	4d28      	ldr	r5, [pc, #160]	; (80166ec <CS_attach_PS_domain+0x108>)
 801664a:	f104 0630 	add.w	r6, r4, #48	; 0x30
 801664e:	46a4      	mov	ip, r4
 8016650:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016654:	6028      	str	r0, [r5, #0]
 8016656:	6069      	str	r1, [r5, #4]
 8016658:	60aa      	str	r2, [r5, #8]
 801665a:	60eb      	str	r3, [r5, #12]
 801665c:	4664      	mov	r4, ip
 801665e:	3510      	adds	r5, #16
 8016660:	45b4      	cmp	ip, r6
 8016662:	d1f4      	bne.n	801664e <CS_attach_PS_domain+0x6a>
 8016664:	cc07      	ldmia	r4!, {r0, r1, r2}
 8016666:	6028      	str	r0, [r5, #0]
 8016668:	6069      	str	r1, [r5, #4]
 801666a:	60aa      	str	r2, [r5, #8]
 801666c:	7823      	ldrb	r3, [r4, #0]
 801666e:	732b      	strb	r3, [r5, #12]
 8016670:	4c1e      	ldr	r4, [pc, #120]	; (80166ec <CS_attach_PS_domain+0x108>)
 8016672:	4620      	mov	r0, r4
 8016674:	f008 fe59 	bl	801f32a <crs_strlen>
 8016678:	b283      	uxth	r3, r0
 801667a:	4622      	mov	r2, r4
 801667c:	2110      	movs	r1, #16
 801667e:	2001      	movs	r0, #1
 8016680:	f008 fe96 	bl	801f3b0 <traceIF_itmPrint>
 8016684:	4620      	mov	r0, r4
 8016686:	f008 fe50 	bl	801f32a <crs_strlen>
 801668a:	b283      	uxth	r3, r0
 801668c:	4622      	mov	r2, r4
 801668e:	2110      	movs	r1, #16
 8016690:	2001      	movs	r0, #1
 8016692:	f008 feaf 	bl	801f3f4 <traceIF_uartPrint>
 8016696:	2601      	movs	r6, #1
}
 8016698:	4630      	mov	r0, r6
 801669a:	bd70      	pop	{r4, r5, r6, pc}
      PRINT_DBG("<Cellular_Service> attach PS domain done")
 801669c:	4d19      	ldr	r5, [pc, #100]	; (8016704 <CS_attach_PS_domain+0x120>)
 801669e:	f105 0e20 	add.w	lr, r5, #32
 80166a2:	46ac      	mov	ip, r5
 80166a4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80166a8:	6020      	str	r0, [r4, #0]
 80166aa:	6061      	str	r1, [r4, #4]
 80166ac:	60a2      	str	r2, [r4, #8]
 80166ae:	60e3      	str	r3, [r4, #12]
 80166b0:	4665      	mov	r5, ip
 80166b2:	3410      	adds	r4, #16
 80166b4:	45f4      	cmp	ip, lr
 80166b6:	d1f4      	bne.n	80166a2 <CS_attach_PS_domain+0xbe>
 80166b8:	cd07      	ldmia	r5!, {r0, r1, r2}
 80166ba:	6020      	str	r0, [r4, #0]
 80166bc:	6061      	str	r1, [r4, #4]
 80166be:	60a2      	str	r2, [r4, #8]
 80166c0:	882b      	ldrh	r3, [r5, #0]
 80166c2:	81a3      	strh	r3, [r4, #12]
 80166c4:	4c09      	ldr	r4, [pc, #36]	; (80166ec <CS_attach_PS_domain+0x108>)
 80166c6:	4620      	mov	r0, r4
 80166c8:	f008 fe2f 	bl	801f32a <crs_strlen>
 80166cc:	b283      	uxth	r3, r0
 80166ce:	4622      	mov	r2, r4
 80166d0:	2102      	movs	r1, #2
 80166d2:	2001      	movs	r0, #1
 80166d4:	f008 fe6c 	bl	801f3b0 <traceIF_itmPrint>
 80166d8:	4620      	mov	r0, r4
 80166da:	f008 fe26 	bl	801f32a <crs_strlen>
 80166de:	b283      	uxth	r3, r0
 80166e0:	4622      	mov	r2, r4
 80166e2:	2102      	movs	r1, #2
 80166e4:	2001      	movs	r0, #1
 80166e6:	f008 fe85 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80166ea:	e7d5      	b.n	8016698 <CS_attach_PS_domain+0xb4>
 80166ec:	200047dc 	.word	0x200047dc
 80166f0:	080321b4 	.word	0x080321b4
 80166f4:	20003620 	.word	0x20003620
 80166f8:	20003814 	.word	0x20003814
 80166fc:	2000361c 	.word	0x2000361c
 8016700:	08032204 	.word	0x08032204
 8016704:	080321d4 	.word	0x080321d4

08016708 <CS_get_attach_status>:
{
 8016708:	b570      	push	{r4, r5, r6, lr}
 801670a:	4606      	mov	r6, r0
  PRINT_API("CS_get_attachstatus")
 801670c:	4c35      	ldr	r4, [pc, #212]	; (80167e4 <CS_get_attach_status+0xdc>)
 801670e:	4d36      	ldr	r5, [pc, #216]	; (80167e8 <CS_get_attach_status+0xe0>)
 8016710:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016712:	6020      	str	r0, [r4, #0]
 8016714:	6061      	str	r1, [r4, #4]
 8016716:	60a2      	str	r2, [r4, #8]
 8016718:	60e3      	str	r3, [r4, #12]
 801671a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801671c:	6120      	str	r0, [r4, #16]
 801671e:	6161      	str	r1, [r4, #20]
 8016720:	61a2      	str	r2, [r4, #24]
 8016722:	782a      	ldrb	r2, [r5, #0]
 8016724:	7722      	strb	r2, [r4, #28]
 8016726:	4620      	mov	r0, r4
 8016728:	f008 fdff 	bl	801f32a <crs_strlen>
 801672c:	b283      	uxth	r3, r0
 801672e:	4622      	mov	r2, r4
 8016730:	2104      	movs	r1, #4
 8016732:	2001      	movs	r0, #1
 8016734:	f008 fe3c 	bl	801f3b0 <traceIF_itmPrint>
 8016738:	4620      	mov	r0, r4
 801673a:	f008 fdf6 	bl	801f32a <crs_strlen>
 801673e:	b283      	uxth	r3, r0
 8016740:	4622      	mov	r2, r4
 8016742:	2104      	movs	r1, #4
 8016744:	2001      	movs	r0, #1
 8016746:	f008 fe55 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 801674a:	2300      	movs	r3, #0
 801674c:	461a      	mov	r2, r3
 801674e:	2104      	movs	r1, #4
 8016750:	4826      	ldr	r0, [pc, #152]	; (80167ec <CS_get_attach_status+0xe4>)
 8016752:	f7f5 fcaf 	bl	800c0b4 <DATAPACK_writeStruct>
 8016756:	b940      	cbnz	r0, 801676a <CS_get_attach_status+0x62>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_ATTACHSTATUS, &cmd_buf[0], &rsp_buf[0]);
 8016758:	4b25      	ldr	r3, [pc, #148]	; (80167f0 <CS_get_attach_status+0xe8>)
 801675a:	4a24      	ldr	r2, [pc, #144]	; (80167ec <CS_get_attach_status+0xe4>)
 801675c:	216d      	movs	r1, #109	; 0x6d
 801675e:	4825      	ldr	r0, [pc, #148]	; (80167f4 <CS_get_attach_status+0xec>)
 8016760:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016764:	f7f5 fa3e 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016768:	b1d0      	cbz	r0, 80167a0 <CS_get_attach_status+0x98>
    PRINT_ERR("<Cellular_Service> error when getting attachment status")
 801676a:	4c1e      	ldr	r4, [pc, #120]	; (80167e4 <CS_get_attach_status+0xdc>)
 801676c:	2243      	movs	r2, #67	; 0x43
 801676e:	4922      	ldr	r1, [pc, #136]	; (80167f8 <CS_get_attach_status+0xf0>)
 8016770:	4620      	mov	r0, r4
 8016772:	f010 f9b9 	bl	8026ae8 <memcpy>
 8016776:	4620      	mov	r0, r4
 8016778:	f008 fdd7 	bl	801f32a <crs_strlen>
 801677c:	b283      	uxth	r3, r0
 801677e:	4622      	mov	r2, r4
 8016780:	2110      	movs	r1, #16
 8016782:	2001      	movs	r0, #1
 8016784:	f008 fe14 	bl	801f3b0 <traceIF_itmPrint>
 8016788:	4620      	mov	r0, r4
 801678a:	f008 fdce 	bl	801f32a <crs_strlen>
 801678e:	b283      	uxth	r3, r0
 8016790:	4622      	mov	r2, r4
 8016792:	2110      	movs	r1, #16
 8016794:	2001      	movs	r0, #1
 8016796:	f008 fe2d 	bl	801f3f4 <traceIF_uartPrint>
 801679a:	2401      	movs	r4, #1
}
 801679c:	4620      	mov	r0, r4
 801679e:	bd70      	pop	{r4, r5, r6, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 80167a0:	4633      	mov	r3, r6
 80167a2:	2201      	movs	r2, #1
 80167a4:	2113      	movs	r1, #19
 80167a6:	4812      	ldr	r0, [pc, #72]	; (80167f0 <CS_get_attach_status+0xe8>)
 80167a8:	f7f5 fda4 	bl	800c2f4 <DATAPACK_readStruct>
 80167ac:	4604      	mov	r4, r0
 80167ae:	2800      	cmp	r0, #0
 80167b0:	d1db      	bne.n	801676a <CS_get_attach_status+0x62>
        PRINT_DBG("<Cellular_Service> Attachment status received = %d", *p_attach)
 80167b2:	4d0c      	ldr	r5, [pc, #48]	; (80167e4 <CS_get_attach_status+0xdc>)
 80167b4:	7832      	ldrb	r2, [r6, #0]
 80167b6:	4911      	ldr	r1, [pc, #68]	; (80167fc <CS_get_attach_status+0xf4>)
 80167b8:	4628      	mov	r0, r5
 80167ba:	f010 f845 	bl	8026848 <sprintf>
 80167be:	4628      	mov	r0, r5
 80167c0:	f008 fdb3 	bl	801f32a <crs_strlen>
 80167c4:	b283      	uxth	r3, r0
 80167c6:	462a      	mov	r2, r5
 80167c8:	2102      	movs	r1, #2
 80167ca:	2001      	movs	r0, #1
 80167cc:	f008 fdf0 	bl	801f3b0 <traceIF_itmPrint>
 80167d0:	4628      	mov	r0, r5
 80167d2:	f008 fdaa 	bl	801f32a <crs_strlen>
 80167d6:	b283      	uxth	r3, r0
 80167d8:	462a      	mov	r2, r5
 80167da:	2102      	movs	r1, #2
 80167dc:	2001      	movs	r0, #1
 80167de:	f008 fe09 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80167e2:	e7db      	b.n	801679c <CS_get_attach_status+0x94>
 80167e4:	200047dc 	.word	0x200047dc
 80167e8:	08032244 	.word	0x08032244
 80167ec:	20003620 	.word	0x20003620
 80167f0:	20003814 	.word	0x20003814
 80167f4:	2000361c 	.word	0x2000361c
 80167f8:	0803229c 	.word	0x0803229c
 80167fc:	08032264 	.word	0x08032264

08016800 <CS_get_net_status>:
{
 8016800:	b570      	push	{r4, r5, r6, lr}
 8016802:	4606      	mov	r6, r0
  PRINT_API("CS_get_netstatus")
 8016804:	4c44      	ldr	r4, [pc, #272]	; (8016918 <CS_get_net_status+0x118>)
 8016806:	4d45      	ldr	r5, [pc, #276]	; (801691c <CS_get_net_status+0x11c>)
 8016808:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801680a:	6020      	str	r0, [r4, #0]
 801680c:	6061      	str	r1, [r4, #4]
 801680e:	60a2      	str	r2, [r4, #8]
 8016810:	60e3      	str	r3, [r4, #12]
 8016812:	cd03      	ldmia	r5!, {r0, r1}
 8016814:	6120      	str	r0, [r4, #16]
 8016816:	6161      	str	r1, [r4, #20]
 8016818:	882b      	ldrh	r3, [r5, #0]
 801681a:	8323      	strh	r3, [r4, #24]
 801681c:	4620      	mov	r0, r4
 801681e:	f008 fd84 	bl	801f32a <crs_strlen>
 8016822:	b283      	uxth	r3, r0
 8016824:	4622      	mov	r2, r4
 8016826:	2104      	movs	r1, #4
 8016828:	2001      	movs	r0, #1
 801682a:	f008 fdc1 	bl	801f3b0 <traceIF_itmPrint>
 801682e:	4620      	mov	r0, r4
 8016830:	f008 fd7b 	bl	801f32a <crs_strlen>
 8016834:	b283      	uxth	r3, r0
 8016836:	4622      	mov	r2, r4
 8016838:	2104      	movs	r1, #4
 801683a:	2001      	movs	r0, #1
 801683c:	f008 fdda 	bl	801f3f4 <traceIF_uartPrint>
  p_reg_status->optional_fields_presence = CS_RSF_NONE;
 8016840:	2200      	movs	r2, #0
 8016842:	8132      	strh	r2, [r6, #8]
  p_reg_status->CS_NetworkRegState = CS_NRS_UNKNOWN;
 8016844:	2104      	movs	r1, #4
 8016846:	80f1      	strh	r1, [r6, #6]
  p_reg_status->GPRS_NetworkRegState = CS_NRS_UNKNOWN;
 8016848:	80b1      	strh	r1, [r6, #4]
  p_reg_status->EPS_NetworkRegState = CS_NRS_UNKNOWN;
 801684a:	8071      	strh	r1, [r6, #2]
  if (DATAPACK_writeStruct(&cmd_buf[0],
 801684c:	4613      	mov	r3, r2
 801684e:	4834      	ldr	r0, [pc, #208]	; (8016920 <CS_get_net_status+0x120>)
 8016850:	f7f5 fc30 	bl	800c0b4 <DATAPACK_writeStruct>
 8016854:	b940      	cbnz	r0, 8016868 <CS_get_net_status+0x68>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_NETSTATUS, &cmd_buf[0], &rsp_buf[0]);
 8016856:	4b33      	ldr	r3, [pc, #204]	; (8016924 <CS_get_net_status+0x124>)
 8016858:	4a31      	ldr	r2, [pc, #196]	; (8016920 <CS_get_net_status+0x120>)
 801685a:	216c      	movs	r1, #108	; 0x6c
 801685c:	4832      	ldr	r0, [pc, #200]	; (8016928 <CS_get_net_status+0x128>)
 801685e:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016862:	f7f5 f9bf 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016866:	b338      	cbz	r0, 80168b8 <CS_get_net_status+0xb8>
    PRINT_ERR("<Cellular_Service> error when getting net status")
 8016868:	4c30      	ldr	r4, [pc, #192]	; (801692c <CS_get_net_status+0x12c>)
 801686a:	4d2b      	ldr	r5, [pc, #172]	; (8016918 <CS_get_net_status+0x118>)
 801686c:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 8016870:	4626      	mov	r6, r4
 8016872:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8016874:	6028      	str	r0, [r5, #0]
 8016876:	6069      	str	r1, [r5, #4]
 8016878:	60aa      	str	r2, [r5, #8]
 801687a:	60eb      	str	r3, [r5, #12]
 801687c:	4634      	mov	r4, r6
 801687e:	3510      	adds	r5, #16
 8016880:	4566      	cmp	r6, ip
 8016882:	d1f5      	bne.n	8016870 <CS_get_net_status+0x70>
 8016884:	cc07      	ldmia	r4!, {r0, r1, r2}
 8016886:	6028      	str	r0, [r5, #0]
 8016888:	6069      	str	r1, [r5, #4]
 801688a:	60aa      	str	r2, [r5, #8]
 801688c:	4c22      	ldr	r4, [pc, #136]	; (8016918 <CS_get_net_status+0x118>)
 801688e:	4620      	mov	r0, r4
 8016890:	f008 fd4b 	bl	801f32a <crs_strlen>
 8016894:	b283      	uxth	r3, r0
 8016896:	4622      	mov	r2, r4
 8016898:	2110      	movs	r1, #16
 801689a:	2001      	movs	r0, #1
 801689c:	f008 fd88 	bl	801f3b0 <traceIF_itmPrint>
 80168a0:	4620      	mov	r0, r4
 80168a2:	f008 fd42 	bl	801f32a <crs_strlen>
 80168a6:	b283      	uxth	r3, r0
 80168a8:	4622      	mov	r2, r4
 80168aa:	2110      	movs	r1, #16
 80168ac:	2001      	movs	r0, #1
 80168ae:	f008 fda1 	bl	801f3f4 <traceIF_uartPrint>
 80168b2:	2401      	movs	r4, #1
}
 80168b4:	4620      	mov	r0, r4
 80168b6:	bd70      	pop	{r4, r5, r6, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 80168b8:	4633      	mov	r3, r6
 80168ba:	224e      	movs	r2, #78	; 0x4e
 80168bc:	2115      	movs	r1, #21
 80168be:	4819      	ldr	r0, [pc, #100]	; (8016924 <CS_get_net_status+0x124>)
 80168c0:	f7f5 fd18 	bl	800c2f4 <DATAPACK_readStruct>
 80168c4:	4604      	mov	r4, r0
 80168c6:	2800      	cmp	r0, #0
 80168c8:	d1ce      	bne.n	8016868 <CS_get_net_status+0x68>
        PRINT_DBG("<Cellular_Service> Net status received")
 80168ca:	4e19      	ldr	r6, [pc, #100]	; (8016930 <CS_get_net_status+0x130>)
 80168cc:	4d12      	ldr	r5, [pc, #72]	; (8016918 <CS_get_net_status+0x118>)
 80168ce:	f106 0e20 	add.w	lr, r6, #32
 80168d2:	46b4      	mov	ip, r6
 80168d4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80168d8:	6028      	str	r0, [r5, #0]
 80168da:	6069      	str	r1, [r5, #4]
 80168dc:	60aa      	str	r2, [r5, #8]
 80168de:	60eb      	str	r3, [r5, #12]
 80168e0:	4666      	mov	r6, ip
 80168e2:	3510      	adds	r5, #16
 80168e4:	45f4      	cmp	ip, lr
 80168e6:	d1f4      	bne.n	80168d2 <CS_get_net_status+0xd2>
 80168e8:	ce07      	ldmia	r6!, {r0, r1, r2}
 80168ea:	6028      	str	r0, [r5, #0]
 80168ec:	6069      	str	r1, [r5, #4]
 80168ee:	60aa      	str	r2, [r5, #8]
 80168f0:	4d09      	ldr	r5, [pc, #36]	; (8016918 <CS_get_net_status+0x118>)
 80168f2:	4628      	mov	r0, r5
 80168f4:	f008 fd19 	bl	801f32a <crs_strlen>
 80168f8:	b283      	uxth	r3, r0
 80168fa:	462a      	mov	r2, r5
 80168fc:	2102      	movs	r1, #2
 80168fe:	2001      	movs	r0, #1
 8016900:	f008 fd56 	bl	801f3b0 <traceIF_itmPrint>
 8016904:	4628      	mov	r0, r5
 8016906:	f008 fd10 	bl	801f32a <crs_strlen>
 801690a:	b283      	uxth	r3, r0
 801690c:	462a      	mov	r2, r5
 801690e:	2102      	movs	r1, #2
 8016910:	2001      	movs	r0, #1
 8016912:	f008 fd6f 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016916:	e7cd      	b.n	80168b4 <CS_get_net_status+0xb4>
 8016918:	200047dc 	.word	0x200047dc
 801691c:	080322e0 	.word	0x080322e0
 8016920:	20003620 	.word	0x20003620
 8016924:	20003814 	.word	0x20003814
 8016928:	2000361c 	.word	0x2000361c
 801692c:	08032328 	.word	0x08032328
 8016930:	080322fc 	.word	0x080322fc

08016934 <CS_get_signal_quality>:
{
 8016934:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016938:	b082      	sub	sp, #8
 801693a:	4607      	mov	r7, r0
  PRINT_API("CS_get_signal_quality")
 801693c:	4c41      	ldr	r4, [pc, #260]	; (8016a44 <CS_get_signal_quality+0x110>)
 801693e:	4d42      	ldr	r5, [pc, #264]	; (8016a48 <CS_get_signal_quality+0x114>)
 8016940:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8016942:	6020      	str	r0, [r4, #0]
 8016944:	6061      	str	r1, [r4, #4]
 8016946:	60a2      	str	r2, [r4, #8]
 8016948:	60e3      	str	r3, [r4, #12]
 801694a:	cd07      	ldmia	r5!, {r0, r1, r2}
 801694c:	6120      	str	r0, [r4, #16]
 801694e:	6161      	str	r1, [r4, #20]
 8016950:	61a2      	str	r2, [r4, #24]
 8016952:	882a      	ldrh	r2, [r5, #0]
 8016954:	78ab      	ldrb	r3, [r5, #2]
 8016956:	83a2      	strh	r2, [r4, #28]
 8016958:	77a3      	strb	r3, [r4, #30]
 801695a:	4620      	mov	r0, r4
 801695c:	f008 fce5 	bl	801f32a <crs_strlen>
 8016960:	b283      	uxth	r3, r0
 8016962:	4622      	mov	r2, r4
 8016964:	2104      	movs	r1, #4
 8016966:	2001      	movs	r0, #1
 8016968:	f008 fd22 	bl	801f3b0 <traceIF_itmPrint>
 801696c:	4620      	mov	r0, r4
 801696e:	f008 fcdc 	bl	801f32a <crs_strlen>
 8016972:	b283      	uxth	r3, r0
 8016974:	4622      	mov	r2, r4
 8016976:	2104      	movs	r1, #4
 8016978:	2001      	movs	r0, #1
 801697a:	f008 fd3b 	bl	801f3f4 <traceIF_uartPrint>
  CS_SignalQuality_t local_sig_qual = {0};
 801697e:	2300      	movs	r3, #0
 8016980:	f8ad 3004 	strh.w	r3, [sp, #4]
  if (DATAPACK_writePtr(&cmd_buf[0],
 8016984:	aa01      	add	r2, sp, #4
 8016986:	211d      	movs	r1, #29
 8016988:	4830      	ldr	r0, [pc, #192]	; (8016a4c <CS_get_signal_quality+0x118>)
 801698a:	f7f5 fb63 	bl	800c054 <DATAPACK_writePtr>
 801698e:	b948      	cbnz	r0, 80169a4 <CS_get_signal_quality+0x70>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_SIGNAL_QUALITY, &cmd_buf[0], &rsp_buf[0]);
 8016990:	4b2f      	ldr	r3, [pc, #188]	; (8016a50 <CS_get_signal_quality+0x11c>)
 8016992:	4a2e      	ldr	r2, [pc, #184]	; (8016a4c <CS_get_signal_quality+0x118>)
 8016994:	216e      	movs	r1, #110	; 0x6e
 8016996:	482f      	ldr	r0, [pc, #188]	; (8016a54 <CS_get_signal_quality+0x120>)
 8016998:	f9b0 0000 	ldrsh.w	r0, [r0]
 801699c:	f7f5 f922 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 80169a0:	4680      	mov	r8, r0
 80169a2:	b330      	cbz	r0, 80169f2 <CS_get_signal_quality+0xbe>
    PRINT_ERR("<Cellular_Service> error when getting signal quality")
 80169a4:	4e2c      	ldr	r6, [pc, #176]	; (8016a58 <CS_get_signal_quality+0x124>)
 80169a6:	4d27      	ldr	r5, [pc, #156]	; (8016a44 <CS_get_signal_quality+0x110>)
 80169a8:	f106 0740 	add.w	r7, r6, #64	; 0x40
 80169ac:	4634      	mov	r4, r6
 80169ae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80169b0:	6028      	str	r0, [r5, #0]
 80169b2:	6069      	str	r1, [r5, #4]
 80169b4:	60aa      	str	r2, [r5, #8]
 80169b6:	60eb      	str	r3, [r5, #12]
 80169b8:	4626      	mov	r6, r4
 80169ba:	3510      	adds	r5, #16
 80169bc:	42bc      	cmp	r4, r7
 80169be:	d1f5      	bne.n	80169ac <CS_get_signal_quality+0x78>
 80169c0:	4c20      	ldr	r4, [pc, #128]	; (8016a44 <CS_get_signal_quality+0x110>)
 80169c2:	4620      	mov	r0, r4
 80169c4:	f008 fcb1 	bl	801f32a <crs_strlen>
 80169c8:	b283      	uxth	r3, r0
 80169ca:	4622      	mov	r2, r4
 80169cc:	2110      	movs	r1, #16
 80169ce:	2001      	movs	r0, #1
 80169d0:	f008 fcee 	bl	801f3b0 <traceIF_itmPrint>
 80169d4:	4620      	mov	r0, r4
 80169d6:	f008 fca8 	bl	801f32a <crs_strlen>
 80169da:	b283      	uxth	r3, r0
 80169dc:	4622      	mov	r2, r4
 80169de:	2110      	movs	r1, #16
 80169e0:	2001      	movs	r0, #1
 80169e2:	f008 fd07 	bl	801f3f4 <traceIF_uartPrint>
 80169e6:	f04f 0801 	mov.w	r8, #1
}
 80169ea:	4640      	mov	r0, r8
 80169ec:	b002      	add	sp, #8
 80169ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      PRINT_DBG("<Cellular_Service> Signal quality information received")
 80169f2:	4d1a      	ldr	r5, [pc, #104]	; (8016a5c <CS_get_signal_quality+0x128>)
 80169f4:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 80169f8:	462e      	mov	r6, r5
 80169fa:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80169fc:	6020      	str	r0, [r4, #0]
 80169fe:	6061      	str	r1, [r4, #4]
 8016a00:	60a2      	str	r2, [r4, #8]
 8016a02:	60e3      	str	r3, [r4, #12]
 8016a04:	4635      	mov	r5, r6
 8016a06:	3410      	adds	r4, #16
 8016a08:	4566      	cmp	r6, ip
 8016a0a:	d1f5      	bne.n	80169f8 <CS_get_signal_quality+0xc4>
 8016a0c:	cd07      	ldmia	r5!, {r0, r1, r2}
 8016a0e:	6020      	str	r0, [r4, #0]
 8016a10:	6061      	str	r1, [r4, #4]
 8016a12:	60a2      	str	r2, [r4, #8]
 8016a14:	4c0b      	ldr	r4, [pc, #44]	; (8016a44 <CS_get_signal_quality+0x110>)
 8016a16:	4620      	mov	r0, r4
 8016a18:	f008 fc87 	bl	801f32a <crs_strlen>
 8016a1c:	b283      	uxth	r3, r0
 8016a1e:	4622      	mov	r2, r4
 8016a20:	2102      	movs	r1, #2
 8016a22:	2001      	movs	r0, #1
 8016a24:	f008 fcc4 	bl	801f3b0 <traceIF_itmPrint>
 8016a28:	4620      	mov	r0, r4
 8016a2a:	f008 fc7e 	bl	801f32a <crs_strlen>
 8016a2e:	b283      	uxth	r3, r0
 8016a30:	4622      	mov	r2, r4
 8016a32:	2102      	movs	r1, #2
 8016a34:	2001      	movs	r0, #1
 8016a36:	f008 fcdd 	bl	801f3f4 <traceIF_uartPrint>
      (void) memcpy((void *)p_sig_qual, (void *)&local_sig_qual, sizeof(CS_SignalQuality_t));
 8016a3a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8016a3e:	803b      	strh	r3, [r7, #0]
  if (retval == CELLULAR_ERROR)
 8016a40:	e7d3      	b.n	80169ea <CS_get_signal_quality+0xb6>
 8016a42:	bf00      	nop
 8016a44:	200047dc 	.word	0x200047dc
 8016a48:	08032364 	.word	0x08032364
 8016a4c:	20003620 	.word	0x20003620
 8016a50:	20003814 	.word	0x20003814
 8016a54:	2000361c 	.word	0x2000361c
 8016a58:	080323c0 	.word	0x080323c0
 8016a5c:	08032384 	.word	0x08032384

08016a60 <CS_activate_pdn>:
{
 8016a60:	b530      	push	{r4, r5, lr}
 8016a62:	b083      	sub	sp, #12
 8016a64:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_activate_pdn for cid=%d", cid)
 8016a68:	4c30      	ldr	r4, [pc, #192]	; (8016b2c <CS_activate_pdn+0xcc>)
 8016a6a:	b2c2      	uxtb	r2, r0
 8016a6c:	4930      	ldr	r1, [pc, #192]	; (8016b30 <CS_activate_pdn+0xd0>)
 8016a6e:	4620      	mov	r0, r4
 8016a70:	f00f feea 	bl	8026848 <sprintf>
 8016a74:	4620      	mov	r0, r4
 8016a76:	f008 fc58 	bl	801f32a <crs_strlen>
 8016a7a:	b283      	uxth	r3, r0
 8016a7c:	4622      	mov	r2, r4
 8016a7e:	2104      	movs	r1, #4
 8016a80:	2001      	movs	r0, #1
 8016a82:	f008 fc95 	bl	801f3b0 <traceIF_itmPrint>
 8016a86:	4620      	mov	r0, r4
 8016a88:	f008 fc4f 	bl	801f32a <crs_strlen>
 8016a8c:	b283      	uxth	r3, r0
 8016a8e:	4622      	mov	r2, r4
 8016a90:	2104      	movs	r1, #4
 8016a92:	2001      	movs	r0, #1
 8016a94:	f008 fcae 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016a98:	f10d 0307 	add.w	r3, sp, #7
 8016a9c:	2201      	movs	r2, #1
 8016a9e:	2121      	movs	r1, #33	; 0x21
 8016aa0:	4824      	ldr	r0, [pc, #144]	; (8016b34 <CS_activate_pdn+0xd4>)
 8016aa2:	f7f5 fb07 	bl	800c0b4 <DATAPACK_writeStruct>
 8016aa6:	b948      	cbnz	r0, 8016abc <CS_activate_pdn+0x5c>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_ACTIVATE_PDN, &cmd_buf[0], &rsp_buf[0]);
 8016aa8:	4b23      	ldr	r3, [pc, #140]	; (8016b38 <CS_activate_pdn+0xd8>)
 8016aaa:	4a22      	ldr	r2, [pc, #136]	; (8016b34 <CS_activate_pdn+0xd4>)
 8016aac:	216f      	movs	r1, #111	; 0x6f
 8016aae:	4823      	ldr	r0, [pc, #140]	; (8016b3c <CS_activate_pdn+0xdc>)
 8016ab0:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016ab4:	f7f5 f896 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016ab8:	4604      	mov	r4, r0
 8016aba:	b1e0      	cbz	r0, 8016af6 <CS_activate_pdn+0x96>
    PRINT_ERR("<Cellular_Service> error when PDN %cid activation", cid)
 8016abc:	4c1b      	ldr	r4, [pc, #108]	; (8016b2c <CS_activate_pdn+0xcc>)
 8016abe:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016ac2:	491f      	ldr	r1, [pc, #124]	; (8016b40 <CS_activate_pdn+0xe0>)
 8016ac4:	4620      	mov	r0, r4
 8016ac6:	f00f febf 	bl	8026848 <sprintf>
 8016aca:	4620      	mov	r0, r4
 8016acc:	f008 fc2d 	bl	801f32a <crs_strlen>
 8016ad0:	b283      	uxth	r3, r0
 8016ad2:	4622      	mov	r2, r4
 8016ad4:	2110      	movs	r1, #16
 8016ad6:	2001      	movs	r0, #1
 8016ad8:	f008 fc6a 	bl	801f3b0 <traceIF_itmPrint>
 8016adc:	4620      	mov	r0, r4
 8016ade:	f008 fc24 	bl	801f32a <crs_strlen>
 8016ae2:	b283      	uxth	r3, r0
 8016ae4:	4622      	mov	r2, r4
 8016ae6:	2110      	movs	r1, #16
 8016ae8:	2001      	movs	r0, #1
 8016aea:	f008 fc83 	bl	801f3f4 <traceIF_uartPrint>
 8016aee:	2401      	movs	r4, #1
}
 8016af0:	4620      	mov	r0, r4
 8016af2:	b003      	add	sp, #12
 8016af4:	bd30      	pop	{r4, r5, pc}
      PRINT_DBG("<Cellular_Service> PDN %d connected", cid)
 8016af6:	4d0d      	ldr	r5, [pc, #52]	; (8016b2c <CS_activate_pdn+0xcc>)
 8016af8:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016afc:	4911      	ldr	r1, [pc, #68]	; (8016b44 <CS_activate_pdn+0xe4>)
 8016afe:	4628      	mov	r0, r5
 8016b00:	f00f fea2 	bl	8026848 <sprintf>
 8016b04:	4628      	mov	r0, r5
 8016b06:	f008 fc10 	bl	801f32a <crs_strlen>
 8016b0a:	b283      	uxth	r3, r0
 8016b0c:	462a      	mov	r2, r5
 8016b0e:	2102      	movs	r1, #2
 8016b10:	2001      	movs	r0, #1
 8016b12:	f008 fc4d 	bl	801f3b0 <traceIF_itmPrint>
 8016b16:	4628      	mov	r0, r5
 8016b18:	f008 fc07 	bl	801f32a <crs_strlen>
 8016b1c:	b283      	uxth	r3, r0
 8016b1e:	462a      	mov	r2, r5
 8016b20:	2102      	movs	r1, #2
 8016b22:	2001      	movs	r0, #1
 8016b24:	f008 fc66 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016b28:	e7e2      	b.n	8016af0 <CS_activate_pdn+0x90>
 8016b2a:	bf00      	nop
 8016b2c:	200047dc 	.word	0x200047dc
 8016b30:	08032400 	.word	0x08032400
 8016b34:	20003620 	.word	0x20003620
 8016b38:	20003814 	.word	0x20003814
 8016b3c:	2000361c 	.word	0x2000361c
 8016b40:	08032450 	.word	0x08032450
 8016b44:	08032424 	.word	0x08032424

08016b48 <CS_define_pdn>:
{
 8016b48:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016b4a:	b0a3      	sub	sp, #140	; 0x8c
 8016b4c:	4604      	mov	r4, r0
 8016b4e:	460e      	mov	r6, r1
 8016b50:	4617      	mov	r7, r2
  PRINT_API("CS_define_pdn for cid=%d", cid)
 8016b52:	4d4e      	ldr	r5, [pc, #312]	; (8016c8c <CS_define_pdn+0x144>)
 8016b54:	4602      	mov	r2, r0
 8016b56:	494e      	ldr	r1, [pc, #312]	; (8016c90 <CS_define_pdn+0x148>)
 8016b58:	4628      	mov	r0, r5
 8016b5a:	f00f fe75 	bl	8026848 <sprintf>
 8016b5e:	4628      	mov	r0, r5
 8016b60:	f008 fbe3 	bl	801f32a <crs_strlen>
 8016b64:	b283      	uxth	r3, r0
 8016b66:	462a      	mov	r2, r5
 8016b68:	2104      	movs	r1, #4
 8016b6a:	2001      	movs	r0, #1
 8016b6c:	f008 fc20 	bl	801f3b0 <traceIF_itmPrint>
 8016b70:	4628      	mov	r0, r5
 8016b72:	f008 fbda 	bl	801f32a <crs_strlen>
 8016b76:	b283      	uxth	r3, r0
 8016b78:	462a      	mov	r2, r5
 8016b7a:	2104      	movs	r1, #4
 8016b7c:	2001      	movs	r0, #1
 8016b7e:	f008 fc39 	bl	801f3f4 <traceIF_uartPrint>
  if ((cid < CS_PDN_USER_CONFIG_1) || (cid > CS_PDN_USER_CONFIG_5))
 8016b82:	1e63      	subs	r3, r4, #1
 8016b84:	b2db      	uxtb	r3, r3
 8016b86:	2b04      	cmp	r3, #4
 8016b88:	d827      	bhi.n	8016bda <CS_define_pdn+0x92>
  else if (apn == NULL)
 8016b8a:	2e00      	cmp	r6, #0
 8016b8c:	d057      	beq.n	8016c3e <CS_define_pdn+0xf6>
    (void) memset((void *)&pdn_infos, 0, sizeof(csint_pdn_infos_t));
 8016b8e:	2282      	movs	r2, #130	; 0x82
 8016b90:	2100      	movs	r1, #0
 8016b92:	a801      	add	r0, sp, #4
 8016b94:	f00f fecb 	bl	802692e <memset>
    pdn_infos.conf_id = cid;
 8016b98:	f88d 4004 	strb.w	r4, [sp, #4]
    (void) memcpy((void *)&pdn_infos.apn[0],
 8016b9c:	4630      	mov	r0, r6
 8016b9e:	f7e9 fb29 	bl	80001f4 <strlen>
 8016ba2:	4602      	mov	r2, r0
 8016ba4:	4631      	mov	r1, r6
 8016ba6:	f10d 0005 	add.w	r0, sp, #5
 8016baa:	f00f ff9d 	bl	8026ae8 <memcpy>
    (void) memcpy((void *)&pdn_infos.pdn_conf, (void *)pdn_conf, sizeof(CS_PDN_configuration_t));
 8016bae:	2241      	movs	r2, #65	; 0x41
 8016bb0:	4639      	mov	r1, r7
 8016bb2:	f10d 0045 	add.w	r0, sp, #69	; 0x45
 8016bb6:	f00f ff97 	bl	8026ae8 <memcpy>
    if (DATAPACK_writePtr(&cmd_buf[0],
 8016bba:	aa01      	add	r2, sp, #4
 8016bbc:	2123      	movs	r1, #35	; 0x23
 8016bbe:	4835      	ldr	r0, [pc, #212]	; (8016c94 <CS_define_pdn+0x14c>)
 8016bc0:	f7f5 fa48 	bl	800c054 <DATAPACK_writePtr>
 8016bc4:	bb00      	cbnz	r0, 8016c08 <CS_define_pdn+0xc0>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_DEFINE_PDN, &cmd_buf[0], &rsp_buf[0]);
 8016bc6:	4b34      	ldr	r3, [pc, #208]	; (8016c98 <CS_define_pdn+0x150>)
 8016bc8:	4a32      	ldr	r2, [pc, #200]	; (8016c94 <CS_define_pdn+0x14c>)
 8016bca:	2176      	movs	r1, #118	; 0x76
 8016bcc:	4833      	ldr	r0, [pc, #204]	; (8016c9c <CS_define_pdn+0x154>)
 8016bce:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016bd2:	f7f5 f807 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8016bd6:	b380      	cbz	r0, 8016c3a <CS_define_pdn+0xf2>
 8016bd8:	e016      	b.n	8016c08 <CS_define_pdn+0xc0>
    PRINT_ERR("<Cellular_Service> selected configuration id %d can not be set by user", cid)
 8016bda:	4622      	mov	r2, r4
 8016bdc:	4930      	ldr	r1, [pc, #192]	; (8016ca0 <CS_define_pdn+0x158>)
 8016bde:	4628      	mov	r0, r5
 8016be0:	f00f fe32 	bl	8026848 <sprintf>
 8016be4:	4628      	mov	r0, r5
 8016be6:	f008 fba0 	bl	801f32a <crs_strlen>
 8016bea:	b283      	uxth	r3, r0
 8016bec:	462a      	mov	r2, r5
 8016bee:	2110      	movs	r1, #16
 8016bf0:	2001      	movs	r0, #1
 8016bf2:	f008 fbdd 	bl	801f3b0 <traceIF_itmPrint>
 8016bf6:	4628      	mov	r0, r5
 8016bf8:	f008 fb97 	bl	801f32a <crs_strlen>
 8016bfc:	b283      	uxth	r3, r0
 8016bfe:	462a      	mov	r2, r5
 8016c00:	2110      	movs	r1, #16
 8016c02:	2001      	movs	r0, #1
 8016c04:	f008 fbf6 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when defining PDN %d", cid)
 8016c08:	4d20      	ldr	r5, [pc, #128]	; (8016c8c <CS_define_pdn+0x144>)
 8016c0a:	4622      	mov	r2, r4
 8016c0c:	4925      	ldr	r1, [pc, #148]	; (8016ca4 <CS_define_pdn+0x15c>)
 8016c0e:	4628      	mov	r0, r5
 8016c10:	f00f fe1a 	bl	8026848 <sprintf>
 8016c14:	4628      	mov	r0, r5
 8016c16:	f008 fb88 	bl	801f32a <crs_strlen>
 8016c1a:	b283      	uxth	r3, r0
 8016c1c:	462a      	mov	r2, r5
 8016c1e:	2110      	movs	r1, #16
 8016c20:	2001      	movs	r0, #1
 8016c22:	f008 fbc5 	bl	801f3b0 <traceIF_itmPrint>
 8016c26:	4628      	mov	r0, r5
 8016c28:	f008 fb7f 	bl	801f32a <crs_strlen>
 8016c2c:	b283      	uxth	r3, r0
 8016c2e:	462a      	mov	r2, r5
 8016c30:	2110      	movs	r1, #16
 8016c32:	2001      	movs	r0, #1
 8016c34:	f008 fbde 	bl	801f3f4 <traceIF_uartPrint>
 8016c38:	2001      	movs	r0, #1
}
 8016c3a:	b023      	add	sp, #140	; 0x8c
 8016c3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINT_ERR("<Cellular_Service> apn must be non NULL")
 8016c3e:	4f1a      	ldr	r7, [pc, #104]	; (8016ca8 <CS_define_pdn+0x160>)
 8016c40:	4d12      	ldr	r5, [pc, #72]	; (8016c8c <CS_define_pdn+0x144>)
 8016c42:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8016c46:	463e      	mov	r6, r7
 8016c48:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8016c4a:	6028      	str	r0, [r5, #0]
 8016c4c:	6069      	str	r1, [r5, #4]
 8016c4e:	60aa      	str	r2, [r5, #8]
 8016c50:	60eb      	str	r3, [r5, #12]
 8016c52:	4637      	mov	r7, r6
 8016c54:	3510      	adds	r5, #16
 8016c56:	4566      	cmp	r6, ip
 8016c58:	d1f5      	bne.n	8016c46 <CS_define_pdn+0xfe>
 8016c5a:	8832      	ldrh	r2, [r6, #0]
 8016c5c:	78b3      	ldrb	r3, [r6, #2]
 8016c5e:	802a      	strh	r2, [r5, #0]
 8016c60:	70ab      	strb	r3, [r5, #2]
 8016c62:	4d0a      	ldr	r5, [pc, #40]	; (8016c8c <CS_define_pdn+0x144>)
 8016c64:	4628      	mov	r0, r5
 8016c66:	f008 fb60 	bl	801f32a <crs_strlen>
 8016c6a:	b283      	uxth	r3, r0
 8016c6c:	462a      	mov	r2, r5
 8016c6e:	2110      	movs	r1, #16
 8016c70:	2001      	movs	r0, #1
 8016c72:	f008 fb9d 	bl	801f3b0 <traceIF_itmPrint>
 8016c76:	4628      	mov	r0, r5
 8016c78:	f008 fb57 	bl	801f32a <crs_strlen>
 8016c7c:	b283      	uxth	r3, r0
 8016c7e:	462a      	mov	r2, r5
 8016c80:	2110      	movs	r1, #16
 8016c82:	2001      	movs	r0, #1
 8016c84:	f008 fbb6 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016c88:	e7be      	b.n	8016c08 <CS_define_pdn+0xc0>
 8016c8a:	bf00      	nop
 8016c8c:	200047dc 	.word	0x200047dc
 8016c90:	08032490 	.word	0x08032490
 8016c94:	20003620 	.word	0x20003620
 8016c98:	20003814 	.word	0x20003814
 8016c9c:	2000361c 	.word	0x2000361c
 8016ca0:	080324b4 	.word	0x080324b4
 8016ca4:	0803253c 	.word	0x0803253c
 8016ca8:	08032508 	.word	0x08032508

08016cac <CS_set_default_pdn>:
{
 8016cac:	b530      	push	{r4, r5, lr}
 8016cae:	b083      	sub	sp, #12
 8016cb0:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_set_default_pdn (conf_id=%d)", cid)
 8016cb4:	4c30      	ldr	r4, [pc, #192]	; (8016d78 <CS_set_default_pdn+0xcc>)
 8016cb6:	b2c2      	uxtb	r2, r0
 8016cb8:	4930      	ldr	r1, [pc, #192]	; (8016d7c <CS_set_default_pdn+0xd0>)
 8016cba:	4620      	mov	r0, r4
 8016cbc:	f00f fdc4 	bl	8026848 <sprintf>
 8016cc0:	4620      	mov	r0, r4
 8016cc2:	f008 fb32 	bl	801f32a <crs_strlen>
 8016cc6:	b283      	uxth	r3, r0
 8016cc8:	4622      	mov	r2, r4
 8016cca:	2104      	movs	r1, #4
 8016ccc:	2001      	movs	r0, #1
 8016cce:	f008 fb6f 	bl	801f3b0 <traceIF_itmPrint>
 8016cd2:	4620      	mov	r0, r4
 8016cd4:	f008 fb29 	bl	801f32a <crs_strlen>
 8016cd8:	b283      	uxth	r3, r0
 8016cda:	4622      	mov	r2, r4
 8016cdc:	2104      	movs	r1, #4
 8016cde:	2001      	movs	r0, #1
 8016ce0:	f008 fb88 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016ce4:	f10d 0307 	add.w	r3, sp, #7
 8016ce8:	2201      	movs	r2, #1
 8016cea:	2124      	movs	r1, #36	; 0x24
 8016cec:	4824      	ldr	r0, [pc, #144]	; (8016d80 <CS_set_default_pdn+0xd4>)
 8016cee:	f7f5 f9e1 	bl	800c0b4 <DATAPACK_writeStruct>
 8016cf2:	b948      	cbnz	r0, 8016d08 <CS_set_default_pdn+0x5c>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SET_DEFAULT_PDN, &cmd_buf[0], &rsp_buf[0]);
 8016cf4:	4b23      	ldr	r3, [pc, #140]	; (8016d84 <CS_set_default_pdn+0xd8>)
 8016cf6:	4a22      	ldr	r2, [pc, #136]	; (8016d80 <CS_set_default_pdn+0xd4>)
 8016cf8:	2177      	movs	r1, #119	; 0x77
 8016cfa:	4823      	ldr	r0, [pc, #140]	; (8016d88 <CS_set_default_pdn+0xdc>)
 8016cfc:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016d00:	f7f4 ff70 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016d04:	4604      	mov	r4, r0
 8016d06:	b1e0      	cbz	r0, 8016d42 <CS_set_default_pdn+0x96>
    PRINT_ERR("<Cellular_Service> error when setting default PDN %d", cid)
 8016d08:	4c1b      	ldr	r4, [pc, #108]	; (8016d78 <CS_set_default_pdn+0xcc>)
 8016d0a:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016d0e:	491f      	ldr	r1, [pc, #124]	; (8016d8c <CS_set_default_pdn+0xe0>)
 8016d10:	4620      	mov	r0, r4
 8016d12:	f00f fd99 	bl	8026848 <sprintf>
 8016d16:	4620      	mov	r0, r4
 8016d18:	f008 fb07 	bl	801f32a <crs_strlen>
 8016d1c:	b283      	uxth	r3, r0
 8016d1e:	4622      	mov	r2, r4
 8016d20:	2110      	movs	r1, #16
 8016d22:	2001      	movs	r0, #1
 8016d24:	f008 fb44 	bl	801f3b0 <traceIF_itmPrint>
 8016d28:	4620      	mov	r0, r4
 8016d2a:	f008 fafe 	bl	801f32a <crs_strlen>
 8016d2e:	b283      	uxth	r3, r0
 8016d30:	4622      	mov	r2, r4
 8016d32:	2110      	movs	r1, #16
 8016d34:	2001      	movs	r0, #1
 8016d36:	f008 fb5d 	bl	801f3f4 <traceIF_uartPrint>
 8016d3a:	2401      	movs	r4, #1
}
 8016d3c:	4620      	mov	r0, r4
 8016d3e:	b003      	add	sp, #12
 8016d40:	bd30      	pop	{r4, r5, pc}
      PRINT_DBG("<Cellular_Service> PDN %d set as default", cid)
 8016d42:	4d0d      	ldr	r5, [pc, #52]	; (8016d78 <CS_set_default_pdn+0xcc>)
 8016d44:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8016d48:	4911      	ldr	r1, [pc, #68]	; (8016d90 <CS_set_default_pdn+0xe4>)
 8016d4a:	4628      	mov	r0, r5
 8016d4c:	f00f fd7c 	bl	8026848 <sprintf>
 8016d50:	4628      	mov	r0, r5
 8016d52:	f008 faea 	bl	801f32a <crs_strlen>
 8016d56:	b283      	uxth	r3, r0
 8016d58:	462a      	mov	r2, r5
 8016d5a:	2102      	movs	r1, #2
 8016d5c:	2001      	movs	r0, #1
 8016d5e:	f008 fb27 	bl	801f3b0 <traceIF_itmPrint>
 8016d62:	4628      	mov	r0, r5
 8016d64:	f008 fae1 	bl	801f32a <crs_strlen>
 8016d68:	b283      	uxth	r3, r0
 8016d6a:	462a      	mov	r2, r5
 8016d6c:	2102      	movs	r1, #2
 8016d6e:	2001      	movs	r0, #1
 8016d70:	f008 fb40 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016d74:	e7e2      	b.n	8016d3c <CS_set_default_pdn+0x90>
 8016d76:	bf00      	nop
 8016d78:	200047dc 	.word	0x200047dc
 8016d7c:	08032578 	.word	0x08032578
 8016d80:	20003620 	.word	0x20003620
 8016d84:	20003814 	.word	0x20003814
 8016d88:	2000361c 	.word	0x2000361c
 8016d8c:	080325d4 	.word	0x080325d4
 8016d90:	080325a4 	.word	0x080325a4

08016d94 <CS_get_dev_IP_address>:
{
 8016d94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8016d98:	b094      	sub	sp, #80	; 0x50
 8016d9a:	460d      	mov	r5, r1
 8016d9c:	4616      	mov	r6, r2
 8016d9e:	f88d 0007 	strb.w	r0, [sp, #7]
  PRINT_API("CS_get_dev_IP_address (for conf_id=%d)", cid)
 8016da2:	4c4f      	ldr	r4, [pc, #316]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016da4:	b2c2      	uxtb	r2, r0
 8016da6:	494f      	ldr	r1, [pc, #316]	; (8016ee4 <CS_get_dev_IP_address+0x150>)
 8016da8:	4620      	mov	r0, r4
 8016daa:	f00f fd4d 	bl	8026848 <sprintf>
 8016dae:	4620      	mov	r0, r4
 8016db0:	f008 fabb 	bl	801f32a <crs_strlen>
 8016db4:	b283      	uxth	r3, r0
 8016db6:	4622      	mov	r2, r4
 8016db8:	2104      	movs	r1, #4
 8016dba:	2001      	movs	r0, #1
 8016dbc:	f008 faf8 	bl	801f3b0 <traceIF_itmPrint>
 8016dc0:	4620      	mov	r0, r4
 8016dc2:	f008 fab2 	bl	801f32a <crs_strlen>
 8016dc6:	b283      	uxth	r3, r0
 8016dc8:	4622      	mov	r2, r4
 8016dca:	2104      	movs	r1, #4
 8016dcc:	2001      	movs	r0, #1
 8016dce:	f008 fb11 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016dd2:	f10d 0307 	add.w	r3, sp, #7
 8016dd6:	2201      	movs	r2, #1
 8016dd8:	2125      	movs	r1, #37	; 0x25
 8016dda:	4843      	ldr	r0, [pc, #268]	; (8016ee8 <CS_get_dev_IP_address+0x154>)
 8016ddc:	f7f5 f96a 	bl	800c0b4 <DATAPACK_writeStruct>
 8016de0:	b940      	cbnz	r0, 8016df4 <CS_get_dev_IP_address+0x60>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_GET_IP_ADDRESS, &cmd_buf[0], &rsp_buf[0]);
 8016de2:	4b42      	ldr	r3, [pc, #264]	; (8016eec <CS_get_dev_IP_address+0x158>)
 8016de4:	4a40      	ldr	r2, [pc, #256]	; (8016ee8 <CS_get_dev_IP_address+0x154>)
 8016de6:	2175      	movs	r1, #117	; 0x75
 8016de8:	4841      	ldr	r0, [pc, #260]	; (8016ef0 <CS_get_dev_IP_address+0x15c>)
 8016dea:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016dee:	f7f4 fef9 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016df2:	b1e0      	cbz	r0, 8016e2e <CS_get_dev_IP_address+0x9a>
    PRINT_ERR("<Cellular_Service> error when getting IP address information")
 8016df4:	4c3a      	ldr	r4, [pc, #232]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016df6:	2248      	movs	r2, #72	; 0x48
 8016df8:	493e      	ldr	r1, [pc, #248]	; (8016ef4 <CS_get_dev_IP_address+0x160>)
 8016dfa:	4620      	mov	r0, r4
 8016dfc:	f00f fe74 	bl	8026ae8 <memcpy>
 8016e00:	4620      	mov	r0, r4
 8016e02:	f008 fa92 	bl	801f32a <crs_strlen>
 8016e06:	b283      	uxth	r3, r0
 8016e08:	4622      	mov	r2, r4
 8016e0a:	2110      	movs	r1, #16
 8016e0c:	2001      	movs	r0, #1
 8016e0e:	f008 facf 	bl	801f3b0 <traceIF_itmPrint>
 8016e12:	4620      	mov	r0, r4
 8016e14:	f008 fa89 	bl	801f32a <crs_strlen>
 8016e18:	b283      	uxth	r3, r0
 8016e1a:	4622      	mov	r2, r4
 8016e1c:	2110      	movs	r1, #16
 8016e1e:	2001      	movs	r0, #1
 8016e20:	f008 fae8 	bl	801f3f4 <traceIF_uartPrint>
 8016e24:	2401      	movs	r4, #1
}
 8016e26:	4620      	mov	r0, r4
 8016e28:	b014      	add	sp, #80	; 0x50
 8016e2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (DATAPACK_readStruct(&rsp_buf[0],
 8016e2e:	ab03      	add	r3, sp, #12
 8016e30:	2241      	movs	r2, #65	; 0x41
 8016e32:	2125      	movs	r1, #37	; 0x25
 8016e34:	482d      	ldr	r0, [pc, #180]	; (8016eec <CS_get_dev_IP_address+0x158>)
 8016e36:	f7f5 fa5d 	bl	800c2f4 <DATAPACK_readStruct>
 8016e3a:	4604      	mov	r4, r0
 8016e3c:	2800      	cmp	r0, #0
 8016e3e:	d1d9      	bne.n	8016df4 <CS_get_dev_IP_address+0x60>
        PRINT_DBG("<Cellular_Service> IP address information received")
 8016e40:	f8df e0b8 	ldr.w	lr, [pc, #184]	; 8016efc <CS_get_dev_IP_address+0x168>
 8016e44:	4f26      	ldr	r7, [pc, #152]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016e46:	f10e 0830 	add.w	r8, lr, #48	; 0x30
 8016e4a:	46f4      	mov	ip, lr
 8016e4c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016e50:	6038      	str	r0, [r7, #0]
 8016e52:	6079      	str	r1, [r7, #4]
 8016e54:	60ba      	str	r2, [r7, #8]
 8016e56:	60fb      	str	r3, [r7, #12]
 8016e58:	46e6      	mov	lr, ip
 8016e5a:	3710      	adds	r7, #16
 8016e5c:	45c4      	cmp	ip, r8
 8016e5e:	d1f4      	bne.n	8016e4a <CS_get_dev_IP_address+0xb6>
 8016e60:	e8be 0003 	ldmia.w	lr!, {r0, r1}
 8016e64:	6038      	str	r0, [r7, #0]
 8016e66:	6079      	str	r1, [r7, #4]
 8016e68:	4f1d      	ldr	r7, [pc, #116]	; (8016ee0 <CS_get_dev_IP_address+0x14c>)
 8016e6a:	4638      	mov	r0, r7
 8016e6c:	f008 fa5d 	bl	801f32a <crs_strlen>
 8016e70:	b283      	uxth	r3, r0
 8016e72:	463a      	mov	r2, r7
 8016e74:	2102      	movs	r1, #2
 8016e76:	2001      	movs	r0, #1
 8016e78:	f008 fa9a 	bl	801f3b0 <traceIF_itmPrint>
 8016e7c:	4638      	mov	r0, r7
 8016e7e:	f008 fa54 	bl	801f32a <crs_strlen>
 8016e82:	b283      	uxth	r3, r0
 8016e84:	463a      	mov	r2, r7
 8016e86:	2102      	movs	r1, #2
 8016e88:	2001      	movs	r0, #1
 8016e8a:	f008 fab3 	bl	801f3f4 <traceIF_uartPrint>
        *ip_addr_type = ip_addr_info.ip_addr_type;
 8016e8e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016e92:	702b      	strb	r3, [r5, #0]
        (void) memcpy((void *)p_ip_addr_value,
 8016e94:	f10d 000d 	add.w	r0, sp, #13
 8016e98:	f7e9 f9ac 	bl	80001f4 <strlen>
 8016e9c:	4602      	mov	r2, r0
 8016e9e:	f10d 010d 	add.w	r1, sp, #13
 8016ea2:	4630      	mov	r0, r6
 8016ea4:	f00f fe20 	bl	8026ae8 <memcpy>
        PRINT_DBG("<Cellular_Service> IP address = %s (type = %d)",
 8016ea8:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016eac:	f10d 020d 	add.w	r2, sp, #13
 8016eb0:	4911      	ldr	r1, [pc, #68]	; (8016ef8 <CS_get_dev_IP_address+0x164>)
 8016eb2:	4638      	mov	r0, r7
 8016eb4:	f00f fcc8 	bl	8026848 <sprintf>
 8016eb8:	4638      	mov	r0, r7
 8016eba:	f008 fa36 	bl	801f32a <crs_strlen>
 8016ebe:	b283      	uxth	r3, r0
 8016ec0:	463a      	mov	r2, r7
 8016ec2:	2102      	movs	r1, #2
 8016ec4:	2001      	movs	r0, #1
 8016ec6:	f008 fa73 	bl	801f3b0 <traceIF_itmPrint>
 8016eca:	4638      	mov	r0, r7
 8016ecc:	f008 fa2d 	bl	801f32a <crs_strlen>
 8016ed0:	b283      	uxth	r3, r0
 8016ed2:	463a      	mov	r2, r7
 8016ed4:	2102      	movs	r1, #2
 8016ed6:	2001      	movs	r0, #1
 8016ed8:	f008 fa8c 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016edc:	e7a3      	b.n	8016e26 <CS_get_dev_IP_address+0x92>
 8016ede:	bf00      	nop
 8016ee0:	200047dc 	.word	0x200047dc
 8016ee4:	08032614 	.word	0x08032614
 8016ee8:	20003620 	.word	0x20003620
 8016eec:	20003814 	.word	0x20003814
 8016ef0:	2000361c 	.word	0x2000361c
 8016ef4:	080326b0 	.word	0x080326b0
 8016ef8:	0803267c 	.word	0x0803267c
 8016efc:	08032644 	.word	0x08032644

08016f00 <CS_subscribe_modem_event>:
{
 8016f00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016f02:	b083      	sub	sp, #12
 8016f04:	460e      	mov	r6, r1
 8016f06:	f8ad 0006 	strh.w	r0, [sp, #6]
  PRINT_API("CS_subscribe_modem_event")
 8016f0a:	4d3b      	ldr	r5, [pc, #236]	; (8016ff8 <CS_subscribe_modem_event+0xf8>)
 8016f0c:	4c3b      	ldr	r4, [pc, #236]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016f0e:	f105 0720 	add.w	r7, r5, #32
 8016f12:	46ac      	mov	ip, r5
 8016f14:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8016f18:	6020      	str	r0, [r4, #0]
 8016f1a:	6061      	str	r1, [r4, #4]
 8016f1c:	60a2      	str	r2, [r4, #8]
 8016f1e:	60e3      	str	r3, [r4, #12]
 8016f20:	4665      	mov	r5, ip
 8016f22:	3410      	adds	r4, #16
 8016f24:	45bc      	cmp	ip, r7
 8016f26:	d1f4      	bne.n	8016f12 <CS_subscribe_modem_event+0x12>
 8016f28:	f8bc 3000 	ldrh.w	r3, [ip]
 8016f2c:	8023      	strh	r3, [r4, #0]
 8016f2e:	4c33      	ldr	r4, [pc, #204]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016f30:	4620      	mov	r0, r4
 8016f32:	f008 f9fa 	bl	801f32a <crs_strlen>
 8016f36:	b283      	uxth	r3, r0
 8016f38:	4622      	mov	r2, r4
 8016f3a:	2104      	movs	r1, #4
 8016f3c:	2001      	movs	r0, #1
 8016f3e:	f008 fa37 	bl	801f3b0 <traceIF_itmPrint>
 8016f42:	4620      	mov	r0, r4
 8016f44:	f008 f9f1 	bl	801f32a <crs_strlen>
 8016f48:	b283      	uxth	r3, r0
 8016f4a:	4622      	mov	r2, r4
 8016f4c:	2104      	movs	r1, #4
 8016f4e:	2001      	movs	r0, #1
 8016f50:	f008 fa50 	bl	801f3f4 <traceIF_uartPrint>
  if (DATAPACK_writeStruct(&cmd_buf[0],
 8016f54:	f10d 0306 	add.w	r3, sp, #6
 8016f58:	2202      	movs	r2, #2
 8016f5a:	2129      	movs	r1, #41	; 0x29
 8016f5c:	4828      	ldr	r0, [pc, #160]	; (8017000 <CS_subscribe_modem_event+0x100>)
 8016f5e:	f7f5 f8a9 	bl	800c0b4 <DATAPACK_writeStruct>
 8016f62:	b948      	cbnz	r0, 8016f78 <CS_subscribe_modem_event+0x78>
    err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SUSBCRIBE_MODEM_EVENT, &cmd_buf[0], &rsp_buf[0]);
 8016f64:	4b27      	ldr	r3, [pc, #156]	; (8017004 <CS_subscribe_modem_event+0x104>)
 8016f66:	4a26      	ldr	r2, [pc, #152]	; (8017000 <CS_subscribe_modem_event+0x100>)
 8016f68:	2185      	movs	r1, #133	; 0x85
 8016f6a:	4827      	ldr	r0, [pc, #156]	; (8017008 <CS_subscribe_modem_event+0x108>)
 8016f6c:	f9b0 0000 	ldrsh.w	r0, [r0]
 8016f70:	f7f4 fe38 	bl	800bbe4 <AT_sendcmd>
    if (err == ATSTATUS_OK)
 8016f74:	4607      	mov	r7, r0
 8016f76:	b1d8      	cbz	r0, 8016fb0 <CS_subscribe_modem_event+0xb0>
    PRINT_ERR("<Cellular_Service> error when subscribing modem event")
 8016f78:	4c20      	ldr	r4, [pc, #128]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016f7a:	2241      	movs	r2, #65	; 0x41
 8016f7c:	4923      	ldr	r1, [pc, #140]	; (801700c <CS_subscribe_modem_event+0x10c>)
 8016f7e:	4620      	mov	r0, r4
 8016f80:	f00f fdb2 	bl	8026ae8 <memcpy>
 8016f84:	4620      	mov	r0, r4
 8016f86:	f008 f9d0 	bl	801f32a <crs_strlen>
 8016f8a:	b283      	uxth	r3, r0
 8016f8c:	4622      	mov	r2, r4
 8016f8e:	2110      	movs	r1, #16
 8016f90:	2001      	movs	r0, #1
 8016f92:	f008 fa0d 	bl	801f3b0 <traceIF_itmPrint>
 8016f96:	4620      	mov	r0, r4
 8016f98:	f008 f9c7 	bl	801f32a <crs_strlen>
 8016f9c:	b283      	uxth	r3, r0
 8016f9e:	4622      	mov	r2, r4
 8016fa0:	2110      	movs	r1, #16
 8016fa2:	2001      	movs	r0, #1
 8016fa4:	f008 fa26 	bl	801f3f4 <traceIF_uartPrint>
 8016fa8:	2701      	movs	r7, #1
}
 8016faa:	4638      	mov	r0, r7
 8016fac:	b003      	add	sp, #12
 8016fae:	bdf0      	pop	{r4, r5, r6, r7, pc}
      urc_modem_event_callback = modem_evt_cb;
 8016fb0:	4b17      	ldr	r3, [pc, #92]	; (8017010 <CS_subscribe_modem_event+0x110>)
 8016fb2:	601e      	str	r6, [r3, #0]
      PRINT_DBG("<Cellular_Service> modem events subscribed")
 8016fb4:	4e17      	ldr	r6, [pc, #92]	; (8017014 <CS_subscribe_modem_event+0x114>)
 8016fb6:	4625      	mov	r5, r4
 8016fb8:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 8016fbc:	4634      	mov	r4, r6
 8016fbe:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8016fc0:	6028      	str	r0, [r5, #0]
 8016fc2:	6069      	str	r1, [r5, #4]
 8016fc4:	60aa      	str	r2, [r5, #8]
 8016fc6:	60eb      	str	r3, [r5, #12]
 8016fc8:	4626      	mov	r6, r4
 8016fca:	3510      	adds	r5, #16
 8016fcc:	4564      	cmp	r4, ip
 8016fce:	d1f5      	bne.n	8016fbc <CS_subscribe_modem_event+0xbc>
 8016fd0:	4c0a      	ldr	r4, [pc, #40]	; (8016ffc <CS_subscribe_modem_event+0xfc>)
 8016fd2:	4620      	mov	r0, r4
 8016fd4:	f008 f9a9 	bl	801f32a <crs_strlen>
 8016fd8:	b283      	uxth	r3, r0
 8016fda:	4622      	mov	r2, r4
 8016fdc:	2102      	movs	r1, #2
 8016fde:	2001      	movs	r0, #1
 8016fe0:	f008 f9e6 	bl	801f3b0 <traceIF_itmPrint>
 8016fe4:	4620      	mov	r0, r4
 8016fe6:	f008 f9a0 	bl	801f32a <crs_strlen>
 8016fea:	b283      	uxth	r3, r0
 8016fec:	4622      	mov	r2, r4
 8016fee:	2102      	movs	r1, #2
 8016ff0:	2001      	movs	r0, #1
 8016ff2:	f008 f9ff 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8016ff6:	e7d8      	b.n	8016faa <CS_subscribe_modem_event+0xaa>
 8016ff8:	080326f8 	.word	0x080326f8
 8016ffc:	200047dc 	.word	0x200047dc
 8017000:	20003620 	.word	0x20003620
 8017004:	20003814 	.word	0x20003814
 8017008:	2000361c 	.word	0x2000361c
 801700c:	0803274c 	.word	0x0803274c
 8017010:	200038ac 	.word	0x200038ac
 8017014:	0803271c 	.word	0x0803271c

08017018 <CS_register_pdn_event>:
{
 8017018:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801701c:	4606      	mov	r6, r0
 801701e:	460f      	mov	r7, r1
  PRINT_API("CS_register_pdn_event")
 8017020:	4c57      	ldr	r4, [pc, #348]	; (8017180 <CS_register_pdn_event+0x168>)
 8017022:	4d58      	ldr	r5, [pc, #352]	; (8017184 <CS_register_pdn_event+0x16c>)
 8017024:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017026:	6020      	str	r0, [r4, #0]
 8017028:	6061      	str	r1, [r4, #4]
 801702a:	60a2      	str	r2, [r4, #8]
 801702c:	60e3      	str	r3, [r4, #12]
 801702e:	cd07      	ldmia	r5!, {r0, r1, r2}
 8017030:	6120      	str	r0, [r4, #16]
 8017032:	6161      	str	r1, [r4, #20]
 8017034:	61a2      	str	r2, [r4, #24]
 8017036:	882a      	ldrh	r2, [r5, #0]
 8017038:	78ab      	ldrb	r3, [r5, #2]
 801703a:	83a2      	strh	r2, [r4, #28]
 801703c:	77a3      	strb	r3, [r4, #30]
 801703e:	4620      	mov	r0, r4
 8017040:	f008 f973 	bl	801f32a <crs_strlen>
 8017044:	b283      	uxth	r3, r0
 8017046:	4622      	mov	r2, r4
 8017048:	2104      	movs	r1, #4
 801704a:	2001      	movs	r0, #1
 801704c:	f008 f9b0 	bl	801f3b0 <traceIF_itmPrint>
 8017050:	4620      	mov	r0, r4
 8017052:	f008 f96a 	bl	801f32a <crs_strlen>
 8017056:	b283      	uxth	r3, r0
 8017058:	4622      	mov	r2, r4
 801705a:	2104      	movs	r1, #4
 801705c:	2001      	movs	r0, #1
 801705e:	f008 f9c9 	bl	801f3f4 <traceIF_uartPrint>
  if (cid > CS_PDN_USER_CONFIG_5)
 8017062:	2e05      	cmp	r6, #5
 8017064:	d945      	bls.n	80170f2 <CS_register_pdn_event+0xda>
    PRINT_ERR("<Cellular_Service> only explicit PDN user config is supported (cid=%d)", cid)
 8017066:	4632      	mov	r2, r6
 8017068:	4947      	ldr	r1, [pc, #284]	; (8017188 <CS_register_pdn_event+0x170>)
 801706a:	4620      	mov	r0, r4
 801706c:	f00f fbec 	bl	8026848 <sprintf>
 8017070:	4620      	mov	r0, r4
 8017072:	f008 f95a 	bl	801f32a <crs_strlen>
 8017076:	b283      	uxth	r3, r0
 8017078:	4622      	mov	r2, r4
 801707a:	2110      	movs	r1, #16
 801707c:	2001      	movs	r0, #1
 801707e:	f008 f997 	bl	801f3b0 <traceIF_itmPrint>
 8017082:	4620      	mov	r0, r4
 8017084:	f008 f951 	bl	801f32a <crs_strlen>
 8017088:	b283      	uxth	r3, r0
 801708a:	4622      	mov	r2, r4
 801708c:	2110      	movs	r1, #16
 801708e:	2001      	movs	r0, #1
 8017090:	f008 f9b0 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service>error when registering PDN events")
 8017094:	4c3d      	ldr	r4, [pc, #244]	; (801718c <CS_register_pdn_event+0x174>)
 8017096:	4d3a      	ldr	r5, [pc, #232]	; (8017180 <CS_register_pdn_event+0x168>)
 8017098:	f104 0630 	add.w	r6, r4, #48	; 0x30
 801709c:	46a4      	mov	ip, r4
 801709e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80170a2:	6028      	str	r0, [r5, #0]
 80170a4:	6069      	str	r1, [r5, #4]
 80170a6:	60aa      	str	r2, [r5, #8]
 80170a8:	60eb      	str	r3, [r5, #12]
 80170aa:	4664      	mov	r4, ip
 80170ac:	3510      	adds	r5, #16
 80170ae:	45b4      	cmp	ip, r6
 80170b0:	d1f4      	bne.n	801709c <CS_register_pdn_event+0x84>
 80170b2:	4663      	mov	r3, ip
 80170b4:	cb07      	ldmia	r3!, {r0, r1, r2}
 80170b6:	6028      	str	r0, [r5, #0]
 80170b8:	6069      	str	r1, [r5, #4]
 80170ba:	60aa      	str	r2, [r5, #8]
 80170bc:	881a      	ldrh	r2, [r3, #0]
 80170be:	789b      	ldrb	r3, [r3, #2]
 80170c0:	81aa      	strh	r2, [r5, #12]
 80170c2:	73ab      	strb	r3, [r5, #14]
 80170c4:	4c2e      	ldr	r4, [pc, #184]	; (8017180 <CS_register_pdn_event+0x168>)
 80170c6:	4620      	mov	r0, r4
 80170c8:	f008 f92f 	bl	801f32a <crs_strlen>
 80170cc:	b283      	uxth	r3, r0
 80170ce:	4622      	mov	r2, r4
 80170d0:	2110      	movs	r1, #16
 80170d2:	2001      	movs	r0, #1
 80170d4:	f008 f96c 	bl	801f3b0 <traceIF_itmPrint>
 80170d8:	4620      	mov	r0, r4
 80170da:	f008 f926 	bl	801f32a <crs_strlen>
 80170de:	b283      	uxth	r3, r0
 80170e0:	4622      	mov	r2, r4
 80170e2:	2110      	movs	r1, #16
 80170e4:	2001      	movs	r0, #1
 80170e6:	f008 f985 	bl	801f3f4 <traceIF_uartPrint>
 80170ea:	2401      	movs	r4, #1
}
 80170ec:	4620      	mov	r0, r4
 80170ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (DATAPACK_writeStruct(&cmd_buf[0],
 80170f2:	2300      	movs	r3, #0
 80170f4:	461a      	mov	r2, r3
 80170f6:	2104      	movs	r1, #4
 80170f8:	4825      	ldr	r0, [pc, #148]	; (8017190 <CS_register_pdn_event+0x178>)
 80170fa:	f7f4 ffdb 	bl	800c0b4 <DATAPACK_writeStruct>
 80170fe:	2800      	cmp	r0, #0
 8017100:	d1c8      	bne.n	8017094 <CS_register_pdn_event+0x7c>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_REGISTER_PDN_EVENT, &cmd_buf[0], &rsp_buf[0]);
 8017102:	4b24      	ldr	r3, [pc, #144]	; (8017194 <CS_register_pdn_event+0x17c>)
 8017104:	4a22      	ldr	r2, [pc, #136]	; (8017190 <CS_register_pdn_event+0x178>)
 8017106:	2173      	movs	r1, #115	; 0x73
 8017108:	4823      	ldr	r0, [pc, #140]	; (8017198 <CS_register_pdn_event+0x180>)
 801710a:	f9b0 0000 	ldrsh.w	r0, [r0]
 801710e:	f7f4 fd69 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017112:	4604      	mov	r4, r0
 8017114:	2800      	cmp	r0, #0
 8017116:	d1bd      	bne.n	8017094 <CS_register_pdn_event+0x7c>
        PRINT_DBG("<Cellular_Service> PDN events registered successfully")
 8017118:	f8df c088 	ldr.w	ip, [pc, #136]	; 80171a4 <CS_register_pdn_event+0x18c>
 801711c:	4d18      	ldr	r5, [pc, #96]	; (8017180 <CS_register_pdn_event+0x168>)
 801711e:	f10c 0830 	add.w	r8, ip, #48	; 0x30
 8017122:	46e6      	mov	lr, ip
 8017124:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 8017128:	6028      	str	r0, [r5, #0]
 801712a:	6069      	str	r1, [r5, #4]
 801712c:	60aa      	str	r2, [r5, #8]
 801712e:	60eb      	str	r3, [r5, #12]
 8017130:	46f4      	mov	ip, lr
 8017132:	3510      	adds	r5, #16
 8017134:	45c6      	cmp	lr, r8
 8017136:	d1f4      	bne.n	8017122 <CS_register_pdn_event+0x10a>
 8017138:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 801713c:	6028      	str	r0, [r5, #0]
 801713e:	6069      	str	r1, [r5, #4]
 8017140:	f8bc 2000 	ldrh.w	r2, [ip]
 8017144:	f89c 3002 	ldrb.w	r3, [ip, #2]
 8017148:	812a      	strh	r2, [r5, #8]
 801714a:	72ab      	strb	r3, [r5, #10]
 801714c:	4d0c      	ldr	r5, [pc, #48]	; (8017180 <CS_register_pdn_event+0x168>)
 801714e:	4628      	mov	r0, r5
 8017150:	f008 f8eb 	bl	801f32a <crs_strlen>
 8017154:	b283      	uxth	r3, r0
 8017156:	462a      	mov	r2, r5
 8017158:	2102      	movs	r1, #2
 801715a:	2001      	movs	r0, #1
 801715c:	f008 f928 	bl	801f3b0 <traceIF_itmPrint>
 8017160:	4628      	mov	r0, r5
 8017162:	f008 f8e2 	bl	801f32a <crs_strlen>
 8017166:	b283      	uxth	r3, r0
 8017168:	462a      	mov	r2, r5
 801716a:	2102      	movs	r1, #2
 801716c:	2001      	movs	r0, #1
 801716e:	f008 f941 	bl	801f3f4 <traceIF_uartPrint>
        urc_packet_domain_event_callback[cid] = pdn_event_callback;
 8017172:	4b0a      	ldr	r3, [pc, #40]	; (801719c <CS_register_pdn_event+0x184>)
 8017174:	f843 7026 	str.w	r7, [r3, r6, lsl #2]
        cs_ctxt_urc_subscription.packet_domain_event = CELLULAR_TRUE;
 8017178:	4b09      	ldr	r3, [pc, #36]	; (80171a0 <CS_register_pdn_event+0x188>)
 801717a:	2201      	movs	r2, #1
 801717c:	71da      	strb	r2, [r3, #7]
  if (retval == CELLULAR_ERROR)
 801717e:	e7b5      	b.n	80170ec <CS_register_pdn_event+0xd4>
 8017180:	200047dc 	.word	0x200047dc
 8017184:	08032790 	.word	0x08032790
 8017188:	080327b0 	.word	0x080327b0
 801718c:	08032840 	.word	0x08032840
 8017190:	20003620 	.word	0x20003620
 8017194:	20003814 	.word	0x20003814
 8017198:	2000361c 	.word	0x2000361c
 801719c:	200038b0 	.word	0x200038b0
 80171a0:	20003804 	.word	0x20003804
 80171a4:	08032804 	.word	0x08032804

080171a8 <CDS_socket_create>:
{
 80171a8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80171ac:	b083      	sub	sp, #12
 80171ae:	4607      	mov	r7, r0
 80171b0:	4688      	mov	r8, r1
 80171b2:	4691      	mov	r9, r2
  PRINT_API("CDS_socket_create")
 80171b4:	4c4b      	ldr	r4, [pc, #300]	; (80172e4 <CDS_socket_create+0x13c>)
 80171b6:	4d4c      	ldr	r5, [pc, #304]	; (80172e8 <CDS_socket_create+0x140>)
 80171b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80171ba:	6020      	str	r0, [r4, #0]
 80171bc:	6061      	str	r1, [r4, #4]
 80171be:	60a2      	str	r2, [r4, #8]
 80171c0:	60e3      	str	r3, [r4, #12]
 80171c2:	cd03      	ldmia	r5!, {r0, r1}
 80171c4:	6120      	str	r0, [r4, #16]
 80171c6:	6161      	str	r1, [r4, #20]
 80171c8:	882a      	ldrh	r2, [r5, #0]
 80171ca:	78ab      	ldrb	r3, [r5, #2]
 80171cc:	8322      	strh	r2, [r4, #24]
 80171ce:	76a3      	strb	r3, [r4, #26]
 80171d0:	4620      	mov	r0, r4
 80171d2:	f008 f8aa 	bl	801f32a <crs_strlen>
 80171d6:	b283      	uxth	r3, r0
 80171d8:	4622      	mov	r2, r4
 80171da:	2104      	movs	r1, #4
 80171dc:	2001      	movs	r0, #1
 80171de:	f008 f8e7 	bl	801f3b0 <traceIF_itmPrint>
 80171e2:	4620      	mov	r0, r4
 80171e4:	f008 f8a1 	bl	801f32a <crs_strlen>
 80171e8:	b283      	uxth	r3, r0
 80171ea:	4622      	mov	r2, r4
 80171ec:	2104      	movs	r1, #4
 80171ee:	2001      	movs	r0, #1
 80171f0:	f008 f900 	bl	801f3f4 <traceIF_uartPrint>
  socket_handle_t sockhandle = csint_socket_allocateHandle();
 80171f4:	f003 fa1e 	bl	801a634 <csint_socket_allocateHandle>
 80171f8:	4606      	mov	r6, r0
  if (sockhandle == CS_INVALID_SOCKET_HANDLE)
 80171fa:	f1b0 3fff 	cmp.w	r0, #4294967295
 80171fe:	d024      	beq.n	801724a <CDS_socket_create+0xa2>
  else if (csint_socket_create(sockhandle, addr_type, protocol, /* default local_port = 0 */ 0U, cid) != CELLULAR_OK)
 8017200:	f8cd 9000 	str.w	r9, [sp]
 8017204:	2300      	movs	r3, #0
 8017206:	4642      	mov	r2, r8
 8017208:	4639      	mov	r1, r7
 801720a:	f003 fa47 	bl	801a69c <csint_socket_create>
 801720e:	2800      	cmp	r0, #0
 8017210:	d13f      	bne.n	8017292 <CDS_socket_create+0xea>
    PRINT_INFO("allocated socket handle=%ld (local)", sockhandle)
 8017212:	4c34      	ldr	r4, [pc, #208]	; (80172e4 <CDS_socket_create+0x13c>)
 8017214:	4632      	mov	r2, r6
 8017216:	4935      	ldr	r1, [pc, #212]	; (80172ec <CDS_socket_create+0x144>)
 8017218:	4620      	mov	r0, r4
 801721a:	f00f fb15 	bl	8026848 <sprintf>
 801721e:	4620      	mov	r0, r4
 8017220:	f008 f883 	bl	801f32a <crs_strlen>
 8017224:	b283      	uxth	r3, r0
 8017226:	4622      	mov	r2, r4
 8017228:	2101      	movs	r1, #1
 801722a:	4608      	mov	r0, r1
 801722c:	f008 f8c0 	bl	801f3b0 <traceIF_itmPrint>
 8017230:	4620      	mov	r0, r4
 8017232:	f008 f87a 	bl	801f32a <crs_strlen>
 8017236:	b283      	uxth	r3, r0
 8017238:	4622      	mov	r2, r4
 801723a:	2101      	movs	r1, #1
 801723c:	4608      	mov	r0, r1
 801723e:	f008 f8d9 	bl	801f3f4 <traceIF_uartPrint>
}
 8017242:	4630      	mov	r0, r6
 8017244:	b003      	add	sp, #12
 8017246:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("no free socket handle")
 801724a:	4f29      	ldr	r7, [pc, #164]	; (80172f0 <CDS_socket_create+0x148>)
 801724c:	4625      	mov	r5, r4
 801724e:	f107 0c20 	add.w	ip, r7, #32
 8017252:	463c      	mov	r4, r7
 8017254:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8017256:	6028      	str	r0, [r5, #0]
 8017258:	6069      	str	r1, [r5, #4]
 801725a:	60aa      	str	r2, [r5, #8]
 801725c:	60eb      	str	r3, [r5, #12]
 801725e:	4627      	mov	r7, r4
 8017260:	3510      	adds	r5, #16
 8017262:	4564      	cmp	r4, ip
 8017264:	d1f5      	bne.n	8017252 <CDS_socket_create+0xaa>
 8017266:	7823      	ldrb	r3, [r4, #0]
 8017268:	702b      	strb	r3, [r5, #0]
 801726a:	4c1e      	ldr	r4, [pc, #120]	; (80172e4 <CDS_socket_create+0x13c>)
 801726c:	4620      	mov	r0, r4
 801726e:	f008 f85c 	bl	801f32a <crs_strlen>
 8017272:	b283      	uxth	r3, r0
 8017274:	4622      	mov	r2, r4
 8017276:	2110      	movs	r1, #16
 8017278:	2001      	movs	r0, #1
 801727a:	f008 f899 	bl	801f3b0 <traceIF_itmPrint>
 801727e:	4620      	mov	r0, r4
 8017280:	f008 f853 	bl	801f32a <crs_strlen>
 8017284:	b283      	uxth	r3, r0
 8017286:	4622      	mov	r2, r4
 8017288:	2110      	movs	r1, #16
 801728a:	2001      	movs	r0, #1
 801728c:	f008 f8b2 	bl	801f3f4 <traceIF_uartPrint>
 8017290:	e7d7      	b.n	8017242 <CDS_socket_create+0x9a>
    PRINT_ERR("socket creation failed")
 8017292:	4f18      	ldr	r7, [pc, #96]	; (80172f4 <CDS_socket_create+0x14c>)
 8017294:	4d13      	ldr	r5, [pc, #76]	; (80172e4 <CDS_socket_create+0x13c>)
 8017296:	f107 0c20 	add.w	ip, r7, #32
 801729a:	463c      	mov	r4, r7
 801729c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801729e:	6028      	str	r0, [r5, #0]
 80172a0:	6069      	str	r1, [r5, #4]
 80172a2:	60aa      	str	r2, [r5, #8]
 80172a4:	60eb      	str	r3, [r5, #12]
 80172a6:	4627      	mov	r7, r4
 80172a8:	3510      	adds	r5, #16
 80172aa:	4564      	cmp	r4, ip
 80172ac:	d1f5      	bne.n	801729a <CDS_socket_create+0xf2>
 80172ae:	8823      	ldrh	r3, [r4, #0]
 80172b0:	802b      	strh	r3, [r5, #0]
 80172b2:	4c0c      	ldr	r4, [pc, #48]	; (80172e4 <CDS_socket_create+0x13c>)
 80172b4:	4620      	mov	r0, r4
 80172b6:	f008 f838 	bl	801f32a <crs_strlen>
 80172ba:	b283      	uxth	r3, r0
 80172bc:	4622      	mov	r2, r4
 80172be:	2110      	movs	r1, #16
 80172c0:	2001      	movs	r0, #1
 80172c2:	f008 f875 	bl	801f3b0 <traceIF_itmPrint>
 80172c6:	4620      	mov	r0, r4
 80172c8:	f008 f82f 	bl	801f32a <crs_strlen>
 80172cc:	b283      	uxth	r3, r0
 80172ce:	4622      	mov	r2, r4
 80172d0:	2110      	movs	r1, #16
 80172d2:	2001      	movs	r0, #1
 80172d4:	f008 f88e 	bl	801f3f4 <traceIF_uartPrint>
    csint_socket_deallocateHandle(sockhandle);
 80172d8:	4630      	mov	r0, r6
 80172da:	f003 f9bd 	bl	801a658 <csint_socket_deallocateHandle>
    sockhandle = CS_INVALID_SOCKET_HANDLE;
 80172de:	f04f 36ff 	mov.w	r6, #4294967295
 80172e2:	e7ae      	b.n	8017242 <CDS_socket_create+0x9a>
 80172e4:	200047dc 	.word	0x200047dc
 80172e8:	08032880 	.word	0x08032880
 80172ec:	080328e4 	.word	0x080328e4
 80172f0:	0803289c 	.word	0x0803289c
 80172f4:	080328c0 	.word	0x080328c0

080172f8 <CDS_socket_bind>:
{
 80172f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80172fa:	4606      	mov	r6, r0
 80172fc:	460f      	mov	r7, r1
  PRINT_API("CDS_socket_bind")
 80172fe:	4c33      	ldr	r4, [pc, #204]	; (80173cc <CDS_socket_bind+0xd4>)
 8017300:	4d33      	ldr	r5, [pc, #204]	; (80173d0 <CDS_socket_bind+0xd8>)
 8017302:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017304:	6020      	str	r0, [r4, #0]
 8017306:	6061      	str	r1, [r4, #4]
 8017308:	60a2      	str	r2, [r4, #8]
 801730a:	60e3      	str	r3, [r4, #12]
 801730c:	cd03      	ldmia	r5!, {r0, r1}
 801730e:	6120      	str	r0, [r4, #16]
 8017310:	6161      	str	r1, [r4, #20]
 8017312:	782b      	ldrb	r3, [r5, #0]
 8017314:	7623      	strb	r3, [r4, #24]
 8017316:	4620      	mov	r0, r4
 8017318:	f008 f807 	bl	801f32a <crs_strlen>
 801731c:	b283      	uxth	r3, r0
 801731e:	4622      	mov	r2, r4
 8017320:	2104      	movs	r1, #4
 8017322:	2001      	movs	r0, #1
 8017324:	f008 f844 	bl	801f3b0 <traceIF_itmPrint>
 8017328:	4620      	mov	r0, r4
 801732a:	f007 fffe 	bl	801f32a <crs_strlen>
 801732e:	b283      	uxth	r3, r0
 8017330:	4622      	mov	r2, r4
 8017332:	2104      	movs	r1, #4
 8017334:	2001      	movs	r0, #1
 8017336:	f008 f85d 	bl	801f3f4 <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CREATED)
 801733a:	4b26      	ldr	r3, [pc, #152]	; (80173d4 <CDS_socket_bind+0xdc>)
 801733c:	226c      	movs	r2, #108	; 0x6c
 801733e:	fb02 3306 	mla	r3, r2, r6, r3
 8017342:	791c      	ldrb	r4, [r3, #4]
 8017344:	2c01      	cmp	r4, #1
 8017346:	d019      	beq.n	801737c <CDS_socket_bind+0x84>
    PRINT_ERR("<Cellular_Service> socket bind allowed only after create/before connect %ld ", sockHandle)
 8017348:	4c20      	ldr	r4, [pc, #128]	; (80173cc <CDS_socket_bind+0xd4>)
 801734a:	4632      	mov	r2, r6
 801734c:	4922      	ldr	r1, [pc, #136]	; (80173d8 <CDS_socket_bind+0xe0>)
 801734e:	4620      	mov	r0, r4
 8017350:	f00f fa7a 	bl	8026848 <sprintf>
 8017354:	4620      	mov	r0, r4
 8017356:	f007 ffe8 	bl	801f32a <crs_strlen>
 801735a:	b283      	uxth	r3, r0
 801735c:	4622      	mov	r2, r4
 801735e:	2110      	movs	r1, #16
 8017360:	2001      	movs	r0, #1
 8017362:	f008 f825 	bl	801f3b0 <traceIF_itmPrint>
 8017366:	4620      	mov	r0, r4
 8017368:	f007 ffdf 	bl	801f32a <crs_strlen>
 801736c:	b283      	uxth	r3, r0
 801736e:	4622      	mov	r2, r4
 8017370:	2110      	movs	r1, #16
 8017372:	2001      	movs	r0, #1
 8017374:	f008 f83e 	bl	801f3f4 <traceIF_uartPrint>
    res = CELLULAR_ERROR;
 8017378:	2001      	movs	r0, #1
}
 801737a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (csint_socket_bind(sockHandle, local_port) != CELLULAR_OK)
 801737c:	4639      	mov	r1, r7
 801737e:	4630      	mov	r0, r6
 8017380:	f003 f9c4 	bl	801a70c <csint_socket_bind>
 8017384:	2800      	cmp	r0, #0
 8017386:	d0f8      	beq.n	801737a <CDS_socket_bind+0x82>
    PRINT_ERR("Socket Bind error")
 8017388:	4d10      	ldr	r5, [pc, #64]	; (80173cc <CDS_socket_bind+0xd4>)
 801738a:	4e14      	ldr	r6, [pc, #80]	; (80173dc <CDS_socket_bind+0xe4>)
 801738c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801738e:	6028      	str	r0, [r5, #0]
 8017390:	6069      	str	r1, [r5, #4]
 8017392:	60aa      	str	r2, [r5, #8]
 8017394:	60eb      	str	r3, [r5, #12]
 8017396:	ce07      	ldmia	r6!, {r0, r1, r2}
 8017398:	6128      	str	r0, [r5, #16]
 801739a:	6169      	str	r1, [r5, #20]
 801739c:	61aa      	str	r2, [r5, #24]
 801739e:	7833      	ldrb	r3, [r6, #0]
 80173a0:	772b      	strb	r3, [r5, #28]
 80173a2:	4628      	mov	r0, r5
 80173a4:	f007 ffc1 	bl	801f32a <crs_strlen>
 80173a8:	b283      	uxth	r3, r0
 80173aa:	462a      	mov	r2, r5
 80173ac:	2110      	movs	r1, #16
 80173ae:	2001      	movs	r0, #1
 80173b0:	f007 fffe 	bl	801f3b0 <traceIF_itmPrint>
 80173b4:	4628      	mov	r0, r5
 80173b6:	f007 ffb8 	bl	801f32a <crs_strlen>
 80173ba:	b283      	uxth	r3, r0
 80173bc:	462a      	mov	r2, r5
 80173be:	2110      	movs	r1, #16
 80173c0:	2001      	movs	r0, #1
 80173c2:	f008 f817 	bl	801f3f4 <traceIF_uartPrint>
    res = CELLULAR_ERROR;
 80173c6:	4620      	mov	r0, r4
 80173c8:	e7d7      	b.n	801737a <CDS_socket_bind+0x82>
 80173ca:	bf00      	nop
 80173cc:	200047dc 	.word	0x200047dc
 80173d0:	08032910 	.word	0x08032910
 80173d4:	20003d18 	.word	0x20003d18
 80173d8:	0803292c 	.word	0x0803292c
 80173dc:	08032984 	.word	0x08032984

080173e0 <CDS_socket_set_callbacks>:
{
 80173e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80173e4:	4606      	mov	r6, r0
 80173e6:	460f      	mov	r7, r1
 80173e8:	4691      	mov	r9, r2
 80173ea:	4698      	mov	r8, r3
  PRINT_API("CDS_socket_set_callbacks")
 80173ec:	4d66      	ldr	r5, [pc, #408]	; (8017588 <CDS_socket_set_callbacks+0x1a8>)
 80173ee:	4c67      	ldr	r4, [pc, #412]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 80173f0:	f105 0e20 	add.w	lr, r5, #32
 80173f4:	46ac      	mov	ip, r5
 80173f6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80173fa:	6020      	str	r0, [r4, #0]
 80173fc:	6061      	str	r1, [r4, #4]
 80173fe:	60a2      	str	r2, [r4, #8]
 8017400:	60e3      	str	r3, [r4, #12]
 8017402:	4665      	mov	r5, ip
 8017404:	3410      	adds	r4, #16
 8017406:	45f4      	cmp	ip, lr
 8017408:	d1f4      	bne.n	80173f4 <CDS_socket_set_callbacks+0x14>
 801740a:	f8bc 3000 	ldrh.w	r3, [ip]
 801740e:	8023      	strh	r3, [r4, #0]
 8017410:	4c5e      	ldr	r4, [pc, #376]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017412:	4620      	mov	r0, r4
 8017414:	f007 ff89 	bl	801f32a <crs_strlen>
 8017418:	b283      	uxth	r3, r0
 801741a:	4622      	mov	r2, r4
 801741c:	2104      	movs	r1, #4
 801741e:	2001      	movs	r0, #1
 8017420:	f007 ffc6 	bl	801f3b0 <traceIF_itmPrint>
 8017424:	4620      	mov	r0, r4
 8017426:	f007 ff80 	bl	801f32a <crs_strlen>
 801742a:	b283      	uxth	r3, r0
 801742c:	4622      	mov	r2, r4
 801742e:	2104      	movs	r1, #4
 8017430:	2001      	movs	r0, #1
 8017432:	f007 ffdf 	bl	801f3f4 <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_NOT_ALLOC)
 8017436:	4b56      	ldr	r3, [pc, #344]	; (8017590 <CDS_socket_set_callbacks+0x1b0>)
 8017438:	226c      	movs	r2, #108	; 0x6c
 801743a:	fb02 3306 	mla	r3, r2, r6, r3
 801743e:	791b      	ldrb	r3, [r3, #4]
 8017440:	2b00      	cmp	r3, #0
 8017442:	d03a      	beq.n	80174ba <CDS_socket_set_callbacks+0xda>
  else if (data_ready_cb == NULL)
 8017444:	2f00      	cmp	r7, #0
 8017446:	d051      	beq.n	80174ec <CDS_socket_set_callbacks+0x10c>
  else if (remote_close_cb == NULL)
 8017448:	f1b8 0f00 	cmp.w	r8, #0
 801744c:	d075      	beq.n	801753a <CDS_socket_set_callbacks+0x15a>
    cs_ctxt_sockets_info[sockHandle].socket_data_ready_callback = data_ready_cb;
 801744e:	4b50      	ldr	r3, [pc, #320]	; (8017590 <CDS_socket_set_callbacks+0x1b0>)
 8017450:	226c      	movs	r2, #108	; 0x6c
 8017452:	fb02 3306 	mla	r3, r2, r6, r3
 8017456:	661f      	str	r7, [r3, #96]	; 0x60
    cs_ctxt_sockets_info[sockHandle].socket_remote_close_callback = remote_close_cb;
 8017458:	f8c3 8068 	str.w	r8, [r3, #104]	; 0x68
    retval = CELLULAR_OK;
 801745c:	2600      	movs	r6, #0
  if (data_sent_cb != NULL)
 801745e:	f1b9 0f00 	cmp.w	r9, #0
 8017462:	d027      	beq.n	80174b4 <CDS_socket_set_callbacks+0xd4>
    PRINT_ERR("DATA sent callback not supported (only synch mode)")
 8017464:	4c4b      	ldr	r4, [pc, #300]	; (8017594 <CDS_socket_set_callbacks+0x1b4>)
 8017466:	4d49      	ldr	r5, [pc, #292]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017468:	f104 0730 	add.w	r7, r4, #48	; 0x30
 801746c:	46a4      	mov	ip, r4
 801746e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017472:	6028      	str	r0, [r5, #0]
 8017474:	6069      	str	r1, [r5, #4]
 8017476:	60aa      	str	r2, [r5, #8]
 8017478:	60eb      	str	r3, [r5, #12]
 801747a:	4664      	mov	r4, ip
 801747c:	3510      	adds	r5, #16
 801747e:	45bc      	cmp	ip, r7
 8017480:	d1f4      	bne.n	801746c <CDS_socket_set_callbacks+0x8c>
 8017482:	cc07      	ldmia	r4!, {r0, r1, r2}
 8017484:	6028      	str	r0, [r5, #0]
 8017486:	6069      	str	r1, [r5, #4]
 8017488:	60aa      	str	r2, [r5, #8]
 801748a:	8823      	ldrh	r3, [r4, #0]
 801748c:	81ab      	strh	r3, [r5, #12]
 801748e:	4c3f      	ldr	r4, [pc, #252]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017490:	4620      	mov	r0, r4
 8017492:	f007 ff4a 	bl	801f32a <crs_strlen>
 8017496:	b283      	uxth	r3, r0
 8017498:	4622      	mov	r2, r4
 801749a:	2110      	movs	r1, #16
 801749c:	2001      	movs	r0, #1
 801749e:	f007 ff87 	bl	801f3b0 <traceIF_itmPrint>
 80174a2:	4620      	mov	r0, r4
 80174a4:	f007 ff41 	bl	801f32a <crs_strlen>
 80174a8:	b283      	uxth	r3, r0
 80174aa:	4622      	mov	r2, r4
 80174ac:	2110      	movs	r1, #16
 80174ae:	2001      	movs	r0, #1
 80174b0:	f007 ffa0 	bl	801f3f4 <traceIF_uartPrint>
}
 80174b4:	4630      	mov	r0, r6
 80174b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (set cb)", sockHandle)
 80174ba:	4632      	mov	r2, r6
 80174bc:	4936      	ldr	r1, [pc, #216]	; (8017598 <CDS_socket_set_callbacks+0x1b8>)
 80174be:	4620      	mov	r0, r4
 80174c0:	f00f f9c2 	bl	8026848 <sprintf>
 80174c4:	4620      	mov	r0, r4
 80174c6:	f007 ff30 	bl	801f32a <crs_strlen>
 80174ca:	b283      	uxth	r3, r0
 80174cc:	4622      	mov	r2, r4
 80174ce:	2110      	movs	r1, #16
 80174d0:	2001      	movs	r0, #1
 80174d2:	f007 ff6d 	bl	801f3b0 <traceIF_itmPrint>
 80174d6:	4620      	mov	r0, r4
 80174d8:	f007 ff27 	bl	801f32a <crs_strlen>
 80174dc:	b283      	uxth	r3, r0
 80174de:	4622      	mov	r2, r4
 80174e0:	2110      	movs	r1, #16
 80174e2:	2001      	movs	r0, #1
 80174e4:	f007 ff86 	bl	801f3f4 <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 80174e8:	2601      	movs	r6, #1
 80174ea:	e7b8      	b.n	801745e <CDS_socket_set_callbacks+0x7e>
    PRINT_ERR("data_ready_cb is mandatory")
 80174ec:	4e2b      	ldr	r6, [pc, #172]	; (801759c <CDS_socket_set_callbacks+0x1bc>)
 80174ee:	4c27      	ldr	r4, [pc, #156]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 80174f0:	f106 0720 	add.w	r7, r6, #32
 80174f4:	4635      	mov	r5, r6
 80174f6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80174f8:	6020      	str	r0, [r4, #0]
 80174fa:	6061      	str	r1, [r4, #4]
 80174fc:	60a2      	str	r2, [r4, #8]
 80174fe:	60e3      	str	r3, [r4, #12]
 8017500:	462e      	mov	r6, r5
 8017502:	3410      	adds	r4, #16
 8017504:	42bd      	cmp	r5, r7
 8017506:	d1f5      	bne.n	80174f4 <CDS_socket_set_callbacks+0x114>
 8017508:	6828      	ldr	r0, [r5, #0]
 801750a:	6020      	str	r0, [r4, #0]
 801750c:	88ab      	ldrh	r3, [r5, #4]
 801750e:	80a3      	strh	r3, [r4, #4]
 8017510:	4c1e      	ldr	r4, [pc, #120]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 8017512:	4620      	mov	r0, r4
 8017514:	f007 ff09 	bl	801f32a <crs_strlen>
 8017518:	b283      	uxth	r3, r0
 801751a:	4622      	mov	r2, r4
 801751c:	2110      	movs	r1, #16
 801751e:	2001      	movs	r0, #1
 8017520:	f007 ff46 	bl	801f3b0 <traceIF_itmPrint>
 8017524:	4620      	mov	r0, r4
 8017526:	f007 ff00 	bl	801f32a <crs_strlen>
 801752a:	b283      	uxth	r3, r0
 801752c:	4622      	mov	r2, r4
 801752e:	2110      	movs	r1, #16
 8017530:	2001      	movs	r0, #1
 8017532:	f007 ff5f 	bl	801f3f4 <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 8017536:	2601      	movs	r6, #1
 8017538:	e791      	b.n	801745e <CDS_socket_set_callbacks+0x7e>
    PRINT_ERR("remote_close_cb is mandatory")
 801753a:	4e19      	ldr	r6, [pc, #100]	; (80175a0 <CDS_socket_set_callbacks+0x1c0>)
 801753c:	4c13      	ldr	r4, [pc, #76]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 801753e:	f106 0720 	add.w	r7, r6, #32
 8017542:	4635      	mov	r5, r6
 8017544:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017546:	6020      	str	r0, [r4, #0]
 8017548:	6061      	str	r1, [r4, #4]
 801754a:	60a2      	str	r2, [r4, #8]
 801754c:	60e3      	str	r3, [r4, #12]
 801754e:	462e      	mov	r6, r5
 8017550:	3410      	adds	r4, #16
 8017552:	42bd      	cmp	r5, r7
 8017554:	d1f5      	bne.n	8017542 <CDS_socket_set_callbacks+0x162>
 8017556:	ce03      	ldmia	r6!, {r0, r1}
 8017558:	6020      	str	r0, [r4, #0]
 801755a:	6061      	str	r1, [r4, #4]
 801755c:	4c0b      	ldr	r4, [pc, #44]	; (801758c <CDS_socket_set_callbacks+0x1ac>)
 801755e:	4620      	mov	r0, r4
 8017560:	f007 fee3 	bl	801f32a <crs_strlen>
 8017564:	b283      	uxth	r3, r0
 8017566:	4622      	mov	r2, r4
 8017568:	2110      	movs	r1, #16
 801756a:	2001      	movs	r0, #1
 801756c:	f007 ff20 	bl	801f3b0 <traceIF_itmPrint>
 8017570:	4620      	mov	r0, r4
 8017572:	f007 feda 	bl	801f32a <crs_strlen>
 8017576:	b283      	uxth	r3, r0
 8017578:	4622      	mov	r2, r4
 801757a:	2110      	movs	r1, #16
 801757c:	2001      	movs	r0, #1
 801757e:	f007 ff39 	bl	801f3f4 <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 8017582:	2601      	movs	r6, #1
 8017584:	e76b      	b.n	801745e <CDS_socket_set_callbacks+0x7e>
 8017586:	bf00      	nop
 8017588:	080329a4 	.word	0x080329a4
 801758c:	200047dc 	.word	0x200047dc
 8017590:	20003d18 	.word	0x20003d18
 8017594:	08032a5c 	.word	0x08032a5c
 8017598:	080329c8 	.word	0x080329c8
 801759c:	08032a0c 	.word	0x08032a0c
 80175a0:	08032a34 	.word	0x08032a34

080175a4 <CDS_socket_connect>:
{
 80175a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80175a8:	4606      	mov	r6, r0
 80175aa:	460f      	mov	r7, r1
 80175ac:	4690      	mov	r8, r2
 80175ae:	4699      	mov	r9, r3
  PRINT_API("CDS_socket_connect")
 80175b0:	4c39      	ldr	r4, [pc, #228]	; (8017698 <CDS_socket_connect+0xf4>)
 80175b2:	4d3a      	ldr	r5, [pc, #232]	; (801769c <CDS_socket_connect+0xf8>)
 80175b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80175b6:	6020      	str	r0, [r4, #0]
 80175b8:	6061      	str	r1, [r4, #4]
 80175ba:	60a2      	str	r2, [r4, #8]
 80175bc:	60e3      	str	r3, [r4, #12]
 80175be:	cd07      	ldmia	r5!, {r0, r1, r2}
 80175c0:	6120      	str	r0, [r4, #16]
 80175c2:	6161      	str	r1, [r4, #20]
 80175c4:	61a2      	str	r2, [r4, #24]
 80175c6:	4620      	mov	r0, r4
 80175c8:	f007 feaf 	bl	801f32a <crs_strlen>
 80175cc:	b283      	uxth	r3, r0
 80175ce:	4622      	mov	r2, r4
 80175d0:	2104      	movs	r1, #4
 80175d2:	2001      	movs	r0, #1
 80175d4:	f007 feec 	bl	801f3b0 <traceIF_itmPrint>
 80175d8:	4620      	mov	r0, r4
 80175da:	f007 fea6 	bl	801f32a <crs_strlen>
 80175de:	b283      	uxth	r3, r0
 80175e0:	4622      	mov	r2, r4
 80175e2:	2104      	movs	r1, #4
 80175e4:	2001      	movs	r0, #1
 80175e6:	f007 ff05 	bl	801f3f4 <traceIF_uartPrint>
  retval = csint_socket_configure_remote(sockHandle, ip_addr_type, p_ip_addr_value, remote_port);
 80175ea:	464b      	mov	r3, r9
 80175ec:	4642      	mov	r2, r8
 80175ee:	4639      	mov	r1, r7
 80175f0:	4630      	mov	r0, r6
 80175f2:	f003 f8b9 	bl	801a768 <csint_socket_configure_remote>
  if (retval == CELLULAR_OK)
 80175f6:	b108      	cbz	r0, 80175fc <CDS_socket_connect+0x58>
}
 80175f8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (DATAPACK_writePtr(&cmd_buf[0],
 80175fc:	226c      	movs	r2, #108	; 0x6c
 80175fe:	4b28      	ldr	r3, [pc, #160]	; (80176a0 <CDS_socket_connect+0xfc>)
 8017600:	fb02 3206 	mla	r2, r2, r6, r3
 8017604:	2118      	movs	r1, #24
 8017606:	4827      	ldr	r0, [pc, #156]	; (80176a4 <CDS_socket_connect+0x100>)
 8017608:	f7f4 fd24 	bl	800c054 <DATAPACK_writePtr>
 801760c:	2800      	cmp	r0, #0
 801760e:	d140      	bne.n	8017692 <CDS_socket_connect+0xee>
      if (socket_infos->trp_connect_mode == CS_CM_COMMAND_MODE)
 8017610:	4b23      	ldr	r3, [pc, #140]	; (80176a0 <CDS_socket_connect+0xfc>)
 8017612:	226c      	movs	r2, #108	; 0x6c
 8017614:	fb02 3306 	mla	r3, r2, r6, r3
 8017618:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
 801761c:	b97b      	cbnz	r3, 801763e <CDS_socket_connect+0x9a>
        err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_DIAL_COMMAND, &cmd_buf[0], &rsp_buf[0]);
 801761e:	4b22      	ldr	r3, [pc, #136]	; (80176a8 <CDS_socket_connect+0x104>)
 8017620:	4a20      	ldr	r2, [pc, #128]	; (80176a4 <CDS_socket_connect+0x100>)
 8017622:	2179      	movs	r1, #121	; 0x79
 8017624:	4821      	ldr	r0, [pc, #132]	; (80176ac <CDS_socket_connect+0x108>)
 8017626:	f9b0 0000 	ldrsh.w	r0, [r0]
 801762a:	f7f4 fadb 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 801762e:	b930      	cbnz	r0, 801763e <CDS_socket_connect+0x9a>
        cs_ctxt_sockets_info[sockHandle].state = SOCKETSTATE_CONNECTED;
 8017630:	4b1b      	ldr	r3, [pc, #108]	; (80176a0 <CDS_socket_connect+0xfc>)
 8017632:	226c      	movs	r2, #108	; 0x6c
 8017634:	fb02 3306 	mla	r3, r2, r6, r3
 8017638:	2202      	movs	r2, #2
 801763a:	711a      	strb	r2, [r3, #4]
        retval = CELLULAR_OK;
 801763c:	e7dc      	b.n	80175f8 <CDS_socket_connect+0x54>
        PRINT_ERR("<Cellular_Service> error when socket connection")
 801763e:	4d1c      	ldr	r5, [pc, #112]	; (80176b0 <CDS_socket_connect+0x10c>)
 8017640:	4c15      	ldr	r4, [pc, #84]	; (8017698 <CDS_socket_connect+0xf4>)
 8017642:	f105 0730 	add.w	r7, r5, #48	; 0x30
 8017646:	462e      	mov	r6, r5
 8017648:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801764a:	6020      	str	r0, [r4, #0]
 801764c:	6061      	str	r1, [r4, #4]
 801764e:	60a2      	str	r2, [r4, #8]
 8017650:	60e3      	str	r3, [r4, #12]
 8017652:	4635      	mov	r5, r6
 8017654:	3410      	adds	r4, #16
 8017656:	42be      	cmp	r6, r7
 8017658:	d1f5      	bne.n	8017646 <CDS_socket_connect+0xa2>
 801765a:	cd03      	ldmia	r5!, {r0, r1}
 801765c:	6020      	str	r0, [r4, #0]
 801765e:	6061      	str	r1, [r4, #4]
 8017660:	882a      	ldrh	r2, [r5, #0]
 8017662:	78ab      	ldrb	r3, [r5, #2]
 8017664:	8122      	strh	r2, [r4, #8]
 8017666:	72a3      	strb	r3, [r4, #10]
 8017668:	4c0b      	ldr	r4, [pc, #44]	; (8017698 <CDS_socket_connect+0xf4>)
 801766a:	4620      	mov	r0, r4
 801766c:	f007 fe5d 	bl	801f32a <crs_strlen>
 8017670:	b283      	uxth	r3, r0
 8017672:	4622      	mov	r2, r4
 8017674:	2110      	movs	r1, #16
 8017676:	2001      	movs	r0, #1
 8017678:	f007 fe9a 	bl	801f3b0 <traceIF_itmPrint>
 801767c:	4620      	mov	r0, r4
 801767e:	f007 fe54 	bl	801f32a <crs_strlen>
 8017682:	b283      	uxth	r3, r0
 8017684:	4622      	mov	r2, r4
 8017686:	2110      	movs	r1, #16
 8017688:	2001      	movs	r0, #1
 801768a:	f007 feb3 	bl	801f3f4 <traceIF_uartPrint>
        retval = CELLULAR_ERROR;
 801768e:	2001      	movs	r0, #1
 8017690:	e7b2      	b.n	80175f8 <CDS_socket_connect+0x54>
      retval = CELLULAR_ERROR;
 8017692:	2001      	movs	r0, #1
 8017694:	e7b0      	b.n	80175f8 <CDS_socket_connect+0x54>
 8017696:	bf00      	nop
 8017698:	200047dc 	.word	0x200047dc
 801769c:	08032a9c 	.word	0x08032a9c
 80176a0:	20003d18 	.word	0x20003d18
 80176a4:	20003620 	.word	0x20003620
 80176a8:	20003814 	.word	0x20003814
 80176ac:	2000361c 	.word	0x2000361c
 80176b0:	08032ab8 	.word	0x08032ab8

080176b4 <CDS_socket_send>:
{
 80176b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80176b6:	b097      	sub	sp, #92	; 0x5c
 80176b8:	4606      	mov	r6, r0
 80176ba:	460f      	mov	r7, r1
 80176bc:	4615      	mov	r5, r2
  PRINT_API("CDS_socket_send (buf@=%p - buflength = %ld)", p_buf, length)
 80176be:	4c5f      	ldr	r4, [pc, #380]	; (801783c <CDS_socket_send+0x188>)
 80176c0:	4613      	mov	r3, r2
 80176c2:	460a      	mov	r2, r1
 80176c4:	495e      	ldr	r1, [pc, #376]	; (8017840 <CDS_socket_send+0x18c>)
 80176c6:	4620      	mov	r0, r4
 80176c8:	f00f f8be 	bl	8026848 <sprintf>
 80176cc:	4620      	mov	r0, r4
 80176ce:	f007 fe2c 	bl	801f32a <crs_strlen>
 80176d2:	b283      	uxth	r3, r0
 80176d4:	4622      	mov	r2, r4
 80176d6:	2104      	movs	r1, #4
 80176d8:	2001      	movs	r0, #1
 80176da:	f007 fe69 	bl	801f3b0 <traceIF_itmPrint>
 80176de:	4620      	mov	r0, r4
 80176e0:	f007 fe23 	bl	801f32a <crs_strlen>
 80176e4:	b283      	uxth	r3, r0
 80176e6:	4622      	mov	r2, r4
 80176e8:	2104      	movs	r1, #4
 80176ea:	2001      	movs	r0, #1
 80176ec:	f007 fe82 	bl	801f3f4 <traceIF_uartPrint>
  if (length > DEFAULT_IP_MAX_PACKET_SIZE)
 80176f0:	f240 53dc 	movw	r3, #1500	; 0x5dc
 80176f4:	429d      	cmp	r5, r3
 80176f6:	d844      	bhi.n	8017782 <CDS_socket_send+0xce>
  else if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CONNECTED)
 80176f8:	4b52      	ldr	r3, [pc, #328]	; (8017844 <CDS_socket_send+0x190>)
 80176fa:	226c      	movs	r2, #108	; 0x6c
 80176fc:	fb02 3306 	mla	r3, r2, r6, r3
 8017700:	791a      	ldrb	r2, [r3, #4]
 8017702:	2a02      	cmp	r2, #2
 8017704:	d055      	beq.n	80177b2 <CDS_socket_send+0xfe>
    PRINT_ERR("<Cellular_Service> socket not connected (state=%d) for handle %ld (send)",
 8017706:	4c4d      	ldr	r4, [pc, #308]	; (801783c <CDS_socket_send+0x188>)
 8017708:	4633      	mov	r3, r6
 801770a:	494f      	ldr	r1, [pc, #316]	; (8017848 <CDS_socket_send+0x194>)
 801770c:	4620      	mov	r0, r4
 801770e:	f00f f89b 	bl	8026848 <sprintf>
 8017712:	4620      	mov	r0, r4
 8017714:	f007 fe09 	bl	801f32a <crs_strlen>
 8017718:	b283      	uxth	r3, r0
 801771a:	4622      	mov	r2, r4
 801771c:	2110      	movs	r1, #16
 801771e:	2001      	movs	r0, #1
 8017720:	f007 fe46 	bl	801f3b0 <traceIF_itmPrint>
 8017724:	4620      	mov	r0, r4
 8017726:	f007 fe00 	bl	801f32a <crs_strlen>
 801772a:	b283      	uxth	r3, r0
 801772c:	4622      	mov	r2, r4
 801772e:	2110      	movs	r1, #16
 8017730:	2001      	movs	r0, #1
 8017732:	f007 fe5f 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when sending data to socket")
 8017736:	4d45      	ldr	r5, [pc, #276]	; (801784c <CDS_socket_send+0x198>)
 8017738:	4c40      	ldr	r4, [pc, #256]	; (801783c <CDS_socket_send+0x188>)
 801773a:	f105 0640 	add.w	r6, r5, #64	; 0x40
 801773e:	46ac      	mov	ip, r5
 8017740:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017744:	6020      	str	r0, [r4, #0]
 8017746:	6061      	str	r1, [r4, #4]
 8017748:	60a2      	str	r2, [r4, #8]
 801774a:	60e3      	str	r3, [r4, #12]
 801774c:	4665      	mov	r5, ip
 801774e:	3410      	adds	r4, #16
 8017750:	45b4      	cmp	ip, r6
 8017752:	d1f4      	bne.n	801773e <CDS_socket_send+0x8a>
 8017754:	4c39      	ldr	r4, [pc, #228]	; (801783c <CDS_socket_send+0x188>)
 8017756:	4620      	mov	r0, r4
 8017758:	f007 fde7 	bl	801f32a <crs_strlen>
 801775c:	b283      	uxth	r3, r0
 801775e:	4622      	mov	r2, r4
 8017760:	2110      	movs	r1, #16
 8017762:	2001      	movs	r0, #1
 8017764:	f007 fe24 	bl	801f3b0 <traceIF_itmPrint>
 8017768:	4620      	mov	r0, r4
 801776a:	f007 fdde 	bl	801f32a <crs_strlen>
 801776e:	b283      	uxth	r3, r0
 8017770:	4622      	mov	r2, r4
 8017772:	2110      	movs	r1, #16
 8017774:	2001      	movs	r0, #1
 8017776:	f007 fe3d 	bl	801f3f4 <traceIF_uartPrint>
 801777a:	2401      	movs	r4, #1
}
 801777c:	4620      	mov	r0, r4
 801777e:	b017      	add	sp, #92	; 0x5c
 8017780:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PRINT_ERR("<Cellular_Service> buffer size %ld exceed maximum value %d",
 8017782:	462a      	mov	r2, r5
 8017784:	4932      	ldr	r1, [pc, #200]	; (8017850 <CDS_socket_send+0x19c>)
 8017786:	4620      	mov	r0, r4
 8017788:	f00f f85e 	bl	8026848 <sprintf>
 801778c:	4620      	mov	r0, r4
 801778e:	f007 fdcc 	bl	801f32a <crs_strlen>
 8017792:	b283      	uxth	r3, r0
 8017794:	4622      	mov	r2, r4
 8017796:	2110      	movs	r1, #16
 8017798:	2001      	movs	r0, #1
 801779a:	f007 fe09 	bl	801f3b0 <traceIF_itmPrint>
 801779e:	4620      	mov	r0, r4
 80177a0:	f007 fdc3 	bl	801f32a <crs_strlen>
 80177a4:	b283      	uxth	r3, r0
 80177a6:	4622      	mov	r2, r4
 80177a8:	2110      	movs	r1, #16
 80177aa:	2001      	movs	r0, #1
 80177ac:	f007 fe22 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80177b0:	e7c1      	b.n	8017736 <CDS_socket_send+0x82>
    (void) memset((void *)&send_data_struct, 0, sizeof(csint_socket_data_buffer_t));
 80177b2:	2458      	movs	r4, #88	; 0x58
 80177b4:	4622      	mov	r2, r4
 80177b6:	2100      	movs	r1, #0
 80177b8:	4668      	mov	r0, sp
 80177ba:	f00f f8b8 	bl	802692e <memset>
    send_data_struct.socket_handle = sockHandle;
 80177be:	9600      	str	r6, [sp, #0]
    send_data_struct.p_buffer_addr_send = p_buf;
 80177c0:	9701      	str	r7, [sp, #4]
    send_data_struct.buffer_size = length;
 80177c2:	9503      	str	r5, [sp, #12]
    send_data_struct.max_buffer_size = length;
 80177c4:	9504      	str	r5, [sp, #16]
    if (DATAPACK_writeStruct(&cmd_buf[0],
 80177c6:	466b      	mov	r3, sp
 80177c8:	4622      	mov	r2, r4
 80177ca:	2119      	movs	r1, #25
 80177cc:	4821      	ldr	r0, [pc, #132]	; (8017854 <CDS_socket_send+0x1a0>)
 80177ce:	f7f4 fc71 	bl	800c0b4 <DATAPACK_writeStruct>
 80177d2:	2800      	cmp	r0, #0
 80177d4:	d1af      	bne.n	8017736 <CDS_socket_send+0x82>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SEND_DATA, &cmd_buf[0], &rsp_buf[0]);
 80177d6:	4b20      	ldr	r3, [pc, #128]	; (8017858 <CDS_socket_send+0x1a4>)
 80177d8:	4a1e      	ldr	r2, [pc, #120]	; (8017854 <CDS_socket_send+0x1a0>)
 80177da:	217a      	movs	r1, #122	; 0x7a
 80177dc:	481f      	ldr	r0, [pc, #124]	; (801785c <CDS_socket_send+0x1a8>)
 80177de:	f9b0 0000 	ldrsh.w	r0, [r0]
 80177e2:	f7f4 f9ff 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 80177e6:	4604      	mov	r4, r0
 80177e8:	2800      	cmp	r0, #0
 80177ea:	d1a4      	bne.n	8017736 <CDS_socket_send+0x82>
        PRINT_DBG("<Cellular_Service> socket data sent")
 80177ec:	4e1c      	ldr	r6, [pc, #112]	; (8017860 <CDS_socket_send+0x1ac>)
 80177ee:	4d13      	ldr	r5, [pc, #76]	; (801783c <CDS_socket_send+0x188>)
 80177f0:	f106 0c20 	add.w	ip, r6, #32
 80177f4:	4637      	mov	r7, r6
 80177f6:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80177f8:	6028      	str	r0, [r5, #0]
 80177fa:	6069      	str	r1, [r5, #4]
 80177fc:	60aa      	str	r2, [r5, #8]
 80177fe:	60eb      	str	r3, [r5, #12]
 8017800:	463e      	mov	r6, r7
 8017802:	3510      	adds	r5, #16
 8017804:	4567      	cmp	r7, ip
 8017806:	d1f5      	bne.n	80177f4 <CDS_socket_send+0x140>
 8017808:	ce03      	ldmia	r6!, {r0, r1}
 801780a:	6028      	str	r0, [r5, #0]
 801780c:	6069      	str	r1, [r5, #4]
 801780e:	7833      	ldrb	r3, [r6, #0]
 8017810:	722b      	strb	r3, [r5, #8]
 8017812:	4d0a      	ldr	r5, [pc, #40]	; (801783c <CDS_socket_send+0x188>)
 8017814:	4628      	mov	r0, r5
 8017816:	f007 fd88 	bl	801f32a <crs_strlen>
 801781a:	b283      	uxth	r3, r0
 801781c:	462a      	mov	r2, r5
 801781e:	2102      	movs	r1, #2
 8017820:	2001      	movs	r0, #1
 8017822:	f007 fdc5 	bl	801f3b0 <traceIF_itmPrint>
 8017826:	4628      	mov	r0, r5
 8017828:	f007 fd7f 	bl	801f32a <crs_strlen>
 801782c:	b283      	uxth	r3, r0
 801782e:	462a      	mov	r2, r5
 8017830:	2102      	movs	r1, #2
 8017832:	2001      	movs	r0, #1
 8017834:	f007 fdde 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017838:	e7a0      	b.n	801777c <CDS_socket_send+0xc8>
 801783a:	bf00      	nop
 801783c:	200047dc 	.word	0x200047dc
 8017840:	08032af4 	.word	0x08032af4
 8017844:	20003d18 	.word	0x20003d18
 8017848:	08032b74 	.word	0x08032b74
 801784c:	08032bf4 	.word	0x08032bf4
 8017850:	08032b2c 	.word	0x08032b2c
 8017854:	20003620 	.word	0x20003620
 8017858:	20003814 	.word	0x20003814
 801785c:	2000361c 	.word	0x2000361c
 8017860:	08032bc8 	.word	0x08032bc8

08017864 <CDS_socket_sendto>:
{
 8017864:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8017868:	b097      	sub	sp, #92	; 0x5c
 801786a:	4606      	mov	r6, r0
 801786c:	460f      	mov	r7, r1
 801786e:	4615      	mov	r5, r2
 8017870:	4698      	mov	r8, r3
  PRINT_API("CDS_socket_send (buf@=%p - buflength = %ld)", p_buf, length)
 8017872:	4c8b      	ldr	r4, [pc, #556]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017874:	4613      	mov	r3, r2
 8017876:	460a      	mov	r2, r1
 8017878:	498a      	ldr	r1, [pc, #552]	; (8017aa4 <CDS_socket_sendto+0x240>)
 801787a:	4620      	mov	r0, r4
 801787c:	f00e ffe4 	bl	8026848 <sprintf>
 8017880:	4620      	mov	r0, r4
 8017882:	f007 fd52 	bl	801f32a <crs_strlen>
 8017886:	b283      	uxth	r3, r0
 8017888:	4622      	mov	r2, r4
 801788a:	2104      	movs	r1, #4
 801788c:	2001      	movs	r0, #1
 801788e:	f007 fd8f 	bl	801f3b0 <traceIF_itmPrint>
 8017892:	4620      	mov	r0, r4
 8017894:	f007 fd49 	bl	801f32a <crs_strlen>
 8017898:	b283      	uxth	r3, r0
 801789a:	4622      	mov	r2, r4
 801789c:	2104      	movs	r1, #4
 801789e:	2001      	movs	r0, #1
 80178a0:	f007 fda8 	bl	801f3f4 <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CONNECTED)
 80178a4:	4a80      	ldr	r2, [pc, #512]	; (8017aa8 <CDS_socket_sendto+0x244>)
 80178a6:	236c      	movs	r3, #108	; 0x6c
 80178a8:	fb03 2206 	mla	r2, r3, r6, r2
 80178ac:	7912      	ldrb	r2, [r2, #4]
 80178ae:	2a02      	cmp	r2, #2
 80178b0:	d131      	bne.n	8017916 <CDS_socket_sendto+0xb2>
  else if (length > DEFAULT_IP_MAX_PACKET_SIZE)
 80178b2:	f240 53dc 	movw	r3, #1500	; 0x5dc
 80178b6:	429d      	cmp	r5, r3
 80178b8:	d861      	bhi.n	801797e <CDS_socket_sendto+0x11a>
  else if (p_ip_addr_value == NULL)
 80178ba:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80178bc:	2b00      	cmp	r3, #0
 80178be:	d077      	beq.n	80179b0 <CDS_socket_sendto+0x14c>
    ip_addr_length = strlen((const CRC_CHAR_t *)p_ip_addr_value);
 80178c0:	981e      	ldr	r0, [sp, #120]	; 0x78
 80178c2:	f7e8 fc97 	bl	80001f4 <strlen>
 80178c6:	4604      	mov	r4, r0
    if (ip_addr_length > MAX_IP_ADDR_SIZE)
 80178c8:	2840      	cmp	r0, #64	; 0x40
 80178ca:	f240 8099 	bls.w	8017a00 <CDS_socket_sendto+0x19c>
      PRINT_ERR("<Cellular_Service> IP address too long")
 80178ce:	4e77      	ldr	r6, [pc, #476]	; (8017aac <CDS_socket_sendto+0x248>)
 80178d0:	4d73      	ldr	r5, [pc, #460]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80178d2:	f106 0730 	add.w	r7, r6, #48	; 0x30
 80178d6:	4634      	mov	r4, r6
 80178d8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80178da:	6028      	str	r0, [r5, #0]
 80178dc:	6069      	str	r1, [r5, #4]
 80178de:	60aa      	str	r2, [r5, #8]
 80178e0:	60eb      	str	r3, [r5, #12]
 80178e2:	4626      	mov	r6, r4
 80178e4:	3510      	adds	r5, #16
 80178e6:	42bc      	cmp	r4, r7
 80178e8:	d1f5      	bne.n	80178d6 <CDS_socket_sendto+0x72>
 80178ea:	8823      	ldrh	r3, [r4, #0]
 80178ec:	802b      	strh	r3, [r5, #0]
 80178ee:	4c6c      	ldr	r4, [pc, #432]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80178f0:	4620      	mov	r0, r4
 80178f2:	f007 fd1a 	bl	801f32a <crs_strlen>
 80178f6:	b283      	uxth	r3, r0
 80178f8:	4622      	mov	r2, r4
 80178fa:	2110      	movs	r1, #16
 80178fc:	2001      	movs	r0, #1
 80178fe:	f007 fd57 	bl	801f3b0 <traceIF_itmPrint>
 8017902:	4620      	mov	r0, r4
 8017904:	f007 fd11 	bl	801f32a <crs_strlen>
 8017908:	b283      	uxth	r3, r0
 801790a:	4622      	mov	r2, r4
 801790c:	2110      	movs	r1, #16
 801790e:	2001      	movs	r0, #1
 8017910:	f007 fd70 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017914:	e016      	b.n	8017944 <CDS_socket_sendto+0xe0>
    PRINT_ERR("<Cellular_Service> socket not connected (state=%d) for handle %ld (send)",
 8017916:	4633      	mov	r3, r6
 8017918:	4965      	ldr	r1, [pc, #404]	; (8017ab0 <CDS_socket_sendto+0x24c>)
 801791a:	4620      	mov	r0, r4
 801791c:	f00e ff94 	bl	8026848 <sprintf>
 8017920:	4620      	mov	r0, r4
 8017922:	f007 fd02 	bl	801f32a <crs_strlen>
 8017926:	b283      	uxth	r3, r0
 8017928:	4622      	mov	r2, r4
 801792a:	2110      	movs	r1, #16
 801792c:	2001      	movs	r0, #1
 801792e:	f007 fd3f 	bl	801f3b0 <traceIF_itmPrint>
 8017932:	4620      	mov	r0, r4
 8017934:	f007 fcf9 	bl	801f32a <crs_strlen>
 8017938:	b283      	uxth	r3, r0
 801793a:	4622      	mov	r2, r4
 801793c:	2110      	movs	r1, #16
 801793e:	2001      	movs	r0, #1
 8017940:	f007 fd58 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when sending data to socket (sendto)")
 8017944:	4c56      	ldr	r4, [pc, #344]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017946:	2249      	movs	r2, #73	; 0x49
 8017948:	495a      	ldr	r1, [pc, #360]	; (8017ab4 <CDS_socket_sendto+0x250>)
 801794a:	4620      	mov	r0, r4
 801794c:	f00f f8cc 	bl	8026ae8 <memcpy>
 8017950:	4620      	mov	r0, r4
 8017952:	f007 fcea 	bl	801f32a <crs_strlen>
 8017956:	b283      	uxth	r3, r0
 8017958:	4622      	mov	r2, r4
 801795a:	2110      	movs	r1, #16
 801795c:	2001      	movs	r0, #1
 801795e:	f007 fd27 	bl	801f3b0 <traceIF_itmPrint>
 8017962:	4620      	mov	r0, r4
 8017964:	f007 fce1 	bl	801f32a <crs_strlen>
 8017968:	b283      	uxth	r3, r0
 801796a:	4622      	mov	r2, r4
 801796c:	2110      	movs	r1, #16
 801796e:	2001      	movs	r0, #1
 8017970:	f007 fd40 	bl	801f3f4 <traceIF_uartPrint>
 8017974:	2401      	movs	r4, #1
}
 8017976:	4620      	mov	r0, r4
 8017978:	b017      	add	sp, #92	; 0x5c
 801797a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("<Cellular_Service> buffer size %ld exceed maximum value %d",
 801797e:	4c48      	ldr	r4, [pc, #288]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017980:	462a      	mov	r2, r5
 8017982:	494d      	ldr	r1, [pc, #308]	; (8017ab8 <CDS_socket_sendto+0x254>)
 8017984:	4620      	mov	r0, r4
 8017986:	f00e ff5f 	bl	8026848 <sprintf>
 801798a:	4620      	mov	r0, r4
 801798c:	f007 fccd 	bl	801f32a <crs_strlen>
 8017990:	b283      	uxth	r3, r0
 8017992:	4622      	mov	r2, r4
 8017994:	2110      	movs	r1, #16
 8017996:	2001      	movs	r0, #1
 8017998:	f007 fd0a 	bl	801f3b0 <traceIF_itmPrint>
 801799c:	4620      	mov	r0, r4
 801799e:	f007 fcc4 	bl	801f32a <crs_strlen>
 80179a2:	b283      	uxth	r3, r0
 80179a4:	4622      	mov	r2, r4
 80179a6:	2110      	movs	r1, #16
 80179a8:	2001      	movs	r0, #1
 80179aa:	f007 fd23 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80179ae:	e7c9      	b.n	8017944 <CDS_socket_sendto+0xe0>
    PRINT_ERR("<Cellular_Service> NULL ptr")
 80179b0:	4e42      	ldr	r6, [pc, #264]	; (8017abc <CDS_socket_sendto+0x258>)
 80179b2:	4c3b      	ldr	r4, [pc, #236]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80179b4:	f106 0720 	add.w	r7, r6, #32
 80179b8:	4635      	mov	r5, r6
 80179ba:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80179bc:	6020      	str	r0, [r4, #0]
 80179be:	6061      	str	r1, [r4, #4]
 80179c0:	60a2      	str	r2, [r4, #8]
 80179c2:	60e3      	str	r3, [r4, #12]
 80179c4:	462e      	mov	r6, r5
 80179c6:	3410      	adds	r4, #16
 80179c8:	42bd      	cmp	r5, r7
 80179ca:	d1f5      	bne.n	80179b8 <CDS_socket_sendto+0x154>
 80179cc:	6828      	ldr	r0, [r5, #0]
 80179ce:	6020      	str	r0, [r4, #0]
 80179d0:	88aa      	ldrh	r2, [r5, #4]
 80179d2:	79ab      	ldrb	r3, [r5, #6]
 80179d4:	80a2      	strh	r2, [r4, #4]
 80179d6:	71a3      	strb	r3, [r4, #6]
 80179d8:	4c31      	ldr	r4, [pc, #196]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 80179da:	4620      	mov	r0, r4
 80179dc:	f007 fca5 	bl	801f32a <crs_strlen>
 80179e0:	b283      	uxth	r3, r0
 80179e2:	4622      	mov	r2, r4
 80179e4:	2110      	movs	r1, #16
 80179e6:	2001      	movs	r0, #1
 80179e8:	f007 fce2 	bl	801f3b0 <traceIF_itmPrint>
 80179ec:	4620      	mov	r0, r4
 80179ee:	f007 fc9c 	bl	801f32a <crs_strlen>
 80179f2:	b283      	uxth	r3, r0
 80179f4:	4622      	mov	r2, r4
 80179f6:	2110      	movs	r1, #16
 80179f8:	2001      	movs	r0, #1
 80179fa:	f007 fcfb 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 80179fe:	e7a1      	b.n	8017944 <CDS_socket_sendto+0xe0>
      (void) memset((void *)&send_data_struct, 0, sizeof(csint_socket_data_buffer_t));
 8017a00:	f04f 0958 	mov.w	r9, #88	; 0x58
 8017a04:	464a      	mov	r2, r9
 8017a06:	2100      	movs	r1, #0
 8017a08:	4668      	mov	r0, sp
 8017a0a:	f00e ff90 	bl	802692e <memset>
      send_data_struct.socket_handle = sockHandle;
 8017a0e:	9600      	str	r6, [sp, #0]
      send_data_struct.p_buffer_addr_send = p_buf;
 8017a10:	9701      	str	r7, [sp, #4]
      send_data_struct.buffer_size = length;
 8017a12:	9503      	str	r5, [sp, #12]
      send_data_struct.max_buffer_size = length;
 8017a14:	9504      	str	r5, [sp, #16]
      send_data_struct.ip_addr_type = ip_addr_type;
 8017a16:	f88d 8014 	strb.w	r8, [sp, #20]
      (void) memcpy((void *)send_data_struct.ip_addr_value,
 8017a1a:	4622      	mov	r2, r4
 8017a1c:	991e      	ldr	r1, [sp, #120]	; 0x78
 8017a1e:	f10d 0015 	add.w	r0, sp, #21
 8017a22:	f00f f861 	bl	8026ae8 <memcpy>
      send_data_struct.remote_port = remote_port;
 8017a26:	f8bd 307c 	ldrh.w	r3, [sp, #124]	; 0x7c
 8017a2a:	f8ad 3056 	strh.w	r3, [sp, #86]	; 0x56
      if (DATAPACK_writeStruct(&cmd_buf[0],
 8017a2e:	466b      	mov	r3, sp
 8017a30:	464a      	mov	r2, r9
 8017a32:	2119      	movs	r1, #25
 8017a34:	4822      	ldr	r0, [pc, #136]	; (8017ac0 <CDS_socket_sendto+0x25c>)
 8017a36:	f7f4 fb3d 	bl	800c0b4 <DATAPACK_writeStruct>
 8017a3a:	2800      	cmp	r0, #0
 8017a3c:	d182      	bne.n	8017944 <CDS_socket_sendto+0xe0>
        err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SEND_DATA, &cmd_buf[0], &rsp_buf[0]);
 8017a3e:	4b21      	ldr	r3, [pc, #132]	; (8017ac4 <CDS_socket_sendto+0x260>)
 8017a40:	4a1f      	ldr	r2, [pc, #124]	; (8017ac0 <CDS_socket_sendto+0x25c>)
 8017a42:	217a      	movs	r1, #122	; 0x7a
 8017a44:	4820      	ldr	r0, [pc, #128]	; (8017ac8 <CDS_socket_sendto+0x264>)
 8017a46:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017a4a:	f7f4 f8cb 	bl	800bbe4 <AT_sendcmd>
        if (err == ATSTATUS_OK)
 8017a4e:	4604      	mov	r4, r0
 8017a50:	2800      	cmp	r0, #0
 8017a52:	f47f af77 	bne.w	8017944 <CDS_socket_sendto+0xe0>
          PRINT_DBG("<Cellular_Service> socket data sent (sendto)")
 8017a56:	4f1d      	ldr	r7, [pc, #116]	; (8017acc <CDS_socket_sendto+0x268>)
 8017a58:	4e11      	ldr	r6, [pc, #68]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017a5a:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8017a5e:	463d      	mov	r5, r7
 8017a60:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017a62:	6030      	str	r0, [r6, #0]
 8017a64:	6071      	str	r1, [r6, #4]
 8017a66:	60b2      	str	r2, [r6, #8]
 8017a68:	60f3      	str	r3, [r6, #12]
 8017a6a:	462f      	mov	r7, r5
 8017a6c:	3610      	adds	r6, #16
 8017a6e:	4565      	cmp	r5, ip
 8017a70:	d1f5      	bne.n	8017a5e <CDS_socket_sendto+0x1fa>
 8017a72:	882b      	ldrh	r3, [r5, #0]
 8017a74:	8033      	strh	r3, [r6, #0]
 8017a76:	4d0a      	ldr	r5, [pc, #40]	; (8017aa0 <CDS_socket_sendto+0x23c>)
 8017a78:	4628      	mov	r0, r5
 8017a7a:	f007 fc56 	bl	801f32a <crs_strlen>
 8017a7e:	b283      	uxth	r3, r0
 8017a80:	462a      	mov	r2, r5
 8017a82:	2102      	movs	r1, #2
 8017a84:	2001      	movs	r0, #1
 8017a86:	f007 fc93 	bl	801f3b0 <traceIF_itmPrint>
 8017a8a:	4628      	mov	r0, r5
 8017a8c:	f007 fc4d 	bl	801f32a <crs_strlen>
 8017a90:	b283      	uxth	r3, r0
 8017a92:	462a      	mov	r2, r5
 8017a94:	2102      	movs	r1, #2
 8017a96:	2001      	movs	r0, #1
 8017a98:	f007 fcac 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017a9c:	e76b      	b.n	8017976 <CDS_socket_sendto+0x112>
 8017a9e:	bf00      	nop
 8017aa0:	200047dc 	.word	0x200047dc
 8017aa4:	08032af4 	.word	0x08032af4
 8017aa8:	20003d18 	.word	0x20003d18
 8017aac:	08032c5c 	.word	0x08032c5c
 8017ab0:	08032b74 	.word	0x08032b74
 8017ab4:	08032cc4 	.word	0x08032cc4
 8017ab8:	08032b2c 	.word	0x08032b2c
 8017abc:	08032c34 	.word	0x08032c34
 8017ac0:	20003620 	.word	0x20003620
 8017ac4:	20003814 	.word	0x20003814
 8017ac8:	2000361c 	.word	0x2000361c
 8017acc:	08032c90 	.word	0x08032c90

08017ad0 <CDS_socket_receive>:
{
 8017ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017ad4:	b098      	sub	sp, #96	; 0x60
 8017ad6:	4606      	mov	r6, r0
 8017ad8:	4688      	mov	r8, r1
 8017ada:	4617      	mov	r7, r2
  uint32_t bytes_received = 0U;
 8017adc:	2300      	movs	r3, #0
 8017ade:	9317      	str	r3, [sp, #92]	; 0x5c
  PRINT_API("CDS_socket_receive")
 8017ae0:	4c67      	ldr	r4, [pc, #412]	; (8017c80 <CDS_socket_receive+0x1b0>)
 8017ae2:	4d68      	ldr	r5, [pc, #416]	; (8017c84 <CDS_socket_receive+0x1b4>)
 8017ae4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017ae6:	6020      	str	r0, [r4, #0]
 8017ae8:	6061      	str	r1, [r4, #4]
 8017aea:	60a2      	str	r2, [r4, #8]
 8017aec:	60e3      	str	r3, [r4, #12]
 8017aee:	cd07      	ldmia	r5!, {r0, r1, r2}
 8017af0:	6120      	str	r0, [r4, #16]
 8017af2:	6161      	str	r1, [r4, #20]
 8017af4:	61a2      	str	r2, [r4, #24]
 8017af6:	4620      	mov	r0, r4
 8017af8:	f007 fc17 	bl	801f32a <crs_strlen>
 8017afc:	b283      	uxth	r3, r0
 8017afe:	4622      	mov	r2, r4
 8017b00:	2104      	movs	r1, #4
 8017b02:	2001      	movs	r0, #1
 8017b04:	f007 fc54 	bl	801f3b0 <traceIF_itmPrint>
 8017b08:	4620      	mov	r0, r4
 8017b0a:	f007 fc0e 	bl	801f32a <crs_strlen>
 8017b0e:	b283      	uxth	r3, r0
 8017b10:	4622      	mov	r2, r4
 8017b12:	2104      	movs	r1, #4
 8017b14:	2001      	movs	r0, #1
 8017b16:	f007 fc6d 	bl	801f3f4 <traceIF_uartPrint>
  if (max_buf_length > DEFAULT_IP_MAX_PACKET_SIZE)
 8017b1a:	f240 53dc 	movw	r3, #1500	; 0x5dc
 8017b1e:	429f      	cmp	r7, r3
 8017b20:	d862      	bhi.n	8017be8 <CDS_socket_receive+0x118>
  else if (cs_ctxt_sockets_info[sockHandle].state != SOCKETSTATE_CONNECTED)
 8017b22:	4b59      	ldr	r3, [pc, #356]	; (8017c88 <CDS_socket_receive+0x1b8>)
 8017b24:	226c      	movs	r2, #108	; 0x6c
 8017b26:	fb02 3306 	mla	r3, r2, r6, r3
 8017b2a:	791a      	ldrb	r2, [r3, #4]
 8017b2c:	2a02      	cmp	r2, #2
 8017b2e:	d173      	bne.n	8017c18 <CDS_socket_receive+0x148>
    csint_socket_data_buffer_t receive_data_struct = {0};
 8017b30:	2458      	movs	r4, #88	; 0x58
 8017b32:	4622      	mov	r2, r4
 8017b34:	2100      	movs	r1, #0
 8017b36:	a801      	add	r0, sp, #4
 8017b38:	f00e fef9 	bl	802692e <memset>
    (void) memset((void *)&receive_data_struct, 0, sizeof(csint_socket_data_buffer_t));
 8017b3c:	4622      	mov	r2, r4
 8017b3e:	2100      	movs	r1, #0
 8017b40:	a801      	add	r0, sp, #4
 8017b42:	f00e fef4 	bl	802692e <memset>
    receive_data_struct.socket_handle = sockHandle;
 8017b46:	9601      	str	r6, [sp, #4]
    receive_data_struct.p_buffer_addr_rcv = p_buf;
 8017b48:	f8cd 800c 	str.w	r8, [sp, #12]
    receive_data_struct.max_buffer_size = max_buf_length;
 8017b4c:	9705      	str	r7, [sp, #20]
    if (DATAPACK_writeStruct(&cmd_buf[0],
 8017b4e:	ab01      	add	r3, sp, #4
 8017b50:	4622      	mov	r2, r4
 8017b52:	2119      	movs	r1, #25
 8017b54:	484d      	ldr	r0, [pc, #308]	; (8017c8c <CDS_socket_receive+0x1bc>)
 8017b56:	f7f4 faad 	bl	800c0b4 <DATAPACK_writeStruct>
 8017b5a:	2800      	cmp	r0, #0
 8017b5c:	d174      	bne.n	8017c48 <CDS_socket_receive+0x178>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_RECEIVE_DATA, &cmd_buf[0], &rsp_buf[0]);
 8017b5e:	4b4c      	ldr	r3, [pc, #304]	; (8017c90 <CDS_socket_receive+0x1c0>)
 8017b60:	4a4a      	ldr	r2, [pc, #296]	; (8017c8c <CDS_socket_receive+0x1bc>)
 8017b62:	217b      	movs	r1, #123	; 0x7b
 8017b64:	484b      	ldr	r0, [pc, #300]	; (8017c94 <CDS_socket_receive+0x1c4>)
 8017b66:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017b6a:	f7f4 f83b 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017b6e:	2800      	cmp	r0, #0
 8017b70:	d16a      	bne.n	8017c48 <CDS_socket_receive+0x178>
        if (DATAPACK_readStruct(&rsp_buf[0],
 8017b72:	ab17      	add	r3, sp, #92	; 0x5c
 8017b74:	2204      	movs	r2, #4
 8017b76:	211a      	movs	r1, #26
 8017b78:	4845      	ldr	r0, [pc, #276]	; (8017c90 <CDS_socket_receive+0x1c0>)
 8017b7a:	f7f4 fbbb 	bl	800c2f4 <DATAPACK_readStruct>
 8017b7e:	2800      	cmp	r0, #0
 8017b80:	d162      	bne.n	8017c48 <CDS_socket_receive+0x178>
    PRINT_INFO("Size of data received on the socket= %ld bytes", bytes_received)
 8017b82:	4c3f      	ldr	r4, [pc, #252]	; (8017c80 <CDS_socket_receive+0x1b0>)
 8017b84:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 8017b86:	4944      	ldr	r1, [pc, #272]	; (8017c98 <CDS_socket_receive+0x1c8>)
 8017b88:	4620      	mov	r0, r4
 8017b8a:	f00e fe5d 	bl	8026848 <sprintf>
 8017b8e:	4620      	mov	r0, r4
 8017b90:	f007 fbcb 	bl	801f32a <crs_strlen>
 8017b94:	b283      	uxth	r3, r0
 8017b96:	4622      	mov	r2, r4
 8017b98:	2101      	movs	r1, #1
 8017b9a:	4608      	mov	r0, r1
 8017b9c:	f007 fc08 	bl	801f3b0 <traceIF_itmPrint>
 8017ba0:	4620      	mov	r0, r4
 8017ba2:	f007 fbc2 	bl	801f32a <crs_strlen>
 8017ba6:	b283      	uxth	r3, r0
 8017ba8:	4622      	mov	r2, r4
 8017baa:	2101      	movs	r1, #1
 8017bac:	4608      	mov	r0, r1
 8017bae:	f007 fc21 	bl	801f3f4 <traceIF_uartPrint>
	PRINT_INFO("data received on the socket= %s", p_buf)
 8017bb2:	4642      	mov	r2, r8
 8017bb4:	4939      	ldr	r1, [pc, #228]	; (8017c9c <CDS_socket_receive+0x1cc>)
 8017bb6:	4620      	mov	r0, r4
 8017bb8:	f00e fe46 	bl	8026848 <sprintf>
 8017bbc:	4620      	mov	r0, r4
 8017bbe:	f007 fbb4 	bl	801f32a <crs_strlen>
 8017bc2:	b283      	uxth	r3, r0
 8017bc4:	4622      	mov	r2, r4
 8017bc6:	2101      	movs	r1, #1
 8017bc8:	4608      	mov	r0, r1
 8017bca:	f007 fbf1 	bl	801f3b0 <traceIF_itmPrint>
 8017bce:	4620      	mov	r0, r4
 8017bd0:	f007 fbab 	bl	801f32a <crs_strlen>
 8017bd4:	b283      	uxth	r3, r0
 8017bd6:	4622      	mov	r2, r4
 8017bd8:	2101      	movs	r1, #1
 8017bda:	4608      	mov	r0, r1
 8017bdc:	f007 fc0a 	bl	801f3f4 <traceIF_uartPrint>
    returned_data_size = ((int32_t)bytes_received);
 8017be0:	9817      	ldr	r0, [sp, #92]	; 0x5c
}
 8017be2:	b018      	add	sp, #96	; 0x60
 8017be4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    PRINT_ERR("<Cellular_Service> buffer size %ld exceed maximum value %d",
 8017be8:	463a      	mov	r2, r7
 8017bea:	492d      	ldr	r1, [pc, #180]	; (8017ca0 <CDS_socket_receive+0x1d0>)
 8017bec:	4620      	mov	r0, r4
 8017bee:	f00e fe2b 	bl	8026848 <sprintf>
 8017bf2:	4620      	mov	r0, r4
 8017bf4:	f007 fb99 	bl	801f32a <crs_strlen>
 8017bf8:	b283      	uxth	r3, r0
 8017bfa:	4622      	mov	r2, r4
 8017bfc:	2110      	movs	r1, #16
 8017bfe:	2001      	movs	r0, #1
 8017c00:	f007 fbd6 	bl	801f3b0 <traceIF_itmPrint>
 8017c04:	4620      	mov	r0, r4
 8017c06:	f007 fb90 	bl	801f32a <crs_strlen>
 8017c0a:	b283      	uxth	r3, r0
 8017c0c:	4622      	mov	r2, r4
 8017c0e:	2110      	movs	r1, #16
 8017c10:	2001      	movs	r0, #1
 8017c12:	f007 fbef 	bl	801f3f4 <traceIF_uartPrint>
  if (status == CELLULAR_ERROR)
 8017c16:	e017      	b.n	8017c48 <CDS_socket_receive+0x178>
    PRINT_ERR("<Cellular_Service> socket not connected (state=%d) for handle %ld (rcv)",
 8017c18:	4c19      	ldr	r4, [pc, #100]	; (8017c80 <CDS_socket_receive+0x1b0>)
 8017c1a:	4633      	mov	r3, r6
 8017c1c:	4921      	ldr	r1, [pc, #132]	; (8017ca4 <CDS_socket_receive+0x1d4>)
 8017c1e:	4620      	mov	r0, r4
 8017c20:	f00e fe12 	bl	8026848 <sprintf>
 8017c24:	4620      	mov	r0, r4
 8017c26:	f007 fb80 	bl	801f32a <crs_strlen>
 8017c2a:	b283      	uxth	r3, r0
 8017c2c:	4622      	mov	r2, r4
 8017c2e:	2110      	movs	r1, #16
 8017c30:	2001      	movs	r0, #1
 8017c32:	f007 fbbd 	bl	801f3b0 <traceIF_itmPrint>
 8017c36:	4620      	mov	r0, r4
 8017c38:	f007 fb77 	bl	801f32a <crs_strlen>
 8017c3c:	b283      	uxth	r3, r0
 8017c3e:	4622      	mov	r2, r4
 8017c40:	2110      	movs	r1, #16
 8017c42:	2001      	movs	r0, #1
 8017c44:	f007 fbd6 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when receiving data from socket")
 8017c48:	4c0d      	ldr	r4, [pc, #52]	; (8017c80 <CDS_socket_receive+0x1b0>)
 8017c4a:	2244      	movs	r2, #68	; 0x44
 8017c4c:	4916      	ldr	r1, [pc, #88]	; (8017ca8 <CDS_socket_receive+0x1d8>)
 8017c4e:	4620      	mov	r0, r4
 8017c50:	f00e ff4a 	bl	8026ae8 <memcpy>
 8017c54:	4620      	mov	r0, r4
 8017c56:	f007 fb68 	bl	801f32a <crs_strlen>
 8017c5a:	b283      	uxth	r3, r0
 8017c5c:	4622      	mov	r2, r4
 8017c5e:	2110      	movs	r1, #16
 8017c60:	2001      	movs	r0, #1
 8017c62:	f007 fba5 	bl	801f3b0 <traceIF_itmPrint>
 8017c66:	4620      	mov	r0, r4
 8017c68:	f007 fb5f 	bl	801f32a <crs_strlen>
 8017c6c:	b283      	uxth	r3, r0
 8017c6e:	4622      	mov	r2, r4
 8017c70:	2110      	movs	r1, #16
 8017c72:	2001      	movs	r0, #1
 8017c74:	f007 fbbe 	bl	801f3f4 <traceIF_uartPrint>
    returned_data_size = -1;
 8017c78:	f04f 30ff 	mov.w	r0, #4294967295
  return (returned_data_size);
 8017c7c:	e7b1      	b.n	8017be2 <CDS_socket_receive+0x112>
 8017c7e:	bf00      	nop
 8017c80:	200047dc 	.word	0x200047dc
 8017c84:	08032d10 	.word	0x08032d10
 8017c88:	20003d18 	.word	0x20003d18
 8017c8c:	20003620 	.word	0x20003620
 8017c90:	20003814 	.word	0x20003814
 8017c94:	2000361c 	.word	0x2000361c
 8017c98:	08032d80 	.word	0x08032d80
 8017c9c:	08032db4 	.word	0x08032db4
 8017ca0:	08032b2c 	.word	0x08032b2c
 8017ca4:	08032d2c 	.word	0x08032d2c
 8017ca8:	08032ddc 	.word	0x08032ddc

08017cac <CDS_socket_close>:
{
 8017cac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017cae:	4606      	mov	r6, r0
  PRINT_API("CDS_socket_close")
 8017cb0:	4c71      	ldr	r4, [pc, #452]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017cb2:	4d72      	ldr	r5, [pc, #456]	; (8017e7c <CDS_socket_close+0x1d0>)
 8017cb4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017cb6:	6020      	str	r0, [r4, #0]
 8017cb8:	6061      	str	r1, [r4, #4]
 8017cba:	60a2      	str	r2, [r4, #8]
 8017cbc:	60e3      	str	r3, [r4, #12]
 8017cbe:	cd03      	ldmia	r5!, {r0, r1}
 8017cc0:	6120      	str	r0, [r4, #16]
 8017cc2:	6161      	str	r1, [r4, #20]
 8017cc4:	882b      	ldrh	r3, [r5, #0]
 8017cc6:	8323      	strh	r3, [r4, #24]
 8017cc8:	4620      	mov	r0, r4
 8017cca:	f007 fb2e 	bl	801f32a <crs_strlen>
 8017cce:	b283      	uxth	r3, r0
 8017cd0:	4622      	mov	r2, r4
 8017cd2:	2104      	movs	r1, #4
 8017cd4:	2001      	movs	r0, #1
 8017cd6:	f007 fb6b 	bl	801f3b0 <traceIF_itmPrint>
 8017cda:	4620      	mov	r0, r4
 8017cdc:	f007 fb25 	bl	801f32a <crs_strlen>
 8017ce0:	b283      	uxth	r3, r0
 8017ce2:	4622      	mov	r2, r4
 8017ce4:	2104      	movs	r1, #4
 8017ce6:	2001      	movs	r0, #1
 8017ce8:	f007 fb84 	bl	801f3f4 <traceIF_uartPrint>
  if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_CONNECTED)
 8017cec:	4b64      	ldr	r3, [pc, #400]	; (8017e80 <CDS_socket_close+0x1d4>)
 8017cee:	226c      	movs	r2, #108	; 0x6c
 8017cf0:	fb02 3306 	mla	r3, r2, r6, r3
 8017cf4:	791a      	ldrb	r2, [r3, #4]
 8017cf6:	2a02      	cmp	r2, #2
 8017cf8:	d046      	beq.n	8017d88 <CDS_socket_close+0xdc>
  else if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_CREATED)
 8017cfa:	2a01      	cmp	r2, #1
 8017cfc:	d05d      	beq.n	8017dba <CDS_socket_close+0x10e>
  else if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_NOT_ALLOC)
 8017cfe:	2a00      	cmp	r2, #0
 8017d00:	f000 8083 	beq.w	8017e0a <CDS_socket_close+0x15e>
  else if (cs_ctxt_sockets_info[sockHandle].state == SOCKETSTATE_ALLOC_BUT_INVALID)
 8017d04:	2a03      	cmp	r2, #3
 8017d06:	f000 8099 	beq.w	8017e3c <CDS_socket_close+0x190>
    PRINT_ERR("<Cellular_Service> invalid socket state %d (close)", cs_ctxt_sockets_info[sockHandle].state)
 8017d0a:	4c5b      	ldr	r4, [pc, #364]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017d0c:	495d      	ldr	r1, [pc, #372]	; (8017e84 <CDS_socket_close+0x1d8>)
 8017d0e:	4620      	mov	r0, r4
 8017d10:	f00e fd9a 	bl	8026848 <sprintf>
 8017d14:	4620      	mov	r0, r4
 8017d16:	f007 fb08 	bl	801f32a <crs_strlen>
 8017d1a:	b283      	uxth	r3, r0
 8017d1c:	4622      	mov	r2, r4
 8017d1e:	2110      	movs	r1, #16
 8017d20:	2001      	movs	r0, #1
 8017d22:	f007 fb45 	bl	801f3b0 <traceIF_itmPrint>
 8017d26:	4620      	mov	r0, r4
 8017d28:	f007 faff 	bl	801f32a <crs_strlen>
 8017d2c:	b283      	uxth	r3, r0
 8017d2e:	4622      	mov	r2, r4
 8017d30:	2110      	movs	r1, #16
 8017d32:	2001      	movs	r0, #1
 8017d34:	f007 fb5e 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_ERR("<Cellular_Service> error when closing socket")
 8017d38:	4c53      	ldr	r4, [pc, #332]	; (8017e88 <CDS_socket_close+0x1dc>)
 8017d3a:	4d4f      	ldr	r5, [pc, #316]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017d3c:	f104 0630 	add.w	r6, r4, #48	; 0x30
 8017d40:	46a4      	mov	ip, r4
 8017d42:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017d46:	6028      	str	r0, [r5, #0]
 8017d48:	6069      	str	r1, [r5, #4]
 8017d4a:	60aa      	str	r2, [r5, #8]
 8017d4c:	60eb      	str	r3, [r5, #12]
 8017d4e:	4664      	mov	r4, ip
 8017d50:	3510      	adds	r5, #16
 8017d52:	45b4      	cmp	ip, r6
 8017d54:	d1f4      	bne.n	8017d40 <CDS_socket_close+0x94>
 8017d56:	cc03      	ldmia	r4!, {r0, r1}
 8017d58:	6028      	str	r0, [r5, #0]
 8017d5a:	6069      	str	r1, [r5, #4]
 8017d5c:	4c46      	ldr	r4, [pc, #280]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017d5e:	4620      	mov	r0, r4
 8017d60:	f007 fae3 	bl	801f32a <crs_strlen>
 8017d64:	b283      	uxth	r3, r0
 8017d66:	4622      	mov	r2, r4
 8017d68:	2110      	movs	r1, #16
 8017d6a:	2001      	movs	r0, #1
 8017d6c:	f007 fb20 	bl	801f3b0 <traceIF_itmPrint>
 8017d70:	4620      	mov	r0, r4
 8017d72:	f007 fada 	bl	801f32a <crs_strlen>
 8017d76:	b283      	uxth	r3, r0
 8017d78:	4622      	mov	r2, r4
 8017d7a:	2110      	movs	r1, #16
 8017d7c:	2001      	movs	r0, #1
 8017d7e:	f007 fb39 	bl	801f3f4 <traceIF_uartPrint>
 8017d82:	2401      	movs	r4, #1
}
 8017d84:	4620      	mov	r0, r4
 8017d86:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (DATAPACK_writePtr(&cmd_buf[0],
 8017d88:	226c      	movs	r2, #108	; 0x6c
 8017d8a:	4b3d      	ldr	r3, [pc, #244]	; (8017e80 <CDS_socket_close+0x1d4>)
 8017d8c:	fb02 3206 	mla	r2, r2, r6, r3
 8017d90:	2118      	movs	r1, #24
 8017d92:	483e      	ldr	r0, [pc, #248]	; (8017e8c <CDS_socket_close+0x1e0>)
 8017d94:	f7f4 f95e 	bl	800c054 <DATAPACK_writePtr>
 8017d98:	2800      	cmp	r0, #0
 8017d9a:	d1cd      	bne.n	8017d38 <CDS_socket_close+0x8c>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_SOCKET_CLOSE, &cmd_buf[0], &rsp_buf[0]);
 8017d9c:	4b3c      	ldr	r3, [pc, #240]	; (8017e90 <CDS_socket_close+0x1e4>)
 8017d9e:	4a3b      	ldr	r2, [pc, #236]	; (8017e8c <CDS_socket_close+0x1e0>)
 8017da0:	217d      	movs	r1, #125	; 0x7d
 8017da2:	483c      	ldr	r0, [pc, #240]	; (8017e94 <CDS_socket_close+0x1e8>)
 8017da4:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017da8:	f7f3 ff1c 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017dac:	4604      	mov	r4, r0
 8017dae:	2800      	cmp	r0, #0
 8017db0:	d1c2      	bne.n	8017d38 <CDS_socket_close+0x8c>
        csint_socket_deallocateHandle(sockHandle);
 8017db2:	4630      	mov	r0, r6
 8017db4:	f002 fc50 	bl	801a658 <csint_socket_deallocateHandle>
  if (retval == CELLULAR_ERROR)
 8017db8:	e7e4      	b.n	8017d84 <CDS_socket_close+0xd8>
    PRINT_INFO("<Cellular_Service> socket was not connected ")
 8017dba:	4f37      	ldr	r7, [pc, #220]	; (8017e98 <CDS_socket_close+0x1ec>)
 8017dbc:	4d2e      	ldr	r5, [pc, #184]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017dbe:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8017dc2:	463c      	mov	r4, r7
 8017dc4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8017dc6:	6028      	str	r0, [r5, #0]
 8017dc8:	6069      	str	r1, [r5, #4]
 8017dca:	60aa      	str	r2, [r5, #8]
 8017dcc:	60eb      	str	r3, [r5, #12]
 8017dce:	4627      	mov	r7, r4
 8017dd0:	3510      	adds	r5, #16
 8017dd2:	4564      	cmp	r4, ip
 8017dd4:	d1f5      	bne.n	8017dc2 <CDS_socket_close+0x116>
 8017dd6:	8823      	ldrh	r3, [r4, #0]
 8017dd8:	802b      	strh	r3, [r5, #0]
 8017dda:	4c27      	ldr	r4, [pc, #156]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017ddc:	4620      	mov	r0, r4
 8017dde:	f007 faa4 	bl	801f32a <crs_strlen>
 8017de2:	b283      	uxth	r3, r0
 8017de4:	4622      	mov	r2, r4
 8017de6:	2101      	movs	r1, #1
 8017de8:	4608      	mov	r0, r1
 8017dea:	f007 fae1 	bl	801f3b0 <traceIF_itmPrint>
 8017dee:	4620      	mov	r0, r4
 8017df0:	f007 fa9b 	bl	801f32a <crs_strlen>
 8017df4:	b283      	uxth	r3, r0
 8017df6:	4622      	mov	r2, r4
 8017df8:	2101      	movs	r1, #1
 8017dfa:	4608      	mov	r0, r1
 8017dfc:	f007 fafa 	bl	801f3f4 <traceIF_uartPrint>
    csint_socket_deallocateHandle(sockHandle);
 8017e00:	4630      	mov	r0, r6
 8017e02:	f002 fc29 	bl	801a658 <csint_socket_deallocateHandle>
    retval = CELLULAR_OK;
 8017e06:	2400      	movs	r4, #0
 8017e08:	e7bc      	b.n	8017d84 <CDS_socket_close+0xd8>
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (close)", sockHandle)
 8017e0a:	4c1b      	ldr	r4, [pc, #108]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017e0c:	4632      	mov	r2, r6
 8017e0e:	4923      	ldr	r1, [pc, #140]	; (8017e9c <CDS_socket_close+0x1f0>)
 8017e10:	4620      	mov	r0, r4
 8017e12:	f00e fd19 	bl	8026848 <sprintf>
 8017e16:	4620      	mov	r0, r4
 8017e18:	f007 fa87 	bl	801f32a <crs_strlen>
 8017e1c:	b283      	uxth	r3, r0
 8017e1e:	4622      	mov	r2, r4
 8017e20:	2110      	movs	r1, #16
 8017e22:	2001      	movs	r0, #1
 8017e24:	f007 fac4 	bl	801f3b0 <traceIF_itmPrint>
 8017e28:	4620      	mov	r0, r4
 8017e2a:	f007 fa7e 	bl	801f32a <crs_strlen>
 8017e2e:	b283      	uxth	r3, r0
 8017e30:	4622      	mov	r2, r4
 8017e32:	2110      	movs	r1, #16
 8017e34:	2001      	movs	r0, #1
 8017e36:	f007 fadd 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017e3a:	e77d      	b.n	8017d38 <CDS_socket_close+0x8c>
    PRINT_INFO("<Cellular_Service> invalid socket state (after modem reboot) ")
 8017e3c:	4c0e      	ldr	r4, [pc, #56]	; (8017e78 <CDS_socket_close+0x1cc>)
 8017e3e:	2243      	movs	r2, #67	; 0x43
 8017e40:	4917      	ldr	r1, [pc, #92]	; (8017ea0 <CDS_socket_close+0x1f4>)
 8017e42:	4620      	mov	r0, r4
 8017e44:	f00e fe50 	bl	8026ae8 <memcpy>
 8017e48:	4620      	mov	r0, r4
 8017e4a:	f007 fa6e 	bl	801f32a <crs_strlen>
 8017e4e:	b283      	uxth	r3, r0
 8017e50:	4622      	mov	r2, r4
 8017e52:	2101      	movs	r1, #1
 8017e54:	4608      	mov	r0, r1
 8017e56:	f007 faab 	bl	801f3b0 <traceIF_itmPrint>
 8017e5a:	4620      	mov	r0, r4
 8017e5c:	f007 fa65 	bl	801f32a <crs_strlen>
 8017e60:	b283      	uxth	r3, r0
 8017e62:	4622      	mov	r2, r4
 8017e64:	2101      	movs	r1, #1
 8017e66:	4608      	mov	r0, r1
 8017e68:	f007 fac4 	bl	801f3f4 <traceIF_uartPrint>
    csint_socket_deallocateHandle(sockHandle);
 8017e6c:	4630      	mov	r0, r6
 8017e6e:	f002 fbf3 	bl	801a658 <csint_socket_deallocateHandle>
    retval = CELLULAR_OK;
 8017e72:	2400      	movs	r4, #0
 8017e74:	e786      	b.n	8017d84 <CDS_socket_close+0xd8>
 8017e76:	bf00      	nop
 8017e78:	200047dc 	.word	0x200047dc
 8017e7c:	08032e20 	.word	0x08032e20
 8017e80:	20003d18 	.word	0x20003d18
 8017e84:	08032ef4 	.word	0x08032ef4
 8017e88:	08032f34 	.word	0x08032f34
 8017e8c:	20003620 	.word	0x20003620
 8017e90:	20003814 	.word	0x20003814
 8017e94:	2000361c 	.word	0x2000361c
 8017e98:	08032e3c 	.word	0x08032e3c
 8017e9c:	08032e70 	.word	0x08032e70
 8017ea0:	08032eb0 	.word	0x08032eb0

08017ea4 <CS_direct_cmd>:
{
 8017ea4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017ea6:	4606      	mov	r6, r0
  PRINT_API("CS_direct_cmd")
 8017ea8:	4c50      	ldr	r4, [pc, #320]	; (8017fec <CS_direct_cmd+0x148>)
 8017eaa:	4d51      	ldr	r5, [pc, #324]	; (8017ff0 <CS_direct_cmd+0x14c>)
 8017eac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017eae:	6020      	str	r0, [r4, #0]
 8017eb0:	6061      	str	r1, [r4, #4]
 8017eb2:	60a2      	str	r2, [r4, #8]
 8017eb4:	60e3      	str	r3, [r4, #12]
 8017eb6:	6828      	ldr	r0, [r5, #0]
 8017eb8:	6120      	str	r0, [r4, #16]
 8017eba:	88aa      	ldrh	r2, [r5, #4]
 8017ebc:	79ab      	ldrb	r3, [r5, #6]
 8017ebe:	82a2      	strh	r2, [r4, #20]
 8017ec0:	75a3      	strb	r3, [r4, #22]
 8017ec2:	4620      	mov	r0, r4
 8017ec4:	f007 fa31 	bl	801f32a <crs_strlen>
 8017ec8:	b283      	uxth	r3, r0
 8017eca:	4622      	mov	r2, r4
 8017ecc:	2104      	movs	r1, #4
 8017ece:	2001      	movs	r0, #1
 8017ed0:	f007 fa6e 	bl	801f3b0 <traceIF_itmPrint>
 8017ed4:	4620      	mov	r0, r4
 8017ed6:	f007 fa28 	bl	801f32a <crs_strlen>
 8017eda:	b283      	uxth	r3, r0
 8017edc:	4622      	mov	r2, r4
 8017ede:	2104      	movs	r1, #4
 8017ee0:	2001      	movs	r0, #1
 8017ee2:	f007 fa87 	bl	801f3f4 <traceIF_uartPrint>
  if (direct_cmd_tx->cmd_size <= MAX_DIRECT_CMD_SIZE)
 8017ee6:	f8b6 3076 	ldrh.w	r3, [r6, #118]	; 0x76
 8017eea:	2b76      	cmp	r3, #118	; 0x76
 8017eec:	d83d      	bhi.n	8017f6a <CS_direct_cmd+0xc6>
    if (DATAPACK_writePtr(&cmd_buf[0],
 8017eee:	4632      	mov	r2, r6
 8017ef0:	212b      	movs	r1, #43	; 0x2b
 8017ef2:	4840      	ldr	r0, [pc, #256]	; (8017ff4 <CS_direct_cmd+0x150>)
 8017ef4:	f7f4 f8ae 	bl	800c054 <DATAPACK_writePtr>
 8017ef8:	b108      	cbz	r0, 8017efe <CS_direct_cmd+0x5a>
  CS_Status_t retval = CELLULAR_ERROR;
 8017efa:	2601      	movs	r6, #1
 8017efc:	e04e      	b.n	8017f9c <CS_direct_cmd+0xf8>
      err = AT_sendcmd(_Adapter_Handle, (at_msg_t) SID_CS_DIRECT_CMD, &cmd_buf[0], &rsp_buf[0]);
 8017efe:	4b3e      	ldr	r3, [pc, #248]	; (8017ff8 <CS_direct_cmd+0x154>)
 8017f00:	4a3c      	ldr	r2, [pc, #240]	; (8017ff4 <CS_direct_cmd+0x150>)
 8017f02:	2186      	movs	r1, #134	; 0x86
 8017f04:	483d      	ldr	r0, [pc, #244]	; (8017ffc <CS_direct_cmd+0x158>)
 8017f06:	f9b0 0000 	ldrsh.w	r0, [r0]
 8017f0a:	f7f3 fe6b 	bl	800bbe4 <AT_sendcmd>
      if (err == ATSTATUS_OK)
 8017f0e:	4606      	mov	r6, r0
 8017f10:	bb20      	cbnz	r0, 8017f5c <CS_direct_cmd+0xb8>
        PRINT_DBG("<Cellular_Service> Direct command infos received")
 8017f12:	4f3b      	ldr	r7, [pc, #236]	; (8018000 <CS_direct_cmd+0x15c>)
 8017f14:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8017f18:	463d      	mov	r5, r7
 8017f1a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8017f1c:	6020      	str	r0, [r4, #0]
 8017f1e:	6061      	str	r1, [r4, #4]
 8017f20:	60a2      	str	r2, [r4, #8]
 8017f22:	60e3      	str	r3, [r4, #12]
 8017f24:	462f      	mov	r7, r5
 8017f26:	3410      	adds	r4, #16
 8017f28:	4565      	cmp	r5, ip
 8017f2a:	d1f5      	bne.n	8017f18 <CS_direct_cmd+0x74>
 8017f2c:	6828      	ldr	r0, [r5, #0]
 8017f2e:	6020      	str	r0, [r4, #0]
 8017f30:	88ab      	ldrh	r3, [r5, #4]
 8017f32:	80a3      	strh	r3, [r4, #4]
 8017f34:	4c2d      	ldr	r4, [pc, #180]	; (8017fec <CS_direct_cmd+0x148>)
 8017f36:	4620      	mov	r0, r4
 8017f38:	f007 f9f7 	bl	801f32a <crs_strlen>
 8017f3c:	b283      	uxth	r3, r0
 8017f3e:	4622      	mov	r2, r4
 8017f40:	2102      	movs	r1, #2
 8017f42:	2001      	movs	r0, #1
 8017f44:	f007 fa34 	bl	801f3b0 <traceIF_itmPrint>
 8017f48:	4620      	mov	r0, r4
 8017f4a:	f007 f9ee 	bl	801f32a <crs_strlen>
 8017f4e:	b283      	uxth	r3, r0
 8017f50:	4622      	mov	r2, r4
 8017f52:	2102      	movs	r1, #2
 8017f54:	2001      	movs	r0, #1
 8017f56:	f007 fa4d 	bl	801f3f4 <traceIF_uartPrint>
  if (retval == CELLULAR_ERROR)
 8017f5a:	e045      	b.n	8017fe8 <CS_direct_cmd+0x144>
        retval = CELLULAR_analyze_error_report(&rsp_buf[0]);
 8017f5c:	4826      	ldr	r0, [pc, #152]	; (8017ff8 <CS_direct_cmd+0x154>)
 8017f5e:	f7fd fdcf 	bl	8015b00 <CELLULAR_analyze_error_report>
 8017f62:	4606      	mov	r6, r0
  if (retval == CELLULAR_ERROR)
 8017f64:	2801      	cmp	r0, #1
 8017f66:	d13f      	bne.n	8017fe8 <CS_direct_cmd+0x144>
 8017f68:	e018      	b.n	8017f9c <CS_direct_cmd+0xf8>
    PRINT_INFO("<Cellular_Service> Direct command command size to big (limit=%d)", MAX_DIRECT_CMD_SIZE)
 8017f6a:	4c20      	ldr	r4, [pc, #128]	; (8017fec <CS_direct_cmd+0x148>)
 8017f6c:	2276      	movs	r2, #118	; 0x76
 8017f6e:	4925      	ldr	r1, [pc, #148]	; (8018004 <CS_direct_cmd+0x160>)
 8017f70:	4620      	mov	r0, r4
 8017f72:	f00e fc69 	bl	8026848 <sprintf>
 8017f76:	4620      	mov	r0, r4
 8017f78:	f007 f9d7 	bl	801f32a <crs_strlen>
 8017f7c:	b283      	uxth	r3, r0
 8017f7e:	4622      	mov	r2, r4
 8017f80:	2101      	movs	r1, #1
 8017f82:	4608      	mov	r0, r1
 8017f84:	f007 fa14 	bl	801f3b0 <traceIF_itmPrint>
 8017f88:	4620      	mov	r0, r4
 8017f8a:	f007 f9ce 	bl	801f32a <crs_strlen>
 8017f8e:	b283      	uxth	r3, r0
 8017f90:	4622      	mov	r2, r4
 8017f92:	2101      	movs	r1, #1
 8017f94:	4608      	mov	r0, r1
 8017f96:	f007 fa2d 	bl	801f3f4 <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 8017f9a:	2601      	movs	r6, #1
    PRINT_ERR("<Cellular_Service> error when sending direct cmd")
 8017f9c:	4c1a      	ldr	r4, [pc, #104]	; (8018008 <CS_direct_cmd+0x164>)
 8017f9e:	4d13      	ldr	r5, [pc, #76]	; (8017fec <CS_direct_cmd+0x148>)
 8017fa0:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 8017fa4:	46a4      	mov	ip, r4
 8017fa6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8017faa:	6028      	str	r0, [r5, #0]
 8017fac:	6069      	str	r1, [r5, #4]
 8017fae:	60aa      	str	r2, [r5, #8]
 8017fb0:	60eb      	str	r3, [r5, #12]
 8017fb2:	4664      	mov	r4, ip
 8017fb4:	3510      	adds	r5, #16
 8017fb6:	45f4      	cmp	ip, lr
 8017fb8:	d1f4      	bne.n	8017fa4 <CS_direct_cmd+0x100>
 8017fba:	cc07      	ldmia	r4!, {r0, r1, r2}
 8017fbc:	6028      	str	r0, [r5, #0]
 8017fbe:	6069      	str	r1, [r5, #4]
 8017fc0:	60aa      	str	r2, [r5, #8]
 8017fc2:	4c0a      	ldr	r4, [pc, #40]	; (8017fec <CS_direct_cmd+0x148>)
 8017fc4:	4620      	mov	r0, r4
 8017fc6:	f007 f9b0 	bl	801f32a <crs_strlen>
 8017fca:	b283      	uxth	r3, r0
 8017fcc:	4622      	mov	r2, r4
 8017fce:	2110      	movs	r1, #16
 8017fd0:	2001      	movs	r0, #1
 8017fd2:	f007 f9ed 	bl	801f3b0 <traceIF_itmPrint>
 8017fd6:	4620      	mov	r0, r4
 8017fd8:	f007 f9a7 	bl	801f32a <crs_strlen>
 8017fdc:	b283      	uxth	r3, r0
 8017fde:	4622      	mov	r2, r4
 8017fe0:	2110      	movs	r1, #16
 8017fe2:	2001      	movs	r0, #1
 8017fe4:	f007 fa06 	bl	801f3f4 <traceIF_uartPrint>
}
 8017fe8:	4630      	mov	r0, r6
 8017fea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8017fec:	200047dc 	.word	0x200047dc
 8017ff0:	08032f6c 	.word	0x08032f6c
 8017ff4:	20003620 	.word	0x20003620
 8017ff8:	20003814 	.word	0x20003814
 8017ffc:	2000361c 	.word	0x2000361c
 8018000:	08032f84 	.word	0x08032f84
 8018004:	08032fbc 	.word	0x08032fbc
 8018008:	08033004 	.word	0x08033004

0801800c <CST_cellular_direct_cmd_callback>:
  * @brief  at processing callback
  * @param  direct_cmd_rx - rx command line
  * @retval -
  */
static void CST_cellular_direct_cmd_callback(CS_direct_cmd_rx_t direct_cmd_rx)
{
 801800c:	b084      	sub	sp, #16
 801800e:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
  UNUSED(direct_cmd_rx);
}
 8018012:	b004      	add	sp, #16
 8018014:	4770      	bx	lr
	...

08018018 <CST_CMD_display_bitmap_name_altair>:
{
 8018018:	b538      	push	{r3, r4, r5, lr}
  for (i = 0U; i < CST_CMD_band_count  ; i++)
 801801a:	2500      	movs	r5, #0
 801801c:	e018      	b.n	8018050 <CST_CMD_display_bitmap_name_altair+0x38>
    PRINT_FORCE("B%d", CST_CMD_band_tab[i])
 801801e:	4c0f      	ldr	r4, [pc, #60]	; (801805c <CST_CMD_display_bitmap_name_altair+0x44>)
 8018020:	4b0f      	ldr	r3, [pc, #60]	; (8018060 <CST_CMD_display_bitmap_name_altair+0x48>)
 8018022:	5d5a      	ldrb	r2, [r3, r5]
 8018024:	490f      	ldr	r1, [pc, #60]	; (8018064 <CST_CMD_display_bitmap_name_altair+0x4c>)
 8018026:	4620      	mov	r0, r4
 8018028:	f00e fc0e 	bl	8026848 <sprintf>
 801802c:	4620      	mov	r0, r4
 801802e:	f007 f97c 	bl	801f32a <crs_strlen>
 8018032:	b283      	uxth	r3, r0
 8018034:	4622      	mov	r2, r4
 8018036:	2101      	movs	r1, #1
 8018038:	2007      	movs	r0, #7
 801803a:	f007 f9b9 	bl	801f3b0 <traceIF_itmPrint>
 801803e:	4620      	mov	r0, r4
 8018040:	f007 f973 	bl	801f32a <crs_strlen>
 8018044:	b282      	uxth	r2, r0
 8018046:	4621      	mov	r1, r4
 8018048:	2007      	movs	r0, #7
 801804a:	f007 f9eb 	bl	801f424 <traceIF_uartPrintForce>
  for (i = 0U; i < CST_CMD_band_count  ; i++)
 801804e:	3501      	adds	r5, #1
 8018050:	4b05      	ldr	r3, [pc, #20]	; (8018068 <CST_CMD_display_bitmap_name_altair+0x50>)
 8018052:	781b      	ldrb	r3, [r3, #0]
 8018054:	42ab      	cmp	r3, r5
 8018056:	d8e2      	bhi.n	801801e <CST_CMD_display_bitmap_name_altair+0x6>
}
 8018058:	bd38      	pop	{r3, r4, r5, pc}
 801805a:	bf00      	nop
 801805c:	20004ddc 	.word	0x20004ddc
 8018060:	20000048 	.word	0x20000048
 8018064:	08033040 	.word	0x08033040
 8018068:	20000046 	.word	0x20000046

0801806c <CST_ModemHelpCmd>:
{
 801806c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CMD_print_help(CST_cmd_modem_label);
 8018070:	48d7      	ldr	r0, [pc, #860]	; (80183d0 <CST_ModemHelpCmd+0x364>)
 8018072:	f00a fca1 	bl	80229b8 <CMD_print_help>
  PRINT_FORCE("--------------------------------------")
 8018076:	4cd7      	ldr	r4, [pc, #860]	; (80183d4 <CST_ModemHelpCmd+0x368>)
 8018078:	4dd7      	ldr	r5, [pc, #860]	; (80183d8 <CST_ModemHelpCmd+0x36c>)
 801807a:	f104 0620 	add.w	r6, r4, #32
 801807e:	46a4      	mov	ip, r4
 8018080:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8018084:	6028      	str	r0, [r5, #0]
 8018086:	6069      	str	r1, [r5, #4]
 8018088:	60aa      	str	r2, [r5, #8]
 801808a:	60eb      	str	r3, [r5, #12]
 801808c:	4664      	mov	r4, ip
 801808e:	3510      	adds	r5, #16
 8018090:	45b4      	cmp	ip, r6
 8018092:	d1f4      	bne.n	801807e <CST_ModemHelpCmd+0x12>
 8018094:	cc03      	ldmia	r4!, {r0, r1}
 8018096:	6028      	str	r0, [r5, #0]
 8018098:	6069      	str	r1, [r5, #4]
 801809a:	7823      	ldrb	r3, [r4, #0]
 801809c:	722b      	strb	r3, [r5, #8]
 801809e:	4cce      	ldr	r4, [pc, #824]	; (80183d8 <CST_ModemHelpCmd+0x36c>)
 80180a0:	4620      	mov	r0, r4
 80180a2:	f007 f942 	bl	801f32a <crs_strlen>
 80180a6:	b283      	uxth	r3, r0
 80180a8:	4622      	mov	r2, r4
 80180aa:	2101      	movs	r1, #1
 80180ac:	2007      	movs	r0, #7
 80180ae:	f007 f97f 	bl	801f3b0 <traceIF_itmPrint>
 80180b2:	4620      	mov	r0, r4
 80180b4:	f007 f939 	bl	801f32a <crs_strlen>
 80180b8:	b282      	uxth	r2, r0
 80180ba:	4621      	mov	r1, r4
 80180bc:	2007      	movs	r0, #7
 80180be:	f007 f9b1 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("1 - Modem band configuration commands")
 80180c2:	4dc6      	ldr	r5, [pc, #792]	; (80183dc <CST_ModemHelpCmd+0x370>)
 80180c4:	f105 0620 	add.w	r6, r5, #32
 80180c8:	46ac      	mov	ip, r5
 80180ca:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80180ce:	6020      	str	r0, [r4, #0]
 80180d0:	6061      	str	r1, [r4, #4]
 80180d2:	60a2      	str	r2, [r4, #8]
 80180d4:	60e3      	str	r3, [r4, #12]
 80180d6:	4665      	mov	r5, ip
 80180d8:	3410      	adds	r4, #16
 80180da:	45b4      	cmp	ip, r6
 80180dc:	d1f4      	bne.n	80180c8 <CST_ModemHelpCmd+0x5c>
 80180de:	cd03      	ldmia	r5!, {r0, r1}
 80180e0:	6020      	str	r0, [r4, #0]
 80180e2:	6061      	str	r1, [r4, #4]
 80180e4:	4cbc      	ldr	r4, [pc, #752]	; (80183d8 <CST_ModemHelpCmd+0x36c>)
 80180e6:	4620      	mov	r0, r4
 80180e8:	f007 f91f 	bl	801f32a <crs_strlen>
 80180ec:	b283      	uxth	r3, r0
 80180ee:	4622      	mov	r2, r4
 80180f0:	2101      	movs	r1, #1
 80180f2:	2007      	movs	r0, #7
 80180f4:	f007 f95c 	bl	801f3b0 <traceIF_itmPrint>
 80180f8:	4620      	mov	r0, r4
 80180fa:	f007 f916 	bl	801f32a <crs_strlen>
 80180fe:	b282      	uxth	r2, r0
 8018100:	4621      	mov	r1, r4
 8018102:	2007      	movs	r0, #7
 8018104:	f007 f98e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("--------------------------------------")
 8018108:	4db2      	ldr	r5, [pc, #712]	; (80183d4 <CST_ModemHelpCmd+0x368>)
 801810a:	f105 0620 	add.w	r6, r5, #32
 801810e:	46ac      	mov	ip, r5
 8018110:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8018114:	6020      	str	r0, [r4, #0]
 8018116:	6061      	str	r1, [r4, #4]
 8018118:	60a2      	str	r2, [r4, #8]
 801811a:	60e3      	str	r3, [r4, #12]
 801811c:	4665      	mov	r5, ip
 801811e:	3410      	adds	r4, #16
 8018120:	45b4      	cmp	ip, r6
 8018122:	d1f4      	bne.n	801810e <CST_ModemHelpCmd+0xa2>
 8018124:	cd03      	ldmia	r5!, {r0, r1}
 8018126:	6020      	str	r0, [r4, #0]
 8018128:	6061      	str	r1, [r4, #4]
 801812a:	782b      	ldrb	r3, [r5, #0]
 801812c:	7223      	strb	r3, [r4, #8]
 801812e:	4caa      	ldr	r4, [pc, #680]	; (80183d8 <CST_ModemHelpCmd+0x36c>)
 8018130:	4620      	mov	r0, r4
 8018132:	f007 f8fa 	bl	801f32a <crs_strlen>
 8018136:	b283      	uxth	r3, r0
 8018138:	4622      	mov	r2, r4
 801813a:	2101      	movs	r1, #1
 801813c:	2007      	movs	r0, #7
 801813e:	f007 f937 	bl	801f3b0 <traceIF_itmPrint>
 8018142:	4620      	mov	r0, r4
 8018144:	f007 f8f1 	bl	801f32a <crs_strlen>
 8018148:	b282      	uxth	r2, r0
 801814a:	4621      	mov	r1, r4
 801814c:	2007      	movs	r0, #7
 801814e:	f007 f969 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("Modem configuration commands are used to modify the modem band configuration.")
 8018152:	2250      	movs	r2, #80	; 0x50
 8018154:	49a2      	ldr	r1, [pc, #648]	; (80183e0 <CST_ModemHelpCmd+0x374>)
 8018156:	4620      	mov	r0, r4
 8018158:	f00e fcc6 	bl	8026ae8 <memcpy>
 801815c:	4620      	mov	r0, r4
 801815e:	f007 f8e4 	bl	801f32a <crs_strlen>
 8018162:	b283      	uxth	r3, r0
 8018164:	4622      	mov	r2, r4
 8018166:	2101      	movs	r1, #1
 8018168:	2007      	movs	r0, #7
 801816a:	f007 f921 	bl	801f3b0 <traceIF_itmPrint>
 801816e:	4620      	mov	r0, r4
 8018170:	f007 f8db 	bl	801f32a <crs_strlen>
 8018174:	b282      	uxth	r2, r0
 8018176:	4621      	mov	r1, r4
 8018178:	2007      	movs	r0, #7
 801817a:	f007 f953 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("Setting a new configuration is performed in two steps:")
 801817e:	4d99      	ldr	r5, [pc, #612]	; (80183e4 <CST_ModemHelpCmd+0x378>)
 8018180:	f105 0630 	add.w	r6, r5, #48	; 0x30
 8018184:	46ac      	mov	ip, r5
 8018186:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801818a:	6020      	str	r0, [r4, #0]
 801818c:	6061      	str	r1, [r4, #4]
 801818e:	60a2      	str	r2, [r4, #8]
 8018190:	60e3      	str	r3, [r4, #12]
 8018192:	4665      	mov	r5, ip
 8018194:	3410      	adds	r4, #16
 8018196:	45b4      	cmp	ip, r6
 8018198:	d1f4      	bne.n	8018184 <CST_ModemHelpCmd+0x118>
 801819a:	cd03      	ldmia	r5!, {r0, r1}
 801819c:	6020      	str	r0, [r4, #0]
 801819e:	6061      	str	r1, [r4, #4]
 80181a0:	782b      	ldrb	r3, [r5, #0]
 80181a2:	7223      	strb	r3, [r4, #8]
 80181a4:	4c8c      	ldr	r4, [pc, #560]	; (80183d8 <CST_ModemHelpCmd+0x36c>)
 80181a6:	4620      	mov	r0, r4
 80181a8:	f007 f8bf 	bl	801f32a <crs_strlen>
 80181ac:	b283      	uxth	r3, r0
 80181ae:	4622      	mov	r2, r4
 80181b0:	2101      	movs	r1, #1
 80181b2:	2007      	movs	r0, #7
 80181b4:	f007 f8fc 	bl	801f3b0 <traceIF_itmPrint>
 80181b8:	4620      	mov	r0, r4
 80181ba:	f007 f8b6 	bl	801f32a <crs_strlen>
 80181be:	b282      	uxth	r2, r0
 80181c0:	4621      	mov	r1, r4
 80181c2:	2007      	movs	r0, #7
 80181c4:	f007 f92e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 80181c8:	4d87      	ldr	r5, [pc, #540]	; (80183e8 <CST_ModemHelpCmd+0x37c>)
 80181ca:	6828      	ldr	r0, [r5, #0]
 80181cc:	6020      	str	r0, [r4, #0]
 80181ce:	792e      	ldrb	r6, [r5, #4]
 80181d0:	7126      	strb	r6, [r4, #4]
 80181d2:	4620      	mov	r0, r4
 80181d4:	f007 f8a9 	bl	801f32a <crs_strlen>
 80181d8:	b283      	uxth	r3, r0
 80181da:	4622      	mov	r2, r4
 80181dc:	2101      	movs	r1, #1
 80181de:	2007      	movs	r0, #7
 80181e0:	f007 f8e6 	bl	801f3b0 <traceIF_itmPrint>
 80181e4:	4620      	mov	r0, r4
 80181e6:	f007 f8a0 	bl	801f32a <crs_strlen>
 80181ea:	b282      	uxth	r2, r0
 80181ec:	4621      	mov	r1, r4
 80181ee:	2007      	movs	r0, #7
 80181f0:	f007 f918 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("- 1st step: enter the configuration parameters using the following commands:");
 80181f4:	224f      	movs	r2, #79	; 0x4f
 80181f6:	497d      	ldr	r1, [pc, #500]	; (80183ec <CST_ModemHelpCmd+0x380>)
 80181f8:	4620      	mov	r0, r4
 80181fa:	f00e fc75 	bl	8026ae8 <memcpy>
 80181fe:	4620      	mov	r0, r4
 8018200:	f007 f893 	bl	801f32a <crs_strlen>
 8018204:	b283      	uxth	r3, r0
 8018206:	4622      	mov	r2, r4
 8018208:	2101      	movs	r1, #1
 801820a:	2007      	movs	r0, #7
 801820c:	f007 f8d0 	bl	801f3b0 <traceIF_itmPrint>
 8018210:	4620      	mov	r0, r4
 8018212:	f007 f88a 	bl	801f32a <crs_strlen>
 8018216:	b282      	uxth	r2, r0
 8018218:	4621      	mov	r1, r4
 801821a:	2007      	movs	r0, #7
 801821c:	f007 f902 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s config band [B1] [B2] [B3] [B4] [B5] [B8] [B12] [B13] [B14] [B17] [B18] ", CST_cmd_modem_label);
 8018220:	4a6b      	ldr	r2, [pc, #428]	; (80183d0 <CST_ModemHelpCmd+0x364>)
 8018222:	4973      	ldr	r1, [pc, #460]	; (80183f0 <CST_ModemHelpCmd+0x384>)
 8018224:	4620      	mov	r0, r4
 8018226:	f00e fb0f 	bl	8026848 <sprintf>
 801822a:	4620      	mov	r0, r4
 801822c:	f007 f87d 	bl	801f32a <crs_strlen>
 8018230:	b283      	uxth	r3, r0
 8018232:	4622      	mov	r2, r4
 8018234:	2101      	movs	r1, #1
 8018236:	2007      	movs	r0, #7
 8018238:	f007 f8ba 	bl	801f3b0 <traceIF_itmPrint>
 801823c:	4620      	mov	r0, r4
 801823e:	f007 f874 	bl	801f32a <crs_strlen>
 8018242:	b282      	uxth	r2, r0
 8018244:	4621      	mov	r1, r4
 8018246:	2007      	movs	r0, #7
 8018248:	f007 f8ec 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("               [B19] [B20] [B26] [B28] [B39] [B66]  (gets/sets the bands to use(12 bands max))");
 801824c:	2261      	movs	r2, #97	; 0x61
 801824e:	4969      	ldr	r1, [pc, #420]	; (80183f4 <CST_ModemHelpCmd+0x388>)
 8018250:	4620      	mov	r0, r4
 8018252:	f00e fc49 	bl	8026ae8 <memcpy>
 8018256:	4620      	mov	r0, r4
 8018258:	f007 f867 	bl	801f32a <crs_strlen>
 801825c:	b283      	uxth	r3, r0
 801825e:	4622      	mov	r2, r4
 8018260:	2101      	movs	r1, #1
 8018262:	2007      	movs	r0, #7
 8018264:	f007 f8a4 	bl	801f3b0 <traceIF_itmPrint>
 8018268:	4620      	mov	r0, r4
 801826a:	f007 f85e 	bl	801f32a <crs_strlen>
 801826e:	b282      	uxth	r2, r0
 8018270:	4621      	mov	r1, r4
 8018272:	2007      	movs	r0, #7
 8018274:	f007 f8d6 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 8018278:	6828      	ldr	r0, [r5, #0]
 801827a:	6020      	str	r0, [r4, #0]
 801827c:	7126      	strb	r6, [r4, #4]
 801827e:	4620      	mov	r0, r4
 8018280:	f007 f853 	bl	801f32a <crs_strlen>
 8018284:	b283      	uxth	r3, r0
 8018286:	4622      	mov	r2, r4
 8018288:	2101      	movs	r1, #1
 801828a:	2007      	movs	r0, #7
 801828c:	f007 f890 	bl	801f3b0 <traceIF_itmPrint>
 8018290:	4620      	mov	r0, r4
 8018292:	f007 f84a 	bl	801f32a <crs_strlen>
 8018296:	b282      	uxth	r2, r0
 8018298:	4621      	mov	r1, r4
 801829a:	2007      	movs	r0, #7
 801829c:	f007 f8c2 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("- 2nd step: send the new configuration to the modem");
 80182a0:	4d55      	ldr	r5, [pc, #340]	; (80183f8 <CST_ModemHelpCmd+0x38c>)
 80182a2:	f105 0630 	add.w	r6, r5, #48	; 0x30
 80182a6:	46ac      	mov	ip, r5
 80182a8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80182ac:	6020      	str	r0, [r4, #0]
 80182ae:	6061      	str	r1, [r4, #4]
 80182b0:	60a2      	str	r2, [r4, #8]
 80182b2:	60e3      	str	r3, [r4, #12]
 80182b4:	4665      	mov	r5, ip
 80182b6:	3410      	adds	r4, #16
 80182b8:	45b4      	cmp	ip, r6
 80182ba:	d1f4      	bne.n	80182a6 <CST_ModemHelpCmd+0x23a>
 80182bc:	f8dc 0000 	ldr.w	r0, [ip]
 80182c0:	6020      	str	r0, [r4, #0]
 80182c2:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80182c6:	80a3      	strh	r3, [r4, #4]
 80182c8:	4c43      	ldr	r4, [pc, #268]	; (80183d8 <CST_ModemHelpCmd+0x36c>)
 80182ca:	4620      	mov	r0, r4
 80182cc:	f007 f82d 	bl	801f32a <crs_strlen>
 80182d0:	b283      	uxth	r3, r0
 80182d2:	4622      	mov	r2, r4
 80182d4:	2101      	movs	r1, #1
 80182d6:	2007      	movs	r0, #7
 80182d8:	f007 f86a 	bl	801f3b0 <traceIF_itmPrint>
 80182dc:	4620      	mov	r0, r4
 80182de:	f007 f824 	bl	801f32a <crs_strlen>
 80182e2:	b282      	uxth	r2, r0
 80182e4:	4621      	mov	r1, r4
 80182e6:	2007      	movs	r0, #7
 80182e8:	f007 f89c 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s config send", (CRC_CHAR_t *)CST_cmd_modem_label)
 80182ec:	4f38      	ldr	r7, [pc, #224]	; (80183d0 <CST_ModemHelpCmd+0x364>)
 80182ee:	463a      	mov	r2, r7
 80182f0:	4942      	ldr	r1, [pc, #264]	; (80183fc <CST_ModemHelpCmd+0x390>)
 80182f2:	4620      	mov	r0, r4
 80182f4:	f00e faa8 	bl	8026848 <sprintf>
 80182f8:	4620      	mov	r0, r4
 80182fa:	f007 f816 	bl	801f32a <crs_strlen>
 80182fe:	b283      	uxth	r3, r0
 8018300:	4622      	mov	r2, r4
 8018302:	2101      	movs	r1, #1
 8018304:	2007      	movs	r0, #7
 8018306:	f007 f853 	bl	801f3b0 <traceIF_itmPrint>
 801830a:	4620      	mov	r0, r4
 801830c:	f007 f80d 	bl	801f32a <crs_strlen>
 8018310:	b282      	uxth	r2, r0
 8018312:	4621      	mov	r1, r4
 8018314:	2007      	movs	r0, #7
 8018316:	f007 f885 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 801831a:	4e33      	ldr	r6, [pc, #204]	; (80183e8 <CST_ModemHelpCmd+0x37c>)
 801831c:	6830      	ldr	r0, [r6, #0]
 801831e:	6020      	str	r0, [r4, #0]
 8018320:	f896 8004 	ldrb.w	r8, [r6, #4]
 8018324:	f884 8004 	strb.w	r8, [r4, #4]
 8018328:	4620      	mov	r0, r4
 801832a:	f006 fffe 	bl	801f32a <crs_strlen>
 801832e:	b283      	uxth	r3, r0
 8018330:	4622      	mov	r2, r4
 8018332:	2101      	movs	r1, #1
 8018334:	2007      	movs	r0, #7
 8018336:	f007 f83b 	bl	801f3b0 <traceIF_itmPrint>
 801833a:	4620      	mov	r0, r4
 801833c:	f006 fff5 	bl	801f32a <crs_strlen>
 8018340:	b282      	uxth	r2, r0
 8018342:	4621      	mov	r1, r4
 8018344:	2007      	movs	r0, #7
 8018346:	f007 f86d 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("Other commands:");
 801834a:	4d2d      	ldr	r5, [pc, #180]	; (8018400 <CST_ModemHelpCmd+0x394>)
 801834c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801834e:	6020      	str	r0, [r4, #0]
 8018350:	6061      	str	r1, [r4, #4]
 8018352:	60a2      	str	r2, [r4, #8]
 8018354:	60e3      	str	r3, [r4, #12]
 8018356:	882b      	ldrh	r3, [r5, #0]
 8018358:	8223      	strh	r3, [r4, #16]
 801835a:	4620      	mov	r0, r4
 801835c:	f006 ffe5 	bl	801f32a <crs_strlen>
 8018360:	b283      	uxth	r3, r0
 8018362:	4622      	mov	r2, r4
 8018364:	2101      	movs	r1, #1
 8018366:	2007      	movs	r0, #7
 8018368:	f007 f822 	bl	801f3b0 <traceIF_itmPrint>
 801836c:	4620      	mov	r0, r4
 801836e:	f006 ffdc 	bl	801f32a <crs_strlen>
 8018372:	b282      	uxth	r2, r0
 8018374:	4621      	mov	r1, r4
 8018376:	2007      	movs	r0, #7
 8018378:	f007 f854 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s config get (get current config from modem)", (CRC_CHAR_t *)CST_cmd_modem_label)
 801837c:	463a      	mov	r2, r7
 801837e:	4921      	ldr	r1, [pc, #132]	; (8018404 <CST_ModemHelpCmd+0x398>)
 8018380:	4620      	mov	r0, r4
 8018382:	f00e fa61 	bl	8026848 <sprintf>
 8018386:	4620      	mov	r0, r4
 8018388:	f006 ffcf 	bl	801f32a <crs_strlen>
 801838c:	b283      	uxth	r3, r0
 801838e:	4622      	mov	r2, r4
 8018390:	2101      	movs	r1, #1
 8018392:	2007      	movs	r0, #7
 8018394:	f007 f80c 	bl	801f3b0 <traceIF_itmPrint>
 8018398:	4620      	mov	r0, r4
 801839a:	f006 ffc6 	bl	801f32a <crs_strlen>
 801839e:	b282      	uxth	r2, r0
 80183a0:	4621      	mov	r1, r4
 80183a2:	2007      	movs	r0, #7
 80183a4:	f007 f83e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("    (Note: the result of this command displays trace of modem response)")
 80183a8:	224a      	movs	r2, #74	; 0x4a
 80183aa:	4917      	ldr	r1, [pc, #92]	; (8018408 <CST_ModemHelpCmd+0x39c>)
 80183ac:	4620      	mov	r0, r4
 80183ae:	f00e fb9b 	bl	8026ae8 <memcpy>
 80183b2:	4620      	mov	r0, r4
 80183b4:	f006 ffb9 	bl	801f32a <crs_strlen>
 80183b8:	b283      	uxth	r3, r0
 80183ba:	4622      	mov	r2, r4
 80183bc:	2101      	movs	r1, #1
 80183be:	2007      	movs	r0, #7
 80183c0:	f006 fff6 	bl	801f3b0 <traceIF_itmPrint>
 80183c4:	4620      	mov	r0, r4
 80183c6:	f006 ffb0 	bl	801f32a <crs_strlen>
 80183ca:	b282      	uxth	r2, r0
 80183cc:	e01e      	b.n	801840c <CST_ModemHelpCmd+0x3a0>
 80183ce:	bf00      	nop
 80183d0:	08033048 	.word	0x08033048
 80183d4:	08033050 	.word	0x08033050
 80183d8:	20004ddc 	.word	0x20004ddc
 80183dc:	0803307c 	.word	0x0803307c
 80183e0:	080330a4 	.word	0x080330a4
 80183e4:	080330f4 	.word	0x080330f4
 80183e8:	08036cf4 	.word	0x08036cf4
 80183ec:	08033130 	.word	0x08033130
 80183f0:	08033180 	.word	0x08033180
 80183f4:	080331d0 	.word	0x080331d0
 80183f8:	08033234 	.word	0x08033234
 80183fc:	0803326c 	.word	0x0803326c
 8018400:	08033280 	.word	0x08033280
 8018404:	08033294 	.word	0x08033294
 8018408:	080332c4 	.word	0x080332c4
 801840c:	4621      	mov	r1, r4
 801840e:	2007      	movs	r0, #7
 8018410:	f007 f808 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s config (display current config to be sent to modem)", CST_cmd_modem_label)
 8018414:	463a      	mov	r2, r7
 8018416:	49b0      	ldr	r1, [pc, #704]	; (80186d8 <CST_ModemHelpCmd+0x66c>)
 8018418:	4620      	mov	r0, r4
 801841a:	f00e fa15 	bl	8026848 <sprintf>
 801841e:	4620      	mov	r0, r4
 8018420:	f006 ff83 	bl	801f32a <crs_strlen>
 8018424:	b283      	uxth	r3, r0
 8018426:	4622      	mov	r2, r4
 8018428:	2101      	movs	r1, #1
 801842a:	2007      	movs	r0, #7
 801842c:	f006 ffc0 	bl	801f3b0 <traceIF_itmPrint>
 8018430:	4620      	mov	r0, r4
 8018432:	f006 ff7a 	bl	801f32a <crs_strlen>
 8018436:	b282      	uxth	r2, r0
 8018438:	4621      	mov	r1, r4
 801843a:	2007      	movs	r0, #7
 801843c:	f006 fff2 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 8018440:	6830      	ldr	r0, [r6, #0]
 8018442:	6020      	str	r0, [r4, #0]
 8018444:	f884 8004 	strb.w	r8, [r4, #4]
 8018448:	4620      	mov	r0, r4
 801844a:	f006 ff6e 	bl	801f32a <crs_strlen>
 801844e:	b283      	uxth	r3, r0
 8018450:	4622      	mov	r2, r4
 8018452:	2101      	movs	r1, #1
 8018454:	2007      	movs	r0, #7
 8018456:	f006 ffab 	bl	801f3b0 <traceIF_itmPrint>
 801845a:	4620      	mov	r0, r4
 801845c:	f006 ff65 	bl	801f32a <crs_strlen>
 8018460:	b282      	uxth	r2, r0
 8018462:	4621      	mov	r1, r4
 8018464:	2007      	movs	r0, #7
 8018466:	f006 ffdd 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("--------------------------------------")
 801846a:	4d9c      	ldr	r5, [pc, #624]	; (80186dc <CST_ModemHelpCmd+0x670>)
 801846c:	f105 0620 	add.w	r6, r5, #32
 8018470:	46ac      	mov	ip, r5
 8018472:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8018476:	6020      	str	r0, [r4, #0]
 8018478:	6061      	str	r1, [r4, #4]
 801847a:	60a2      	str	r2, [r4, #8]
 801847c:	60e3      	str	r3, [r4, #12]
 801847e:	4665      	mov	r5, ip
 8018480:	3410      	adds	r4, #16
 8018482:	45b4      	cmp	ip, r6
 8018484:	d1f4      	bne.n	8018470 <CST_ModemHelpCmd+0x404>
 8018486:	cd03      	ldmia	r5!, {r0, r1}
 8018488:	6020      	str	r0, [r4, #0]
 801848a:	6061      	str	r1, [r4, #4]
 801848c:	782b      	ldrb	r3, [r5, #0]
 801848e:	7223      	strb	r3, [r4, #8]
 8018490:	4c93      	ldr	r4, [pc, #588]	; (80186e0 <CST_ModemHelpCmd+0x674>)
 8018492:	4620      	mov	r0, r4
 8018494:	f006 ff49 	bl	801f32a <crs_strlen>
 8018498:	b283      	uxth	r3, r0
 801849a:	4622      	mov	r2, r4
 801849c:	2101      	movs	r1, #1
 801849e:	2007      	movs	r0, #7
 80184a0:	f006 ff86 	bl	801f3b0 <traceIF_itmPrint>
 80184a4:	4620      	mov	r0, r4
 80184a6:	f006 ff40 	bl	801f32a <crs_strlen>
 80184aa:	b282      	uxth	r2, r0
 80184ac:	4621      	mov	r1, r4
 80184ae:	2007      	movs	r0, #7
 80184b0:	f006 ffb8 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("2 - Modem low power configuration     ")
 80184b4:	4d8b      	ldr	r5, [pc, #556]	; (80186e4 <CST_ModemHelpCmd+0x678>)
 80184b6:	f105 0620 	add.w	r6, r5, #32
 80184ba:	46ac      	mov	ip, r5
 80184bc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80184c0:	6020      	str	r0, [r4, #0]
 80184c2:	6061      	str	r1, [r4, #4]
 80184c4:	60a2      	str	r2, [r4, #8]
 80184c6:	60e3      	str	r3, [r4, #12]
 80184c8:	4665      	mov	r5, ip
 80184ca:	3410      	adds	r4, #16
 80184cc:	45b4      	cmp	ip, r6
 80184ce:	d1f4      	bne.n	80184ba <CST_ModemHelpCmd+0x44e>
 80184d0:	cd03      	ldmia	r5!, {r0, r1}
 80184d2:	6020      	str	r0, [r4, #0]
 80184d4:	6061      	str	r1, [r4, #4]
 80184d6:	782b      	ldrb	r3, [r5, #0]
 80184d8:	7223      	strb	r3, [r4, #8]
 80184da:	4c81      	ldr	r4, [pc, #516]	; (80186e0 <CST_ModemHelpCmd+0x674>)
 80184dc:	4620      	mov	r0, r4
 80184de:	f006 ff24 	bl	801f32a <crs_strlen>
 80184e2:	b283      	uxth	r3, r0
 80184e4:	4622      	mov	r2, r4
 80184e6:	2101      	movs	r1, #1
 80184e8:	2007      	movs	r0, #7
 80184ea:	f006 ff61 	bl	801f3b0 <traceIF_itmPrint>
 80184ee:	4620      	mov	r0, r4
 80184f0:	f006 ff1b 	bl	801f32a <crs_strlen>
 80184f4:	b282      	uxth	r2, r0
 80184f6:	4621      	mov	r1, r4
 80184f8:	2007      	movs	r0, #7
 80184fa:	f006 ff93 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("--------------------------------------")
 80184fe:	4d77      	ldr	r5, [pc, #476]	; (80186dc <CST_ModemHelpCmd+0x670>)
 8018500:	f105 0620 	add.w	r6, r5, #32
 8018504:	46ac      	mov	ip, r5
 8018506:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801850a:	6020      	str	r0, [r4, #0]
 801850c:	6061      	str	r1, [r4, #4]
 801850e:	60a2      	str	r2, [r4, #8]
 8018510:	60e3      	str	r3, [r4, #12]
 8018512:	4665      	mov	r5, ip
 8018514:	3410      	adds	r4, #16
 8018516:	45b4      	cmp	ip, r6
 8018518:	d1f4      	bne.n	8018504 <CST_ModemHelpCmd+0x498>
 801851a:	cd03      	ldmia	r5!, {r0, r1}
 801851c:	6020      	str	r0, [r4, #0]
 801851e:	6061      	str	r1, [r4, #4]
 8018520:	782b      	ldrb	r3, [r5, #0]
 8018522:	7223      	strb	r3, [r4, #8]
 8018524:	4c6e      	ldr	r4, [pc, #440]	; (80186e0 <CST_ModemHelpCmd+0x674>)
 8018526:	4620      	mov	r0, r4
 8018528:	f006 feff 	bl	801f32a <crs_strlen>
 801852c:	b283      	uxth	r3, r0
 801852e:	4622      	mov	r2, r4
 8018530:	2101      	movs	r1, #1
 8018532:	2007      	movs	r0, #7
 8018534:	f006 ff3c 	bl	801f3b0 <traceIF_itmPrint>
 8018538:	4620      	mov	r0, r4
 801853a:	f006 fef6 	bl	801f32a <crs_strlen>
 801853e:	b282      	uxth	r2, r0
 8018540:	4621      	mov	r1, r4
 8018542:	2007      	movs	r0, #7
 8018544:	f006 ff6e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s config lowpower  (configure modem with lowpower capabilities)", (CRC_CHAR_t *)CST_cmd_modem_label)
 8018548:	4a67      	ldr	r2, [pc, #412]	; (80186e8 <CST_ModemHelpCmd+0x67c>)
 801854a:	4968      	ldr	r1, [pc, #416]	; (80186ec <CST_ModemHelpCmd+0x680>)
 801854c:	4620      	mov	r0, r4
 801854e:	f00e f97b 	bl	8026848 <sprintf>
 8018552:	4620      	mov	r0, r4
 8018554:	f006 fee9 	bl	801f32a <crs_strlen>
 8018558:	b283      	uxth	r3, r0
 801855a:	4622      	mov	r2, r4
 801855c:	2101      	movs	r1, #1
 801855e:	2007      	movs	r0, #7
 8018560:	f006 ff26 	bl	801f3b0 <traceIF_itmPrint>
 8018564:	4620      	mov	r0, r4
 8018566:	f006 fee0 	bl	801f32a <crs_strlen>
 801856a:	b282      	uxth	r2, r0
 801856c:	4621      	mov	r1, r4
 801856e:	2007      	movs	r0, #7
 8018570:	f006 ff58 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\n\r");
 8018574:	4b5e      	ldr	r3, [pc, #376]	; (80186f0 <CST_ModemHelpCmd+0x684>)
 8018576:	6818      	ldr	r0, [r3, #0]
 8018578:	6020      	str	r0, [r4, #0]
 801857a:	791b      	ldrb	r3, [r3, #4]
 801857c:	7123      	strb	r3, [r4, #4]
 801857e:	4620      	mov	r0, r4
 8018580:	f006 fed3 	bl	801f32a <crs_strlen>
 8018584:	b283      	uxth	r3, r0
 8018586:	4622      	mov	r2, r4
 8018588:	2101      	movs	r1, #1
 801858a:	2007      	movs	r0, #7
 801858c:	f006 ff10 	bl	801f3b0 <traceIF_itmPrint>
 8018590:	4620      	mov	r0, r4
 8018592:	f006 feca 	bl	801f32a <crs_strlen>
 8018596:	b282      	uxth	r2, r0
 8018598:	4621      	mov	r1, r4
 801859a:	2007      	movs	r0, #7
 801859c:	f006 ff42 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("------")
 80185a0:	4d54      	ldr	r5, [pc, #336]	; (80186f4 <CST_ModemHelpCmd+0x688>)
 80185a2:	462b      	mov	r3, r5
 80185a4:	cb03      	ldmia	r3!, {r0, r1}
 80185a6:	6020      	str	r0, [r4, #0]
 80185a8:	6061      	str	r1, [r4, #4]
 80185aa:	781e      	ldrb	r6, [r3, #0]
 80185ac:	7226      	strb	r6, [r4, #8]
 80185ae:	4620      	mov	r0, r4
 80185b0:	f006 febb 	bl	801f32a <crs_strlen>
 80185b4:	b283      	uxth	r3, r0
 80185b6:	4622      	mov	r2, r4
 80185b8:	2101      	movs	r1, #1
 80185ba:	2007      	movs	r0, #7
 80185bc:	f006 fef8 	bl	801f3b0 <traceIF_itmPrint>
 80185c0:	4620      	mov	r0, r4
 80185c2:	f006 feb2 	bl	801f32a <crs_strlen>
 80185c6:	b282      	uxth	r2, r0
 80185c8:	4621      	mov	r1, r4
 80185ca:	2007      	movs	r0, #7
 80185cc:	f006 ff2a 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("Notes:");
 80185d0:	4b49      	ldr	r3, [pc, #292]	; (80186f8 <CST_ModemHelpCmd+0x68c>)
 80185d2:	cb03      	ldmia	r3!, {r0, r1}
 80185d4:	6020      	str	r0, [r4, #0]
 80185d6:	6061      	str	r1, [r4, #4]
 80185d8:	781b      	ldrb	r3, [r3, #0]
 80185da:	7223      	strb	r3, [r4, #8]
 80185dc:	4620      	mov	r0, r4
 80185de:	f006 fea4 	bl	801f32a <crs_strlen>
 80185e2:	b283      	uxth	r3, r0
 80185e4:	4622      	mov	r2, r4
 80185e6:	2101      	movs	r1, #1
 80185e8:	2007      	movs	r0, #7
 80185ea:	f006 fee1 	bl	801f3b0 <traceIF_itmPrint>
 80185ee:	4620      	mov	r0, r4
 80185f0:	f006 fe9b 	bl	801f32a <crs_strlen>
 80185f4:	b282      	uxth	r2, r0
 80185f6:	4621      	mov	r1, r4
 80185f8:	2007      	movs	r0, #7
 80185fa:	f006 ff13 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("------")
 80185fe:	462b      	mov	r3, r5
 8018600:	cb03      	ldmia	r3!, {r0, r1}
 8018602:	6020      	str	r0, [r4, #0]
 8018604:	6061      	str	r1, [r4, #4]
 8018606:	7226      	strb	r6, [r4, #8]
 8018608:	4620      	mov	r0, r4
 801860a:	f006 fe8e 	bl	801f32a <crs_strlen>
 801860e:	b283      	uxth	r3, r0
 8018610:	4622      	mov	r2, r4
 8018612:	2101      	movs	r1, #1
 8018614:	2007      	movs	r0, #7
 8018616:	f006 fecb 	bl	801f3b0 <traceIF_itmPrint>
 801861a:	4620      	mov	r0, r4
 801861c:	f006 fe85 	bl	801f32a <crs_strlen>
 8018620:	b282      	uxth	r2, r0
 8018622:	4621      	mov	r1, r4
 8018624:	2007      	movs	r0, #7
 8018626:	f006 fefd 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("- To use these commands, it is advised to start firmware in 'Modem power on' mode");
 801862a:	2254      	movs	r2, #84	; 0x54
 801862c:	4933      	ldr	r1, [pc, #204]	; (80186fc <CST_ModemHelpCmd+0x690>)
 801862e:	4620      	mov	r0, r4
 8018630:	f00e fa5a 	bl	8026ae8 <memcpy>
 8018634:	4620      	mov	r0, r4
 8018636:	f006 fe78 	bl	801f32a <crs_strlen>
 801863a:	b283      	uxth	r3, r0
 801863c:	4622      	mov	r2, r4
 801863e:	2101      	movs	r1, #1
 8018640:	2007      	movs	r0, #7
 8018642:	f006 feb5 	bl	801f3b0 <traceIF_itmPrint>
 8018646:	4620      	mov	r0, r4
 8018648:	f006 fe6f 	bl	801f32a <crs_strlen>
 801864c:	b282      	uxth	r2, r0
 801864e:	4621      	mov	r1, r4
 8018650:	2007      	movs	r0, #7
 8018652:	f006 fee7 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("              (option '2' of the boot menu).");
 8018656:	4d2a      	ldr	r5, [pc, #168]	; (8018700 <CST_ModemHelpCmd+0x694>)
 8018658:	f105 0620 	add.w	r6, r5, #32
 801865c:	46ac      	mov	ip, r5
 801865e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8018662:	6020      	str	r0, [r4, #0]
 8018664:	6061      	str	r1, [r4, #4]
 8018666:	60a2      	str	r2, [r4, #8]
 8018668:	60e3      	str	r3, [r4, #12]
 801866a:	4665      	mov	r5, ip
 801866c:	3410      	adds	r4, #16
 801866e:	45b4      	cmp	ip, r6
 8018670:	d1f4      	bne.n	801865c <CST_ModemHelpCmd+0x5f0>
 8018672:	4663      	mov	r3, ip
 8018674:	cb07      	ldmia	r3!, {r0, r1, r2}
 8018676:	6020      	str	r0, [r4, #0]
 8018678:	6061      	str	r1, [r4, #4]
 801867a:	60a2      	str	r2, [r4, #8]
 801867c:	881a      	ldrh	r2, [r3, #0]
 801867e:	789b      	ldrb	r3, [r3, #2]
 8018680:	81a2      	strh	r2, [r4, #12]
 8018682:	73a3      	strb	r3, [r4, #14]
 8018684:	4c16      	ldr	r4, [pc, #88]	; (80186e0 <CST_ModemHelpCmd+0x674>)
 8018686:	4620      	mov	r0, r4
 8018688:	f006 fe4f 	bl	801f32a <crs_strlen>
 801868c:	b283      	uxth	r3, r0
 801868e:	4622      	mov	r2, r4
 8018690:	2101      	movs	r1, #1
 8018692:	2007      	movs	r0, #7
 8018694:	f006 fe8c 	bl	801f3b0 <traceIF_itmPrint>
 8018698:	4620      	mov	r0, r4
 801869a:	f006 fe46 	bl	801f32a <crs_strlen>
 801869e:	b282      	uxth	r2, r0
 80186a0:	4621      	mov	r1, r4
 80186a2:	2007      	movs	r0, #7
 80186a4:	f006 febe 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("- The new modem configuration is taken into account only after target reboot.");
 80186a8:	2250      	movs	r2, #80	; 0x50
 80186aa:	4916      	ldr	r1, [pc, #88]	; (8018704 <CST_ModemHelpCmd+0x698>)
 80186ac:	4620      	mov	r0, r4
 80186ae:	f00e fa1b 	bl	8026ae8 <memcpy>
 80186b2:	4620      	mov	r0, r4
 80186b4:	f006 fe39 	bl	801f32a <crs_strlen>
 80186b8:	b283      	uxth	r3, r0
 80186ba:	4622      	mov	r2, r4
 80186bc:	2101      	movs	r1, #1
 80186be:	2007      	movs	r0, #7
 80186c0:	f006 fe76 	bl	801f3b0 <traceIF_itmPrint>
 80186c4:	4620      	mov	r0, r4
 80186c6:	f006 fe30 	bl	801f32a <crs_strlen>
 80186ca:	b282      	uxth	r2, r0
 80186cc:	4621      	mov	r1, r4
 80186ce:	2007      	movs	r0, #7
 80186d0:	f006 fea8 	bl	801f424 <traceIF_uartPrintForce>
}
 80186d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80186d8:	08033310 	.word	0x08033310
 80186dc:	08033050 	.word	0x08033050
 80186e0:	20004ddc 	.word	0x20004ddc
 80186e4:	0803334c 	.word	0x0803334c
 80186e8:	08033048 	.word	0x08033048
 80186ec:	08033378 	.word	0x08033378
 80186f0:	08036cf4 	.word	0x08036cf4
 80186f4:	08033070 	.word	0x08033070
 80186f8:	080333bc 	.word	0x080333bc
 80186fc:	080333c8 	.word	0x080333c8
 8018700:	0803341c 	.word	0x0803341c
 8018704:	0803344c 	.word	0x0803344c

08018708 <cst_at_cmd_help>:
  * @brief  displays help of atcmd commands
  * @param  -
  * @retval -
  */
static void cst_at_cmd_help(void)
{
 8018708:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help(CST_cmd_at_label);
 801870a:	4d1a      	ldr	r5, [pc, #104]	; (8018774 <cst_at_cmd_help+0x6c>)
 801870c:	4628      	mov	r0, r5
 801870e:	f00a f953 	bl	80229b8 <CMD_print_help>

  PRINT_FORCE("%s timeout [<modem response timeout(ms) (default %d)>]", CST_cmd_at_label, CST_AT_TIMEOUT)
 8018712:	4c19      	ldr	r4, [pc, #100]	; (8018778 <cst_at_cmd_help+0x70>)
 8018714:	f241 3388 	movw	r3, #5000	; 0x1388
 8018718:	462a      	mov	r2, r5
 801871a:	4918      	ldr	r1, [pc, #96]	; (801877c <cst_at_cmd_help+0x74>)
 801871c:	4620      	mov	r0, r4
 801871e:	f00e f893 	bl	8026848 <sprintf>
 8018722:	4620      	mov	r0, r4
 8018724:	f006 fe01 	bl	801f32a <crs_strlen>
 8018728:	b283      	uxth	r3, r0
 801872a:	4622      	mov	r2, r4
 801872c:	2101      	movs	r1, #1
 801872e:	2007      	movs	r0, #7
 8018730:	f006 fe3e 	bl	801f3b0 <traceIF_itmPrint>
 8018734:	4620      	mov	r0, r4
 8018736:	f006 fdf8 	bl	801f32a <crs_strlen>
 801873a:	b282      	uxth	r2, r0
 801873c:	4621      	mov	r1, r4
 801873e:	2007      	movs	r0, #7
 8018740:	f006 fe70 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s <at command> (send an AT command to modem ex:atcmd AT+CSQ)", CST_cmd_at_label)
 8018744:	462a      	mov	r2, r5
 8018746:	490e      	ldr	r1, [pc, #56]	; (8018780 <cst_at_cmd_help+0x78>)
 8018748:	4620      	mov	r0, r4
 801874a:	f00e f87d 	bl	8026848 <sprintf>
 801874e:	4620      	mov	r0, r4
 8018750:	f006 fdeb 	bl	801f32a <crs_strlen>
 8018754:	b283      	uxth	r3, r0
 8018756:	4622      	mov	r2, r4
 8018758:	2101      	movs	r1, #1
 801875a:	2007      	movs	r0, #7
 801875c:	f006 fe28 	bl	801f3b0 <traceIF_itmPrint>
 8018760:	4620      	mov	r0, r4
 8018762:	f006 fde2 	bl	801f32a <crs_strlen>
 8018766:	b282      	uxth	r2, r0
 8018768:	4621      	mov	r1, r4
 801876a:	2007      	movs	r0, #7
 801876c:	f006 fe5a 	bl	801f424 <traceIF_uartPrintForce>
}
 8018770:	bd38      	pop	{r3, r4, r5, pc}
 8018772:	bf00      	nop
 8018774:	0803349c 	.word	0x0803349c
 8018778:	20004ddc 	.word	0x20004ddc
 801877c:	080334a4 	.word	0x080334a4
 8018780:	080334e0 	.word	0x080334e0

08018784 <CST_HelpCmd>:
{
 8018784:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help(CST_cmd_label);
 8018786:	4d92      	ldr	r5, [pc, #584]	; (80189d0 <CST_HelpCmd+0x24c>)
 8018788:	4628      	mov	r0, r5
 801878a:	f00a f915 	bl	80229b8 <CMD_print_help>
  PRINT_FORCE("%s help", (CRC_CHAR_t *)CST_cmd_label)
 801878e:	4c91      	ldr	r4, [pc, #580]	; (80189d4 <CST_HelpCmd+0x250>)
 8018790:	462a      	mov	r2, r5
 8018792:	4991      	ldr	r1, [pc, #580]	; (80189d8 <CST_HelpCmd+0x254>)
 8018794:	4620      	mov	r0, r4
 8018796:	f00e f857 	bl	8026848 <sprintf>
 801879a:	4620      	mov	r0, r4
 801879c:	f006 fdc5 	bl	801f32a <crs_strlen>
 80187a0:	b283      	uxth	r3, r0
 80187a2:	4622      	mov	r2, r4
 80187a4:	2101      	movs	r1, #1
 80187a6:	2007      	movs	r0, #7
 80187a8:	f006 fe02 	bl	801f3b0 <traceIF_itmPrint>
 80187ac:	4620      	mov	r0, r4
 80187ae:	f006 fdbc 	bl	801f32a <crs_strlen>
 80187b2:	b282      	uxth	r2, r0
 80187b4:	4621      	mov	r1, r4
 80187b6:	2007      	movs	r0, #7
 80187b8:	f006 fe34 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s state   (Displays the cellular and SIM state)", CST_cmd_label)
 80187bc:	462a      	mov	r2, r5
 80187be:	4987      	ldr	r1, [pc, #540]	; (80189dc <CST_HelpCmd+0x258>)
 80187c0:	4620      	mov	r0, r4
 80187c2:	f00e f841 	bl	8026848 <sprintf>
 80187c6:	4620      	mov	r0, r4
 80187c8:	f006 fdaf 	bl	801f32a <crs_strlen>
 80187cc:	b283      	uxth	r3, r0
 80187ce:	4622      	mov	r2, r4
 80187d0:	2101      	movs	r1, #1
 80187d2:	2007      	movs	r0, #7
 80187d4:	f006 fdec 	bl	801f3b0 <traceIF_itmPrint>
 80187d8:	4620      	mov	r0, r4
 80187da:	f006 fda6 	bl	801f32a <crs_strlen>
 80187de:	b282      	uxth	r2, r0
 80187e0:	4621      	mov	r1, r4
 80187e2:	2007      	movs	r0, #7
 80187e4:	f006 fe1e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s config  (Displays the cellular configuration used)", CST_cmd_label)
 80187e8:	462a      	mov	r2, r5
 80187ea:	497d      	ldr	r1, [pc, #500]	; (80189e0 <CST_HelpCmd+0x25c>)
 80187ec:	4620      	mov	r0, r4
 80187ee:	f00e f82b 	bl	8026848 <sprintf>
 80187f2:	4620      	mov	r0, r4
 80187f4:	f006 fd99 	bl	801f32a <crs_strlen>
 80187f8:	b283      	uxth	r3, r0
 80187fa:	4622      	mov	r2, r4
 80187fc:	2101      	movs	r1, #1
 80187fe:	2007      	movs	r0, #7
 8018800:	f006 fdd6 	bl	801f3b0 <traceIF_itmPrint>
 8018804:	4620      	mov	r0, r4
 8018806:	f006 fd90 	bl	801f32a <crs_strlen>
 801880a:	b282      	uxth	r2, r0
 801880c:	4621      	mov	r1, r4
 801880e:	2007      	movs	r0, #7
 8018810:	f006 fe08 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s info    (Displays modem information)", CST_cmd_label)
 8018814:	462a      	mov	r2, r5
 8018816:	4973      	ldr	r1, [pc, #460]	; (80189e4 <CST_HelpCmd+0x260>)
 8018818:	4620      	mov	r0, r4
 801881a:	f00e f815 	bl	8026848 <sprintf>
 801881e:	4620      	mov	r0, r4
 8018820:	f006 fd83 	bl	801f32a <crs_strlen>
 8018824:	b283      	uxth	r3, r0
 8018826:	4622      	mov	r2, r4
 8018828:	2101      	movs	r1, #1
 801882a:	2007      	movs	r0, #7
 801882c:	f006 fdc0 	bl	801f3b0 <traceIF_itmPrint>
 8018830:	4620      	mov	r0, r4
 8018832:	f006 fd7a 	bl	801f32a <crs_strlen>
 8018836:	b282      	uxth	r2, r0
 8018838:	4621      	mov	r1, r4
 801883a:	2007      	movs	r0, #7
 801883c:	f006 fdf2 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s targetstate [off|sim|full] (set modem state)", CST_cmd_label)
 8018840:	462a      	mov	r2, r5
 8018842:	4969      	ldr	r1, [pc, #420]	; (80189e8 <CST_HelpCmd+0x264>)
 8018844:	4620      	mov	r0, r4
 8018846:	f00d ffff 	bl	8026848 <sprintf>
 801884a:	4620      	mov	r0, r4
 801884c:	f006 fd6d 	bl	801f32a <crs_strlen>
 8018850:	b283      	uxth	r3, r0
 8018852:	4622      	mov	r2, r4
 8018854:	2101      	movs	r1, #1
 8018856:	2007      	movs	r0, #7
 8018858:	f006 fdaa 	bl	801f3b0 <traceIF_itmPrint>
 801885c:	4620      	mov	r0, r4
 801885e:	f006 fd64 	bl	801f32a <crs_strlen>
 8018862:	b282      	uxth	r2, r0
 8018864:	4621      	mov	r1, r4
 8018866:	2007      	movs	r0, #7
 8018868:	f006 fddc 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s polling [on|off]  (enable/disable periodical modem polling)", CST_cmd_label)
 801886c:	462a      	mov	r2, r5
 801886e:	495f      	ldr	r1, [pc, #380]	; (80189ec <CST_HelpCmd+0x268>)
 8018870:	4620      	mov	r0, r4
 8018872:	f00d ffe9 	bl	8026848 <sprintf>
 8018876:	4620      	mov	r0, r4
 8018878:	f006 fd57 	bl	801f32a <crs_strlen>
 801887c:	b283      	uxth	r3, r0
 801887e:	4622      	mov	r2, r4
 8018880:	2101      	movs	r1, #1
 8018882:	2007      	movs	r0, #7
 8018884:	f006 fd94 	bl	801f3b0 <traceIF_itmPrint>
 8018888:	4620      	mov	r0, r4
 801888a:	f006 fd4e 	bl	801f32a <crs_strlen>
 801888e:	b282      	uxth	r2, r0
 8018890:	4621      	mov	r1, r4
 8018892:	2007      	movs	r0, #7
 8018894:	f006 fdc6 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s cmd  (switch to command mode)", CST_cmd_label)
 8018898:	462a      	mov	r2, r5
 801889a:	4955      	ldr	r1, [pc, #340]	; (80189f0 <CST_HelpCmd+0x26c>)
 801889c:	4620      	mov	r0, r4
 801889e:	f00d ffd3 	bl	8026848 <sprintf>
 80188a2:	4620      	mov	r0, r4
 80188a4:	f006 fd41 	bl	801f32a <crs_strlen>
 80188a8:	b283      	uxth	r3, r0
 80188aa:	4622      	mov	r2, r4
 80188ac:	2101      	movs	r1, #1
 80188ae:	2007      	movs	r0, #7
 80188b0:	f006 fd7e 	bl	801f3b0 <traceIF_itmPrint>
 80188b4:	4620      	mov	r0, r4
 80188b6:	f006 fd38 	bl	801f32a <crs_strlen>
 80188ba:	b282      	uxth	r2, r0
 80188bc:	4621      	mov	r1, r4
 80188be:	2007      	movs	r0, #7
 80188c0:	f006 fdb0 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s data  (switch to data mode)", CST_cmd_label)
 80188c4:	462a      	mov	r2, r5
 80188c6:	494b      	ldr	r1, [pc, #300]	; (80189f4 <CST_HelpCmd+0x270>)
 80188c8:	4620      	mov	r0, r4
 80188ca:	f00d ffbd 	bl	8026848 <sprintf>
 80188ce:	4620      	mov	r0, r4
 80188d0:	f006 fd2b 	bl	801f32a <crs_strlen>
 80188d4:	b283      	uxth	r3, r0
 80188d6:	4622      	mov	r2, r4
 80188d8:	2101      	movs	r1, #1
 80188da:	2007      	movs	r0, #7
 80188dc:	f006 fd68 	bl	801f3b0 <traceIF_itmPrint>
 80188e0:	4620      	mov	r0, r4
 80188e2:	f006 fd22 	bl	801f32a <crs_strlen>
 80188e6:	b282      	uxth	r2, r0
 80188e8:	4621      	mov	r1, r4
 80188ea:	2007      	movs	r0, #7
 80188ec:	f006 fd9a 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s apnconf [<apn> [<cid> [<username> <password>]]]]  (update apn configuration of active sim slot)",
 80188f0:	462a      	mov	r2, r5
 80188f2:	4941      	ldr	r1, [pc, #260]	; (80189f8 <CST_HelpCmd+0x274>)
 80188f4:	4620      	mov	r0, r4
 80188f6:	f00d ffa7 	bl	8026848 <sprintf>
 80188fa:	4620      	mov	r0, r4
 80188fc:	f006 fd15 	bl	801f32a <crs_strlen>
 8018900:	b283      	uxth	r3, r0
 8018902:	4622      	mov	r2, r4
 8018904:	2101      	movs	r1, #1
 8018906:	2007      	movs	r0, #7
 8018908:	f006 fd52 	bl	801f3b0 <traceIF_itmPrint>
 801890c:	4620      	mov	r0, r4
 801890e:	f006 fd0c 	bl	801f32a <crs_strlen>
 8018912:	b282      	uxth	r2, r0
 8018914:	4621      	mov	r1, r4
 8018916:	2007      	movs	r0, #7
 8018918:	f006 fd84 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s power [on|off]  (modem switch ON or OFF)", CST_cmd_label)
 801891c:	462a      	mov	r2, r5
 801891e:	4937      	ldr	r1, [pc, #220]	; (80189fc <CST_HelpCmd+0x278>)
 8018920:	4620      	mov	r0, r4
 8018922:	f00d ff91 	bl	8026848 <sprintf>
 8018926:	4620      	mov	r0, r4
 8018928:	f006 fcff 	bl	801f32a <crs_strlen>
 801892c:	b283      	uxth	r3, r0
 801892e:	4622      	mov	r2, r4
 8018930:	2101      	movs	r1, #1
 8018932:	2007      	movs	r0, #7
 8018934:	f006 fd3c 	bl	801f3b0 <traceIF_itmPrint>
 8018938:	4620      	mov	r0, r4
 801893a:	f006 fcf6 	bl	801f32a <crs_strlen>
 801893e:	b282      	uxth	r2, r0
 8018940:	4621      	mov	r1, r4
 8018942:	2007      	movs	r0, #7
 8018944:	f006 fd6e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s operator  (operator selection)", CST_cmd_label)
 8018948:	462a      	mov	r2, r5
 801894a:	492d      	ldr	r1, [pc, #180]	; (8018a00 <CST_HelpCmd+0x27c>)
 801894c:	4620      	mov	r0, r4
 801894e:	f00d ff7b 	bl	8026848 <sprintf>
 8018952:	4620      	mov	r0, r4
 8018954:	f006 fce9 	bl	801f32a <crs_strlen>
 8018958:	b283      	uxth	r3, r0
 801895a:	4622      	mov	r2, r4
 801895c:	2101      	movs	r1, #1
 801895e:	2007      	movs	r0, #7
 8018960:	f006 fd26 	bl	801f3b0 <traceIF_itmPrint>
 8018964:	4620      	mov	r0, r4
 8018966:	f006 fce0 	bl	801f32a <crs_strlen>
 801896a:	b282      	uxth	r2, r0
 801896c:	4621      	mov	r1, r4
 801896e:	2007      	movs	r0, #7
 8018970:	f006 fd58 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s techno off", CST_cmd_label)
 8018974:	462a      	mov	r2, r5
 8018976:	4923      	ldr	r1, [pc, #140]	; (8018a04 <CST_HelpCmd+0x280>)
 8018978:	4620      	mov	r0, r4
 801897a:	f00d ff65 	bl	8026848 <sprintf>
 801897e:	4620      	mov	r0, r4
 8018980:	f006 fcd3 	bl	801f32a <crs_strlen>
 8018984:	b283      	uxth	r3, r0
 8018986:	4622      	mov	r2, r4
 8018988:	2101      	movs	r1, #1
 801898a:	2007      	movs	r0, #7
 801898c:	f006 fd10 	bl	801f3b0 <traceIF_itmPrint>
 8018990:	4620      	mov	r0, r4
 8018992:	f006 fcca 	bl	801f32a <crs_strlen>
 8018996:	b282      	uxth	r2, r0
 8018998:	4621      	mov	r1, r4
 801899a:	2007      	movs	r0, #7
 801899c:	f006 fd42 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s techno on [0 (GSM)|1 (GSM_COMPACT)|2 (UTRAN)|3(GSM EDGE)|4 (UTRAN HSDPA)|5 (UTRAN HSUPA)|\
 80189a0:	462a      	mov	r2, r5
 80189a2:	4919      	ldr	r1, [pc, #100]	; (8018a08 <CST_HelpCmd+0x284>)
 80189a4:	4620      	mov	r0, r4
 80189a6:	f00d ff4f 	bl	8026848 <sprintf>
 80189aa:	4620      	mov	r0, r4
 80189ac:	f006 fcbd 	bl	801f32a <crs_strlen>
 80189b0:	b283      	uxth	r3, r0
 80189b2:	4622      	mov	r2, r4
 80189b4:	2101      	movs	r1, #1
 80189b6:	2007      	movs	r0, #7
 80189b8:	f006 fcfa 	bl	801f3b0 <traceIF_itmPrint>
 80189bc:	4620      	mov	r0, r4
 80189be:	f006 fcb4 	bl	801f32a <crs_strlen>
 80189c2:	b282      	uxth	r2, r0
 80189c4:	4621      	mov	r1, r4
 80189c6:	2007      	movs	r0, #7
 80189c8:	f006 fd2c 	bl	801f424 <traceIF_uartPrintForce>
}
 80189cc:	bd38      	pop	{r3, r4, r5, pc}
 80189ce:	bf00      	nop
 80189d0:	08033520 	.word	0x08033520
 80189d4:	20004ddc 	.word	0x20004ddc
 80189d8:	08033524 	.word	0x08033524
 80189dc:	08033530 	.word	0x08033530
 80189e0:	08033564 	.word	0x08033564
 80189e4:	0803359c 	.word	0x0803359c
 80189e8:	080335c8 	.word	0x080335c8
 80189ec:	080335fc 	.word	0x080335fc
 80189f0:	08033640 	.word	0x08033640
 80189f4:	08033664 	.word	0x08033664
 80189f8:	08033688 	.word	0x08033688
 80189fc:	080336f0 	.word	0x080336f0
 8018a00:	08033720 	.word	0x08033720
 8018a04:	08033744 	.word	0x08033744
 8018a08:	08033754 	.word	0x08033754

08018a0c <CST_CMD_get_band_altair>:
{
 8018a0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018a0e:	4607      	mov	r7, r0
  nb_band = argc - 2U;
 8018a10:	1e8e      	subs	r6, r1, #2
  CST_CMD_band_count = 0U;
 8018a12:	2400      	movs	r4, #0
 8018a14:	4b15      	ldr	r3, [pc, #84]	; (8018a6c <CST_CMD_get_band_altair+0x60>)
 8018a16:	701c      	strb	r4, [r3, #0]
  (void)memset(CST_CMD_band_tab, 0, sizeof(CST_CMD_band_tab));
 8018a18:	4b15      	ldr	r3, [pc, #84]	; (8018a70 <CST_CMD_get_band_altair+0x64>)
 8018a1a:	601c      	str	r4, [r3, #0]
 8018a1c:	605c      	str	r4, [r3, #4]
 8018a1e:	609c      	str	r4, [r3, #8]
  leave = false;
 8018a20:	4625      	mov	r5, r4
  for (j = 0U ; (j < nb_band) && (leave == false) ; j++)
 8018a22:	e00a      	b.n	8018a3a <CST_CMD_get_band_altair+0x2e>
      band_value = (uint8_t)crs_atoi(&argv_p[current_arg][1]);
 8018a24:	3001      	adds	r0, #1
 8018a26:	f006 fc3b 	bl	801f2a0 <crs_atoi>
      if (band_value == 0U)
 8018a2a:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 8018a2e:	d10f      	bne.n	8018a50 <CST_CMD_get_band_altair+0x44>
        CST_CMD_band_count = 0U;
 8018a30:	4b0e      	ldr	r3, [pc, #56]	; (8018a6c <CST_CMD_get_band_altair+0x60>)
 8018a32:	2200      	movs	r2, #0
 8018a34:	701a      	strb	r2, [r3, #0]
        leave = true;
 8018a36:	2501      	movs	r5, #1
  for (j = 0U ; (j < nb_band) && (leave == false) ; j++)
 8018a38:	3401      	adds	r4, #1
 8018a3a:	42b4      	cmp	r4, r6
 8018a3c:	d20f      	bcs.n	8018a5e <CST_CMD_get_band_altair+0x52>
 8018a3e:	b975      	cbnz	r5, 8018a5e <CST_CMD_get_band_altair+0x52>
    current_arg = j + 2U;
 8018a40:	1ca3      	adds	r3, r4, #2
    if (argv_p[current_arg][0] == (uint8_t)'B')
 8018a42:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
 8018a46:	7802      	ldrb	r2, [r0, #0]
 8018a48:	2a42      	cmp	r2, #66	; 0x42
 8018a4a:	d0eb      	beq.n	8018a24 <CST_CMD_get_band_altair+0x18>
      leave = true;
 8018a4c:	2501      	movs	r5, #1
 8018a4e:	e7f3      	b.n	8018a38 <CST_CMD_get_band_altair+0x2c>
        CST_CMD_band_tab[CST_CMD_band_count] = band_value;
 8018a50:	4a06      	ldr	r2, [pc, #24]	; (8018a6c <CST_CMD_get_band_altair+0x60>)
 8018a52:	7813      	ldrb	r3, [r2, #0]
 8018a54:	4906      	ldr	r1, [pc, #24]	; (8018a70 <CST_CMD_get_band_altair+0x64>)
 8018a56:	54c8      	strb	r0, [r1, r3]
        CST_CMD_band_count++;
 8018a58:	3301      	adds	r3, #1
 8018a5a:	7013      	strb	r3, [r2, #0]
 8018a5c:	e7ec      	b.n	8018a38 <CST_CMD_get_band_altair+0x2c>
  if (CST_CMD_band_count == 0U)
 8018a5e:	4b03      	ldr	r3, [pc, #12]	; (8018a6c <CST_CMD_get_band_altair+0x60>)
 8018a60:	781b      	ldrb	r3, [r3, #0]
 8018a62:	b10b      	cbz	r3, 8018a68 <CST_CMD_get_band_altair+0x5c>
  ret = 0U;
 8018a64:	2000      	movs	r0, #0
}
 8018a66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ret = 1U;
 8018a68:	2001      	movs	r0, #1
  return ret;
 8018a6a:	e7fc      	b.n	8018a66 <CST_CMD_get_band_altair+0x5a>
 8018a6c:	20000046 	.word	0x20000046
 8018a70:	20000048 	.word	0x20000048

08018a74 <cst_at_command_handle>:
  * @brief  AT command line processing
  * @param  cmd_line_p - command line
  * @retval cmd_status_t - command result
  */
static cmd_status_t cst_at_command_handle(uint8_t *cmd_line_p)
{
 8018a74:	b538      	push	{r3, r4, r5, lr}
 8018a76:	4604      	mov	r4, r0
  CS_Status_t  cs_status ;
  static CS_direct_cmd_tx_t CST_direct_cmd_tx;

  cmd_status = CMD_OK;

  size =  crs_strlen(cmd_line_p) + 1U;
 8018a78:	f006 fc57 	bl	801f32a <crs_strlen>
 8018a7c:	1c42      	adds	r2, r0, #1
  if (size <= MAX_DIRECT_CMD_SIZE)
 8018a7e:	2a76      	cmp	r2, #118	; 0x76
 8018a80:	d90e      	bls.n	8018aa0 <cst_at_command_handle+0x2c>
    (void)memcpy(&CST_direct_cmd_tx.cmd_str[0],
                 (CRC_CHAR_t *)cmd_line_p,
                 size);
  }

  CST_direct_cmd_tx.cmd_size    = (uint16_t)crs_strlen(cmd_line_p);
 8018a82:	4620      	mov	r0, r4
 8018a84:	f006 fc51 	bl	801f32a <crs_strlen>
 8018a88:	4b14      	ldr	r3, [pc, #80]	; (8018adc <cst_at_command_handle+0x68>)
 8018a8a:	f8a3 0076 	strh.w	r0, [r3, #118]	; 0x76
  CST_direct_cmd_tx.cmd_timeout = cst_at_timeout;
 8018a8e:	4a14      	ldr	r2, [pc, #80]	; (8018ae0 <cst_at_command_handle+0x6c>)
 8018a90:	6812      	ldr	r2, [r2, #0]
 8018a92:	679a      	str	r2, [r3, #120]	; 0x78

  /* send the AT command to the modem */
  cs_status = osCDS_direct_cmd(&CST_direct_cmd_tx, CST_cellular_direct_cmd_callback);
 8018a94:	4913      	ldr	r1, [pc, #76]	; (8018ae4 <cst_at_command_handle+0x70>)
 8018a96:	4618      	mov	r0, r3
 8018a98:	f002 f9aa 	bl	801adf0 <osCDS_direct_cmd>
  if (cs_status != CELLULAR_OK)
 8018a9c:	b928      	cbnz	r0, 8018aaa <cst_at_command_handle+0x36>
    /* AT command failed */
    PRINT_FORCE("\n\r%s command FAIL\n\r", cmd_line_p)
    cmd_status = CMD_PROCESS_ERROR;
  }
  return cmd_status;
}
 8018a9e:	bd38      	pop	{r3, r4, r5, pc}
    (void)memcpy(&CST_direct_cmd_tx.cmd_str[0],
 8018aa0:	4621      	mov	r1, r4
 8018aa2:	480e      	ldr	r0, [pc, #56]	; (8018adc <cst_at_command_handle+0x68>)
 8018aa4:	f00e f820 	bl	8026ae8 <memcpy>
 8018aa8:	e7eb      	b.n	8018a82 <cst_at_command_handle+0xe>
    PRINT_FORCE("\n\r%s command FAIL\n\r", cmd_line_p)
 8018aaa:	4d0f      	ldr	r5, [pc, #60]	; (8018ae8 <cst_at_command_handle+0x74>)
 8018aac:	4622      	mov	r2, r4
 8018aae:	490f      	ldr	r1, [pc, #60]	; (8018aec <cst_at_command_handle+0x78>)
 8018ab0:	4628      	mov	r0, r5
 8018ab2:	f00d fec9 	bl	8026848 <sprintf>
 8018ab6:	4628      	mov	r0, r5
 8018ab8:	f006 fc37 	bl	801f32a <crs_strlen>
 8018abc:	b283      	uxth	r3, r0
 8018abe:	462a      	mov	r2, r5
 8018ac0:	2101      	movs	r1, #1
 8018ac2:	2007      	movs	r0, #7
 8018ac4:	f006 fc74 	bl	801f3b0 <traceIF_itmPrint>
 8018ac8:	4628      	mov	r0, r5
 8018aca:	f006 fc2e 	bl	801f32a <crs_strlen>
 8018ace:	b282      	uxth	r2, r0
 8018ad0:	4629      	mov	r1, r5
 8018ad2:	2007      	movs	r0, #7
 8018ad4:	f006 fca6 	bl	801f424 <traceIF_uartPrintForce>
    cmd_status = CMD_PROCESS_ERROR;
 8018ad8:	2002      	movs	r0, #2
 8018ada:	e7e0      	b.n	8018a9e <cst_at_command_handle+0x2a>
 8018adc:	20003934 	.word	0x20003934
 8018ae0:	20000054 	.word	0x20000054
 8018ae4:	0801800d 	.word	0x0801800d
 8018ae8:	20004ddc 	.word	0x20004ddc
 8018aec:	08033814 	.word	0x08033814

08018af0 <CST_ModemCmd>:
{
 8018af0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8018af2:	b08f      	sub	sp, #60	; 0x3c
 8018af4:	4605      	mov	r5, r0
  PRINT_FORCE("\n\r")
 8018af6:	4c95      	ldr	r4, [pc, #596]	; (8018d4c <CST_ModemCmd+0x25c>)
 8018af8:	4b95      	ldr	r3, [pc, #596]	; (8018d50 <CST_ModemCmd+0x260>)
 8018afa:	6818      	ldr	r0, [r3, #0]
 8018afc:	6020      	str	r0, [r4, #0]
 8018afe:	791b      	ldrb	r3, [r3, #4]
 8018b00:	7123      	strb	r3, [r4, #4]
 8018b02:	4620      	mov	r0, r4
 8018b04:	f006 fc11 	bl	801f32a <crs_strlen>
 8018b08:	b283      	uxth	r3, r0
 8018b0a:	4622      	mov	r2, r4
 8018b0c:	2101      	movs	r1, #1
 8018b0e:	2007      	movs	r0, #7
 8018b10:	f006 fc4e 	bl	801f3b0 <traceIF_itmPrint>
 8018b14:	4620      	mov	r0, r4
 8018b16:	f006 fc08 	bl	801f32a <crs_strlen>
 8018b1a:	b282      	uxth	r2, r0
 8018b1c:	4621      	mov	r1, r4
 8018b1e:	2007      	movs	r0, #7
 8018b20:	f006 fc80 	bl	801f424 <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8018b24:	498b      	ldr	r1, [pc, #556]	; (8018d54 <CST_ModemCmd+0x264>)
 8018b26:	4628      	mov	r0, r5
 8018b28:	f00d ff1c 	bl	8026964 <strtok>
 8018b2c:	4605      	mov	r5, r0
             crs_strlen(cmd_p)) == 0)
 8018b2e:	f006 fbfc 	bl	801f32a <crs_strlen>
 8018b32:	4602      	mov	r2, r0
  if (memcmp((CRC_CHAR_t *)cmd_p,
 8018b34:	4988      	ldr	r1, [pc, #544]	; (8018d58 <CST_ModemCmd+0x268>)
 8018b36:	4628      	mov	r0, r5
 8018b38:	f00d fee9 	bl	802690e <memcmp>
 8018b3c:	b1d0      	cbz	r0, 8018b74 <CST_ModemCmd+0x84>
  cmd_status = CMD_OK;
 8018b3e:	2500      	movs	r5, #0
  PRINT_FORCE("")
 8018b40:	4c82      	ldr	r4, [pc, #520]	; (8018d4c <CST_ModemCmd+0x25c>)
 8018b42:	4b86      	ldr	r3, [pc, #536]	; (8018d5c <CST_ModemCmd+0x26c>)
 8018b44:	881a      	ldrh	r2, [r3, #0]
 8018b46:	789b      	ldrb	r3, [r3, #2]
 8018b48:	8022      	strh	r2, [r4, #0]
 8018b4a:	70a3      	strb	r3, [r4, #2]
 8018b4c:	4620      	mov	r0, r4
 8018b4e:	f006 fbec 	bl	801f32a <crs_strlen>
 8018b52:	b283      	uxth	r3, r0
 8018b54:	4622      	mov	r2, r4
 8018b56:	2101      	movs	r1, #1
 8018b58:	2007      	movs	r0, #7
 8018b5a:	f006 fc29 	bl	801f3b0 <traceIF_itmPrint>
 8018b5e:	4620      	mov	r0, r4
 8018b60:	f006 fbe3 	bl	801f32a <crs_strlen>
 8018b64:	b282      	uxth	r2, r0
 8018b66:	4621      	mov	r1, r4
 8018b68:	2007      	movs	r0, #7
 8018b6a:	f006 fc5b 	bl	801f424 <traceIF_uartPrintForce>
}
 8018b6e:	4628      	mov	r0, r5
 8018b70:	b00f      	add	sp, #60	; 0x3c
 8018b72:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (argc = 0U ; argc < CST_CMS_PARAM_MAX ; argc++)
 8018b74:	2400      	movs	r4, #0
 8018b76:	2c0c      	cmp	r4, #12
 8018b78:	d80b      	bhi.n	8018b92 <CST_ModemCmd+0xa2>
      argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 8018b7a:	4976      	ldr	r1, [pc, #472]	; (8018d54 <CST_ModemCmd+0x264>)
 8018b7c:	2000      	movs	r0, #0
 8018b7e:	f00d fef1 	bl	8026964 <strtok>
 8018b82:	ab0e      	add	r3, sp, #56	; 0x38
 8018b84:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8018b88:	f843 0c34 	str.w	r0, [r3, #-52]
      if (argv_p[argc] == NULL)
 8018b8c:	b108      	cbz	r0, 8018b92 <CST_ModemCmd+0xa2>
    for (argc = 0U ; argc < CST_CMS_PARAM_MAX ; argc++)
 8018b8e:	3401      	adds	r4, #1
 8018b90:	e7f1      	b.n	8018b76 <CST_ModemCmd+0x86>
    if (argc == 0U)
 8018b92:	b91c      	cbnz	r4, 8018b9c <CST_ModemCmd+0xac>
      CST_ModemHelpCmd();
 8018b94:	f7ff fa6a 	bl	801806c <CST_ModemHelpCmd>
  cmd_status = CMD_OK;
 8018b98:	2500      	movs	r5, #0
 8018b9a:	e7d1      	b.n	8018b40 <CST_ModemCmd+0x50>
    else if (memcmp((const CRC_CHAR_t *)argv_p[0], "help", crs_strlen(argv_p[0])) == 0)
 8018b9c:	9e01      	ldr	r6, [sp, #4]
 8018b9e:	4630      	mov	r0, r6
 8018ba0:	f006 fbc3 	bl	801f32a <crs_strlen>
 8018ba4:	4602      	mov	r2, r0
 8018ba6:	496e      	ldr	r1, [pc, #440]	; (8018d60 <CST_ModemCmd+0x270>)
 8018ba8:	4630      	mov	r0, r6
 8018baa:	f00d feb0 	bl	802690e <memcmp>
 8018bae:	b918      	cbnz	r0, 8018bb8 <CST_ModemCmd+0xc8>
      CST_ModemHelpCmd();
 8018bb0:	f7ff fa5c 	bl	801806c <CST_ModemHelpCmd>
  cmd_status = CMD_OK;
 8018bb4:	2500      	movs	r5, #0
 8018bb6:	e7c3      	b.n	8018b40 <CST_ModemCmd+0x50>
    else if (memcmp((const CRC_CHAR_t *)argv_p[0],
 8018bb8:	9e01      	ldr	r6, [sp, #4]
                    crs_strlen(argv_p[0]))
 8018bba:	4630      	mov	r0, r6
 8018bbc:	f006 fbb5 	bl	801f32a <crs_strlen>
 8018bc0:	4602      	mov	r2, r0
    else if (memcmp((const CRC_CHAR_t *)argv_p[0],
 8018bc2:	4968      	ldr	r1, [pc, #416]	; (8018d64 <CST_ModemCmd+0x274>)
 8018bc4:	4630      	mov	r0, r6
 8018bc6:	f00d fea2 	bl	802690e <memcmp>
 8018bca:	2800      	cmp	r0, #0
 8018bcc:	f040 81ca 	bne.w	8018f64 <CST_ModemCmd+0x474>
      if (argc == 1U)
 8018bd0:	2c01      	cmp	r4, #1
 8018bd2:	d010      	beq.n	8018bf6 <CST_ModemCmd+0x106>
      else if (memcmp((const CRC_CHAR_t *)argv_p[1],
 8018bd4:	9e02      	ldr	r6, [sp, #8]
                      crs_strlen(argv_p[1]))
 8018bd6:	4630      	mov	r0, r6
 8018bd8:	f006 fba7 	bl	801f32a <crs_strlen>
 8018bdc:	4602      	mov	r2, r0
      else if (memcmp((const CRC_CHAR_t *)argv_p[1],
 8018bde:	4962      	ldr	r1, [pc, #392]	; (8018d68 <CST_ModemCmd+0x278>)
 8018be0:	4630      	mov	r0, r6
 8018be2:	f00d fe94 	bl	802690e <memcmp>
 8018be6:	2800      	cmp	r0, #0
 8018be8:	d16f      	bne.n	8018cca <CST_ModemCmd+0x1da>
        if (argc >= 3U)
 8018bea:	2c02      	cmp	r4, #2
 8018bec:	d821      	bhi.n	8018c32 <CST_ModemCmd+0x142>
  cmd_status = CMD_OK;
 8018bee:	2500      	movs	r5, #0
        CST_CMD_display_bitmap_name_altair();
 8018bf0:	f7ff fa12 	bl	8018018 <CST_CMD_display_bitmap_name_altair>
 8018bf4:	e7a4      	b.n	8018b40 <CST_ModemCmd+0x50>
        PRINT_FORCE("bands : ")
 8018bf6:	4c55      	ldr	r4, [pc, #340]	; (8018d4c <CST_ModemCmd+0x25c>)
 8018bf8:	4b5c      	ldr	r3, [pc, #368]	; (8018d6c <CST_ModemCmd+0x27c>)
 8018bfa:	cb03      	ldmia	r3!, {r0, r1}
 8018bfc:	6020      	str	r0, [r4, #0]
 8018bfe:	6061      	str	r1, [r4, #4]
 8018c00:	881a      	ldrh	r2, [r3, #0]
 8018c02:	789b      	ldrb	r3, [r3, #2]
 8018c04:	8122      	strh	r2, [r4, #8]
 8018c06:	72a3      	strb	r3, [r4, #10]
 8018c08:	4620      	mov	r0, r4
 8018c0a:	f006 fb8e 	bl	801f32a <crs_strlen>
 8018c0e:	b283      	uxth	r3, r0
 8018c10:	4622      	mov	r2, r4
 8018c12:	2101      	movs	r1, #1
 8018c14:	2007      	movs	r0, #7
 8018c16:	f006 fbcb 	bl	801f3b0 <traceIF_itmPrint>
 8018c1a:	4620      	mov	r0, r4
 8018c1c:	f006 fb85 	bl	801f32a <crs_strlen>
 8018c20:	b282      	uxth	r2, r0
 8018c22:	4621      	mov	r1, r4
 8018c24:	2007      	movs	r0, #7
 8018c26:	f006 fbfd 	bl	801f424 <traceIF_uartPrintForce>
        CST_CMD_display_bitmap_name_altair();
 8018c2a:	f7ff f9f5 	bl	8018018 <CST_CMD_display_bitmap_name_altair>
  cmd_status = CMD_OK;
 8018c2e:	2500      	movs	r5, #0
 8018c30:	e786      	b.n	8018b40 <CST_ModemCmd+0x50>
          ret = CST_CMD_get_band_altair(argv_p,  argc);
 8018c32:	4621      	mov	r1, r4
 8018c34:	a801      	add	r0, sp, #4
 8018c36:	f7ff fee9 	bl	8018a0c <CST_CMD_get_band_altair>
          if (ret != 0U)
 8018c3a:	b908      	cbnz	r0, 8018c40 <CST_ModemCmd+0x150>
  cmd_status = CMD_OK;
 8018c3c:	2500      	movs	r5, #0
 8018c3e:	e7d7      	b.n	8018bf0 <CST_ModemCmd+0x100>
            PRINT_FORCE("%s Bad parameter", CST_cmd_modem_label)
 8018c40:	4c42      	ldr	r4, [pc, #264]	; (8018d4c <CST_ModemCmd+0x25c>)
 8018c42:	4a45      	ldr	r2, [pc, #276]	; (8018d58 <CST_ModemCmd+0x268>)
 8018c44:	494a      	ldr	r1, [pc, #296]	; (8018d70 <CST_ModemCmd+0x280>)
 8018c46:	4620      	mov	r0, r4
 8018c48:	f00d fdfe 	bl	8026848 <sprintf>
 8018c4c:	4620      	mov	r0, r4
 8018c4e:	f006 fb6c 	bl	801f32a <crs_strlen>
 8018c52:	b283      	uxth	r3, r0
 8018c54:	4622      	mov	r2, r4
 8018c56:	2101      	movs	r1, #1
 8018c58:	2007      	movs	r0, #7
 8018c5a:	f006 fba9 	bl	801f3b0 <traceIF_itmPrint>
 8018c5e:	4620      	mov	r0, r4
 8018c60:	f006 fb63 	bl	801f32a <crs_strlen>
 8018c64:	b282      	uxth	r2, r0
 8018c66:	4621      	mov	r1, r4
 8018c68:	2007      	movs	r0, #7
 8018c6a:	f006 fbdb 	bl	801f424 <traceIF_uartPrintForce>
            PRINT_FORCE("Usage: config m1band [B1] [B2] [B3] [B4] [B5] [B8] [B12] [B13] [B14] [B17]");
 8018c6e:	224d      	movs	r2, #77	; 0x4d
 8018c70:	4940      	ldr	r1, [pc, #256]	; (8018d74 <CST_ModemCmd+0x284>)
 8018c72:	4620      	mov	r0, r4
 8018c74:	f00d ff38 	bl	8026ae8 <memcpy>
 8018c78:	4620      	mov	r0, r4
 8018c7a:	f006 fb56 	bl	801f32a <crs_strlen>
 8018c7e:	b283      	uxth	r3, r0
 8018c80:	4622      	mov	r2, r4
 8018c82:	2101      	movs	r1, #1
 8018c84:	2007      	movs	r0, #7
 8018c86:	f006 fb93 	bl	801f3b0 <traceIF_itmPrint>
 8018c8a:	4620      	mov	r0, r4
 8018c8c:	f006 fb4d 	bl	801f32a <crs_strlen>
 8018c90:	b282      	uxth	r2, r0
 8018c92:	4621      	mov	r1, r4
 8018c94:	2007      	movs	r0, #7
 8018c96:	f006 fbc5 	bl	801f424 <traceIF_uartPrintForce>
            PRINT_FORCE("                     [B18] [B19] [B20] [B26] [B28] [B39] [B66]  (12 bands max)");
 8018c9a:	2251      	movs	r2, #81	; 0x51
 8018c9c:	4936      	ldr	r1, [pc, #216]	; (8018d78 <CST_ModemCmd+0x288>)
 8018c9e:	4620      	mov	r0, r4
 8018ca0:	f00d ff22 	bl	8026ae8 <memcpy>
 8018ca4:	4620      	mov	r0, r4
 8018ca6:	f006 fb40 	bl	801f32a <crs_strlen>
 8018caa:	b283      	uxth	r3, r0
 8018cac:	4622      	mov	r2, r4
 8018cae:	2101      	movs	r1, #1
 8018cb0:	2007      	movs	r0, #7
 8018cb2:	f006 fb7d 	bl	801f3b0 <traceIF_itmPrint>
 8018cb6:	4620      	mov	r0, r4
 8018cb8:	f006 fb37 	bl	801f32a <crs_strlen>
 8018cbc:	b282      	uxth	r2, r0
 8018cbe:	4621      	mov	r1, r4
 8018cc0:	2007      	movs	r0, #7
 8018cc2:	f006 fbaf 	bl	801f424 <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 8018cc6:	2501      	movs	r5, #1
 8018cc8:	e792      	b.n	8018bf0 <CST_ModemCmd+0x100>
      else if (memcmp((const CRC_CHAR_t *)argv_p[1], "send", crs_strlen(argv_p[1])) == 0)
 8018cca:	9c02      	ldr	r4, [sp, #8]
 8018ccc:	4620      	mov	r0, r4
 8018cce:	f006 fb2c 	bl	801f32a <crs_strlen>
 8018cd2:	4602      	mov	r2, r0
 8018cd4:	4929      	ldr	r1, [pc, #164]	; (8018d7c <CST_ModemCmd+0x28c>)
 8018cd6:	4620      	mov	r0, r4
 8018cd8:	f00d fe19 	bl	802690e <memcmp>
 8018cdc:	2800      	cmp	r0, #0
 8018cde:	d15b      	bne.n	8018d98 <CST_ModemCmd+0x2a8>
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETCFG=\"BAND\"");
 8018ce0:	4927      	ldr	r1, [pc, #156]	; (8018d80 <CST_ModemCmd+0x290>)
 8018ce2:	4828      	ldr	r0, [pc, #160]	; (8018d84 <CST_ModemCmd+0x294>)
 8018ce4:	f00d fdb0 	bl	8026848 <sprintf>
        for (i = 0; i < CST_CMD_band_count; i++)
 8018ce8:	2400      	movs	r4, #0
 8018cea:	e008      	b.n	8018cfe <CST_ModemCmd+0x20e>
          (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "%s,\"%d\"", (CRC_CHAR_t *)CST_CMD_Command, CST_CMD_band_tab[i]);
 8018cec:	4825      	ldr	r0, [pc, #148]	; (8018d84 <CST_ModemCmd+0x294>)
 8018cee:	4b26      	ldr	r3, [pc, #152]	; (8018d88 <CST_ModemCmd+0x298>)
 8018cf0:	5d1b      	ldrb	r3, [r3, r4]
 8018cf2:	4602      	mov	r2, r0
 8018cf4:	4925      	ldr	r1, [pc, #148]	; (8018d8c <CST_ModemCmd+0x29c>)
 8018cf6:	f00d fda7 	bl	8026848 <sprintf>
        for (i = 0; i < CST_CMD_band_count; i++)
 8018cfa:	3401      	adds	r4, #1
 8018cfc:	b2e4      	uxtb	r4, r4
 8018cfe:	4b24      	ldr	r3, [pc, #144]	; (8018d90 <CST_ModemCmd+0x2a0>)
 8018d00:	781b      	ldrb	r3, [r3, #0]
 8018d02:	42a3      	cmp	r3, r4
 8018d04:	d8f2      	bhi.n	8018cec <CST_ModemCmd+0x1fc>
        ret = (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018d06:	481f      	ldr	r0, [pc, #124]	; (8018d84 <CST_ModemCmd+0x294>)
 8018d08:	f7ff feb4 	bl	8018a74 <cst_at_command_handle>
        if (ret != 0U)
 8018d0c:	4605      	mov	r5, r0
 8018d0e:	2800      	cmp	r0, #0
 8018d10:	f43f af16 	beq.w	8018b40 <CST_ModemCmd+0x50>
          PRINT_FORCE("command fail\n\r")
 8018d14:	4c0d      	ldr	r4, [pc, #52]	; (8018d4c <CST_ModemCmd+0x25c>)
 8018d16:	4d1f      	ldr	r5, [pc, #124]	; (8018d94 <CST_ModemCmd+0x2a4>)
 8018d18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018d1a:	6020      	str	r0, [r4, #0]
 8018d1c:	6061      	str	r1, [r4, #4]
 8018d1e:	60a2      	str	r2, [r4, #8]
 8018d20:	60e3      	str	r3, [r4, #12]
 8018d22:	782b      	ldrb	r3, [r5, #0]
 8018d24:	7423      	strb	r3, [r4, #16]
 8018d26:	4620      	mov	r0, r4
 8018d28:	f006 faff 	bl	801f32a <crs_strlen>
 8018d2c:	b283      	uxth	r3, r0
 8018d2e:	4622      	mov	r2, r4
 8018d30:	2101      	movs	r1, #1
 8018d32:	2007      	movs	r0, #7
 8018d34:	f006 fb3c 	bl	801f3b0 <traceIF_itmPrint>
 8018d38:	4620      	mov	r0, r4
 8018d3a:	f006 faf6 	bl	801f32a <crs_strlen>
 8018d3e:	b282      	uxth	r2, r0
 8018d40:	4621      	mov	r1, r4
 8018d42:	2007      	movs	r0, #7
 8018d44:	f006 fb6e 	bl	801f424 <traceIF_uartPrintForce>
          cmd_status = CMD_PROCESS_ERROR;
 8018d48:	2502      	movs	r5, #2
 8018d4a:	e6f9      	b.n	8018b40 <CST_ModemCmd+0x50>
 8018d4c:	20004ddc 	.word	0x20004ddc
 8018d50:	08036cf4 	.word	0x08036cf4
 8018d54:	0803382c 	.word	0x0803382c
 8018d58:	08033048 	.word	0x08033048
 8018d5c:	0802eac4 	.word	0x0802eac4
 8018d60:	08033830 	.word	0x08033830
 8018d64:	08033838 	.word	0x08033838
 8018d68:	0803384c 	.word	0x0803384c
 8018d6c:	08033840 	.word	0x08033840
 8018d70:	08033854 	.word	0x08033854
 8018d74:	08033868 	.word	0x08033868
 8018d78:	080338b8 	.word	0x080338b8
 8018d7c:	080373e8 	.word	0x080373e8
 8018d80:	0803390c 	.word	0x0803390c
 8018d84:	200038d0 	.word	0x200038d0
 8018d88:	20000048 	.word	0x20000048
 8018d8c:	08033920 	.word	0x08033920
 8018d90:	20000046 	.word	0x20000046
 8018d94:	08033928 	.word	0x08033928
      else if (memcmp((const CRC_CHAR_t *)argv_p[1], "lowpower", crs_strlen(argv_p[1])) == 0)
 8018d98:	9c02      	ldr	r4, [sp, #8]
 8018d9a:	4620      	mov	r0, r4
 8018d9c:	f006 fac5 	bl	801f32a <crs_strlen>
 8018da0:	4602      	mov	r2, r0
 8018da2:	497d      	ldr	r1, [pc, #500]	; (8018f98 <CST_ModemCmd+0x4a8>)
 8018da4:	4620      	mov	r0, r4
 8018da6:	f00d fdb2 	bl	802690e <memcmp>
 8018daa:	2800      	cmp	r0, #0
 8018dac:	d174      	bne.n	8018e98 <CST_ModemCmd+0x3a8>
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETACFG=\"pm.hifc.mode,A\"");
 8018dae:	4d7b      	ldr	r5, [pc, #492]	; (8018f9c <CST_ModemCmd+0x4ac>)
 8018db0:	497b      	ldr	r1, [pc, #492]	; (8018fa0 <CST_ModemCmd+0x4b0>)
 8018db2:	4628      	mov	r0, r5
 8018db4:	f00d fd48 	bl	8026848 <sprintf>
        ret = (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018db8:	4628      	mov	r0, r5
 8018dba:	f7ff fe5b 	bl	8018a74 <cst_at_command_handle>
 8018dbe:	4604      	mov	r4, r0
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETACFG=\"pm.conf.sleep_mode,enable\"");
 8018dc0:	4978      	ldr	r1, [pc, #480]	; (8018fa4 <CST_ModemCmd+0x4b4>)
 8018dc2:	4628      	mov	r0, r5
 8018dc4:	f00d fd40 	bl	8026848 <sprintf>
        ret |= (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018dc8:	4628      	mov	r0, r5
 8018dca:	f7ff fe53 	bl	8018a74 <cst_at_command_handle>
 8018dce:	4304      	orrs	r4, r0
 8018dd0:	b2e4      	uxtb	r4, r4
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%SETACFG=\"pm.conf.max_allowed_pm_mode,dh0\"");
 8018dd2:	4975      	ldr	r1, [pc, #468]	; (8018fa8 <CST_ModemCmd+0x4b8>)
 8018dd4:	4628      	mov	r0, r5
 8018dd6:	f00d fd37 	bl	8026848 <sprintf>
        ret |= (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018dda:	4628      	mov	r0, r5
 8018ddc:	f7ff fe4a 	bl	8018a74 <cst_at_command_handle>
 8018de0:	ea40 0504 	orr.w	r5, r0, r4
        if (ret != 0U)
 8018de4:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 8018de8:	d13a      	bne.n	8018e60 <CST_ModemCmd+0x370>
          PRINT_FORCE("\n\r")
 8018dea:	4c70      	ldr	r4, [pc, #448]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018dec:	4b70      	ldr	r3, [pc, #448]	; (8018fb0 <CST_ModemCmd+0x4c0>)
 8018dee:	6818      	ldr	r0, [r3, #0]
 8018df0:	6020      	str	r0, [r4, #0]
 8018df2:	791b      	ldrb	r3, [r3, #4]
 8018df4:	7123      	strb	r3, [r4, #4]
 8018df6:	4620      	mov	r0, r4
 8018df8:	f006 fa97 	bl	801f32a <crs_strlen>
 8018dfc:	b283      	uxth	r3, r0
 8018dfe:	4622      	mov	r2, r4
 8018e00:	2101      	movs	r1, #1
 8018e02:	2007      	movs	r0, #7
 8018e04:	f006 fad4 	bl	801f3b0 <traceIF_itmPrint>
 8018e08:	4620      	mov	r0, r4
 8018e0a:	f006 fa8e 	bl	801f32a <crs_strlen>
 8018e0e:	b282      	uxth	r2, r0
 8018e10:	4621      	mov	r1, r4
 8018e12:	2007      	movs	r0, #7
 8018e14:	f006 fb06 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("Low power capabilities enabled\n\r")
 8018e18:	4f66      	ldr	r7, [pc, #408]	; (8018fb4 <CST_ModemCmd+0x4c4>)
 8018e1a:	f107 0e20 	add.w	lr, r7, #32
 8018e1e:	463e      	mov	r6, r7
 8018e20:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8018e22:	6020      	str	r0, [r4, #0]
 8018e24:	6061      	str	r1, [r4, #4]
 8018e26:	60a2      	str	r2, [r4, #8]
 8018e28:	60e3      	str	r3, [r4, #12]
 8018e2a:	4637      	mov	r7, r6
 8018e2c:	3410      	adds	r4, #16
 8018e2e:	4576      	cmp	r6, lr
 8018e30:	d1f5      	bne.n	8018e1e <CST_ModemCmd+0x32e>
 8018e32:	8832      	ldrh	r2, [r6, #0]
 8018e34:	78b3      	ldrb	r3, [r6, #2]
 8018e36:	8022      	strh	r2, [r4, #0]
 8018e38:	70a3      	strb	r3, [r4, #2]
 8018e3a:	4c5c      	ldr	r4, [pc, #368]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018e3c:	4620      	mov	r0, r4
 8018e3e:	f006 fa74 	bl	801f32a <crs_strlen>
 8018e42:	b283      	uxth	r3, r0
 8018e44:	4622      	mov	r2, r4
 8018e46:	2101      	movs	r1, #1
 8018e48:	2007      	movs	r0, #7
 8018e4a:	f006 fab1 	bl	801f3b0 <traceIF_itmPrint>
 8018e4e:	4620      	mov	r0, r4
 8018e50:	f006 fa6b 	bl	801f32a <crs_strlen>
 8018e54:	b282      	uxth	r2, r0
 8018e56:	4621      	mov	r1, r4
 8018e58:	2007      	movs	r0, #7
 8018e5a:	f006 fae3 	bl	801f424 <traceIF_uartPrintForce>
 8018e5e:	e66f      	b.n	8018b40 <CST_ModemCmd+0x50>
          PRINT_FORCE("command fail\n\r")
 8018e60:	4c52      	ldr	r4, [pc, #328]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018e62:	4d55      	ldr	r5, [pc, #340]	; (8018fb8 <CST_ModemCmd+0x4c8>)
 8018e64:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018e66:	6020      	str	r0, [r4, #0]
 8018e68:	6061      	str	r1, [r4, #4]
 8018e6a:	60a2      	str	r2, [r4, #8]
 8018e6c:	60e3      	str	r3, [r4, #12]
 8018e6e:	782b      	ldrb	r3, [r5, #0]
 8018e70:	7423      	strb	r3, [r4, #16]
 8018e72:	4620      	mov	r0, r4
 8018e74:	f006 fa59 	bl	801f32a <crs_strlen>
 8018e78:	b283      	uxth	r3, r0
 8018e7a:	4622      	mov	r2, r4
 8018e7c:	2101      	movs	r1, #1
 8018e7e:	2007      	movs	r0, #7
 8018e80:	f006 fa96 	bl	801f3b0 <traceIF_itmPrint>
 8018e84:	4620      	mov	r0, r4
 8018e86:	f006 fa50 	bl	801f32a <crs_strlen>
 8018e8a:	b282      	uxth	r2, r0
 8018e8c:	4621      	mov	r1, r4
 8018e8e:	2007      	movs	r0, #7
 8018e90:	f006 fac8 	bl	801f424 <traceIF_uartPrintForce>
          cmd_status = CMD_PROCESS_ERROR;
 8018e94:	2502      	movs	r5, #2
 8018e96:	e653      	b.n	8018b40 <CST_ModemCmd+0x50>
      else if (memcmp((const CRC_CHAR_t *)argv_p[1], "get", crs_strlen(argv_p[1])) == 0)
 8018e98:	9c02      	ldr	r4, [sp, #8]
 8018e9a:	4620      	mov	r0, r4
 8018e9c:	f006 fa45 	bl	801f32a <crs_strlen>
 8018ea0:	4602      	mov	r2, r0
 8018ea2:	4946      	ldr	r1, [pc, #280]	; (8018fbc <CST_ModemCmd+0x4cc>)
 8018ea4:	4620      	mov	r0, r4
 8018ea6:	f00d fd32 	bl	802690e <memcmp>
 8018eaa:	2800      	cmp	r0, #0
 8018eac:	d140      	bne.n	8018f30 <CST_ModemCmd+0x440>
        PRINT_FORCE("GSM Bands:")
 8018eae:	4c3f      	ldr	r4, [pc, #252]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018eb0:	4b43      	ldr	r3, [pc, #268]	; (8018fc0 <CST_ModemCmd+0x4d0>)
 8018eb2:	cb07      	ldmia	r3!, {r0, r1, r2}
 8018eb4:	6020      	str	r0, [r4, #0]
 8018eb6:	6061      	str	r1, [r4, #4]
 8018eb8:	60a2      	str	r2, [r4, #8]
 8018eba:	781b      	ldrb	r3, [r3, #0]
 8018ebc:	7323      	strb	r3, [r4, #12]
 8018ebe:	4620      	mov	r0, r4
 8018ec0:	f006 fa33 	bl	801f32a <crs_strlen>
 8018ec4:	b283      	uxth	r3, r0
 8018ec6:	4622      	mov	r2, r4
 8018ec8:	2101      	movs	r1, #1
 8018eca:	2007      	movs	r0, #7
 8018ecc:	f006 fa70 	bl	801f3b0 <traceIF_itmPrint>
 8018ed0:	4620      	mov	r0, r4
 8018ed2:	f006 fa2a 	bl	801f32a <crs_strlen>
 8018ed6:	b282      	uxth	r2, r0
 8018ed8:	4621      	mov	r1, r4
 8018eda:	2007      	movs	r0, #7
 8018edc:	f006 faa2 	bl	801f424 <traceIF_uartPrintForce>
        (void)sprintf((CRC_CHAR_t *)CST_CMD_Command, "AT%%GETCFG=\"BAND\"");
 8018ee0:	4c2e      	ldr	r4, [pc, #184]	; (8018f9c <CST_ModemCmd+0x4ac>)
 8018ee2:	4938      	ldr	r1, [pc, #224]	; (8018fc4 <CST_ModemCmd+0x4d4>)
 8018ee4:	4620      	mov	r0, r4
 8018ee6:	f00d fcaf 	bl	8026848 <sprintf>
        ret = (uint32_t)cst_at_command_handle((uint8_t *)CST_CMD_Command);
 8018eea:	4620      	mov	r0, r4
 8018eec:	f7ff fdc2 	bl	8018a74 <cst_at_command_handle>
        if (ret != 0U)
 8018ef0:	4605      	mov	r5, r0
 8018ef2:	2800      	cmp	r0, #0
 8018ef4:	f43f ae24 	beq.w	8018b40 <CST_ModemCmd+0x50>
          PRINT_FORCE("command fail\n\r")
 8018ef8:	4c2c      	ldr	r4, [pc, #176]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018efa:	4d2f      	ldr	r5, [pc, #188]	; (8018fb8 <CST_ModemCmd+0x4c8>)
 8018efc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018efe:	6020      	str	r0, [r4, #0]
 8018f00:	6061      	str	r1, [r4, #4]
 8018f02:	60a2      	str	r2, [r4, #8]
 8018f04:	60e3      	str	r3, [r4, #12]
 8018f06:	782b      	ldrb	r3, [r5, #0]
 8018f08:	7423      	strb	r3, [r4, #16]
 8018f0a:	4620      	mov	r0, r4
 8018f0c:	f006 fa0d 	bl	801f32a <crs_strlen>
 8018f10:	b283      	uxth	r3, r0
 8018f12:	4622      	mov	r2, r4
 8018f14:	2101      	movs	r1, #1
 8018f16:	2007      	movs	r0, #7
 8018f18:	f006 fa4a 	bl	801f3b0 <traceIF_itmPrint>
 8018f1c:	4620      	mov	r0, r4
 8018f1e:	f006 fa04 	bl	801f32a <crs_strlen>
 8018f22:	b282      	uxth	r2, r0
 8018f24:	4621      	mov	r1, r4
 8018f26:	2007      	movs	r0, #7
 8018f28:	f006 fa7c 	bl	801f424 <traceIF_uartPrintForce>
          cmd_status = CMD_PROCESS_ERROR;
 8018f2c:	2502      	movs	r5, #2
 8018f2e:	e607      	b.n	8018b40 <CST_ModemCmd+0x50>
        PRINT_FORCE("bad command: %s %s\n\r", cmd_p, argv_p[0])
 8018f30:	4c1e      	ldr	r4, [pc, #120]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018f32:	9b01      	ldr	r3, [sp, #4]
 8018f34:	462a      	mov	r2, r5
 8018f36:	4924      	ldr	r1, [pc, #144]	; (8018fc8 <CST_ModemCmd+0x4d8>)
 8018f38:	4620      	mov	r0, r4
 8018f3a:	f00d fc85 	bl	8026848 <sprintf>
 8018f3e:	4620      	mov	r0, r4
 8018f40:	f006 f9f3 	bl	801f32a <crs_strlen>
 8018f44:	b283      	uxth	r3, r0
 8018f46:	4622      	mov	r2, r4
 8018f48:	2101      	movs	r1, #1
 8018f4a:	2007      	movs	r0, #7
 8018f4c:	f006 fa30 	bl	801f3b0 <traceIF_itmPrint>
 8018f50:	4620      	mov	r0, r4
 8018f52:	f006 f9ea 	bl	801f32a <crs_strlen>
 8018f56:	b282      	uxth	r2, r0
 8018f58:	4621      	mov	r1, r4
 8018f5a:	2007      	movs	r0, #7
 8018f5c:	f006 fa62 	bl	801f424 <traceIF_uartPrintForce>
        cmd_status = CMD_SYNTAX_ERROR;
 8018f60:	2501      	movs	r5, #1
 8018f62:	e5ed      	b.n	8018b40 <CST_ModemCmd+0x50>
      PRINT_FORCE("bad command: %s %s\n\r", cmd_p, argv_p[0])
 8018f64:	4c11      	ldr	r4, [pc, #68]	; (8018fac <CST_ModemCmd+0x4bc>)
 8018f66:	9b01      	ldr	r3, [sp, #4]
 8018f68:	462a      	mov	r2, r5
 8018f6a:	4917      	ldr	r1, [pc, #92]	; (8018fc8 <CST_ModemCmd+0x4d8>)
 8018f6c:	4620      	mov	r0, r4
 8018f6e:	f00d fc6b 	bl	8026848 <sprintf>
 8018f72:	4620      	mov	r0, r4
 8018f74:	f006 f9d9 	bl	801f32a <crs_strlen>
 8018f78:	b283      	uxth	r3, r0
 8018f7a:	4622      	mov	r2, r4
 8018f7c:	2101      	movs	r1, #1
 8018f7e:	2007      	movs	r0, #7
 8018f80:	f006 fa16 	bl	801f3b0 <traceIF_itmPrint>
 8018f84:	4620      	mov	r0, r4
 8018f86:	f006 f9d0 	bl	801f32a <crs_strlen>
 8018f8a:	b282      	uxth	r2, r0
 8018f8c:	4621      	mov	r1, r4
 8018f8e:	2007      	movs	r0, #7
 8018f90:	f006 fa48 	bl	801f424 <traceIF_uartPrintForce>
      cmd_status = CMD_SYNTAX_ERROR;
 8018f94:	2501      	movs	r5, #1
 8018f96:	e5d3      	b.n	8018b40 <CST_ModemCmd+0x50>
 8018f98:	0803393c 	.word	0x0803393c
 8018f9c:	200038d0 	.word	0x200038d0
 8018fa0:	08033948 	.word	0x08033948
 8018fa4:	08033968 	.word	0x08033968
 8018fa8:	08033990 	.word	0x08033990
 8018fac:	20004ddc 	.word	0x20004ddc
 8018fb0:	08036cf4 	.word	0x08036cf4
 8018fb4:	080339c0 	.word	0x080339c0
 8018fb8:	08033928 	.word	0x08033928
 8018fbc:	080339e4 	.word	0x080339e4
 8018fc0:	080339e8 	.word	0x080339e8
 8018fc4:	080339f8 	.word	0x080339f8
 8018fc8:	08033a0c 	.word	0x08033a0c

08018fcc <CST_AtCmd>:
  * @brief  AT command line management
  * @param  cmd_line_p - command line
  * @retval cmd_status_t - command result
  */
static cmd_status_t CST_AtCmd(uint8_t *cmd_line_p)
{
 8018fcc:	b530      	push	{r4, r5, lr}
 8018fce:	b08f      	sub	sp, #60	; 0x3c
  const uint8_t *cmd_p;

  cmd_status = CMD_OK;

  /* find an AT command */
  if (cmd_line_p != NULL)
 8018fd0:	2800      	cmp	r0, #0
 8018fd2:	d078      	beq.n	80190c6 <CST_AtCmd+0xfa>
 8018fd4:	4605      	mov	r5, r0
  {
    cmd_len = crs_strlen(cmd_line_p);
 8018fd6:	f006 f9a8 	bl	801f32a <crs_strlen>
    for (i = 0U ; i < cmd_len ; i++)
 8018fda:	2300      	movs	r3, #0
 8018fdc:	4283      	cmp	r3, r0
 8018fde:	d204      	bcs.n	8018fea <CST_AtCmd+0x1e>
    {
      if (cmd_line_p[i] == (uint8_t)' ')
 8018fe0:	5cea      	ldrb	r2, [r5, r3]
 8018fe2:	2a20      	cmp	r2, #32
 8018fe4:	d001      	beq.n	8018fea <CST_AtCmd+0x1e>
    for (i = 0U ; i < cmd_len ; i++)
 8018fe6:	3301      	adds	r3, #1
 8018fe8:	e7f8      	b.n	8018fdc <CST_AtCmd+0x10>
      {
        /* first blank found in the command line */
        break;
      }
    }
    i++;
 8018fea:	3301      	adds	r3, #1

    if (
 8018fec:	4298      	cmp	r0, r3
 8018fee:	d911      	bls.n	8019014 <CST_AtCmd+0x48>
      (i < cmd_len)
      &&
      (
        (memcmp((const CRC_CHAR_t *)&cmd_line_p[i], (const CRC_CHAR_t *)"at", 2) == 0)
 8018ff0:	18ec      	adds	r4, r5, r3
 8018ff2:	2202      	movs	r2, #2
 8018ff4:	4937      	ldr	r1, [pc, #220]	; (80190d4 <CST_AtCmd+0x108>)
 8018ff6:	4620      	mov	r0, r4
 8018ff8:	f00d fc89 	bl	802690e <memcmp>
      &&
 8018ffc:	b128      	cbz	r0, 801900a <CST_AtCmd+0x3e>
        ||
        (memcmp((const CRC_CHAR_t *)&cmd_line_p[i], (const CRC_CHAR_t *)"AT", 2) == 0)
 8018ffe:	2202      	movs	r2, #2
 8019000:	4935      	ldr	r1, [pc, #212]	; (80190d8 <CST_AtCmd+0x10c>)
 8019002:	4620      	mov	r0, r4
 8019004:	f00d fc83 	bl	802690e <memcmp>
        ||
 8019008:	b920      	cbnz	r0, 8019014 <CST_AtCmd+0x48>
      )
    )
    {
      /* AT command to process */
      cmd_status = cst_at_command_handle(&cmd_line_p[i]);
 801900a:	4620      	mov	r0, r4
 801900c:	f7ff fd32 	bl	8018a74 <cst_at_command_handle>
  {
    /* wrong command: displays help */
    cst_at_cmd_help();
  }
  return cmd_status;
}
 8019010:	b00f      	add	sp, #60	; 0x3c
 8019012:	bd30      	pop	{r4, r5, pc}
      cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8019014:	4931      	ldr	r1, [pc, #196]	; (80190dc <CST_AtCmd+0x110>)
 8019016:	4628      	mov	r0, r5
 8019018:	f00d fca4 	bl	8026964 <strtok>
      if (cmd_p != NULL)
 801901c:	4604      	mov	r4, r0
 801901e:	2800      	cmp	r0, #0
 8019020:	d04d      	beq.n	80190be <CST_AtCmd+0xf2>
                   crs_strlen(cmd_p))
 8019022:	f006 f982 	bl	801f32a <crs_strlen>
 8019026:	4602      	mov	r2, r0
        if (memcmp((const CRC_CHAR_t *)cmd_p,
 8019028:	492d      	ldr	r1, [pc, #180]	; (80190e0 <CST_AtCmd+0x114>)
 801902a:	4620      	mov	r0, r4
 801902c:	f00d fc6f 	bl	802690e <memcmp>
 8019030:	2800      	cmp	r0, #0
 8019032:	d140      	bne.n	80190b6 <CST_AtCmd+0xea>
          argv_p[0] = (uint8_t *)strtok(NULL, " \t");
 8019034:	4929      	ldr	r1, [pc, #164]	; (80190dc <CST_AtCmd+0x110>)
 8019036:	f00d fc95 	bl	8026964 <strtok>
 801903a:	4604      	mov	r4, r0
 801903c:	9001      	str	r0, [sp, #4]
          if (argv_p[0] != NULL)
 801903e:	2800      	cmp	r0, #0
 8019040:	d045      	beq.n	80190ce <CST_AtCmd+0x102>
            if (memcmp((CRC_CHAR_t *)argv_p[0], "help", crs_strlen(argv_p[0])) == 0)
 8019042:	f006 f972 	bl	801f32a <crs_strlen>
 8019046:	4602      	mov	r2, r0
 8019048:	4926      	ldr	r1, [pc, #152]	; (80190e4 <CST_AtCmd+0x118>)
 801904a:	4620      	mov	r0, r4
 801904c:	f00d fc5f 	bl	802690e <memcmp>
 8019050:	b918      	cbnz	r0, 801905a <CST_AtCmd+0x8e>
              cst_at_cmd_help();
 8019052:	f7ff fb59 	bl	8018708 <cst_at_cmd_help>
  cmd_status = CMD_OK;
 8019056:	2000      	movs	r0, #0
 8019058:	e7da      	b.n	8019010 <CST_AtCmd+0x44>
                            crs_strlen(argv_p[0]))
 801905a:	4620      	mov	r0, r4
 801905c:	f006 f965 	bl	801f32a <crs_strlen>
 8019060:	4602      	mov	r2, r0
            else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8019062:	4921      	ldr	r1, [pc, #132]	; (80190e8 <CST_AtCmd+0x11c>)
 8019064:	4620      	mov	r0, r4
 8019066:	f00d fc52 	bl	802690e <memcmp>
 801906a:	b108      	cbz	r0, 8019070 <CST_AtCmd+0xa4>
  cmd_status = CMD_OK;
 801906c:	2000      	movs	r0, #0
 801906e:	e7cf      	b.n	8019010 <CST_AtCmd+0x44>
              argv_p[1] = (uint8_t *)strtok(NULL, " \t");
 8019070:	491a      	ldr	r1, [pc, #104]	; (80190dc <CST_AtCmd+0x110>)
 8019072:	f00d fc77 	bl	8026964 <strtok>
 8019076:	9002      	str	r0, [sp, #8]
              if (argv_p[1] != NULL)
 8019078:	b118      	cbz	r0, 8019082 <CST_AtCmd+0xb6>
                cst_at_timeout = (uint32_t)crs_atoi(argv_p[1]);
 801907a:	f006 f911 	bl	801f2a0 <crs_atoi>
 801907e:	4b1b      	ldr	r3, [pc, #108]	; (80190ec <CST_AtCmd+0x120>)
 8019080:	6018      	str	r0, [r3, #0]
              PRINT_FORCE("at timeout : %ld\n\r", cst_at_timeout)
 8019082:	4c1b      	ldr	r4, [pc, #108]	; (80190f0 <CST_AtCmd+0x124>)
 8019084:	4b19      	ldr	r3, [pc, #100]	; (80190ec <CST_AtCmd+0x120>)
 8019086:	681a      	ldr	r2, [r3, #0]
 8019088:	491a      	ldr	r1, [pc, #104]	; (80190f4 <CST_AtCmd+0x128>)
 801908a:	4620      	mov	r0, r4
 801908c:	f00d fbdc 	bl	8026848 <sprintf>
 8019090:	4620      	mov	r0, r4
 8019092:	f006 f94a 	bl	801f32a <crs_strlen>
 8019096:	b283      	uxth	r3, r0
 8019098:	4622      	mov	r2, r4
 801909a:	2101      	movs	r1, #1
 801909c:	2007      	movs	r0, #7
 801909e:	f006 f987 	bl	801f3b0 <traceIF_itmPrint>
 80190a2:	4620      	mov	r0, r4
 80190a4:	f006 f941 	bl	801f32a <crs_strlen>
 80190a8:	b282      	uxth	r2, r0
 80190aa:	4621      	mov	r1, r4
 80190ac:	2007      	movs	r0, #7
 80190ae:	f006 f9b9 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 80190b2:	2000      	movs	r0, #0
 80190b4:	e7ac      	b.n	8019010 <CST_AtCmd+0x44>
          cst_at_cmd_help();
 80190b6:	f7ff fb27 	bl	8018708 <cst_at_cmd_help>
  cmd_status = CMD_OK;
 80190ba:	2000      	movs	r0, #0
 80190bc:	e7a8      	b.n	8019010 <CST_AtCmd+0x44>
        cst_at_cmd_help();
 80190be:	f7ff fb23 	bl	8018708 <cst_at_cmd_help>
  cmd_status = CMD_OK;
 80190c2:	2000      	movs	r0, #0
 80190c4:	e7a4      	b.n	8019010 <CST_AtCmd+0x44>
    cst_at_cmd_help();
 80190c6:	f7ff fb1f 	bl	8018708 <cst_at_cmd_help>
  cmd_status = CMD_OK;
 80190ca:	2000      	movs	r0, #0
 80190cc:	e7a0      	b.n	8019010 <CST_AtCmd+0x44>
 80190ce:	2000      	movs	r0, #0
 80190d0:	e79e      	b.n	8019010 <CST_AtCmd+0x44>
 80190d2:	bf00      	nop
 80190d4:	08033a24 	.word	0x08033a24
 80190d8:	08033a28 	.word	0x08033a28
 80190dc:	0803382c 	.word	0x0803382c
 80190e0:	0803349c 	.word	0x0803349c
 80190e4:	08033830 	.word	0x08033830
 80190e8:	08033a2c 	.word	0x08033a2c
 80190ec:	20000054 	.word	0x20000054
 80190f0:	20004ddc 	.word	0x20004ddc
 80190f4:	08033a34 	.word	0x08033a34

080190f8 <CST_cmd>:
{
 80190f8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80190fc:	b08f      	sub	sp, #60	; 0x3c
 80190fe:	4605      	mov	r5, r0
  PRINT_FORCE("\n\r")
 8019100:	4c88      	ldr	r4, [pc, #544]	; (8019324 <CST_cmd+0x22c>)
 8019102:	4b89      	ldr	r3, [pc, #548]	; (8019328 <CST_cmd+0x230>)
 8019104:	6818      	ldr	r0, [r3, #0]
 8019106:	6020      	str	r0, [r4, #0]
 8019108:	791b      	ldrb	r3, [r3, #4]
 801910a:	7123      	strb	r3, [r4, #4]
 801910c:	4620      	mov	r0, r4
 801910e:	f006 f90c 	bl	801f32a <crs_strlen>
 8019112:	b283      	uxth	r3, r0
 8019114:	4622      	mov	r2, r4
 8019116:	2101      	movs	r1, #1
 8019118:	2007      	movs	r0, #7
 801911a:	f006 f949 	bl	801f3b0 <traceIF_itmPrint>
 801911e:	4620      	mov	r0, r4
 8019120:	f006 f903 	bl	801f32a <crs_strlen>
 8019124:	b282      	uxth	r2, r0
 8019126:	4621      	mov	r1, r4
 8019128:	2007      	movs	r0, #7
 801912a:	f006 f97b 	bl	801f424 <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 801912e:	497f      	ldr	r1, [pc, #508]	; (801932c <CST_cmd+0x234>)
 8019130:	4628      	mov	r0, r5
 8019132:	f00d fc17 	bl	8026964 <strtok>
  if (cmd_p != NULL)
 8019136:	2800      	cmp	r0, #0
 8019138:	f001 80d8 	beq.w	801a2ec <CST_cmd+0x11f4>
 801913c:	4605      	mov	r5, r0
               crs_strlen(cmd_p))
 801913e:	f006 f8f4 	bl	801f32a <crs_strlen>
 8019142:	4602      	mov	r2, r0
    if (memcmp((CRC_CHAR_t *)cmd_p,
 8019144:	497a      	ldr	r1, [pc, #488]	; (8019330 <CST_cmd+0x238>)
 8019146:	4628      	mov	r0, r5
 8019148:	f00d fbe1 	bl	802690e <memcmp>
 801914c:	2800      	cmp	r0, #0
 801914e:	f041 80ad 	bne.w	801a2ac <CST_cmd+0x11b4>
      for (argc = 0U ; argc < CST_CMS_PARAM_MAX ; argc++)
 8019152:	2400      	movs	r4, #0
 8019154:	e000      	b.n	8019158 <CST_cmd+0x60>
 8019156:	3401      	adds	r4, #1
 8019158:	2c0c      	cmp	r4, #12
 801915a:	d80a      	bhi.n	8019172 <CST_cmd+0x7a>
        argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 801915c:	4973      	ldr	r1, [pc, #460]	; (801932c <CST_cmd+0x234>)
 801915e:	2000      	movs	r0, #0
 8019160:	f00d fc00 	bl	8026964 <strtok>
 8019164:	ab0e      	add	r3, sp, #56	; 0x38
 8019166:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 801916a:	f843 0c34 	str.w	r0, [r3, #-52]
        if (argv_p[argc] == NULL)
 801916e:	2800      	cmp	r0, #0
 8019170:	d1f1      	bne.n	8019156 <CST_cmd+0x5e>
      if (argc == 0U)
 8019172:	b924      	cbnz	r4, 801917e <CST_cmd+0x86>
        CST_HelpCmd();
 8019174:	f7ff fb06 	bl	8018784 <CST_HelpCmd>
  cmd_status = CMD_OK;
 8019178:	2500      	movs	r5, #0
 801917a:	f001 b8b8 	b.w	801a2ee <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0],  "help",  crs_strlen(argv_p[0])) == 0)
 801917e:	9e01      	ldr	r6, [sp, #4]
 8019180:	4630      	mov	r0, r6
 8019182:	f006 f8d2 	bl	801f32a <crs_strlen>
 8019186:	4602      	mov	r2, r0
 8019188:	496a      	ldr	r1, [pc, #424]	; (8019334 <CST_cmd+0x23c>)
 801918a:	4630      	mov	r0, r6
 801918c:	f00d fbbf 	bl	802690e <memcmp>
 8019190:	b920      	cbnz	r0, 801919c <CST_cmd+0xa4>
        CST_HelpCmd();
 8019192:	f7ff faf7 	bl	8018784 <CST_HelpCmd>
  cmd_status = CMD_OK;
 8019196:	2500      	movs	r5, #0
 8019198:	f001 b8a9 	b.w	801a2ee <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "polling", crs_strlen(argv_p[0])) == 0)
 801919c:	4630      	mov	r0, r6
 801919e:	f006 f8c4 	bl	801f32a <crs_strlen>
 80191a2:	4602      	mov	r2, r0
 80191a4:	4964      	ldr	r1, [pc, #400]	; (8019338 <CST_cmd+0x240>)
 80191a6:	4630      	mov	r0, r6
 80191a8:	f00d fbb1 	bl	802690e <memcmp>
 80191ac:	2800      	cmp	r0, #0
 80191ae:	d14a      	bne.n	8019246 <CST_cmd+0x14e>
        if (argc == 2U)
 80191b0:	2c02      	cmp	r4, #2
 80191b2:	d01c      	beq.n	80191ee <CST_cmd+0xf6>
        if (CST_polling_active == 0U)
 80191b4:	4b61      	ldr	r3, [pc, #388]	; (801933c <CST_cmd+0x244>)
 80191b6:	781b      	ldrb	r3, [r3, #0]
 80191b8:	bb5b      	cbnz	r3, 8019212 <CST_cmd+0x11a>
          PRINT_FORCE("%s polling disable", CST_cmd_label)
 80191ba:	4c5a      	ldr	r4, [pc, #360]	; (8019324 <CST_cmd+0x22c>)
 80191bc:	4a5c      	ldr	r2, [pc, #368]	; (8019330 <CST_cmd+0x238>)
 80191be:	4960      	ldr	r1, [pc, #384]	; (8019340 <CST_cmd+0x248>)
 80191c0:	4620      	mov	r0, r4
 80191c2:	f00d fb41 	bl	8026848 <sprintf>
 80191c6:	4620      	mov	r0, r4
 80191c8:	f006 f8af 	bl	801f32a <crs_strlen>
 80191cc:	b283      	uxth	r3, r0
 80191ce:	4622      	mov	r2, r4
 80191d0:	2101      	movs	r1, #1
 80191d2:	2007      	movs	r0, #7
 80191d4:	f006 f8ec 	bl	801f3b0 <traceIF_itmPrint>
 80191d8:	4620      	mov	r0, r4
 80191da:	f006 f8a6 	bl	801f32a <crs_strlen>
 80191de:	b282      	uxth	r2, r0
 80191e0:	4621      	mov	r1, r4
 80191e2:	2007      	movs	r0, #7
 80191e4:	f006 f91e 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 80191e8:	2500      	movs	r5, #0
 80191ea:	f001 b880 	b.w	801a2ee <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 80191ee:	9c02      	ldr	r4, [sp, #8]
 80191f0:	4620      	mov	r0, r4
 80191f2:	f006 f89a 	bl	801f32a <crs_strlen>
 80191f6:	4602      	mov	r2, r0
 80191f8:	4952      	ldr	r1, [pc, #328]	; (8019344 <CST_cmd+0x24c>)
 80191fa:	4620      	mov	r0, r4
 80191fc:	f00d fb87 	bl	802690e <memcmp>
 8019200:	b918      	cbnz	r0, 801920a <CST_cmd+0x112>
            CST_polling_active = false;
 8019202:	4b4e      	ldr	r3, [pc, #312]	; (801933c <CST_cmd+0x244>)
 8019204:	2200      	movs	r2, #0
 8019206:	701a      	strb	r2, [r3, #0]
 8019208:	e7d4      	b.n	80191b4 <CST_cmd+0xbc>
            CST_polling_active = true;
 801920a:	4b4c      	ldr	r3, [pc, #304]	; (801933c <CST_cmd+0x244>)
 801920c:	2201      	movs	r2, #1
 801920e:	701a      	strb	r2, [r3, #0]
 8019210:	e7d0      	b.n	80191b4 <CST_cmd+0xbc>
          PRINT_FORCE("%s polling enable", CST_cmd_label)
 8019212:	4c44      	ldr	r4, [pc, #272]	; (8019324 <CST_cmd+0x22c>)
 8019214:	4a46      	ldr	r2, [pc, #280]	; (8019330 <CST_cmd+0x238>)
 8019216:	494c      	ldr	r1, [pc, #304]	; (8019348 <CST_cmd+0x250>)
 8019218:	4620      	mov	r0, r4
 801921a:	f00d fb15 	bl	8026848 <sprintf>
 801921e:	4620      	mov	r0, r4
 8019220:	f006 f883 	bl	801f32a <crs_strlen>
 8019224:	b283      	uxth	r3, r0
 8019226:	4622      	mov	r2, r4
 8019228:	2101      	movs	r1, #1
 801922a:	2007      	movs	r0, #7
 801922c:	f006 f8c0 	bl	801f3b0 <traceIF_itmPrint>
 8019230:	4620      	mov	r0, r4
 8019232:	f006 f87a 	bl	801f32a <crs_strlen>
 8019236:	b282      	uxth	r2, r0
 8019238:	4621      	mov	r1, r4
 801923a:	2007      	movs	r0, #7
 801923c:	f006 f8f2 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8019240:	2500      	movs	r5, #0
 8019242:	f001 b854 	b.w	801a2ee <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "targetstate", crs_strlen(argv_p[0])) == 0)
 8019246:	4630      	mov	r0, r6
 8019248:	f006 f86f 	bl	801f32a <crs_strlen>
 801924c:	4602      	mov	r2, r0
 801924e:	493f      	ldr	r1, [pc, #252]	; (801934c <CST_cmd+0x254>)
 8019250:	4630      	mov	r0, r6
 8019252:	f00d fb5c 	bl	802690e <memcmp>
 8019256:	2800      	cmp	r0, #0
 8019258:	f040 8088 	bne.w	801936c <CST_cmd+0x274>
        if (argc == 2U)
 801925c:	2c02      	cmp	r4, #2
 801925e:	d002      	beq.n	8019266 <CST_cmd+0x16e>
  cmd_status = CMD_OK;
 8019260:	2500      	movs	r5, #0
 8019262:	f001 b844 	b.w	801a2ee <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 8019266:	9c02      	ldr	r4, [sp, #8]
 8019268:	4620      	mov	r0, r4
 801926a:	f006 f85e 	bl	801f32a <crs_strlen>
 801926e:	4602      	mov	r2, r0
 8019270:	4934      	ldr	r1, [pc, #208]	; (8019344 <CST_cmd+0x24c>)
 8019272:	4620      	mov	r0, r4
 8019274:	f00d fb4b 	bl	802690e <memcmp>
 8019278:	bb40      	cbnz	r0, 80192cc <CST_cmd+0x1d4>
            target_state.rt_state     = DC_SERVICE_ON;
 801927a:	4a35      	ldr	r2, [pc, #212]	; (8019350 <CST_cmd+0x258>)
 801927c:	2307      	movs	r3, #7
 801927e:	7213      	strb	r3, [r2, #8]
            target_state.target_state = DC_TARGET_STATE_OFF;
 8019280:	2300      	movs	r3, #0
 8019282:	7253      	strb	r3, [r2, #9]
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&target_state, sizeof(target_state));
 8019284:	230c      	movs	r3, #12
 8019286:	4933      	ldr	r1, [pc, #204]	; (8019354 <CST_cmd+0x25c>)
 8019288:	8809      	ldrh	r1, [r1, #0]
 801928a:	4833      	ldr	r0, [pc, #204]	; (8019358 <CST_cmd+0x260>)
 801928c:	f008 ff04 	bl	8022098 <dc_com_write>
          PRINT_FORCE("New modem target state   : %s", CST_TargetStateName_p[target_state.target_state])
 8019290:	4b2f      	ldr	r3, [pc, #188]	; (8019350 <CST_cmd+0x258>)
 8019292:	7a5a      	ldrb	r2, [r3, #9]
 8019294:	4c23      	ldr	r4, [pc, #140]	; (8019324 <CST_cmd+0x22c>)
 8019296:	4b31      	ldr	r3, [pc, #196]	; (801935c <CST_cmd+0x264>)
 8019298:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 801929c:	4930      	ldr	r1, [pc, #192]	; (8019360 <CST_cmd+0x268>)
 801929e:	4620      	mov	r0, r4
 80192a0:	f00d fad2 	bl	8026848 <sprintf>
 80192a4:	4620      	mov	r0, r4
 80192a6:	f006 f840 	bl	801f32a <crs_strlen>
 80192aa:	b283      	uxth	r3, r0
 80192ac:	4622      	mov	r2, r4
 80192ae:	2101      	movs	r1, #1
 80192b0:	2007      	movs	r0, #7
 80192b2:	f006 f87d 	bl	801f3b0 <traceIF_itmPrint>
 80192b6:	4620      	mov	r0, r4
 80192b8:	f006 f837 	bl	801f32a <crs_strlen>
 80192bc:	b282      	uxth	r2, r0
 80192be:	4621      	mov	r1, r4
 80192c0:	2007      	movs	r0, #7
 80192c2:	f006 f8af 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 80192c6:	2500      	movs	r5, #0
 80192c8:	f001 b811 	b.w	801a2ee <CST_cmd+0x11f6>
          else if (memcmp((CRC_CHAR_t *)argv_p[1], "sim", crs_strlen(argv_p[1])) == 0)
 80192cc:	4620      	mov	r0, r4
 80192ce:	f006 f82c 	bl	801f32a <crs_strlen>
 80192d2:	4602      	mov	r2, r0
 80192d4:	4923      	ldr	r1, [pc, #140]	; (8019364 <CST_cmd+0x26c>)
 80192d6:	4620      	mov	r0, r4
 80192d8:	f00d fb19 	bl	802690e <memcmp>
 80192dc:	b958      	cbnz	r0, 80192f6 <CST_cmd+0x1fe>
            target_state.rt_state     = DC_SERVICE_ON;
 80192de:	4a1c      	ldr	r2, [pc, #112]	; (8019350 <CST_cmd+0x258>)
 80192e0:	2307      	movs	r3, #7
 80192e2:	7213      	strb	r3, [r2, #8]
            target_state.target_state = DC_TARGET_STATE_SIM_ONLY;
 80192e4:	2301      	movs	r3, #1
 80192e6:	7253      	strb	r3, [r2, #9]
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&target_state, sizeof(target_state));
 80192e8:	230c      	movs	r3, #12
 80192ea:	491a      	ldr	r1, [pc, #104]	; (8019354 <CST_cmd+0x25c>)
 80192ec:	8809      	ldrh	r1, [r1, #0]
 80192ee:	481a      	ldr	r0, [pc, #104]	; (8019358 <CST_cmd+0x260>)
 80192f0:	f008 fed2 	bl	8022098 <dc_com_write>
 80192f4:	e7cc      	b.n	8019290 <CST_cmd+0x198>
          else if (memcmp((CRC_CHAR_t *)argv_p[1], "full", crs_strlen(argv_p[1])) == 0)
 80192f6:	4620      	mov	r0, r4
 80192f8:	f006 f817 	bl	801f32a <crs_strlen>
 80192fc:	4602      	mov	r2, r0
 80192fe:	491a      	ldr	r1, [pc, #104]	; (8019368 <CST_cmd+0x270>)
 8019300:	4620      	mov	r0, r4
 8019302:	f00d fb04 	bl	802690e <memcmp>
 8019306:	2800      	cmp	r0, #0
 8019308:	d1c2      	bne.n	8019290 <CST_cmd+0x198>
            target_state.rt_state     = DC_SERVICE_ON;
 801930a:	4a11      	ldr	r2, [pc, #68]	; (8019350 <CST_cmd+0x258>)
 801930c:	2307      	movs	r3, #7
 801930e:	7213      	strb	r3, [r2, #8]
            target_state.target_state = DC_TARGET_STATE_FULL;
 8019310:	2302      	movs	r3, #2
 8019312:	7253      	strb	r3, [r2, #9]
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&target_state, sizeof(target_state));
 8019314:	230c      	movs	r3, #12
 8019316:	490f      	ldr	r1, [pc, #60]	; (8019354 <CST_cmd+0x25c>)
 8019318:	8809      	ldrh	r1, [r1, #0]
 801931a:	480f      	ldr	r0, [pc, #60]	; (8019358 <CST_cmd+0x260>)
 801931c:	f008 febc 	bl	8022098 <dc_com_write>
 8019320:	e7b6      	b.n	8019290 <CST_cmd+0x198>
 8019322:	bf00      	nop
 8019324:	20004ddc 	.word	0x20004ddc
 8019328:	08036cf4 	.word	0x08036cf4
 801932c:	0803382c 	.word	0x0803382c
 8019330:	08033520 	.word	0x08033520
 8019334:	08033830 	.word	0x08033830
 8019338:	08033a60 	.word	0x08033a60
 801933c:	20003fac 	.word	0x20003fac
 8019340:	08033a6c 	.word	0x08033a6c
 8019344:	08033a68 	.word	0x08033a68
 8019348:	08033a84 	.word	0x08033a84
 801934c:	08033a98 	.word	0x08033a98
 8019350:	20003d0c 	.word	0x20003d0c
 8019354:	2000023e 	.word	0x2000023e
 8019358:	200058b0 	.word	0x200058b0
 801935c:	08034228 	.word	0x08034228
 8019360:	08033ab0 	.word	0x08033ab0
 8019364:	08033aa4 	.word	0x08033aa4
 8019368:	08033aa8 	.word	0x08033aa8
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "apnconf", crs_strlen(argv_p[0])) == 0)
 801936c:	4630      	mov	r0, r6
 801936e:	f005 ffdc 	bl	801f32a <crs_strlen>
 8019372:	4602      	mov	r2, r0
 8019374:	49b8      	ldr	r1, [pc, #736]	; (8019658 <CST_cmd+0x560>)
 8019376:	4630      	mov	r0, r6
 8019378:	f00d fac9 	bl	802690e <memcmp>
 801937c:	2800      	cmp	r0, #0
 801937e:	f040 8195 	bne.w	80196ac <CST_cmd+0x5b4>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 8019382:	4db6      	ldr	r5, [pc, #728]	; (801965c <CST_cmd+0x564>)
 8019384:	4fb6      	ldr	r7, [pc, #728]	; (8019660 <CST_cmd+0x568>)
 8019386:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801938a:	462a      	mov	r2, r5
 801938c:	49b5      	ldr	r1, [pc, #724]	; (8019664 <CST_cmd+0x56c>)
 801938e:	8809      	ldrh	r1, [r1, #0]
 8019390:	4638      	mov	r0, r7
 8019392:	f008 fecd 	bl	8022130 <dc_com_read>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_cmd_sim_info, sizeof(cst_cmd_sim_info));
 8019396:	4eb4      	ldr	r6, [pc, #720]	; (8019668 <CST_cmd+0x570>)
 8019398:	2330      	movs	r3, #48	; 0x30
 801939a:	4632      	mov	r2, r6
 801939c:	49b3      	ldr	r1, [pc, #716]	; (801966c <CST_cmd+0x574>)
 801939e:	8809      	ldrh	r1, [r1, #0]
 80193a0:	4638      	mov	r0, r7
 80193a2:	f008 fec5 	bl	8022130 <dc_com_read>
        apn_config.cid             = cst_cmd_cellular_params.sim_slot[cst_cmd_sim_info.index_slot].cid;
 80193a6:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 80193aa:	2262      	movs	r2, #98	; 0x62
 80193ac:	fb02 f303 	mul.w	r3, r2, r3
 80193b0:	18ea      	adds	r2, r5, r3
 80193b2:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
 80193b6:	4aae      	ldr	r2, [pc, #696]	; (8019670 <CST_cmd+0x578>)
 80193b8:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
        size =  crs_strlen(cst_cmd_cellular_params.sim_slot[cst_cmd_sim_info.index_slot].apn) + 1U;
 80193bc:	3308      	adds	r3, #8
 80193be:	18e8      	adds	r0, r5, r3
 80193c0:	3004      	adds	r0, #4
 80193c2:	f005 ffb2 	bl	801f32a <crs_strlen>
 80193c6:	1c42      	adds	r2, r0, #1
        if (size <= DC_MAX_SIZE_APN)
 80193c8:	2a20      	cmp	r2, #32
 80193ca:	f200 80a6 	bhi.w	801951a <CST_cmd+0x422>
          (void)memcpy(apn_config.apn, cst_cmd_cellular_params.sim_slot[cst_cmd_sim_info.index_slot].apn, size);
 80193ce:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 80193d2:	2162      	movs	r1, #98	; 0x62
 80193d4:	fb01 f303 	mul.w	r3, r1, r3
 80193d8:	3308      	adds	r3, #8
 80193da:	4629      	mov	r1, r5
 80193dc:	4419      	add	r1, r3
 80193de:	3104      	adds	r1, #4
 80193e0:	48a4      	ldr	r0, [pc, #656]	; (8019674 <CST_cmd+0x57c>)
 80193e2:	f00d fb81 	bl	8026ae8 <memcpy>
  cmd_status = CMD_OK;
 80193e6:	2500      	movs	r5, #0
        apn_config.username[0] = 0U;
 80193e8:	4ba1      	ldr	r3, [pc, #644]	; (8019670 <CST_cmd+0x578>)
 80193ea:	2200      	movs	r2, #0
 80193ec:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
        apn_config.password[0] = 0U;
 80193f0:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
        if (argc >= 5U)
 80193f4:	2c04      	cmp	r4, #4
 80193f6:	f200 80ab 	bhi.w	8019550 <CST_cmd+0x458>
        if (argc >= 4U)
 80193fa:	2c03      	cmp	r4, #3
 80193fc:	f200 80d2 	bhi.w	80195a4 <CST_cmd+0x4ac>
        if (argc >= 3U)
 8019400:	2c02      	cmp	r4, #2
 8019402:	f200 80f9 	bhi.w	80195f8 <CST_cmd+0x500>
        if (argc >= 2U)
 8019406:	2c01      	cmp	r4, #1
 8019408:	f200 80fd 	bhi.w	8019606 <CST_cmd+0x50e>
        if (cmd_status == CMD_OK)
 801940c:	2d00      	cmp	r5, #0
 801940e:	f040 876e 	bne.w	801a2ee <CST_cmd+0x11f6>
          apn_config.rt_state = DC_SERVICE_ON;
 8019412:	4f97      	ldr	r7, [pc, #604]	; (8019670 <CST_cmd+0x578>)
 8019414:	2607      	movs	r6, #7
 8019416:	723e      	strb	r6, [r7, #8]
          (void)dc_com_write(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&apn_config, sizeof(apn_config));
 8019418:	236c      	movs	r3, #108	; 0x6c
 801941a:	463a      	mov	r2, r7
 801941c:	4996      	ldr	r1, [pc, #600]	; (8019678 <CST_cmd+0x580>)
 801941e:	8809      	ldrh	r1, [r1, #0]
 8019420:	488f      	ldr	r0, [pc, #572]	; (8019660 <CST_cmd+0x568>)
 8019422:	f008 fe39 	bl	8022098 <dc_com_write>
          PRINT_FORCE("APN configuration vualues for the sim slot (%s):",
 8019426:	4b90      	ldr	r3, [pc, #576]	; (8019668 <CST_cmd+0x570>)
 8019428:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 801942c:	4c93      	ldr	r4, [pc, #588]	; (801967c <CST_cmd+0x584>)
 801942e:	4b94      	ldr	r3, [pc, #592]	; (8019680 <CST_cmd+0x588>)
 8019430:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019434:	4993      	ldr	r1, [pc, #588]	; (8019684 <CST_cmd+0x58c>)
 8019436:	4620      	mov	r0, r4
 8019438:	f00d fa06 	bl	8026848 <sprintf>
 801943c:	4620      	mov	r0, r4
 801943e:	f005 ff74 	bl	801f32a <crs_strlen>
 8019442:	b283      	uxth	r3, r0
 8019444:	4622      	mov	r2, r4
 8019446:	2101      	movs	r1, #1
 8019448:	4630      	mov	r0, r6
 801944a:	f005 ffb1 	bl	801f3b0 <traceIF_itmPrint>
 801944e:	4620      	mov	r0, r4
 8019450:	f005 ff6b 	bl	801f32a <crs_strlen>
 8019454:	b282      	uxth	r2, r0
 8019456:	4621      	mov	r1, r4
 8019458:	4630      	mov	r0, r6
 801945a:	f005 ffe3 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("APN                : %s", apn_config.apn)
 801945e:	f107 0209 	add.w	r2, r7, #9
 8019462:	4989      	ldr	r1, [pc, #548]	; (8019688 <CST_cmd+0x590>)
 8019464:	4620      	mov	r0, r4
 8019466:	f00d f9ef 	bl	8026848 <sprintf>
 801946a:	4620      	mov	r0, r4
 801946c:	f005 ff5d 	bl	801f32a <crs_strlen>
 8019470:	b283      	uxth	r3, r0
 8019472:	4622      	mov	r2, r4
 8019474:	2101      	movs	r1, #1
 8019476:	4630      	mov	r0, r6
 8019478:	f005 ff9a 	bl	801f3b0 <traceIF_itmPrint>
 801947c:	4620      	mov	r0, r4
 801947e:	f005 ff54 	bl	801f32a <crs_strlen>
 8019482:	b282      	uxth	r2, r0
 8019484:	4621      	mov	r1, r4
 8019486:	4630      	mov	r0, r6
 8019488:	f005 ffcc 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("CID                : %d", apn_config.cid)
 801948c:	f897 2029 	ldrb.w	r2, [r7, #41]	; 0x29
 8019490:	497e      	ldr	r1, [pc, #504]	; (801968c <CST_cmd+0x594>)
 8019492:	4620      	mov	r0, r4
 8019494:	f00d f9d8 	bl	8026848 <sprintf>
 8019498:	4620      	mov	r0, r4
 801949a:	f005 ff46 	bl	801f32a <crs_strlen>
 801949e:	b283      	uxth	r3, r0
 80194a0:	4622      	mov	r2, r4
 80194a2:	2101      	movs	r1, #1
 80194a4:	4630      	mov	r0, r6
 80194a6:	f005 ff83 	bl	801f3b0 <traceIF_itmPrint>
 80194aa:	4620      	mov	r0, r4
 80194ac:	f005 ff3d 	bl	801f32a <crs_strlen>
 80194b0:	b282      	uxth	r2, r0
 80194b2:	4621      	mov	r1, r4
 80194b4:	4630      	mov	r0, r6
 80194b6:	f005 ffb5 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("username           : %s", apn_config.username)
 80194ba:	f107 022a 	add.w	r2, r7, #42	; 0x2a
 80194be:	4974      	ldr	r1, [pc, #464]	; (8019690 <CST_cmd+0x598>)
 80194c0:	4620      	mov	r0, r4
 80194c2:	f00d f9c1 	bl	8026848 <sprintf>
 80194c6:	4620      	mov	r0, r4
 80194c8:	f005 ff2f 	bl	801f32a <crs_strlen>
 80194cc:	b283      	uxth	r3, r0
 80194ce:	4622      	mov	r2, r4
 80194d0:	2101      	movs	r1, #1
 80194d2:	4630      	mov	r0, r6
 80194d4:	f005 ff6c 	bl	801f3b0 <traceIF_itmPrint>
 80194d8:	4620      	mov	r0, r4
 80194da:	f005 ff26 	bl	801f32a <crs_strlen>
 80194de:	b282      	uxth	r2, r0
 80194e0:	4621      	mov	r1, r4
 80194e2:	4630      	mov	r0, r6
 80194e4:	f005 ff9e 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("password           : %s", apn_config.password)
 80194e8:	f107 024a 	add.w	r2, r7, #74	; 0x4a
 80194ec:	4969      	ldr	r1, [pc, #420]	; (8019694 <CST_cmd+0x59c>)
 80194ee:	4620      	mov	r0, r4
 80194f0:	f00d f9aa 	bl	8026848 <sprintf>
 80194f4:	4620      	mov	r0, r4
 80194f6:	f005 ff18 	bl	801f32a <crs_strlen>
 80194fa:	b283      	uxth	r3, r0
 80194fc:	4622      	mov	r2, r4
 80194fe:	2101      	movs	r1, #1
 8019500:	4630      	mov	r0, r6
 8019502:	f005 ff55 	bl	801f3b0 <traceIF_itmPrint>
 8019506:	4620      	mov	r0, r4
 8019508:	f005 ff0f 	bl	801f32a <crs_strlen>
 801950c:	b282      	uxth	r2, r0
 801950e:	4621      	mov	r1, r4
 8019510:	4630      	mov	r0, r6
 8019512:	f005 ff87 	bl	801f424 <traceIF_uartPrintForce>
 8019516:	f000 beea 	b.w	801a2ee <CST_cmd+0x11f6>
          PRINT_FORCE("APN to long")
 801951a:	4d58      	ldr	r5, [pc, #352]	; (801967c <CST_cmd+0x584>)
 801951c:	4b5e      	ldr	r3, [pc, #376]	; (8019698 <CST_cmd+0x5a0>)
 801951e:	cb07      	ldmia	r3!, {r0, r1, r2}
 8019520:	6028      	str	r0, [r5, #0]
 8019522:	6069      	str	r1, [r5, #4]
 8019524:	60aa      	str	r2, [r5, #8]
 8019526:	881b      	ldrh	r3, [r3, #0]
 8019528:	81ab      	strh	r3, [r5, #12]
 801952a:	4628      	mov	r0, r5
 801952c:	f005 fefd 	bl	801f32a <crs_strlen>
 8019530:	b283      	uxth	r3, r0
 8019532:	462a      	mov	r2, r5
 8019534:	2101      	movs	r1, #1
 8019536:	2007      	movs	r0, #7
 8019538:	f005 ff3a 	bl	801f3b0 <traceIF_itmPrint>
 801953c:	4628      	mov	r0, r5
 801953e:	f005 fef4 	bl	801f32a <crs_strlen>
 8019542:	b282      	uxth	r2, r0
 8019544:	4629      	mov	r1, r5
 8019546:	2007      	movs	r0, #7
 8019548:	f005 ff6c 	bl	801f424 <traceIF_uartPrintForce>
          cmd_status = CMD_SYNTAX_ERROR;
 801954c:	2501      	movs	r5, #1
 801954e:	e74b      	b.n	80193e8 <CST_cmd+0x2f0>
          size =  crs_strlen(argv_p[4]) + 1U;
 8019550:	9e05      	ldr	r6, [sp, #20]
 8019552:	4630      	mov	r0, r6
 8019554:	f005 fee9 	bl	801f32a <crs_strlen>
 8019558:	1c42      	adds	r2, r0, #1
          if (size <= DC_CST_PASSWORD_SIZE)
 801955a:	2a20      	cmp	r2, #32
 801955c:	d804      	bhi.n	8019568 <CST_cmd+0x470>
            (void)memcpy(apn_config.password, argv_p[4], size);
 801955e:	4631      	mov	r1, r6
 8019560:	484e      	ldr	r0, [pc, #312]	; (801969c <CST_cmd+0x5a4>)
 8019562:	f00d fac1 	bl	8026ae8 <memcpy>
 8019566:	e748      	b.n	80193fa <CST_cmd+0x302>
            PRINT_FORCE("password to long")
 8019568:	4d44      	ldr	r5, [pc, #272]	; (801967c <CST_cmd+0x584>)
 801956a:	4e4d      	ldr	r6, [pc, #308]	; (80196a0 <CST_cmd+0x5a8>)
 801956c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801956e:	6028      	str	r0, [r5, #0]
 8019570:	6069      	str	r1, [r5, #4]
 8019572:	60aa      	str	r2, [r5, #8]
 8019574:	60eb      	str	r3, [r5, #12]
 8019576:	8832      	ldrh	r2, [r6, #0]
 8019578:	78b3      	ldrb	r3, [r6, #2]
 801957a:	822a      	strh	r2, [r5, #16]
 801957c:	74ab      	strb	r3, [r5, #18]
 801957e:	4628      	mov	r0, r5
 8019580:	f005 fed3 	bl	801f32a <crs_strlen>
 8019584:	b283      	uxth	r3, r0
 8019586:	462a      	mov	r2, r5
 8019588:	2101      	movs	r1, #1
 801958a:	2007      	movs	r0, #7
 801958c:	f005 ff10 	bl	801f3b0 <traceIF_itmPrint>
 8019590:	4628      	mov	r0, r5
 8019592:	f005 feca 	bl	801f32a <crs_strlen>
 8019596:	b282      	uxth	r2, r0
 8019598:	4629      	mov	r1, r5
 801959a:	2007      	movs	r0, #7
 801959c:	f005 ff42 	bl	801f424 <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 80195a0:	2501      	movs	r5, #1
 80195a2:	e72a      	b.n	80193fa <CST_cmd+0x302>
          size =  crs_strlen(argv_p[3]) + 1U;
 80195a4:	9e04      	ldr	r6, [sp, #16]
 80195a6:	4630      	mov	r0, r6
 80195a8:	f005 febf 	bl	801f32a <crs_strlen>
 80195ac:	1c42      	adds	r2, r0, #1
          if (size <= DC_CST_USERNAME_SIZE)
 80195ae:	2a20      	cmp	r2, #32
 80195b0:	d804      	bhi.n	80195bc <CST_cmd+0x4c4>
            (void)memcpy(apn_config.username, argv_p[3], size);
 80195b2:	4631      	mov	r1, r6
 80195b4:	483b      	ldr	r0, [pc, #236]	; (80196a4 <CST_cmd+0x5ac>)
 80195b6:	f00d fa97 	bl	8026ae8 <memcpy>
 80195ba:	e721      	b.n	8019400 <CST_cmd+0x308>
            PRINT_FORCE("username to long")
 80195bc:	4d2f      	ldr	r5, [pc, #188]	; (801967c <CST_cmd+0x584>)
 80195be:	4e3a      	ldr	r6, [pc, #232]	; (80196a8 <CST_cmd+0x5b0>)
 80195c0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80195c2:	6028      	str	r0, [r5, #0]
 80195c4:	6069      	str	r1, [r5, #4]
 80195c6:	60aa      	str	r2, [r5, #8]
 80195c8:	60eb      	str	r3, [r5, #12]
 80195ca:	8832      	ldrh	r2, [r6, #0]
 80195cc:	78b3      	ldrb	r3, [r6, #2]
 80195ce:	822a      	strh	r2, [r5, #16]
 80195d0:	74ab      	strb	r3, [r5, #18]
 80195d2:	4628      	mov	r0, r5
 80195d4:	f005 fea9 	bl	801f32a <crs_strlen>
 80195d8:	b283      	uxth	r3, r0
 80195da:	462a      	mov	r2, r5
 80195dc:	2101      	movs	r1, #1
 80195de:	2007      	movs	r0, #7
 80195e0:	f005 fee6 	bl	801f3b0 <traceIF_itmPrint>
 80195e4:	4628      	mov	r0, r5
 80195e6:	f005 fea0 	bl	801f32a <crs_strlen>
 80195ea:	b282      	uxth	r2, r0
 80195ec:	4629      	mov	r1, r5
 80195ee:	2007      	movs	r0, #7
 80195f0:	f005 ff18 	bl	801f424 <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 80195f4:	2501      	movs	r5, #1
 80195f6:	e703      	b.n	8019400 <CST_cmd+0x308>
          apn_config.cid = (uint8_t)crs_atoi(argv_p[2]);
 80195f8:	9803      	ldr	r0, [sp, #12]
 80195fa:	f005 fe51 	bl	801f2a0 <crs_atoi>
 80195fe:	4b1c      	ldr	r3, [pc, #112]	; (8019670 <CST_cmd+0x578>)
 8019600:	f883 0029 	strb.w	r0, [r3, #41]	; 0x29
 8019604:	e6ff      	b.n	8019406 <CST_cmd+0x30e>
          size =  crs_strlen(argv_p[1]) + 1U;
 8019606:	9c02      	ldr	r4, [sp, #8]
 8019608:	4620      	mov	r0, r4
 801960a:	f005 fe8e 	bl	801f32a <crs_strlen>
 801960e:	1c42      	adds	r2, r0, #1
          if (size <= DC_MAX_SIZE_APN)
 8019610:	2a20      	cmp	r2, #32
 8019612:	d804      	bhi.n	801961e <CST_cmd+0x526>
            (void)memcpy(apn_config.apn, argv_p[1], size);
 8019614:	4621      	mov	r1, r4
 8019616:	4817      	ldr	r0, [pc, #92]	; (8019674 <CST_cmd+0x57c>)
 8019618:	f00d fa66 	bl	8026ae8 <memcpy>
 801961c:	e6f6      	b.n	801940c <CST_cmd+0x314>
            PRINT_FORCE("APN to long")
 801961e:	4c17      	ldr	r4, [pc, #92]	; (801967c <CST_cmd+0x584>)
 8019620:	4b1d      	ldr	r3, [pc, #116]	; (8019698 <CST_cmd+0x5a0>)
 8019622:	cb07      	ldmia	r3!, {r0, r1, r2}
 8019624:	6020      	str	r0, [r4, #0]
 8019626:	6061      	str	r1, [r4, #4]
 8019628:	60a2      	str	r2, [r4, #8]
 801962a:	881b      	ldrh	r3, [r3, #0]
 801962c:	81a3      	strh	r3, [r4, #12]
 801962e:	4620      	mov	r0, r4
 8019630:	f005 fe7b 	bl	801f32a <crs_strlen>
 8019634:	b283      	uxth	r3, r0
 8019636:	4622      	mov	r2, r4
 8019638:	2101      	movs	r1, #1
 801963a:	2007      	movs	r0, #7
 801963c:	f005 feb8 	bl	801f3b0 <traceIF_itmPrint>
 8019640:	4620      	mov	r0, r4
 8019642:	f005 fe72 	bl	801f32a <crs_strlen>
 8019646:	b282      	uxth	r2, r0
 8019648:	4621      	mov	r1, r4
 801964a:	2007      	movs	r0, #7
 801964c:	f005 feea 	bl	801f424 <traceIF_uartPrintForce>
            cmd_status = CMD_SYNTAX_ERROR;
 8019650:	2501      	movs	r5, #1
 8019652:	f000 be4c 	b.w	801a2ee <CST_cmd+0x11f6>
 8019656:	bf00      	nop
 8019658:	08033ad0 	.word	0x08033ad0
 801965c:	20003b10 	.word	0x20003b10
 8019660:	200058b0 	.word	0x200058b0
 8019664:	20000232 	.word	0x20000232
 8019668:	20003cdc 	.word	0x20003cdc
 801966c:	2000023c 	.word	0x2000023c
 8019670:	200039b0 	.word	0x200039b0
 8019674:	200039b9 	.word	0x200039b9
 8019678:	20000230 	.word	0x20000230
 801967c:	20004ddc 	.word	0x20004ddc
 8019680:	20000058 	.word	0x20000058
 8019684:	08033b10 	.word	0x08033b10
 8019688:	08033b44 	.word	0x08033b44
 801968c:	08033b60 	.word	0x08033b60
 8019690:	08033b7c 	.word	0x08033b7c
 8019694:	08033b98 	.word	0x08033b98
 8019698:	08033ad8 	.word	0x08033ad8
 801969c:	200039fa 	.word	0x200039fa
 80196a0:	08033ae8 	.word	0x08033ae8
 80196a4:	200039da 	.word	0x200039da
 80196a8:	08033afc 	.word	0x08033afc
                      crs_strlen(argv_p[0]))
 80196ac:	4630      	mov	r0, r6
 80196ae:	f005 fe3c 	bl	801f32a <crs_strlen>
 80196b2:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 80196b4:	4990      	ldr	r1, [pc, #576]	; (80198f8 <CST_cmd+0x800>)
 80196b6:	4630      	mov	r0, r6
 80196b8:	f00d f929 	bl	802690e <memcmp>
 80196bc:	2800      	cmp	r0, #0
 80196be:	f040 80ee 	bne.w	801989e <CST_cmd+0x7a6>
        PRINT_FORCE("Cellular Service Task State")
 80196c2:	4c8e      	ldr	r4, [pc, #568]	; (80198fc <CST_cmd+0x804>)
 80196c4:	4d8e      	ldr	r5, [pc, #568]	; (8019900 <CST_cmd+0x808>)
 80196c6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80196c8:	6020      	str	r0, [r4, #0]
 80196ca:	6061      	str	r1, [r4, #4]
 80196cc:	60a2      	str	r2, [r4, #8]
 80196ce:	60e3      	str	r3, [r4, #12]
 80196d0:	cd07      	ldmia	r5!, {r0, r1, r2}
 80196d2:	6120      	str	r0, [r4, #16]
 80196d4:	6161      	str	r1, [r4, #20]
 80196d6:	61a2      	str	r2, [r4, #24]
 80196d8:	882b      	ldrh	r3, [r5, #0]
 80196da:	83a3      	strh	r3, [r4, #28]
 80196dc:	4620      	mov	r0, r4
 80196de:	f005 fe24 	bl	801f32a <crs_strlen>
 80196e2:	b283      	uxth	r3, r0
 80196e4:	4622      	mov	r2, r4
 80196e6:	2101      	movs	r1, #1
 80196e8:	2007      	movs	r0, #7
 80196ea:	f005 fe61 	bl	801f3b0 <traceIF_itmPrint>
 80196ee:	4620      	mov	r0, r4
 80196f0:	f005 fe1b 	bl	801f32a <crs_strlen>
 80196f4:	b282      	uxth	r2, r0
 80196f6:	4621      	mov	r1, r4
 80196f8:	2007      	movs	r0, #7
 80196fa:	f005 fe93 	bl	801f424 <traceIF_uartPrintForce>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_cmd_sim_info, sizeof(cst_cmd_sim_info));
 80196fe:	4e81      	ldr	r6, [pc, #516]	; (8019904 <CST_cmd+0x80c>)
 8019700:	4f81      	ldr	r7, [pc, #516]	; (8019908 <CST_cmd+0x810>)
 8019702:	2330      	movs	r3, #48	; 0x30
 8019704:	4632      	mov	r2, r6
 8019706:	4981      	ldr	r1, [pc, #516]	; (801990c <CST_cmd+0x814>)
 8019708:	8809      	ldrh	r1, [r1, #0]
 801970a:	4638      	mov	r0, r7
 801970c:	f008 fd10 	bl	8022130 <dc_com_read>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 8019710:	4d7f      	ldr	r5, [pc, #508]	; (8019910 <CST_cmd+0x818>)
 8019712:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 8019716:	462a      	mov	r2, r5
 8019718:	497e      	ldr	r1, [pc, #504]	; (8019914 <CST_cmd+0x81c>)
 801971a:	8809      	ldrh	r1, [r1, #0]
 801971c:	4638      	mov	r0, r7
 801971e:	f008 fd07 	bl	8022130 <dc_com_read>
        PRINT_FORCE("Current State  : %s", CST_StateName[CST_get_state()])
 8019722:	f002 ffd9 	bl	801c6d8 <CST_get_state>
 8019726:	4b7c      	ldr	r3, [pc, #496]	; (8019918 <CST_cmd+0x820>)
 8019728:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 801972c:	497b      	ldr	r1, [pc, #492]	; (801991c <CST_cmd+0x824>)
 801972e:	4620      	mov	r0, r4
 8019730:	f00d f88a 	bl	8026848 <sprintf>
 8019734:	4620      	mov	r0, r4
 8019736:	f005 fdf8 	bl	801f32a <crs_strlen>
 801973a:	b283      	uxth	r3, r0
 801973c:	4622      	mov	r2, r4
 801973e:	2101      	movs	r1, #1
 8019740:	2007      	movs	r0, #7
 8019742:	f005 fe35 	bl	801f3b0 <traceIF_itmPrint>
 8019746:	4620      	mov	r0, r4
 8019748:	f005 fdef 	bl	801f32a <crs_strlen>
 801974c:	b282      	uxth	r2, r0
 801974e:	4621      	mov	r1, r4
 8019750:	2007      	movs	r0, #7
 8019752:	f005 fe67 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Sim Selected   : %s", CST_SimSlotName_p[cst_cmd_sim_info.active_slot])
 8019756:	f896 302a 	ldrb.w	r3, [r6, #42]	; 0x2a
 801975a:	4f71      	ldr	r7, [pc, #452]	; (8019920 <CST_cmd+0x828>)
 801975c:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8019760:	4970      	ldr	r1, [pc, #448]	; (8019924 <CST_cmd+0x82c>)
 8019762:	4620      	mov	r0, r4
 8019764:	f00d f870 	bl	8026848 <sprintf>
 8019768:	4620      	mov	r0, r4
 801976a:	f005 fdde 	bl	801f32a <crs_strlen>
 801976e:	b283      	uxth	r3, r0
 8019770:	4622      	mov	r2, r4
 8019772:	2101      	movs	r1, #1
 8019774:	2007      	movs	r0, #7
 8019776:	f005 fe1b 	bl	801f3b0 <traceIF_itmPrint>
 801977a:	4620      	mov	r0, r4
 801977c:	f005 fdd5 	bl	801f32a <crs_strlen>
 8019780:	b282      	uxth	r2, r0
 8019782:	4621      	mov	r1, r4
 8019784:	2007      	movs	r0, #7
 8019786:	f005 fe4d 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Sim %s         : %s", CST_SimSlotName_p[cst_cmd_cellular_params.sim_slot[0].sim_slot_type],
 801978a:	7aea      	ldrb	r2, [r5, #11]
 801978c:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
 8019790:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 8019944 <CST_cmd+0x84c>
 8019794:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 8019948 <CST_cmd+0x850>
 8019798:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 801979c:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 80197a0:	4641      	mov	r1, r8
 80197a2:	4620      	mov	r0, r4
 80197a4:	f00d f850 	bl	8026848 <sprintf>
 80197a8:	4620      	mov	r0, r4
 80197aa:	f005 fdbe 	bl	801f32a <crs_strlen>
 80197ae:	b283      	uxth	r3, r0
 80197b0:	4622      	mov	r2, r4
 80197b2:	2101      	movs	r1, #1
 80197b4:	2007      	movs	r0, #7
 80197b6:	f005 fdfb 	bl	801f3b0 <traceIF_itmPrint>
 80197ba:	4620      	mov	r0, r4
 80197bc:	f005 fdb5 	bl	801f32a <crs_strlen>
 80197c0:	b282      	uxth	r2, r0
 80197c2:	4621      	mov	r1, r4
 80197c4:	2007      	movs	r0, #7
 80197c6:	f005 fe2d 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Sim %s         : %s", CST_SimSlotName_p[cst_cmd_cellular_params.sim_slot[1].sim_slot_type],
 80197ca:	f895 206d 	ldrb.w	r2, [r5, #109]	; 0x6d
 80197ce:	f896 302c 	ldrb.w	r3, [r6, #44]	; 0x2c
 80197d2:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 80197d6:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 80197da:	4641      	mov	r1, r8
 80197dc:	4620      	mov	r0, r4
 80197de:	f00d f833 	bl	8026848 <sprintf>
 80197e2:	4620      	mov	r0, r4
 80197e4:	f005 fda1 	bl	801f32a <crs_strlen>
 80197e8:	b283      	uxth	r3, r0
 80197ea:	4622      	mov	r2, r4
 80197ec:	2101      	movs	r1, #1
 80197ee:	2007      	movs	r0, #7
 80197f0:	f005 fdde 	bl	801f3b0 <traceIF_itmPrint>
 80197f4:	4620      	mov	r0, r4
 80197f6:	f005 fd98 	bl	801f32a <crs_strlen>
 80197fa:	b282      	uxth	r2, r0
 80197fc:	4621      	mov	r1, r4
 80197fe:	2007      	movs	r0, #7
 8019800:	f005 fe10 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Sim %s         : %s", CST_SimSlotName_p[cst_cmd_cellular_params.sim_slot[2].sim_slot_type],
 8019804:	f895 20cf 	ldrb.w	r2, [r5, #207]	; 0xcf
 8019808:	f896 302d 	ldrb.w	r3, [r6, #45]	; 0x2d
 801980c:	f859 3023 	ldr.w	r3, [r9, r3, lsl #2]
 8019810:	f857 2022 	ldr.w	r2, [r7, r2, lsl #2]
 8019814:	4641      	mov	r1, r8
 8019816:	4620      	mov	r0, r4
 8019818:	f00d f816 	bl	8026848 <sprintf>
 801981c:	4620      	mov	r0, r4
 801981e:	f005 fd84 	bl	801f32a <crs_strlen>
 8019822:	b283      	uxth	r3, r0
 8019824:	4622      	mov	r2, r4
 8019826:	2101      	movs	r1, #1
 8019828:	2007      	movs	r0, #7
 801982a:	f005 fdc1 	bl	801f3b0 <traceIF_itmPrint>
 801982e:	4620      	mov	r0, r4
 8019830:	f005 fd7b 	bl	801f32a <crs_strlen>
 8019834:	b282      	uxth	r2, r0
 8019836:	4621      	mov	r1, r4
 8019838:	2007      	movs	r0, #7
 801983a:	f005 fdf3 	bl	801f424 <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.nfmc_active != 0U)
 801983e:	f895 517c 	ldrb.w	r5, [r5, #380]	; 0x17c
 8019842:	2d00      	cmp	r5, #0
 8019844:	f000 8553 	beq.w	801a2ee <CST_cmd+0x11f6>
          (void)dc_com_read(&dc_com_db, DC_CELLULAR_NFMC_INFO, (void *)&cst_cmd_nfmc_info, sizeof(cst_cmd_nfmc_info));
 8019848:	232c      	movs	r3, #44	; 0x2c
 801984a:	4a37      	ldr	r2, [pc, #220]	; (8019928 <CST_cmd+0x830>)
 801984c:	4937      	ldr	r1, [pc, #220]	; (801992c <CST_cmd+0x834>)
 801984e:	8809      	ldrh	r1, [r1, #0]
 8019850:	482d      	ldr	r0, [pc, #180]	; (8019908 <CST_cmd+0x810>)
 8019852:	f008 fc6d 	bl	8022130 <dc_com_read>
          for (i = 0U; i < DC_NFMC_TEMPO_NB ; i++)
 8019856:	2300      	movs	r3, #0
 8019858:	e01c      	b.n	8019894 <CST_cmd+0x79c>
            PRINT_FORCE("nfmc tempo %ld   : %ld", i + 1U, cst_cmd_nfmc_info.tempo[i])
 801985a:	1c5d      	adds	r5, r3, #1
 801985c:	3304      	adds	r3, #4
 801985e:	4c27      	ldr	r4, [pc, #156]	; (80198fc <CST_cmd+0x804>)
 8019860:	4a31      	ldr	r2, [pc, #196]	; (8019928 <CST_cmd+0x830>)
 8019862:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019866:	462a      	mov	r2, r5
 8019868:	4931      	ldr	r1, [pc, #196]	; (8019930 <CST_cmd+0x838>)
 801986a:	4620      	mov	r0, r4
 801986c:	f00c ffec 	bl	8026848 <sprintf>
 8019870:	4620      	mov	r0, r4
 8019872:	f005 fd5a 	bl	801f32a <crs_strlen>
 8019876:	b283      	uxth	r3, r0
 8019878:	4622      	mov	r2, r4
 801987a:	2101      	movs	r1, #1
 801987c:	2007      	movs	r0, #7
 801987e:	f005 fd97 	bl	801f3b0 <traceIF_itmPrint>
 8019882:	4620      	mov	r0, r4
 8019884:	f005 fd51 	bl	801f32a <crs_strlen>
 8019888:	b282      	uxth	r2, r0
 801988a:	4621      	mov	r1, r4
 801988c:	2007      	movs	r0, #7
 801988e:	f005 fdc9 	bl	801f424 <traceIF_uartPrintForce>
          for (i = 0U; i < DC_NFMC_TEMPO_NB ; i++)
 8019892:	462b      	mov	r3, r5
 8019894:	2b06      	cmp	r3, #6
 8019896:	d9e0      	bls.n	801985a <CST_cmd+0x762>
  cmd_status = CMD_OK;
 8019898:	2500      	movs	r5, #0
 801989a:	f000 bd28 	b.w	801a2ee <CST_cmd+0x11f6>
                      crs_strlen(argv_p[0]))
 801989e:	4630      	mov	r0, r6
 80198a0:	f005 fd43 	bl	801f32a <crs_strlen>
 80198a4:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 80198a6:	4923      	ldr	r1, [pc, #140]	; (8019934 <CST_cmd+0x83c>)
 80198a8:	4630      	mov	r0, r6
 80198aa:	f00d f830 	bl	802690e <memcmp>
 80198ae:	2800      	cmp	r0, #0
 80198b0:	d14c      	bne.n	801994c <CST_cmd+0x854>
        if (memcmp((CRC_CHAR_t *)argv_p[1],
 80198b2:	9c02      	ldr	r4, [sp, #8]
                   crs_strlen(argv_p[1]))
 80198b4:	4620      	mov	r0, r4
 80198b6:	f005 fd38 	bl	801f32a <crs_strlen>
 80198ba:	4602      	mov	r2, r0
        if (memcmp((CRC_CHAR_t *)argv_p[1],
 80198bc:	491e      	ldr	r1, [pc, #120]	; (8019938 <CST_cmd+0x840>)
 80198be:	4620      	mov	r0, r4
 80198c0:	f00d f825 	bl	802690e <memcmp>
 80198c4:	b110      	cbz	r0, 80198cc <CST_cmd+0x7d4>
  cmd_status = CMD_OK;
 80198c6:	2500      	movs	r5, #0
 80198c8:	f000 bd11 	b.w	801a2ee <CST_cmd+0x11f6>
          TRACE_VALID("@valid@:cst:netstate:%s\n\r", CST_StateName[CST_get_state()])
 80198cc:	f002 ff04 	bl	801c6d8 <CST_get_state>
 80198d0:	4c1a      	ldr	r4, [pc, #104]	; (801993c <CST_cmd+0x844>)
 80198d2:	4b11      	ldr	r3, [pc, #68]	; (8019918 <CST_cmd+0x820>)
 80198d4:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 80198d8:	4919      	ldr	r1, [pc, #100]	; (8019940 <CST_cmd+0x848>)
 80198da:	4620      	mov	r0, r4
 80198dc:	f00c ffb4 	bl	8026848 <sprintf>
 80198e0:	4620      	mov	r0, r4
 80198e2:	f005 fd22 	bl	801f32a <crs_strlen>
 80198e6:	b282      	uxth	r2, r0
 80198e8:	4621      	mov	r1, r4
 80198ea:	200c      	movs	r0, #12
 80198ec:	f005 fd9a 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 80198f0:	2500      	movs	r5, #0
 80198f2:	f000 bcfc 	b.w	801a2ee <CST_cmd+0x11f6>
 80198f6:	bf00      	nop
 80198f8:	08033bb4 	.word	0x08033bb4
 80198fc:	20004ddc 	.word	0x20004ddc
 8019900:	08033bbc 	.word	0x08033bbc
 8019904:	20003cdc 	.word	0x20003cdc
 8019908:	200058b0 	.word	0x200058b0
 801990c:	2000023c 	.word	0x2000023c
 8019910:	20003b10 	.word	0x20003b10
 8019914:	20000232 	.word	0x20000232
 8019918:	20000064 	.word	0x20000064
 801991c:	08033bdc 	.word	0x08033bdc
 8019920:	20000058 	.word	0x20000058
 8019924:	08033bf4 	.word	0x08033bf4
 8019928:	20003cb0 	.word	0x20003cb0
 801992c:	20000238 	.word	0x20000238
 8019930:	08033c24 	.word	0x08033c24
 8019934:	08033c40 	.word	0x08033c40
 8019938:	08033c48 	.word	0x08033c48
 801993c:	200052dc 	.word	0x200052dc
 8019940:	08033c54 	.word	0x08033c54
 8019944:	08034204 	.word	0x08034204
 8019948:	08033c0c 	.word	0x08033c0c
                      crs_strlen(argv_p[0])) == 0)
 801994c:	4630      	mov	r0, r6
 801994e:	f005 fcec 	bl	801f32a <crs_strlen>
 8019952:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8019954:	49a6      	ldr	r1, [pc, #664]	; (8019bf0 <CST_cmd+0xaf8>)
 8019956:	4630      	mov	r0, r6
 8019958:	f00c ffd9 	bl	802690e <memcmp>
 801995c:	2800      	cmp	r0, #0
 801995e:	f040 8173 	bne.w	8019c48 <CST_cmd+0xb50>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cmd_cellular_info, sizeof(cst_cmd_cellular_info));
 8019962:	4da4      	ldr	r5, [pc, #656]	; (8019bf4 <CST_cmd+0xafc>)
 8019964:	4ca4      	ldr	r4, [pc, #656]	; (8019bf8 <CST_cmd+0xb00>)
 8019966:	23f4      	movs	r3, #244	; 0xf4
 8019968:	462a      	mov	r2, r5
 801996a:	49a4      	ldr	r1, [pc, #656]	; (8019bfc <CST_cmd+0xb04>)
 801996c:	8809      	ldrh	r1, [r1, #0]
 801996e:	4620      	mov	r0, r4
 8019970:	f008 fbde 	bl	8022130 <dc_com_read>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_cmd_sim_info, sizeof(cst_cmd_sim_info));
 8019974:	4fa2      	ldr	r7, [pc, #648]	; (8019c00 <CST_cmd+0xb08>)
 8019976:	2330      	movs	r3, #48	; 0x30
 8019978:	463a      	mov	r2, r7
 801997a:	49a2      	ldr	r1, [pc, #648]	; (8019c04 <CST_cmd+0xb0c>)
 801997c:	8809      	ldrh	r1, [r1, #0]
 801997e:	4620      	mov	r0, r4
 8019980:	f008 fbd6 	bl	8022130 <dc_com_read>
        PRINT_FORCE("Cellular Service Infos ")
 8019984:	4ca0      	ldr	r4, [pc, #640]	; (8019c08 <CST_cmd+0xb10>)
 8019986:	4ea1      	ldr	r6, [pc, #644]	; (8019c0c <CST_cmd+0xb14>)
 8019988:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801998a:	6020      	str	r0, [r4, #0]
 801998c:	6061      	str	r1, [r4, #4]
 801998e:	60a2      	str	r2, [r4, #8]
 8019990:	60e3      	str	r3, [r4, #12]
 8019992:	ce03      	ldmia	r6!, {r0, r1}
 8019994:	6120      	str	r0, [r4, #16]
 8019996:	6161      	str	r1, [r4, #20]
 8019998:	8833      	ldrh	r3, [r6, #0]
 801999a:	8323      	strh	r3, [r4, #24]
 801999c:	4620      	mov	r0, r4
 801999e:	f005 fcc4 	bl	801f32a <crs_strlen>
 80199a2:	b283      	uxth	r3, r0
 80199a4:	4622      	mov	r2, r4
 80199a6:	2101      	movs	r1, #1
 80199a8:	2007      	movs	r0, #7
 80199aa:	f005 fd01 	bl	801f3b0 <traceIF_itmPrint>
 80199ae:	4620      	mov	r0, r4
 80199b0:	f005 fcbb 	bl	801f32a <crs_strlen>
 80199b4:	b282      	uxth	r2, r0
 80199b6:	4621      	mov	r1, r4
 80199b8:	2007      	movs	r0, #7
 80199ba:	f005 fd33 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Modem state          : %d (%s)", cst_cmd_cellular_info.modem_state,
 80199be:	7a6a      	ldrb	r2, [r5, #9]
 80199c0:	4b93      	ldr	r3, [pc, #588]	; (8019c10 <CST_cmd+0xb18>)
 80199c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80199c6:	4993      	ldr	r1, [pc, #588]	; (8019c14 <CST_cmd+0xb1c>)
 80199c8:	4620      	mov	r0, r4
 80199ca:	f00c ff3d 	bl	8026848 <sprintf>
 80199ce:	4620      	mov	r0, r4
 80199d0:	f005 fcab 	bl	801f32a <crs_strlen>
 80199d4:	b283      	uxth	r3, r0
 80199d6:	4622      	mov	r2, r4
 80199d8:	2101      	movs	r1, #1
 80199da:	2007      	movs	r0, #7
 80199dc:	f005 fce8 	bl	801f3b0 <traceIF_itmPrint>
 80199e0:	4620      	mov	r0, r4
 80199e2:	f005 fca2 	bl	801f32a <crs_strlen>
 80199e6:	b282      	uxth	r2, r0
 80199e8:	4621      	mov	r1, r4
 80199ea:	2007      	movs	r0, #7
 80199ec:	f005 fd1a 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Signal Quality       : %d", cst_cmd_cellular_info.cs_signal_level)
 80199f0:	7aaa      	ldrb	r2, [r5, #10]
 80199f2:	4989      	ldr	r1, [pc, #548]	; (8019c18 <CST_cmd+0xb20>)
 80199f4:	4620      	mov	r0, r4
 80199f6:	f00c ff27 	bl	8026848 <sprintf>
 80199fa:	4620      	mov	r0, r4
 80199fc:	f005 fc95 	bl	801f32a <crs_strlen>
 8019a00:	b283      	uxth	r3, r0
 8019a02:	4622      	mov	r2, r4
 8019a04:	2101      	movs	r1, #1
 8019a06:	2007      	movs	r0, #7
 8019a08:	f005 fcd2 	bl	801f3b0 <traceIF_itmPrint>
 8019a0c:	4620      	mov	r0, r4
 8019a0e:	f005 fc8c 	bl	801f32a <crs_strlen>
 8019a12:	b282      	uxth	r2, r0
 8019a14:	4621      	mov	r1, r4
 8019a16:	2007      	movs	r0, #7
 8019a18:	f005 fd04 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Signal level(dBm)    : %ld", cst_cmd_cellular_info.cs_signal_level_db)
 8019a1c:	68ea      	ldr	r2, [r5, #12]
 8019a1e:	497f      	ldr	r1, [pc, #508]	; (8019c1c <CST_cmd+0xb24>)
 8019a20:	4620      	mov	r0, r4
 8019a22:	f00c ff11 	bl	8026848 <sprintf>
 8019a26:	4620      	mov	r0, r4
 8019a28:	f005 fc7f 	bl	801f32a <crs_strlen>
 8019a2c:	b283      	uxth	r3, r0
 8019a2e:	4622      	mov	r2, r4
 8019a30:	2101      	movs	r1, #1
 8019a32:	2007      	movs	r0, #7
 8019a34:	f005 fcbc 	bl	801f3b0 <traceIF_itmPrint>
 8019a38:	4620      	mov	r0, r4
 8019a3a:	f005 fc76 	bl	801f32a <crs_strlen>
 8019a3e:	b282      	uxth	r2, r0
 8019a40:	4621      	mov	r1, r4
 8019a42:	2007      	movs	r0, #7
 8019a44:	f005 fcee 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Operator name        : %s", cst_cmd_cellular_info.mno_name)
 8019a48:	f105 0230 	add.w	r2, r5, #48	; 0x30
 8019a4c:	4974      	ldr	r1, [pc, #464]	; (8019c20 <CST_cmd+0xb28>)
 8019a4e:	4620      	mov	r0, r4
 8019a50:	f00c fefa 	bl	8026848 <sprintf>
 8019a54:	4620      	mov	r0, r4
 8019a56:	f005 fc68 	bl	801f32a <crs_strlen>
 8019a5a:	b283      	uxth	r3, r0
 8019a5c:	4622      	mov	r2, r4
 8019a5e:	2101      	movs	r1, #1
 8019a60:	2007      	movs	r0, #7
 8019a62:	f005 fca5 	bl	801f3b0 <traceIF_itmPrint>
 8019a66:	4620      	mov	r0, r4
 8019a68:	f005 fc5f 	bl	801f32a <crs_strlen>
 8019a6c:	b282      	uxth	r2, r0
 8019a6e:	4621      	mov	r1, r4
 8019a70:	2007      	movs	r0, #7
 8019a72:	f005 fcd7 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("IMEI                 : %s", cst_cmd_cellular_info.imei)
 8019a76:	f105 0210 	add.w	r2, r5, #16
 8019a7a:	496a      	ldr	r1, [pc, #424]	; (8019c24 <CST_cmd+0xb2c>)
 8019a7c:	4620      	mov	r0, r4
 8019a7e:	f00c fee3 	bl	8026848 <sprintf>
 8019a82:	4620      	mov	r0, r4
 8019a84:	f005 fc51 	bl	801f32a <crs_strlen>
 8019a88:	b283      	uxth	r3, r0
 8019a8a:	4622      	mov	r2, r4
 8019a8c:	2101      	movs	r1, #1
 8019a8e:	2007      	movs	r0, #7
 8019a90:	f005 fc8e 	bl	801f3b0 <traceIF_itmPrint>
 8019a94:	4620      	mov	r0, r4
 8019a96:	f005 fc48 	bl	801f32a <crs_strlen>
 8019a9a:	b282      	uxth	r2, r0
 8019a9c:	4621      	mov	r1, r4
 8019a9e:	2007      	movs	r0, #7
 8019aa0:	f005 fcc0 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Manuf name           : %s", cst_cmd_cellular_info.manufacturer_name)
 8019aa4:	f105 0250 	add.w	r2, r5, #80	; 0x50
 8019aa8:	495f      	ldr	r1, [pc, #380]	; (8019c28 <CST_cmd+0xb30>)
 8019aaa:	4620      	mov	r0, r4
 8019aac:	f00c fecc 	bl	8026848 <sprintf>
 8019ab0:	4620      	mov	r0, r4
 8019ab2:	f005 fc3a 	bl	801f32a <crs_strlen>
 8019ab6:	b283      	uxth	r3, r0
 8019ab8:	4622      	mov	r2, r4
 8019aba:	2101      	movs	r1, #1
 8019abc:	2007      	movs	r0, #7
 8019abe:	f005 fc77 	bl	801f3b0 <traceIF_itmPrint>
 8019ac2:	4620      	mov	r0, r4
 8019ac4:	f005 fc31 	bl	801f32a <crs_strlen>
 8019ac8:	b282      	uxth	r2, r0
 8019aca:	4621      	mov	r1, r4
 8019acc:	2007      	movs	r0, #7
 8019ace:	f005 fca9 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Model                : %s", cst_cmd_cellular_info.model)
 8019ad2:	f105 0270 	add.w	r2, r5, #112	; 0x70
 8019ad6:	4955      	ldr	r1, [pc, #340]	; (8019c2c <CST_cmd+0xb34>)
 8019ad8:	4620      	mov	r0, r4
 8019ada:	f00c feb5 	bl	8026848 <sprintf>
 8019ade:	4620      	mov	r0, r4
 8019ae0:	f005 fc23 	bl	801f32a <crs_strlen>
 8019ae4:	b283      	uxth	r3, r0
 8019ae6:	4622      	mov	r2, r4
 8019ae8:	2101      	movs	r1, #1
 8019aea:	2007      	movs	r0, #7
 8019aec:	f005 fc60 	bl	801f3b0 <traceIF_itmPrint>
 8019af0:	4620      	mov	r0, r4
 8019af2:	f005 fc1a 	bl	801f32a <crs_strlen>
 8019af6:	b282      	uxth	r2, r0
 8019af8:	4621      	mov	r1, r4
 8019afa:	2007      	movs	r0, #7
 8019afc:	f005 fc92 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Revision             : %s", cst_cmd_cellular_info.revision)
 8019b00:	f105 0290 	add.w	r2, r5, #144	; 0x90
 8019b04:	494a      	ldr	r1, [pc, #296]	; (8019c30 <CST_cmd+0xb38>)
 8019b06:	4620      	mov	r0, r4
 8019b08:	f00c fe9e 	bl	8026848 <sprintf>
 8019b0c:	4620      	mov	r0, r4
 8019b0e:	f005 fc0c 	bl	801f32a <crs_strlen>
 8019b12:	b283      	uxth	r3, r0
 8019b14:	4622      	mov	r2, r4
 8019b16:	2101      	movs	r1, #1
 8019b18:	2007      	movs	r0, #7
 8019b1a:	f005 fc49 	bl	801f3b0 <traceIF_itmPrint>
 8019b1e:	4620      	mov	r0, r4
 8019b20:	f005 fc03 	bl	801f32a <crs_strlen>
 8019b24:	b282      	uxth	r2, r0
 8019b26:	4621      	mov	r1, r4
 8019b28:	2007      	movs	r0, #7
 8019b2a:	f005 fc7b 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Serial Number        : %s", cst_cmd_cellular_info.serial_number)
 8019b2e:	f105 02b0 	add.w	r2, r5, #176	; 0xb0
 8019b32:	4940      	ldr	r1, [pc, #256]	; (8019c34 <CST_cmd+0xb3c>)
 8019b34:	4620      	mov	r0, r4
 8019b36:	f00c fe87 	bl	8026848 <sprintf>
 8019b3a:	4620      	mov	r0, r4
 8019b3c:	f005 fbf5 	bl	801f32a <crs_strlen>
 8019b40:	b283      	uxth	r3, r0
 8019b42:	4622      	mov	r2, r4
 8019b44:	2101      	movs	r1, #1
 8019b46:	2007      	movs	r0, #7
 8019b48:	f005 fc32 	bl	801f3b0 <traceIF_itmPrint>
 8019b4c:	4620      	mov	r0, r4
 8019b4e:	f005 fbec 	bl	801f32a <crs_strlen>
 8019b52:	b282      	uxth	r2, r0
 8019b54:	4621      	mov	r1, r4
 8019b56:	2007      	movs	r0, #7
 8019b58:	f005 fc64 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("ICCID                : %s", cst_cmd_cellular_info.iccid)
 8019b5c:	f105 02d0 	add.w	r2, r5, #208	; 0xd0
 8019b60:	4935      	ldr	r1, [pc, #212]	; (8019c38 <CST_cmd+0xb40>)
 8019b62:	4620      	mov	r0, r4
 8019b64:	f00c fe70 	bl	8026848 <sprintf>
 8019b68:	4620      	mov	r0, r4
 8019b6a:	f005 fbde 	bl	801f32a <crs_strlen>
 8019b6e:	b283      	uxth	r3, r0
 8019b70:	4622      	mov	r2, r4
 8019b72:	2101      	movs	r1, #1
 8019b74:	2007      	movs	r0, #7
 8019b76:	f005 fc1b 	bl	801f3b0 <traceIF_itmPrint>
 8019b7a:	4620      	mov	r0, r4
 8019b7c:	f005 fbd5 	bl	801f32a <crs_strlen>
 8019b80:	b282      	uxth	r2, r0
 8019b82:	4621      	mov	r1, r4
 8019b84:	2007      	movs	r0, #7
 8019b86:	f005 fc4d 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("IMSI                 : %s", cst_cmd_sim_info.imsi)
 8019b8a:	f107 0209 	add.w	r2, r7, #9
 8019b8e:	492b      	ldr	r1, [pc, #172]	; (8019c3c <CST_cmd+0xb44>)
 8019b90:	4620      	mov	r0, r4
 8019b92:	f00c fe59 	bl	8026848 <sprintf>
 8019b96:	4620      	mov	r0, r4
 8019b98:	f005 fbc7 	bl	801f32a <crs_strlen>
 8019b9c:	b283      	uxth	r3, r0
 8019b9e:	4622      	mov	r2, r4
 8019ba0:	2101      	movs	r1, #1
 8019ba2:	2007      	movs	r0, #7
 8019ba4:	f005 fc04 	bl	801f3b0 <traceIF_itmPrint>
 8019ba8:	4620      	mov	r0, r4
 8019baa:	f005 fbbe 	bl	801f32a <crs_strlen>
 8019bae:	b282      	uxth	r2, r0
 8019bb0:	4621      	mov	r1, r4
 8019bb2:	2007      	movs	r0, #7
 8019bb4:	f005 fc36 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Network register mode: %d (%s)", cst_cmd_cellular_info.access_techno,
 8019bb8:	f895 20f0 	ldrb.w	r2, [r5, #240]	; 0xf0
 8019bbc:	4b20      	ldr	r3, [pc, #128]	; (8019c40 <CST_cmd+0xb48>)
 8019bbe:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019bc2:	4920      	ldr	r1, [pc, #128]	; (8019c44 <CST_cmd+0xb4c>)
 8019bc4:	4620      	mov	r0, r4
 8019bc6:	f00c fe3f 	bl	8026848 <sprintf>
 8019bca:	4620      	mov	r0, r4
 8019bcc:	f005 fbad 	bl	801f32a <crs_strlen>
 8019bd0:	b283      	uxth	r3, r0
 8019bd2:	4622      	mov	r2, r4
 8019bd4:	2101      	movs	r1, #1
 8019bd6:	2007      	movs	r0, #7
 8019bd8:	f005 fbea 	bl	801f3b0 <traceIF_itmPrint>
 8019bdc:	4620      	mov	r0, r4
 8019bde:	f005 fba4 	bl	801f32a <crs_strlen>
 8019be2:	b282      	uxth	r2, r0
 8019be4:	4621      	mov	r1, r4
 8019be6:	2007      	movs	r0, #7
 8019be8:	f005 fc1c 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 8019bec:	2500      	movs	r5, #0
 8019bee:	e37e      	b.n	801a2ee <CST_cmd+0x11f6>
 8019bf0:	08033c70 	.word	0x08033c70
 8019bf4:	20003a1c 	.word	0x20003a1c
 8019bf8:	200058b0 	.word	0x200058b0
 8019bfc:	20000236 	.word	0x20000236
 8019c00:	20003cdc 	.word	0x20003cdc
 8019c04:	2000023c 	.word	0x2000023c
 8019c08:	20004ddc 	.word	0x20004ddc
 8019c0c:	08033c78 	.word	0x08033c78
 8019c10:	080341f4 	.word	0x080341f4
 8019c14:	08033c94 	.word	0x08033c94
 8019c18:	08033cb8 	.word	0x08033cb8
 8019c1c:	08033cd4 	.word	0x08033cd4
 8019c20:	08033cf4 	.word	0x08033cf4
 8019c24:	08033d10 	.word	0x08033d10
 8019c28:	08033d2c 	.word	0x08033d2c
 8019c2c:	08033d48 	.word	0x08033d48
 8019c30:	08033d64 	.word	0x08033d64
 8019c34:	08033d80 	.word	0x08033d80
 8019c38:	08033d9c 	.word	0x08033d9c
 8019c3c:	08033db8 	.word	0x08033db8
 8019c40:	08034234 	.word	0x08034234
 8019c44:	08033dd4 	.word	0x08033dd4
                      crs_strlen(argv_p[0]))
 8019c48:	4630      	mov	r0, r6
 8019c4a:	f005 fb6e 	bl	801f32a <crs_strlen>
 8019c4e:	4602      	mov	r2, r0
      else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8019c50:	49d1      	ldr	r1, [pc, #836]	; (8019f98 <CST_cmd+0xea0>)
 8019c52:	4630      	mov	r0, r6
 8019c54:	f00c fe5b 	bl	802690e <memcmp>
 8019c58:	2800      	cmp	r0, #0
 8019c5a:	f040 81ee 	bne.w	801a03a <CST_cmd+0xf42>
        PRINT_FORCE("Cellular Service Task Config")
 8019c5e:	4ccf      	ldr	r4, [pc, #828]	; (8019f9c <CST_cmd+0xea4>)
 8019c60:	4dcf      	ldr	r5, [pc, #828]	; (8019fa0 <CST_cmd+0xea8>)
 8019c62:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8019c64:	6020      	str	r0, [r4, #0]
 8019c66:	6061      	str	r1, [r4, #4]
 8019c68:	60a2      	str	r2, [r4, #8]
 8019c6a:	60e3      	str	r3, [r4, #12]
 8019c6c:	cd07      	ldmia	r5!, {r0, r1, r2}
 8019c6e:	6120      	str	r0, [r4, #16]
 8019c70:	6161      	str	r1, [r4, #20]
 8019c72:	61a2      	str	r2, [r4, #24]
 8019c74:	882a      	ldrh	r2, [r5, #0]
 8019c76:	78ab      	ldrb	r3, [r5, #2]
 8019c78:	83a2      	strh	r2, [r4, #28]
 8019c7a:	77a3      	strb	r3, [r4, #30]
 8019c7c:	4620      	mov	r0, r4
 8019c7e:	f005 fb54 	bl	801f32a <crs_strlen>
 8019c82:	b283      	uxth	r3, r0
 8019c84:	4622      	mov	r2, r4
 8019c86:	2101      	movs	r1, #1
 8019c88:	2007      	movs	r0, #7
 8019c8a:	f005 fb91 	bl	801f3b0 <traceIF_itmPrint>
 8019c8e:	4620      	mov	r0, r4
 8019c90:	f005 fb4b 	bl	801f32a <crs_strlen>
 8019c94:	b282      	uxth	r2, r0
 8019c96:	4621      	mov	r1, r4
 8019c98:	2007      	movs	r0, #7
 8019c9a:	f005 fbc3 	bl	801f424 <traceIF_uartPrintForce>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 8019c9e:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 8019ca2:	4ac0      	ldr	r2, [pc, #768]	; (8019fa4 <CST_cmd+0xeac>)
 8019ca4:	49c0      	ldr	r1, [pc, #768]	; (8019fa8 <CST_cmd+0xeb0>)
 8019ca6:	8809      	ldrh	r1, [r1, #0]
 8019ca8:	48c0      	ldr	r0, [pc, #768]	; (8019fac <CST_cmd+0xeb4>)
 8019caa:	f008 fa41 	bl	8022130 <dc_com_read>
        for (i = 0 ; i < cst_cmd_cellular_params.sim_slot_nb ; i++)
 8019cae:	2700      	movs	r7, #0
 8019cb0:	4bbc      	ldr	r3, [pc, #752]	; (8019fa4 <CST_cmd+0xeac>)
 8019cb2:	7a9b      	ldrb	r3, [r3, #10]
 8019cb4:	42bb      	cmp	r3, r7
 8019cb6:	f240 8085 	bls.w	8019dc4 <CST_cmd+0xccc>
          PRINT_FORCE("Sim Slot             : %ld (%s)", i,
 8019cba:	4eba      	ldr	r6, [pc, #744]	; (8019fa4 <CST_cmd+0xeac>)
 8019cbc:	2562      	movs	r5, #98	; 0x62
 8019cbe:	fb07 f505 	mul.w	r5, r7, r5
 8019cc2:	eb06 0805 	add.w	r8, r6, r5
 8019cc6:	f898 200b 	ldrb.w	r2, [r8, #11]
 8019cca:	4cb4      	ldr	r4, [pc, #720]	; (8019f9c <CST_cmd+0xea4>)
 8019ccc:	4bb8      	ldr	r3, [pc, #736]	; (8019fb0 <CST_cmd+0xeb8>)
 8019cce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019cd2:	463a      	mov	r2, r7
 8019cd4:	49b7      	ldr	r1, [pc, #732]	; (8019fb4 <CST_cmd+0xebc>)
 8019cd6:	4620      	mov	r0, r4
 8019cd8:	f00c fdb6 	bl	8026848 <sprintf>
 8019cdc:	4620      	mov	r0, r4
 8019cde:	f005 fb24 	bl	801f32a <crs_strlen>
 8019ce2:	b283      	uxth	r3, r0
 8019ce4:	4622      	mov	r2, r4
 8019ce6:	2101      	movs	r1, #1
 8019ce8:	2007      	movs	r0, #7
 8019cea:	f005 fb61 	bl	801f3b0 <traceIF_itmPrint>
 8019cee:	4620      	mov	r0, r4
 8019cf0:	f005 fb1b 	bl	801f32a <crs_strlen>
 8019cf4:	b282      	uxth	r2, r0
 8019cf6:	4621      	mov	r1, r4
 8019cf8:	2007      	movs	r0, #7
 8019cfa:	f005 fb93 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("APN                  : \"%s\"", cst_cmd_cellular_params.sim_slot[i].apn)
 8019cfe:	f105 0208 	add.w	r2, r5, #8
 8019d02:	4432      	add	r2, r6
 8019d04:	3204      	adds	r2, #4
 8019d06:	49ac      	ldr	r1, [pc, #688]	; (8019fb8 <CST_cmd+0xec0>)
 8019d08:	4620      	mov	r0, r4
 8019d0a:	f00c fd9d 	bl	8026848 <sprintf>
 8019d0e:	4620      	mov	r0, r4
 8019d10:	f005 fb0b 	bl	801f32a <crs_strlen>
 8019d14:	b283      	uxth	r3, r0
 8019d16:	4622      	mov	r2, r4
 8019d18:	2101      	movs	r1, #1
 8019d1a:	2007      	movs	r0, #7
 8019d1c:	f005 fb48 	bl	801f3b0 <traceIF_itmPrint>
 8019d20:	4620      	mov	r0, r4
 8019d22:	f005 fb02 	bl	801f32a <crs_strlen>
 8019d26:	b282      	uxth	r2, r0
 8019d28:	4621      	mov	r1, r4
 8019d2a:	2007      	movs	r0, #7
 8019d2c:	f005 fb7a 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("CID                  : %d", cst_cmd_cellular_params.sim_slot[i].cid)
 8019d30:	f898 202c 	ldrb.w	r2, [r8, #44]	; 0x2c
 8019d34:	49a1      	ldr	r1, [pc, #644]	; (8019fbc <CST_cmd+0xec4>)
 8019d36:	4620      	mov	r0, r4
 8019d38:	f00c fd86 	bl	8026848 <sprintf>
 8019d3c:	4620      	mov	r0, r4
 8019d3e:	f005 faf4 	bl	801f32a <crs_strlen>
 8019d42:	b283      	uxth	r3, r0
 8019d44:	4622      	mov	r2, r4
 8019d46:	2101      	movs	r1, #1
 8019d48:	2007      	movs	r0, #7
 8019d4a:	f005 fb31 	bl	801f3b0 <traceIF_itmPrint>
 8019d4e:	4620      	mov	r0, r4
 8019d50:	f005 faeb 	bl	801f32a <crs_strlen>
 8019d54:	b282      	uxth	r2, r0
 8019d56:	4621      	mov	r1, r4
 8019d58:	2007      	movs	r0, #7
 8019d5a:	f005 fb63 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("username             : %s", cst_cmd_cellular_params.sim_slot[i].username)
 8019d5e:	f105 0228 	add.w	r2, r5, #40	; 0x28
 8019d62:	4432      	add	r2, r6
 8019d64:	3205      	adds	r2, #5
 8019d66:	4996      	ldr	r1, [pc, #600]	; (8019fc0 <CST_cmd+0xec8>)
 8019d68:	4620      	mov	r0, r4
 8019d6a:	f00c fd6d 	bl	8026848 <sprintf>
 8019d6e:	4620      	mov	r0, r4
 8019d70:	f005 fadb 	bl	801f32a <crs_strlen>
 8019d74:	b283      	uxth	r3, r0
 8019d76:	4622      	mov	r2, r4
 8019d78:	2101      	movs	r1, #1
 8019d7a:	2007      	movs	r0, #7
 8019d7c:	f005 fb18 	bl	801f3b0 <traceIF_itmPrint>
 8019d80:	4620      	mov	r0, r4
 8019d82:	f005 fad2 	bl	801f32a <crs_strlen>
 8019d86:	b282      	uxth	r2, r0
 8019d88:	4621      	mov	r1, r4
 8019d8a:	2007      	movs	r0, #7
 8019d8c:	f005 fb4a 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("password             : %s", cst_cmd_cellular_params.sim_slot[i].password)
 8019d90:	3548      	adds	r5, #72	; 0x48
 8019d92:	1972      	adds	r2, r6, r5
 8019d94:	3205      	adds	r2, #5
 8019d96:	498b      	ldr	r1, [pc, #556]	; (8019fc4 <CST_cmd+0xecc>)
 8019d98:	4620      	mov	r0, r4
 8019d9a:	f00c fd55 	bl	8026848 <sprintf>
 8019d9e:	4620      	mov	r0, r4
 8019da0:	f005 fac3 	bl	801f32a <crs_strlen>
 8019da4:	b283      	uxth	r3, r0
 8019da6:	4622      	mov	r2, r4
 8019da8:	2101      	movs	r1, #1
 8019daa:	2007      	movs	r0, #7
 8019dac:	f005 fb00 	bl	801f3b0 <traceIF_itmPrint>
 8019db0:	4620      	mov	r0, r4
 8019db2:	f005 faba 	bl	801f32a <crs_strlen>
 8019db6:	b282      	uxth	r2, r0
 8019db8:	4621      	mov	r1, r4
 8019dba:	2007      	movs	r0, #7
 8019dbc:	f005 fb32 	bl	801f424 <traceIF_uartPrintForce>
        for (i = 0 ; i < cst_cmd_cellular_params.sim_slot_nb ; i++)
 8019dc0:	3701      	adds	r7, #1
 8019dc2:	e775      	b.n	8019cb0 <CST_cmd+0xbb8>
        PRINT_FORCE("Target state         : %s", CST_TargetStateName_p[cst_cmd_cellular_params.target_state])
 8019dc4:	4d77      	ldr	r5, [pc, #476]	; (8019fa4 <CST_cmd+0xeac>)
 8019dc6:	f895 2131 	ldrb.w	r2, [r5, #305]	; 0x131
 8019dca:	4c74      	ldr	r4, [pc, #464]	; (8019f9c <CST_cmd+0xea4>)
 8019dcc:	4b7e      	ldr	r3, [pc, #504]	; (8019fc8 <CST_cmd+0xed0>)
 8019dce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019dd2:	497e      	ldr	r1, [pc, #504]	; (8019fcc <CST_cmd+0xed4>)
 8019dd4:	4620      	mov	r0, r4
 8019dd6:	f00c fd37 	bl	8026848 <sprintf>
 8019dda:	4620      	mov	r0, r4
 8019ddc:	f005 faa5 	bl	801f32a <crs_strlen>
 8019de0:	b283      	uxth	r3, r0
 8019de2:	4622      	mov	r2, r4
 8019de4:	2101      	movs	r1, #1
 8019de6:	2007      	movs	r0, #7
 8019de8:	f005 fae2 	bl	801f3b0 <traceIF_itmPrint>
 8019dec:	4620      	mov	r0, r4
 8019dee:	f005 fa9c 	bl	801f32a <crs_strlen>
 8019df2:	b282      	uxth	r2, r0
 8019df4:	4621      	mov	r1, r4
 8019df6:	2007      	movs	r0, #7
 8019df8:	f005 fb14 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("Attachment timeout   : %ld ms", cst_cmd_cellular_params.attachment_timeout)
 8019dfc:	f8d5 2134 	ldr.w	r2, [r5, #308]	; 0x134
 8019e00:	4973      	ldr	r1, [pc, #460]	; (8019fd0 <CST_cmd+0xed8>)
 8019e02:	4620      	mov	r0, r4
 8019e04:	f00c fd20 	bl	8026848 <sprintf>
 8019e08:	4620      	mov	r0, r4
 8019e0a:	f005 fa8e 	bl	801f32a <crs_strlen>
 8019e0e:	b283      	uxth	r3, r0
 8019e10:	4622      	mov	r2, r4
 8019e12:	2101      	movs	r1, #1
 8019e14:	2007      	movs	r0, #7
 8019e16:	f005 facb 	bl	801f3b0 <traceIF_itmPrint>
 8019e1a:	4620      	mov	r0, r4
 8019e1c:	f005 fa85 	bl	801f32a <crs_strlen>
 8019e20:	b282      	uxth	r2, r0
 8019e22:	4621      	mov	r1, r4
 8019e24:	2007      	movs	r0, #7
 8019e26:	f005 fafd 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("nfmc mode            : %s", CST_ActivateName_p[cst_cmd_cellular_params.nfmc_active])
 8019e2a:	f895 217c 	ldrb.w	r2, [r5, #380]	; 0x17c
 8019e2e:	4b69      	ldr	r3, [pc, #420]	; (8019fd4 <CST_cmd+0xedc>)
 8019e30:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8019e34:	4968      	ldr	r1, [pc, #416]	; (8019fd8 <CST_cmd+0xee0>)
 8019e36:	4620      	mov	r0, r4
 8019e38:	f00c fd06 	bl	8026848 <sprintf>
 8019e3c:	4620      	mov	r0, r4
 8019e3e:	f005 fa74 	bl	801f32a <crs_strlen>
 8019e42:	b283      	uxth	r3, r0
 8019e44:	4622      	mov	r2, r4
 8019e46:	2101      	movs	r1, #1
 8019e48:	2007      	movs	r0, #7
 8019e4a:	f005 fab1 	bl	801f3b0 <traceIF_itmPrint>
 8019e4e:	4620      	mov	r0, r4
 8019e50:	f005 fa6b 	bl	801f32a <crs_strlen>
 8019e54:	b282      	uxth	r2, r0
 8019e56:	4621      	mov	r1, r4
 8019e58:	2007      	movs	r0, #7
 8019e5a:	f005 fae3 	bl	801f424 <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.nfmc_active != 0U)
 8019e5e:	f895 317c 	ldrb.w	r3, [r5, #380]	; 0x17c
 8019e62:	2b00      	cmp	r3, #0
 8019e64:	d164      	bne.n	8019f30 <CST_cmd+0xe38>
        PRINT_FORCE("Network register mode: %d = %s", cst_cmd_cellular_params.operator_selector.network_reg_mode,
 8019e66:	4d4f      	ldr	r5, [pc, #316]	; (8019fa4 <CST_cmd+0xeac>)
 8019e68:	f895 2138 	ldrb.w	r2, [r5, #312]	; 0x138
 8019e6c:	4c4b      	ldr	r4, [pc, #300]	; (8019f9c <CST_cmd+0xea4>)
 8019e6e:	4b5b      	ldr	r3, [pc, #364]	; (8019fdc <CST_cmd+0xee4>)
 8019e70:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019e74:	495a      	ldr	r1, [pc, #360]	; (8019fe0 <CST_cmd+0xee8>)
 8019e76:	4620      	mov	r0, r4
 8019e78:	f00c fce6 	bl	8026848 <sprintf>
 8019e7c:	4620      	mov	r0, r4
 8019e7e:	f005 fa54 	bl	801f32a <crs_strlen>
 8019e82:	b283      	uxth	r3, r0
 8019e84:	4622      	mov	r2, r4
 8019e86:	2101      	movs	r1, #1
 8019e88:	2007      	movs	r0, #7
 8019e8a:	f005 fa91 	bl	801f3b0 <traceIF_itmPrint>
 8019e8e:	4620      	mov	r0, r4
 8019e90:	f005 fa4b 	bl	801f32a <crs_strlen>
 8019e94:	b282      	uxth	r2, r0
 8019e96:	4621      	mov	r1, r4
 8019e98:	2007      	movs	r0, #7
 8019e9a:	f005 fac3 	bl	801f424 <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.operator_selector.network_reg_mode != DC_NRM_AUTO)
 8019e9e:	f895 3138 	ldrb.w	r3, [r5, #312]	; 0x138
 8019ea2:	2b00      	cmp	r3, #0
 8019ea4:	d146      	bne.n	8019f34 <CST_cmd+0xe3c>
        PRINT_FORCE("Access techno present: %s",
 8019ea6:	4b3f      	ldr	r3, [pc, #252]	; (8019fa4 <CST_cmd+0xeac>)
 8019ea8:	f893 317a 	ldrb.w	r3, [r3, #378]	; 0x17a
 8019eac:	2b00      	cmp	r3, #0
 8019eae:	f000 80a5 	beq.w	8019ffc <CST_cmd+0xf04>
 8019eb2:	4a4c      	ldr	r2, [pc, #304]	; (8019fe4 <CST_cmd+0xeec>)
 8019eb4:	4c39      	ldr	r4, [pc, #228]	; (8019f9c <CST_cmd+0xea4>)
 8019eb6:	494c      	ldr	r1, [pc, #304]	; (8019fe8 <CST_cmd+0xef0>)
 8019eb8:	4620      	mov	r0, r4
 8019eba:	f00c fcc5 	bl	8026848 <sprintf>
 8019ebe:	4620      	mov	r0, r4
 8019ec0:	f005 fa33 	bl	801f32a <crs_strlen>
 8019ec4:	b283      	uxth	r3, r0
 8019ec6:	4622      	mov	r2, r4
 8019ec8:	2101      	movs	r1, #1
 8019eca:	2007      	movs	r0, #7
 8019ecc:	f005 fa70 	bl	801f3b0 <traceIF_itmPrint>
 8019ed0:	4620      	mov	r0, r4
 8019ed2:	f005 fa2a 	bl	801f32a <crs_strlen>
 8019ed6:	b282      	uxth	r2, r0
 8019ed8:	4621      	mov	r1, r4
 8019eda:	2007      	movs	r0, #7
 8019edc:	f005 faa2 	bl	801f424 <traceIF_uartPrintForce>
        if (cst_cmd_cellular_params.operator_selector.access_techno_present != DC_ACT_PRESENT_FALSE)
 8019ee0:	4b30      	ldr	r3, [pc, #192]	; (8019fa4 <CST_cmd+0xeac>)
 8019ee2:	f893 317a 	ldrb.w	r3, [r3, #378]	; 0x17a
 8019ee6:	2b00      	cmp	r3, #0
 8019ee8:	f040 808a 	bne.w	801a000 <CST_cmd+0xf08>
  cmd_status = CMD_OK;
 8019eec:	2500      	movs	r5, #0
 8019eee:	e1fe      	b.n	801a2ee <CST_cmd+0x11f6>
            PRINT_FORCE("nfmc value %ld       : %ld", i + 1U, cst_cmd_cellular_params.nfmc_value[i])
 8019ef0:	1c5d      	adds	r5, r3, #1
 8019ef2:	3360      	adds	r3, #96	; 0x60
 8019ef4:	4c29      	ldr	r4, [pc, #164]	; (8019f9c <CST_cmd+0xea4>)
 8019ef6:	4a2b      	ldr	r2, [pc, #172]	; (8019fa4 <CST_cmd+0xeac>)
 8019ef8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8019efc:	462a      	mov	r2, r5
 8019efe:	493b      	ldr	r1, [pc, #236]	; (8019fec <CST_cmd+0xef4>)
 8019f00:	4620      	mov	r0, r4
 8019f02:	f00c fca1 	bl	8026848 <sprintf>
 8019f06:	4620      	mov	r0, r4
 8019f08:	f005 fa0f 	bl	801f32a <crs_strlen>
 8019f0c:	b283      	uxth	r3, r0
 8019f0e:	4622      	mov	r2, r4
 8019f10:	2101      	movs	r1, #1
 8019f12:	2007      	movs	r0, #7
 8019f14:	f005 fa4c 	bl	801f3b0 <traceIF_itmPrint>
 8019f18:	4620      	mov	r0, r4
 8019f1a:	f005 fa06 	bl	801f32a <crs_strlen>
 8019f1e:	b282      	uxth	r2, r0
 8019f20:	4621      	mov	r1, r4
 8019f22:	2007      	movs	r0, #7
 8019f24:	f005 fa7e 	bl	801f424 <traceIF_uartPrintForce>
          for (i = 0U; i < DC_NFMC_TEMPO_NB ; i++)
 8019f28:	462b      	mov	r3, r5
 8019f2a:	2b06      	cmp	r3, #6
 8019f2c:	d9e0      	bls.n	8019ef0 <CST_cmd+0xdf8>
 8019f2e:	e79a      	b.n	8019e66 <CST_cmd+0xd6e>
 8019f30:	2300      	movs	r3, #0
 8019f32:	e7fa      	b.n	8019f2a <CST_cmd+0xe32>
          PRINT_FORCE("Operator name format: %d (%s)",
 8019f34:	f895 2139 	ldrb.w	r2, [r5, #313]	; 0x139
 8019f38:	4b2d      	ldr	r3, [pc, #180]	; (8019ff0 <CST_cmd+0xef8>)
 8019f3a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8019f3e:	492d      	ldr	r1, [pc, #180]	; (8019ff4 <CST_cmd+0xefc>)
 8019f40:	4620      	mov	r0, r4
 8019f42:	f00c fc81 	bl	8026848 <sprintf>
 8019f46:	4620      	mov	r0, r4
 8019f48:	f005 f9ef 	bl	801f32a <crs_strlen>
 8019f4c:	b283      	uxth	r3, r0
 8019f4e:	4622      	mov	r2, r4
 8019f50:	2101      	movs	r1, #1
 8019f52:	2007      	movs	r0, #7
 8019f54:	f005 fa2c 	bl	801f3b0 <traceIF_itmPrint>
 8019f58:	4620      	mov	r0, r4
 8019f5a:	f005 f9e6 	bl	801f32a <crs_strlen>
 8019f5e:	b282      	uxth	r2, r0
 8019f60:	4621      	mov	r1, r4
 8019f62:	2007      	movs	r0, #7
 8019f64:	f005 fa5e 	bl	801f424 <traceIF_uartPrintForce>
          PRINT_FORCE("Operator name: %s\n\r", cst_cmd_cellular_params.operator_selector.operator_name);
 8019f68:	f505 729d 	add.w	r2, r5, #314	; 0x13a
 8019f6c:	4922      	ldr	r1, [pc, #136]	; (8019ff8 <CST_cmd+0xf00>)
 8019f6e:	4620      	mov	r0, r4
 8019f70:	f00c fc6a 	bl	8026848 <sprintf>
 8019f74:	4620      	mov	r0, r4
 8019f76:	f005 f9d8 	bl	801f32a <crs_strlen>
 8019f7a:	b283      	uxth	r3, r0
 8019f7c:	4622      	mov	r2, r4
 8019f7e:	2101      	movs	r1, #1
 8019f80:	2007      	movs	r0, #7
 8019f82:	f005 fa15 	bl	801f3b0 <traceIF_itmPrint>
 8019f86:	4620      	mov	r0, r4
 8019f88:	f005 f9cf 	bl	801f32a <crs_strlen>
 8019f8c:	b282      	uxth	r2, r0
 8019f8e:	4621      	mov	r1, r4
 8019f90:	2007      	movs	r0, #7
 8019f92:	f005 fa47 	bl	801f424 <traceIF_uartPrintForce>
 8019f96:	e786      	b.n	8019ea6 <CST_cmd+0xdae>
 8019f98:	08033838 	.word	0x08033838
 8019f9c:	20004ddc 	.word	0x20004ddc
 8019fa0:	08033df8 	.word	0x08033df8
 8019fa4:	20003b10 	.word	0x20003b10
 8019fa8:	20000232 	.word	0x20000232
 8019fac:	200058b0 	.word	0x200058b0
 8019fb0:	20000058 	.word	0x20000058
 8019fb4:	08033e18 	.word	0x08033e18
 8019fb8:	08033e3c 	.word	0x08033e3c
 8019fbc:	08033e5c 	.word	0x08033e5c
 8019fc0:	08033e78 	.word	0x08033e78
 8019fc4:	08033e94 	.word	0x08033e94
 8019fc8:	08034228 	.word	0x08034228
 8019fcc:	08033eb0 	.word	0x08033eb0
 8019fd0:	08033ecc 	.word	0x08033ecc
 8019fd4:	080341ec 	.word	0x080341ec
 8019fd8:	08033eec 	.word	0x08033eec
 8019fdc:	0803425c 	.word	0x0803425c
 8019fe0:	08033f28 	.word	0x08033f28
 8019fe4:	08033a4c 	.word	0x08033a4c
 8019fe8:	08033f84 	.word	0x08033f84
 8019fec:	08033f08 	.word	0x08033f08
 8019ff0:	0803426c 	.word	0x0803426c
 8019ff4:	08033f4c 	.word	0x08033f4c
 8019ff8:	08033f6c 	.word	0x08033f6c
        PRINT_FORCE("Access techno present: %s",
 8019ffc:	4abe      	ldr	r2, [pc, #760]	; (801a2f8 <CST_cmd+0x1200>)
 8019ffe:	e759      	b.n	8019eb4 <CST_cmd+0xdbc>
          PRINT_FORCE("Network register mode: %d (%s)", cst_cmd_cellular_params.operator_selector.access_techno,
 801a000:	4bbe      	ldr	r3, [pc, #760]	; (801a2fc <CST_cmd+0x1204>)
 801a002:	f893 217b 	ldrb.w	r2, [r3, #379]	; 0x17b
 801a006:	4bbe      	ldr	r3, [pc, #760]	; (801a300 <CST_cmd+0x1208>)
 801a008:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801a00c:	49bd      	ldr	r1, [pc, #756]	; (801a304 <CST_cmd+0x120c>)
 801a00e:	4620      	mov	r0, r4
 801a010:	f00c fc1a 	bl	8026848 <sprintf>
 801a014:	4620      	mov	r0, r4
 801a016:	f005 f988 	bl	801f32a <crs_strlen>
 801a01a:	b283      	uxth	r3, r0
 801a01c:	4622      	mov	r2, r4
 801a01e:	2101      	movs	r1, #1
 801a020:	2007      	movs	r0, #7
 801a022:	f005 f9c5 	bl	801f3b0 <traceIF_itmPrint>
 801a026:	4620      	mov	r0, r4
 801a028:	f005 f97f 	bl	801f32a <crs_strlen>
 801a02c:	b282      	uxth	r2, r0
 801a02e:	4621      	mov	r1, r4
 801a030:	2007      	movs	r0, #7
 801a032:	f005 f9f7 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 801a036:	2500      	movs	r5, #0
 801a038:	e159      	b.n	801a2ee <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "power", crs_strlen(argv_p[0])) == 0)
 801a03a:	4630      	mov	r0, r6
 801a03c:	f005 f975 	bl	801f32a <crs_strlen>
 801a040:	4602      	mov	r2, r0
 801a042:	49b1      	ldr	r1, [pc, #708]	; (801a308 <CST_cmd+0x1210>)
 801a044:	4630      	mov	r0, r6
 801a046:	f00c fc62 	bl	802690e <memcmp>
 801a04a:	2800      	cmp	r0, #0
 801a04c:	f040 8090 	bne.w	801a170 <CST_cmd+0x1078>
        if (argc == 2U)
 801a050:	2c02      	cmp	r4, #2
 801a052:	d001      	beq.n	801a058 <CST_cmd+0xf60>
  cmd_status = CMD_OK;
 801a054:	2500      	movs	r5, #0
 801a056:	e14a      	b.n	801a2ee <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "on", crs_strlen(argv_p[1])) == 0)
 801a058:	9c02      	ldr	r4, [sp, #8]
 801a05a:	4620      	mov	r0, r4
 801a05c:	f005 f965 	bl	801f32a <crs_strlen>
 801a060:	4602      	mov	r2, r0
 801a062:	49aa      	ldr	r1, [pc, #680]	; (801a30c <CST_cmd+0x1214>)
 801a064:	4620      	mov	r0, r4
 801a066:	f00c fc52 	bl	802690e <memcmp>
 801a06a:	2800      	cmp	r0, #0
 801a06c:	d13a      	bne.n	801a0e4 <CST_cmd+0xfec>
            PRINT_FORCE("modem power ON")
 801a06e:	4ca8      	ldr	r4, [pc, #672]	; (801a310 <CST_cmd+0x1218>)
 801a070:	4da8      	ldr	r5, [pc, #672]	; (801a314 <CST_cmd+0x121c>)
 801a072:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a074:	6020      	str	r0, [r4, #0]
 801a076:	6061      	str	r1, [r4, #4]
 801a078:	60a2      	str	r2, [r4, #8]
 801a07a:	60e3      	str	r3, [r4, #12]
 801a07c:	782b      	ldrb	r3, [r5, #0]
 801a07e:	7423      	strb	r3, [r4, #16]
 801a080:	4620      	mov	r0, r4
 801a082:	f005 f952 	bl	801f32a <crs_strlen>
 801a086:	b283      	uxth	r3, r0
 801a088:	4622      	mov	r2, r4
 801a08a:	2101      	movs	r1, #1
 801a08c:	2007      	movs	r0, #7
 801a08e:	f005 f98f 	bl	801f3b0 <traceIF_itmPrint>
 801a092:	4620      	mov	r0, r4
 801a094:	f005 f949 	bl	801f32a <crs_strlen>
 801a098:	b282      	uxth	r2, r0
 801a09a:	4621      	mov	r1, r4
 801a09c:	2007      	movs	r0, #7
 801a09e:	f005 f9c1 	bl	801f424 <traceIF_uartPrintForce>
            if (osCDS_power_on() != CELLULAR_OK)
 801a0a2:	f000 fdd7 	bl	801ac54 <osCDS_power_on>
 801a0a6:	4605      	mov	r5, r0
 801a0a8:	2800      	cmp	r0, #0
 801a0aa:	f000 8120 	beq.w	801a2ee <CST_cmd+0x11f6>
              PRINT_FORCE("command fail\n\r")
 801a0ae:	4d9a      	ldr	r5, [pc, #616]	; (801a318 <CST_cmd+0x1220>)
 801a0b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a0b2:	6020      	str	r0, [r4, #0]
 801a0b4:	6061      	str	r1, [r4, #4]
 801a0b6:	60a2      	str	r2, [r4, #8]
 801a0b8:	60e3      	str	r3, [r4, #12]
 801a0ba:	782b      	ldrb	r3, [r5, #0]
 801a0bc:	7423      	strb	r3, [r4, #16]
 801a0be:	4620      	mov	r0, r4
 801a0c0:	f005 f933 	bl	801f32a <crs_strlen>
 801a0c4:	b283      	uxth	r3, r0
 801a0c6:	4622      	mov	r2, r4
 801a0c8:	2101      	movs	r1, #1
 801a0ca:	2007      	movs	r0, #7
 801a0cc:	f005 f970 	bl	801f3b0 <traceIF_itmPrint>
 801a0d0:	4620      	mov	r0, r4
 801a0d2:	f005 f92a 	bl	801f32a <crs_strlen>
 801a0d6:	b282      	uxth	r2, r0
 801a0d8:	4621      	mov	r1, r4
 801a0da:	2007      	movs	r0, #7
 801a0dc:	f005 f9a2 	bl	801f424 <traceIF_uartPrintForce>
              cmd_status = CMD_PROCESS_ERROR;
 801a0e0:	2502      	movs	r5, #2
 801a0e2:	e104      	b.n	801a2ee <CST_cmd+0x11f6>
          else if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 801a0e4:	4620      	mov	r0, r4
 801a0e6:	f005 f920 	bl	801f32a <crs_strlen>
 801a0ea:	4602      	mov	r2, r0
 801a0ec:	498b      	ldr	r1, [pc, #556]	; (801a31c <CST_cmd+0x1224>)
 801a0ee:	4620      	mov	r0, r4
 801a0f0:	f00c fc0d 	bl	802690e <memcmp>
 801a0f4:	b108      	cbz	r0, 801a0fa <CST_cmd+0x1002>
  cmd_status = CMD_OK;
 801a0f6:	2500      	movs	r5, #0
 801a0f8:	e0f9      	b.n	801a2ee <CST_cmd+0x11f6>
            PRINT_FORCE("modem power OFF")
 801a0fa:	4c85      	ldr	r4, [pc, #532]	; (801a310 <CST_cmd+0x1218>)
 801a0fc:	4d88      	ldr	r5, [pc, #544]	; (801a320 <CST_cmd+0x1228>)
 801a0fe:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a100:	6020      	str	r0, [r4, #0]
 801a102:	6061      	str	r1, [r4, #4]
 801a104:	60a2      	str	r2, [r4, #8]
 801a106:	60e3      	str	r3, [r4, #12]
 801a108:	882b      	ldrh	r3, [r5, #0]
 801a10a:	8223      	strh	r3, [r4, #16]
 801a10c:	4620      	mov	r0, r4
 801a10e:	f005 f90c 	bl	801f32a <crs_strlen>
 801a112:	b283      	uxth	r3, r0
 801a114:	4622      	mov	r2, r4
 801a116:	2101      	movs	r1, #1
 801a118:	2007      	movs	r0, #7
 801a11a:	f005 f949 	bl	801f3b0 <traceIF_itmPrint>
 801a11e:	4620      	mov	r0, r4
 801a120:	f005 f903 	bl	801f32a <crs_strlen>
 801a124:	b282      	uxth	r2, r0
 801a126:	4621      	mov	r1, r4
 801a128:	2007      	movs	r0, #7
 801a12a:	f005 f97b 	bl	801f424 <traceIF_uartPrintForce>
            if (osCDS_power_off() != CELLULAR_OK)
 801a12e:	f000 fda3 	bl	801ac78 <osCDS_power_off>
 801a132:	4605      	mov	r5, r0
 801a134:	2800      	cmp	r0, #0
 801a136:	f000 80da 	beq.w	801a2ee <CST_cmd+0x11f6>
              PRINT_FORCE("command fail\n\r")
 801a13a:	4d77      	ldr	r5, [pc, #476]	; (801a318 <CST_cmd+0x1220>)
 801a13c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a13e:	6020      	str	r0, [r4, #0]
 801a140:	6061      	str	r1, [r4, #4]
 801a142:	60a2      	str	r2, [r4, #8]
 801a144:	60e3      	str	r3, [r4, #12]
 801a146:	782b      	ldrb	r3, [r5, #0]
 801a148:	7423      	strb	r3, [r4, #16]
 801a14a:	4620      	mov	r0, r4
 801a14c:	f005 f8ed 	bl	801f32a <crs_strlen>
 801a150:	b283      	uxth	r3, r0
 801a152:	4622      	mov	r2, r4
 801a154:	2101      	movs	r1, #1
 801a156:	2007      	movs	r0, #7
 801a158:	f005 f92a 	bl	801f3b0 <traceIF_itmPrint>
 801a15c:	4620      	mov	r0, r4
 801a15e:	f005 f8e4 	bl	801f32a <crs_strlen>
 801a162:	b282      	uxth	r2, r0
 801a164:	4621      	mov	r1, r4
 801a166:	2007      	movs	r0, #7
 801a168:	f005 f95c 	bl	801f424 <traceIF_uartPrintForce>
              cmd_status = CMD_PROCESS_ERROR;
 801a16c:	2502      	movs	r5, #2
 801a16e:	e0be      	b.n	801a2ee <CST_cmd+0x11f6>
      else if (memcmp((CRC_CHAR_t *)argv_p[0], "techno", crs_strlen(argv_p[0])) == 0)
 801a170:	4630      	mov	r0, r6
 801a172:	f005 f8da 	bl	801f32a <crs_strlen>
 801a176:	4602      	mov	r2, r0
 801a178:	496a      	ldr	r1, [pc, #424]	; (801a324 <CST_cmd+0x122c>)
 801a17a:	4630      	mov	r0, r6
 801a17c:	f00c fbc7 	bl	802690e <memcmp>
 801a180:	2800      	cmp	r0, #0
 801a182:	d178      	bne.n	801a276 <CST_cmd+0x117e>
        if (argc == 3U)
 801a184:	2c03      	cmp	r4, #3
 801a186:	d01c      	beq.n	801a1c2 <CST_cmd+0x10ca>
        else if (argc == 2U)
 801a188:	2c02      	cmp	r4, #2
 801a18a:	d05c      	beq.n	801a246 <CST_cmd+0x114e>
          PRINT_FORCE("%s bad command. Usage:", cmd_p)
 801a18c:	4c60      	ldr	r4, [pc, #384]	; (801a310 <CST_cmd+0x1218>)
 801a18e:	462a      	mov	r2, r5
 801a190:	4965      	ldr	r1, [pc, #404]	; (801a328 <CST_cmd+0x1230>)
 801a192:	4620      	mov	r0, r4
 801a194:	f00c fb58 	bl	8026848 <sprintf>
 801a198:	4620      	mov	r0, r4
 801a19a:	f005 f8c6 	bl	801f32a <crs_strlen>
 801a19e:	b283      	uxth	r3, r0
 801a1a0:	4622      	mov	r2, r4
 801a1a2:	2101      	movs	r1, #1
 801a1a4:	2007      	movs	r0, #7
 801a1a6:	f005 f903 	bl	801f3b0 <traceIF_itmPrint>
 801a1aa:	4620      	mov	r0, r4
 801a1ac:	f005 f8bd 	bl	801f32a <crs_strlen>
 801a1b0:	b282      	uxth	r2, r0
 801a1b2:	4621      	mov	r1, r4
 801a1b4:	2007      	movs	r0, #7
 801a1b6:	f005 f935 	bl	801f424 <traceIF_uartPrintForce>
          CST_HelpCmd();
 801a1ba:	f7fe fae3 	bl	8018784 <CST_HelpCmd>
          cmd_status = CMD_SYNTAX_ERROR;
 801a1be:	2501      	movs	r5, #1
 801a1c0:	e095      	b.n	801a2ee <CST_cmd+0x11f6>
          (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a1c2:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a1c6:	4a4d      	ldr	r2, [pc, #308]	; (801a2fc <CST_cmd+0x1204>)
 801a1c8:	4958      	ldr	r1, [pc, #352]	; (801a32c <CST_cmd+0x1234>)
 801a1ca:	8809      	ldrh	r1, [r1, #0]
 801a1cc:	4858      	ldr	r0, [pc, #352]	; (801a330 <CST_cmd+0x1238>)
 801a1ce:	f007 ffaf 	bl	8022130 <dc_com_read>
          tmpConversion = (uint8_t)crs_atoi(argv_p[2]);
 801a1d2:	9803      	ldr	r0, [sp, #12]
 801a1d4:	f005 f864 	bl	801f2a0 <crs_atoi>
 801a1d8:	b2c4      	uxtb	r4, r0
          if ((memcmp((CRC_CHAR_t *)argv_p[1], "on", crs_strlen(argv_p[1])) == 0) && (tmpConversion <= 9U))
 801a1da:	9e02      	ldr	r6, [sp, #8]
 801a1dc:	4630      	mov	r0, r6
 801a1de:	f005 f8a4 	bl	801f32a <crs_strlen>
 801a1e2:	4602      	mov	r2, r0
 801a1e4:	4949      	ldr	r1, [pc, #292]	; (801a30c <CST_cmd+0x1214>)
 801a1e6:	4630      	mov	r0, r6
 801a1e8:	f00c fb91 	bl	802690e <memcmp>
 801a1ec:	b908      	cbnz	r0, 801a1f2 <CST_cmd+0x10fa>
 801a1ee:	2c09      	cmp	r4, #9
 801a1f0:	d91a      	bls.n	801a228 <CST_cmd+0x1130>
            PRINT_FORCE("%s bad command. Usage:", cmd_p)
 801a1f2:	4c47      	ldr	r4, [pc, #284]	; (801a310 <CST_cmd+0x1218>)
 801a1f4:	462a      	mov	r2, r5
 801a1f6:	494c      	ldr	r1, [pc, #304]	; (801a328 <CST_cmd+0x1230>)
 801a1f8:	4620      	mov	r0, r4
 801a1fa:	f00c fb25 	bl	8026848 <sprintf>
 801a1fe:	4620      	mov	r0, r4
 801a200:	f005 f893 	bl	801f32a <crs_strlen>
 801a204:	b283      	uxth	r3, r0
 801a206:	4622      	mov	r2, r4
 801a208:	2101      	movs	r1, #1
 801a20a:	2007      	movs	r0, #7
 801a20c:	f005 f8d0 	bl	801f3b0 <traceIF_itmPrint>
 801a210:	4620      	mov	r0, r4
 801a212:	f005 f88a 	bl	801f32a <crs_strlen>
 801a216:	b282      	uxth	r2, r0
 801a218:	4621      	mov	r1, r4
 801a21a:	2007      	movs	r0, #7
 801a21c:	f005 f902 	bl	801f424 <traceIF_uartPrintForce>
            CST_HelpCmd();
 801a220:	f7fe fab0 	bl	8018784 <CST_HelpCmd>
            cmd_status = CMD_SYNTAX_ERROR;
 801a224:	2501      	movs	r5, #1
 801a226:	e062      	b.n	801a2ee <CST_cmd+0x11f6>
            cst_cmd_cellular_params.operator_selector.access_techno_present = DC_ACT_PRESENT_TRUE;
 801a228:	4a34      	ldr	r2, [pc, #208]	; (801a2fc <CST_cmd+0x1204>)
 801a22a:	2301      	movs	r3, #1
 801a22c:	f882 317a 	strb.w	r3, [r2, #378]	; 0x17a
            cst_cmd_cellular_params.operator_selector.access_techno = (dc_access_techno_t)tmpConversion;
 801a230:	f882 417b 	strb.w	r4, [r2, #379]	; 0x17b
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a234:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a238:	493c      	ldr	r1, [pc, #240]	; (801a32c <CST_cmd+0x1234>)
 801a23a:	8809      	ldrh	r1, [r1, #0]
 801a23c:	483c      	ldr	r0, [pc, #240]	; (801a330 <CST_cmd+0x1238>)
 801a23e:	f007 ff2b 	bl	8022098 <dc_com_write>
  cmd_status = CMD_OK;
 801a242:	2500      	movs	r5, #0
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a244:	e053      	b.n	801a2ee <CST_cmd+0x11f6>
          if (memcmp((CRC_CHAR_t *)argv_p[1], "off", crs_strlen(argv_p[1])) == 0)
 801a246:	9c02      	ldr	r4, [sp, #8]
 801a248:	4620      	mov	r0, r4
 801a24a:	f005 f86e 	bl	801f32a <crs_strlen>
 801a24e:	4602      	mov	r2, r0
 801a250:	4932      	ldr	r1, [pc, #200]	; (801a31c <CST_cmd+0x1224>)
 801a252:	4620      	mov	r0, r4
 801a254:	f00c fb5b 	bl	802690e <memcmp>
 801a258:	b918      	cbnz	r0, 801a262 <CST_cmd+0x116a>
            cst_cmd_cellular_params.operator_selector.access_techno_present = DC_ACT_PRESENT_FALSE;
 801a25a:	4b28      	ldr	r3, [pc, #160]	; (801a2fc <CST_cmd+0x1204>)
 801a25c:	2200      	movs	r2, #0
 801a25e:	f883 217a 	strb.w	r2, [r3, #378]	; 0x17a
          (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cmd_cellular_params,
 801a262:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a266:	4a25      	ldr	r2, [pc, #148]	; (801a2fc <CST_cmd+0x1204>)
 801a268:	4930      	ldr	r1, [pc, #192]	; (801a32c <CST_cmd+0x1234>)
 801a26a:	8809      	ldrh	r1, [r1, #0]
 801a26c:	4830      	ldr	r0, [pc, #192]	; (801a330 <CST_cmd+0x1238>)
 801a26e:	f007 ff13 	bl	8022098 <dc_com_write>
  cmd_status = CMD_OK;
 801a272:	2500      	movs	r5, #0
 801a274:	e03b      	b.n	801a2ee <CST_cmd+0x11f6>
        PRINT_FORCE("%s bad command. Usage:", cmd_p)
 801a276:	4c26      	ldr	r4, [pc, #152]	; (801a310 <CST_cmd+0x1218>)
 801a278:	462a      	mov	r2, r5
 801a27a:	492b      	ldr	r1, [pc, #172]	; (801a328 <CST_cmd+0x1230>)
 801a27c:	4620      	mov	r0, r4
 801a27e:	f00c fae3 	bl	8026848 <sprintf>
 801a282:	4620      	mov	r0, r4
 801a284:	f005 f851 	bl	801f32a <crs_strlen>
 801a288:	b283      	uxth	r3, r0
 801a28a:	4622      	mov	r2, r4
 801a28c:	2101      	movs	r1, #1
 801a28e:	2007      	movs	r0, #7
 801a290:	f005 f88e 	bl	801f3b0 <traceIF_itmPrint>
 801a294:	4620      	mov	r0, r4
 801a296:	f005 f848 	bl	801f32a <crs_strlen>
 801a29a:	b282      	uxth	r2, r0
 801a29c:	4621      	mov	r1, r4
 801a29e:	2007      	movs	r0, #7
 801a2a0:	f005 f8c0 	bl	801f424 <traceIF_uartPrintForce>
        CST_HelpCmd();
 801a2a4:	f7fe fa6e 	bl	8018784 <CST_HelpCmd>
        cmd_status = CMD_SYNTAX_ERROR;
 801a2a8:	2501      	movs	r5, #1
 801a2aa:	e020      	b.n	801a2ee <CST_cmd+0x11f6>
      PRINT_FORCE("Bad command. Usage:")
 801a2ac:	4c18      	ldr	r4, [pc, #96]	; (801a310 <CST_cmd+0x1218>)
 801a2ae:	4d21      	ldr	r5, [pc, #132]	; (801a334 <CST_cmd+0x123c>)
 801a2b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a2b2:	6020      	str	r0, [r4, #0]
 801a2b4:	6061      	str	r1, [r4, #4]
 801a2b6:	60a2      	str	r2, [r4, #8]
 801a2b8:	60e3      	str	r3, [r4, #12]
 801a2ba:	6828      	ldr	r0, [r5, #0]
 801a2bc:	6120      	str	r0, [r4, #16]
 801a2be:	88ab      	ldrh	r3, [r5, #4]
 801a2c0:	82a3      	strh	r3, [r4, #20]
 801a2c2:	4620      	mov	r0, r4
 801a2c4:	f005 f831 	bl	801f32a <crs_strlen>
 801a2c8:	b283      	uxth	r3, r0
 801a2ca:	4622      	mov	r2, r4
 801a2cc:	2101      	movs	r1, #1
 801a2ce:	2007      	movs	r0, #7
 801a2d0:	f005 f86e 	bl	801f3b0 <traceIF_itmPrint>
 801a2d4:	4620      	mov	r0, r4
 801a2d6:	f005 f828 	bl	801f32a <crs_strlen>
 801a2da:	b282      	uxth	r2, r0
 801a2dc:	4621      	mov	r1, r4
 801a2de:	2007      	movs	r0, #7
 801a2e0:	f005 f8a0 	bl	801f424 <traceIF_uartPrintForce>
      CST_HelpCmd();
 801a2e4:	f7fe fa4e 	bl	8018784 <CST_HelpCmd>
      cmd_status = CMD_SYNTAX_ERROR;
 801a2e8:	2501      	movs	r5, #1
 801a2ea:	e000      	b.n	801a2ee <CST_cmd+0x11f6>
  cmd_status = CMD_OK;
 801a2ec:	2500      	movs	r5, #0
}
 801a2ee:	4628      	mov	r0, r5
 801a2f0:	b00f      	add	sp, #60	; 0x3c
 801a2f2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801a2f6:	bf00      	nop
 801a2f8:	08033a54 	.word	0x08033a54
 801a2fc:	20003b10 	.word	0x20003b10
 801a300:	08034234 	.word	0x08034234
 801a304:	08033dd4 	.word	0x08033dd4
 801a308:	08033fa0 	.word	0x08033fa0
 801a30c:	08033fa8 	.word	0x08033fa8
 801a310:	20004ddc 	.word	0x20004ddc
 801a314:	08033fac 	.word	0x08033fac
 801a318:	08033928 	.word	0x08033928
 801a31c:	08033a68 	.word	0x08033a68
 801a320:	08033fc0 	.word	0x08033fc0
 801a324:	08033fd4 	.word	0x08033fd4
 801a328:	08033fdc 	.word	0x08033fdc
 801a32c:	20000232 	.word	0x20000232
 801a330:	200058b0 	.word	0x200058b0
 801a334:	08033ff8 	.word	0x08033ff8

0801a338 <CST_cmd_cellular_service_start>:
  * @brief  starts cellar command managememnt
  * @param  -
  * @retval CS_Status_t - function result
  */
CS_Status_t CST_cmd_cellular_service_start(void)
{
 801a338:	b508      	push	{r3, lr}
  CMD_Declare(CST_cmd_label, CST_cmd, (uint8_t *)"cellular service task management");
 801a33a:	4a08      	ldr	r2, [pc, #32]	; (801a35c <CST_cmd_cellular_service_start+0x24>)
 801a33c:	4908      	ldr	r1, [pc, #32]	; (801a360 <CST_cmd_cellular_service_start+0x28>)
 801a33e:	4809      	ldr	r0, [pc, #36]	; (801a364 <CST_cmd_cellular_service_start+0x2c>)
 801a340:	f008 fada 	bl	80228f8 <CMD_Declare>
  CMD_Declare(CST_cmd_at_label, CST_AtCmd, (uint8_t *)"send an at command");
 801a344:	4a08      	ldr	r2, [pc, #32]	; (801a368 <CST_cmd_cellular_service_start+0x30>)
 801a346:	4909      	ldr	r1, [pc, #36]	; (801a36c <CST_cmd_cellular_service_start+0x34>)
 801a348:	4809      	ldr	r0, [pc, #36]	; (801a370 <CST_cmd_cellular_service_start+0x38>)
 801a34a:	f008 fad5 	bl	80228f8 <CMD_Declare>
#if (CST_CMD_USE_MODEM_CONFIG == 1)
  CMD_Declare(CST_cmd_modem_label, CST_ModemCmd, (uint8_t *)"modem configuration management");
 801a34e:	4a09      	ldr	r2, [pc, #36]	; (801a374 <CST_cmd_cellular_service_start+0x3c>)
 801a350:	4909      	ldr	r1, [pc, #36]	; (801a378 <CST_cmd_cellular_service_start+0x40>)
 801a352:	480a      	ldr	r0, [pc, #40]	; (801a37c <CST_cmd_cellular_service_start+0x44>)
 801a354:	f008 fad0 	bl	80228f8 <CMD_Declare>
#endif  /* CST_CMD_USE_MODEM_CONFIG == 1 */

  return CELLULAR_OK;
}
 801a358:	2000      	movs	r0, #0
 801a35a:	bd08      	pop	{r3, pc}
 801a35c:	08034010 	.word	0x08034010
 801a360:	080190f9 	.word	0x080190f9
 801a364:	08033520 	.word	0x08033520
 801a368:	08034034 	.word	0x08034034
 801a36c:	08018fcd 	.word	0x08018fcd
 801a370:	0803349c 	.word	0x0803349c
 801a374:	08034048 	.word	0x08034048
 801a378:	08018af1 	.word	0x08018af1
 801a37c:	08033048 	.word	0x08033048

0801a380 <cst_get_sim_socket_value>:
  * @retval dc_cs_sim_slot_type_t  - sim slot DC enum value
  */
static dc_cs_sim_slot_type_t  cst_get_sim_socket_value(uint8_t sim_slot_value)
{
  dc_cs_sim_slot_type_t enum_value;
  switch (sim_slot_value)
 801a380:	2801      	cmp	r0, #1
 801a382:	d002      	beq.n	801a38a <cst_get_sim_socket_value+0xa>
 801a384:	2802      	cmp	r0, #2
 801a386:	d000      	beq.n	801a38a <cst_get_sim_socket_value+0xa>
 801a388:	2000      	movs	r0, #0
      enum_value = DC_SIM_SLOT_MODEM_SOCKET;
      break;
    }
  }
  return enum_value;
}
 801a38a:	4770      	bx	lr

0801a38c <cst_get_target_state_value>:
  * @retval dc_cs_sim_slot_type_t  - modem target state enum value
  */
static dc_cs_target_state_t  cst_get_target_state_value(uint8_t target_state_value)
{
  dc_cs_target_state_t enum_value;
  switch (target_state_value)
 801a38c:	2801      	cmp	r0, #1
 801a38e:	d003      	beq.n	801a398 <cst_get_target_state_value+0xc>
 801a390:	2802      	cmp	r0, #2
 801a392:	d001      	beq.n	801a398 <cst_get_target_state_value+0xc>
 801a394:	b100      	cbz	r0, 801a398 <cst_get_target_state_value+0xc>
      enum_value = DC_TARGET_STATE_FULL;
      break;
    }
    default:
    {
      enum_value = DC_TARGET_STATE_FULL;
 801a396:	2002      	movs	r0, #2
      break;
    }
  }
  return enum_value;
}
 801a398:	4770      	bx	lr

0801a39a <cst_get_cid_value>:
  * @retval CS_PDN_conf_id_t  - cid enum value
  */
CS_PDN_conf_id_t  cst_get_cid_value(uint8_t cid_value)
{
  CS_PDN_conf_id_t enum_value;
  switch (cid_value)
 801a39a:	1e43      	subs	r3, r0, #1
 801a39c:	2b0c      	cmp	r3, #12
 801a39e:	d808      	bhi.n	801a3b2 <cst_get_cid_value+0x18>
 801a3a0:	e8df f003 	tbb	[pc, r3]
 801a3a4:	08080808 	.word	0x08080808
 801a3a8:	07070708 	.word	0x07070708
 801a3ac:	08080707 	.word	0x08080707
 801a3b0:	08          	.byte	0x08
 801a3b1:	00          	.byte	0x00
 801a3b2:	2000      	movs	r0, #0
      break;
    }

  }
  return enum_value;
}
 801a3b4:	4770      	bx	lr
	...

0801a3b8 <CST_local_setup_handler>:
  * @note  used only if USE_DEFAULT_SETUP compilation flag is defined
  * @param  none
  * @retval none
  */
static void CST_local_setup_handler(void)
{
 801a3b8:	b530      	push	{r4, r5, lr}
 801a3ba:	b0e9      	sub	sp, #420	; 0x1a4
  const uint8_t *tmp_string;
  dc_cellular_params_t cellular_params;
  uint32_t size;

  (void)memset((void *)&cellular_params, 0, sizeof(cellular_params));
 801a3bc:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 801a3c0:	2100      	movs	r1, #0
 801a3c2:	4668      	mov	r0, sp
 801a3c4:	f00c fab3 	bl	802692e <memset>

  cellular_params.set_pdn_mode = 1U;
 801a3c8:	2301      	movs	r3, #1
 801a3ca:	f88d 3009 	strb.w	r3, [sp, #9]
  cellular_params.sim_slot_nb  = 1U;
 801a3ce:	f88d 300a 	strb.w	r3, [sp, #10]

  /* SIM slot 0 parameters BEGIN*/
  tmp_string = CST_default_setup_table[CST_PARAM_SIM_SLOT];
  cellular_params.sim_slot[0].sim_slot_type = cst_get_sim_socket_value(tmp_string[0] - (uint8_t)'0');
 801a3d2:	2000      	movs	r0, #0
 801a3d4:	f7ff ffd4 	bl	801a380 <cst_get_sim_socket_value>
 801a3d8:	f88d 000b 	strb.w	r0, [sp, #11]

  /* APN parameter */
  size = crs_strlen(CST_default_setup_table[CST_PARAM_APN]) + 1U;
 801a3dc:	483e      	ldr	r0, [pc, #248]	; (801a4d8 <CST_local_setup_handler+0x120>)
 801a3de:	f004 ffa4 	bl	801f32a <crs_strlen>
 801a3e2:	1c42      	adds	r2, r0, #1
  /* to avoid string overflow */
  if (size <= DC_MAX_SIZE_APN)
 801a3e4:	2a20      	cmp	r2, #32
 801a3e6:	d94e      	bls.n	801a486 <CST_local_setup_handler+0xce>
                 size);
  }

  /* CID parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_CID];
  cellular_params.sim_slot[0].cid = cst_get_cid_value(tmp_string[0] - (uint8_t)'0');
 801a3e8:	2001      	movs	r0, #1
 801a3ea:	f7ff ffd6 	bl	801a39a <cst_get_cid_value>
 801a3ee:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c

  /* username parameter */
  size = crs_strlen(CST_default_setup_table[CST_PARAM_USERNAME]) + 1U;
 801a3f2:	4839      	ldr	r0, [pc, #228]	; (801a4d8 <CST_local_setup_handler+0x120>)
 801a3f4:	f004 ff99 	bl	801f32a <crs_strlen>
 801a3f8:	1c42      	adds	r2, r0, #1
  /* to avoid string overflow */
  if (size <= DC_CST_USERNAME_SIZE)
 801a3fa:	2a20      	cmp	r2, #32
 801a3fc:	d948      	bls.n	801a490 <CST_local_setup_handler+0xd8>
                 (CRC_CHAR_t *)CST_default_setup_table[CST_PARAM_USERNAME],
                 size);
  }

  /* password parameter */
  size = crs_strlen(CST_default_setup_table[CST_PARAM_PASSWORD]) + 1U;
 801a3fe:	4836      	ldr	r0, [pc, #216]	; (801a4d8 <CST_local_setup_handler+0x120>)
 801a400:	f004 ff93 	bl	801f32a <crs_strlen>
 801a404:	1c42      	adds	r2, r0, #1
  /* to avoid string overflow */
  if (size <= DC_CST_PASSWORD_SIZE)
 801a406:	2a20      	cmp	r2, #32
 801a408:	d948      	bls.n	801a49c <CST_local_setup_handler+0xe4>

  /* SIM slot 0 parameters END*/

  /* modem target state parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_TARGET_STATE];
  cellular_params.target_state = cst_get_target_state_value(tmp_string[0] - (uint8_t)'0');
 801a40a:	2002      	movs	r0, #2
 801a40c:	f7ff ffbe 	bl	801a38c <cst_get_target_state_value>
 801a410:	f88d 0131 	strb.w	r0, [sp, #305]	; 0x131

  /* attachment timeout parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_ATTACHMENT_TIMEOUT];
  cellular_params.attachment_timeout = (uint32_t)crs_atoi(tmp_string);
 801a414:	4831      	ldr	r0, [pc, #196]	; (801a4dc <CST_local_setup_handler+0x124>)
 801a416:	f004 ff43 	bl	801f2a0 <crs_atoi>
 801a41a:	904d      	str	r0, [sp, #308]	; 0x134

  cellular_params.operator_selector.network_reg_mode      =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_NETWORK_REG_MODE]);
 801a41c:	4830      	ldr	r0, [pc, #192]	; (801a4e0 <CST_local_setup_handler+0x128>)
 801a41e:	f004 ff3f 	bl	801f2a0 <crs_atoi>
  cellular_params.operator_selector.network_reg_mode      =
 801a422:	f88d 0138 	strb.w	r0, [sp, #312]	; 0x138

  cellular_params.operator_selector.operator_name_format  =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_OPERATOR_NAME_FORMAT]);
 801a426:	482f      	ldr	r0, [pc, #188]	; (801a4e4 <CST_local_setup_handler+0x12c>)
 801a428:	f004 ff3a 	bl	801f2a0 <crs_atoi>
  cellular_params.operator_selector.operator_name_format  =
 801a42c:	f88d 0139 	strb.w	r0, [sp, #313]	; 0x139

  memcpy(cellular_params.operator_selector.operator_name, CST_default_setup_table[CST_PARAM_OPERATOR_NAME],
 801a430:	4d2d      	ldr	r5, [pc, #180]	; (801a4e8 <CST_local_setup_handler+0x130>)
 801a432:	f50d 7c9d 	add.w	ip, sp, #314	; 0x13a
 801a436:	f105 0e40 	add.w	lr, r5, #64	; 0x40
 801a43a:	462c      	mov	r4, r5
 801a43c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a43e:	f8cc 0000 	str.w	r0, [ip]
 801a442:	f8cc 1004 	str.w	r1, [ip, #4]
 801a446:	f8cc 2008 	str.w	r2, [ip, #8]
 801a44a:	f8cc 300c 	str.w	r3, [ip, #12]
 801a44e:	4625      	mov	r5, r4
 801a450:	f10c 0c10 	add.w	ip, ip, #16
 801a454:	4574      	cmp	r4, lr
 801a456:	d1f0      	bne.n	801a43a <CST_local_setup_handler+0x82>
         sizeof(cellular_params.operator_selector.operator_name));

  cellular_params.operator_selector.access_techno_present =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_ACT_PRESENT]);
 801a458:	4821      	ldr	r0, [pc, #132]	; (801a4e0 <CST_local_setup_handler+0x128>)
 801a45a:	f004 ff21 	bl	801f2a0 <crs_atoi>
 801a45e:	f010 0fff 	tst.w	r0, #255	; 0xff
 801a462:	bf14      	ite	ne
 801a464:	2301      	movne	r3, #1
 801a466:	2300      	moveq	r3, #0
  cellular_params.operator_selector.access_techno_present =
 801a468:	f88d 317a 	strb.w	r3, [sp, #378]	; 0x17a

  cellular_params.operator_selector.access_techno         =
    (uint8_t)crs_atoi(CST_default_setup_table[CST_PARAM_ACCESS_TECHNO]);
 801a46c:	481f      	ldr	r0, [pc, #124]	; (801a4ec <CST_local_setup_handler+0x134>)
 801a46e:	f004 ff17 	bl	801f2a0 <crs_atoi>
  cellular_params.operator_selector.access_techno         =
 801a472:	f88d 017b 	strb.w	r0, [sp, #379]	; 0x17b

  /* low power inactivity timeout parameter */
  tmp_string = CST_default_setup_table[CST_PARAM_LP_INACTIVITY_TIMEOUT];
  cellular_params.lp_inactivity_timeout = (uint32_t)crs_atoi(tmp_string);
 801a476:	481e      	ldr	r0, [pc, #120]	; (801a4f0 <CST_local_setup_handler+0x138>)
 801a478:	f004 ff12 	bl	801f2a0 <crs_atoi>
 801a47c:	9067      	str	r0, [sp, #412]	; 0x19c
  {
    cellular_params.nfmc_active = 1U;
  }
  else
  {
    cellular_params.nfmc_active = 0U;
 801a47e:	2400      	movs	r4, #0
 801a480:	f88d 417c 	strb.w	r4, [sp, #380]	; 0x17c
 801a484:	e018      	b.n	801a4b8 <CST_local_setup_handler+0x100>
    (void)memcpy((CRC_CHAR_t *)cellular_params.sim_slot[0].apn,
 801a486:	4914      	ldr	r1, [pc, #80]	; (801a4d8 <CST_local_setup_handler+0x120>)
 801a488:	a803      	add	r0, sp, #12
 801a48a:	f00c fb2d 	bl	8026ae8 <memcpy>
 801a48e:	e7ab      	b.n	801a3e8 <CST_local_setup_handler+0x30>
    (void)memcpy((CRC_CHAR_t *)cellular_params.sim_slot[0].username,
 801a490:	4911      	ldr	r1, [pc, #68]	; (801a4d8 <CST_local_setup_handler+0x120>)
 801a492:	f10d 002d 	add.w	r0, sp, #45	; 0x2d
 801a496:	f00c fb27 	bl	8026ae8 <memcpy>
 801a49a:	e7b0      	b.n	801a3fe <CST_local_setup_handler+0x46>
    (void)memcpy((CRC_CHAR_t *)cellular_params.sim_slot[0].password,
 801a49c:	490e      	ldr	r1, [pc, #56]	; (801a4d8 <CST_local_setup_handler+0x120>)
 801a49e:	f10d 004d 	add.w	r0, sp, #77	; 0x4d
 801a4a2:	f00c fb21 	bl	8026ae8 <memcpy>
 801a4a6:	e7b0      	b.n	801a40a <CST_local_setup_handler+0x52>
  }

  /* Set all NFMC tempo values */
  for (uint32_t i = 0U; i < CST_NFMC_TEMPO_NB ; i++)
  {
    cellular_params.nfmc_value[i] = (uint32_t)crs_atoi(CST_default_setup_table[CST_PARAM_NFMC_TEMPO]);
 801a4a8:	4812      	ldr	r0, [pc, #72]	; (801a4f4 <CST_local_setup_handler+0x13c>)
 801a4aa:	f004 fef9 	bl	801f2a0 <crs_atoi>
 801a4ae:	f104 0360 	add.w	r3, r4, #96	; 0x60
 801a4b2:	f84d 0023 	str.w	r0, [sp, r3, lsl #2]
  for (uint32_t i = 0U; i < CST_NFMC_TEMPO_NB ; i++)
 801a4b6:	3401      	adds	r4, #1
 801a4b8:	2c06      	cmp	r4, #6
 801a4ba:	d9f5      	bls.n	801a4a8 <CST_local_setup_handler+0xf0>
  cellular_params.nfmc_value[5] = (uint32_t)crs_atoi(CST_DEFAULT_NFMC_TEMPO6_STRING);
  cellular_params.nfmc_value[6] = (uint32_t)crs_atoi(CST_DEFAULT_NFMC_TEMPO7_STRING);
#endif /* (CST_SETUP_NFMC == 1) */

  /* set Data Cache entry valid */
  cellular_params.rt_state = DC_SERVICE_ON;
 801a4bc:	2307      	movs	r3, #7
 801a4be:	f88d 3008 	strb.w	r3, [sp, #8]

  /* write Entry to Data Cache */
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cellular_params, sizeof(cellular_params));
 801a4c2:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801a4c6:	466a      	mov	r2, sp
 801a4c8:	490b      	ldr	r1, [pc, #44]	; (801a4f8 <CST_local_setup_handler+0x140>)
 801a4ca:	8809      	ldrh	r1, [r1, #0]
 801a4cc:	480b      	ldr	r0, [pc, #44]	; (801a4fc <CST_local_setup_handler+0x144>)
 801a4ce:	f007 fde3 	bl	8022098 <dc_com_write>
}
 801a4d2:	b069      	add	sp, #420	; 0x1a4
 801a4d4:	bd30      	pop	{r4, r5, pc}
 801a4d6:	bf00      	nop
 801a4d8:	08035c54 	.word	0x08035c54
 801a4dc:	08034294 	.word	0x08034294
 801a4e0:	080342b8 	.word	0x080342b8
 801a4e4:	0803429c 	.word	0x0803429c
 801a4e8:	080342a0 	.word	0x080342a0
 801a4ec:	080342a8 	.word	0x080342a8
 801a4f0:	080342ac 	.word	0x080342ac
 801a4f4:	080342b4 	.word	0x080342b4
 801a4f8:	20000232 	.word	0x20000232
 801a4fc:	200058b0 	.word	0x200058b0

0801a500 <CST_config_init>:
  * @param  cellular_params   - cellular configuration
  * @retval error code (O:OK)
  */

CS_Status_t CST_config_init(void)
{
 801a500:	b508      	push	{r3, lr}
                     CST_setup_dump,
                     CST_setup_help,
                     CST_default_setup_table, CST_DEFAULT_PARAMA_NB);
#else
  /* In case on default setup (without menu) calls default configuration setting */
  CST_local_setup_handler();
 801a502:	f7ff ff59 	bl	801a3b8 <CST_local_setup_handler>
#endif   /* (!USE_DEFAULT_SETUP == 1) */

  return CELLULAR_OK;
}
 801a506:	2000      	movs	r0, #0
 801a508:	bd08      	pop	{r3, pc}
	...

0801a50c <csint_modem_reset_update_socket_state>:
  * @note  Update socket state after a modem reset
  * @param  none
  * @retval none
  */
void csint_modem_reset_update_socket_state(void)
{
 801a50c:	b570      	push	{r4, r5, r6, lr}
  * - if SOCKETSTATE_CONNECTED => socket is lost, invalid state
  * - if SOCKETSTATE_ALLOC_BUT_INVALID => socket already in an invalid state
  */
  uint8_t cpt;

  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a50e:	2500      	movs	r5, #0
 801a510:	e003      	b.n	801a51a <csint_modem_reset_update_socket_state+0xe>
  {
    switch (cs_ctxt_sockets_info[cpt].state)
 801a512:	2b01      	cmp	r3, #1
 801a514:	d80d      	bhi.n	801a532 <csint_modem_reset_update_socket_state+0x26>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a516:	3501      	adds	r5, #1
 801a518:	b2ed      	uxtb	r5, r5
 801a51a:	2d05      	cmp	r5, #5
 801a51c:	d839      	bhi.n	801a592 <csint_modem_reset_update_socket_state+0x86>
    switch (cs_ctxt_sockets_info[cpt].state)
 801a51e:	4b1d      	ldr	r3, [pc, #116]	; (801a594 <csint_modem_reset_update_socket_state+0x88>)
 801a520:	226c      	movs	r2, #108	; 0x6c
 801a522:	fb02 3305 	mla	r3, r2, r5, r3
 801a526:	791b      	ldrb	r3, [r3, #4]
 801a528:	2b02      	cmp	r3, #2
 801a52a:	d02b      	beq.n	801a584 <csint_modem_reset_update_socket_state+0x78>
 801a52c:	d9f1      	bls.n	801a512 <csint_modem_reset_update_socket_state+0x6>
 801a52e:	2b03      	cmp	r3, #3
 801a530:	d0f1      	beq.n	801a516 <csint_modem_reset_update_socket_state+0xa>
        */
        cs_ctxt_sockets_info[cpt].state = SOCKETSTATE_ALLOC_BUT_INVALID;
        break;

      default:
        PRINT_ERR("unknown socket state, Should not happen")
 801a532:	4e19      	ldr	r6, [pc, #100]	; (801a598 <csint_modem_reset_update_socket_state+0x8c>)
 801a534:	4c19      	ldr	r4, [pc, #100]	; (801a59c <csint_modem_reset_update_socket_state+0x90>)
 801a536:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 801a53a:	46b4      	mov	ip, r6
 801a53c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801a540:	6020      	str	r0, [r4, #0]
 801a542:	6061      	str	r1, [r4, #4]
 801a544:	60a2      	str	r2, [r4, #8]
 801a546:	60e3      	str	r3, [r4, #12]
 801a548:	4666      	mov	r6, ip
 801a54a:	3410      	adds	r4, #16
 801a54c:	45f4      	cmp	ip, lr
 801a54e:	d1f4      	bne.n	801a53a <csint_modem_reset_update_socket_state+0x2e>
 801a550:	f8bc 2000 	ldrh.w	r2, [ip]
 801a554:	f89c 3002 	ldrb.w	r3, [ip, #2]
 801a558:	8022      	strh	r2, [r4, #0]
 801a55a:	70a3      	strb	r3, [r4, #2]
 801a55c:	4c0f      	ldr	r4, [pc, #60]	; (801a59c <csint_modem_reset_update_socket_state+0x90>)
 801a55e:	4620      	mov	r0, r4
 801a560:	f004 fee3 	bl	801f32a <crs_strlen>
 801a564:	b283      	uxth	r3, r0
 801a566:	4622      	mov	r2, r4
 801a568:	2110      	movs	r1, #16
 801a56a:	2001      	movs	r0, #1
 801a56c:	f004 ff20 	bl	801f3b0 <traceIF_itmPrint>
 801a570:	4620      	mov	r0, r4
 801a572:	f004 feda 	bl	801f32a <crs_strlen>
 801a576:	b283      	uxth	r3, r0
 801a578:	4622      	mov	r2, r4
 801a57a:	2110      	movs	r1, #16
 801a57c:	2001      	movs	r0, #1
 801a57e:	f004 ff39 	bl	801f3f4 <traceIF_uartPrint>
        break;
 801a582:	e7c8      	b.n	801a516 <csint_modem_reset_update_socket_state+0xa>
        cs_ctxt_sockets_info[cpt].state = SOCKETSTATE_ALLOC_BUT_INVALID;
 801a584:	4b03      	ldr	r3, [pc, #12]	; (801a594 <csint_modem_reset_update_socket_state+0x88>)
 801a586:	226c      	movs	r2, #108	; 0x6c
 801a588:	fb02 3305 	mla	r3, r2, r5, r3
 801a58c:	2203      	movs	r2, #3
 801a58e:	711a      	strb	r2, [r3, #4]
        break;
 801a590:	e7c1      	b.n	801a516 <csint_modem_reset_update_socket_state+0xa>
    }
  }
}
 801a592:	bd70      	pop	{r4, r5, r6, pc}
 801a594:	20003d18 	.word	0x20003d18
 801a598:	080342bc 	.word	0x080342bc
 801a59c:	200047dc 	.word	0x200047dc

0801a5a0 <csint_socket_init>:
  * @note   Initialize socket parameters
  * @param  index
  * @retval none
  */
void csint_socket_init(socket_handle_t index)
{
 801a5a0:	b538      	push	{r3, r4, r5, lr}
 801a5a2:	4604      	mov	r4, r0
  PRINT_API("<Cellular_Service> SOCKET_init (index=%ld)", index)
 801a5a4:	4d20      	ldr	r5, [pc, #128]	; (801a628 <csint_socket_init+0x88>)
 801a5a6:	4602      	mov	r2, r0
 801a5a8:	4920      	ldr	r1, [pc, #128]	; (801a62c <csint_socket_init+0x8c>)
 801a5aa:	4628      	mov	r0, r5
 801a5ac:	f00c f94c 	bl	8026848 <sprintf>
 801a5b0:	4628      	mov	r0, r5
 801a5b2:	f004 feba 	bl	801f32a <crs_strlen>
 801a5b6:	b283      	uxth	r3, r0
 801a5b8:	462a      	mov	r2, r5
 801a5ba:	2104      	movs	r1, #4
 801a5bc:	2001      	movs	r0, #1
 801a5be:	f004 fef7 	bl	801f3b0 <traceIF_itmPrint>
 801a5c2:	4628      	mov	r0, r5
 801a5c4:	f004 feb1 	bl	801f32a <crs_strlen>
 801a5c8:	b283      	uxth	r3, r0
 801a5ca:	462a      	mov	r2, r5
 801a5cc:	2104      	movs	r1, #4
 801a5ce:	2001      	movs	r0, #1
 801a5d0:	f004 ff10 	bl	801f3f4 <traceIF_uartPrint>

  cs_ctxt_sockets_info[index].socket_handle = index;
 801a5d4:	4916      	ldr	r1, [pc, #88]	; (801a630 <csint_socket_init+0x90>)
 801a5d6:	226c      	movs	r2, #108	; 0x6c
 801a5d8:	fb04 f202 	mul.w	r2, r4, r2
 801a5dc:	188b      	adds	r3, r1, r2
 801a5de:	508c      	str	r4, [r1, r2]
  cs_ctxt_sockets_info[index].state = SOCKETSTATE_NOT_ALLOC;
 801a5e0:	2200      	movs	r2, #0
 801a5e2:	711a      	strb	r2, [r3, #4]
  cs_ctxt_sockets_info[index].config = CS_SON_NO_OPTION;
 801a5e4:	80da      	strh	r2, [r3, #6]

  cs_ctxt_sockets_info[index].addr_type = CS_IPAT_IPV4;
 801a5e6:	2101      	movs	r1, #1
 801a5e8:	7219      	strb	r1, [r3, #8]
  cs_ctxt_sockets_info[index].protocol = CS_TCP_PROTOCOL;
 801a5ea:	725a      	strb	r2, [r3, #9]
  cs_ctxt_sockets_info[index].local_port = 0U;
 801a5ec:	815a      	strh	r2, [r3, #10]
  cs_ctxt_sockets_info[index].conf_id = CS_PDN_NOT_DEFINED;
 801a5ee:	210c      	movs	r1, #12
 801a5f0:	7319      	strb	r1, [r3, #12]

  cs_ctxt_sockets_info[index].ip_max_packet_size = DEFAULT_IP_MAX_PACKET_SIZE;
 801a5f2:	f240 51dc 	movw	r1, #1500	; 0x5dc
 801a5f6:	f8a3 1050 	strh.w	r1, [r3, #80]	; 0x50
  cs_ctxt_sockets_info[index].trp_max_timeout = DEFAULT_TRP_MAX_TIMEOUT;
 801a5fa:	215a      	movs	r1, #90	; 0x5a
 801a5fc:	f8a3 1052 	strh.w	r1, [r3, #82]	; 0x52
  cs_ctxt_sockets_info[index].trp_conn_setup_timeout = DEFAULT_TRP_CONN_SETUP_TIMEOUT;
 801a600:	f44f 7116 	mov.w	r1, #600	; 0x258
 801a604:	f8a3 1054 	strh.w	r1, [r3, #84]	; 0x54
  cs_ctxt_sockets_info[index].trp_transfer_timeout = DEFAULT_TRP_TRANSFER_TIMEOUT;
 801a608:	2132      	movs	r1, #50	; 0x32
 801a60a:	f8a3 1056 	strh.w	r1, [r3, #86]	; 0x56
  cs_ctxt_sockets_info[index].trp_connect_mode = CS_CM_COMMAND_MODE;
 801a60e:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58
  cs_ctxt_sockets_info[index].trp_suspend_timeout = DEFAULT_TRP_SUSPEND_TIMEOUT;
 801a612:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801a616:	f8a3 005a 	strh.w	r0, [r3, #90]	; 0x5a
  cs_ctxt_sockets_info[index].trp_rx_timeout = DEFAULT_TRP_RX_TIMEOUT;
 801a61a:	f8a3 105c 	strh.w	r1, [r3, #92]	; 0x5c

  /* socket callback functions pointers */
  cs_ctxt_sockets_info[index].socket_data_ready_callback = NULL;
 801a61e:	661a      	str	r2, [r3, #96]	; 0x60
  cs_ctxt_sockets_info[index].socket_data_sent_callback = NULL;
 801a620:	665a      	str	r2, [r3, #100]	; 0x64
  cs_ctxt_sockets_info[index].socket_remote_close_callback = NULL;
 801a622:	669a      	str	r2, [r3, #104]	; 0x68
}
 801a624:	bd38      	pop	{r3, r4, r5, pc}
 801a626:	bf00      	nop
 801a628:	200047dc 	.word	0x200047dc
 801a62c:	080342f0 	.word	0x080342f0
 801a630:	20003d18 	.word	0x20003d18

0801a634 <csint_socket_allocateHandle>:
socket_handle_t csint_socket_allocateHandle(void)
{
  socket_handle_t socket_handle = CS_INVALID_SOCKET_HANDLE;
  uint8_t cpt;

  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a634:	2300      	movs	r3, #0
 801a636:	2b05      	cmp	r3, #5
 801a638:	d809      	bhi.n	801a64e <csint_socket_allocateHandle+0x1a>
  {
    if (cs_ctxt_sockets_info[cpt].state == SOCKETSTATE_NOT_ALLOC)
 801a63a:	4618      	mov	r0, r3
 801a63c:	4a05      	ldr	r2, [pc, #20]	; (801a654 <csint_socket_allocateHandle+0x20>)
 801a63e:	216c      	movs	r1, #108	; 0x6c
 801a640:	fb01 2203 	mla	r2, r1, r3, r2
 801a644:	7912      	ldrb	r2, [r2, #4]
 801a646:	b122      	cbz	r2, 801a652 <csint_socket_allocateHandle+0x1e>
  for (cpt = 0U; cpt < CELLULAR_MAX_SOCKETS; cpt++)
 801a648:	3301      	adds	r3, #1
 801a64a:	b2db      	uxtb	r3, r3
 801a64c:	e7f3      	b.n	801a636 <csint_socket_allocateHandle+0x2>
  socket_handle_t socket_handle = CS_INVALID_SOCKET_HANDLE;
 801a64e:	f04f 30ff 	mov.w	r0, #4294967295
      break;
    }
  }

  return (socket_handle);
}
 801a652:	4770      	bx	lr
 801a654:	20003d18 	.word	0x20003d18

0801a658 <csint_socket_deallocateHandle>:
  * @note   Deallocate a socket handle
  * @param  sockhandle
  * @retval none
  */
void csint_socket_deallocateHandle(socket_handle_t sockhandle)
{
 801a658:	b538      	push	{r3, r4, r5, lr}
 801a65a:	4605      	mov	r5, r0
  PRINT_INFO("socket_deallocateHandle %ld", sockhandle)
 801a65c:	4c0d      	ldr	r4, [pc, #52]	; (801a694 <csint_socket_deallocateHandle+0x3c>)
 801a65e:	4602      	mov	r2, r0
 801a660:	490d      	ldr	r1, [pc, #52]	; (801a698 <csint_socket_deallocateHandle+0x40>)
 801a662:	4620      	mov	r0, r4
 801a664:	f00c f8f0 	bl	8026848 <sprintf>
 801a668:	4620      	mov	r0, r4
 801a66a:	f004 fe5e 	bl	801f32a <crs_strlen>
 801a66e:	b283      	uxth	r3, r0
 801a670:	4622      	mov	r2, r4
 801a672:	2101      	movs	r1, #1
 801a674:	4608      	mov	r0, r1
 801a676:	f004 fe9b 	bl	801f3b0 <traceIF_itmPrint>
 801a67a:	4620      	mov	r0, r4
 801a67c:	f004 fe55 	bl	801f32a <crs_strlen>
 801a680:	b283      	uxth	r3, r0
 801a682:	4622      	mov	r2, r4
 801a684:	2101      	movs	r1, #1
 801a686:	4608      	mov	r0, r1
 801a688:	f004 feb4 	bl	801f3f4 <traceIF_uartPrint>
  csint_socket_init(sockhandle);
 801a68c:	4628      	mov	r0, r5
 801a68e:	f7ff ff87 	bl	801a5a0 <csint_socket_init>
}
 801a692:	bd38      	pop	{r3, r4, r5, pc}
 801a694:	200047dc 	.word	0x200047dc
 801a698:	08034324 	.word	0x08034324

0801a69c <csint_socket_create>:
CS_Status_t csint_socket_create(socket_handle_t sockhandle,
                                CS_IPaddrType_t addr_type,
                                CS_TransportProtocol_t protocol,
                                uint16_t local_port,
                                CS_PDN_conf_id_t cid)
{
 801a69c:	b510      	push	{r4, lr}
 801a69e:	4686      	mov	lr, r0
  CS_Status_t retval;

  cs_ctxt_sockets_info[sockhandle].addr_type = addr_type;
 801a6a0:	4c17      	ldr	r4, [pc, #92]	; (801a700 <csint_socket_create+0x64>)
 801a6a2:	206c      	movs	r0, #108	; 0x6c
 801a6a4:	fb00 4c0e 	mla	ip, r0, lr, r4
 801a6a8:	f88c 1008 	strb.w	r1, [ip, #8]
  cs_ctxt_sockets_info[sockhandle].protocol = protocol;
 801a6ac:	f88c 2009 	strb.w	r2, [ip, #9]
  cs_ctxt_sockets_info[sockhandle].local_port = local_port;
 801a6b0:	f8ac 300a 	strh.w	r3, [ip, #10]
  cs_ctxt_sockets_info[sockhandle].conf_id = cid;
 801a6b4:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801a6b8:	f88c 300c 	strb.w	r3, [ip, #12]

  if (cs_ctxt_sockets_info[sockhandle].state == SOCKETSTATE_NOT_ALLOC)
 801a6bc:	f89c 0004 	ldrb.w	r0, [ip, #4]
 801a6c0:	b918      	cbnz	r0, 801a6ca <csint_socket_create+0x2e>
  {
    /* update socket state */
    cs_ctxt_sockets_info[sockhandle].state = SOCKETSTATE_CREATED;
 801a6c2:	2201      	movs	r2, #1
 801a6c4:	f88c 2004 	strb.w	r2, [ip, #4]
    PRINT_ERR("<Cellular_Service> socket handle %ld not available", sockhandle)
    retval = CELLULAR_ERROR;
  }

  return (retval);
}
 801a6c8:	bd10      	pop	{r4, pc}
    PRINT_ERR("<Cellular_Service> socket handle %ld not available", sockhandle)
 801a6ca:	4c0e      	ldr	r4, [pc, #56]	; (801a704 <csint_socket_create+0x68>)
 801a6cc:	4672      	mov	r2, lr
 801a6ce:	490e      	ldr	r1, [pc, #56]	; (801a708 <csint_socket_create+0x6c>)
 801a6d0:	4620      	mov	r0, r4
 801a6d2:	f00c f8b9 	bl	8026848 <sprintf>
 801a6d6:	4620      	mov	r0, r4
 801a6d8:	f004 fe27 	bl	801f32a <crs_strlen>
 801a6dc:	b283      	uxth	r3, r0
 801a6de:	4622      	mov	r2, r4
 801a6e0:	2110      	movs	r1, #16
 801a6e2:	2001      	movs	r0, #1
 801a6e4:	f004 fe64 	bl	801f3b0 <traceIF_itmPrint>
 801a6e8:	4620      	mov	r0, r4
 801a6ea:	f004 fe1e 	bl	801f32a <crs_strlen>
 801a6ee:	b283      	uxth	r3, r0
 801a6f0:	4622      	mov	r2, r4
 801a6f2:	2110      	movs	r1, #16
 801a6f4:	2001      	movs	r0, #1
 801a6f6:	f004 fe7d 	bl	801f3f4 <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 801a6fa:	2001      	movs	r0, #1
 801a6fc:	e7e4      	b.n	801a6c8 <csint_socket_create+0x2c>
 801a6fe:	bf00      	nop
 801a700:	20003d18 	.word	0x20003d18
 801a704:	200047dc 	.word	0x200047dc
 801a708:	08034348 	.word	0x08034348

0801a70c <csint_socket_bind>:
  * @param  local_port
  * @retval CS_Status_t
  */
CS_Status_t csint_socket_bind(socket_handle_t sockhandle,
                              uint16_t local_port)
{
 801a70c:	4602      	mov	r2, r0
  CS_Status_t retval;

  /* check that socket has been allocated */
  if (cs_ctxt_sockets_info[sockhandle].state == SOCKETSTATE_NOT_ALLOC)
 801a70e:	4b13      	ldr	r3, [pc, #76]	; (801a75c <csint_socket_bind+0x50>)
 801a710:	206c      	movs	r0, #108	; 0x6c
 801a712:	fb00 3302 	mla	r3, r0, r2, r3
 801a716:	791b      	ldrb	r3, [r3, #4]
 801a718:	b133      	cbz	r3, 801a728 <csint_socket_bind+0x1c>
    retval = CELLULAR_ERROR;
  }
  else
  {
    /* set the local port */
    cs_ctxt_sockets_info[sockhandle].local_port = local_port;
 801a71a:	4b10      	ldr	r3, [pc, #64]	; (801a75c <csint_socket_bind+0x50>)
 801a71c:	206c      	movs	r0, #108	; 0x6c
 801a71e:	fb00 3302 	mla	r3, r0, r2, r3
 801a722:	8159      	strh	r1, [r3, #10]
    retval = CELLULAR_OK;
 801a724:	2000      	movs	r0, #0
  }

  return (retval);
}
 801a726:	4770      	bx	lr
{
 801a728:	b510      	push	{r4, lr}
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (bind)", sockhandle)
 801a72a:	4c0d      	ldr	r4, [pc, #52]	; (801a760 <csint_socket_bind+0x54>)
 801a72c:	490d      	ldr	r1, [pc, #52]	; (801a764 <csint_socket_bind+0x58>)
 801a72e:	4620      	mov	r0, r4
 801a730:	f00c f88a 	bl	8026848 <sprintf>
 801a734:	4620      	mov	r0, r4
 801a736:	f004 fdf8 	bl	801f32a <crs_strlen>
 801a73a:	b283      	uxth	r3, r0
 801a73c:	4622      	mov	r2, r4
 801a73e:	2110      	movs	r1, #16
 801a740:	2001      	movs	r0, #1
 801a742:	f004 fe35 	bl	801f3b0 <traceIF_itmPrint>
 801a746:	4620      	mov	r0, r4
 801a748:	f004 fdef 	bl	801f32a <crs_strlen>
 801a74c:	b283      	uxth	r3, r0
 801a74e:	4622      	mov	r2, r4
 801a750:	2110      	movs	r1, #16
 801a752:	2001      	movs	r0, #1
 801a754:	f004 fe4e 	bl	801f3f4 <traceIF_uartPrint>
    retval = CELLULAR_ERROR;
 801a758:	2001      	movs	r0, #1
}
 801a75a:	bd10      	pop	{r4, pc}
 801a75c:	20003d18 	.word	0x20003d18
 801a760:	200047dc 	.word	0x200047dc
 801a764:	08034388 	.word	0x08034388

0801a768 <csint_socket_configure_remote>:
  */
CS_Status_t csint_socket_configure_remote(socket_handle_t sockhandle,
                                          CS_IPaddrType_t ip_addr_type,
                                          CS_CHAR_t *p_ip_addr_value,
                                          uint16_t remote_port)
{
 801a768:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801a76c:	4604      	mov	r4, r0
 801a76e:	4698      	mov	r8, r3
  CS_Status_t retval = CELLULAR_ERROR;

  size_t ip_addr_length;

  /* check that socket has been allocated */
  if (cs_ctxt_sockets_info[sockhandle].state == SOCKETSTATE_NOT_ALLOC)
 801a770:	4d6c      	ldr	r5, [pc, #432]	; (801a924 <csint_socket_configure_remote+0x1bc>)
 801a772:	236c      	movs	r3, #108	; 0x6c
 801a774:	fb03 5500 	mla	r5, r3, r0, r5
 801a778:	792b      	ldrb	r3, [r5, #4]
 801a77a:	b373      	cbz	r3, 801a7da <csint_socket_configure_remote+0x72>
 801a77c:	460f      	mov	r7, r1
 801a77e:	4616      	mov	r6, r2
  {
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (cfg remote)", sockhandle)
  }
  /* check p_ip_addr_value ptr */
  else if (p_ip_addr_value == NULL)
 801a780:	2a00      	cmp	r2, #0
 801a782:	d045      	beq.n	801a810 <csint_socket_configure_remote+0xa8>
  {
    PRINT_ERR("<Cellular_Service> NULL ptr")
  }
  else
  {
    ip_addr_length = strlen((const CRC_CHAR_t *)p_ip_addr_value);
 801a784:	4610      	mov	r0, r2
 801a786:	f7e5 fd35 	bl	80001f4 <strlen>
 801a78a:	4605      	mov	r5, r0
    if (ip_addr_length > MAX_IP_ADDR_SIZE)
 801a78c:	2840      	cmp	r0, #64	; 0x40
 801a78e:	d968      	bls.n	801a862 <csint_socket_configure_remote+0xfa>
    {
      PRINT_ERR("<Cellular_Service> IP address too long")
 801a790:	4e65      	ldr	r6, [pc, #404]	; (801a928 <csint_socket_configure_remote+0x1c0>)
 801a792:	4d66      	ldr	r5, [pc, #408]	; (801a92c <csint_socket_configure_remote+0x1c4>)
 801a794:	f106 0730 	add.w	r7, r6, #48	; 0x30
 801a798:	4634      	mov	r4, r6
 801a79a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801a79c:	6028      	str	r0, [r5, #0]
 801a79e:	6069      	str	r1, [r5, #4]
 801a7a0:	60aa      	str	r2, [r5, #8]
 801a7a2:	60eb      	str	r3, [r5, #12]
 801a7a4:	4626      	mov	r6, r4
 801a7a6:	3510      	adds	r5, #16
 801a7a8:	42bc      	cmp	r4, r7
 801a7aa:	d1f5      	bne.n	801a798 <csint_socket_configure_remote+0x30>
 801a7ac:	8823      	ldrh	r3, [r4, #0]
 801a7ae:	802b      	strh	r3, [r5, #0]
 801a7b0:	4c5e      	ldr	r4, [pc, #376]	; (801a92c <csint_socket_configure_remote+0x1c4>)
 801a7b2:	4620      	mov	r0, r4
 801a7b4:	f004 fdb9 	bl	801f32a <crs_strlen>
 801a7b8:	b283      	uxth	r3, r0
 801a7ba:	4622      	mov	r2, r4
 801a7bc:	2110      	movs	r1, #16
 801a7be:	2001      	movs	r0, #1
 801a7c0:	f004 fdf6 	bl	801f3b0 <traceIF_itmPrint>
 801a7c4:	4620      	mov	r0, r4
 801a7c6:	f004 fdb0 	bl	801f32a <crs_strlen>
 801a7ca:	b283      	uxth	r3, r0
 801a7cc:	4622      	mov	r2, r4
 801a7ce:	2110      	movs	r1, #16
 801a7d0:	2001      	movs	r0, #1
 801a7d2:	f004 fe0f 	bl	801f3f4 <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 801a7d6:	2001      	movs	r0, #1
 801a7d8:	e018      	b.n	801a80c <csint_socket_configure_remote+0xa4>
    PRINT_ERR("<Cellular_Service> invalid socket handle %ld (cfg remote)", sockhandle)
 801a7da:	4d54      	ldr	r5, [pc, #336]	; (801a92c <csint_socket_configure_remote+0x1c4>)
 801a7dc:	4602      	mov	r2, r0
 801a7de:	4954      	ldr	r1, [pc, #336]	; (801a930 <csint_socket_configure_remote+0x1c8>)
 801a7e0:	4628      	mov	r0, r5
 801a7e2:	f00c f831 	bl	8026848 <sprintf>
 801a7e6:	4628      	mov	r0, r5
 801a7e8:	f004 fd9f 	bl	801f32a <crs_strlen>
 801a7ec:	b283      	uxth	r3, r0
 801a7ee:	462a      	mov	r2, r5
 801a7f0:	2110      	movs	r1, #16
 801a7f2:	2001      	movs	r0, #1
 801a7f4:	f004 fddc 	bl	801f3b0 <traceIF_itmPrint>
 801a7f8:	4628      	mov	r0, r5
 801a7fa:	f004 fd96 	bl	801f32a <crs_strlen>
 801a7fe:	b283      	uxth	r3, r0
 801a800:	462a      	mov	r2, r5
 801a802:	2110      	movs	r1, #16
 801a804:	2001      	movs	r0, #1
 801a806:	f004 fdf5 	bl	801f3f4 <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 801a80a:	2001      	movs	r0, #1
      PRINT_DBG("DBG: ip_addr cb=%s", cs_ctxt_sockets_info[sockhandle].ip_addr_value)
    }
  }

  return (retval);
}
 801a80c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    PRINT_ERR("<Cellular_Service> NULL ptr")
 801a810:	4e48      	ldr	r6, [pc, #288]	; (801a934 <csint_socket_configure_remote+0x1cc>)
 801a812:	4c46      	ldr	r4, [pc, #280]	; (801a92c <csint_socket_configure_remote+0x1c4>)
 801a814:	f106 0720 	add.w	r7, r6, #32
 801a818:	4635      	mov	r5, r6
 801a81a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801a81c:	6020      	str	r0, [r4, #0]
 801a81e:	6061      	str	r1, [r4, #4]
 801a820:	60a2      	str	r2, [r4, #8]
 801a822:	60e3      	str	r3, [r4, #12]
 801a824:	462e      	mov	r6, r5
 801a826:	3410      	adds	r4, #16
 801a828:	42bd      	cmp	r5, r7
 801a82a:	d1f5      	bne.n	801a818 <csint_socket_configure_remote+0xb0>
 801a82c:	6828      	ldr	r0, [r5, #0]
 801a82e:	6020      	str	r0, [r4, #0]
 801a830:	88aa      	ldrh	r2, [r5, #4]
 801a832:	79ab      	ldrb	r3, [r5, #6]
 801a834:	80a2      	strh	r2, [r4, #4]
 801a836:	71a3      	strb	r3, [r4, #6]
 801a838:	4c3c      	ldr	r4, [pc, #240]	; (801a92c <csint_socket_configure_remote+0x1c4>)
 801a83a:	4620      	mov	r0, r4
 801a83c:	f004 fd75 	bl	801f32a <crs_strlen>
 801a840:	b283      	uxth	r3, r0
 801a842:	4622      	mov	r2, r4
 801a844:	2110      	movs	r1, #16
 801a846:	2001      	movs	r0, #1
 801a848:	f004 fdb2 	bl	801f3b0 <traceIF_itmPrint>
 801a84c:	4620      	mov	r0, r4
 801a84e:	f004 fd6c 	bl	801f32a <crs_strlen>
 801a852:	b283      	uxth	r3, r0
 801a854:	4622      	mov	r2, r4
 801a856:	2110      	movs	r1, #16
 801a858:	2001      	movs	r0, #1
 801a85a:	f004 fdcb 	bl	801f3f4 <traceIF_uartPrint>
  CS_Status_t retval = CELLULAR_ERROR;
 801a85e:	2001      	movs	r0, #1
 801a860:	e7d4      	b.n	801a80c <csint_socket_configure_remote+0xa4>
      cs_ctxt_sockets_info[sockhandle].remote_port = remote_port;
 801a862:	4b30      	ldr	r3, [pc, #192]	; (801a924 <csint_socket_configure_remote+0x1bc>)
 801a864:	226c      	movs	r2, #108	; 0x6c
 801a866:	fb02 f404 	mul.w	r4, r2, r4
 801a86a:	eb03 0904 	add.w	r9, r3, r4
 801a86e:	f8a9 804e 	strh.w	r8, [r9, #78]	; 0x4e
      cs_ctxt_sockets_info[sockhandle].ip_addr_type = ip_addr_type;
 801a872:	f889 700d 	strb.w	r7, [r9, #13]
      (void) memset((void *) &cs_ctxt_sockets_info[sockhandle].ip_addr_value, 0, MAX_IP_ADDR_SIZE);
 801a876:	3408      	adds	r4, #8
 801a878:	191f      	adds	r7, r3, r4
 801a87a:	3706      	adds	r7, #6
 801a87c:	2240      	movs	r2, #64	; 0x40
 801a87e:	2100      	movs	r1, #0
 801a880:	4638      	mov	r0, r7
 801a882:	f00c f854 	bl	802692e <memset>
      (void) memcpy((void *) &cs_ctxt_sockets_info[sockhandle].ip_addr_value, (void *)p_ip_addr_value,
 801a886:	462a      	mov	r2, r5
 801a888:	4631      	mov	r1, r6
 801a88a:	4638      	mov	r0, r7
 801a88c:	f00c f92c 	bl	8026ae8 <memcpy>
      PRINT_DBG("DBG: remote_port=%d", cs_ctxt_sockets_info[sockhandle].remote_port)
 801a890:	4c26      	ldr	r4, [pc, #152]	; (801a92c <csint_socket_configure_remote+0x1c4>)
 801a892:	f8b9 204e 	ldrh.w	r2, [r9, #78]	; 0x4e
 801a896:	4928      	ldr	r1, [pc, #160]	; (801a938 <csint_socket_configure_remote+0x1d0>)
 801a898:	4620      	mov	r0, r4
 801a89a:	f00b ffd5 	bl	8026848 <sprintf>
 801a89e:	4620      	mov	r0, r4
 801a8a0:	f004 fd43 	bl	801f32a <crs_strlen>
 801a8a4:	b283      	uxth	r3, r0
 801a8a6:	4622      	mov	r2, r4
 801a8a8:	2102      	movs	r1, #2
 801a8aa:	2001      	movs	r0, #1
 801a8ac:	f004 fd80 	bl	801f3b0 <traceIF_itmPrint>
 801a8b0:	4620      	mov	r0, r4
 801a8b2:	f004 fd3a 	bl	801f32a <crs_strlen>
 801a8b6:	b283      	uxth	r3, r0
 801a8b8:	4622      	mov	r2, r4
 801a8ba:	2102      	movs	r1, #2
 801a8bc:	2001      	movs	r0, #1
 801a8be:	f004 fd99 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_DBG("DBG: ip_addr_type=%d", cs_ctxt_sockets_info[sockhandle].ip_addr_type)
 801a8c2:	f899 200d 	ldrb.w	r2, [r9, #13]
 801a8c6:	491d      	ldr	r1, [pc, #116]	; (801a93c <csint_socket_configure_remote+0x1d4>)
 801a8c8:	4620      	mov	r0, r4
 801a8ca:	f00b ffbd 	bl	8026848 <sprintf>
 801a8ce:	4620      	mov	r0, r4
 801a8d0:	f004 fd2b 	bl	801f32a <crs_strlen>
 801a8d4:	b283      	uxth	r3, r0
 801a8d6:	4622      	mov	r2, r4
 801a8d8:	2102      	movs	r1, #2
 801a8da:	2001      	movs	r0, #1
 801a8dc:	f004 fd68 	bl	801f3b0 <traceIF_itmPrint>
 801a8e0:	4620      	mov	r0, r4
 801a8e2:	f004 fd22 	bl	801f32a <crs_strlen>
 801a8e6:	b283      	uxth	r3, r0
 801a8e8:	4622      	mov	r2, r4
 801a8ea:	2102      	movs	r1, #2
 801a8ec:	2001      	movs	r0, #1
 801a8ee:	f004 fd81 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_DBG("DBG: ip_addr cb=%s", cs_ctxt_sockets_info[sockhandle].ip_addr_value)
 801a8f2:	463a      	mov	r2, r7
 801a8f4:	4912      	ldr	r1, [pc, #72]	; (801a940 <csint_socket_configure_remote+0x1d8>)
 801a8f6:	4620      	mov	r0, r4
 801a8f8:	f00b ffa6 	bl	8026848 <sprintf>
 801a8fc:	4620      	mov	r0, r4
 801a8fe:	f004 fd14 	bl	801f32a <crs_strlen>
 801a902:	b283      	uxth	r3, r0
 801a904:	4622      	mov	r2, r4
 801a906:	2102      	movs	r1, #2
 801a908:	2001      	movs	r0, #1
 801a90a:	f004 fd51 	bl	801f3b0 <traceIF_itmPrint>
 801a90e:	4620      	mov	r0, r4
 801a910:	f004 fd0b 	bl	801f32a <crs_strlen>
 801a914:	b283      	uxth	r3, r0
 801a916:	4622      	mov	r2, r4
 801a918:	2102      	movs	r1, #2
 801a91a:	2001      	movs	r0, #1
 801a91c:	f004 fd6a 	bl	801f3f4 <traceIF_uartPrint>
      retval = CELLULAR_OK;
 801a920:	2000      	movs	r0, #0
 801a922:	e773      	b.n	801a80c <csint_socket_configure_remote+0xa4>
 801a924:	20003d18 	.word	0x20003d18
 801a928:	08032c5c 	.word	0x08032c5c
 801a92c:	200047dc 	.word	0x200047dc
 801a930:	0803464c 	.word	0x0803464c
 801a934:	08032c34 	.word	0x08032c34
 801a938:	08034694 	.word	0x08034694
 801a93c:	080346b0 	.word	0x080346b0
 801a940:	080346cc 	.word	0x080346cc

0801a944 <osCS_get_signal_quality>:
  * @note   Call CS_get_signal_quality with mutex access protection
  * @param  same parameters as the CS_get_signal_quality function
  * @retval CS_Status_t
  */
CS_Status_t osCS_get_signal_quality(CS_SignalQuality_t *p_sig_qual)
{
 801a944:	b538      	push	{r3, r4, r5, lr}
 801a946:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a948:	4d07      	ldr	r5, [pc, #28]	; (801a968 <osCS_get_signal_quality+0x24>)
 801a94a:	f04f 31ff 	mov.w	r1, #4294967295
 801a94e:	6828      	ldr	r0, [r5, #0]
 801a950:	f004 fc05 	bl	801f15e <rtosalMutexAcquire>

  result = CS_get_signal_quality(p_sig_qual);
 801a954:	4620      	mov	r0, r4
 801a956:	f7fb ffed 	bl	8016934 <CS_get_signal_quality>
 801a95a:	4604      	mov	r4, r0

  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a95c:	6828      	ldr	r0, [r5, #0]
 801a95e:	f004 fc02 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801a962:	4620      	mov	r0, r4
 801a964:	bd38      	pop	{r3, r4, r5, pc}
 801a966:	bf00      	nop
 801a968:	20003fa8 	.word	0x20003fa8

0801a96c <osCDS_socket_create>:
  * @retval Socket handle which references allocated socket
  */
socket_handle_t osCDS_socket_create(CS_IPaddrType_t addr_type,
                                    CS_TransportProtocol_t protocol,
                                    CS_PDN_conf_id_t cid)
{
 801a96c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801a96e:	4604      	mov	r4, r0
 801a970:	460d      	mov	r5, r1
 801a972:	4616      	mov	r6, r2
  socket_handle_t socket_handle;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a974:	4f08      	ldr	r7, [pc, #32]	; (801a998 <osCDS_socket_create+0x2c>)
 801a976:	f04f 31ff 	mov.w	r1, #4294967295
 801a97a:	6838      	ldr	r0, [r7, #0]
 801a97c:	f004 fbef 	bl	801f15e <rtosalMutexAcquire>

  socket_handle = CDS_socket_create(addr_type,
 801a980:	4632      	mov	r2, r6
 801a982:	4629      	mov	r1, r5
 801a984:	4620      	mov	r0, r4
 801a986:	f7fc fc0f 	bl	80171a8 <CDS_socket_create>
 801a98a:	4604      	mov	r4, r0
                                    protocol,
                                    cid);
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a98c:	6838      	ldr	r0, [r7, #0]
 801a98e:	f004 fbea 	bl	801f166 <rtosalMutexRelease>

  return (socket_handle);
}
 801a992:	4620      	mov	r0, r4
 801a994:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801a996:	bf00      	nop
 801a998:	20003fa8 	.word	0x20003fa8

0801a99c <osCDS_socket_set_callbacks>:
  */
CS_Status_t osCDS_socket_set_callbacks(socket_handle_t sockHandle,
                                       cellular_socket_data_ready_callback_t data_ready_cb,
                                       cellular_socket_data_sent_callback_t data_sent_cb,
                                       cellular_socket_closed_callback_t remote_close_cb)
{
 801a99c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801a9a0:	4604      	mov	r4, r0
 801a9a2:	460d      	mov	r5, r1
 801a9a4:	4616      	mov	r6, r2
 801a9a6:	461f      	mov	r7, r3
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a9a8:	f8df 8028 	ldr.w	r8, [pc, #40]	; 801a9d4 <osCDS_socket_set_callbacks+0x38>
 801a9ac:	f04f 31ff 	mov.w	r1, #4294967295
 801a9b0:	f8d8 0000 	ldr.w	r0, [r8]
 801a9b4:	f004 fbd3 	bl	801f15e <rtosalMutexAcquire>

  result = CDS_socket_set_callbacks(sockHandle,
 801a9b8:	463b      	mov	r3, r7
 801a9ba:	4632      	mov	r2, r6
 801a9bc:	4629      	mov	r1, r5
 801a9be:	4620      	mov	r0, r4
 801a9c0:	f7fc fd0e 	bl	80173e0 <CDS_socket_set_callbacks>
 801a9c4:	4604      	mov	r4, r0
                                    data_ready_cb,
                                    data_sent_cb,
                                    remote_close_cb);

  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801a9c6:	f8d8 0000 	ldr.w	r0, [r8]
 801a9ca:	f004 fbcc 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801a9ce:	4620      	mov	r0, r4
 801a9d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801a9d4:	20003fa8 	.word	0x20003fa8

0801a9d8 <osCDS_socket_bind>:
  * @param  same parameters as the CDS_socket_bind function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_socket_bind(socket_handle_t sockHandle,
                              uint16_t local_port)
{
 801a9d8:	b570      	push	{r4, r5, r6, lr}
 801a9da:	4604      	mov	r4, r0
 801a9dc:	460d      	mov	r5, r1
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801a9de:	f001 fe7b 	bl	801c6d8 <CST_get_state>
 801a9e2:	2808      	cmp	r0, #8
 801a9e4:	d002      	beq.n	801a9ec <osCDS_socket_bind+0x14>
  CS_Status_t result = CELLULAR_ERROR;
 801a9e6:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801a9e8:	4620      	mov	r0, r4
 801a9ea:	bd70      	pop	{r4, r5, r6, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801a9ec:	4e07      	ldr	r6, [pc, #28]	; (801aa0c <osCDS_socket_bind+0x34>)
 801a9ee:	f04f 31ff 	mov.w	r1, #4294967295
 801a9f2:	6830      	ldr	r0, [r6, #0]
 801a9f4:	f004 fbb3 	bl	801f15e <rtosalMutexAcquire>
    result = CDS_socket_bind(sockHandle,
 801a9f8:	4629      	mov	r1, r5
 801a9fa:	4620      	mov	r0, r4
 801a9fc:	f7fc fc7c 	bl	80172f8 <CDS_socket_bind>
 801aa00:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa02:	6830      	ldr	r0, [r6, #0]
 801aa04:	f004 fbaf 	bl	801f166 <rtosalMutexRelease>
 801aa08:	e7ee      	b.n	801a9e8 <osCDS_socket_bind+0x10>
 801aa0a:	bf00      	nop
 801aa0c:	20003fa8 	.word	0x20003fa8

0801aa10 <osCDS_socket_connect>:
  */
CS_Status_t osCDS_socket_connect(socket_handle_t sockHandle,
                                 CS_IPaddrType_t addr_type,
                                 CS_CHAR_t *p_ip_addr_value,
                                 uint16_t remote_port)
{
 801aa10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801aa14:	4607      	mov	r7, r0
 801aa16:	460c      	mov	r4, r1
 801aa18:	4615      	mov	r5, r2
 801aa1a:	461e      	mov	r6, r3
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801aa1c:	f001 fe5c 	bl	801c6d8 <CST_get_state>
 801aa20:	2808      	cmp	r0, #8
 801aa22:	d003      	beq.n	801aa2c <osCDS_socket_connect+0x1c>
  CS_Status_t result = CELLULAR_ERROR;
 801aa24:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801aa26:	4620      	mov	r0, r4
 801aa28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aa2c:	f8df 8024 	ldr.w	r8, [pc, #36]	; 801aa54 <osCDS_socket_connect+0x44>
 801aa30:	f04f 31ff 	mov.w	r1, #4294967295
 801aa34:	f8d8 0000 	ldr.w	r0, [r8]
 801aa38:	f004 fb91 	bl	801f15e <rtosalMutexAcquire>
    result = CDS_socket_connect(sockHandle,
 801aa3c:	4633      	mov	r3, r6
 801aa3e:	462a      	mov	r2, r5
 801aa40:	4621      	mov	r1, r4
 801aa42:	4638      	mov	r0, r7
 801aa44:	f7fc fdae 	bl	80175a4 <CDS_socket_connect>
 801aa48:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa4a:	f8d8 0000 	ldr.w	r0, [r8]
 801aa4e:	f004 fb8a 	bl	801f166 <rtosalMutexRelease>
 801aa52:	e7e8      	b.n	801aa26 <osCDS_socket_connect+0x16>
 801aa54:	20003fa8 	.word	0x20003fa8

0801aa58 <osCDS_socket_send>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_socket_send(socket_handle_t sockHandle,
                              const CS_CHAR_t *p_buf,
                              uint32_t length)
{
 801aa58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801aa5a:	4604      	mov	r4, r0
 801aa5c:	460d      	mov	r5, r1
 801aa5e:	4616      	mov	r6, r2
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801aa60:	f001 fe3a 	bl	801c6d8 <CST_get_state>
 801aa64:	2808      	cmp	r0, #8
 801aa66:	d002      	beq.n	801aa6e <osCDS_socket_send+0x16>
  CS_Status_t result = CELLULAR_ERROR;
 801aa68:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801aa6a:	4620      	mov	r0, r4
 801aa6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aa6e:	4f08      	ldr	r7, [pc, #32]	; (801aa90 <osCDS_socket_send+0x38>)
 801aa70:	f04f 31ff 	mov.w	r1, #4294967295
 801aa74:	6838      	ldr	r0, [r7, #0]
 801aa76:	f004 fb72 	bl	801f15e <rtosalMutexAcquire>
    result = CDS_socket_send(sockHandle,
 801aa7a:	4632      	mov	r2, r6
 801aa7c:	4629      	mov	r1, r5
 801aa7e:	4620      	mov	r0, r4
 801aa80:	f7fc fe18 	bl	80176b4 <CDS_socket_send>
 801aa84:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aa86:	6838      	ldr	r0, [r7, #0]
 801aa88:	f004 fb6d 	bl	801f166 <rtosalMutexRelease>
 801aa8c:	e7ed      	b.n	801aa6a <osCDS_socket_send+0x12>
 801aa8e:	bf00      	nop
 801aa90:	20003fa8 	.word	0x20003fa8

0801aa94 <osCDS_socket_receive>:
  * @retval Size of received data (in bytes).
  */
int32_t osCDS_socket_receive(socket_handle_t sockHandle,
                             CS_CHAR_t *p_buf,
                             uint32_t  max_buf_length)
{
 801aa94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801aa96:	4604      	mov	r4, r0
 801aa98:	460d      	mov	r5, r1
 801aa9a:	4616      	mov	r6, r2
  int32_t result;

  result = 0;
  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801aa9c:	f001 fe1c 	bl	801c6d8 <CST_get_state>
 801aaa0:	2808      	cmp	r0, #8
 801aaa2:	d002      	beq.n	801aaaa <osCDS_socket_receive+0x16>
  result = 0;
 801aaa4:	2400      	movs	r4, #0

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801aaa6:	4620      	mov	r0, r4
 801aaa8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aaaa:	4f08      	ldr	r7, [pc, #32]	; (801aacc <osCDS_socket_receive+0x38>)
 801aaac:	f04f 31ff 	mov.w	r1, #4294967295
 801aab0:	6838      	ldr	r0, [r7, #0]
 801aab2:	f004 fb54 	bl	801f15e <rtosalMutexAcquire>
    result = CDS_socket_receive(sockHandle,
 801aab6:	4632      	mov	r2, r6
 801aab8:	4629      	mov	r1, r5
 801aaba:	4620      	mov	r0, r4
 801aabc:	f7fd f808 	bl	8017ad0 <CDS_socket_receive>
 801aac0:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801aac2:	6838      	ldr	r0, [r7, #0]
 801aac4:	f004 fb4f 	bl	801f166 <rtosalMutexRelease>
 801aac8:	e7ed      	b.n	801aaa6 <osCDS_socket_receive+0x12>
 801aaca:	bf00      	nop
 801aacc:	20003fa8 	.word	0x20003fa8

0801aad0 <osCDS_socket_sendto>:
                                uint32_t length,
                                CS_IPaddrType_t addr_type,
                                CS_CHAR_t *p_ip_addr_value,
                                uint16_t remote_port)

{
 801aad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801aad4:	b082      	sub	sp, #8
 801aad6:	4607      	mov	r7, r0
 801aad8:	460e      	mov	r6, r1
 801aada:	4615      	mov	r5, r2
 801aadc:	461c      	mov	r4, r3
  CS_Status_t result = CELLULAR_ERROR;

  if (CST_get_state() == CST_MODEM_DATA_READY_STATE)
 801aade:	f001 fdfb 	bl	801c6d8 <CST_get_state>
 801aae2:	2808      	cmp	r0, #8
 801aae4:	d004      	beq.n	801aaf0 <osCDS_socket_sendto+0x20>
  CS_Status_t result = CELLULAR_ERROR;
 801aae6:	2401      	movs	r4, #1

    (void)rtosalMutexRelease(CellularServiceMutexHandle);
  }

  return (result);
}
 801aae8:	4620      	mov	r0, r4
 801aaea:	b002      	add	sp, #8
 801aaec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aaf0:	f8df 8030 	ldr.w	r8, [pc, #48]	; 801ab24 <osCDS_socket_sendto+0x54>
 801aaf4:	f04f 31ff 	mov.w	r1, #4294967295
 801aaf8:	f8d8 0000 	ldr.w	r0, [r8]
 801aafc:	f004 fb2f 	bl	801f15e <rtosalMutexAcquire>
    result = CDS_socket_sendto(sockHandle,
 801ab00:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
 801ab04:	9301      	str	r3, [sp, #4]
 801ab06:	9b08      	ldr	r3, [sp, #32]
 801ab08:	9300      	str	r3, [sp, #0]
 801ab0a:	4623      	mov	r3, r4
 801ab0c:	462a      	mov	r2, r5
 801ab0e:	4631      	mov	r1, r6
 801ab10:	4638      	mov	r0, r7
 801ab12:	f7fc fea7 	bl	8017864 <CDS_socket_sendto>
 801ab16:	4604      	mov	r4, r0
    (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ab18:	f8d8 0000 	ldr.w	r0, [r8]
 801ab1c:	f004 fb23 	bl	801f166 <rtosalMutexRelease>
 801ab20:	e7e2      	b.n	801aae8 <osCDS_socket_sendto+0x18>
 801ab22:	bf00      	nop
 801ab24:	20003fa8 	.word	0x20003fa8

0801ab28 <osCDS_socket_close>:
  * @param  same parameters as the CDS_socket_close function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_socket_close(socket_handle_t sockHandle,
                               uint8_t force)
{
 801ab28:	b570      	push	{r4, r5, r6, lr}
 801ab2a:	4604      	mov	r4, r0
 801ab2c:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ab2e:	4e08      	ldr	r6, [pc, #32]	; (801ab50 <osCDS_socket_close+0x28>)
 801ab30:	f04f 31ff 	mov.w	r1, #4294967295
 801ab34:	6830      	ldr	r0, [r6, #0]
 801ab36:	f004 fb12 	bl	801f15e <rtosalMutexAcquire>

  result = CDS_socket_close(sockHandle,
 801ab3a:	4629      	mov	r1, r5
 801ab3c:	4620      	mov	r0, r4
 801ab3e:	f7fd f8b5 	bl	8017cac <CDS_socket_close>
 801ab42:	4604      	mov	r4, r0
                            force);

  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ab44:	6830      	ldr	r0, [r6, #0]
 801ab46:	f004 fb0e 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ab4a:	4620      	mov	r0, r4
 801ab4c:	bd70      	pop	{r4, r5, r6, pc}
 801ab4e:	bf00      	nop
 801ab50:	20003fa8 	.word	0x20003fa8

0801ab54 <osCDS_cellular_service_init>:
  * @brief  cellular service initialization
  * @param  none
  * @retval CS_Bool_t   cellular initialized or not
  */
CS_Bool_t osCDS_cellular_service_init(void)
{
 801ab54:	b538      	push	{r3, r4, r5, lr}
  static CS_Bool_t CellularServiceInitialized = CELLULAR_FALSE;
  CS_Bool_t result;

  result = CELLULAR_TRUE;
  if (CellularServiceInitialized == CELLULAR_FALSE)
 801ab56:	4b12      	ldr	r3, [pc, #72]	; (801aba0 <osCDS_cellular_service_init+0x4c>)
 801ab58:	781c      	ldrb	r4, [r3, #0]
 801ab5a:	b114      	cbz	r4, 801ab62 <osCDS_cellular_service_init+0xe>
  result = CELLULAR_TRUE;
 801ab5c:	2501      	movs	r5, #1
     */
    CellularServiceInitialized = CELLULAR_TRUE;
  }

  return result;
}
 801ab5e:	4628      	mov	r0, r5
 801ab60:	bd38      	pop	{r3, r4, r5, pc}
    CellularServiceMutexHandle = rtosalMutexNew(NULL);
 801ab62:	2000      	movs	r0, #0
 801ab64:	f004 faf1 	bl	801f14a <rtosalMutexNew>
 801ab68:	4b0e      	ldr	r3, [pc, #56]	; (801aba4 <osCDS_cellular_service_init+0x50>)
 801ab6a:	6018      	str	r0, [r3, #0]
    if (CellularServiceMutexHandle == NULL)
 801ab6c:	b150      	cbz	r0, 801ab84 <osCDS_cellular_service_init+0x30>
  result = CELLULAR_TRUE;
 801ab6e:	2501      	movs	r5, #1
    CellularServiceGeneralMutexHandle = rtosalMutexNew(NULL);
 801ab70:	2000      	movs	r0, #0
 801ab72:	f004 faea 	bl	801f14a <rtosalMutexNew>
 801ab76:	4b0c      	ldr	r3, [pc, #48]	; (801aba8 <osCDS_cellular_service_init+0x54>)
 801ab78:	6018      	str	r0, [r3, #0]
    if (CellularServiceGeneralMutexHandle == NULL)
 801ab7a:	b150      	cbz	r0, 801ab92 <osCDS_cellular_service_init+0x3e>
    CellularServiceInitialized = CELLULAR_TRUE;
 801ab7c:	4b08      	ldr	r3, [pc, #32]	; (801aba0 <osCDS_cellular_service_init+0x4c>)
 801ab7e:	2201      	movs	r2, #1
 801ab80:	701a      	strb	r2, [r3, #0]
 801ab82:	e7ec      	b.n	801ab5e <osCDS_cellular_service_init+0xa>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 1, ERROR_FATAL);
 801ab84:	2203      	movs	r2, #3
 801ab86:	2101      	movs	r1, #1
 801ab88:	2007      	movs	r0, #7
 801ab8a:	f003 fbeb 	bl	801e364 <ERROR_Handler>
      result = CELLULAR_FALSE;
 801ab8e:	4625      	mov	r5, r4
 801ab90:	e7ee      	b.n	801ab70 <osCDS_cellular_service_init+0x1c>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 2, ERROR_FATAL);
 801ab92:	2203      	movs	r2, #3
 801ab94:	2102      	movs	r1, #2
 801ab96:	2007      	movs	r0, #7
 801ab98:	f003 fbe4 	bl	801e364 <ERROR_Handler>
      result = CELLULAR_FALSE;
 801ab9c:	4625      	mov	r5, r4
 801ab9e:	e7ed      	b.n	801ab7c <osCDS_cellular_service_init+0x28>
 801aba0:	20003fa4 	.word	0x20003fa4
 801aba4:	20003fa8 	.word	0x20003fa8
 801aba8:	20003fa0 	.word	0x20003fa0

0801abac <osCDS_get_net_status>:
  * @note   Call CS_get_net_status with mutex access protection
  * @param  same parameters as the CS_get_net_status function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_net_status(CS_RegistrationStatus_t *p_reg_status)
{
 801abac:	b538      	push	{r3, r4, r5, lr}
 801abae:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801abb0:	4d07      	ldr	r5, [pc, #28]	; (801abd0 <osCDS_get_net_status+0x24>)
 801abb2:	f04f 31ff 	mov.w	r1, #4294967295
 801abb6:	6828      	ldr	r0, [r5, #0]
 801abb8:	f004 fad1 	bl	801f15e <rtosalMutexAcquire>
  result = CS_get_net_status(p_reg_status);
 801abbc:	4620      	mov	r0, r4
 801abbe:	f7fb fe1f 	bl	8016800 <CS_get_net_status>
 801abc2:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801abc4:	6828      	ldr	r0, [r5, #0]
 801abc6:	f004 face 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801abca:	4620      	mov	r0, r4
 801abcc:	bd38      	pop	{r3, r4, r5, pc}
 801abce:	bf00      	nop
 801abd0:	20003fa8 	.word	0x20003fa8

0801abd4 <osCDS_get_device_info>:
  * @note   Call CS_get_device_info with mutex access protection
  * @param  same parameters as the CS_get_device_info function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_device_info(CS_DeviceInfo_t *p_devinfo)
{
 801abd4:	b538      	push	{r3, r4, r5, lr}
 801abd6:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801abd8:	4d07      	ldr	r5, [pc, #28]	; (801abf8 <osCDS_get_device_info+0x24>)
 801abda:	f04f 31ff 	mov.w	r1, #4294967295
 801abde:	6828      	ldr	r0, [r5, #0]
 801abe0:	f004 fabd 	bl	801f15e <rtosalMutexAcquire>
  result = CS_get_device_info(p_devinfo);
 801abe4:	4620      	mov	r0, r4
 801abe6:	f7fb fadb 	bl	80161a0 <CS_get_device_info>
 801abea:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801abec:	6828      	ldr	r0, [r5, #0]
 801abee:	f004 faba 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801abf2:	4620      	mov	r0, r4
 801abf4:	bd38      	pop	{r3, r4, r5, pc}
 801abf6:	bf00      	nop
 801abf8:	20003fa8 	.word	0x20003fa8

0801abfc <osCDS_subscribe_net_event>:
  * @param  urc_callback Handle on user callback that will be used to notify a
  *                      change on requested event.
  * @retval CS_Status_t
  */
CS_Status_t osCDS_subscribe_net_event(CS_UrcEvent_t event, cellular_urc_callback_t urc_callback)
{
 801abfc:	b570      	push	{r4, r5, r6, lr}
 801abfe:	4604      	mov	r4, r0
 801ac00:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ac02:	4e08      	ldr	r6, [pc, #32]	; (801ac24 <osCDS_subscribe_net_event+0x28>)
 801ac04:	f04f 31ff 	mov.w	r1, #4294967295
 801ac08:	6830      	ldr	r0, [r6, #0]
 801ac0a:	f004 faa8 	bl	801f15e <rtosalMutexAcquire>
  result = CS_subscribe_net_event(event,  urc_callback);
 801ac0e:	4629      	mov	r1, r5
 801ac10:	4620      	mov	r0, r4
 801ac12:	f7fb fc05 	bl	8016420 <CS_subscribe_net_event>
 801ac16:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ac18:	6830      	ldr	r0, [r6, #0]
 801ac1a:	f004 faa4 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ac1e:	4620      	mov	r0, r4
 801ac20:	bd70      	pop	{r4, r5, r6, pc}
 801ac22:	bf00      	nop
 801ac24:	20003fa8 	.word	0x20003fa8

0801ac28 <osCDS_subscribe_modem_event>:
  * @param  same parameters as the CS_subscribe_modem_event function
  *         change on requested event.
  * @retval CS_Status_t
  */
CS_Status_t osCDS_subscribe_modem_event(CS_ModemEvent_t events_mask, cellular_modem_event_callback_t modem_evt_cb)
{
 801ac28:	b570      	push	{r4, r5, r6, lr}
 801ac2a:	4604      	mov	r4, r0
 801ac2c:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ac2e:	4e08      	ldr	r6, [pc, #32]	; (801ac50 <osCDS_subscribe_modem_event+0x28>)
 801ac30:	f04f 31ff 	mov.w	r1, #4294967295
 801ac34:	6830      	ldr	r0, [r6, #0]
 801ac36:	f004 fa92 	bl	801f15e <rtosalMutexAcquire>
  result = CS_subscribe_modem_event(events_mask, modem_evt_cb);
 801ac3a:	4629      	mov	r1, r5
 801ac3c:	4620      	mov	r0, r4
 801ac3e:	f7fc f95f 	bl	8016f00 <CS_subscribe_modem_event>
 801ac42:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ac44:	6830      	ldr	r0, [r6, #0]
 801ac46:	f004 fa8e 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ac4a:	4620      	mov	r0, r4
 801ac4c:	bd70      	pop	{r4, r5, r6, pc}
 801ac4e:	bf00      	nop
 801ac50:	20003fa8 	.word	0x20003fa8

0801ac54 <osCDS_power_on>:
  * @note   Call CS_power_on with mutex access protection
  * @param  none
  * @retval CS_Status_t
  */
CS_Status_t osCDS_power_on(void)
{
 801ac54:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ac56:	4d07      	ldr	r5, [pc, #28]	; (801ac74 <osCDS_power_on+0x20>)
 801ac58:	f04f 31ff 	mov.w	r1, #4294967295
 801ac5c:	6828      	ldr	r0, [r5, #0]
 801ac5e:	f004 fa7e 	bl	801f15e <rtosalMutexAcquire>
  result = CS_power_on();
 801ac62:	f7fb f835 	bl	8015cd0 <CS_power_on>
 801ac66:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ac68:	6828      	ldr	r0, [r5, #0]
 801ac6a:	f004 fa7c 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ac6e:	4620      	mov	r0, r4
 801ac70:	bd38      	pop	{r3, r4, r5, pc}
 801ac72:	bf00      	nop
 801ac74:	20003fa8 	.word	0x20003fa8

0801ac78 <osCDS_power_off>:
  * @note   Call CS_power_off with mutex access protection
  * @param  none
  * @retval CS_Status_t
  */
CS_Status_t osCDS_power_off(void)
{
 801ac78:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ac7a:	4d07      	ldr	r5, [pc, #28]	; (801ac98 <osCDS_power_off+0x20>)
 801ac7c:	f04f 31ff 	mov.w	r1, #4294967295
 801ac80:	6828      	ldr	r0, [r5, #0]
 801ac82:	f004 fa6c 	bl	801f15e <rtosalMutexAcquire>
  result = CS_power_off();
 801ac86:	f7fb f8b9 	bl	8015dfc <CS_power_off>
 801ac8a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ac8c:	6828      	ldr	r0, [r5, #0]
 801ac8e:	f004 fa6a 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ac92:	4620      	mov	r0, r4
 801ac94:	bd38      	pop	{r3, r4, r5, pc}
 801ac96:	bf00      	nop
 801ac98:	20003fa8 	.word	0x20003fa8

0801ac9c <osCDS_init_modem>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_init_modem(CS_ModemInit_t init,
                             CS_Bool_t reset,
                             const CS_CHAR_t *pin_code)
{
 801ac9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ac9e:	4604      	mov	r4, r0
 801aca0:	460d      	mov	r5, r1
 801aca2:	4616      	mov	r6, r2
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801aca4:	4f08      	ldr	r7, [pc, #32]	; (801acc8 <osCDS_init_modem+0x2c>)
 801aca6:	f04f 31ff 	mov.w	r1, #4294967295
 801acaa:	6838      	ldr	r0, [r7, #0]
 801acac:	f004 fa57 	bl	801f15e <rtosalMutexAcquire>
  result = CS_init_modem(init,  reset, pin_code);
 801acb0:	4632      	mov	r2, r6
 801acb2:	4629      	mov	r1, r5
 801acb4:	4620      	mov	r0, r4
 801acb6:	f7fb f9c3 	bl	8016040 <CS_init_modem>
 801acba:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801acbc:	6838      	ldr	r0, [r7, #0]
 801acbe:	f004 fa52 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801acc2:	4620      	mov	r0, r4
 801acc4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801acc6:	bf00      	nop
 801acc8:	20003fa8 	.word	0x20003fa8

0801accc <osCDS_register_net>:
  * @param  same parameters as the CS_register_net function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_register_net(CS_OperatorSelector_t *p_operator,
                               CS_RegistrationStatus_t *p_reg_status)
{
 801accc:	b570      	push	{r4, r5, r6, lr}
 801acce:	4604      	mov	r4, r0
 801acd0:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801acd2:	4e08      	ldr	r6, [pc, #32]	; (801acf4 <osCDS_register_net+0x28>)
 801acd4:	f04f 31ff 	mov.w	r1, #4294967295
 801acd8:	6830      	ldr	r0, [r6, #0]
 801acda:	f004 fa40 	bl	801f15e <rtosalMutexAcquire>
  result = CS_register_net(p_operator, p_reg_status);
 801acde:	4629      	mov	r1, r5
 801ace0:	4620      	mov	r0, r4
 801ace2:	f7fb fb07 	bl	80162f4 <CS_register_net>
 801ace6:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ace8:	6830      	ldr	r0, [r6, #0]
 801acea:	f004 fa3c 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801acee:	4620      	mov	r0, r4
 801acf0:	bd70      	pop	{r4, r5, r6, pc}
 801acf2:	bf00      	nop
 801acf4:	20003fa8 	.word	0x20003fa8

0801acf8 <osCDS_get_attach_status>:
  * @note   Call CDS_socket_set_callbacks with mutex access protection
  * @param  same parameters as the CDS_socket_set_callbacks function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_attach_status(CS_PSattach_t *p_attach)
{
 801acf8:	b538      	push	{r3, r4, r5, lr}
 801acfa:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801acfc:	4d07      	ldr	r5, [pc, #28]	; (801ad1c <osCDS_get_attach_status+0x24>)
 801acfe:	f04f 31ff 	mov.w	r1, #4294967295
 801ad02:	6828      	ldr	r0, [r5, #0]
 801ad04:	f004 fa2b 	bl	801f15e <rtosalMutexAcquire>
  result = CS_get_attach_status(p_attach);
 801ad08:	4620      	mov	r0, r4
 801ad0a:	f7fb fcfd 	bl	8016708 <CS_get_attach_status>
 801ad0e:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ad10:	6828      	ldr	r0, [r5, #0]
 801ad12:	f004 fa28 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ad16:	4620      	mov	r0, r4
 801ad18:	bd38      	pop	{r3, r4, r5, pc}
 801ad1a:	bf00      	nop
 801ad1c:	20003fa8 	.word	0x20003fa8

0801ad20 <osCDS_attach_PS_domain>:
  * @note   Call CS_attach_PS_domain with mutex access protection
  * @param  none.
  * @retval CS_Status_t
  */
CS_Status_t osCDS_attach_PS_domain(void)
{
 801ad20:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ad22:	4d07      	ldr	r5, [pc, #28]	; (801ad40 <osCDS_attach_PS_domain+0x20>)
 801ad24:	f04f 31ff 	mov.w	r1, #4294967295
 801ad28:	6828      	ldr	r0, [r5, #0]
 801ad2a:	f004 fa18 	bl	801f15e <rtosalMutexAcquire>
  result = CS_attach_PS_domain();
 801ad2e:	f7fb fc59 	bl	80165e4 <CS_attach_PS_domain>
 801ad32:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ad34:	6828      	ldr	r0, [r5, #0]
 801ad36:	f004 fa16 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ad3a:	4620      	mov	r0, r4
 801ad3c:	bd38      	pop	{r3, r4, r5, pc}
 801ad3e:	bf00      	nop
 801ad40:	20003fa8 	.word	0x20003fa8

0801ad44 <osCDS_define_pdn>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_define_pdn(CS_PDN_conf_id_t cid,
                             const CS_CHAR_t *apn,
                             CS_PDN_configuration_t *pdn_conf)
{
 801ad44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ad46:	4604      	mov	r4, r0
 801ad48:	460d      	mov	r5, r1
 801ad4a:	4616      	mov	r6, r2
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ad4c:	4f08      	ldr	r7, [pc, #32]	; (801ad70 <osCDS_define_pdn+0x2c>)
 801ad4e:	f04f 31ff 	mov.w	r1, #4294967295
 801ad52:	6838      	ldr	r0, [r7, #0]
 801ad54:	f004 fa03 	bl	801f15e <rtosalMutexAcquire>
  result = CS_define_pdn(cid, apn, pdn_conf);
 801ad58:	4632      	mov	r2, r6
 801ad5a:	4629      	mov	r1, r5
 801ad5c:	4620      	mov	r0, r4
 801ad5e:	f7fb fef3 	bl	8016b48 <CS_define_pdn>
 801ad62:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ad64:	6838      	ldr	r0, [r7, #0]
 801ad66:	f004 f9fe 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ad6a:	4620      	mov	r0, r4
 801ad6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ad6e:	bf00      	nop
 801ad70:	20003fa8 	.word	0x20003fa8

0801ad74 <osCDS_register_pdn_event>:
  * @param  same parameters as the CS_register_pdn_event function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_register_pdn_event(CS_PDN_conf_id_t cid,
                                     cellular_pdn_event_callback_t pdn_event_callback)
{
 801ad74:	b570      	push	{r4, r5, r6, lr}
 801ad76:	4604      	mov	r4, r0
 801ad78:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ad7a:	4e08      	ldr	r6, [pc, #32]	; (801ad9c <osCDS_register_pdn_event+0x28>)
 801ad7c:	f04f 31ff 	mov.w	r1, #4294967295
 801ad80:	6830      	ldr	r0, [r6, #0]
 801ad82:	f004 f9ec 	bl	801f15e <rtosalMutexAcquire>
  result = CS_register_pdn_event(cid,  pdn_event_callback);
 801ad86:	4629      	mov	r1, r5
 801ad88:	4620      	mov	r0, r4
 801ad8a:	f7fc f945 	bl	8017018 <CS_register_pdn_event>
 801ad8e:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ad90:	6830      	ldr	r0, [r6, #0]
 801ad92:	f004 f9e8 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ad96:	4620      	mov	r0, r4
 801ad98:	bd70      	pop	{r4, r5, r6, pc}
 801ad9a:	bf00      	nop
 801ad9c:	20003fa8 	.word	0x20003fa8

0801ada0 <osCDS_set_default_pdn>:
  * @note   Call CS_set_default_pdn with mutex access protection
  * @param  same parameters as the CS_set_default_pdn function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_set_default_pdn(CS_PDN_conf_id_t cid)
{
 801ada0:	b538      	push	{r3, r4, r5, lr}
 801ada2:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ada4:	4d07      	ldr	r5, [pc, #28]	; (801adc4 <osCDS_set_default_pdn+0x24>)
 801ada6:	f04f 31ff 	mov.w	r1, #4294967295
 801adaa:	6828      	ldr	r0, [r5, #0]
 801adac:	f004 f9d7 	bl	801f15e <rtosalMutexAcquire>
  result = CS_set_default_pdn(cid);
 801adb0:	4620      	mov	r0, r4
 801adb2:	f7fb ff7b 	bl	8016cac <CS_set_default_pdn>
 801adb6:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801adb8:	6828      	ldr	r0, [r5, #0]
 801adba:	f004 f9d4 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801adbe:	4620      	mov	r0, r4
 801adc0:	bd38      	pop	{r3, r4, r5, pc}
 801adc2:	bf00      	nop
 801adc4:	20003fa8 	.word	0x20003fa8

0801adc8 <osCDS_activate_pdn>:
  * @note   Call CS_activate_pdn with mutex access protection
  * @param  same parameters as the CS_activate_pdn function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_activate_pdn(CS_PDN_conf_id_t cid)
{
 801adc8:	b538      	push	{r3, r4, r5, lr}
 801adca:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801adcc:	4d07      	ldr	r5, [pc, #28]	; (801adec <osCDS_activate_pdn+0x24>)
 801adce:	f04f 31ff 	mov.w	r1, #4294967295
 801add2:	6828      	ldr	r0, [r5, #0]
 801add4:	f004 f9c3 	bl	801f15e <rtosalMutexAcquire>
  result = CS_activate_pdn(cid);
 801add8:	4620      	mov	r0, r4
 801adda:	f7fb fe41 	bl	8016a60 <CS_activate_pdn>
 801adde:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ade0:	6828      	ldr	r0, [r5, #0]
 801ade2:	f004 f9c0 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ade6:	4620      	mov	r0, r4
 801ade8:	bd38      	pop	{r3, r4, r5, pc}
 801adea:	bf00      	nop
 801adec:	20003fa8 	.word	0x20003fa8

0801adf0 <osCDS_direct_cmd>:
  * @param  same parameters as the CS_direct_cmd function
  * @retval CS_Status_t
  */
CS_Status_t osCDS_direct_cmd(CS_direct_cmd_tx_t *direct_cmd_tx,
                             cellular_direct_cmd_callback_t direct_cmd_callback)
{
 801adf0:	b570      	push	{r4, r5, r6, lr}
 801adf2:	4604      	mov	r4, r0
 801adf4:	460d      	mov	r5, r1
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801adf6:	4e08      	ldr	r6, [pc, #32]	; (801ae18 <osCDS_direct_cmd+0x28>)
 801adf8:	f04f 31ff 	mov.w	r1, #4294967295
 801adfc:	6830      	ldr	r0, [r6, #0]
 801adfe:	f004 f9ae 	bl	801f15e <rtosalMutexAcquire>
  result =  CS_direct_cmd(direct_cmd_tx, direct_cmd_callback);
 801ae02:	4629      	mov	r1, r5
 801ae04:	4620      	mov	r0, r4
 801ae06:	f7fd f84d 	bl	8017ea4 <CS_direct_cmd>
 801ae0a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ae0c:	6830      	ldr	r0, [r6, #0]
 801ae0e:	f004 f9aa 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ae12:	4620      	mov	r0, r4
 801ae14:	bd70      	pop	{r4, r5, r6, pc}
 801ae16:	bf00      	nop
 801ae18:	20003fa8 	.word	0x20003fa8

0801ae1c <osCDS_get_dev_IP_address>:
  * @retval CS_Status_t
  */
CS_Status_t osCDS_get_dev_IP_address(CS_PDN_conf_id_t cid,
                                     CS_IPaddrType_t *ip_addr_type,
                                     CS_CHAR_t *p_ip_addr_value)
{
 801ae1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801ae1e:	4604      	mov	r4, r0
 801ae20:	460d      	mov	r5, r1
 801ae22:	4616      	mov	r6, r2
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ae24:	4f08      	ldr	r7, [pc, #32]	; (801ae48 <osCDS_get_dev_IP_address+0x2c>)
 801ae26:	f04f 31ff 	mov.w	r1, #4294967295
 801ae2a:	6838      	ldr	r0, [r7, #0]
 801ae2c:	f004 f997 	bl	801f15e <rtosalMutexAcquire>
  result = CS_get_dev_IP_address(cid, ip_addr_type, p_ip_addr_value);
 801ae30:	4632      	mov	r2, r6
 801ae32:	4629      	mov	r1, r5
 801ae34:	4620      	mov	r0, r4
 801ae36:	f7fb ffad 	bl	8016d94 <CS_get_dev_IP_address>
 801ae3a:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ae3c:	6838      	ldr	r0, [r7, #0]
 801ae3e:	f004 f992 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ae42:	4620      	mov	r0, r4
 801ae44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801ae46:	bf00      	nop
 801ae48:	20003fa8 	.word	0x20003fa8

0801ae4c <osCS_sim_select>:
  *         Call CS_sim_select with mutex access protection
  * @param  same parameters as the CS_sim_select function
  * @retval CS_Status_t
  */
CS_Status_t osCS_sim_select(CS_SimSlot_t simSelected)
{
 801ae4c:	b538      	push	{r3, r4, r5, lr}
 801ae4e:	4604      	mov	r4, r0
  CS_Status_t result;

  (void)rtosalMutexAcquire(CellularServiceMutexHandle, RTOSAL_WAIT_FOREVER);
 801ae50:	4d07      	ldr	r5, [pc, #28]	; (801ae70 <osCS_sim_select+0x24>)
 801ae52:	f04f 31ff 	mov.w	r1, #4294967295
 801ae56:	6828      	ldr	r0, [r5, #0]
 801ae58:	f004 f981 	bl	801f15e <rtosalMutexAcquire>
  result = CS_sim_select(simSelected);
 801ae5c:	4620      	mov	r0, r4
 801ae5e:	f7fb f863 	bl	8015f28 <CS_sim_select>
 801ae62:	4604      	mov	r4, r0
  (void)rtosalMutexRelease(CellularServiceMutexHandle);
 801ae64:	6828      	ldr	r0, [r5, #0]
 801ae66:	f004 f97e 	bl	801f166 <rtosalMutexRelease>

  return (result);
}
 801ae6a:	4620      	mov	r0, r4
 801ae6c:	bd38      	pop	{r3, r4, r5, pc}
 801ae6e:	bf00      	nop
 801ae70:	20003fa8 	.word	0x20003fa8

0801ae74 <CST_fota_timeout_event_mngt>:
  * @brief  FOTA timeout
  * @param  -
  * @retval -
  */
static void CST_fota_timeout_event_mngt(void)
{
 801ae74:	b538      	push	{r3, r4, r5, lr}
  /* FOTA timeout has occurred : FAIL */

  PRINT_CELLULAR_SERVICE("CST FOTA FAIL : Timeout expired RESTART\n\r")
 801ae76:	4c16      	ldr	r4, [pc, #88]	; (801aed0 <CST_fota_timeout_event_mngt+0x5c>)
 801ae78:	4d16      	ldr	r5, [pc, #88]	; (801aed4 <CST_fota_timeout_event_mngt+0x60>)
 801ae7a:	f104 0e20 	add.w	lr, r4, #32
 801ae7e:	46a4      	mov	ip, r4
 801ae80:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ae84:	6028      	str	r0, [r5, #0]
 801ae86:	6069      	str	r1, [r5, #4]
 801ae88:	60aa      	str	r2, [r5, #8]
 801ae8a:	60eb      	str	r3, [r5, #12]
 801ae8c:	4664      	mov	r4, ip
 801ae8e:	3510      	adds	r5, #16
 801ae90:	45f4      	cmp	ip, lr
 801ae92:	d1f4      	bne.n	801ae7e <CST_fota_timeout_event_mngt+0xa>
 801ae94:	cc03      	ldmia	r4!, {r0, r1}
 801ae96:	6028      	str	r0, [r5, #0]
 801ae98:	6069      	str	r1, [r5, #4]
 801ae9a:	8823      	ldrh	r3, [r4, #0]
 801ae9c:	812b      	strh	r3, [r5, #8]
 801ae9e:	4c0d      	ldr	r4, [pc, #52]	; (801aed4 <CST_fota_timeout_event_mngt+0x60>)
 801aea0:	4620      	mov	r0, r4
 801aea2:	f004 fa42 	bl	801f32a <crs_strlen>
 801aea6:	b283      	uxth	r3, r0
 801aea8:	4622      	mov	r2, r4
 801aeaa:	2101      	movs	r1, #1
 801aeac:	2007      	movs	r0, #7
 801aeae:	f004 fa7f 	bl	801f3b0 <traceIF_itmPrint>
 801aeb2:	4620      	mov	r0, r4
 801aeb4:	f004 fa39 	bl	801f32a <crs_strlen>
 801aeb8:	b283      	uxth	r3, r0
 801aeba:	4622      	mov	r2, r4
 801aebc:	2101      	movs	r1, #1
 801aebe:	2007      	movs	r0, #7
 801aec0:	f004 fa98 	bl	801f3f4 <traceIF_uartPrint>

  ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 4, ERROR_FATAL);
 801aec4:	2203      	movs	r2, #3
 801aec6:	2104      	movs	r1, #4
 801aec8:	2007      	movs	r0, #7
 801aeca:	f003 fa4b 	bl	801e364 <ERROR_Handler>
}
 801aece:	bd38      	pop	{r3, r4, r5, pc}
 801aed0:	080346e4 	.word	0x080346e4
 801aed4:	20004ddc 	.word	0x20004ddc

0801aed8 <CST_modem_off_mngt>:
  * @brief  set modem off
  * @param  -
  * @retval -
  */
static void CST_modem_off_mngt(void)
{
 801aed8:	b570      	push	{r4, r5, r6, lr}
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801aeda:	4e09      	ldr	r6, [pc, #36]	; (801af00 <CST_modem_off_mngt+0x28>)
 801aedc:	4c09      	ldr	r4, [pc, #36]	; (801af04 <CST_modem_off_mngt+0x2c>)
 801aede:	4d0a      	ldr	r5, [pc, #40]	; (801af08 <CST_modem_off_mngt+0x30>)
 801aee0:	23f4      	movs	r3, #244	; 0xf4
 801aee2:	4622      	mov	r2, r4
 801aee4:	8831      	ldrh	r1, [r6, #0]
 801aee6:	4628      	mov	r0, r5
 801aee8:	f007 f922 	bl	8022130 <dc_com_read>
  cst_cellular_info.modem_state = DC_MODEM_STATE_OFF;
 801aeec:	2300      	movs	r3, #0
 801aeee:	7263      	strb	r3, [r4, #9]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801aef0:	23f4      	movs	r3, #244	; 0xf4
 801aef2:	4622      	mov	r2, r4
 801aef4:	8831      	ldrh	r1, [r6, #0]
 801aef6:	4628      	mov	r0, r5
 801aef8:	f007 f8ce 	bl	8022098 <dc_com_write>
}
 801aefc:	bd70      	pop	{r4, r5, r6, pc}
 801aefe:	bf00      	nop
 801af00:	20000236 	.word	0x20000236
 801af04:	2000406c 	.word	0x2000406c
 801af08:	200058b0 	.word	0x200058b0

0801af0c <CST_nw_reg_timeout_expiration_mngt>:
{
 801af0c:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("-----> NW REG TIMEOUT TIMER EXPIRY WE PWDN THE MODEM \n\r")
 801af0e:	4c2e      	ldr	r4, [pc, #184]	; (801afc8 <CST_nw_reg_timeout_expiration_mngt+0xbc>)
 801af10:	4d2e      	ldr	r5, [pc, #184]	; (801afcc <CST_nw_reg_timeout_expiration_mngt+0xc0>)
 801af12:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801af16:	46a4      	mov	ip, r4
 801af18:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801af1c:	6028      	str	r0, [r5, #0]
 801af1e:	6069      	str	r1, [r5, #4]
 801af20:	60aa      	str	r2, [r5, #8]
 801af22:	60eb      	str	r3, [r5, #12]
 801af24:	4664      	mov	r4, ip
 801af26:	3510      	adds	r5, #16
 801af28:	45f4      	cmp	ip, lr
 801af2a:	d1f4      	bne.n	801af16 <CST_nw_reg_timeout_expiration_mngt+0xa>
 801af2c:	cc03      	ldmia	r4!, {r0, r1}
 801af2e:	6028      	str	r0, [r5, #0]
 801af30:	6069      	str	r1, [r5, #4]
 801af32:	4c26      	ldr	r4, [pc, #152]	; (801afcc <CST_nw_reg_timeout_expiration_mngt+0xc0>)
 801af34:	4620      	mov	r0, r4
 801af36:	f004 f9f8 	bl	801f32a <crs_strlen>
 801af3a:	b283      	uxth	r3, r0
 801af3c:	4622      	mov	r2, r4
 801af3e:	2101      	movs	r1, #1
 801af40:	2007      	movs	r0, #7
 801af42:	f004 fa35 	bl	801f3b0 <traceIF_itmPrint>
 801af46:	4620      	mov	r0, r4
 801af48:	f004 f9ef 	bl	801f32a <crs_strlen>
 801af4c:	b283      	uxth	r3, r0
 801af4e:	4622      	mov	r2, r4
 801af50:	2101      	movs	r1, #1
 801af52:	2007      	movs	r0, #7
 801af54:	f004 fa4e 	bl	801f3f4 <traceIF_uartPrint>
  if (cst_nfmc_context.active == true)
 801af58:	4b1d      	ldr	r3, [pc, #116]	; (801afd0 <CST_nw_reg_timeout_expiration_mngt+0xc4>)
 801af5a:	781b      	ldrb	r3, [r3, #0]
 801af5c:	b903      	cbnz	r3, 801af60 <CST_nw_reg_timeout_expiration_mngt+0x54>
}
 801af5e:	bd70      	pop	{r4, r5, r6, pc}
    cst_nfmc_context.nfmc_timer_on_going = true;
 801af60:	4c1b      	ldr	r4, [pc, #108]	; (801afd0 <CST_nw_reg_timeout_expiration_mngt+0xc4>)
 801af62:	2601      	movs	r6, #1
 801af64:	7066      	strb	r6, [r4, #1]
    (void)osCDS_power_off();
 801af66:	f7ff fe87 	bl	801ac78 <osCDS_power_off>
                           cst_nfmc_context.tempo[cst_context.register_retry_tempo_count]);
 801af6a:	4d1a      	ldr	r5, [pc, #104]	; (801afd4 <CST_nw_reg_timeout_expiration_mngt+0xc8>)
 801af6c:	89eb      	ldrh	r3, [r5, #14]
    (void)rtosalTimerStart(cst_register_retry_timer_handle,
 801af6e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801af72:	6859      	ldr	r1, [r3, #4]
 801af74:	4b18      	ldr	r3, [pc, #96]	; (801afd8 <CST_nw_reg_timeout_expiration_mngt+0xcc>)
 801af76:	6818      	ldr	r0, [r3, #0]
 801af78:	f004 f927 	bl	801f1ca <rtosalTimerStart>
    PRINT_CELLULAR_SERVICE("-----> CST_waiting_for_network_status NOK - retry tempo %d : %ld\n\r",
 801af7c:	89ea      	ldrh	r2, [r5, #14]
 801af7e:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 801af82:	4c12      	ldr	r4, [pc, #72]	; (801afcc <CST_nw_reg_timeout_expiration_mngt+0xc0>)
 801af84:	685b      	ldr	r3, [r3, #4]
 801af86:	4432      	add	r2, r6
 801af88:	4914      	ldr	r1, [pc, #80]	; (801afdc <CST_nw_reg_timeout_expiration_mngt+0xd0>)
 801af8a:	4620      	mov	r0, r4
 801af8c:	f00b fc5c 	bl	8026848 <sprintf>
 801af90:	4620      	mov	r0, r4
 801af92:	f004 f9ca 	bl	801f32a <crs_strlen>
 801af96:	b283      	uxth	r3, r0
 801af98:	4622      	mov	r2, r4
 801af9a:	4631      	mov	r1, r6
 801af9c:	2007      	movs	r0, #7
 801af9e:	f004 fa07 	bl	801f3b0 <traceIF_itmPrint>
 801afa2:	4620      	mov	r0, r4
 801afa4:	f004 f9c1 	bl	801f32a <crs_strlen>
 801afa8:	b283      	uxth	r3, r0
 801afaa:	4622      	mov	r2, r4
 801afac:	4631      	mov	r1, r6
 801afae:	2007      	movs	r0, #7
 801afb0:	f004 fa20 	bl	801f3f4 <traceIF_uartPrint>
    cst_context.register_retry_tempo_count++;
 801afb4:	89eb      	ldrh	r3, [r5, #14]
 801afb6:	4433      	add	r3, r6
 801afb8:	b29b      	uxth	r3, r3
 801afba:	81eb      	strh	r3, [r5, #14]
    if (cst_context.register_retry_tempo_count >= CST_NFMC_TEMPO_NB)
 801afbc:	2b06      	cmp	r3, #6
 801afbe:	d9ce      	bls.n	801af5e <CST_nw_reg_timeout_expiration_mngt+0x52>
      cst_context.register_retry_tempo_count = 0U;
 801afc0:	2200      	movs	r2, #0
 801afc2:	81ea      	strh	r2, [r5, #14]
}
 801afc4:	e7cb      	b.n	801af5e <CST_nw_reg_timeout_expiration_mngt+0x52>
 801afc6:	bf00      	nop
 801afc8:	08034710 	.word	0x08034710
 801afcc:	20004ddc 	.word	0x20004ddc
 801afd0:	2000430c 	.word	0x2000430c
 801afd4:	200000b0 	.word	0x200000b0
 801afd8:	20004334 	.word	0x20004334
 801afdc:	08034748 	.word	0x08034748

0801afe0 <CST_off_state_target_cmd_state_mngt>:
{
 801afe0:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_init_state_mngt ********\n\r")
 801afe2:	4c28      	ldr	r4, [pc, #160]	; (801b084 <CST_off_state_target_cmd_state_mngt+0xa4>)
 801afe4:	4d28      	ldr	r5, [pc, #160]	; (801b088 <CST_off_state_target_cmd_state_mngt+0xa8>)
 801afe6:	f104 0e20 	add.w	lr, r4, #32
 801afea:	46a4      	mov	ip, r4
 801afec:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801aff0:	6028      	str	r0, [r5, #0]
 801aff2:	6069      	str	r1, [r5, #4]
 801aff4:	60aa      	str	r2, [r5, #8]
 801aff6:	60eb      	str	r3, [r5, #12]
 801aff8:	4664      	mov	r4, ip
 801affa:	3510      	adds	r5, #16
 801affc:	45f4      	cmp	ip, lr
 801affe:	d1f4      	bne.n	801afea <CST_off_state_target_cmd_state_mngt+0xa>
 801b000:	cc03      	ldmia	r4!, {r0, r1}
 801b002:	6028      	str	r0, [r5, #0]
 801b004:	6069      	str	r1, [r5, #4]
 801b006:	8822      	ldrh	r2, [r4, #0]
 801b008:	78a3      	ldrb	r3, [r4, #2]
 801b00a:	812a      	strh	r2, [r5, #8]
 801b00c:	72ab      	strb	r3, [r5, #10]
 801b00e:	4c1e      	ldr	r4, [pc, #120]	; (801b088 <CST_off_state_target_cmd_state_mngt+0xa8>)
 801b010:	4620      	mov	r0, r4
 801b012:	f004 f98a 	bl	801f32a <crs_strlen>
 801b016:	b283      	uxth	r3, r0
 801b018:	4622      	mov	r2, r4
 801b01a:	2101      	movs	r1, #1
 801b01c:	2007      	movs	r0, #7
 801b01e:	f004 f9c7 	bl	801f3b0 <traceIF_itmPrint>
 801b022:	4620      	mov	r0, r4
 801b024:	f004 f981 	bl	801f32a <crs_strlen>
 801b028:	b283      	uxth	r3, r0
 801b02a:	4622      	mov	r2, r4
 801b02c:	2101      	movs	r1, #1
 801b02e:	2007      	movs	r0, #7
 801b030:	f004 f9e0 	bl	801f3f4 <traceIF_uartPrint>
  if (cst_cellular_params.target_state != DC_TARGET_STATE_OFF)
 801b034:	4b15      	ldr	r3, [pc, #84]	; (801b08c <CST_off_state_target_cmd_state_mngt+0xac>)
 801b036:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b03a:	b113      	cbz	r3, 801b042 <CST_off_state_target_cmd_state_mngt+0x62>
    if (cst_nfmc_context.nfmc_timer_on_going == false)
 801b03c:	4b14      	ldr	r3, [pc, #80]	; (801b090 <CST_off_state_target_cmd_state_mngt+0xb0>)
 801b03e:	785b      	ldrb	r3, [r3, #1]
 801b040:	b103      	cbz	r3, 801b044 <CST_off_state_target_cmd_state_mngt+0x64>
}
 801b042:	bd70      	pop	{r4, r5, r6, pc}
      cs_status = osCDS_power_on();
 801b044:	f7ff fe06 	bl	801ac54 <osCDS_power_on>
      if (cs_status != CELLULAR_OK)
 801b048:	b130      	cbz	r0, 801b058 <CST_off_state_target_cmd_state_mngt+0x78>
        CST_config_fail(((uint8_t *)"CST_cmd"),
 801b04a:	2305      	movs	r3, #5
 801b04c:	4a11      	ldr	r2, [pc, #68]	; (801b094 <CST_off_state_target_cmd_state_mngt+0xb4>)
 801b04e:	2101      	movs	r1, #1
 801b050:	4811      	ldr	r0, [pc, #68]	; (801b098 <CST_off_state_target_cmd_state_mngt+0xb8>)
 801b052:	f002 fb0b 	bl	801d66c <CST_config_fail>
 801b056:	e7f4      	b.n	801b042 <CST_off_state_target_cmd_state_mngt+0x62>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b058:	4e10      	ldr	r6, [pc, #64]	; (801b09c <CST_off_state_target_cmd_state_mngt+0xbc>)
 801b05a:	4c11      	ldr	r4, [pc, #68]	; (801b0a0 <CST_off_state_target_cmd_state_mngt+0xc0>)
 801b05c:	4d11      	ldr	r5, [pc, #68]	; (801b0a4 <CST_off_state_target_cmd_state_mngt+0xc4>)
 801b05e:	23f4      	movs	r3, #244	; 0xf4
 801b060:	4622      	mov	r2, r4
 801b062:	8831      	ldrh	r1, [r6, #0]
 801b064:	4628      	mov	r0, r5
 801b066:	f007 f863 	bl	8022130 <dc_com_read>
        cst_cellular_info.rt_state    = DC_SERVICE_RUN;
 801b06a:	2306      	movs	r3, #6
 801b06c:	7223      	strb	r3, [r4, #8]
        cst_cellular_info.modem_state = DC_MODEM_STATE_POWERED_ON;
 801b06e:	2301      	movs	r3, #1
 801b070:	7263      	strb	r3, [r4, #9]
        (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b072:	23f4      	movs	r3, #244	; 0xf4
 801b074:	4622      	mov	r2, r4
 801b076:	8831      	ldrh	r1, [r6, #0]
 801b078:	4628      	mov	r0, r5
 801b07a:	f007 f80d 	bl	8022098 <dc_com_write>
        CST_modem_sim_init();
 801b07e:	f002 fbf3 	bl	801d868 <CST_modem_sim_init>
}
 801b082:	e7de      	b.n	801b042 <CST_off_state_target_cmd_state_mngt+0x62>
 801b084:	0803478c 	.word	0x0803478c
 801b088:	20004ddc 	.word	0x20004ddc
 801b08c:	20004160 	.word	0x20004160
 801b090:	2000430c 	.word	0x2000430c
 801b094:	200000c1 	.word	0x200000c1
 801b098:	080347b8 	.word	0x080347b8
 801b09c:	20000236 	.word	0x20000236
 801b0a0:	2000406c 	.word	0x2000406c
 801b0a4:	200058b0 	.word	0x200058b0

0801b0a8 <CST_polling_timer_mngt>:
{
 801b0a8:	b538      	push	{r3, r4, r5, lr}
  if (CST_polling_active == true)
 801b0aa:	4b1b      	ldr	r3, [pc, #108]	; (801b118 <CST_polling_timer_mngt+0x70>)
 801b0ac:	781b      	ldrb	r3, [r3, #0]
 801b0ae:	b38b      	cbz	r3, 801b114 <CST_polling_timer_mngt+0x6c>
    if (CST_polling_on_going == false)
 801b0b0:	4b1a      	ldr	r3, [pc, #104]	; (801b11c <CST_polling_timer_mngt+0x74>)
 801b0b2:	781b      	ldrb	r3, [r3, #0]
 801b0b4:	b93b      	cbnz	r3, 801b0c6 <CST_polling_timer_mngt+0x1e>
      CST_polling_on_going = true;
 801b0b6:	4c19      	ldr	r4, [pc, #100]	; (801b11c <CST_polling_timer_mngt+0x74>)
 801b0b8:	2301      	movs	r3, #1
 801b0ba:	7023      	strb	r3, [r4, #0]
      (void)CST_set_signal_quality();
 801b0bc:	f002 ff72 	bl	801dfa4 <CST_set_signal_quality>
      CST_polling_on_going = false;
 801b0c0:	2300      	movs	r3, #0
 801b0c2:	7023      	strb	r3, [r4, #0]
 801b0c4:	e026      	b.n	801b114 <CST_polling_timer_mngt+0x6c>
      PRINT_CELLULAR_SERVICE("Discard pooling timer, another one is already on going\n\r")
 801b0c6:	4d16      	ldr	r5, [pc, #88]	; (801b120 <CST_polling_timer_mngt+0x78>)
 801b0c8:	4c16      	ldr	r4, [pc, #88]	; (801b124 <CST_polling_timer_mngt+0x7c>)
 801b0ca:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801b0ce:	46ac      	mov	ip, r5
 801b0d0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b0d4:	6020      	str	r0, [r4, #0]
 801b0d6:	6061      	str	r1, [r4, #4]
 801b0d8:	60a2      	str	r2, [r4, #8]
 801b0da:	60e3      	str	r3, [r4, #12]
 801b0dc:	4665      	mov	r5, ip
 801b0de:	3410      	adds	r4, #16
 801b0e0:	45f4      	cmp	ip, lr
 801b0e2:	d1f4      	bne.n	801b0ce <CST_polling_timer_mngt+0x26>
 801b0e4:	cd03      	ldmia	r5!, {r0, r1}
 801b0e6:	6020      	str	r0, [r4, #0]
 801b0e8:	6061      	str	r1, [r4, #4]
 801b0ea:	782b      	ldrb	r3, [r5, #0]
 801b0ec:	7223      	strb	r3, [r4, #8]
 801b0ee:	4c0d      	ldr	r4, [pc, #52]	; (801b124 <CST_polling_timer_mngt+0x7c>)
 801b0f0:	4620      	mov	r0, r4
 801b0f2:	f004 f91a 	bl	801f32a <crs_strlen>
 801b0f6:	b283      	uxth	r3, r0
 801b0f8:	4622      	mov	r2, r4
 801b0fa:	2101      	movs	r1, #1
 801b0fc:	2007      	movs	r0, #7
 801b0fe:	f004 f957 	bl	801f3b0 <traceIF_itmPrint>
 801b102:	4620      	mov	r0, r4
 801b104:	f004 f911 	bl	801f32a <crs_strlen>
 801b108:	b283      	uxth	r3, r0
 801b10a:	4622      	mov	r2, r4
 801b10c:	2101      	movs	r1, #1
 801b10e:	2007      	movs	r0, #7
 801b110:	f004 f970 	bl	801f3f4 <traceIF_uartPrint>
}
 801b114:	bd38      	pop	{r3, r4, r5, pc}
 801b116:	bf00      	nop
 801b118:	20003fac 	.word	0x20003fac
 801b11c:	20003fad 	.word	0x20003fad
 801b120:	080347c0 	.word	0x080347c0
 801b124:	20004ddc 	.word	0x20004ddc

0801b128 <CST_fota_end_event_mngt>:
{
 801b128:	b570      	push	{r4, r5, r6, lr}
  (void)rtosalTimerStop(cst_fota_timer_handle);
 801b12a:	4b29      	ldr	r3, [pc, #164]	; (801b1d0 <CST_fota_end_event_mngt+0xa8>)
 801b12c:	6818      	ldr	r0, [r3, #0]
 801b12e:	f004 f850 	bl	801f1d2 <rtosalTimerStop>
  PRINT_CELLULAR_SERVICE("Modem event received:  CS_MDMEVENT_FOTA_END\n\r")
 801b132:	4c28      	ldr	r4, [pc, #160]	; (801b1d4 <CST_fota_end_event_mngt+0xac>)
 801b134:	4d28      	ldr	r5, [pc, #160]	; (801b1d8 <CST_fota_end_event_mngt+0xb0>)
 801b136:	f104 0620 	add.w	r6, r4, #32
 801b13a:	46a4      	mov	ip, r4
 801b13c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b140:	6028      	str	r0, [r5, #0]
 801b142:	6069      	str	r1, [r5, #4]
 801b144:	60aa      	str	r2, [r5, #8]
 801b146:	60eb      	str	r3, [r5, #12]
 801b148:	4664      	mov	r4, ip
 801b14a:	3510      	adds	r5, #16
 801b14c:	45b4      	cmp	ip, r6
 801b14e:	d1f4      	bne.n	801b13a <CST_fota_end_event_mngt+0x12>
 801b150:	cc07      	ldmia	r4!, {r0, r1, r2}
 801b152:	6028      	str	r0, [r5, #0]
 801b154:	6069      	str	r1, [r5, #4]
 801b156:	60aa      	str	r2, [r5, #8]
 801b158:	8823      	ldrh	r3, [r4, #0]
 801b15a:	81ab      	strh	r3, [r5, #12]
 801b15c:	4c1e      	ldr	r4, [pc, #120]	; (801b1d8 <CST_fota_end_event_mngt+0xb0>)
 801b15e:	4620      	mov	r0, r4
 801b160:	f004 f8e3 	bl	801f32a <crs_strlen>
 801b164:	b283      	uxth	r3, r0
 801b166:	4622      	mov	r2, r4
 801b168:	2101      	movs	r1, #1
 801b16a:	2007      	movs	r0, #7
 801b16c:	f004 f920 	bl	801f3b0 <traceIF_itmPrint>
 801b170:	4620      	mov	r0, r4
 801b172:	f004 f8da 	bl	801f32a <crs_strlen>
 801b176:	b283      	uxth	r3, r0
 801b178:	4622      	mov	r2, r4
 801b17a:	2101      	movs	r1, #1
 801b17c:	2007      	movs	r0, #7
 801b17e:	f004 f939 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_CELLULAR_SERVICE("TRIGGER PLATFORM REBOOT AFTER FOTA UPDATE ...\n\r")
 801b182:	4e16      	ldr	r6, [pc, #88]	; (801b1dc <CST_fota_end_event_mngt+0xb4>)
 801b184:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801b188:	4635      	mov	r5, r6
 801b18a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801b18c:	6020      	str	r0, [r4, #0]
 801b18e:	6061      	str	r1, [r4, #4]
 801b190:	60a2      	str	r2, [r4, #8]
 801b192:	60e3      	str	r3, [r4, #12]
 801b194:	462e      	mov	r6, r5
 801b196:	3410      	adds	r4, #16
 801b198:	4565      	cmp	r5, ip
 801b19a:	d1f5      	bne.n	801b188 <CST_fota_end_event_mngt+0x60>
 801b19c:	4c0e      	ldr	r4, [pc, #56]	; (801b1d8 <CST_fota_end_event_mngt+0xb0>)
 801b19e:	4620      	mov	r0, r4
 801b1a0:	f004 f8c3 	bl	801f32a <crs_strlen>
 801b1a4:	b283      	uxth	r3, r0
 801b1a6:	4622      	mov	r2, r4
 801b1a8:	2101      	movs	r1, #1
 801b1aa:	2007      	movs	r0, #7
 801b1ac:	f004 f900 	bl	801f3b0 <traceIF_itmPrint>
 801b1b0:	4620      	mov	r0, r4
 801b1b2:	f004 f8ba 	bl	801f32a <crs_strlen>
 801b1b6:	b283      	uxth	r3, r0
 801b1b8:	4622      	mov	r2, r4
 801b1ba:	2101      	movs	r1, #1
 801b1bc:	2007      	movs	r0, #7
 801b1be:	f004 f919 	bl	801f3f4 <traceIF_uartPrint>
  ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 3, ERROR_FATAL);
 801b1c2:	2203      	movs	r2, #3
 801b1c4:	4611      	mov	r1, r2
 801b1c6:	2007      	movs	r0, #7
 801b1c8:	f003 f8cc 	bl	801e364 <ERROR_Handler>
}
 801b1cc:	bd70      	pop	{r4, r5, r6, pc}
 801b1ce:	bf00      	nop
 801b1d0:	20004304 	.word	0x20004304
 801b1d4:	080347fc 	.word	0x080347fc
 801b1d8:	20004ddc 	.word	0x20004ddc
 801b1dc:	0803482c 	.word	0x0803482c

0801b1e0 <CST_modem_reprog_state>:
  * @brief  FOTA state : modem formware update on going
  * @param  autom_event - automaton event
  * @retval -
  */
static void CST_modem_reprog_state(cst_autom_event_t autom_event)
{
 801b1e0:	b508      	push	{r3, lr}
#if (USE_LOW_POWER == 1)
  (void)rtosalTimerStop(cst_lp_inactivity_timer_handle);
#endif /* (USE_LOW_POWER == 1) */
  switch (autom_event)
 801b1e2:	2816      	cmp	r0, #22
 801b1e4:	d004      	beq.n	801b1f0 <CST_modem_reprog_state+0x10>
 801b1e6:	2817      	cmp	r0, #23
 801b1e8:	d005      	beq.n	801b1f6 <CST_modem_reprog_state+0x16>
 801b1ea:	2811      	cmp	r0, #17
 801b1ec:	d006      	beq.n	801b1fc <CST_modem_reprog_state+0x1c>

    default:
      /* Nothing to do */
      break;
  }
}
 801b1ee:	bd08      	pop	{r3, pc}
      CST_fota_end_event_mngt();
 801b1f0:	f7ff ff9a 	bl	801b128 <CST_fota_end_event_mngt>
      break;
 801b1f4:	e7fb      	b.n	801b1ee <CST_modem_reprog_state+0xe>
      CST_fota_timeout_event_mngt();
 801b1f6:	f7ff fe3d 	bl	801ae74 <CST_fota_timeout_event_mngt>
      break;
 801b1fa:	e7f8      	b.n	801b1ee <CST_modem_reprog_state+0xe>
      __NOP();
 801b1fc:	bf00      	nop
}
 801b1fe:	e7f6      	b.n	801b1ee <CST_modem_reprog_state+0xe>

0801b200 <CST_send_message>:
{
 801b200:	b538      	push	{r3, r4, r5, lr}
  SET_AUTOMATON_MSG_ID(cmd_message, event);
 801b202:	ea40 4401 	orr.w	r4, r0, r1, lsl #16
  if (rtosalMessageQueuePut((osMessageQId)cst_queue_id, cmd_message, 0U) != osOK)
 801b206:	2200      	movs	r2, #0
 801b208:	4621      	mov	r1, r4
 801b20a:	4b0f      	ldr	r3, [pc, #60]	; (801b248 <CST_send_message+0x48>)
 801b20c:	6818      	ldr	r0, [r3, #0]
 801b20e:	f003 ffba 	bl	801f186 <rtosalMessageQueuePut>
 801b212:	b900      	cbnz	r0, 801b216 <CST_send_message+0x16>
}
 801b214:	bd38      	pop	{r3, r4, r5, pc}
    PRINT_CELLULAR_SERVICE_ERR("CST queue msg %ld can NOT be added. (Queue full ?)\n\r", cmd_message)
 801b216:	4d0d      	ldr	r5, [pc, #52]	; (801b24c <CST_send_message+0x4c>)
 801b218:	4622      	mov	r2, r4
 801b21a:	490d      	ldr	r1, [pc, #52]	; (801b250 <CST_send_message+0x50>)
 801b21c:	4628      	mov	r0, r5
 801b21e:	f00b fb13 	bl	8026848 <sprintf>
 801b222:	4628      	mov	r0, r5
 801b224:	f004 f881 	bl	801f32a <crs_strlen>
 801b228:	b283      	uxth	r3, r0
 801b22a:	462a      	mov	r2, r5
 801b22c:	2110      	movs	r1, #16
 801b22e:	2007      	movs	r0, #7
 801b230:	f004 f8be 	bl	801f3b0 <traceIF_itmPrint>
 801b234:	4628      	mov	r0, r5
 801b236:	f004 f878 	bl	801f32a <crs_strlen>
 801b23a:	b283      	uxth	r3, r0
 801b23c:	462a      	mov	r2, r5
 801b23e:	2110      	movs	r1, #16
 801b240:	2007      	movs	r0, #7
 801b242:	f004 f8d7 	bl	801f3f4 <traceIF_uartPrint>
}
 801b246:	e7e5      	b.n	801b214 <CST_send_message+0x14>
 801b248:	20004330 	.word	0x20004330
 801b24c:	20004ddc 	.word	0x20004ddc
 801b250:	0803485c 	.word	0x0803485c

0801b254 <CST_fota_timer_callback>:
{
 801b254:	b508      	push	{r3, lr}
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_FOTA_TIMEOUT_EVENT);
 801b256:	2117      	movs	r1, #23
 801b258:	2000      	movs	r0, #0
 801b25a:	f7ff ffd1 	bl	801b200 <CST_send_message>
}
 801b25e:	bd08      	pop	{r3, pc}

0801b260 <CST_network_status_timer_callback>:
{
 801b260:	b508      	push	{r3, lr}
  if (cst_context.current_state == CST_WAITING_FOR_NETWORK_STATUS_STATE)
 801b262:	4b05      	ldr	r3, [pc, #20]	; (801b278 <CST_network_status_timer_callback+0x18>)
 801b264:	881b      	ldrh	r3, [r3, #0]
 801b266:	2b04      	cmp	r3, #4
 801b268:	d000      	beq.n	801b26c <CST_network_status_timer_callback+0xc>
}
 801b26a:	bd08      	pop	{r3, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NW_REG_TIMEOUT_TIMER_EVENT);
 801b26c:	2114      	movs	r1, #20
 801b26e:	2000      	movs	r0, #0
 801b270:	f7ff ffc6 	bl	801b200 <CST_send_message>
}
 801b274:	e7f9      	b.n	801b26a <CST_network_status_timer_callback+0xa>
 801b276:	bf00      	nop
 801b278:	200000b0 	.word	0x200000b0

0801b27c <CST_pdn_activate_retry_timer_callback>:
{
 801b27c:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_pdn_activate_retry_timer_callback ********\n\r")
 801b27e:	4c19      	ldr	r4, [pc, #100]	; (801b2e4 <CST_pdn_activate_retry_timer_callback+0x68>)
 801b280:	4d19      	ldr	r5, [pc, #100]	; (801b2e8 <CST_pdn_activate_retry_timer_callback+0x6c>)
 801b282:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801b286:	46a4      	mov	ip, r4
 801b288:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b28c:	6028      	str	r0, [r5, #0]
 801b28e:	6069      	str	r1, [r5, #4]
 801b290:	60aa      	str	r2, [r5, #8]
 801b292:	60eb      	str	r3, [r5, #12]
 801b294:	4664      	mov	r4, ip
 801b296:	3510      	adds	r5, #16
 801b298:	45f4      	cmp	ip, lr
 801b29a:	d1f4      	bne.n	801b286 <CST_pdn_activate_retry_timer_callback+0xa>
 801b29c:	cc07      	ldmia	r4!, {r0, r1, r2}
 801b29e:	6028      	str	r0, [r5, #0]
 801b2a0:	6069      	str	r1, [r5, #4]
 801b2a2:	60aa      	str	r2, [r5, #8]
 801b2a4:	7823      	ldrb	r3, [r4, #0]
 801b2a6:	732b      	strb	r3, [r5, #12]
 801b2a8:	4c0f      	ldr	r4, [pc, #60]	; (801b2e8 <CST_pdn_activate_retry_timer_callback+0x6c>)
 801b2aa:	4620      	mov	r0, r4
 801b2ac:	f004 f83d 	bl	801f32a <crs_strlen>
 801b2b0:	b283      	uxth	r3, r0
 801b2b2:	4622      	mov	r2, r4
 801b2b4:	2101      	movs	r1, #1
 801b2b6:	2007      	movs	r0, #7
 801b2b8:	f004 f87a 	bl	801f3b0 <traceIF_itmPrint>
 801b2bc:	4620      	mov	r0, r4
 801b2be:	f004 f834 	bl	801f32a <crs_strlen>
 801b2c2:	b283      	uxth	r3, r0
 801b2c4:	4622      	mov	r2, r4
 801b2c6:	2101      	movs	r1, #1
 801b2c8:	2007      	movs	r0, #7
 801b2ca:	f004 f893 	bl	801f3f4 <traceIF_uartPrint>
  if (cst_context.current_state == CST_MODEM_PDN_ACTIVATING_STATE)
 801b2ce:	4b07      	ldr	r3, [pc, #28]	; (801b2ec <CST_pdn_activate_retry_timer_callback+0x70>)
 801b2d0:	881b      	ldrh	r3, [r3, #0]
 801b2d2:	2b07      	cmp	r3, #7
 801b2d4:	d000      	beq.n	801b2d8 <CST_pdn_activate_retry_timer_callback+0x5c>
}
 801b2d6:	bd38      	pop	{r3, r4, r5, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_PDN_ACTIVATE_RETRY_TIMER_EVENT);
 801b2d8:	2109      	movs	r1, #9
 801b2da:	2000      	movs	r0, #0
 801b2dc:	f7ff ff90 	bl	801b200 <CST_send_message>
}
 801b2e0:	e7f9      	b.n	801b2d6 <CST_pdn_activate_retry_timer_callback+0x5a>
 801b2e2:	bf00      	nop
 801b2e4:	08034898 	.word	0x08034898
 801b2e8:	20004ddc 	.word	0x20004ddc
 801b2ec:	200000b0 	.word	0x200000b0

0801b2f0 <CST_polling_timer_callback>:
{
 801b2f0:	b508      	push	{r3, lr}
  if (((cst_context.current_state == CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE)
 801b2f2:	4b0d      	ldr	r3, [pc, #52]	; (801b328 <CST_polling_timer_callback+0x38>)
 801b2f4:	881a      	ldrh	r2, [r3, #0]
       || (cst_context.current_state == CST_WAITING_FOR_NETWORK_STATUS_STATE)
 801b2f6:	1ed3      	subs	r3, r2, #3
 801b2f8:	b29b      	uxth	r3, r3
  if (((cst_context.current_state == CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE)
 801b2fa:	2b01      	cmp	r3, #1
 801b2fc:	d902      	bls.n	801b304 <CST_polling_timer_callback+0x14>
       || (cst_context.current_state == CST_MODEM_DATA_READY_STATE))
 801b2fe:	2a08      	cmp	r2, #8
 801b300:	d000      	beq.n	801b304 <CST_polling_timer_callback+0x14>
}
 801b302:	bd08      	pop	{r3, pc}
      && (cst_nfmc_context.nfmc_timer_on_going == false)
 801b304:	4b09      	ldr	r3, [pc, #36]	; (801b32c <CST_polling_timer_callback+0x3c>)
 801b306:	785b      	ldrb	r3, [r3, #1]
 801b308:	2b00      	cmp	r3, #0
 801b30a:	d1fa      	bne.n	801b302 <CST_polling_timer_callback+0x12>
      && (CST_polling_active == true)
 801b30c:	4b08      	ldr	r3, [pc, #32]	; (801b330 <CST_polling_timer_callback+0x40>)
 801b30e:	781b      	ldrb	r3, [r3, #0]
 801b310:	2b00      	cmp	r3, #0
 801b312:	d0f6      	beq.n	801b302 <CST_polling_timer_callback+0x12>
    if (CST_polling_on_going == false)
 801b314:	4b07      	ldr	r3, [pc, #28]	; (801b334 <CST_polling_timer_callback+0x44>)
 801b316:	781b      	ldrb	r3, [r3, #0]
 801b318:	2b00      	cmp	r3, #0
 801b31a:	d1f2      	bne.n	801b302 <CST_polling_timer_callback+0x12>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_POLLING_TIMER_EVENT);
 801b31c:	210b      	movs	r1, #11
 801b31e:	2000      	movs	r0, #0
 801b320:	f7ff ff6e 	bl	801b200 <CST_send_message>
}
 801b324:	e7ed      	b.n	801b302 <CST_polling_timer_callback+0x12>
 801b326:	bf00      	nop
 801b328:	200000b0 	.word	0x200000b0
 801b32c:	2000430c 	.word	0x2000430c
 801b330:	20003fac 	.word	0x20003fac
 801b334:	20003fad 	.word	0x20003fad

0801b338 <CST_pdn_event_callback>:
{
 801b338:	b538      	push	{r3, r4, r5, lr}
 801b33a:	4602      	mov	r2, r0
 801b33c:	460d      	mov	r5, r1
  PRINT_CELLULAR_SERVICE("====================================CST_pdn_event_callback (cid=%d / event=%d)\n\r",
 801b33e:	4c0f      	ldr	r4, [pc, #60]	; (801b37c <CST_pdn_event_callback+0x44>)
 801b340:	460b      	mov	r3, r1
 801b342:	490f      	ldr	r1, [pc, #60]	; (801b380 <CST_pdn_event_callback+0x48>)
 801b344:	4620      	mov	r0, r4
 801b346:	f00b fa7f 	bl	8026848 <sprintf>
 801b34a:	4620      	mov	r0, r4
 801b34c:	f003 ffed 	bl	801f32a <crs_strlen>
 801b350:	b283      	uxth	r3, r0
 801b352:	4622      	mov	r2, r4
 801b354:	2101      	movs	r1, #1
 801b356:	2007      	movs	r0, #7
 801b358:	f004 f82a 	bl	801f3b0 <traceIF_itmPrint>
 801b35c:	4620      	mov	r0, r4
 801b35e:	f003 ffe4 	bl	801f32a <crs_strlen>
 801b362:	b283      	uxth	r3, r0
 801b364:	4622      	mov	r2, r4
 801b366:	2101      	movs	r1, #1
 801b368:	2007      	movs	r0, #7
 801b36a:	f004 f843 	bl	801f3f4 <traceIF_uartPrint>
  cst_context.pdn_status = pdn_event;
 801b36e:	4b05      	ldr	r3, [pc, #20]	; (801b384 <CST_pdn_event_callback+0x4c>)
 801b370:	70dd      	strb	r5, [r3, #3]
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_PDN_STATUS_TO_CHECK_EVENT);
 801b372:	2108      	movs	r1, #8
 801b374:	2000      	movs	r0, #0
 801b376:	f7ff ff43 	bl	801b200 <CST_send_message>
}
 801b37a:	bd38      	pop	{r3, r4, r5, pc}
 801b37c:	20004ddc 	.word	0x20004ddc
 801b380:	080348d8 	.word	0x080348d8
 801b384:	200000b0 	.word	0x200000b0

0801b388 <CST_set_state>:
  * @brief  sets new automaton state
  * @param  new_state - new current automaton state to set
  * @retval -
  */
void CST_set_state(CST_autom_state_t new_state)
{
 801b388:	b510      	push	{r4, lr}
  cst_context.current_state = new_state;
 801b38a:	4b0e      	ldr	r3, [pc, #56]	; (801b3c4 <CST_set_state+0x3c>)
 801b38c:	8018      	strh	r0, [r3, #0]
  PRINT_CELLULAR_SERVICE("-----> New State: %s <-----\n\r", CST_StateName[new_state])
 801b38e:	4c0e      	ldr	r4, [pc, #56]	; (801b3c8 <CST_set_state+0x40>)
 801b390:	4b0e      	ldr	r3, [pc, #56]	; (801b3cc <CST_set_state+0x44>)
 801b392:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 801b396:	490e      	ldr	r1, [pc, #56]	; (801b3d0 <CST_set_state+0x48>)
 801b398:	4620      	mov	r0, r4
 801b39a:	f00b fa55 	bl	8026848 <sprintf>
 801b39e:	4620      	mov	r0, r4
 801b3a0:	f003 ffc3 	bl	801f32a <crs_strlen>
 801b3a4:	b283      	uxth	r3, r0
 801b3a6:	4622      	mov	r2, r4
 801b3a8:	2101      	movs	r1, #1
 801b3aa:	2007      	movs	r0, #7
 801b3ac:	f004 f800 	bl	801f3b0 <traceIF_itmPrint>
 801b3b0:	4620      	mov	r0, r4
 801b3b2:	f003 ffba 	bl	801f32a <crs_strlen>
 801b3b6:	b283      	uxth	r3, r0
 801b3b8:	4622      	mov	r2, r4
 801b3ba:	2101      	movs	r1, #1
 801b3bc:	2007      	movs	r0, #7
 801b3be:	f004 f819 	bl	801f3f4 <traceIF_uartPrint>

#if (USE_CELLULAR_SERVICE_TASK_TEST == 1)
  /* instrumentation code to test automaton */
  CSTE_cellular_service_task_test(cst_context.current_state);
#endif  /* (USE_CELLULAR_SERVICE_TASK_TEST == 1) */
}
 801b3c2:	bd10      	pop	{r4, pc}
 801b3c4:	200000b0 	.word	0x200000b0
 801b3c8:	20004ddc 	.word	0x20004ddc
 801b3cc:	20000064 	.word	0x20000064
 801b3d0:	0803492c 	.word	0x0803492c

0801b3d4 <CST_register_retry_timer_callback>:
{
 801b3d4:	b510      	push	{r4, lr}
  cst_nfmc_context.nfmc_timer_on_going = false;
 801b3d6:	2400      	movs	r4, #0
 801b3d8:	4b04      	ldr	r3, [pc, #16]	; (801b3ec <CST_register_retry_timer_callback+0x18>)
 801b3da:	705c      	strb	r4, [r3, #1]
  CST_set_state(CST_MODEM_INIT_STATE);
 801b3dc:	2001      	movs	r0, #1
 801b3de:	f7ff ffd3 	bl	801b388 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b3e2:	2101      	movs	r1, #1
 801b3e4:	4620      	mov	r0, r4
 801b3e6:	f7ff ff0b 	bl	801b200 <CST_send_message>
}
 801b3ea:	bd10      	pop	{r4, pc}
 801b3ec:	2000430c 	.word	0x2000430c

0801b3f0 <CST_boot_event_mngt>:
{
 801b3f0:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_boot_event_mngt ********\n\r")
 801b3f2:	4c18      	ldr	r4, [pc, #96]	; (801b454 <CST_boot_event_mngt+0x64>)
 801b3f4:	4d18      	ldr	r5, [pc, #96]	; (801b458 <CST_boot_event_mngt+0x68>)
 801b3f6:	f104 0e20 	add.w	lr, r4, #32
 801b3fa:	46a4      	mov	ip, r4
 801b3fc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b400:	6028      	str	r0, [r5, #0]
 801b402:	6069      	str	r1, [r5, #4]
 801b404:	60aa      	str	r2, [r5, #8]
 801b406:	60eb      	str	r3, [r5, #12]
 801b408:	4664      	mov	r4, ip
 801b40a:	3510      	adds	r5, #16
 801b40c:	45f4      	cmp	ip, lr
 801b40e:	d1f4      	bne.n	801b3fa <CST_boot_event_mngt+0xa>
 801b410:	cc03      	ldmia	r4!, {r0, r1}
 801b412:	6028      	str	r0, [r5, #0]
 801b414:	6069      	str	r1, [r5, #4]
 801b416:	8822      	ldrh	r2, [r4, #0]
 801b418:	78a3      	ldrb	r3, [r4, #2]
 801b41a:	812a      	strh	r2, [r5, #8]
 801b41c:	72ab      	strb	r3, [r5, #10]
 801b41e:	4c0e      	ldr	r4, [pc, #56]	; (801b458 <CST_boot_event_mngt+0x68>)
 801b420:	4620      	mov	r0, r4
 801b422:	f003 ff82 	bl	801f32a <crs_strlen>
 801b426:	b283      	uxth	r3, r0
 801b428:	4622      	mov	r2, r4
 801b42a:	2101      	movs	r1, #1
 801b42c:	2007      	movs	r0, #7
 801b42e:	f003 ffbf 	bl	801f3b0 <traceIF_itmPrint>
 801b432:	4620      	mov	r0, r4
 801b434:	f003 ff79 	bl	801f32a <crs_strlen>
 801b438:	b283      	uxth	r3, r0
 801b43a:	4622      	mov	r2, r4
 801b43c:	2101      	movs	r1, #1
 801b43e:	2007      	movs	r0, #7
 801b440:	f003 ffd8 	bl	801f3f4 <traceIF_uartPrint>
  CST_set_state(CST_MODEM_INIT_STATE);
 801b444:	2001      	movs	r0, #1
 801b446:	f7ff ff9f 	bl	801b388 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b44a:	2101      	movs	r1, #1
 801b44c:	2000      	movs	r0, #0
 801b44e:	f7ff fed7 	bl	801b200 <CST_send_message>
}
 801b452:	bd38      	pop	{r3, r4, r5, pc}
 801b454:	0803494c 	.word	0x0803494c
 801b458:	20004ddc 	.word	0x20004ddc

0801b45c <CST_reboot_modem_event_mngt>:
{
 801b45c:	b538      	push	{r3, r4, r5, lr}
  if (cst_context.current_state != CST_MODEM_INIT_STATE)
 801b45e:	4b1d      	ldr	r3, [pc, #116]	; (801b4d4 <CST_reboot_modem_event_mngt+0x78>)
 801b460:	881b      	ldrh	r3, [r3, #0]
 801b462:	2b01      	cmp	r3, #1
 801b464:	d100      	bne.n	801b468 <CST_reboot_modem_event_mngt+0xc>
}
 801b466:	bd38      	pop	{r3, r4, r5, pc}
    (void)osCDS_power_off();
 801b468:	f7ff fc06 	bl	801ac78 <osCDS_power_off>
    PRINT_CELLULAR_SERVICE("Modem event received: CS_MDMEVENT_BOOT\n\r")
 801b46c:	4c1a      	ldr	r4, [pc, #104]	; (801b4d8 <CST_reboot_modem_event_mngt+0x7c>)
 801b46e:	4d1b      	ldr	r5, [pc, #108]	; (801b4dc <CST_reboot_modem_event_mngt+0x80>)
 801b470:	f104 0e20 	add.w	lr, r4, #32
 801b474:	46a4      	mov	ip, r4
 801b476:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b47a:	6028      	str	r0, [r5, #0]
 801b47c:	6069      	str	r1, [r5, #4]
 801b47e:	60aa      	str	r2, [r5, #8]
 801b480:	60eb      	str	r3, [r5, #12]
 801b482:	4664      	mov	r4, ip
 801b484:	3510      	adds	r5, #16
 801b486:	45f4      	cmp	ip, lr
 801b488:	d1f4      	bne.n	801b474 <CST_reboot_modem_event_mngt+0x18>
 801b48a:	cc03      	ldmia	r4!, {r0, r1}
 801b48c:	6028      	str	r0, [r5, #0]
 801b48e:	6069      	str	r1, [r5, #4]
 801b490:	7823      	ldrb	r3, [r4, #0]
 801b492:	722b      	strb	r3, [r5, #8]
 801b494:	4c11      	ldr	r4, [pc, #68]	; (801b4dc <CST_reboot_modem_event_mngt+0x80>)
 801b496:	4620      	mov	r0, r4
 801b498:	f003 ff47 	bl	801f32a <crs_strlen>
 801b49c:	b283      	uxth	r3, r0
 801b49e:	4622      	mov	r2, r4
 801b4a0:	2101      	movs	r1, #1
 801b4a2:	2007      	movs	r0, #7
 801b4a4:	f003 ff84 	bl	801f3b0 <traceIF_itmPrint>
 801b4a8:	4620      	mov	r0, r4
 801b4aa:	f003 ff3e 	bl	801f32a <crs_strlen>
 801b4ae:	b283      	uxth	r3, r0
 801b4b0:	4622      	mov	r2, r4
 801b4b2:	2101      	movs	r1, #1
 801b4b4:	2007      	movs	r0, #7
 801b4b6:	f003 ff9d 	bl	801f3f4 <traceIF_uartPrint>
    CST_set_state(CST_MODEM_INIT_STATE);
 801b4ba:	2001      	movs	r0, #1
 801b4bc:	f7ff ff64 	bl	801b388 <CST_set_state>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801b4c0:	2100      	movs	r1, #0
 801b4c2:	2003      	movs	r0, #3
 801b4c4:	f002 f892 	bl	801d5ec <CST_data_cache_cellular_info_set>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b4c8:	2101      	movs	r1, #1
 801b4ca:	2000      	movs	r0, #0
 801b4cc:	f7ff fe98 	bl	801b200 <CST_send_message>
}
 801b4d0:	e7c9      	b.n	801b466 <CST_reboot_modem_event_mngt+0xa>
 801b4d2:	bf00      	nop
 801b4d4:	200000b0 	.word	0x200000b0
 801b4d8:	08034978 	.word	0x08034978
 801b4dc:	20004ddc 	.word	0x20004ddc

0801b4e0 <CST_modem_off_state>:
{
 801b4e0:	b508      	push	{r3, lr}
  switch (autom_event)
 801b4e2:	280f      	cmp	r0, #15
 801b4e4:	d004      	beq.n	801b4f0 <CST_modem_off_state+0x10>
 801b4e6:	2811      	cmp	r0, #17
 801b4e8:	d008      	beq.n	801b4fc <CST_modem_off_state+0x1c>
 801b4ea:	2801      	cmp	r0, #1
 801b4ec:	d003      	beq.n	801b4f6 <CST_modem_off_state+0x16>
}
 801b4ee:	bd08      	pop	{r3, pc}
      CST_off_state_target_cmd_state_mngt();
 801b4f0:	f7ff fd76 	bl	801afe0 <CST_off_state_target_cmd_state_mngt>
      break;
 801b4f4:	e7fb      	b.n	801b4ee <CST_modem_off_state+0xe>
      CST_modem_off_mngt();
 801b4f6:	f7ff fcef 	bl	801aed8 <CST_modem_off_mngt>
      break;
 801b4fa:	e7f8      	b.n	801b4ee <CST_modem_off_state+0xe>
      CST_reboot_modem_event_mngt();
 801b4fc:	f7ff ffae 	bl	801b45c <CST_reboot_modem_event_mngt>
}
 801b500:	e7f5      	b.n	801b4ee <CST_modem_off_state+0xe>

0801b502 <CST_fail_state>:
  switch (autom_event)
 801b502:	2811      	cmp	r0, #17
 801b504:	d000      	beq.n	801b508 <CST_fail_state+0x6>
 801b506:	4770      	bx	lr
{
 801b508:	b508      	push	{r3, lr}
      CST_reboot_modem_event_mngt();
 801b50a:	f7ff ffa7 	bl	801b45c <CST_reboot_modem_event_mngt>
}
 801b50e:	bd08      	pop	{r3, pc}

0801b510 <CST_boot_power_on_only_modem_mngt>:
{
 801b510:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_boot_modem_power_on_only_mngt ********\n\r")
 801b512:	4c17      	ldr	r4, [pc, #92]	; (801b570 <CST_boot_power_on_only_modem_mngt+0x60>)
 801b514:	4d17      	ldr	r5, [pc, #92]	; (801b574 <CST_boot_power_on_only_modem_mngt+0x64>)
 801b516:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801b51a:	46a4      	mov	ip, r4
 801b51c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b520:	6028      	str	r0, [r5, #0]
 801b522:	6069      	str	r1, [r5, #4]
 801b524:	60aa      	str	r2, [r5, #8]
 801b526:	60eb      	str	r3, [r5, #12]
 801b528:	4664      	mov	r4, ip
 801b52a:	3510      	adds	r5, #16
 801b52c:	45f4      	cmp	ip, lr
 801b52e:	d1f4      	bne.n	801b51a <CST_boot_power_on_only_modem_mngt+0xa>
 801b530:	cc03      	ldmia	r4!, {r0, r1}
 801b532:	6028      	str	r0, [r5, #0]
 801b534:	6069      	str	r1, [r5, #4]
 801b536:	7823      	ldrb	r3, [r4, #0]
 801b538:	722b      	strb	r3, [r5, #8]
 801b53a:	4c0e      	ldr	r4, [pc, #56]	; (801b574 <CST_boot_power_on_only_modem_mngt+0x64>)
 801b53c:	4620      	mov	r0, r4
 801b53e:	f003 fef4 	bl	801f32a <crs_strlen>
 801b542:	b283      	uxth	r3, r0
 801b544:	4622      	mov	r2, r4
 801b546:	2101      	movs	r1, #1
 801b548:	2007      	movs	r0, #7
 801b54a:	f003 ff31 	bl	801f3b0 <traceIF_itmPrint>
 801b54e:	4620      	mov	r0, r4
 801b550:	f003 feeb 	bl	801f32a <crs_strlen>
 801b554:	b283      	uxth	r3, r0
 801b556:	4622      	mov	r2, r4
 801b558:	2101      	movs	r1, #1
 801b55a:	2007      	movs	r0, #7
 801b55c:	f003 ff4a 	bl	801f3f4 <traceIF_uartPrint>
  CST_set_state(CST_MODEM_INIT_STATE);
 801b560:	2001      	movs	r0, #1
 801b562:	f7ff ff11 	bl	801b388 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_POWER_ON_ONLY_EVENT);
 801b566:	2112      	movs	r1, #18
 801b568:	2000      	movs	r0, #0
 801b56a:	f7ff fe49 	bl	801b200 <CST_send_message>
}
 801b56e:	bd38      	pop	{r3, r4, r5, pc}
 801b570:	080349a4 	.word	0x080349a4
 801b574:	20004ddc 	.word	0x20004ddc

0801b578 <CST_boot_state>:
{
 801b578:	b508      	push	{r3, lr}
  switch (autom_event)
 801b57a:	2811      	cmp	r0, #17
 801b57c:	d006      	beq.n	801b58c <CST_boot_state+0x14>
 801b57e:	2812      	cmp	r0, #18
 801b580:	d007      	beq.n	801b592 <CST_boot_state+0x1a>
 801b582:	b100      	cbz	r0, 801b586 <CST_boot_state+0xe>
}
 801b584:	bd08      	pop	{r3, pc}
      CST_boot_event_mngt();
 801b586:	f7ff ff33 	bl	801b3f0 <CST_boot_event_mngt>
      break;
 801b58a:	e7fb      	b.n	801b584 <CST_boot_state+0xc>
      CST_reboot_modem_event_mngt();
 801b58c:	f7ff ff66 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801b590:	e7f8      	b.n	801b584 <CST_boot_state+0xc>
      CST_boot_power_on_only_modem_mngt();
 801b592:	f7ff ffbd 	bl	801b510 <CST_boot_power_on_only_modem_mngt>
}
 801b596:	e7f5      	b.n	801b584 <CST_boot_state+0xc>

0801b598 <CST_init_state_mngt>:
{
 801b598:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_init_state_mngt ********\n\r")
 801b59a:	4c33      	ldr	r4, [pc, #204]	; (801b668 <CST_init_state_mngt+0xd0>)
 801b59c:	4d33      	ldr	r5, [pc, #204]	; (801b66c <CST_init_state_mngt+0xd4>)
 801b59e:	f104 0e20 	add.w	lr, r4, #32
 801b5a2:	46a4      	mov	ip, r4
 801b5a4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b5a8:	6028      	str	r0, [r5, #0]
 801b5aa:	6069      	str	r1, [r5, #4]
 801b5ac:	60aa      	str	r2, [r5, #8]
 801b5ae:	60eb      	str	r3, [r5, #12]
 801b5b0:	4664      	mov	r4, ip
 801b5b2:	3510      	adds	r5, #16
 801b5b4:	45f4      	cmp	ip, lr
 801b5b6:	d1f4      	bne.n	801b5a2 <CST_init_state_mngt+0xa>
 801b5b8:	cc03      	ldmia	r4!, {r0, r1}
 801b5ba:	6028      	str	r0, [r5, #0]
 801b5bc:	6069      	str	r1, [r5, #4]
 801b5be:	8822      	ldrh	r2, [r4, #0]
 801b5c0:	78a3      	ldrb	r3, [r4, #2]
 801b5c2:	812a      	strh	r2, [r5, #8]
 801b5c4:	72ab      	strb	r3, [r5, #10]
 801b5c6:	4c29      	ldr	r4, [pc, #164]	; (801b66c <CST_init_state_mngt+0xd4>)
 801b5c8:	4620      	mov	r0, r4
 801b5ca:	f003 feae 	bl	801f32a <crs_strlen>
 801b5ce:	b283      	uxth	r3, r0
 801b5d0:	4622      	mov	r2, r4
 801b5d2:	2101      	movs	r1, #1
 801b5d4:	2007      	movs	r0, #7
 801b5d6:	f003 feeb 	bl	801f3b0 <traceIF_itmPrint>
 801b5da:	4620      	mov	r0, r4
 801b5dc:	f003 fea5 	bl	801f32a <crs_strlen>
 801b5e0:	b283      	uxth	r3, r0
 801b5e2:	4622      	mov	r2, r4
 801b5e4:	2101      	movs	r1, #1
 801b5e6:	2007      	movs	r0, #7
 801b5e8:	f003 ff04 	bl	801f3f4 <traceIF_uartPrint>
  if (cst_cellular_params.target_state == DC_TARGET_STATE_OFF)
 801b5ec:	4b20      	ldr	r3, [pc, #128]	; (801b670 <CST_init_state_mngt+0xd8>)
 801b5ee:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b5f2:	b11b      	cbz	r3, 801b5fc <CST_init_state_mngt+0x64>
    if (cst_nfmc_context.nfmc_timer_on_going == false)
 801b5f4:	4b1f      	ldr	r3, [pc, #124]	; (801b674 <CST_init_state_mngt+0xdc>)
 801b5f6:	785b      	ldrb	r3, [r3, #1]
 801b5f8:	b1ab      	cbz	r3, 801b626 <CST_init_state_mngt+0x8e>
}
 801b5fa:	bd70      	pop	{r4, r5, r6, pc}
    CST_set_state(CST_MODEM_OFF_STATE);
 801b5fc:	200d      	movs	r0, #13
 801b5fe:	f7ff fec3 	bl	801b388 <CST_set_state>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b602:	4e1d      	ldr	r6, [pc, #116]	; (801b678 <CST_init_state_mngt+0xe0>)
 801b604:	4c1d      	ldr	r4, [pc, #116]	; (801b67c <CST_init_state_mngt+0xe4>)
 801b606:	4d1e      	ldr	r5, [pc, #120]	; (801b680 <CST_init_state_mngt+0xe8>)
 801b608:	23f4      	movs	r3, #244	; 0xf4
 801b60a:	4622      	mov	r2, r4
 801b60c:	8831      	ldrh	r1, [r6, #0]
 801b60e:	4628      	mov	r0, r5
 801b610:	f006 fd8e 	bl	8022130 <dc_com_read>
    cst_cellular_info.modem_state = DC_MODEM_STATE_OFF;
 801b614:	2300      	movs	r3, #0
 801b616:	7263      	strb	r3, [r4, #9]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b618:	23f4      	movs	r3, #244	; 0xf4
 801b61a:	4622      	mov	r2, r4
 801b61c:	8831      	ldrh	r1, [r6, #0]
 801b61e:	4628      	mov	r0, r5
 801b620:	f006 fd3a 	bl	8022098 <dc_com_write>
 801b624:	e7e9      	b.n	801b5fa <CST_init_state_mngt+0x62>
      cs_status = osCDS_power_on();
 801b626:	f7ff fb15 	bl	801ac54 <osCDS_power_on>
      if (cs_status != CELLULAR_OK)
 801b62a:	b130      	cbz	r0, 801b63a <CST_init_state_mngt+0xa2>
        CST_config_fail(((uint8_t *)"CST_cmd"),
 801b62c:	2305      	movs	r3, #5
 801b62e:	4a15      	ldr	r2, [pc, #84]	; (801b684 <CST_init_state_mngt+0xec>)
 801b630:	2101      	movs	r1, #1
 801b632:	4815      	ldr	r0, [pc, #84]	; (801b688 <CST_init_state_mngt+0xf0>)
 801b634:	f002 f81a 	bl	801d66c <CST_config_fail>
 801b638:	e7df      	b.n	801b5fa <CST_init_state_mngt+0x62>
        (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b63a:	4e0f      	ldr	r6, [pc, #60]	; (801b678 <CST_init_state_mngt+0xe0>)
 801b63c:	4c0f      	ldr	r4, [pc, #60]	; (801b67c <CST_init_state_mngt+0xe4>)
 801b63e:	4d10      	ldr	r5, [pc, #64]	; (801b680 <CST_init_state_mngt+0xe8>)
 801b640:	23f4      	movs	r3, #244	; 0xf4
 801b642:	4622      	mov	r2, r4
 801b644:	8831      	ldrh	r1, [r6, #0]
 801b646:	4628      	mov	r0, r5
 801b648:	f006 fd72 	bl	8022130 <dc_com_read>
        cst_cellular_info.rt_state    = DC_SERVICE_RUN;
 801b64c:	2306      	movs	r3, #6
 801b64e:	7223      	strb	r3, [r4, #8]
        cst_cellular_info.modem_state = DC_MODEM_STATE_POWERED_ON;
 801b650:	2301      	movs	r3, #1
 801b652:	7263      	strb	r3, [r4, #9]
        (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b654:	23f4      	movs	r3, #244	; 0xf4
 801b656:	4622      	mov	r2, r4
 801b658:	8831      	ldrh	r1, [r6, #0]
 801b65a:	4628      	mov	r0, r5
 801b65c:	f006 fd1c 	bl	8022098 <dc_com_write>
        CST_modem_sim_init();
 801b660:	f002 f902 	bl	801d868 <CST_modem_sim_init>
}
 801b664:	e7c9      	b.n	801b5fa <CST_init_state_mngt+0x62>
 801b666:	bf00      	nop
 801b668:	0803478c 	.word	0x0803478c
 801b66c:	20004ddc 	.word	0x20004ddc
 801b670:	20004160 	.word	0x20004160
 801b674:	2000430c 	.word	0x2000430c
 801b678:	20000236 	.word	0x20000236
 801b67c:	2000406c 	.word	0x2000406c
 801b680:	200058b0 	.word	0x200058b0
 801b684:	200000c1 	.word	0x200000c1
 801b688:	080347b8 	.word	0x080347b8

0801b68c <CST_init_power_on_only_modem_mngt>:
{
 801b68c:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_power_on_only_modem_mngt ********\n\r")
 801b68e:	4d15      	ldr	r5, [pc, #84]	; (801b6e4 <CST_init_power_on_only_modem_mngt+0x58>)
 801b690:	4c15      	ldr	r4, [pc, #84]	; (801b6e8 <CST_init_power_on_only_modem_mngt+0x5c>)
 801b692:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801b696:	46ac      	mov	ip, r5
 801b698:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b69c:	6020      	str	r0, [r4, #0]
 801b69e:	6061      	str	r1, [r4, #4]
 801b6a0:	60a2      	str	r2, [r4, #8]
 801b6a2:	60e3      	str	r3, [r4, #12]
 801b6a4:	4665      	mov	r5, ip
 801b6a6:	3410      	adds	r4, #16
 801b6a8:	45f4      	cmp	ip, lr
 801b6aa:	d1f4      	bne.n	801b696 <CST_init_power_on_only_modem_mngt+0xa>
 801b6ac:	f8dc 0000 	ldr.w	r0, [ip]
 801b6b0:	6020      	str	r0, [r4, #0]
 801b6b2:	4c0d      	ldr	r4, [pc, #52]	; (801b6e8 <CST_init_power_on_only_modem_mngt+0x5c>)
 801b6b4:	4620      	mov	r0, r4
 801b6b6:	f003 fe38 	bl	801f32a <crs_strlen>
 801b6ba:	b283      	uxth	r3, r0
 801b6bc:	4622      	mov	r2, r4
 801b6be:	2101      	movs	r1, #1
 801b6c0:	2007      	movs	r0, #7
 801b6c2:	f003 fe75 	bl	801f3b0 <traceIF_itmPrint>
 801b6c6:	4620      	mov	r0, r4
 801b6c8:	f003 fe2f 	bl	801f32a <crs_strlen>
 801b6cc:	b283      	uxth	r3, r0
 801b6ce:	4622      	mov	r2, r4
 801b6d0:	2101      	movs	r1, #1
 801b6d2:	2007      	movs	r0, #7
 801b6d4:	f003 fe8e 	bl	801f3f4 <traceIF_uartPrint>
  (void)osCDS_power_on();
 801b6d8:	f7ff fabc 	bl	801ac54 <osCDS_power_on>
  CST_set_state(CST_MODEM_POWER_ON_ONLY_STATE);
 801b6dc:	200e      	movs	r0, #14
 801b6de:	f7ff fe53 	bl	801b388 <CST_set_state>
}
 801b6e2:	bd38      	pop	{r3, r4, r5, pc}
 801b6e4:	080349e0 	.word	0x080349e0
 801b6e8:	20004ddc 	.word	0x20004ddc

0801b6ec <CST_target_state_cmd_event_mngt>:
{
 801b6ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (cst_cellular_params.target_state == DC_TARGET_STATE_SIM_ONLY)
 801b6ee:	4b4b      	ldr	r3, [pc, #300]	; (801b81c <CST_target_state_cmd_event_mngt+0x130>)
 801b6f0:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b6f4:	2b01      	cmp	r3, #1
 801b6f6:	d003      	beq.n	801b700 <CST_target_state_cmd_event_mngt+0x14>
  else if (cst_cellular_params.target_state == DC_TARGET_STATE_OFF)
 801b6f8:	2b00      	cmp	r3, #0
 801b6fa:	d06e      	beq.n	801b7da <CST_target_state_cmd_event_mngt+0xee>
    __NOP();
 801b6fc:	bf00      	nop
}
 801b6fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    PRINT_CELLULAR_SERVICE("****** Transition to CST_MODEM_SIM_ONLY_STATE Ongoing *****\n\r")
 801b700:	4d47      	ldr	r5, [pc, #284]	; (801b820 <CST_target_state_cmd_event_mngt+0x134>)
 801b702:	4c48      	ldr	r4, [pc, #288]	; (801b824 <CST_target_state_cmd_event_mngt+0x138>)
 801b704:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801b708:	46ac      	mov	ip, r5
 801b70a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b70e:	6020      	str	r0, [r4, #0]
 801b710:	6061      	str	r1, [r4, #4]
 801b712:	60a2      	str	r2, [r4, #8]
 801b714:	60e3      	str	r3, [r4, #12]
 801b716:	4665      	mov	r5, ip
 801b718:	3410      	adds	r4, #16
 801b71a:	45f4      	cmp	ip, lr
 801b71c:	d1f4      	bne.n	801b708 <CST_target_state_cmd_event_mngt+0x1c>
 801b71e:	cd07      	ldmia	r5!, {r0, r1, r2}
 801b720:	6020      	str	r0, [r4, #0]
 801b722:	6061      	str	r1, [r4, #4]
 801b724:	60a2      	str	r2, [r4, #8]
 801b726:	882b      	ldrh	r3, [r5, #0]
 801b728:	81a3      	strh	r3, [r4, #12]
 801b72a:	4c3e      	ldr	r4, [pc, #248]	; (801b824 <CST_target_state_cmd_event_mngt+0x138>)
 801b72c:	4620      	mov	r0, r4
 801b72e:	f003 fdfc 	bl	801f32a <crs_strlen>
 801b732:	b283      	uxth	r3, r0
 801b734:	4622      	mov	r2, r4
 801b736:	2101      	movs	r1, #1
 801b738:	2007      	movs	r0, #7
 801b73a:	f003 fe39 	bl	801f3b0 <traceIF_itmPrint>
 801b73e:	4620      	mov	r0, r4
 801b740:	f003 fdf3 	bl	801f32a <crs_strlen>
 801b744:	b283      	uxth	r3, r0
 801b746:	4622      	mov	r2, r4
 801b748:	2101      	movs	r1, #1
 801b74a:	2007      	movs	r0, #7
 801b74c:	f003 fe52 	bl	801f3f4 <traceIF_uartPrint>
    (void) osCDS_init_modem(CS_CMI_SIM_ONLY, CELLULAR_FALSE, CST_SIM_PINCODE);
 801b750:	4a35      	ldr	r2, [pc, #212]	; (801b828 <CST_target_state_cmd_event_mngt+0x13c>)
 801b752:	2100      	movs	r1, #0
 801b754:	2002      	movs	r0, #2
 801b756:	f7ff faa1 	bl	801ac9c <osCDS_init_modem>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b75a:	4f34      	ldr	r7, [pc, #208]	; (801b82c <CST_target_state_cmd_event_mngt+0x140>)
 801b75c:	4d34      	ldr	r5, [pc, #208]	; (801b830 <CST_target_state_cmd_event_mngt+0x144>)
 801b75e:	4e35      	ldr	r6, [pc, #212]	; (801b834 <CST_target_state_cmd_event_mngt+0x148>)
 801b760:	23f4      	movs	r3, #244	; 0xf4
 801b762:	462a      	mov	r2, r5
 801b764:	8839      	ldrh	r1, [r7, #0]
 801b766:	4630      	mov	r0, r6
 801b768:	f006 fce2 	bl	8022130 <dc_com_read>
    cst_cellular_info.modem_state = DC_MODEM_STATE_SIM_CONNECTED;
 801b76c:	2302      	movs	r3, #2
 801b76e:	726b      	strb	r3, [r5, #9]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801b770:	23f4      	movs	r3, #244	; 0xf4
 801b772:	462a      	mov	r2, r5
 801b774:	8839      	ldrh	r1, [r7, #0]
 801b776:	4630      	mov	r0, r6
 801b778:	f006 fc8e 	bl	8022098 <dc_com_write>
    CST_set_state(CST_MODEM_SIM_ONLY_STATE);
 801b77c:	200b      	movs	r0, #11
 801b77e:	f7ff fe03 	bl	801b388 <CST_set_state>
    PRINT_CELLULAR_SERVICE("****** CST_MODEM_SIM_ONLY_STATE *****\n\r")
 801b782:	4d2d      	ldr	r5, [pc, #180]	; (801b838 <CST_target_state_cmd_event_mngt+0x14c>)
 801b784:	46a4      	mov	ip, r4
 801b786:	f105 0e20 	add.w	lr, r5, #32
 801b78a:	462c      	mov	r4, r5
 801b78c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801b78e:	f8cc 0000 	str.w	r0, [ip]
 801b792:	f8cc 1004 	str.w	r1, [ip, #4]
 801b796:	f8cc 2008 	str.w	r2, [ip, #8]
 801b79a:	f8cc 300c 	str.w	r3, [ip, #12]
 801b79e:	4625      	mov	r5, r4
 801b7a0:	f10c 0c10 	add.w	ip, ip, #16
 801b7a4:	4574      	cmp	r4, lr
 801b7a6:	d1f0      	bne.n	801b78a <CST_target_state_cmd_event_mngt+0x9e>
 801b7a8:	cd03      	ldmia	r5!, {r0, r1}
 801b7aa:	f8cc 0000 	str.w	r0, [ip]
 801b7ae:	f8cc 1004 	str.w	r1, [ip, #4]
 801b7b2:	4c1c      	ldr	r4, [pc, #112]	; (801b824 <CST_target_state_cmd_event_mngt+0x138>)
 801b7b4:	4620      	mov	r0, r4
 801b7b6:	f003 fdb8 	bl	801f32a <crs_strlen>
 801b7ba:	b283      	uxth	r3, r0
 801b7bc:	4622      	mov	r2, r4
 801b7be:	2101      	movs	r1, #1
 801b7c0:	2007      	movs	r0, #7
 801b7c2:	f003 fdf5 	bl	801f3b0 <traceIF_itmPrint>
 801b7c6:	4620      	mov	r0, r4
 801b7c8:	f003 fdaf 	bl	801f32a <crs_strlen>
 801b7cc:	b283      	uxth	r3, r0
 801b7ce:	4622      	mov	r2, r4
 801b7d0:	2101      	movs	r1, #1
 801b7d2:	2007      	movs	r0, #7
 801b7d4:	f003 fe0e 	bl	801f3f4 <traceIF_uartPrint>
 801b7d8:	e791      	b.n	801b6fe <CST_target_state_cmd_event_mngt+0x12>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801b7da:	4e18      	ldr	r6, [pc, #96]	; (801b83c <CST_target_state_cmd_event_mngt+0x150>)
 801b7dc:	4c18      	ldr	r4, [pc, #96]	; (801b840 <CST_target_state_cmd_event_mngt+0x154>)
 801b7de:	4d15      	ldr	r5, [pc, #84]	; (801b834 <CST_target_state_cmd_event_mngt+0x148>)
 801b7e0:	2330      	movs	r3, #48	; 0x30
 801b7e2:	4622      	mov	r2, r4
 801b7e4:	8831      	ldrh	r1, [r6, #0]
 801b7e6:	4628      	mov	r0, r5
 801b7e8:	f006 fca2 	bl	8022130 <dc_com_read>
    cst_sim_info.rt_state = DC_SERVICE_OFF;
 801b7ec:	2303      	movs	r3, #3
 801b7ee:	7223      	strb	r3, [r4, #8]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801b7f0:	2330      	movs	r3, #48	; 0x30
 801b7f2:	4622      	mov	r2, r4
 801b7f4:	8831      	ldrh	r1, [r6, #0]
 801b7f6:	4628      	mov	r0, r5
 801b7f8:	f006 fc4e 	bl	8022098 <dc_com_write>
    (void) osCDS_init_modem(CS_CMI_MINI, CELLULAR_FALSE, CST_SIM_PINCODE);
 801b7fc:	4a0a      	ldr	r2, [pc, #40]	; (801b828 <CST_target_state_cmd_event_mngt+0x13c>)
 801b7fe:	2100      	movs	r1, #0
 801b800:	4608      	mov	r0, r1
 801b802:	f7ff fa4b 	bl	801ac9c <osCDS_init_modem>
    (void)osCDS_power_off();
 801b806:	f7ff fa37 	bl	801ac78 <osCDS_power_off>
    CST_set_state(CST_MODEM_OFF_STATE);
 801b80a:	200d      	movs	r0, #13
 801b80c:	f7ff fdbc 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801b810:	2101      	movs	r1, #1
 801b812:	2000      	movs	r0, #0
 801b814:	f7ff fcf4 	bl	801b200 <CST_send_message>
 801b818:	e771      	b.n	801b6fe <CST_target_state_cmd_event_mngt+0x12>
 801b81a:	bf00      	nop
 801b81c:	20004160 	.word	0x20004160
 801b820:	08034a14 	.word	0x08034a14
 801b824:	20004ddc 	.word	0x20004ddc
 801b828:	08035c54 	.word	0x08035c54
 801b82c:	20000236 	.word	0x20000236
 801b830:	2000406c 	.word	0x2000406c
 801b834:	200058b0 	.word	0x200058b0
 801b838:	08034a54 	.word	0x08034a54
 801b83c:	2000023c 	.word	0x2000023c
 801b840:	20004338 	.word	0x20004338

0801b844 <CST_data_mode_target_state_event_mngt>:
{
 801b844:	b508      	push	{r3, lr}
  if (cst_cellular_params.target_state != DC_TARGET_STATE_FULL)
 801b846:	4b06      	ldr	r3, [pc, #24]	; (801b860 <CST_data_mode_target_state_event_mngt+0x1c>)
 801b848:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801b84c:	2b02      	cmp	r3, #2
 801b84e:	d100      	bne.n	801b852 <CST_data_mode_target_state_event_mngt+0xe>
}
 801b850:	bd08      	pop	{r3, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801b852:	2100      	movs	r1, #0
 801b854:	2003      	movs	r0, #3
 801b856:	f001 fec9 	bl	801d5ec <CST_data_cache_cellular_info_set>
    CST_target_state_cmd_event_mngt();
 801b85a:	f7ff ff47 	bl	801b6ec <CST_target_state_cmd_event_mngt>
}
 801b85e:	e7f7      	b.n	801b850 <CST_data_mode_target_state_event_mngt+0xc>
 801b860:	20004160 	.word	0x20004160

0801b864 <CST_fota_start_event_mngt>:
{
 801b864:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("Modem event received:  CS_MDMEVENT_FOTA_START\n\r")
 801b866:	4d1e      	ldr	r5, [pc, #120]	; (801b8e0 <CST_fota_start_event_mngt+0x7c>)
 801b868:	4c1e      	ldr	r4, [pc, #120]	; (801b8e4 <CST_fota_start_event_mngt+0x80>)
 801b86a:	f105 0630 	add.w	r6, r5, #48	; 0x30
 801b86e:	46ac      	mov	ip, r5
 801b870:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801b874:	6020      	str	r0, [r4, #0]
 801b876:	6061      	str	r1, [r4, #4]
 801b878:	60a2      	str	r2, [r4, #8]
 801b87a:	60e3      	str	r3, [r4, #12]
 801b87c:	4665      	mov	r5, ip
 801b87e:	3410      	adds	r4, #16
 801b880:	45b4      	cmp	ip, r6
 801b882:	d1f4      	bne.n	801b86e <CST_fota_start_event_mngt+0xa>
 801b884:	4c17      	ldr	r4, [pc, #92]	; (801b8e4 <CST_fota_start_event_mngt+0x80>)
 801b886:	4620      	mov	r0, r4
 801b888:	f003 fd4f 	bl	801f32a <crs_strlen>
 801b88c:	b283      	uxth	r3, r0
 801b88e:	4622      	mov	r2, r4
 801b890:	2101      	movs	r1, #1
 801b892:	2007      	movs	r0, #7
 801b894:	f003 fd8c 	bl	801f3b0 <traceIF_itmPrint>
 801b898:	4620      	mov	r0, r4
 801b89a:	f003 fd46 	bl	801f32a <crs_strlen>
 801b89e:	b283      	uxth	r3, r0
 801b8a0:	4622      	mov	r2, r4
 801b8a2:	2101      	movs	r1, #1
 801b8a4:	2007      	movs	r0, #7
 801b8a6:	f003 fda5 	bl	801f3f4 <traceIF_uartPrint>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801b8aa:	4e0f      	ldr	r6, [pc, #60]	; (801b8e8 <CST_fota_start_event_mngt+0x84>)
 801b8ac:	4c0f      	ldr	r4, [pc, #60]	; (801b8ec <CST_fota_start_event_mngt+0x88>)
 801b8ae:	4d10      	ldr	r5, [pc, #64]	; (801b8f0 <CST_fota_start_event_mngt+0x8c>)
 801b8b0:	2310      	movs	r3, #16
 801b8b2:	4622      	mov	r2, r4
 801b8b4:	8831      	ldrh	r1, [r6, #0]
 801b8b6:	4628      	mov	r0, r5
 801b8b8:	f006 fc3a 	bl	8022130 <dc_com_read>
  cst_cellular_data_info.rt_state = DC_SERVICE_SHUTTING_DOWN;
 801b8bc:	2304      	movs	r3, #4
 801b8be:	7223      	strb	r3, [r4, #8]
  CST_set_state(CST_MODEM_REPROG_STATE);
 801b8c0:	2009      	movs	r0, #9
 801b8c2:	f7ff fd61 	bl	801b388 <CST_set_state>
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801b8c6:	2310      	movs	r3, #16
 801b8c8:	4622      	mov	r2, r4
 801b8ca:	8831      	ldrh	r1, [r6, #0]
 801b8cc:	4628      	mov	r0, r5
 801b8ce:	f006 fbe3 	bl	8022098 <dc_com_write>
  (void)rtosalTimerStart(cst_fota_timer_handle, CST_FOTA_TIMEOUT);
 801b8d2:	4908      	ldr	r1, [pc, #32]	; (801b8f4 <CST_fota_start_event_mngt+0x90>)
 801b8d4:	4b08      	ldr	r3, [pc, #32]	; (801b8f8 <CST_fota_start_event_mngt+0x94>)
 801b8d6:	6818      	ldr	r0, [r3, #0]
 801b8d8:	f003 fc77 	bl	801f1ca <rtosalTimerStart>
}
 801b8dc:	bd70      	pop	{r4, r5, r6, pc}
 801b8de:	bf00      	nop
 801b8e0:	08034a7c 	.word	0x08034a7c
 801b8e4:	20004ddc 	.word	0x20004ddc
 801b8e8:	20000234 	.word	0x20000234
 801b8ec:	2000405c 	.word	0x2000405c
 801b8f0:	200058b0 	.word	0x200058b0
 801b8f4:	00057e40 	.word	0x00057e40
 801b8f8:	20004304 	.word	0x20004304

0801b8fc <CST_init_state>:
{
 801b8fc:	b508      	push	{r3, lr}
  switch (autom_event)
 801b8fe:	3801      	subs	r0, #1
 801b900:	2814      	cmp	r0, #20
 801b902:	d80e      	bhi.n	801b922 <CST_init_state+0x26>
 801b904:	e8df f000 	tbb	[pc, r0]
 801b908:	0d0d0d0b 	.word	0x0d0d0d0b
 801b90c:	0d0d0d0d 	.word	0x0d0d0d0d
 801b910:	0d0d0d0d 	.word	0x0d0d0d0d
 801b914:	0d160d0d 	.word	0x0d160d0d
 801b918:	0d0d1013 	.word	0x0d0d1013
 801b91c:	19          	.byte	0x19
 801b91d:	00          	.byte	0x00
      CST_init_state_mngt();
 801b91e:	f7ff fe3b 	bl	801b598 <CST_init_state_mngt>
  CST_subscribe_modem_events();
 801b922:	f002 fc15 	bl	801e150 <CST_subscribe_modem_events>
}
 801b926:	bd08      	pop	{r3, pc}
      CST_init_power_on_only_modem_mngt();
 801b928:	f7ff feb0 	bl	801b68c <CST_init_power_on_only_modem_mngt>
      break;
 801b92c:	e7f9      	b.n	801b922 <CST_init_state+0x26>
      CST_reboot_modem_event_mngt();
 801b92e:	f7ff fd95 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801b932:	e7f6      	b.n	801b922 <CST_init_state+0x26>
      CST_target_state_cmd_event_mngt();
 801b934:	f7ff feda 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801b938:	e7f3      	b.n	801b922 <CST_init_state+0x26>
      CST_fota_start_event_mngt();
 801b93a:	f7ff ff93 	bl	801b864 <CST_fota_start_event_mngt>
      break;
 801b93e:	e7f0      	b.n	801b922 <CST_init_state+0x26>

0801b940 <CST_net_register_mngt>:
{
 801b940:	b530      	push	{r4, r5, lr}
 801b942:	b095      	sub	sp, #84	; 0x54
  PRINT_CELLULAR_SERVICE("=== CST_net_register_mngt ===\n\r")
 801b944:	4c39      	ldr	r4, [pc, #228]	; (801ba2c <CST_net_register_mngt+0xec>)
 801b946:	4d3a      	ldr	r5, [pc, #232]	; (801ba30 <CST_net_register_mngt+0xf0>)
 801b948:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801b94a:	6020      	str	r0, [r4, #0]
 801b94c:	6061      	str	r1, [r4, #4]
 801b94e:	60a2      	str	r2, [r4, #8]
 801b950:	60e3      	str	r3, [r4, #12]
 801b952:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801b954:	6120      	str	r0, [r4, #16]
 801b956:	6161      	str	r1, [r4, #20]
 801b958:	61a2      	str	r2, [r4, #24]
 801b95a:	61e3      	str	r3, [r4, #28]
 801b95c:	4620      	mov	r0, r4
 801b95e:	f003 fce4 	bl	801f32a <crs_strlen>
 801b962:	b283      	uxth	r3, r0
 801b964:	4622      	mov	r2, r4
 801b966:	2101      	movs	r1, #1
 801b968:	2007      	movs	r0, #7
 801b96a:	f003 fd21 	bl	801f3b0 <traceIF_itmPrint>
 801b96e:	4620      	mov	r0, r4
 801b970:	f003 fcdb 	bl	801f32a <crs_strlen>
 801b974:	b283      	uxth	r3, r0
 801b976:	4622      	mov	r2, r4
 801b978:	2101      	movs	r1, #1
 801b97a:	2007      	movs	r0, #7
 801b97c:	f003 fd3a 	bl	801f3f4 <traceIF_uartPrint>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params));
 801b980:	4c2c      	ldr	r4, [pc, #176]	; (801ba34 <CST_net_register_mngt+0xf4>)
 801b982:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801b986:	4622      	mov	r2, r4
 801b988:	492b      	ldr	r1, [pc, #172]	; (801ba38 <CST_net_register_mngt+0xf8>)
 801b98a:	8809      	ldrh	r1, [r1, #0]
 801b98c:	482b      	ldr	r0, [pc, #172]	; (801ba3c <CST_net_register_mngt+0xfc>)
 801b98e:	f006 fbcf 	bl	8022130 <dc_com_read>
  ctxt_operator.mode = (CS_NetworkRegMode_t)cst_cellular_params.operator_selector.network_reg_mode;
 801b992:	f894 3138 	ldrb.w	r3, [r4, #312]	; 0x138
 801b996:	4d2a      	ldr	r5, [pc, #168]	; (801ba40 <CST_net_register_mngt+0x100>)
 801b998:	802b      	strh	r3, [r5, #0]
  ctxt_operator.format = (CS_OperatorNameFormat_t)cst_cellular_params.operator_selector.operator_name_format;
 801b99a:	f894 3139 	ldrb.w	r3, [r4, #313]	; 0x139
 801b99e:	806b      	strh	r3, [r5, #2]
  (void)memcpy(ctxt_operator.operator_name, cst_cellular_params.operator_selector.operator_name,
 801b9a0:	f504 7c9d 	add.w	ip, r4, #314	; 0x13a
 801b9a4:	3504      	adds	r5, #4
 801b9a6:	f504 74bd 	add.w	r4, r4, #378	; 0x17a
 801b9aa:	46ae      	mov	lr, r5
 801b9ac:	f8dc 0000 	ldr.w	r0, [ip]
 801b9b0:	f8dc 1004 	ldr.w	r1, [ip, #4]
 801b9b4:	f8dc 2008 	ldr.w	r2, [ip, #8]
 801b9b8:	f8dc 300c 	ldr.w	r3, [ip, #12]
 801b9bc:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
 801b9c0:	f10c 0c10 	add.w	ip, ip, #16
 801b9c4:	4675      	mov	r5, lr
 801b9c6:	45a4      	cmp	ip, r4
 801b9c8:	d1ef      	bne.n	801b9aa <CST_net_register_mngt+0x6a>
  ctxt_operator.AcT_present = (CS_Bool_t)cst_cellular_params.operator_selector.access_techno_present;
 801b9ca:	4b1a      	ldr	r3, [pc, #104]	; (801ba34 <CST_net_register_mngt+0xf4>)
 801b9cc:	f893 217a 	ldrb.w	r2, [r3, #378]	; 0x17a
 801b9d0:	481b      	ldr	r0, [pc, #108]	; (801ba40 <CST_net_register_mngt+0x100>)
 801b9d2:	f880 2044 	strb.w	r2, [r0, #68]	; 0x44
  ctxt_operator.AcT = (CS_AccessTechno_t)cst_cellular_params.operator_selector.access_techno;
 801b9d6:	f893 317b 	ldrb.w	r3, [r3, #379]	; 0x17b
 801b9da:	f8a0 3046 	strh.w	r3, [r0, #70]	; 0x46
  cs_status = osCDS_register_net(&ctxt_operator, &cst_ctxt_reg_status);
 801b9de:	4669      	mov	r1, sp
 801b9e0:	f7ff f974 	bl	801accc <osCDS_register_net>
  if (cs_status == CELLULAR_OK)
 801b9e4:	b9a0      	cbnz	r0, 801ba10 <CST_net_register_mngt+0xd0>
    cst_context.current_EPS_NetworkRegState  = cst_ctxt_reg_status.EPS_NetworkRegState;
 801b9e6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 801b9ea:	4b16      	ldr	r3, [pc, #88]	; (801ba44 <CST_net_register_mngt+0x104>)
 801b9ec:	80da      	strh	r2, [r3, #6]
    cst_context.current_GPRS_NetworkRegState = cst_ctxt_reg_status.GPRS_NetworkRegState;
 801b9ee:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 801b9f2:	811a      	strh	r2, [r3, #8]
    cst_context.current_CS_NetworkRegState   = cst_ctxt_reg_status.CS_NetworkRegState;
 801b9f4:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 801b9f8:	815a      	strh	r2, [r3, #10]
    (void)osCDS_attach_PS_domain();
 801b9fa:	f7ff f991 	bl	801ad20 <osCDS_attach_PS_domain>
    CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801b9fe:	2003      	movs	r0, #3
 801ba00:	f7ff fcc2 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_SIGNAL_QUALITY_TO_CHECK_EVENT);
 801ba04:	2103      	movs	r1, #3
 801ba06:	2000      	movs	r0, #0
 801ba08:	f7ff fbfa 	bl	801b200 <CST_send_message>
}
 801ba0c:	b015      	add	sp, #84	; 0x54
 801ba0e:	bd30      	pop	{r4, r5, pc}
    CST_config_fail(((uint8_t *)"CST_net_register_mngt"),
 801ba10:	4c0c      	ldr	r4, [pc, #48]	; (801ba44 <CST_net_register_mngt+0x104>)
 801ba12:	2305      	movs	r3, #5
 801ba14:	f104 0216 	add.w	r2, r4, #22
 801ba18:	2104      	movs	r1, #4
 801ba1a:	480b      	ldr	r0, [pc, #44]	; (801ba48 <CST_net_register_mngt+0x108>)
 801ba1c:	f001 fe26 	bl	801d66c <CST_config_fail>
    cst_context.current_EPS_NetworkRegState  = CS_NRS_NOT_REGISTERED_SEARCHING;
 801ba20:	2302      	movs	r3, #2
 801ba22:	80e3      	strh	r3, [r4, #6]
    cst_context.current_GPRS_NetworkRegState = CS_NRS_NOT_REGISTERED_SEARCHING;
 801ba24:	8123      	strh	r3, [r4, #8]
    cst_context.current_CS_NetworkRegState   = CS_NRS_NOT_REGISTERED_SEARCHING;
 801ba26:	8163      	strh	r3, [r4, #10]
}
 801ba28:	e7f0      	b.n	801ba0c <CST_net_register_mngt+0xcc>
 801ba2a:	bf00      	nop
 801ba2c:	20004ddc 	.word	0x20004ddc
 801ba30:	08034aac 	.word	0x08034aac
 801ba34:	20004160 	.word	0x20004160
 801ba38:	20000232 	.word	0x20000232
 801ba3c:	200058b0 	.word	0x200058b0
 801ba40:	20004368 	.word	0x20004368
 801ba44:	200000b0 	.word	0x200000b0
 801ba48:	08034acc 	.word	0x08034acc

0801ba4c <CST_modem_ready_state>:
{
 801ba4c:	b508      	push	{r3, lr}
  switch (autom_event)
 801ba4e:	3802      	subs	r0, #2
 801ba50:	2813      	cmp	r0, #19
 801ba52:	d80d      	bhi.n	801ba70 <CST_modem_ready_state+0x24>
 801ba54:	e8df f000 	tbb	[pc, r0]
 801ba58:	0c0c0c0a 	.word	0x0c0c0c0a
 801ba5c:	0c0c0c0c 	.word	0x0c0c0c0c
 801ba60:	0c0c0c0c 	.word	0x0c0c0c0c
 801ba64:	100c0d0c 	.word	0x100c0d0c
 801ba68:	130c0c0c 	.word	0x130c0c0c
      CST_net_register_mngt();
 801ba6c:	f7ff ff68 	bl	801b940 <CST_net_register_mngt>
}
 801ba70:	bd08      	pop	{r3, pc}
      CST_target_state_cmd_event_mngt();
 801ba72:	f7ff fe3b 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801ba76:	e7fb      	b.n	801ba70 <CST_modem_ready_state+0x24>
      CST_reboot_modem_event_mngt();
 801ba78:	f7ff fcf0 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801ba7c:	e7f8      	b.n	801ba70 <CST_modem_ready_state+0x24>
      CST_fota_start_event_mngt();
 801ba7e:	f7ff fef1 	bl	801b864 <CST_fota_start_event_mngt>
}
 801ba82:	e7f5      	b.n	801ba70 <CST_modem_ready_state+0x24>

0801ba84 <CST_signal_quality_test_mngt>:
{
 801ba84:	b538      	push	{r3, r4, r5, lr}
  cs_status = CST_set_signal_quality();
 801ba86:	f002 fa8d 	bl	801dfa4 <CST_set_signal_quality>
  if (cs_status == CELLULAR_OK)
 801ba8a:	b100      	cbz	r0, 801ba8e <CST_signal_quality_test_mngt+0xa>
}
 801ba8c:	bd38      	pop	{r3, r4, r5, pc}
    (void)rtosalTimerStart(cst_network_status_timer_handle, cst_cellular_params.attachment_timeout);
 801ba8e:	4d14      	ldr	r5, [pc, #80]	; (801bae0 <CST_signal_quality_test_mngt+0x5c>)
 801ba90:	f8d5 1134 	ldr.w	r1, [r5, #308]	; 0x134
 801ba94:	4b13      	ldr	r3, [pc, #76]	; (801bae4 <CST_signal_quality_test_mngt+0x60>)
 801ba96:	6818      	ldr	r0, [r3, #0]
 801ba98:	f003 fb97 	bl	801f1ca <rtosalTimerStart>
    PRINT_CELLULAR_SERVICE("-----> Start NW REG TIMEOUT TIMER   : %ld\n\r", cst_cellular_params.attachment_timeout)
 801ba9c:	4c12      	ldr	r4, [pc, #72]	; (801bae8 <CST_signal_quality_test_mngt+0x64>)
 801ba9e:	f8d5 2134 	ldr.w	r2, [r5, #308]	; 0x134
 801baa2:	4912      	ldr	r1, [pc, #72]	; (801baec <CST_signal_quality_test_mngt+0x68>)
 801baa4:	4620      	mov	r0, r4
 801baa6:	f00a fecf 	bl	8026848 <sprintf>
 801baaa:	4620      	mov	r0, r4
 801baac:	f003 fc3d 	bl	801f32a <crs_strlen>
 801bab0:	b283      	uxth	r3, r0
 801bab2:	4622      	mov	r2, r4
 801bab4:	2101      	movs	r1, #1
 801bab6:	2007      	movs	r0, #7
 801bab8:	f003 fc7a 	bl	801f3b0 <traceIF_itmPrint>
 801babc:	4620      	mov	r0, r4
 801babe:	f003 fc34 	bl	801f32a <crs_strlen>
 801bac2:	b283      	uxth	r3, r0
 801bac4:	4622      	mov	r2, r4
 801bac6:	2101      	movs	r1, #1
 801bac8:	2007      	movs	r0, #7
 801baca:	f003 fc93 	bl	801f3f4 <traceIF_uartPrint>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801bace:	2004      	movs	r0, #4
 801bad0:	f7ff fc5a 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_STATUS_TO_CHECK_EVENT);
 801bad4:	2104      	movs	r1, #4
 801bad6:	2000      	movs	r0, #0
 801bad8:	f7ff fb92 	bl	801b200 <CST_send_message>
}
 801badc:	e7d6      	b.n	801ba8c <CST_signal_quality_test_mngt+0x8>
 801bade:	bf00      	nop
 801bae0:	20004160 	.word	0x20004160
 801bae4:	20004308 	.word	0x20004308
 801bae8:	20004ddc 	.word	0x20004ddc
 801baec:	08034ae4 	.word	0x08034ae4

0801baf0 <CST_network_event_mngt>:
{
 801baf0:	b510      	push	{r4, lr}
  ret = CST_get_network_status();
 801baf2:	f002 fb9d 	bl	801e230 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801baf6:	b330      	cbz	r0, 801bb46 <CST_network_event_mngt+0x56>
  else if (ret == CST_NOT_REGISTERED)
 801baf8:	2801      	cmp	r0, #1
 801bafa:	d02c      	beq.n	801bb56 <CST_network_event_mngt+0x66>
  else if (ret == CST_NET_UNKNOWN)
 801bafc:	2803      	cmp	r0, #3
 801bafe:	d032      	beq.n	801bb66 <CST_network_event_mngt+0x76>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801bb00:	2100      	movs	r1, #0
 801bb02:	2003      	movs	r0, #3
 801bb04:	f001 fd72 	bl	801d5ec <CST_data_cache_cellular_info_set>
    PRINT_CELLULAR_SERVICE("******** CST_network_event_mngt: osCDS_get_net_status FAIL ****\n\r")
 801bb08:	4c19      	ldr	r4, [pc, #100]	; (801bb70 <CST_network_event_mngt+0x80>)
 801bb0a:	2242      	movs	r2, #66	; 0x42
 801bb0c:	4919      	ldr	r1, [pc, #100]	; (801bb74 <CST_network_event_mngt+0x84>)
 801bb0e:	4620      	mov	r0, r4
 801bb10:	f00a ffea 	bl	8026ae8 <memcpy>
 801bb14:	4620      	mov	r0, r4
 801bb16:	f003 fc08 	bl	801f32a <crs_strlen>
 801bb1a:	b283      	uxth	r3, r0
 801bb1c:	4622      	mov	r2, r4
 801bb1e:	2101      	movs	r1, #1
 801bb20:	2007      	movs	r0, #7
 801bb22:	f003 fc45 	bl	801f3b0 <traceIF_itmPrint>
 801bb26:	4620      	mov	r0, r4
 801bb28:	f003 fbff 	bl	801f32a <crs_strlen>
 801bb2c:	b283      	uxth	r3, r0
 801bb2e:	4622      	mov	r2, r4
 801bb30:	2101      	movs	r1, #1
 801bb32:	2007      	movs	r0, #7
 801bb34:	f003 fc5e 	bl	801f3f4 <traceIF_uartPrint>
    CST_config_fail(((uint8_t *)"CST_network_status_test_mngt"),
 801bb38:	2305      	movs	r3, #5
 801bb3a:	4a0f      	ldr	r2, [pc, #60]	; (801bb78 <CST_network_event_mngt+0x88>)
 801bb3c:	4619      	mov	r1, r3
 801bb3e:	480f      	ldr	r0, [pc, #60]	; (801bb7c <CST_network_event_mngt+0x8c>)
 801bb40:	f001 fd94 	bl	801d66c <CST_config_fail>
}
 801bb44:	bd10      	pop	{r4, pc}
    CST_set_state(CST_NETWORK_STATUS_OK_STATE);
 801bb46:	2005      	movs	r0, #5
 801bb48:	f7ff fc1e 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_STATUS_OK_EVENT);
 801bb4c:	2105      	movs	r1, #5
 801bb4e:	2000      	movs	r0, #0
 801bb50:	f7ff fb56 	bl	801b200 <CST_send_message>
 801bb54:	e7f6      	b.n	801bb44 <CST_network_event_mngt+0x54>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801bb56:	2100      	movs	r1, #0
 801bb58:	2003      	movs	r0, #3
 801bb5a:	f001 fd47 	bl	801d5ec <CST_data_cache_cellular_info_set>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801bb5e:	2004      	movs	r0, #4
 801bb60:	f7ff fc12 	bl	801b388 <CST_set_state>
 801bb64:	e7ee      	b.n	801bb44 <CST_network_event_mngt+0x54>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801bb66:	210d      	movs	r1, #13
 801bb68:	2000      	movs	r0, #0
 801bb6a:	f7ff fb49 	bl	801b200 <CST_send_message>
 801bb6e:	e7e9      	b.n	801bb44 <CST_network_event_mngt+0x54>
 801bb70:	20004ddc 	.word	0x20004ddc
 801bb74:	08034b10 	.word	0x08034b10
 801bb78:	200000c7 	.word	0x200000c7
 801bb7c:	08034b54 	.word	0x08034b54

0801bb80 <CST_waiting_for_signal_quality_ok_state>:
{
 801bb80:	b570      	push	{r4, r5, r6, lr}
 801bb82:	4606      	mov	r6, r0
  PRINT_CELLULAR_SERVICE("\n\r ====> CST_waiting_for_signal_quality_ok_state <===== \n\r")
 801bb84:	4c23      	ldr	r4, [pc, #140]	; (801bc14 <CST_waiting_for_signal_quality_ok_state+0x94>)
 801bb86:	4d24      	ldr	r5, [pc, #144]	; (801bc18 <CST_waiting_for_signal_quality_ok_state+0x98>)
 801bb88:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801bb8c:	46a4      	mov	ip, r4
 801bb8e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801bb92:	6028      	str	r0, [r5, #0]
 801bb94:	6069      	str	r1, [r5, #4]
 801bb96:	60aa      	str	r2, [r5, #8]
 801bb98:	60eb      	str	r3, [r5, #12]
 801bb9a:	4664      	mov	r4, ip
 801bb9c:	3510      	adds	r5, #16
 801bb9e:	45f4      	cmp	ip, lr
 801bba0:	d1f4      	bne.n	801bb8c <CST_waiting_for_signal_quality_ok_state+0xc>
 801bba2:	cc03      	ldmia	r4!, {r0, r1}
 801bba4:	6028      	str	r0, [r5, #0]
 801bba6:	6069      	str	r1, [r5, #4]
 801bba8:	8822      	ldrh	r2, [r4, #0]
 801bbaa:	78a3      	ldrb	r3, [r4, #2]
 801bbac:	812a      	strh	r2, [r5, #8]
 801bbae:	72ab      	strb	r3, [r5, #10]
 801bbb0:	4c19      	ldr	r4, [pc, #100]	; (801bc18 <CST_waiting_for_signal_quality_ok_state+0x98>)
 801bbb2:	4620      	mov	r0, r4
 801bbb4:	f003 fbb9 	bl	801f32a <crs_strlen>
 801bbb8:	b283      	uxth	r3, r0
 801bbba:	4622      	mov	r2, r4
 801bbbc:	2101      	movs	r1, #1
 801bbbe:	2007      	movs	r0, #7
 801bbc0:	f003 fbf6 	bl	801f3b0 <traceIF_itmPrint>
 801bbc4:	4620      	mov	r0, r4
 801bbc6:	f003 fbb0 	bl	801f32a <crs_strlen>
 801bbca:	b283      	uxth	r3, r0
 801bbcc:	4622      	mov	r2, r4
 801bbce:	2101      	movs	r1, #1
 801bbd0:	2007      	movs	r0, #7
 801bbd2:	f003 fc0f 	bl	801f3f4 <traceIF_uartPrint>
  switch (autom_event)
 801bbd6:	1ef0      	subs	r0, r6, #3
 801bbd8:	2812      	cmp	r0, #18
 801bbda:	d80d      	bhi.n	801bbf8 <CST_waiting_for_signal_quality_ok_state+0x78>
 801bbdc:	e8df f000 	tbb	[pc, r0]
 801bbe0:	0c0c0c0a 	.word	0x0c0c0c0a
 801bbe4:	0c0c0c0c 	.word	0x0c0c0c0c
 801bbe8:	0c0c0c0a 	.word	0x0c0c0c0a
 801bbec:	0c130c10 	.word	0x0c130c10
 801bbf0:	0c0d      	.short	0x0c0d
 801bbf2:	16          	.byte	0x16
 801bbf3:	00          	.byte	0x00
      CST_signal_quality_test_mngt();
 801bbf4:	f7ff ff46 	bl	801ba84 <CST_signal_quality_test_mngt>
}
 801bbf8:	bd70      	pop	{r4, r5, r6, pc}
      CST_network_event_mngt();
 801bbfa:	f7ff ff79 	bl	801baf0 <CST_network_event_mngt>
      break;
 801bbfe:	e7fb      	b.n	801bbf8 <CST_waiting_for_signal_quality_ok_state+0x78>
      CST_target_state_cmd_event_mngt();
 801bc00:	f7ff fd74 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801bc04:	e7f8      	b.n	801bbf8 <CST_waiting_for_signal_quality_ok_state+0x78>
      CST_reboot_modem_event_mngt();
 801bc06:	f7ff fc29 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801bc0a:	e7f5      	b.n	801bbf8 <CST_waiting_for_signal_quality_ok_state+0x78>
      CST_fota_start_event_mngt();
 801bc0c:	f7ff fe2a 	bl	801b864 <CST_fota_start_event_mngt>
}
 801bc10:	e7f2      	b.n	801bbf8 <CST_waiting_for_signal_quality_ok_state+0x78>
 801bc12:	bf00      	nop
 801bc14:	08034b74 	.word	0x08034b74
 801bc18:	20004ddc 	.word	0x20004ddc

0801bc1c <CST_network_status_test_mngt>:
{
 801bc1c:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_network_status_test_mngt ********\n\r")
 801bc1e:	4d4f      	ldr	r5, [pc, #316]	; (801bd5c <CST_network_status_test_mngt+0x140>)
 801bc20:	4c4f      	ldr	r4, [pc, #316]	; (801bd60 <CST_network_status_test_mngt+0x144>)
 801bc22:	f105 0630 	add.w	r6, r5, #48	; 0x30
 801bc26:	46ac      	mov	ip, r5
 801bc28:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801bc2c:	6020      	str	r0, [r4, #0]
 801bc2e:	6061      	str	r1, [r4, #4]
 801bc30:	60a2      	str	r2, [r4, #8]
 801bc32:	60e3      	str	r3, [r4, #12]
 801bc34:	4665      	mov	r5, ip
 801bc36:	3410      	adds	r4, #16
 801bc38:	45b4      	cmp	ip, r6
 801bc3a:	d1f4      	bne.n	801bc26 <CST_network_status_test_mngt+0xa>
 801bc3c:	f8dc 0000 	ldr.w	r0, [ip]
 801bc40:	6020      	str	r0, [r4, #0]
 801bc42:	4c47      	ldr	r4, [pc, #284]	; (801bd60 <CST_network_status_test_mngt+0x144>)
 801bc44:	4620      	mov	r0, r4
 801bc46:	f003 fb70 	bl	801f32a <crs_strlen>
 801bc4a:	b283      	uxth	r3, r0
 801bc4c:	4622      	mov	r2, r4
 801bc4e:	2101      	movs	r1, #1
 801bc50:	2007      	movs	r0, #7
 801bc52:	f003 fbad 	bl	801f3b0 <traceIF_itmPrint>
 801bc56:	4620      	mov	r0, r4
 801bc58:	f003 fb67 	bl	801f32a <crs_strlen>
 801bc5c:	b283      	uxth	r3, r0
 801bc5e:	4622      	mov	r2, r4
 801bc60:	2101      	movs	r1, #1
 801bc62:	2007      	movs	r0, #7
 801bc64:	f003 fbc6 	bl	801f3f4 <traceIF_uartPrint>
  ret = CST_get_network_status();
 801bc68:	f002 fae2 	bl	801e230 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801bc6c:	b150      	cbz	r0, 801bc84 <CST_network_status_test_mngt+0x68>
  else if (ret == CST_NOT_REGISTERED)
 801bc6e:	2801      	cmp	r0, #1
 801bc70:	d03b      	beq.n	801bcea <CST_network_status_test_mngt+0xce>
  else if (ret == CST_NET_UNKNOWN)
 801bc72:	2803      	cmp	r0, #3
 801bc74:	d06d      	beq.n	801bd52 <CST_network_status_test_mngt+0x136>
    CST_config_fail(((uint8_t *)"CST_network_status_test_mngt"),
 801bc76:	2305      	movs	r3, #5
 801bc78:	4a3a      	ldr	r2, [pc, #232]	; (801bd64 <CST_network_status_test_mngt+0x148>)
 801bc7a:	4619      	mov	r1, r3
 801bc7c:	483a      	ldr	r0, [pc, #232]	; (801bd68 <CST_network_status_test_mngt+0x14c>)
 801bc7e:	f001 fcf5 	bl	801d66c <CST_config_fail>
}
 801bc82:	bd70      	pop	{r4, r5, r6, pc}
    (void)rtosalTimerStop(cst_network_status_timer_handle);
 801bc84:	4b39      	ldr	r3, [pc, #228]	; (801bd6c <CST_network_status_test_mngt+0x150>)
 801bc86:	6818      	ldr	r0, [r3, #0]
 801bc88:	f003 faa3 	bl	801f1d2 <rtosalTimerStop>
    PRINT_CELLULAR_SERVICE("-----> Stop NW REG TIMEOUT TIMER\n\r")
 801bc8c:	4e38      	ldr	r6, [pc, #224]	; (801bd70 <CST_network_status_test_mngt+0x154>)
 801bc8e:	f106 0c20 	add.w	ip, r6, #32
 801bc92:	4635      	mov	r5, r6
 801bc94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801bc96:	6020      	str	r0, [r4, #0]
 801bc98:	6061      	str	r1, [r4, #4]
 801bc9a:	60a2      	str	r2, [r4, #8]
 801bc9c:	60e3      	str	r3, [r4, #12]
 801bc9e:	462e      	mov	r6, r5
 801bca0:	3410      	adds	r4, #16
 801bca2:	4565      	cmp	r5, ip
 801bca4:	d1f5      	bne.n	801bc92 <CST_network_status_test_mngt+0x76>
 801bca6:	882a      	ldrh	r2, [r5, #0]
 801bca8:	78ab      	ldrb	r3, [r5, #2]
 801bcaa:	8022      	strh	r2, [r4, #0]
 801bcac:	70a3      	strb	r3, [r4, #2]
 801bcae:	4c2c      	ldr	r4, [pc, #176]	; (801bd60 <CST_network_status_test_mngt+0x144>)
 801bcb0:	4620      	mov	r0, r4
 801bcb2:	f003 fb3a 	bl	801f32a <crs_strlen>
 801bcb6:	b283      	uxth	r3, r0
 801bcb8:	4622      	mov	r2, r4
 801bcba:	2101      	movs	r1, #1
 801bcbc:	2007      	movs	r0, #7
 801bcbe:	f003 fb77 	bl	801f3b0 <traceIF_itmPrint>
 801bcc2:	4620      	mov	r0, r4
 801bcc4:	f003 fb31 	bl	801f32a <crs_strlen>
 801bcc8:	b283      	uxth	r3, r0
 801bcca:	4622      	mov	r2, r4
 801bccc:	2101      	movs	r1, #1
 801bcce:	2007      	movs	r0, #7
 801bcd0:	f003 fb90 	bl	801f3f4 <traceIF_uartPrint>
    cst_context.register_retry_tempo_count = 0U;
 801bcd4:	2400      	movs	r4, #0
 801bcd6:	4b27      	ldr	r3, [pc, #156]	; (801bd74 <CST_network_status_test_mngt+0x158>)
 801bcd8:	81dc      	strh	r4, [r3, #14]
    CST_set_state(CST_NETWORK_STATUS_OK_STATE);
 801bcda:	2005      	movs	r0, #5
 801bcdc:	f7ff fb54 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_STATUS_OK_EVENT);
 801bce0:	2105      	movs	r1, #5
 801bce2:	4620      	mov	r0, r4
 801bce4:	f7ff fa8c 	bl	801b200 <CST_send_message>
 801bce8:	e7cb      	b.n	801bc82 <CST_network_status_test_mngt+0x66>
    cs_status = CST_set_signal_quality();
 801bcea:	f002 f95b 	bl	801dfa4 <CST_set_signal_quality>
    if (cs_status != CELLULAR_OK)
 801bcee:	2800      	cmp	r0, #0
 801bcf0:	d0c7      	beq.n	801bc82 <CST_network_status_test_mngt+0x66>
      (void)rtosalTimerStop(cst_network_status_timer_handle);
 801bcf2:	4b1e      	ldr	r3, [pc, #120]	; (801bd6c <CST_network_status_test_mngt+0x150>)
 801bcf4:	6818      	ldr	r0, [r3, #0]
 801bcf6:	f003 fa6c 	bl	801f1d2 <rtosalTimerStop>
      PRINT_CELLULAR_SERVICE("-----> BAD SIGNAL : Stop NW REG TIMEOUT TIMER\n\r")
 801bcfa:	4e1f      	ldr	r6, [pc, #124]	; (801bd78 <CST_network_status_test_mngt+0x15c>)
 801bcfc:	4d18      	ldr	r5, [pc, #96]	; (801bd60 <CST_network_status_test_mngt+0x144>)
 801bcfe:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bd02:	4634      	mov	r4, r6
 801bd04:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bd06:	6028      	str	r0, [r5, #0]
 801bd08:	6069      	str	r1, [r5, #4]
 801bd0a:	60aa      	str	r2, [r5, #8]
 801bd0c:	60eb      	str	r3, [r5, #12]
 801bd0e:	4626      	mov	r6, r4
 801bd10:	3510      	adds	r5, #16
 801bd12:	4564      	cmp	r4, ip
 801bd14:	d1f5      	bne.n	801bd02 <CST_network_status_test_mngt+0xe6>
 801bd16:	4c12      	ldr	r4, [pc, #72]	; (801bd60 <CST_network_status_test_mngt+0x144>)
 801bd18:	4620      	mov	r0, r4
 801bd1a:	f003 fb06 	bl	801f32a <crs_strlen>
 801bd1e:	b283      	uxth	r3, r0
 801bd20:	4622      	mov	r2, r4
 801bd22:	2101      	movs	r1, #1
 801bd24:	2007      	movs	r0, #7
 801bd26:	f003 fb43 	bl	801f3b0 <traceIF_itmPrint>
 801bd2a:	4620      	mov	r0, r4
 801bd2c:	f003 fafd 	bl	801f32a <crs_strlen>
 801bd30:	b283      	uxth	r3, r0
 801bd32:	4622      	mov	r2, r4
 801bd34:	2101      	movs	r1, #1
 801bd36:	2007      	movs	r0, #7
 801bd38:	f003 fb5c 	bl	801f3f4 <traceIF_uartPrint>
      cst_context.register_retry_tempo_count = 0U;
 801bd3c:	2400      	movs	r4, #0
 801bd3e:	4b0d      	ldr	r3, [pc, #52]	; (801bd74 <CST_network_status_test_mngt+0x158>)
 801bd40:	81dc      	strh	r4, [r3, #14]
      CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801bd42:	2003      	movs	r0, #3
 801bd44:	f7ff fb20 	bl	801b388 <CST_set_state>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_SIGNAL_QUALITY_TO_CHECK_EVENT);
 801bd48:	2103      	movs	r1, #3
 801bd4a:	4620      	mov	r0, r4
 801bd4c:	f7ff fa58 	bl	801b200 <CST_send_message>
 801bd50:	e797      	b.n	801bc82 <CST_network_status_test_mngt+0x66>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801bd52:	210d      	movs	r1, #13
 801bd54:	2000      	movs	r0, #0
 801bd56:	f7ff fa53 	bl	801b200 <CST_send_message>
 801bd5a:	e792      	b.n	801bc82 <CST_network_status_test_mngt+0x66>
 801bd5c:	08034bb0 	.word	0x08034bb0
 801bd60:	20004ddc 	.word	0x20004ddc
 801bd64:	200000c7 	.word	0x200000c7
 801bd68:	08034b54 	.word	0x08034b54
 801bd6c:	20004308 	.word	0x20004308
 801bd70:	08034be4 	.word	0x08034be4
 801bd74:	200000b0 	.word	0x200000b0
 801bd78:	08034c08 	.word	0x08034c08

0801bd7c <CST_waiting_for_network_status_state>:
{
 801bd7c:	b508      	push	{r3, lr}
  switch (autom_event)
 801bd7e:	3803      	subs	r0, #3
 801bd80:	2812      	cmp	r0, #18
 801bd82:	d80d      	bhi.n	801bda0 <CST_waiting_for_network_status_state+0x24>
 801bd84:	e8df f000 	tbb	[pc, r0]
 801bd88:	0c0c0a0a 	.word	0x0c0c0a0a
 801bd8c:	0c0c0c0c 	.word	0x0c0c0c0c
 801bd90:	0c0c0c0a 	.word	0x0c0c0c0a
 801bd94:	0c130c10 	.word	0x0c130c10
 801bd98:	0d0a      	.short	0x0d0a
 801bd9a:	16          	.byte	0x16
 801bd9b:	00          	.byte	0x00
      CST_network_status_test_mngt();
 801bd9c:	f7ff ff3e 	bl	801bc1c <CST_network_status_test_mngt>
}
 801bda0:	bd08      	pop	{r3, pc}
      CST_nw_reg_timeout_expiration_mngt();
 801bda2:	f7ff f8b3 	bl	801af0c <CST_nw_reg_timeout_expiration_mngt>
      break;
 801bda6:	e7fb      	b.n	801bda0 <CST_waiting_for_network_status_state+0x24>
      CST_target_state_cmd_event_mngt();
 801bda8:	f7ff fca0 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801bdac:	e7f8      	b.n	801bda0 <CST_waiting_for_network_status_state+0x24>
      CST_reboot_modem_event_mngt();
 801bdae:	f7ff fb55 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801bdb2:	e7f5      	b.n	801bda0 <CST_waiting_for_network_status_state+0x24>
      CST_fota_start_event_mngt();
 801bdb4:	f7ff fd56 	bl	801b864 <CST_fota_start_event_mngt>
}
 801bdb8:	e7f2      	b.n	801bda0 <CST_waiting_for_network_status_state+0x24>
	...

0801bdbc <CST_attach_modem_mngt>:
{
 801bdbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801bdc0:	b094      	sub	sp, #80	; 0x50
  PRINT_CELLULAR_SERVICE("*********** CST_attach_modem_mngt ********\n\r")
 801bdc2:	4c8f      	ldr	r4, [pc, #572]	; (801c000 <CST_attach_modem_mngt+0x244>)
 801bdc4:	4d8f      	ldr	r5, [pc, #572]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bdc6:	f104 0620 	add.w	r6, r4, #32
 801bdca:	46a4      	mov	ip, r4
 801bdcc:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801bdd0:	6028      	str	r0, [r5, #0]
 801bdd2:	6069      	str	r1, [r5, #4]
 801bdd4:	60aa      	str	r2, [r5, #8]
 801bdd6:	60eb      	str	r3, [r5, #12]
 801bdd8:	4664      	mov	r4, ip
 801bdda:	3510      	adds	r5, #16
 801bddc:	45b4      	cmp	ip, r6
 801bdde:	d1f4      	bne.n	801bdca <CST_attach_modem_mngt+0xe>
 801bde0:	cc07      	ldmia	r4!, {r0, r1, r2}
 801bde2:	6028      	str	r0, [r5, #0]
 801bde4:	6069      	str	r1, [r5, #4]
 801bde6:	60aa      	str	r2, [r5, #8]
 801bde8:	7823      	ldrb	r3, [r4, #0]
 801bdea:	732b      	strb	r3, [r5, #12]
 801bdec:	4c85      	ldr	r4, [pc, #532]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bdee:	4620      	mov	r0, r4
 801bdf0:	f003 fa9b 	bl	801f32a <crs_strlen>
 801bdf4:	b283      	uxth	r3, r0
 801bdf6:	4622      	mov	r2, r4
 801bdf8:	2101      	movs	r1, #1
 801bdfa:	2007      	movs	r0, #7
 801bdfc:	f003 fad8 	bl	801f3b0 <traceIF_itmPrint>
 801be00:	4620      	mov	r0, r4
 801be02:	f003 fa92 	bl	801f32a <crs_strlen>
 801be06:	b283      	uxth	r3, r0
 801be08:	4622      	mov	r2, r4
 801be0a:	2101      	movs	r1, #1
 801be0c:	2007      	movs	r0, #7
 801be0e:	f003 faf1 	bl	801f3f4 <traceIF_uartPrint>
  (void)memset((void *)&reg_status, 0, sizeof(CS_RegistrationStatus_t));
 801be12:	224e      	movs	r2, #78	; 0x4e
 801be14:	2100      	movs	r1, #0
 801be16:	4668      	mov	r0, sp
 801be18:	f00a fd89 	bl	802692e <memset>
  cs_status = osCDS_get_net_status(&reg_status);
 801be1c:	4668      	mov	r0, sp
 801be1e:	f7fe fec5 	bl	801abac <osCDS_get_net_status>
  if (cs_status == CELLULAR_OK)
 801be22:	b920      	cbnz	r0, 801be2e <CST_attach_modem_mngt+0x72>
    if (((uint16_t)reg_status.optional_fields_presence & (uint16_t)CS_RSF_FORMAT_PRESENT) != 0U)
 801be24:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 801be28:	f013 0f01 	tst.w	r3, #1
 801be2c:	d158      	bne.n	801bee0 <CST_attach_modem_mngt+0x124>
  cs_status = osCDS_get_attach_status(&cst_ctxt_attach_status);
 801be2e:	f10d 004f 	add.w	r0, sp, #79	; 0x4f
 801be32:	f7fe ff61 	bl	801acf8 <osCDS_get_attach_status>
  if (cs_status != CELLULAR_OK)
 801be36:	2800      	cmp	r0, #0
 801be38:	f040 808e 	bne.w	801bf58 <CST_attach_modem_mngt+0x19c>
    if (cst_ctxt_attach_status == CS_PS_ATTACHED)
 801be3c:	f89d 304f 	ldrb.w	r3, [sp, #79]	; 0x4f
 801be40:	2b01      	cmp	r3, #1
 801be42:	f000 80b3 	beq.w	801bfac <CST_attach_modem_mngt+0x1f0>
      PRINT_CELLULAR_SERVICE("===CST_attach_modem_mngt - NOT ATTACHED !!! ===\n\r")
 801be46:	4e70      	ldr	r6, [pc, #448]	; (801c008 <CST_attach_modem_mngt+0x24c>)
 801be48:	4d6e      	ldr	r5, [pc, #440]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801be4a:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801be4e:	4634      	mov	r4, r6
 801be50:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801be52:	6028      	str	r0, [r5, #0]
 801be54:	6069      	str	r1, [r5, #4]
 801be56:	60aa      	str	r2, [r5, #8]
 801be58:	60eb      	str	r3, [r5, #12]
 801be5a:	4626      	mov	r6, r4
 801be5c:	3510      	adds	r5, #16
 801be5e:	4564      	cmp	r4, ip
 801be60:	d1f5      	bne.n	801be4e <CST_attach_modem_mngt+0x92>
 801be62:	8823      	ldrh	r3, [r4, #0]
 801be64:	802b      	strh	r3, [r5, #0]
 801be66:	4c67      	ldr	r4, [pc, #412]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801be68:	4620      	mov	r0, r4
 801be6a:	f003 fa5e 	bl	801f32a <crs_strlen>
 801be6e:	b283      	uxth	r3, r0
 801be70:	4622      	mov	r2, r4
 801be72:	2101      	movs	r1, #1
 801be74:	2007      	movs	r0, #7
 801be76:	f003 fa9b 	bl	801f3b0 <traceIF_itmPrint>
 801be7a:	4620      	mov	r0, r4
 801be7c:	f003 fa55 	bl	801f32a <crs_strlen>
 801be80:	b283      	uxth	r3, r0
 801be82:	4622      	mov	r2, r4
 801be84:	2101      	movs	r1, #1
 801be86:	2007      	movs	r0, #7
 801be88:	f003 fab4 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_CELLULAR_SERVICE("===>CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE <===\n\r")
 801be8c:	4e5f      	ldr	r6, [pc, #380]	; (801c00c <CST_attach_modem_mngt+0x250>)
 801be8e:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801be92:	4635      	mov	r5, r6
 801be94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801be96:	6020      	str	r0, [r4, #0]
 801be98:	6061      	str	r1, [r4, #4]
 801be9a:	60a2      	str	r2, [r4, #8]
 801be9c:	60e3      	str	r3, [r4, #12]
 801be9e:	462e      	mov	r6, r5
 801bea0:	3410      	adds	r4, #16
 801bea2:	4565      	cmp	r5, ip
 801bea4:	d1f5      	bne.n	801be92 <CST_attach_modem_mngt+0xd6>
 801bea6:	882a      	ldrh	r2, [r5, #0]
 801bea8:	78ab      	ldrb	r3, [r5, #2]
 801beaa:	8022      	strh	r2, [r4, #0]
 801beac:	70a3      	strb	r3, [r4, #2]
 801beae:	4c55      	ldr	r4, [pc, #340]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801beb0:	4620      	mov	r0, r4
 801beb2:	f003 fa3a 	bl	801f32a <crs_strlen>
 801beb6:	b283      	uxth	r3, r0
 801beb8:	4622      	mov	r2, r4
 801beba:	2101      	movs	r1, #1
 801bebc:	2007      	movs	r0, #7
 801bebe:	f003 fa77 	bl	801f3b0 <traceIF_itmPrint>
 801bec2:	4620      	mov	r0, r4
 801bec4:	f003 fa31 	bl	801f32a <crs_strlen>
 801bec8:	b283      	uxth	r3, r0
 801beca:	4622      	mov	r2, r4
 801becc:	2101      	movs	r1, #1
 801bece:	2007      	movs	r0, #7
 801bed0:	f003 fa90 	bl	801f3f4 <traceIF_uartPrint>
      CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801bed4:	2003      	movs	r0, #3
 801bed6:	f7ff fa57 	bl	801b388 <CST_set_state>
}
 801beda:	b014      	add	sp, #80	; 0x50
 801bedc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      (void)dc_com_read(&dc_com_db,  DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801bee0:	f8df 8148 	ldr.w	r8, [pc, #328]	; 801c02c <CST_attach_modem_mngt+0x270>
 801bee4:	4e4a      	ldr	r6, [pc, #296]	; (801c010 <CST_attach_modem_mngt+0x254>)
 801bee6:	4f4b      	ldr	r7, [pc, #300]	; (801c014 <CST_attach_modem_mngt+0x258>)
 801bee8:	23f4      	movs	r3, #244	; 0xf4
 801beea:	4632      	mov	r2, r6
 801beec:	f8b8 1000 	ldrh.w	r1, [r8]
 801bef0:	4638      	mov	r0, r7
 801bef2:	f006 f91d 	bl	8022130 <dc_com_read>
      (void)memcpy(cst_cellular_info.mno_name, reg_status.operator_name, DC_MAX_SIZE_MNO_NAME - 1U);
 801bef6:	f106 0430 	add.w	r4, r6, #48	; 0x30
 801befa:	ad03      	add	r5, sp, #12
 801befc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801befe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801bf00:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 801bf04:	c407      	stmia	r4!, {r0, r1, r2}
 801bf06:	f824 3b02 	strh.w	r3, [r4], #2
 801bf0a:	0c1b      	lsrs	r3, r3, #16
 801bf0c:	7023      	strb	r3, [r4, #0]
      cst_cellular_info.mno_name[DC_MAX_SIZE_MNO_NAME - 1U] = 0U;  /* to avoid a non null terminated string */
 801bf0e:	2300      	movs	r3, #0
 801bf10:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
      cst_cellular_info.rt_state              = DC_SERVICE_ON;
 801bf14:	2507      	movs	r5, #7
 801bf16:	7235      	strb	r5, [r6, #8]
      (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801bf18:	23f4      	movs	r3, #244	; 0xf4
 801bf1a:	4632      	mov	r2, r6
 801bf1c:	f8b8 1000 	ldrh.w	r1, [r8]
 801bf20:	4638      	mov	r0, r7
 801bf22:	f006 f8b9 	bl	8022098 <dc_com_write>
      PRINT_CELLULAR_SERVICE(" ->operator_name = %s\n\r", reg_status.operator_name)
 801bf26:	4c37      	ldr	r4, [pc, #220]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bf28:	aa03      	add	r2, sp, #12
 801bf2a:	493b      	ldr	r1, [pc, #236]	; (801c018 <CST_attach_modem_mngt+0x25c>)
 801bf2c:	4620      	mov	r0, r4
 801bf2e:	f00a fc8b 	bl	8026848 <sprintf>
 801bf32:	4620      	mov	r0, r4
 801bf34:	f003 f9f9 	bl	801f32a <crs_strlen>
 801bf38:	b283      	uxth	r3, r0
 801bf3a:	4622      	mov	r2, r4
 801bf3c:	2101      	movs	r1, #1
 801bf3e:	4628      	mov	r0, r5
 801bf40:	f003 fa36 	bl	801f3b0 <traceIF_itmPrint>
 801bf44:	4620      	mov	r0, r4
 801bf46:	f003 f9f0 	bl	801f32a <crs_strlen>
 801bf4a:	b283      	uxth	r3, r0
 801bf4c:	4622      	mov	r2, r4
 801bf4e:	2101      	movs	r1, #1
 801bf50:	4628      	mov	r0, r5
 801bf52:	f003 fa4f 	bl	801f3f4 <traceIF_uartPrint>
 801bf56:	e76a      	b.n	801be2e <CST_attach_modem_mngt+0x72>
    PRINT_CELLULAR_SERVICE("*********** CST_attach_modem_mngt fail ********\n\r")
 801bf58:	4e30      	ldr	r6, [pc, #192]	; (801c01c <CST_attach_modem_mngt+0x260>)
 801bf5a:	4d2a      	ldr	r5, [pc, #168]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bf5c:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bf60:	4634      	mov	r4, r6
 801bf62:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bf64:	6028      	str	r0, [r5, #0]
 801bf66:	6069      	str	r1, [r5, #4]
 801bf68:	60aa      	str	r2, [r5, #8]
 801bf6a:	60eb      	str	r3, [r5, #12]
 801bf6c:	4626      	mov	r6, r4
 801bf6e:	3510      	adds	r5, #16
 801bf70:	4564      	cmp	r4, ip
 801bf72:	d1f5      	bne.n	801bf60 <CST_attach_modem_mngt+0x1a4>
 801bf74:	8823      	ldrh	r3, [r4, #0]
 801bf76:	802b      	strh	r3, [r5, #0]
 801bf78:	4c22      	ldr	r4, [pc, #136]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bf7a:	4620      	mov	r0, r4
 801bf7c:	f003 f9d5 	bl	801f32a <crs_strlen>
 801bf80:	b283      	uxth	r3, r0
 801bf82:	4622      	mov	r2, r4
 801bf84:	2101      	movs	r1, #1
 801bf86:	2007      	movs	r0, #7
 801bf88:	f003 fa12 	bl	801f3b0 <traceIF_itmPrint>
 801bf8c:	4620      	mov	r0, r4
 801bf8e:	f003 f9cc 	bl	801f32a <crs_strlen>
 801bf92:	b283      	uxth	r3, r0
 801bf94:	4622      	mov	r2, r4
 801bf96:	2101      	movs	r1, #1
 801bf98:	2007      	movs	r0, #7
 801bf9a:	f003 fa2b 	bl	801f3f4 <traceIF_uartPrint>
    CST_config_fail(((uint8_t *)"CS_get_attach_status FAIL"),
 801bf9e:	2305      	movs	r3, #5
 801bfa0:	4a1f      	ldr	r2, [pc, #124]	; (801c020 <CST_attach_modem_mngt+0x264>)
 801bfa2:	2106      	movs	r1, #6
 801bfa4:	481f      	ldr	r0, [pc, #124]	; (801c024 <CST_attach_modem_mngt+0x268>)
 801bfa6:	f001 fb61 	bl	801d66c <CST_config_fail>
 801bfaa:	e796      	b.n	801beda <CST_attach_modem_mngt+0x11e>
      PRINT_CELLULAR_SERVICE("*********** CST_attach_modem_mngt OK ********\n\r")
 801bfac:	4e1e      	ldr	r6, [pc, #120]	; (801c028 <CST_attach_modem_mngt+0x26c>)
 801bfae:	4d15      	ldr	r5, [pc, #84]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bfb0:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 801bfb4:	4634      	mov	r4, r6
 801bfb6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801bfb8:	6028      	str	r0, [r5, #0]
 801bfba:	6069      	str	r1, [r5, #4]
 801bfbc:	60aa      	str	r2, [r5, #8]
 801bfbe:	60eb      	str	r3, [r5, #12]
 801bfc0:	4626      	mov	r6, r4
 801bfc2:	3510      	adds	r5, #16
 801bfc4:	4564      	cmp	r4, ip
 801bfc6:	d1f5      	bne.n	801bfb4 <CST_attach_modem_mngt+0x1f8>
 801bfc8:	4c0e      	ldr	r4, [pc, #56]	; (801c004 <CST_attach_modem_mngt+0x248>)
 801bfca:	4620      	mov	r0, r4
 801bfcc:	f003 f9ad 	bl	801f32a <crs_strlen>
 801bfd0:	b283      	uxth	r3, r0
 801bfd2:	4622      	mov	r2, r4
 801bfd4:	2101      	movs	r1, #1
 801bfd6:	2007      	movs	r0, #7
 801bfd8:	f003 f9ea 	bl	801f3b0 <traceIF_itmPrint>
 801bfdc:	4620      	mov	r0, r4
 801bfde:	f003 f9a4 	bl	801f32a <crs_strlen>
 801bfe2:	b283      	uxth	r3, r0
 801bfe4:	4622      	mov	r2, r4
 801bfe6:	2101      	movs	r1, #1
 801bfe8:	2007      	movs	r0, #7
 801bfea:	f003 fa03 	bl	801f3f4 <traceIF_uartPrint>
      CST_set_state(CST_MODEM_REGISTERED_STATE);
 801bfee:	2006      	movs	r0, #6
 801bff0:	f7ff f9ca 	bl	801b388 <CST_set_state>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_ATTACHED_EVENT);
 801bff4:	2106      	movs	r1, #6
 801bff6:	2000      	movs	r0, #0
 801bff8:	f7ff f902 	bl	801b200 <CST_send_message>
 801bffc:	e76d      	b.n	801beda <CST_attach_modem_mngt+0x11e>
 801bffe:	bf00      	nop
 801c000:	08034c38 	.word	0x08034c38
 801c004:	20004ddc 	.word	0x20004ddc
 801c008:	08034d00 	.word	0x08034d00
 801c00c:	08034d34 	.word	0x08034d34
 801c010:	2000406c 	.word	0x2000406c
 801c014:	200058b0 	.word	0x200058b0
 801c018:	08034c68 	.word	0x08034c68
 801c01c:	08034c80 	.word	0x08034c80
 801c020:	200000c4 	.word	0x200000c4
 801c024:	08034cb4 	.word	0x08034cb4
 801c028:	08034cd0 	.word	0x08034cd0
 801c02c:	20000236 	.word	0x20000236

0801c030 <CST_network_status_ok_state>:
{
 801c030:	b508      	push	{r3, lr}
  switch (autom_event)
 801c032:	3805      	subs	r0, #5
 801c034:	2810      	cmp	r0, #16
 801c036:	d80c      	bhi.n	801c052 <CST_network_status_ok_state+0x22>
 801c038:	e8df f000 	tbb	[pc, r0]
 801c03c:	0b0b0b09 	.word	0x0b0b0b09
 801c040:	0b0b0b0b 	.word	0x0b0b0b0b
 801c044:	0b0c0b0b 	.word	0x0b0c0b0b
 801c048:	0b0b0b0f 	.word	0x0b0b0b0f
 801c04c:	12          	.byte	0x12
 801c04d:	00          	.byte	0x00
      CST_attach_modem_mngt();
 801c04e:	f7ff feb5 	bl	801bdbc <CST_attach_modem_mngt>
}
 801c052:	bd08      	pop	{r3, pc}
      CST_target_state_cmd_event_mngt();
 801c054:	f7ff fb4a 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801c058:	e7fb      	b.n	801c052 <CST_network_status_ok_state+0x22>
      CST_reboot_modem_event_mngt();
 801c05a:	f7ff f9ff 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801c05e:	e7f8      	b.n	801c052 <CST_network_status_ok_state+0x22>
      CST_fota_start_event_mngt();
 801c060:	f7ff fc00 	bl	801b864 <CST_fota_start_event_mngt>
}
 801c064:	e7f5      	b.n	801c052 <CST_network_status_ok_state+0x22>
	...

0801c068 <CST_modem_activate_pdn_mngt>:
{
 801c068:	b570      	push	{r4, r5, r6, lr}
  CST_set_state(CST_MODEM_PDN_ACTIVATING_STATE);
 801c06a:	2007      	movs	r0, #7
 801c06c:	f7ff f98c 	bl	801b388 <CST_set_state>
  (void)osCDS_set_default_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid));
 801c070:	4e3a      	ldr	r6, [pc, #232]	; (801c15c <CST_modem_activate_pdn_mngt+0xf4>)
 801c072:	7c33      	ldrb	r3, [r6, #16]
 801c074:	4c3a      	ldr	r4, [pc, #232]	; (801c160 <CST_modem_activate_pdn_mngt+0xf8>)
 801c076:	2562      	movs	r5, #98	; 0x62
 801c078:	fb05 4303 	mla	r3, r5, r3, r4
 801c07c:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801c080:	f7fe f98b 	bl	801a39a <cst_get_cid_value>
 801c084:	f7fe fe8c 	bl	801ada0 <osCDS_set_default_pdn>
  (void)osCDS_register_pdn_event(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801c088:	7c33      	ldrb	r3, [r6, #16]
 801c08a:	fb05 4403 	mla	r4, r5, r3, r4
 801c08e:	f894 002c 	ldrb.w	r0, [r4, #44]	; 0x2c
 801c092:	f7fe f982 	bl	801a39a <cst_get_cid_value>
 801c096:	4933      	ldr	r1, [pc, #204]	; (801c164 <CST_modem_activate_pdn_mngt+0xfc>)
 801c098:	f7fe fe6c 	bl	801ad74 <osCDS_register_pdn_event>
  cs_status = osCDS_activate_pdn(CS_PDN_CONFIG_DEFAULT);
 801c09c:	200b      	movs	r0, #11
 801c09e:	f7fe fe93 	bl	801adc8 <osCDS_activate_pdn>
  if (cs_status != CELLULAR_OK)
 801c0a2:	2800      	cmp	r0, #0
 801c0a4:	d053      	beq.n	801c14e <CST_modem_activate_pdn_mngt+0xe6>
    if (cst_nfmc_context.active == false)
 801c0a6:	4b30      	ldr	r3, [pc, #192]	; (801c168 <CST_modem_activate_pdn_mngt+0x100>)
 801c0a8:	781b      	ldrb	r3, [r3, #0]
 801c0aa:	bb4b      	cbnz	r3, 801c100 <CST_modem_activate_pdn_mngt+0x98>
      (void)rtosalTimerStart(cst_pdn_activate_retry_timer_handle, CST_PDN_ACTIVATE_RETRY_DELAY);
 801c0ac:	f247 5130 	movw	r1, #30000	; 0x7530
 801c0b0:	4b2e      	ldr	r3, [pc, #184]	; (801c16c <CST_modem_activate_pdn_mngt+0x104>)
 801c0b2:	6818      	ldr	r0, [r3, #0]
 801c0b4:	f003 f889 	bl	801f1ca <rtosalTimerStart>
      PRINT_CELLULAR_SERVICE("-----> CST_modem_activate_pdn_mngt NOK - retry tempo  : %d\n\r",
 801c0b8:	4c2d      	ldr	r4, [pc, #180]	; (801c170 <CST_modem_activate_pdn_mngt+0x108>)
 801c0ba:	f247 5230 	movw	r2, #30000	; 0x7530
 801c0be:	492d      	ldr	r1, [pc, #180]	; (801c174 <CST_modem_activate_pdn_mngt+0x10c>)
 801c0c0:	4620      	mov	r0, r4
 801c0c2:	f00a fbc1 	bl	8026848 <sprintf>
 801c0c6:	4620      	mov	r0, r4
 801c0c8:	f003 f92f 	bl	801f32a <crs_strlen>
 801c0cc:	b283      	uxth	r3, r0
 801c0ce:	4622      	mov	r2, r4
 801c0d0:	2101      	movs	r1, #1
 801c0d2:	2007      	movs	r0, #7
 801c0d4:	f003 f96c 	bl	801f3b0 <traceIF_itmPrint>
 801c0d8:	4620      	mov	r0, r4
 801c0da:	f003 f926 	bl	801f32a <crs_strlen>
 801c0de:	b283      	uxth	r3, r0
 801c0e0:	4622      	mov	r2, r4
 801c0e2:	2101      	movs	r1, #1
 801c0e4:	2007      	movs	r0, #7
 801c0e6:	f003 f985 	bl	801f3f4 <traceIF_uartPrint>
    cst_context.activate_pdn_nfmc_tempo_count++;
 801c0ea:	4a1c      	ldr	r2, [pc, #112]	; (801c15c <CST_modem_activate_pdn_mngt+0xf4>)
 801c0ec:	8993      	ldrh	r3, [r2, #12]
 801c0ee:	3301      	adds	r3, #1
 801c0f0:	b29b      	uxth	r3, r3
 801c0f2:	8193      	strh	r3, [r2, #12]
    if (cst_context.activate_pdn_nfmc_tempo_count >= CST_NFMC_TEMPO_NB)
 801c0f4:	2b06      	cmp	r3, #6
 801c0f6:	d902      	bls.n	801c0fe <CST_modem_activate_pdn_mngt+0x96>
      cst_context.activate_pdn_nfmc_tempo_count = 0U;
 801c0f8:	4613      	mov	r3, r2
 801c0fa:	2200      	movs	r2, #0
 801c0fc:	819a      	strh	r2, [r3, #12]
}
 801c0fe:	bd70      	pop	{r4, r5, r6, pc}
                             cst_nfmc_context.tempo[cst_context.activate_pdn_nfmc_tempo_count]);
 801c100:	4d16      	ldr	r5, [pc, #88]	; (801c15c <CST_modem_activate_pdn_mngt+0xf4>)
 801c102:	89ab      	ldrh	r3, [r5, #12]
      (void)rtosalTimerStart(cst_pdn_activate_retry_timer_handle,
 801c104:	4c18      	ldr	r4, [pc, #96]	; (801c168 <CST_modem_activate_pdn_mngt+0x100>)
 801c106:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 801c10a:	6859      	ldr	r1, [r3, #4]
 801c10c:	4b17      	ldr	r3, [pc, #92]	; (801c16c <CST_modem_activate_pdn_mngt+0x104>)
 801c10e:	6818      	ldr	r0, [r3, #0]
 801c110:	f003 f85b 	bl	801f1ca <rtosalTimerStart>
      PRINT_CELLULAR_SERVICE("-----> CST_modem_activate_pdn_mngt NOK - retry tempo %d : %ld\n\r",
 801c114:	89aa      	ldrh	r2, [r5, #12]
 801c116:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 801c11a:	4c15      	ldr	r4, [pc, #84]	; (801c170 <CST_modem_activate_pdn_mngt+0x108>)
 801c11c:	685b      	ldr	r3, [r3, #4]
 801c11e:	3201      	adds	r2, #1
 801c120:	4915      	ldr	r1, [pc, #84]	; (801c178 <CST_modem_activate_pdn_mngt+0x110>)
 801c122:	4620      	mov	r0, r4
 801c124:	f00a fb90 	bl	8026848 <sprintf>
 801c128:	4620      	mov	r0, r4
 801c12a:	f003 f8fe 	bl	801f32a <crs_strlen>
 801c12e:	b283      	uxth	r3, r0
 801c130:	4622      	mov	r2, r4
 801c132:	2101      	movs	r1, #1
 801c134:	2007      	movs	r0, #7
 801c136:	f003 f93b 	bl	801f3b0 <traceIF_itmPrint>
 801c13a:	4620      	mov	r0, r4
 801c13c:	f003 f8f5 	bl	801f32a <crs_strlen>
 801c140:	b283      	uxth	r3, r0
 801c142:	4622      	mov	r2, r4
 801c144:	2101      	movs	r1, #1
 801c146:	2007      	movs	r0, #7
 801c148:	f003 f954 	bl	801f3f4 <traceIF_uartPrint>
 801c14c:	e7cd      	b.n	801c0ea <CST_modem_activate_pdn_mngt+0x82>
    cst_context.activate_pdn_nfmc_tempo_count = 0U;
 801c14e:	2000      	movs	r0, #0
 801c150:	4b02      	ldr	r3, [pc, #8]	; (801c15c <CST_modem_activate_pdn_mngt+0xf4>)
 801c152:	8198      	strh	r0, [r3, #12]
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_PDP_ACTIVATED_EVENT);
 801c154:	2107      	movs	r1, #7
 801c156:	f7ff f853 	bl	801b200 <CST_send_message>
}
 801c15a:	e7d0      	b.n	801c0fe <CST_modem_activate_pdn_mngt+0x96>
 801c15c:	200000b0 	.word	0x200000b0
 801c160:	20004160 	.word	0x20004160
 801c164:	0801b339 	.word	0x0801b339
 801c168:	2000430c 	.word	0x2000430c
 801c16c:	2000432c 	.word	0x2000432c
 801c170:	20004ddc 	.word	0x20004ddc
 801c174:	08034d68 	.word	0x08034d68
 801c178:	08034da8 	.word	0x08034da8

0801c17c <CST_modem_registered_state>:
{
 801c17c:	b508      	push	{r3, lr}
  switch (autom_event)
 801c17e:	3806      	subs	r0, #6
 801c180:	280f      	cmp	r0, #15
 801c182:	d80b      	bhi.n	801c19c <CST_modem_registered_state+0x20>
 801c184:	e8df f000 	tbb	[pc, r0]
 801c188:	0a0a0a08 	.word	0x0a0a0a08
 801c18c:	0a0a0a0a 	.word	0x0a0a0a0a
 801c190:	110a0e0a 	.word	0x110a0e0a
 801c194:	140a0b0a 	.word	0x140a0b0a
      CST_modem_activate_pdn_mngt();
 801c198:	f7ff ff66 	bl	801c068 <CST_modem_activate_pdn_mngt>
}
 801c19c:	bd08      	pop	{r3, pc}
      CST_network_event_mngt();
 801c19e:	f7ff fca7 	bl	801baf0 <CST_network_event_mngt>
      break;
 801c1a2:	e7fb      	b.n	801c19c <CST_modem_registered_state+0x20>
      CST_target_state_cmd_event_mngt();
 801c1a4:	f7ff faa2 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801c1a8:	e7f8      	b.n	801c19c <CST_modem_registered_state+0x20>
      CST_reboot_modem_event_mngt();
 801c1aa:	f7ff f957 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801c1ae:	e7f5      	b.n	801c19c <CST_modem_registered_state+0x20>
      CST_fota_start_event_mngt();
 801c1b0:	f7ff fb58 	bl	801b864 <CST_fota_start_event_mngt>
}
 801c1b4:	e7f2      	b.n	801c19c <CST_modem_registered_state+0x20>
	...

0801c1b8 <CST_pdn_event_nw_detach_mngt>:
{
 801c1b8:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_pdn_event_nw_detach_mngt ********\n\r")
 801c1ba:	4d2c      	ldr	r5, [pc, #176]	; (801c26c <CST_pdn_event_nw_detach_mngt+0xb4>)
 801c1bc:	4c2c      	ldr	r4, [pc, #176]	; (801c270 <CST_pdn_event_nw_detach_mngt+0xb8>)
 801c1be:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801c1c2:	46ac      	mov	ip, r5
 801c1c4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801c1c8:	6020      	str	r0, [r4, #0]
 801c1ca:	6061      	str	r1, [r4, #4]
 801c1cc:	60a2      	str	r2, [r4, #8]
 801c1ce:	60e3      	str	r3, [r4, #12]
 801c1d0:	4665      	mov	r5, ip
 801c1d2:	3410      	adds	r4, #16
 801c1d4:	45f4      	cmp	ip, lr
 801c1d6:	d1f4      	bne.n	801c1c2 <CST_pdn_event_nw_detach_mngt+0xa>
 801c1d8:	f8dc 0000 	ldr.w	r0, [ip]
 801c1dc:	6020      	str	r0, [r4, #0]
 801c1de:	4c24      	ldr	r4, [pc, #144]	; (801c270 <CST_pdn_event_nw_detach_mngt+0xb8>)
 801c1e0:	4620      	mov	r0, r4
 801c1e2:	f003 f8a2 	bl	801f32a <crs_strlen>
 801c1e6:	b283      	uxth	r3, r0
 801c1e8:	4622      	mov	r2, r4
 801c1ea:	2101      	movs	r1, #1
 801c1ec:	2007      	movs	r0, #7
 801c1ee:	f003 f8df 	bl	801f3b0 <traceIF_itmPrint>
 801c1f2:	4620      	mov	r0, r4
 801c1f4:	f003 f899 	bl	801f32a <crs_strlen>
 801c1f8:	b283      	uxth	r3, r0
 801c1fa:	4622      	mov	r2, r4
 801c1fc:	2101      	movs	r1, #1
 801c1fe:	2007      	movs	r0, #7
 801c200:	f003 f8f8 	bl	801f3f4 <traceIF_uartPrint>
  if (cst_context.current_state == CST_MODEM_DATA_READY_STATE)
 801c204:	4b1b      	ldr	r3, [pc, #108]	; (801c274 <CST_pdn_event_nw_detach_mngt+0xbc>)
 801c206:	881b      	ldrh	r3, [r3, #0]
 801c208:	2b08      	cmp	r3, #8
 801c20a:	d024      	beq.n	801c256 <CST_pdn_event_nw_detach_mngt+0x9e>
  ret = CST_get_network_status();
 801c20c:	f002 f810 	bl	801e230 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801c210:	b1e8      	cbz	r0, 801c24e <CST_pdn_event_nw_detach_mngt+0x96>
  else if (ret == CST_NOT_REGISTERED)
 801c212:	2801      	cmp	r0, #1
 801c214:	d024      	beq.n	801c260 <CST_pdn_event_nw_detach_mngt+0xa8>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c216:	2100      	movs	r1, #0
 801c218:	2003      	movs	r0, #3
 801c21a:	f001 f9e7 	bl	801d5ec <CST_data_cache_cellular_info_set>
    PRINT_CELLULAR_SERVICE("******** CST_pdn_event_nw_detach_mngt: osCDS_get_net_status FAIL ****\n\r")
 801c21e:	4c14      	ldr	r4, [pc, #80]	; (801c270 <CST_pdn_event_nw_detach_mngt+0xb8>)
 801c220:	2248      	movs	r2, #72	; 0x48
 801c222:	4915      	ldr	r1, [pc, #84]	; (801c278 <CST_pdn_event_nw_detach_mngt+0xc0>)
 801c224:	4620      	mov	r0, r4
 801c226:	f00a fc5f 	bl	8026ae8 <memcpy>
 801c22a:	4620      	mov	r0, r4
 801c22c:	f003 f87d 	bl	801f32a <crs_strlen>
 801c230:	b283      	uxth	r3, r0
 801c232:	4622      	mov	r2, r4
 801c234:	2101      	movs	r1, #1
 801c236:	2007      	movs	r0, #7
 801c238:	f003 f8ba 	bl	801f3b0 <traceIF_itmPrint>
 801c23c:	4620      	mov	r0, r4
 801c23e:	f003 f874 	bl	801f32a <crs_strlen>
 801c242:	b283      	uxth	r3, r0
 801c244:	4622      	mov	r2, r4
 801c246:	2101      	movs	r1, #1
 801c248:	2007      	movs	r0, #7
 801c24a:	f003 f8d3 	bl	801f3f4 <traceIF_uartPrint>
  CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801c24e:	2004      	movs	r0, #4
 801c250:	f7ff f89a 	bl	801b388 <CST_set_state>
}
 801c254:	bd38      	pop	{r3, r4, r5, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c256:	2100      	movs	r1, #0
 801c258:	2003      	movs	r0, #3
 801c25a:	f001 f9c7 	bl	801d5ec <CST_data_cache_cellular_info_set>
 801c25e:	e7d5      	b.n	801c20c <CST_pdn_event_nw_detach_mngt+0x54>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c260:	2100      	movs	r1, #0
 801c262:	2003      	movs	r0, #3
 801c264:	f001 f9c2 	bl	801d5ec <CST_data_cache_cellular_info_set>
 801c268:	e7f1      	b.n	801c24e <CST_pdn_event_nw_detach_mngt+0x96>
 801c26a:	bf00      	nop
 801c26c:	08034de8 	.word	0x08034de8
 801c270:	20004ddc 	.word	0x20004ddc
 801c274:	200000b0 	.word	0x200000b0
 801c278:	08034e1c 	.word	0x08034e1c

0801c27c <CST_pdn_event_mngt>:
{
 801c27c:	b538      	push	{r3, r4, r5, lr}
  CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c27e:	2100      	movs	r1, #0
 801c280:	2003      	movs	r0, #3
 801c282:	f001 f9b3 	bl	801d5ec <CST_data_cache_cellular_info_set>
  if (cst_context.pdn_status == CS_PDN_EVENT_NW_DETACH)
 801c286:	4b20      	ldr	r3, [pc, #128]	; (801c308 <CST_pdn_event_mngt+0x8c>)
 801c288:	78db      	ldrb	r3, [r3, #3]
 801c28a:	2b01      	cmp	r3, #1
 801c28c:	d00b      	beq.n	801c2a6 <CST_pdn_event_mngt+0x2a>
    || (cst_context.pdn_status == CS_PDN_EVENT_NW_PDN_DEACT))
 801c28e:	3b02      	subs	r3, #2
 801c290:	b2db      	uxtb	r3, r3
  else if (
 801c292:	2b01      	cmp	r3, #1
 801c294:	d90a      	bls.n	801c2ac <CST_pdn_event_mngt+0x30>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801c296:	2004      	movs	r0, #4
 801c298:	f7ff f876 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_CALLBACK_EVENT);
 801c29c:	2113      	movs	r1, #19
 801c29e:	2000      	movs	r0, #0
 801c2a0:	f7fe ffae 	bl	801b200 <CST_send_message>
}
 801c2a4:	bd38      	pop	{r3, r4, r5, pc}
    CST_pdn_event_nw_detach_mngt();
 801c2a6:	f7ff ff87 	bl	801c1b8 <CST_pdn_event_nw_detach_mngt>
 801c2aa:	e7fb      	b.n	801c2a4 <CST_pdn_event_mngt+0x28>
    PRINT_CELLULAR_SERVICE("=========CST_pdn_event_mngt CS_PDN_EVENT_NW_DEACT\n\r")
 801c2ac:	4d17      	ldr	r5, [pc, #92]	; (801c30c <CST_pdn_event_mngt+0x90>)
 801c2ae:	4c18      	ldr	r4, [pc, #96]	; (801c310 <CST_pdn_event_mngt+0x94>)
 801c2b0:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801c2b4:	46ac      	mov	ip, r5
 801c2b6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801c2ba:	6020      	str	r0, [r4, #0]
 801c2bc:	6061      	str	r1, [r4, #4]
 801c2be:	60a2      	str	r2, [r4, #8]
 801c2c0:	60e3      	str	r3, [r4, #12]
 801c2c2:	4665      	mov	r5, ip
 801c2c4:	3410      	adds	r4, #16
 801c2c6:	45f4      	cmp	ip, lr
 801c2c8:	d1f4      	bne.n	801c2b4 <CST_pdn_event_mngt+0x38>
 801c2ca:	f8dc 0000 	ldr.w	r0, [ip]
 801c2ce:	6020      	str	r0, [r4, #0]
 801c2d0:	4c0f      	ldr	r4, [pc, #60]	; (801c310 <CST_pdn_event_mngt+0x94>)
 801c2d2:	4620      	mov	r0, r4
 801c2d4:	f003 f829 	bl	801f32a <crs_strlen>
 801c2d8:	b283      	uxth	r3, r0
 801c2da:	4622      	mov	r2, r4
 801c2dc:	2101      	movs	r1, #1
 801c2de:	2007      	movs	r0, #7
 801c2e0:	f003 f866 	bl	801f3b0 <traceIF_itmPrint>
 801c2e4:	4620      	mov	r0, r4
 801c2e6:	f003 f820 	bl	801f32a <crs_strlen>
 801c2ea:	b283      	uxth	r3, r0
 801c2ec:	4622      	mov	r2, r4
 801c2ee:	2101      	movs	r1, #1
 801c2f0:	2007      	movs	r0, #7
 801c2f2:	f003 f87f 	bl	801f3f4 <traceIF_uartPrint>
    CST_set_state(CST_MODEM_REGISTERED_STATE);
 801c2f6:	2006      	movs	r0, #6
 801c2f8:	f7ff f846 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_ATTACHED_EVENT);
 801c2fc:	2106      	movs	r1, #6
 801c2fe:	2000      	movs	r0, #0
 801c300:	f7fe ff7e 	bl	801b200 <CST_send_message>
 801c304:	e7ce      	b.n	801c2a4 <CST_pdn_event_mngt+0x28>
 801c306:	bf00      	nop
 801c308:	200000b0 	.word	0x200000b0
 801c30c:	08034e64 	.word	0x08034e64
 801c310:	20004ddc 	.word	0x20004ddc

0801c314 <CST_data_ready_state_network_event_mngt>:
{
 801c314:	b510      	push	{r4, lr}
  ret = CST_get_network_status();
 801c316:	f001 ff8b 	bl	801e230 <CST_get_network_status>
  if (ret == CST_NET_REGISTERED)
 801c31a:	b330      	cbz	r0, 801c36a <CST_data_ready_state_network_event_mngt+0x56>
  else if (ret == CST_NOT_REGISTERED)
 801c31c:	2801      	cmp	r0, #1
 801c31e:	d028      	beq.n	801c372 <CST_data_ready_state_network_event_mngt+0x5e>
  else if (ret == CST_NET_UNKNOWN)
 801c320:	2803      	cmp	r0, #3
 801c322:	d02e      	beq.n	801c382 <CST_data_ready_state_network_event_mngt+0x6e>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c324:	2100      	movs	r1, #0
 801c326:	2003      	movs	r0, #3
 801c328:	f001 f960 	bl	801d5ec <CST_data_cache_cellular_info_set>
    PRINT_CELLULAR_SERVICE("******** CST_network_event_mngt: osCDS_get_net_status FAIL ****\n\r")
 801c32c:	4c17      	ldr	r4, [pc, #92]	; (801c38c <CST_data_ready_state_network_event_mngt+0x78>)
 801c32e:	2242      	movs	r2, #66	; 0x42
 801c330:	4917      	ldr	r1, [pc, #92]	; (801c390 <CST_data_ready_state_network_event_mngt+0x7c>)
 801c332:	4620      	mov	r0, r4
 801c334:	f00a fbd8 	bl	8026ae8 <memcpy>
 801c338:	4620      	mov	r0, r4
 801c33a:	f002 fff6 	bl	801f32a <crs_strlen>
 801c33e:	b283      	uxth	r3, r0
 801c340:	4622      	mov	r2, r4
 801c342:	2101      	movs	r1, #1
 801c344:	2007      	movs	r0, #7
 801c346:	f003 f833 	bl	801f3b0 <traceIF_itmPrint>
 801c34a:	4620      	mov	r0, r4
 801c34c:	f002 ffed 	bl	801f32a <crs_strlen>
 801c350:	b283      	uxth	r3, r0
 801c352:	4622      	mov	r2, r4
 801c354:	2101      	movs	r1, #1
 801c356:	2007      	movs	r0, #7
 801c358:	f003 f84c 	bl	801f3f4 <traceIF_uartPrint>
    CST_config_fail(((uint8_t *)"CST_network_status_test_mngt"),
 801c35c:	2305      	movs	r3, #5
 801c35e:	4a0d      	ldr	r2, [pc, #52]	; (801c394 <CST_data_ready_state_network_event_mngt+0x80>)
 801c360:	4619      	mov	r1, r3
 801c362:	480d      	ldr	r0, [pc, #52]	; (801c398 <CST_data_ready_state_network_event_mngt+0x84>)
 801c364:	f001 f982 	bl	801d66c <CST_config_fail>
}
 801c368:	bd10      	pop	{r4, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801c36a:	210d      	movs	r1, #13
 801c36c:	f7fe ff48 	bl	801b200 <CST_send_message>
 801c370:	e7fa      	b.n	801c368 <CST_data_ready_state_network_event_mngt+0x54>
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c372:	2100      	movs	r1, #0
 801c374:	2003      	movs	r0, #3
 801c376:	f001 f939 	bl	801d5ec <CST_data_cache_cellular_info_set>
    CST_set_state(CST_WAITING_FOR_NETWORK_STATUS_STATE);
 801c37a:	2004      	movs	r0, #4
 801c37c:	f7ff f804 	bl	801b388 <CST_set_state>
 801c380:	e7f2      	b.n	801c368 <CST_data_ready_state_network_event_mngt+0x54>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801c382:	210d      	movs	r1, #13
 801c384:	2000      	movs	r0, #0
 801c386:	f7fe ff3b 	bl	801b200 <CST_send_message>
 801c38a:	e7ed      	b.n	801c368 <CST_data_ready_state_network_event_mngt+0x54>
 801c38c:	20004ddc 	.word	0x20004ddc
 801c390:	08034b10 	.word	0x08034b10
 801c394:	200000c7 	.word	0x200000c7
 801c398:	08034b54 	.word	0x08034b54

0801c39c <CST_cellular_data_fail_mngt>:
{
 801c39c:	b508      	push	{r3, lr}
  if (cst_context.current_state == CST_MODEM_DATA_READY_STATE)
 801c39e:	4b06      	ldr	r3, [pc, #24]	; (801c3b8 <CST_cellular_data_fail_mngt+0x1c>)
 801c3a0:	881b      	ldrh	r3, [r3, #0]
 801c3a2:	2b08      	cmp	r3, #8
 801c3a4:	d003      	beq.n	801c3ae <CST_cellular_data_fail_mngt+0x12>
  CST_set_state(CST_WAITING_FOR_SIGNAL_QUALITY_OK_STATE);
 801c3a6:	2003      	movs	r0, #3
 801c3a8:	f7fe ffee 	bl	801b388 <CST_set_state>
}
 801c3ac:	bd08      	pop	{r3, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c3ae:	2100      	movs	r1, #0
 801c3b0:	2003      	movs	r0, #3
 801c3b2:	f001 f91b 	bl	801d5ec <CST_data_cache_cellular_info_set>
 801c3b6:	e7f6      	b.n	801c3a6 <CST_cellular_data_fail_mngt+0xa>
 801c3b8:	200000b0 	.word	0x200000b0

0801c3bc <CST_data_ready_state>:
{
 801c3bc:	b508      	push	{r3, lr}
  switch (autom_event)
 801c3be:	3808      	subs	r0, #8
 801c3c0:	2813      	cmp	r0, #19
 801c3c2:	d80d      	bhi.n	801c3e0 <CST_data_ready_state+0x24>
 801c3c4:	e8df f000 	tbb	[pc, r0]
 801c3c8:	0d100c13 	.word	0x0d100c13
 801c3cc:	160c0c0c 	.word	0x160c0c0c
 801c3d0:	0a0c190c 	.word	0x0a0c190c
 801c3d4:	0c0c1c0c 	.word	0x0c0c1c0c
 801c3d8:	190c0c0c 	.word	0x190c0c0c
      CST_data_ready_state_network_event_mngt();
 801c3dc:	f7ff ff9a 	bl	801c314 <CST_data_ready_state_network_event_mngt>
}
 801c3e0:	bd08      	pop	{r3, pc}
      CST_polling_timer_mngt();
 801c3e2:	f7fe fe61 	bl	801b0a8 <CST_polling_timer_mngt>
      break;
 801c3e6:	e7fb      	b.n	801c3e0 <CST_data_ready_state+0x24>
      CST_cellular_data_fail_mngt();
 801c3e8:	f7ff ffd8 	bl	801c39c <CST_cellular_data_fail_mngt>
      break;
 801c3ec:	e7f8      	b.n	801c3e0 <CST_data_ready_state+0x24>
      CST_pdn_event_mngt();
 801c3ee:	f7ff ff45 	bl	801c27c <CST_pdn_event_mngt>
      break;
 801c3f2:	e7f5      	b.n	801c3e0 <CST_data_ready_state+0x24>
      CST_data_mode_target_state_event_mngt();
 801c3f4:	f7ff fa26 	bl	801b844 <CST_data_mode_target_state_event_mngt>
      break;
 801c3f8:	e7f2      	b.n	801c3e0 <CST_data_ready_state+0x24>
      CST_reboot_modem_event_mngt();
 801c3fa:	f7ff f82f 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801c3fe:	e7ef      	b.n	801c3e0 <CST_data_ready_state+0x24>
      CST_fota_start_event_mngt();
 801c400:	f7ff fa30 	bl	801b864 <CST_fota_start_event_mngt>
}
 801c404:	e7ec      	b.n	801c3e0 <CST_data_ready_state+0x24>
	...

0801c408 <CST_sim_only_target_state_event_mngt>:
{
 801c408:	b508      	push	{r3, lr}
  if (cst_cellular_params.target_state == DC_TARGET_STATE_FULL)
 801c40a:	4b0d      	ldr	r3, [pc, #52]	; (801c440 <CST_sim_only_target_state_event_mngt+0x38>)
 801c40c:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801c410:	2b02      	cmp	r3, #2
 801c412:	d002      	beq.n	801c41a <CST_sim_only_target_state_event_mngt+0x12>
  else if (cst_cellular_params.target_state == DC_TARGET_STATE_OFF)
 801c414:	b123      	cbz	r3, 801c420 <CST_sim_only_target_state_event_mngt+0x18>
    __NOP();
 801c416:	bf00      	nop
}
 801c418:	bd08      	pop	{r3, pc}
    CST_modem_sim_init();
 801c41a:	f001 fa25 	bl	801d868 <CST_modem_sim_init>
 801c41e:	e7fb      	b.n	801c418 <CST_sim_only_target_state_event_mngt+0x10>
    (void) osCDS_init_modem(CS_CMI_MINI, CELLULAR_FALSE, CST_SIM_PINCODE);
 801c420:	4a08      	ldr	r2, [pc, #32]	; (801c444 <CST_sim_only_target_state_event_mngt+0x3c>)
 801c422:	2100      	movs	r1, #0
 801c424:	4608      	mov	r0, r1
 801c426:	f7fe fc39 	bl	801ac9c <osCDS_init_modem>
    (void)osCDS_power_off();
 801c42a:	f7fe fc25 	bl	801ac78 <osCDS_power_off>
    CST_set_state(CST_MODEM_OFF_STATE);
 801c42e:	200d      	movs	r0, #13
 801c430:	f7fe ffaa 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801c434:	2101      	movs	r1, #1
 801c436:	2000      	movs	r0, #0
 801c438:	f7fe fee2 	bl	801b200 <CST_send_message>
 801c43c:	e7ec      	b.n	801c418 <CST_sim_only_target_state_event_mngt+0x10>
 801c43e:	bf00      	nop
 801c440:	20004160 	.word	0x20004160
 801c444:	08035c54 	.word	0x08035c54

0801c448 <CST_modem_sim_only_state>:
{
 801c448:	b508      	push	{r3, lr}
  switch (autom_event)
 801c44a:	280f      	cmp	r0, #15
 801c44c:	d002      	beq.n	801c454 <CST_modem_sim_only_state+0xc>
 801c44e:	2811      	cmp	r0, #17
 801c450:	d003      	beq.n	801c45a <CST_modem_sim_only_state+0x12>
}
 801c452:	bd08      	pop	{r3, pc}
      CST_sim_only_target_state_event_mngt();
 801c454:	f7ff ffd8 	bl	801c408 <CST_sim_only_target_state_event_mngt>
      break;
 801c458:	e7fb      	b.n	801c452 <CST_modem_sim_only_state+0xa>
      CST_reboot_modem_event_mngt();
 801c45a:	f7fe ffff 	bl	801b45c <CST_reboot_modem_event_mngt>
}
 801c45e:	e7f8      	b.n	801c452 <CST_modem_sim_only_state+0xa>

0801c460 <CST_apn_set_new_config_mngt>:
{
 801c460:	b570      	push	{r4, r5, r6, lr}
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&cst_apn_config, sizeof(dc_apn_config_t));
 801c462:	4d36      	ldr	r5, [pc, #216]	; (801c53c <CST_apn_set_new_config_mngt+0xdc>)
 801c464:	4e36      	ldr	r6, [pc, #216]	; (801c540 <CST_apn_set_new_config_mngt+0xe0>)
 801c466:	236c      	movs	r3, #108	; 0x6c
 801c468:	462a      	mov	r2, r5
 801c46a:	4936      	ldr	r1, [pc, #216]	; (801c544 <CST_apn_set_new_config_mngt+0xe4>)
 801c46c:	8809      	ldrh	r1, [r1, #0]
 801c46e:	4630      	mov	r0, r6
 801c470:	f005 fe5e 	bl	8022130 <dc_com_read>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params));
 801c474:	4c34      	ldr	r4, [pc, #208]	; (801c548 <CST_apn_set_new_config_mngt+0xe8>)
 801c476:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801c47a:	4622      	mov	r2, r4
 801c47c:	4933      	ldr	r1, [pc, #204]	; (801c54c <CST_apn_set_new_config_mngt+0xec>)
 801c47e:	8809      	ldrh	r1, [r1, #0]
 801c480:	4630      	mov	r0, r6
 801c482:	f005 fe55 	bl	8022130 <dc_com_read>
  cst_cellular_params.sim_slot[cst_sim_info.index_slot].cid  = cst_apn_config.cid;
 801c486:	4b32      	ldr	r3, [pc, #200]	; (801c550 <CST_apn_set_new_config_mngt+0xf0>)
 801c488:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 801c48c:	f895 3029 	ldrb.w	r3, [r5, #41]	; 0x29
 801c490:	2162      	movs	r1, #98	; 0x62
 801c492:	fb01 4402 	mla	r4, r1, r2, r4
 801c496:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  size = crs_strlen(cst_apn_config.apn) + 1U;
 801c49a:	f105 0009 	add.w	r0, r5, #9
 801c49e:	f002 ff44 	bl	801f32a <crs_strlen>
 801c4a2:	1c42      	adds	r2, r0, #1
  if (size <= DC_MAX_SIZE_APN)
 801c4a4:	2a20      	cmp	r2, #32
 801c4a6:	d91d      	bls.n	801c4e4 <CST_apn_set_new_config_mngt+0x84>
  size =  crs_strlen(cst_apn_config.username) + 1U;
 801c4a8:	482a      	ldr	r0, [pc, #168]	; (801c554 <CST_apn_set_new_config_mngt+0xf4>)
 801c4aa:	f002 ff3e 	bl	801f32a <crs_strlen>
 801c4ae:	1c42      	adds	r2, r0, #1
  if (size <= DC_CST_USERNAME_SIZE)
 801c4b0:	2a20      	cmp	r2, #32
 801c4b2:	d926      	bls.n	801c502 <CST_apn_set_new_config_mngt+0xa2>
  size =  crs_strlen(cst_apn_config.password) + 1U;
 801c4b4:	4828      	ldr	r0, [pc, #160]	; (801c558 <CST_apn_set_new_config_mngt+0xf8>)
 801c4b6:	f002 ff38 	bl	801f32a <crs_strlen>
 801c4ba:	1c42      	adds	r2, r0, #1
  if (size <= DC_CST_PASSWORD_SIZE)
 801c4bc:	2a20      	cmp	r2, #32
 801c4be:	d92e      	bls.n	801c51e <CST_apn_set_new_config_mngt+0xbe>
  cst_cellular_params.rt_state = DC_SERVICE_ON;
 801c4c0:	4a21      	ldr	r2, [pc, #132]	; (801c548 <CST_apn_set_new_config_mngt+0xe8>)
 801c4c2:	2307      	movs	r3, #7
 801c4c4:	7213      	strb	r3, [r2, #8]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params));
 801c4c6:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801c4ca:	4920      	ldr	r1, [pc, #128]	; (801c54c <CST_apn_set_new_config_mngt+0xec>)
 801c4cc:	8809      	ldrh	r1, [r1, #0]
 801c4ce:	481c      	ldr	r0, [pc, #112]	; (801c540 <CST_apn_set_new_config_mngt+0xe0>)
 801c4d0:	f005 fde2 	bl	8022098 <dc_com_write>
  CST_set_state(CST_MODEM_RESET_STATE);
 801c4d4:	200c      	movs	r0, #12
 801c4d6:	f7fe ff57 	bl	801b388 <CST_set_state>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_RESET_EVENT);
 801c4da:	2118      	movs	r1, #24
 801c4dc:	2000      	movs	r0, #0
 801c4de:	f7fe fe8f 	bl	801b200 <CST_send_message>
}
 801c4e2:	bd70      	pop	{r4, r5, r6, pc}
    (void)memcpy(cst_cellular_params.sim_slot[cst_sim_info.index_slot].apn,
 801c4e4:	4b1a      	ldr	r3, [pc, #104]	; (801c550 <CST_apn_set_new_config_mngt+0xf0>)
 801c4e6:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801c4ea:	2162      	movs	r1, #98	; 0x62
 801c4ec:	fb01 f303 	mul.w	r3, r1, r3
 801c4f0:	3308      	adds	r3, #8
 801c4f2:	4815      	ldr	r0, [pc, #84]	; (801c548 <CST_apn_set_new_config_mngt+0xe8>)
 801c4f4:	4418      	add	r0, r3
 801c4f6:	f105 0109 	add.w	r1, r5, #9
 801c4fa:	3004      	adds	r0, #4
 801c4fc:	f00a faf4 	bl	8026ae8 <memcpy>
 801c500:	e7d2      	b.n	801c4a8 <CST_apn_set_new_config_mngt+0x48>
    (void)memcpy(cst_cellular_params.sim_slot[cst_sim_info.index_slot].username,
 801c502:	4b13      	ldr	r3, [pc, #76]	; (801c550 <CST_apn_set_new_config_mngt+0xf0>)
 801c504:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801c508:	2162      	movs	r1, #98	; 0x62
 801c50a:	fb01 f303 	mul.w	r3, r1, r3
 801c50e:	3328      	adds	r3, #40	; 0x28
 801c510:	480d      	ldr	r0, [pc, #52]	; (801c548 <CST_apn_set_new_config_mngt+0xe8>)
 801c512:	4418      	add	r0, r3
 801c514:	490f      	ldr	r1, [pc, #60]	; (801c554 <CST_apn_set_new_config_mngt+0xf4>)
 801c516:	3005      	adds	r0, #5
 801c518:	f00a fae6 	bl	8026ae8 <memcpy>
 801c51c:	e7ca      	b.n	801c4b4 <CST_apn_set_new_config_mngt+0x54>
    (void)memcpy(cst_cellular_params.sim_slot[cst_sim_info.index_slot].password,
 801c51e:	4b0c      	ldr	r3, [pc, #48]	; (801c550 <CST_apn_set_new_config_mngt+0xf0>)
 801c520:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 801c524:	2162      	movs	r1, #98	; 0x62
 801c526:	fb01 f303 	mul.w	r3, r1, r3
 801c52a:	3348      	adds	r3, #72	; 0x48
 801c52c:	4806      	ldr	r0, [pc, #24]	; (801c548 <CST_apn_set_new_config_mngt+0xe8>)
 801c52e:	4418      	add	r0, r3
 801c530:	4909      	ldr	r1, [pc, #36]	; (801c558 <CST_apn_set_new_config_mngt+0xf8>)
 801c532:	3005      	adds	r0, #5
 801c534:	f00a fad8 	bl	8026ae8 <memcpy>
 801c538:	e7c2      	b.n	801c4c0 <CST_apn_set_new_config_mngt+0x60>
 801c53a:	bf00      	nop
 801c53c:	20003ff0 	.word	0x20003ff0
 801c540:	200058b0 	.word	0x200058b0
 801c544:	20000230 	.word	0x20000230
 801c548:	20004160 	.word	0x20004160
 801c54c:	20000232 	.word	0x20000232
 801c550:	20004338 	.word	0x20004338
 801c554:	2000401a 	.word	0x2000401a
 801c558:	2000403a 	.word	0x2000403a

0801c55c <CST_apn_config_state>:
  switch (autom_event)
 801c55c:	2810      	cmp	r0, #16
 801c55e:	d000      	beq.n	801c562 <CST_apn_config_state+0x6>
 801c560:	4770      	bx	lr
{
 801c562:	b508      	push	{r3, lr}
      CST_apn_set_new_config_mngt();
 801c564:	f7ff ff7c 	bl	801c460 <CST_apn_set_new_config_mngt>
}
 801c568:	bd08      	pop	{r3, pc}
	...

0801c56c <CST_modem_reset_mngt>:
{
 801c56c:	b570      	push	{r4, r5, r6, lr}
  PRINT_CELLULAR_SERVICE("*********** CST_modem_reset_mngt ********\n\r")
 801c56e:	4c26      	ldr	r4, [pc, #152]	; (801c608 <CST_modem_reset_mngt+0x9c>)
 801c570:	4d26      	ldr	r5, [pc, #152]	; (801c60c <CST_modem_reset_mngt+0xa0>)
 801c572:	f104 0e20 	add.w	lr, r4, #32
 801c576:	46a4      	mov	ip, r4
 801c578:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801c57c:	6028      	str	r0, [r5, #0]
 801c57e:	6069      	str	r1, [r5, #4]
 801c580:	60aa      	str	r2, [r5, #8]
 801c582:	60eb      	str	r3, [r5, #12]
 801c584:	4664      	mov	r4, ip
 801c586:	3510      	adds	r5, #16
 801c588:	45f4      	cmp	ip, lr
 801c58a:	d1f4      	bne.n	801c576 <CST_modem_reset_mngt+0xa>
 801c58c:	cc07      	ldmia	r4!, {r0, r1, r2}
 801c58e:	6028      	str	r0, [r5, #0]
 801c590:	6069      	str	r1, [r5, #4]
 801c592:	60aa      	str	r2, [r5, #8]
 801c594:	4c1d      	ldr	r4, [pc, #116]	; (801c60c <CST_modem_reset_mngt+0xa0>)
 801c596:	4620      	mov	r0, r4
 801c598:	f002 fec7 	bl	801f32a <crs_strlen>
 801c59c:	b283      	uxth	r3, r0
 801c59e:	4622      	mov	r2, r4
 801c5a0:	2101      	movs	r1, #1
 801c5a2:	2007      	movs	r0, #7
 801c5a4:	f002 ff04 	bl	801f3b0 <traceIF_itmPrint>
 801c5a8:	4620      	mov	r0, r4
 801c5aa:	f002 febe 	bl	801f32a <crs_strlen>
 801c5ae:	b283      	uxth	r3, r0
 801c5b0:	4622      	mov	r2, r4
 801c5b2:	2101      	movs	r1, #1
 801c5b4:	2007      	movs	r0, #7
 801c5b6:	f002 ff1d 	bl	801f3f4 <traceIF_uartPrint>
  cs_status = osCDS_power_off();
 801c5ba:	f7fe fb5d 	bl	801ac78 <osCDS_power_off>
  if (cs_status != CELLULAR_OK)
 801c5be:	b130      	cbz	r0, 801c5ce <CST_modem_reset_mngt+0x62>
    CST_config_fail(((uint8_t *)"CST_modem_reset_mngt"),
 801c5c0:	2305      	movs	r3, #5
 801c5c2:	4a13      	ldr	r2, [pc, #76]	; (801c610 <CST_modem_reset_mngt+0xa4>)
 801c5c4:	2102      	movs	r1, #2
 801c5c6:	4813      	ldr	r0, [pc, #76]	; (801c614 <CST_modem_reset_mngt+0xa8>)
 801c5c8:	f001 f850 	bl	801d66c <CST_config_fail>
}
 801c5cc:	bd70      	pop	{r4, r5, r6, pc}
    CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801c5ce:	2100      	movs	r1, #0
 801c5d0:	2003      	movs	r0, #3
 801c5d2:	f001 f80b 	bl	801d5ec <CST_data_cache_cellular_info_set>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c5d6:	4e10      	ldr	r6, [pc, #64]	; (801c618 <CST_modem_reset_mngt+0xac>)
 801c5d8:	4c10      	ldr	r4, [pc, #64]	; (801c61c <CST_modem_reset_mngt+0xb0>)
 801c5da:	4d11      	ldr	r5, [pc, #68]	; (801c620 <CST_modem_reset_mngt+0xb4>)
 801c5dc:	23f4      	movs	r3, #244	; 0xf4
 801c5de:	4622      	mov	r2, r4
 801c5e0:	8831      	ldrh	r1, [r6, #0]
 801c5e2:	4628      	mov	r0, r5
 801c5e4:	f005 fda4 	bl	8022130 <dc_com_read>
    cst_cellular_info.rt_state = DC_SERVICE_ON;
 801c5e8:	2307      	movs	r3, #7
 801c5ea:	7223      	strb	r3, [r4, #8]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c5ec:	23f4      	movs	r3, #244	; 0xf4
 801c5ee:	4622      	mov	r2, r4
 801c5f0:	8831      	ldrh	r1, [r6, #0]
 801c5f2:	4628      	mov	r0, r5
 801c5f4:	f005 fd50 	bl	8022098 <dc_com_write>
    CST_set_state(CST_MODEM_INIT_STATE);
 801c5f8:	2001      	movs	r0, #1
 801c5fa:	f7fe fec5 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801c5fe:	2101      	movs	r1, #1
 801c600:	2000      	movs	r0, #0
 801c602:	f7fe fdfd 	bl	801b200 <CST_send_message>
}
 801c606:	e7e1      	b.n	801c5cc <CST_modem_reset_mngt+0x60>
 801c608:	08034e98 	.word	0x08034e98
 801c60c:	20004ddc 	.word	0x20004ddc
 801c610:	200000c2 	.word	0x200000c2
 801c614:	08034ec4 	.word	0x08034ec4
 801c618:	20000236 	.word	0x20000236
 801c61c:	2000406c 	.word	0x2000406c
 801c620:	200058b0 	.word	0x200058b0

0801c624 <CST_modem_reset_state>:
{
 801c624:	b508      	push	{r3, lr}
  CST_modem_reset_mngt();
 801c626:	f7ff ffa1 	bl	801c56c <CST_modem_reset_mngt>
}
 801c62a:	bd08      	pop	{r3, pc}

0801c62c <CST_notif_callback>:
{
 801c62c:	b510      	push	{r4, lr}
  if ((dc_event_id == DC_CELLULAR_DATA_INFO)
 801c62e:	4601      	mov	r1, r0
 801c630:	4b21      	ldr	r3, [pc, #132]	; (801c6b8 <CST_notif_callback+0x8c>)
 801c632:	881b      	ldrh	r3, [r3, #0]
 801c634:	4298      	cmp	r0, r3
 801c636:	d009      	beq.n	801c64c <CST_notif_callback+0x20>
      || (dc_event_id == DC_CELLULAR_TARGET_STATE_CMD))
 801c638:	4b20      	ldr	r3, [pc, #128]	; (801c6bc <CST_notif_callback+0x90>)
 801c63a:	881b      	ldrh	r3, [r3, #0]
 801c63c:	4298      	cmp	r0, r3
 801c63e:	d005      	beq.n	801c64c <CST_notif_callback+0x20>
  else if (dc_event_id == DC_CELLULAR_APN_CONFIG)
 801c640:	4b1f      	ldr	r3, [pc, #124]	; (801c6c0 <CST_notif_callback+0x94>)
 801c642:	8818      	ldrh	r0, [r3, #0]
 801c644:	4281      	cmp	r1, r0
 801c646:	d005      	beq.n	801c654 <CST_notif_callback+0x28>
    __NOP(); /* Nothing to do */
 801c648:	bf00      	nop
}
 801c64a:	e002      	b.n	801c652 <CST_notif_callback+0x26>
    CST_send_message(CST_MESSAGE_DC_EVENT, (cst_autom_event_t)dc_event_id);
 801c64c:	2001      	movs	r0, #1
 801c64e:	f7fe fdd7 	bl	801b200 <CST_send_message>
}
 801c652:	bd10      	pop	{r4, pc}
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&cst_apn_config,
 801c654:	4c1b      	ldr	r4, [pc, #108]	; (801c6c4 <CST_notif_callback+0x98>)
 801c656:	236c      	movs	r3, #108	; 0x6c
 801c658:	4622      	mov	r2, r4
 801c65a:	4601      	mov	r1, r0
 801c65c:	481a      	ldr	r0, [pc, #104]	; (801c6c8 <CST_notif_callback+0x9c>)
 801c65e:	f005 fd67 	bl	8022130 <dc_com_read>
    if (cst_apn_config.rt_state == DC_SERVICE_ON)
 801c662:	7a23      	ldrb	r3, [r4, #8]
 801c664:	2b07      	cmp	r3, #7
 801c666:	d1f4      	bne.n	801c652 <CST_notif_callback+0x26>
      old_apn_len = crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn);
 801c668:	4b18      	ldr	r3, [pc, #96]	; (801c6cc <CST_notif_callback+0xa0>)
 801c66a:	7c1b      	ldrb	r3, [r3, #16]
 801c66c:	2262      	movs	r2, #98	; 0x62
 801c66e:	fb02 f303 	mul.w	r3, r2, r3
 801c672:	3308      	adds	r3, #8
 801c674:	4816      	ldr	r0, [pc, #88]	; (801c6d0 <CST_notif_callback+0xa4>)
 801c676:	4418      	add	r0, r3
 801c678:	3004      	adds	r0, #4
 801c67a:	f002 fe56 	bl	801f32a <crs_strlen>
 801c67e:	4604      	mov	r4, r0
      new_apn_len = crs_strlen(cst_apn_config.apn);
 801c680:	4814      	ldr	r0, [pc, #80]	; (801c6d4 <CST_notif_callback+0xa8>)
 801c682:	f002 fe52 	bl	801f32a <crs_strlen>
 801c686:	4602      	mov	r2, r0
      if ((old_apn_len != new_apn_len)
 801c688:	4284      	cmp	r4, r0
 801c68a:	d10d      	bne.n	801c6a8 <CST_notif_callback+0x7c>
          (memcmp(cst_apn_config.apn, cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn, new_apn_len) != 0))
 801c68c:	4b0f      	ldr	r3, [pc, #60]	; (801c6cc <CST_notif_callback+0xa0>)
 801c68e:	7c1b      	ldrb	r3, [r3, #16]
 801c690:	2162      	movs	r1, #98	; 0x62
 801c692:	fb01 f303 	mul.w	r3, r1, r3
 801c696:	3308      	adds	r3, #8
 801c698:	490d      	ldr	r1, [pc, #52]	; (801c6d0 <CST_notif_callback+0xa4>)
 801c69a:	4419      	add	r1, r3
 801c69c:	3104      	adds	r1, #4
 801c69e:	480d      	ldr	r0, [pc, #52]	; (801c6d4 <CST_notif_callback+0xa8>)
 801c6a0:	f00a f935 	bl	802690e <memcmp>
          ||
 801c6a4:	2800      	cmp	r0, #0
 801c6a6:	d0d4      	beq.n	801c652 <CST_notif_callback+0x26>
          CST_set_state(CST_APN_CONFIG_STATE);
 801c6a8:	2010      	movs	r0, #16
 801c6aa:	f7fe fe6d 	bl	801b388 <CST_set_state>
          CST_send_message(CST_MESSAGE_CS_EVENT, CST_APN_CONFIG_EVENT);
 801c6ae:	2110      	movs	r1, #16
 801c6b0:	2000      	movs	r0, #0
 801c6b2:	f7fe fda5 	bl	801b200 <CST_send_message>
 801c6b6:	e7cc      	b.n	801c652 <CST_notif_callback+0x26>
 801c6b8:	20000234 	.word	0x20000234
 801c6bc:	2000023e 	.word	0x2000023e
 801c6c0:	20000230 	.word	0x20000230
 801c6c4:	20003ff0 	.word	0x20003ff0
 801c6c8:	200058b0 	.word	0x200058b0
 801c6cc:	200000b0 	.word	0x200000b0
 801c6d0:	20004160 	.word	0x20004160
 801c6d4:	20003ff9 	.word	0x20003ff9

0801c6d8 <CST_get_state>:
  * @retval CST_autom_state_t - automaton state
  */
CST_autom_state_t CST_get_state(void)
{
  return cst_context.current_state;
}
 801c6d8:	4b01      	ldr	r3, [pc, #4]	; (801c6e0 <CST_get_state+0x8>)
 801c6da:	8818      	ldrh	r0, [r3, #0]
 801c6dc:	4770      	bx	lr
 801c6de:	bf00      	nop
 801c6e0:	200000b0 	.word	0x200000b0

0801c6e4 <CST_radio_on>:
  * @brief  allows to set radio on: start cellular automaton
  * @param  -
  * @retval CS_Status_t - return code
  */
CS_Status_t  CST_radio_on(void)
{
 801c6e4:	b508      	push	{r3, lr}
  /* Sends a message to start automaton */
  CST_send_message(CST_MESSAGE_CMD, CST_BOOT_EVENT);
 801c6e6:	2100      	movs	r1, #0
 801c6e8:	2002      	movs	r0, #2
 801c6ea:	f7fe fd89 	bl	801b200 <CST_send_message>
  return CELLULAR_OK;
}
 801c6ee:	2000      	movs	r0, #0
 801c6f0:	bd08      	pop	{r3, pc}
	...

0801c6f4 <CST_get_dev_IP_address>:
  * @param  ip_addr_type - type of IP address
  * @param  p_ip_addr_value - IP address value returned by the function
  * @retval CS_Status_t - return code
  */
CS_Status_t CST_get_dev_IP_address(CS_IPaddrType_t *ip_addr_type, CS_CHAR_t *p_ip_addr_value)
{
 801c6f4:	b538      	push	{r3, r4, r5, lr}
 801c6f6:	4604      	mov	r4, r0
 801c6f8:	460d      	mov	r5, r1
  return osCDS_get_dev_IP_address(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801c6fa:	4b07      	ldr	r3, [pc, #28]	; (801c718 <CST_get_dev_IP_address+0x24>)
 801c6fc:	7c1a      	ldrb	r2, [r3, #16]
 801c6fe:	4b07      	ldr	r3, [pc, #28]	; (801c71c <CST_get_dev_IP_address+0x28>)
 801c700:	2162      	movs	r1, #98	; 0x62
 801c702:	fb01 3302 	mla	r3, r1, r2, r3
 801c706:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801c70a:	f7fd fe46 	bl	801a39a <cst_get_cid_value>
 801c70e:	462a      	mov	r2, r5
 801c710:	4621      	mov	r1, r4
 801c712:	f7fe fb83 	bl	801ae1c <osCDS_get_dev_IP_address>
                                  ip_addr_type,
                                  p_ip_addr_value);
}
 801c716:	bd38      	pop	{r3, r4, r5, pc}
 801c718:	200000b0 	.word	0x200000b0
 801c71c:	20004160 	.word	0x20004160

0801c720 <CST_data_ready_mngt>:
{
 801c720:	b5f0      	push	{r4, r5, r6, r7, lr}
 801c722:	b083      	sub	sp, #12
  cst_context.power_on_reset_count       = 0U;
 801c724:	4b20      	ldr	r3, [pc, #128]	; (801c7a8 <CST_data_ready_mngt+0x88>)
 801c726:	2400      	movs	r4, #0
 801c728:	745c      	strb	r4, [r3, #17]
  cst_context.reset_count                = 0U;
 801c72a:	749c      	strb	r4, [r3, #18]
  cst_context.csq_reset_count            = 0U;
 801c72c:	74dc      	strb	r4, [r3, #19]
  cst_context.attach_reset_count         = 0U;
 801c72e:	751c      	strb	r4, [r3, #20]
  cst_context.activate_pdn_reset_count   = 0U;
 801c730:	755c      	strb	r4, [r3, #21]
  cst_context.cellular_data_retry_count  = 0U;
 801c732:	769c      	strb	r4, [r3, #26]
  cst_context.ppp_fail_count             = 0U;
 801c734:	765c      	strb	r4, [r3, #25]
  cst_context.global_retry_count         = 0U;
 801c736:	76dc      	strb	r4, [r3, #27]
  CST_set_state(CST_MODEM_DATA_READY_STATE);
 801c738:	2008      	movs	r0, #8
 801c73a:	f7fe fe25 	bl	801b388 <CST_set_state>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c73e:	4f1b      	ldr	r7, [pc, #108]	; (801c7ac <CST_data_ready_mngt+0x8c>)
 801c740:	4d1b      	ldr	r5, [pc, #108]	; (801c7b0 <CST_data_ready_mngt+0x90>)
 801c742:	4e1c      	ldr	r6, [pc, #112]	; (801c7b4 <CST_data_ready_mngt+0x94>)
 801c744:	23f4      	movs	r3, #244	; 0xf4
 801c746:	462a      	mov	r2, r5
 801c748:	8839      	ldrh	r1, [r7, #0]
 801c74a:	4630      	mov	r0, r6
 801c74c:	f005 fcf0 	bl	8022130 <dc_com_read>
  cst_cellular_info.modem_state = DC_MODEM_STATE_DATA_OK;
 801c750:	2303      	movs	r3, #3
 801c752:	726b      	strb	r3, [r5, #9]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801c754:	23f4      	movs	r3, #244	; 0xf4
 801c756:	462a      	mov	r2, r5
 801c758:	8839      	ldrh	r1, [r7, #0]
 801c75a:	4630      	mov	r0, r6
 801c75c:	f005 fc9c 	bl	8022098 <dc_com_write>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_NO_EVENT);
 801c760:	210d      	movs	r1, #13
 801c762:	4620      	mov	r0, r4
 801c764:	f7fe fd4c 	bl	801b200 <CST_send_message>
  (void)CST_get_dev_IP_address(&ip_addr_type, cs_ip_addr);
 801c768:	4d13      	ldr	r5, [pc, #76]	; (801c7b8 <CST_data_ready_mngt+0x98>)
 801c76a:	4629      	mov	r1, r5
 801c76c:	f10d 0007 	add.w	r0, sp, #7
 801c770:	f7ff ffc0 	bl	801c6f4 <CST_get_dev_IP_address>
  err = crc_get_ip_addr(&cs_ip_addr[1], cs_ip_addr, NULL);
 801c774:	4622      	mov	r2, r4
 801c776:	4629      	mov	r1, r5
 801c778:	1c68      	adds	r0, r5, #1
 801c77a:	f002 fd32 	bl	801f1e2 <crc_get_ip_addr>
  if (err == 0U)
 801c77e:	b980      	cbnz	r0, 801c7a2 <CST_data_ready_mngt+0x82>
    ip_addr.addr = (uint32_t)cs_ip_addr[0] +
 801c780:	782b      	ldrb	r3, [r5, #0]
                   ((uint32_t)cs_ip_addr[1] <<  8) +
 801c782:	7869      	ldrb	r1, [r5, #1]
    ip_addr.addr = (uint32_t)cs_ip_addr[0] +
 801c784:	eb03 2301 	add.w	r3, r3, r1, lsl #8
                   ((uint32_t)cs_ip_addr[2] << 16) +
 801c788:	78a9      	ldrb	r1, [r5, #2]
                   ((uint32_t)cs_ip_addr[1] <<  8) +
 801c78a:	eb03 4301 	add.w	r3, r3, r1, lsl #16
                   ((uint32_t)cs_ip_addr[3] << 24);
 801c78e:	78ea      	ldrb	r2, [r5, #3]
                   ((uint32_t)cs_ip_addr[2] << 16) +
 801c790:	eb03 6302 	add.w	r3, r3, r2, lsl #24
    ip_addr.addr = (uint32_t)cs_ip_addr[0] +
 801c794:	9300      	str	r3, [sp, #0]
  CST_data_cache_cellular_info_set(DC_SERVICE_ON, &ip_addr);
 801c796:	4669      	mov	r1, sp
 801c798:	2007      	movs	r0, #7
 801c79a:	f000 ff27 	bl	801d5ec <CST_data_cache_cellular_info_set>
}
 801c79e:	b003      	add	sp, #12
 801c7a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ip_addr.addr = 0;
 801c7a2:	2300      	movs	r3, #0
 801c7a4:	9300      	str	r3, [sp, #0]
 801c7a6:	e7f6      	b.n	801c796 <CST_data_ready_mngt+0x76>
 801c7a8:	200000b0 	.word	0x200000b0
 801c7ac:	20000236 	.word	0x20000236
 801c7b0:	2000406c 	.word	0x2000406c
 801c7b4:	200058b0 	.word	0x200058b0
 801c7b8:	20003fb0 	.word	0x20003fb0

0801c7bc <CST_modem_activated_mngt>:
{
 801c7bc:	b508      	push	{r3, lr}
  CST_data_ready_mngt();
 801c7be:	f7ff ffaf 	bl	801c720 <CST_data_ready_mngt>
}
 801c7c2:	bd08      	pop	{r3, pc}

0801c7c4 <CST_modem_pdn_activating_state>:
{
 801c7c4:	b508      	push	{r3, lr}
  switch (autom_event)
 801c7c6:	3807      	subs	r0, #7
 801c7c8:	280e      	cmp	r0, #14
 801c7ca:	d80b      	bhi.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
 801c7cc:	e8df f000 	tbb	[pc, r0]
 801c7d0:	0a0b1108 	.word	0x0a0b1108
 801c7d4:	0a0a0a0a 	.word	0x0a0a0a0a
 801c7d8:	0a170a14 	.word	0x0a170a14
 801c7dc:	0a0e      	.short	0x0a0e
 801c7de:	1a          	.byte	0x1a
 801c7df:	00          	.byte	0x00
      CST_modem_activated_mngt();
 801c7e0:	f7ff ffec 	bl	801c7bc <CST_modem_activated_mngt>
}
 801c7e4:	bd08      	pop	{r3, pc}
      CST_modem_activate_pdn_mngt();
 801c7e6:	f7ff fc3f 	bl	801c068 <CST_modem_activate_pdn_mngt>
      break;
 801c7ea:	e7fb      	b.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
      CST_network_event_mngt();
 801c7ec:	f7ff f980 	bl	801baf0 <CST_network_event_mngt>
      break;
 801c7f0:	e7f8      	b.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
      CST_pdn_event_mngt();
 801c7f2:	f7ff fd43 	bl	801c27c <CST_pdn_event_mngt>
      break;
 801c7f6:	e7f5      	b.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
      CST_target_state_cmd_event_mngt();
 801c7f8:	f7fe ff78 	bl	801b6ec <CST_target_state_cmd_event_mngt>
      break;
 801c7fc:	e7f2      	b.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
      CST_reboot_modem_event_mngt();
 801c7fe:	f7fe fe2d 	bl	801b45c <CST_reboot_modem_event_mngt>
      break;
 801c802:	e7ef      	b.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
      CST_fota_start_event_mngt();
 801c804:	f7ff f82e 	bl	801b864 <CST_fota_start_event_mngt>
}
 801c808:	e7ec      	b.n	801c7e4 <CST_modem_pdn_activating_state+0x20>
	...

0801c80c <CST_cellular_service_task>:
{
 801c80c:	b530      	push	{r4, r5, lr}
 801c80e:	b083      	sub	sp, #12
 801c810:	e071      	b.n	801c8f6 <CST_cellular_service_task+0xea>
      PRINT_CELLULAR_SERVICE("AUTOM TASK:  %s - %s\n\r", CST_StateName[cst_context.current_state],
 801c812:	4d58      	ldr	r5, [pc, #352]	; (801c974 <CST_cellular_service_task+0x168>)
 801c814:	4b58      	ldr	r3, [pc, #352]	; (801c978 <CST_cellular_service_task+0x16c>)
 801c816:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 801c81a:	4958      	ldr	r1, [pc, #352]	; (801c97c <CST_cellular_service_task+0x170>)
 801c81c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 801c820:	4957      	ldr	r1, [pc, #348]	; (801c980 <CST_cellular_service_task+0x174>)
 801c822:	4628      	mov	r0, r5
 801c824:	f00a f810 	bl	8026848 <sprintf>
 801c828:	4628      	mov	r0, r5
 801c82a:	f002 fd7e 	bl	801f32a <crs_strlen>
 801c82e:	b283      	uxth	r3, r0
 801c830:	462a      	mov	r2, r5
 801c832:	2101      	movs	r1, #1
 801c834:	2007      	movs	r0, #7
 801c836:	f002 fdbb 	bl	801f3b0 <traceIF_itmPrint>
 801c83a:	4628      	mov	r0, r5
 801c83c:	f002 fd75 	bl	801f32a <crs_strlen>
 801c840:	b283      	uxth	r3, r0
 801c842:	462a      	mov	r2, r5
 801c844:	2101      	movs	r1, #1
 801c846:	2007      	movs	r0, #7
 801c848:	f002 fdd4 	bl	801f3f4 <traceIF_uartPrint>
 801c84c:	e066      	b.n	801c91c <CST_cellular_service_task+0x110>
          CST_boot_state(autom_event);
 801c84e:	4620      	mov	r0, r4
 801c850:	f7fe fe92 	bl	801b578 <CST_boot_state>
          break;
 801c854:	e04f      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_init_state(autom_event);
 801c856:	4620      	mov	r0, r4
 801c858:	f7ff f850 	bl	801b8fc <CST_init_state>
          break;
 801c85c:	e04b      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_ready_state(autom_event);
 801c85e:	4620      	mov	r0, r4
 801c860:	f7ff f8f4 	bl	801ba4c <CST_modem_ready_state>
          break;
 801c864:	e047      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_waiting_for_signal_quality_ok_state(autom_event);
 801c866:	4620      	mov	r0, r4
 801c868:	f7ff f98a 	bl	801bb80 <CST_waiting_for_signal_quality_ok_state>
          break;
 801c86c:	e043      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_waiting_for_network_status_state(autom_event);
 801c86e:	4620      	mov	r0, r4
 801c870:	f7ff fa84 	bl	801bd7c <CST_waiting_for_network_status_state>
          break;
 801c874:	e03f      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_network_status_ok_state(autom_event);
 801c876:	4620      	mov	r0, r4
 801c878:	f7ff fbda 	bl	801c030 <CST_network_status_ok_state>
          break;
 801c87c:	e03b      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_registered_state(autom_event);
 801c87e:	4620      	mov	r0, r4
 801c880:	f7ff fc7c 	bl	801c17c <CST_modem_registered_state>
          break;
 801c884:	e037      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_pdn_activating_state(autom_event);
 801c886:	4620      	mov	r0, r4
 801c888:	f7ff ff9c 	bl	801c7c4 <CST_modem_pdn_activating_state>
          break;
 801c88c:	e033      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_data_ready_state(autom_event);
 801c88e:	4620      	mov	r0, r4
 801c890:	f7ff fd94 	bl	801c3bc <CST_data_ready_state>
          break;
 801c894:	e02f      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_off_state(autom_event);
 801c896:	4620      	mov	r0, r4
 801c898:	f7fe fe22 	bl	801b4e0 <CST_modem_off_state>
          break;
 801c89c:	e02b      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_sim_only_state(autom_event);
 801c89e:	4620      	mov	r0, r4
 801c8a0:	f7ff fdd2 	bl	801c448 <CST_modem_sim_only_state>
          break;
 801c8a4:	e027      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_reprog_state(autom_event);
 801c8a6:	4620      	mov	r0, r4
 801c8a8:	f7fe fc9a 	bl	801b1e0 <CST_modem_reprog_state>
          break;
 801c8ac:	e023      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_apn_config_state(autom_event);
 801c8ae:	4620      	mov	r0, r4
 801c8b0:	f7ff fe54 	bl	801c55c <CST_apn_config_state>
          break;
 801c8b4:	e01f      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_modem_reset_state(autom_event);
 801c8b6:	4620      	mov	r0, r4
 801c8b8:	f7ff feb4 	bl	801c624 <CST_modem_reset_state>
          break;
 801c8bc:	e01b      	b.n	801c8f6 <CST_cellular_service_task+0xea>
          CST_fail_state(autom_event);
 801c8be:	4620      	mov	r0, r4
 801c8c0:	f7fe fe1f 	bl	801b502 <CST_fail_state>
          break;
 801c8c4:	e017      	b.n	801c8f6 <CST_cellular_service_task+0xea>
      PRINT_CELLULAR_SERVICE("============ CST_cellular_service_task : autom_event = no event \n\r")
 801c8c6:	4c2b      	ldr	r4, [pc, #172]	; (801c974 <CST_cellular_service_task+0x168>)
 801c8c8:	2243      	movs	r2, #67	; 0x43
 801c8ca:	492e      	ldr	r1, [pc, #184]	; (801c984 <CST_cellular_service_task+0x178>)
 801c8cc:	4620      	mov	r0, r4
 801c8ce:	f00a f90b 	bl	8026ae8 <memcpy>
 801c8d2:	4620      	mov	r0, r4
 801c8d4:	f002 fd29 	bl	801f32a <crs_strlen>
 801c8d8:	b283      	uxth	r3, r0
 801c8da:	4622      	mov	r2, r4
 801c8dc:	2101      	movs	r1, #1
 801c8de:	2007      	movs	r0, #7
 801c8e0:	f002 fd66 	bl	801f3b0 <traceIF_itmPrint>
 801c8e4:	4620      	mov	r0, r4
 801c8e6:	f002 fd20 	bl	801f32a <crs_strlen>
 801c8ea:	b283      	uxth	r3, r0
 801c8ec:	4622      	mov	r2, r4
 801c8ee:	2101      	movs	r1, #1
 801c8f0:	2007      	movs	r0, #7
 801c8f2:	f002 fd7f 	bl	801f3f4 <traceIF_uartPrint>
    event = 0xffffffffU;
 801c8f6:	f04f 32ff 	mov.w	r2, #4294967295
 801c8fa:	9201      	str	r2, [sp, #4]
    (void)rtosalMessageQueueGet((osMessageQId)cst_queue_id, &event, RTOSAL_WAIT_FOREVER);
 801c8fc:	a901      	add	r1, sp, #4
 801c8fe:	4b22      	ldr	r3, [pc, #136]	; (801c988 <CST_cellular_service_task+0x17c>)
 801c900:	6818      	ldr	r0, [r3, #0]
 801c902:	f002 fc44 	bl	801f18e <rtosalMessageQueueGet>
    autom_event = CST_get_autom_event(event);
 801c906:	9801      	ldr	r0, [sp, #4]
 801c908:	f001 fc4c 	bl	801e1a4 <CST_get_autom_event>
 801c90c:	4604      	mov	r4, r0
    if ((cst_context.current_state < CST_MAX_STATE) && (autom_event < CST_MAX_EVENT))
 801c90e:	4b1f      	ldr	r3, [pc, #124]	; (801c98c <CST_cellular_service_task+0x180>)
 801c910:	881a      	ldrh	r2, [r3, #0]
 801c912:	2a12      	cmp	r2, #18
 801c914:	d802      	bhi.n	801c91c <CST_cellular_service_task+0x110>
 801c916:	281b      	cmp	r0, #27
 801c918:	f67f af7b 	bls.w	801c812 <CST_cellular_service_task+0x6>
    if (autom_event != CST_NO_EVENT)
 801c91c:	2c0d      	cmp	r4, #13
 801c91e:	d0d2      	beq.n	801c8c6 <CST_cellular_service_task+0xba>
      switch (cst_context.current_state)
 801c920:	4b1a      	ldr	r3, [pc, #104]	; (801c98c <CST_cellular_service_task+0x180>)
 801c922:	881b      	ldrh	r3, [r3, #0]
 801c924:	2b10      	cmp	r3, #16
 801c926:	d8e6      	bhi.n	801c8f6 <CST_cellular_service_task+0xea>
 801c928:	a201      	add	r2, pc, #4	; (adr r2, 801c930 <CST_cellular_service_task+0x124>)
 801c92a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c92e:	bf00      	nop
 801c930:	0801c84f 	.word	0x0801c84f
 801c934:	0801c857 	.word	0x0801c857
 801c938:	0801c85f 	.word	0x0801c85f
 801c93c:	0801c867 	.word	0x0801c867
 801c940:	0801c86f 	.word	0x0801c86f
 801c944:	0801c877 	.word	0x0801c877
 801c948:	0801c87f 	.word	0x0801c87f
 801c94c:	0801c887 	.word	0x0801c887
 801c950:	0801c88f 	.word	0x0801c88f
 801c954:	0801c8a7 	.word	0x0801c8a7
 801c958:	0801c8bf 	.word	0x0801c8bf
 801c95c:	0801c89f 	.word	0x0801c89f
 801c960:	0801c8b7 	.word	0x0801c8b7
 801c964:	0801c897 	.word	0x0801c897
 801c968:	0801c8f7 	.word	0x0801c8f7
 801c96c:	0801c8f7 	.word	0x0801c8f7
 801c970:	0801c8af 	.word	0x0801c8af
 801c974:	20004ddc 	.word	0x20004ddc
 801c978:	080353c4 	.word	0x080353c4
 801c97c:	20000064 	.word	0x20000064
 801c980:	08034edc 	.word	0x08034edc
 801c984:	08034ef4 	.word	0x08034ef4
 801c988:	20004330 	.word	0x20004330
 801c98c:	200000b0 	.word	0x200000b0

0801c990 <CST_cellular_service_init>:
  * @brief  initializes cellular service component
  * @param  -
  * @retval CS_Status_t - return code
  */
CS_Status_t CST_cellular_service_init(void)
{
 801c990:	b538      	push	{r3, r4, r5, lr}
  CS_Status_t ret;

  CST_set_state(CST_BOOT_STATE);
 801c992:	2000      	movs	r0, #0
 801c994:	f7fe fcf8 	bl	801b388 <CST_set_state>

  /* request modem init to Cellular Service */
  ret = CS_init();
 801c998:	f7f9 f976 	bl	8015c88 <CS_init>

  if (ret == CELLULAR_OK)
 801c99c:	4604      	mov	r4, r0
 801c99e:	b108      	cbz	r0, 801c9a4 <CST_cellular_service_init+0x14>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 5, ERROR_FATAL);
      ret = CELLULAR_ERROR;
    }
  }
  return ret;
}
 801c9a0:	4620      	mov	r0, r4
 801c9a2:	bd38      	pop	{r3, r4, r5, pc}
    (void)osCDS_cellular_service_init();
 801c9a4:	f7fe f8d6 	bl	801ab54 <osCDS_cellular_service_init>
    cst_context.csq_count_fail = 0U;
 801c9a8:	2500      	movs	r5, #0
 801c9aa:	4b0c      	ldr	r3, [pc, #48]	; (801c9dc <CST_cellular_service_init+0x4c>)
 801c9ac:	771d      	strb	r5, [r3, #28]
    CST_polling_active = true;
 801c9ae:	4b0c      	ldr	r3, [pc, #48]	; (801c9e0 <CST_cellular_service_init+0x50>)
 801c9b0:	2201      	movs	r2, #1
 801c9b2:	701a      	strb	r2, [r3, #0]
    CST_polling_on_going = false;
 801c9b4:	4b0b      	ldr	r3, [pc, #44]	; (801c9e4 <CST_cellular_service_init+0x54>)
 801c9b6:	701d      	strb	r5, [r3, #0]
    (void)CST_config_init();
 801c9b8:	f7fd fda2 	bl	801a500 <CST_config_init>
    cst_queue_id = rtosalMessageQueueNew(NULL, CST_QUEUE_SIZE);
 801c9bc:	210a      	movs	r1, #10
 801c9be:	4628      	mov	r0, r5
 801c9c0:	f002 fbd5 	bl	801f16e <rtosalMessageQueueNew>
 801c9c4:	4b08      	ldr	r3, [pc, #32]	; (801c9e8 <CST_cellular_service_init+0x58>)
 801c9c6:	6018      	str	r0, [r3, #0]
    if (cst_queue_id == NULL)
 801c9c8:	2800      	cmp	r0, #0
 801c9ca:	d1e9      	bne.n	801c9a0 <CST_cellular_service_init+0x10>
      ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 5, ERROR_FATAL);
 801c9cc:	2203      	movs	r2, #3
 801c9ce:	2105      	movs	r1, #5
 801c9d0:	2007      	movs	r0, #7
 801c9d2:	f001 fcc7 	bl	801e364 <ERROR_Handler>
      ret = CELLULAR_ERROR;
 801c9d6:	2401      	movs	r4, #1
 801c9d8:	e7e2      	b.n	801c9a0 <CST_cellular_service_init+0x10>
 801c9da:	bf00      	nop
 801c9dc:	200000b0 	.word	0x200000b0
 801c9e0:	20003fac 	.word	0x20003fac
 801c9e4:	20003fad 	.word	0x20003fad
 801c9e8:	20004330 	.word	0x20004330

0801c9ec <CST_cellular_service_start>:
  * @note   cellular service task automaton and tempos are started
  * @param  -
  * @retval CS_Status_t - return code
  */
CS_Status_t CST_cellular_service_start(void)
{
 801c9ec:	b570      	push	{r4, r5, r6, lr}
 801c9ee:	b08e      	sub	sp, #56	; 0x38
  cs_ret  = 0U;

  osTimerId         cst_polling_timer_handle;

#if (USE_CMD_CONSOLE == 1)
  (void)CST_cmd_cellular_service_start();
 801c9f0:	f7fd fca2 	bl	801a338 <CST_cmd_cellular_service_start>
#endif /*  (USE_CMD_CONSOLE == 1) */

  /* reads cellular configuration in Data Cache */
  if (dc_com_read(&dc_com_db, DC_CELLULAR_CONFIG, (void *)&cst_cellular_params, sizeof(cst_cellular_params)) ==
 801c9f4:	4d55      	ldr	r5, [pc, #340]	; (801cb4c <CST_cellular_service_start+0x160>)
 801c9f6:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
 801c9fa:	4a55      	ldr	r2, [pc, #340]	; (801cb50 <CST_cellular_service_start+0x164>)
 801c9fc:	4955      	ldr	r1, [pc, #340]	; (801cb54 <CST_cellular_service_start+0x168>)
 801c9fe:	8809      	ldrh	r1, [r1, #0]
 801ca00:	4628      	mov	r0, r5
 801ca02:	f005 fb95 	bl	8022130 <dc_com_read>
 801ca06:	4604      	mov	r4, r0
  {
    dc_ret = DC_COM_ERROR;
  }

  /* initializes Data Cache SIM slot entry  */
  if (dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info)) == DC_COM_ERROR)
 801ca08:	2330      	movs	r3, #48	; 0x30
 801ca0a:	4a53      	ldr	r2, [pc, #332]	; (801cb58 <CST_cellular_service_start+0x16c>)
 801ca0c:	4953      	ldr	r1, [pc, #332]	; (801cb5c <CST_cellular_service_start+0x170>)
 801ca0e:	8809      	ldrh	r1, [r1, #0]
 801ca10:	4628      	mov	r0, r5
 801ca12:	f005 fb8d 	bl	8022130 <dc_com_read>
 801ca16:	4606      	mov	r6, r0
 801ca18:	b100      	cbz	r0, 801ca1c <CST_cellular_service_start+0x30>
 801ca1a:	4626      	mov	r6, r4
  {
    dc_ret = DC_COM_ERROR;
  }
  cst_sim_info.sim_status[DC_SIM_SLOT_MODEM_SOCKET]       = DC_SIM_NOT_USED;
 801ca1c:	4a4e      	ldr	r2, [pc, #312]	; (801cb58 <CST_cellular_service_start+0x16c>)
 801ca1e:	2307      	movs	r3, #7
 801ca20:	f882 302b 	strb.w	r3, [r2, #43]	; 0x2b
  cst_sim_info.sim_status[DC_SIM_SLOT_MODEM_EMBEDDED_SIM] = DC_SIM_NOT_USED;
 801ca24:	f882 302c 	strb.w	r3, [r2, #44]	; 0x2c
  cst_sim_info.sim_status[DC_SIM_SLOT_STM32_EMBEDDED_SIM] = DC_SIM_NOT_USED;
 801ca28:	f882 302d 	strb.w	r3, [r2, #45]	; 0x2d
  cst_context.sim_slot_index = 0U;
 801ca2c:	2300      	movs	r3, #0
 801ca2e:	494c      	ldr	r1, [pc, #304]	; (801cb60 <CST_cellular_service_start+0x174>)
 801ca30:	740b      	strb	r3, [r1, #16]
  cst_sim_info.active_slot = cst_cellular_params.sim_slot[cst_context.sim_slot_index].sim_slot_type;
 801ca32:	4947      	ldr	r1, [pc, #284]	; (801cb50 <CST_cellular_service_start+0x164>)
 801ca34:	7ac9      	ldrb	r1, [r1, #11]
 801ca36:	f882 102a 	strb.w	r1, [r2, #42]	; 0x2a
  cst_sim_info.index_slot  = cst_context.sim_slot_index;
 801ca3a:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
  if (dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info)) == DC_COM_ERROR)
 801ca3e:	2330      	movs	r3, #48	; 0x30
 801ca40:	4946      	ldr	r1, [pc, #280]	; (801cb5c <CST_cellular_service_start+0x170>)
 801ca42:	8809      	ldrh	r1, [r1, #0]
 801ca44:	4841      	ldr	r0, [pc, #260]	; (801cb4c <CST_cellular_service_start+0x160>)
 801ca46:	f005 fb27 	bl	8022098 <dc_com_write>
 801ca4a:	4605      	mov	r5, r0
 801ca4c:	b100      	cbz	r0, 801ca50 <CST_cellular_service_start+0x64>
 801ca4e:	4635      	mov	r5, r6
  {
    dc_ret = DC_COM_ERROR;
  }

  /* request AT core to start */
  if (atcore_task_start(ATCORE_THREAD_STACK_PRIO, ATCORE_THREAD_STACK_SIZE) != ATSTATUS_OK)
 801ca50:	f44f 71c0 	mov.w	r1, #384	; 0x180
 801ca54:	2000      	movs	r0, #0
 801ca56:	f7ef fa33 	bl	800bec0 <atcore_task_start>
 801ca5a:	2800      	cmp	r0, #0
 801ca5c:	d15f      	bne.n	801cb1e <CST_cellular_service_start+0x132>
  cs_ret  = 0U;
 801ca5e:	2400      	movs	r4, #0
    cs_ret |= (uint32_t)CELLULAR_ERROR;
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 6, ERROR_WARNING);
  }

  /* register component to Data Cache  */
  if (dc_com_register_gen_event_cb(&dc_com_db, CST_notif_callback, (const void *)NULL) == DC_COM_INVALID_ENTRY)
 801ca60:	2200      	movs	r2, #0
 801ca62:	4940      	ldr	r1, [pc, #256]	; (801cb64 <CST_cellular_service_start+0x178>)
 801ca64:	4839      	ldr	r0, [pc, #228]	; (801cb4c <CST_cellular_service_start+0x160>)
 801ca66:	f005 fae7 	bl	8022038 <dc_com_register_gen_event_cb>
 801ca6a:	28ff      	cmp	r0, #255	; 0xff
 801ca6c:	d05e      	beq.n	801cb2c <CST_cellular_service_start+0x140>
  {
    dc_ret = DC_COM_ERROR;
  }
  cst_cellular_info.mno_name[0]           = 0U;
 801ca6e:	4a3e      	ldr	r2, [pc, #248]	; (801cb68 <CST_cellular_service_start+0x17c>)
 801ca70:	2300      	movs	r3, #0
 801ca72:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
  cst_cellular_info.rt_state              = DC_SERVICE_UNAVAIL;
 801ca76:	7213      	strb	r3, [r2, #8]

  /* registers component callback to Data Cache  */
  if (dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info)) == DC_COM_ERROR)
 801ca78:	23f4      	movs	r3, #244	; 0xf4
 801ca7a:	493c      	ldr	r1, [pc, #240]	; (801cb6c <CST_cellular_service_start+0x180>)
 801ca7c:	8809      	ldrh	r1, [r1, #0]
 801ca7e:	4833      	ldr	r0, [pc, #204]	; (801cb4c <CST_cellular_service_start+0x160>)
 801ca80:	f005 fb0a 	bl	8022098 <dc_com_write>
 801ca84:	4606      	mov	r6, r0
 801ca86:	b100      	cbz	r0, 801ca8a <CST_cellular_service_start+0x9e>
 801ca88:	462e      	mov	r6, r5
  {
    dc_ret = DC_COM_ERROR;
  }

  /* initializes Data Cache NFMC entry  */
  nfmc_info.rt_state = DC_SERVICE_UNAVAIL;
 801ca8a:	2300      	movs	r3, #0
 801ca8c:	f88d 3014 	strb.w	r3, [sp, #20]
  if (dc_com_write(&dc_com_db, DC_CELLULAR_NFMC_INFO, (void *)&nfmc_info, sizeof(nfmc_info)) == DC_COM_ERROR)
 801ca90:	232c      	movs	r3, #44	; 0x2c
 801ca92:	aa03      	add	r2, sp, #12
 801ca94:	4936      	ldr	r1, [pc, #216]	; (801cb70 <CST_cellular_service_start+0x184>)
 801ca96:	8809      	ldrh	r1, [r1, #0]
 801ca98:	482c      	ldr	r0, [pc, #176]	; (801cb4c <CST_cellular_service_start+0x160>)
 801ca9a:	f005 fafd 	bl	8022098 <dc_com_write>
 801ca9e:	4605      	mov	r5, r0
 801caa0:	b100      	cbz	r0, 801caa4 <CST_cellular_service_start+0xb8>
 801caa2:	4635      	mov	r5, r6
  {
    dc_ret = DC_COM_ERROR;
  }

  /* creates and starts cellar service task automaton */
  cst_cellular_service_thread_id = rtosalThreadNew((const rtosal_char_t *)"cellularServiceTask",
 801caa4:	2200      	movs	r2, #0
 801caa6:	9200      	str	r2, [sp, #0]
 801caa8:	f44f 7300 	mov.w	r3, #512	; 0x200
 801caac:	4931      	ldr	r1, [pc, #196]	; (801cb74 <CST_cellular_service_start+0x188>)
 801caae:	4832      	ldr	r0, [pc, #200]	; (801cb78 <CST_cellular_service_start+0x18c>)
 801cab0:	f002 fb29 	bl	801f106 <rtosalThreadNew>
 801cab4:	4b31      	ldr	r3, [pc, #196]	; (801cb7c <CST_cellular_service_start+0x190>)
 801cab6:	6018      	str	r0, [r3, #0]
                                                   (os_pthread)CST_cellular_service_task, CELLULAR_SERVICE_THREAD_PRIO,
                                                   USED_CELLULAR_SERVICE_THREAD_STACK_SIZE, NULL);

  if (cst_cellular_service_thread_id == NULL)
 801cab8:	2800      	cmp	r0, #0
 801caba:	d039      	beq.n	801cb30 <CST_cellular_service_start+0x144>
    (void)stackAnalysis_addStackSizeByHandle(cst_cellular_service_thread_id, USED_CELLULAR_SERVICE_THREAD_STACK_SIZE);
#endif /* USE_STACK_ANALYSIS == 1 */
  }

  /* creates and start modem polling timer */
  cst_polling_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_polling_timer_callback, osTimerPeriodic, NULL);
 801cabc:	2300      	movs	r3, #0
 801cabe:	2201      	movs	r2, #1
 801cac0:	492f      	ldr	r1, [pc, #188]	; (801cb80 <CST_cellular_service_start+0x194>)
 801cac2:	4618      	mov	r0, r3
 801cac4:	f002 fb75 	bl	801f1b2 <rtosalTimerNew>
#if (CST_MODEM_POLLING_PERIOD == 0)
  cst_polling_period = CST_MODEM_POLLING_PERIOD_DEFAULT;
#else
  cst_polling_period = CST_MODEM_POLLING_PERIOD;
#endif /* (CST_MODEM_POLLING_PERIOD == 1) */
  os_ret = rtosalTimerStart(cst_polling_timer_handle, cst_polling_period);
 801cac8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 801cacc:	f002 fb7d 	bl	801f1ca <rtosalTimerStart>
  if (os_ret != osOK)
 801cad0:	b108      	cbz	r0, 801cad6 <CST_cellular_service_start+0xea>
  {
    /* polling timer start fails */
    cs_ret |= (uint32_t)CELLULAR_ERROR;
 801cad2:	f044 0401 	orr.w	r4, r4, #1
  }

  /* creates timers */

  /* initializes pdn activation timer */
  cst_pdn_activate_retry_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_pdn_activate_retry_timer_callback,
 801cad6:	2300      	movs	r3, #0
 801cad8:	461a      	mov	r2, r3
 801cada:	492a      	ldr	r1, [pc, #168]	; (801cb84 <CST_cellular_service_start+0x198>)
 801cadc:	4618      	mov	r0, r3
 801cade:	f002 fb68 	bl	801f1b2 <rtosalTimerNew>
 801cae2:	4b29      	ldr	r3, [pc, #164]	; (801cb88 <CST_cellular_service_start+0x19c>)
 801cae4:	6018      	str	r0, [r3, #0]
                                                       osTimerOnce, NULL);

  /* initializes network monitoring state timer */
  cst_network_status_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_network_status_timer_callback, osTimerOnce,
 801cae6:	2300      	movs	r3, #0
 801cae8:	461a      	mov	r2, r3
 801caea:	4928      	ldr	r1, [pc, #160]	; (801cb8c <CST_cellular_service_start+0x1a0>)
 801caec:	4618      	mov	r0, r3
 801caee:	f002 fb60 	bl	801f1b2 <rtosalTimerNew>
 801caf2:	4b27      	ldr	r3, [pc, #156]	; (801cb90 <CST_cellular_service_start+0x1a4>)
 801caf4:	6018      	str	r0, [r3, #0]
                                                   NULL);

  /* initializes register timer */
  cst_register_retry_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_register_retry_timer_callback, osTimerOnce,
 801caf6:	2300      	movs	r3, #0
 801caf8:	461a      	mov	r2, r3
 801cafa:	4926      	ldr	r1, [pc, #152]	; (801cb94 <CST_cellular_service_start+0x1a8>)
 801cafc:	4618      	mov	r0, r3
 801cafe:	f002 fb58 	bl	801f1b2 <rtosalTimerNew>
 801cb02:	4b25      	ldr	r3, [pc, #148]	; (801cb98 <CST_cellular_service_start+0x1ac>)
 801cb04:	6018      	str	r0, [r3, #0]
                                                   NULL);

  /* initializes FOTA timer */
  cst_fota_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_fota_timer_callback, osTimerOnce, NULL);
 801cb06:	2300      	movs	r3, #0
 801cb08:	461a      	mov	r2, r3
 801cb0a:	4924      	ldr	r1, [pc, #144]	; (801cb9c <CST_cellular_service_start+0x1b0>)
 801cb0c:	4618      	mov	r0, r3
 801cb0e:	f002 fb50 	bl	801f1b2 <rtosalTimerNew>
 801cb12:	4b23      	ldr	r3, [pc, #140]	; (801cba0 <CST_cellular_service_start+0x1b4>)
 801cb14:	6018      	str	r0, [r3, #0]
  /* initializes low power inactivity timer */
  cst_lp_inactivity_timer_handle = rtosalTimerNew(NULL, (os_ptimer)CST_lp_inactivity_timer_callback, osTimerOnce,
                                                  NULL);
#endif /* (USE_LOW_POWER == 1) */

  if ((dc_ret != DC_COM_OK) || (cs_ret != 0U))
 801cb16:	b19d      	cbz	r5, 801cb40 <CST_cellular_service_start+0x154>
 801cb18:	b9ac      	cbnz	r4, 801cb46 <CST_cellular_service_start+0x15a>
  cst_ret = CELLULAR_OK;
 801cb1a:	2000      	movs	r0, #0
 801cb1c:	e011      	b.n	801cb42 <CST_cellular_service_start+0x156>
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 6, ERROR_WARNING);
 801cb1e:	2202      	movs	r2, #2
 801cb20:	2106      	movs	r1, #6
 801cb22:	2007      	movs	r0, #7
 801cb24:	f001 fc1e 	bl	801e364 <ERROR_Handler>
    cs_ret |= (uint32_t)CELLULAR_ERROR;
 801cb28:	2401      	movs	r4, #1
 801cb2a:	e799      	b.n	801ca60 <CST_cellular_service_start+0x74>
    dc_ret = DC_COM_ERROR;
 801cb2c:	2500      	movs	r5, #0
 801cb2e:	e79e      	b.n	801ca6e <CST_cellular_service_start+0x82>
    cs_ret |= (uint32_t)CELLULAR_ERROR;
 801cb30:	f044 0401 	orr.w	r4, r4, #1
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 7, ERROR_FATAL);
 801cb34:	2203      	movs	r2, #3
 801cb36:	2107      	movs	r1, #7
 801cb38:	4608      	mov	r0, r1
 801cb3a:	f001 fc13 	bl	801e364 <ERROR_Handler>
 801cb3e:	e7bd      	b.n	801cabc <CST_cellular_service_start+0xd0>
  {
    /* At least one error occurs during start function */
    cst_ret = CELLULAR_ERROR;
 801cb40:	2001      	movs	r0, #1
  }

  return cst_ret;
}
 801cb42:	b00e      	add	sp, #56	; 0x38
 801cb44:	bd70      	pop	{r4, r5, r6, pc}
    cst_ret = CELLULAR_ERROR;
 801cb46:	2001      	movs	r0, #1
 801cb48:	e7fb      	b.n	801cb42 <CST_cellular_service_start+0x156>
 801cb4a:	bf00      	nop
 801cb4c:	200058b0 	.word	0x200058b0
 801cb50:	20004160 	.word	0x20004160
 801cb54:	20000232 	.word	0x20000232
 801cb58:	20004338 	.word	0x20004338
 801cb5c:	2000023c 	.word	0x2000023c
 801cb60:	200000b0 	.word	0x200000b0
 801cb64:	0801c62d 	.word	0x0801c62d
 801cb68:	2000406c 	.word	0x2000406c
 801cb6c:	20000236 	.word	0x20000236
 801cb70:	20000238 	.word	0x20000238
 801cb74:	0801c80d 	.word	0x0801c80d
 801cb78:	08034f38 	.word	0x08034f38
 801cb7c:	20004300 	.word	0x20004300
 801cb80:	0801b2f1 	.word	0x0801b2f1
 801cb84:	0801b27d 	.word	0x0801b27d
 801cb88:	2000432c 	.word	0x2000432c
 801cb8c:	0801b261 	.word	0x0801b261
 801cb90:	20004308 	.word	0x20004308
 801cb94:	0801b3d5 	.word	0x0801b3d5
 801cb98:	20004334 	.word	0x20004334
 801cb9c:	0801b255 	.word	0x0801b255
 801cba0:	20004304 	.word	0x20004304

0801cba4 <cst_convert_sim_socket_type>:
  * @retval CS_SimSlot_t  - sim slot CS enum value
  */
static CS_SimSlot_t  cst_convert_sim_socket_type(dc_cs_sim_slot_type_t sim_slot_value)
{
  CS_SimSlot_t enum_value;
  switch (sim_slot_value)
 801cba4:	2801      	cmp	r0, #1
 801cba6:	d002      	beq.n	801cbae <cst_convert_sim_socket_type+0xa>
 801cba8:	2802      	cmp	r0, #2
 801cbaa:	d000      	beq.n	801cbae <cst_convert_sim_socket_type+0xa>
 801cbac:	2000      	movs	r0, #0
    default:
      enum_value = CS_MODEM_SIM_SOCKET_0;
      break;
  }
  return enum_value;
}
 801cbae:	4770      	bx	lr

0801cbb0 <cst_modulo64>:

  tmp_l = 0U;
  div_m = div;
  div_l = 0U;

  if (div_m != 0U)
 801cbb0:	b320      	cbz	r0, 801cbfc <cst_modulo64+0x4c>
  {
    tmp_m = val_m % div_m;
 801cbb2:	fbb1 f3f0 	udiv	r3, r1, r0
 801cbb6:	fb00 1113 	mls	r1, r0, r3, r1
  div_m = div;
 801cbba:	4603      	mov	r3, r0
  div_l = 0U;
 801cbbc:	f04f 0c00 	mov.w	ip, #0

    tmp_l = val_l;

    while (tmp_m > 0U)
 801cbc0:	e00d      	b.n	801cbde <cst_modulo64+0x2e>
    {
      if ((div_m > tmp_m) || ((div_m == tmp_m) && (div_l > tmp_l)))
 801cbc2:	4594      	cmp	ip, r2
 801cbc4:	d803      	bhi.n	801cbce <cst_modulo64+0x1e>
 801cbc6:	e00e      	b.n	801cbe6 <cst_modulo64+0x36>
        tmp_m--;
        tmp_m = tmp_m - div_m;
      }
      else
      {
        tmp_m = tmp_m - div_m;
 801cbc8:	1ac9      	subs	r1, r1, r3
        tmp_l = tmp_l - div_l;
 801cbca:	eba2 020c 	sub.w	r2, r2, ip
      }

      div_l = div_l >> 1;
 801cbce:	ea4f 0c5c 	mov.w	ip, ip, lsr #1
      if ((div_m & 1U) == 1U)
 801cbd2:	f013 0f01 	tst.w	r3, #1
 801cbd6:	d001      	beq.n	801cbdc <cst_modulo64+0x2c>
      {
        div_l = div_l | 0x80000000U;
 801cbd8:	f04c 4c00 	orr.w	ip, ip, #2147483648	; 0x80000000
      }
      div_m = div_m >> 1U;
 801cbdc:	085b      	lsrs	r3, r3, #1
    while (tmp_m > 0U)
 801cbde:	b149      	cbz	r1, 801cbf4 <cst_modulo64+0x44>
      if ((div_m > tmp_m) || ((div_m == tmp_m) && (div_l > tmp_l)))
 801cbe0:	428b      	cmp	r3, r1
 801cbe2:	d8f4      	bhi.n	801cbce <cst_modulo64+0x1e>
 801cbe4:	d0ed      	beq.n	801cbc2 <cst_modulo64+0x12>
      else if (div_l > tmp_l)
 801cbe6:	4594      	cmp	ip, r2
 801cbe8:	d9ee      	bls.n	801cbc8 <cst_modulo64+0x18>
        tmp_l = tmp_l - div_l;
 801cbea:	eba2 020c 	sub.w	r2, r2, ip
        tmp_m--;
 801cbee:	3901      	subs	r1, #1
        tmp_m = tmp_m - div_m;
 801cbf0:	1ac9      	subs	r1, r1, r3
 801cbf2:	e7ec      	b.n	801cbce <cst_modulo64+0x1e>
    }
    tmp_l = tmp_l % div;
 801cbf4:	fbb2 f3f0 	udiv	r3, r2, r0
 801cbf8:	fb00 2013 	mls	r0, r0, r3, r2
  }
  return tmp_l;
}
 801cbfc:	4770      	bx	lr
	...

0801cc00 <CST_location_info_callback>:
  * @brief  location info callback callback
  * @param  -
  * @retval -
  */
static void CST_location_info_callback(void)
{
 801cc00:	b538      	push	{r3, r4, r5, lr}
  /* Not used yet: reserved for future usage */
  PRINT_CELLULAR_SERVICE("CST_location_info_callback\n\r")
 801cc02:	4c10      	ldr	r4, [pc, #64]	; (801cc44 <CST_location_info_callback+0x44>)
 801cc04:	4d10      	ldr	r5, [pc, #64]	; (801cc48 <CST_location_info_callback+0x48>)
 801cc06:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801cc08:	6020      	str	r0, [r4, #0]
 801cc0a:	6061      	str	r1, [r4, #4]
 801cc0c:	60a2      	str	r2, [r4, #8]
 801cc0e:	60e3      	str	r3, [r4, #12]
 801cc10:	cd07      	ldmia	r5!, {r0, r1, r2}
 801cc12:	6120      	str	r0, [r4, #16]
 801cc14:	6161      	str	r1, [r4, #20]
 801cc16:	61a2      	str	r2, [r4, #24]
 801cc18:	782b      	ldrb	r3, [r5, #0]
 801cc1a:	7723      	strb	r3, [r4, #28]
 801cc1c:	4620      	mov	r0, r4
 801cc1e:	f002 fb84 	bl	801f32a <crs_strlen>
 801cc22:	b283      	uxth	r3, r0
 801cc24:	4622      	mov	r2, r4
 801cc26:	2101      	movs	r1, #1
 801cc28:	2007      	movs	r0, #7
 801cc2a:	f002 fbc1 	bl	801f3b0 <traceIF_itmPrint>
 801cc2e:	4620      	mov	r0, r4
 801cc30:	f002 fb7b 	bl	801f32a <crs_strlen>
 801cc34:	b283      	uxth	r3, r0
 801cc36:	4622      	mov	r2, r4
 801cc38:	2101      	movs	r1, #1
 801cc3a:	2007      	movs	r0, #7
 801cc3c:	f002 fbda 	bl	801f3f4 <traceIF_uartPrint>
}
 801cc40:	bd38      	pop	{r3, r4, r5, pc}
 801cc42:	bf00      	nop
 801cc44:	20004ddc 	.word	0x20004ddc
 801cc48:	08035434 	.word	0x08035434

0801cc4c <CST_fill_nfmc_tempo>:
  * @param  imsi_high  - high IMSI 32bits value
  * @param  imsi_low   - low IMSI  32bits value
  * @retval -
  */
static void CST_fill_nfmc_tempo(uint32_t imsi_high, uint32_t imsi_low)
{
 801cc4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801cc50:	b08c      	sub	sp, #48	; 0x30
  uint32_t i;
  dc_nfmc_info_t nfmc_info;

  if (cst_cellular_params.nfmc_active != 0U)
 801cc52:	4b2b      	ldr	r3, [pc, #172]	; (801cd00 <CST_fill_nfmc_tempo+0xb4>)
 801cc54:	f893 317c 	ldrb.w	r3, [r3, #380]	; 0x17c
 801cc58:	2b00      	cmp	r3, #0
 801cc5a:	d049      	beq.n	801ccf0 <CST_fill_nfmc_tempo+0xa4>
 801cc5c:	4680      	mov	r8, r0
 801cc5e:	460f      	mov	r7, r1
  {
    /* NFMC active : NFMC tempos calculation */
    cst_nfmc_context.active = true;
 801cc60:	2301      	movs	r3, #1
 801cc62:	4a28      	ldr	r2, [pc, #160]	; (801cd04 <CST_fill_nfmc_tempo+0xb8>)
 801cc64:	7013      	strb	r3, [r2, #0]
    nfmc_info.activate = 1U;
 801cc66:	9304      	str	r3, [sp, #16]
    for (i = 0U; i < CST_NFMC_TEMPO_NB; i++)
 801cc68:	2400      	movs	r4, #0
 801cc6a:	e029      	b.n	801ccc0 <CST_fill_nfmc_tempo+0x74>
      uint32_t temp_value32;

      /* calculation of NFMC tempo */
      if (cst_cellular_params.nfmc_value[i] != 0U)
      {
        temp_value32 = cst_modulo64(cst_cellular_params.nfmc_value[i], imsi_high, imsi_low);
 801cc6c:	463a      	mov	r2, r7
 801cc6e:	4641      	mov	r1, r8
 801cc70:	4630      	mov	r0, r6
 801cc72:	f7ff ff9d 	bl	801cbb0 <cst_modulo64>
 801cc76:	4603      	mov	r3, r0
      }
      else
      {
        temp_value32 = imsi_low;  /* parameter value == 0 => value set to imsi_low */
      }
      temp_value32 = temp_value32 + cst_cellular_params.nfmc_value[i];
 801cc78:	4433      	add	r3, r6
      cst_nfmc_context.tempo[i] = (0xffffffffU & temp_value32);
 801cc7a:	4a22      	ldr	r2, [pc, #136]	; (801cd04 <CST_fill_nfmc_tempo+0xb8>)
 801cc7c:	eb02 0284 	add.w	r2, r2, r4, lsl #2
 801cc80:	6053      	str	r3, [r2, #4]

      nfmc_info.tempo[i] = cst_nfmc_context.tempo[i];
 801cc82:	1d22      	adds	r2, r4, #4
 801cc84:	a90c      	add	r1, sp, #48	; 0x30
 801cc86:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 801cc8a:	f842 3c2c 	str.w	r3, [r2, #-44]
      PRINT_CELLULAR_SERVICE("VALUE/TEMPO %ld/%ld\n\r",  cst_cellular_params.nfmc_value[i], cst_nfmc_context.tempo[i])
 801cc8e:	4d1e      	ldr	r5, [pc, #120]	; (801cd08 <CST_fill_nfmc_tempo+0xbc>)
 801cc90:	4632      	mov	r2, r6
 801cc92:	491e      	ldr	r1, [pc, #120]	; (801cd0c <CST_fill_nfmc_tempo+0xc0>)
 801cc94:	4628      	mov	r0, r5
 801cc96:	f009 fdd7 	bl	8026848 <sprintf>
 801cc9a:	4628      	mov	r0, r5
 801cc9c:	f002 fb45 	bl	801f32a <crs_strlen>
 801cca0:	b283      	uxth	r3, r0
 801cca2:	462a      	mov	r2, r5
 801cca4:	2101      	movs	r1, #1
 801cca6:	2007      	movs	r0, #7
 801cca8:	f002 fb82 	bl	801f3b0 <traceIF_itmPrint>
 801ccac:	4628      	mov	r0, r5
 801ccae:	f002 fb3c 	bl	801f32a <crs_strlen>
 801ccb2:	b283      	uxth	r3, r0
 801ccb4:	462a      	mov	r2, r5
 801ccb6:	2101      	movs	r1, #1
 801ccb8:	2007      	movs	r0, #7
 801ccba:	f002 fb9b 	bl	801f3f4 <traceIF_uartPrint>
    for (i = 0U; i < CST_NFMC_TEMPO_NB; i++)
 801ccbe:	3401      	adds	r4, #1
 801ccc0:	2c06      	cmp	r4, #6
 801ccc2:	d808      	bhi.n	801ccd6 <CST_fill_nfmc_tempo+0x8a>
      if (cst_cellular_params.nfmc_value[i] != 0U)
 801ccc4:	f104 0360 	add.w	r3, r4, #96	; 0x60
 801ccc8:	4a0d      	ldr	r2, [pc, #52]	; (801cd00 <CST_fill_nfmc_tempo+0xb4>)
 801ccca:	f852 6023 	ldr.w	r6, [r2, r3, lsl #2]
 801ccce:	2e00      	cmp	r6, #0
 801ccd0:	d1cc      	bne.n	801cc6c <CST_fill_nfmc_tempo+0x20>
        temp_value32 = imsi_low;  /* parameter value == 0 => value set to imsi_low */
 801ccd2:	463b      	mov	r3, r7
 801ccd4:	e7d0      	b.n	801cc78 <CST_fill_nfmc_tempo+0x2c>
    }
    nfmc_info.rt_state = DC_SERVICE_ON;
 801ccd6:	2307      	movs	r3, #7
 801ccd8:	f88d 300c 	strb.w	r3, [sp, #12]
    /* NFMC not active */
    nfmc_info.activate = 0U;
    nfmc_info.rt_state = DC_SERVICE_OFF;
    cst_nfmc_context.active = false;
  }
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_NFMC_INFO, (void *)&nfmc_info, sizeof(nfmc_info));
 801ccdc:	232c      	movs	r3, #44	; 0x2c
 801ccde:	aa01      	add	r2, sp, #4
 801cce0:	490b      	ldr	r1, [pc, #44]	; (801cd10 <CST_fill_nfmc_tempo+0xc4>)
 801cce2:	8809      	ldrh	r1, [r1, #0]
 801cce4:	480b      	ldr	r0, [pc, #44]	; (801cd14 <CST_fill_nfmc_tempo+0xc8>)
 801cce6:	f005 f9d7 	bl	8022098 <dc_com_write>
}
 801ccea:	b00c      	add	sp, #48	; 0x30
 801ccec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    nfmc_info.activate = 0U;
 801ccf0:	2300      	movs	r3, #0
 801ccf2:	9304      	str	r3, [sp, #16]
    nfmc_info.rt_state = DC_SERVICE_OFF;
 801ccf4:	2203      	movs	r2, #3
 801ccf6:	f88d 200c 	strb.w	r2, [sp, #12]
    cst_nfmc_context.active = false;
 801ccfa:	4a02      	ldr	r2, [pc, #8]	; (801cd04 <CST_fill_nfmc_tempo+0xb8>)
 801ccfc:	7013      	strb	r3, [r2, #0]
 801ccfe:	e7ed      	b.n	801ccdc <CST_fill_nfmc_tempo+0x90>
 801cd00:	20004160 	.word	0x20004160
 801cd04:	2000430c 	.word	0x2000430c
 801cd08:	20004ddc 	.word	0x20004ddc
 801cd0c:	08035454 	.word	0x08035454
 801cd10:	20000238 	.word	0x20000238
 801cd14:	200058b0 	.word	0x200058b0

0801cd18 <CST_fail_setting>:
  * @brief  setting FAIL mode in DC
  * @param  -
  * @retval -
  */
static void CST_fail_setting(void)
{
 801cd18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801cd1c:	f8df 8058 	ldr.w	r8, [pc, #88]	; 801cd78 <CST_fail_setting+0x60>
 801cd20:	4e11      	ldr	r6, [pc, #68]	; (801cd68 <CST_fail_setting+0x50>)
 801cd22:	4c12      	ldr	r4, [pc, #72]	; (801cd6c <CST_fail_setting+0x54>)
 801cd24:	23f4      	movs	r3, #244	; 0xf4
 801cd26:	4632      	mov	r2, r6
 801cd28:	f8b8 1000 	ldrh.w	r1, [r8]
 801cd2c:	4620      	mov	r0, r4
 801cd2e:	f005 f9ff 	bl	8022130 <dc_com_read>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801cd32:	4f0f      	ldr	r7, [pc, #60]	; (801cd70 <CST_fail_setting+0x58>)
 801cd34:	4d0f      	ldr	r5, [pc, #60]	; (801cd74 <CST_fail_setting+0x5c>)
 801cd36:	2310      	movs	r3, #16
 801cd38:	462a      	mov	r2, r5
 801cd3a:	8839      	ldrh	r1, [r7, #0]
 801cd3c:	4620      	mov	r0, r4
 801cd3e:	f005 f9f7 	bl	8022130 <dc_com_read>
                    sizeof(dc_cellular_data_info_t));
  cst_cellular_info.rt_state      = DC_SERVICE_FAIL;
 801cd42:	2308      	movs	r3, #8
 801cd44:	7233      	strb	r3, [r6, #8]
  cst_cellular_data_info.rt_state = DC_SERVICE_FAIL;
 801cd46:	722b      	strb	r3, [r5, #8]
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801cd48:	23f4      	movs	r3, #244	; 0xf4
 801cd4a:	4632      	mov	r2, r6
 801cd4c:	f8b8 1000 	ldrh.w	r1, [r8]
 801cd50:	4620      	mov	r0, r4
 801cd52:	f005 f9a1 	bl	8022098 <dc_com_write>
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801cd56:	2310      	movs	r3, #16
 801cd58:	462a      	mov	r2, r5
 801cd5a:	8839      	ldrh	r1, [r7, #0]
 801cd5c:	4620      	mov	r0, r4
 801cd5e:	f005 f99b 	bl	8022098 <dc_com_write>
                     sizeof(dc_cellular_data_info_t));
}
 801cd62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801cd66:	bf00      	nop
 801cd68:	2000406c 	.word	0x2000406c
 801cd6c:	200058b0 	.word	0x200058b0
 801cd70:	20000234 	.word	0x20000234
 801cd74:	2000405c 	.word	0x2000405c
 801cd78:	20000236 	.word	0x20000236

0801cd7c <CST_network_reg_callback>:
{
 801cd7c:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("==================================CST_network_reg_callback\n\r")
 801cd7e:	4c16      	ldr	r4, [pc, #88]	; (801cdd8 <CST_network_reg_callback+0x5c>)
 801cd80:	4d16      	ldr	r5, [pc, #88]	; (801cddc <CST_network_reg_callback+0x60>)
 801cd82:	f104 0e30 	add.w	lr, r4, #48	; 0x30
 801cd86:	46a4      	mov	ip, r4
 801cd88:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801cd8c:	6028      	str	r0, [r5, #0]
 801cd8e:	6069      	str	r1, [r5, #4]
 801cd90:	60aa      	str	r2, [r5, #8]
 801cd92:	60eb      	str	r3, [r5, #12]
 801cd94:	4664      	mov	r4, ip
 801cd96:	3510      	adds	r5, #16
 801cd98:	45f4      	cmp	ip, lr
 801cd9a:	d1f4      	bne.n	801cd86 <CST_network_reg_callback+0xa>
 801cd9c:	cc07      	ldmia	r4!, {r0, r1, r2}
 801cd9e:	6028      	str	r0, [r5, #0]
 801cda0:	6069      	str	r1, [r5, #4]
 801cda2:	60aa      	str	r2, [r5, #8]
 801cda4:	7823      	ldrb	r3, [r4, #0]
 801cda6:	732b      	strb	r3, [r5, #12]
 801cda8:	4c0c      	ldr	r4, [pc, #48]	; (801cddc <CST_network_reg_callback+0x60>)
 801cdaa:	4620      	mov	r0, r4
 801cdac:	f002 fabd 	bl	801f32a <crs_strlen>
 801cdb0:	b283      	uxth	r3, r0
 801cdb2:	4622      	mov	r2, r4
 801cdb4:	2101      	movs	r1, #1
 801cdb6:	2007      	movs	r0, #7
 801cdb8:	f002 fafa 	bl	801f3b0 <traceIF_itmPrint>
 801cdbc:	4620      	mov	r0, r4
 801cdbe:	f002 fab4 	bl	801f32a <crs_strlen>
 801cdc2:	b283      	uxth	r3, r0
 801cdc4:	4622      	mov	r2, r4
 801cdc6:	2101      	movs	r1, #1
 801cdc8:	2007      	movs	r0, #7
 801cdca:	f002 fb13 	bl	801f3f4 <traceIF_uartPrint>
  CST_send_message(CST_MESSAGE_CS_EVENT, CST_NETWORK_CALLBACK_EVENT);
 801cdce:	2113      	movs	r1, #19
 801cdd0:	2000      	movs	r0, #0
 801cdd2:	f7fe fa15 	bl	801b200 <CST_send_message>
}
 801cdd6:	bd38      	pop	{r3, r4, r5, pc}
 801cdd8:	0803546c 	.word	0x0803546c
 801cddc:	20004ddc 	.word	0x20004ddc

0801cde0 <CST_modem_event_callback>:
{
 801cde0:	b570      	push	{r4, r5, r6, lr}
 801cde2:	4604      	mov	r4, r0
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_BOOT) != 0U)
 801cde4:	f010 0f01 	tst.w	r0, #1
 801cde8:	d109      	bne.n	801cdfe <CST_modem_event_callback+0x1e>
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_POWER_DOWN) != 0U)
 801cdea:	f014 0f02 	tst.w	r4, #2
 801cdee:	d10b      	bne.n	801ce08 <CST_modem_event_callback+0x28>
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_FOTA_START) != 0U)
 801cdf0:	f014 0f04 	tst.w	r4, #4
 801cdf4:	d12f      	bne.n	801ce56 <CST_modem_event_callback+0x76>
  if (((uint16_t)event & (uint16_t)CS_MDMEVENT_FOTA_END) != 0U)
 801cdf6:	f014 0f08 	tst.w	r4, #8
 801cdfa:	d131      	bne.n	801ce60 <CST_modem_event_callback+0x80>
}
 801cdfc:	bd70      	pop	{r4, r5, r6, pc}
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_REBOOT_MODEM_EVENT);
 801cdfe:	2111      	movs	r1, #17
 801ce00:	2000      	movs	r0, #0
 801ce02:	f7fe f9fd 	bl	801b200 <CST_send_message>
 801ce06:	e7f0      	b.n	801cdea <CST_modem_event_callback+0xa>
    PRINT_CELLULAR_SERVICE("Modem event received:  CS_MDMEVENT_POWER_DOWN\n\r")
 801ce08:	4e18      	ldr	r6, [pc, #96]	; (801ce6c <CST_modem_event_callback+0x8c>)
 801ce0a:	4d19      	ldr	r5, [pc, #100]	; (801ce70 <CST_modem_event_callback+0x90>)
 801ce0c:	f106 0e30 	add.w	lr, r6, #48	; 0x30
 801ce10:	46b4      	mov	ip, r6
 801ce12:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ce16:	6028      	str	r0, [r5, #0]
 801ce18:	6069      	str	r1, [r5, #4]
 801ce1a:	60aa      	str	r2, [r5, #8]
 801ce1c:	60eb      	str	r3, [r5, #12]
 801ce1e:	4666      	mov	r6, ip
 801ce20:	3510      	adds	r5, #16
 801ce22:	45f4      	cmp	ip, lr
 801ce24:	d1f4      	bne.n	801ce10 <CST_modem_event_callback+0x30>
 801ce26:	4d12      	ldr	r5, [pc, #72]	; (801ce70 <CST_modem_event_callback+0x90>)
 801ce28:	4628      	mov	r0, r5
 801ce2a:	f002 fa7e 	bl	801f32a <crs_strlen>
 801ce2e:	b283      	uxth	r3, r0
 801ce30:	462a      	mov	r2, r5
 801ce32:	2101      	movs	r1, #1
 801ce34:	2007      	movs	r0, #7
 801ce36:	f002 fabb 	bl	801f3b0 <traceIF_itmPrint>
 801ce3a:	4628      	mov	r0, r5
 801ce3c:	f002 fa75 	bl	801f32a <crs_strlen>
 801ce40:	b283      	uxth	r3, r0
 801ce42:	462a      	mov	r2, r5
 801ce44:	2101      	movs	r1, #1
 801ce46:	2007      	movs	r0, #7
 801ce48:	f002 fad4 	bl	801f3f4 <traceIF_uartPrint>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_POWER_DOWN_EVENT);
 801ce4c:	211b      	movs	r1, #27
 801ce4e:	2000      	movs	r0, #0
 801ce50:	f7fe f9d6 	bl	801b200 <CST_send_message>
 801ce54:	e7cc      	b.n	801cdf0 <CST_modem_event_callback+0x10>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_FOTA_START_EVENT);
 801ce56:	2115      	movs	r1, #21
 801ce58:	2000      	movs	r0, #0
 801ce5a:	f7fe f9d1 	bl	801b200 <CST_send_message>
 801ce5e:	e7ca      	b.n	801cdf6 <CST_modem_event_callback+0x16>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_FOTA_END_EVENT);
 801ce60:	2116      	movs	r1, #22
 801ce62:	2000      	movs	r0, #0
 801ce64:	f7fe f9cc 	bl	801b200 <CST_send_message>
}
 801ce68:	e7c8      	b.n	801cdfc <CST_modem_event_callback+0x1c>
 801ce6a:	bf00      	nop
 801ce6c:	080354ac 	.word	0x080354ac
 801ce70:	20004ddc 	.word	0x20004ddc

0801ce74 <CST_get_device_all_infos>:
{
 801ce74:	b570      	push	{r4, r5, r6, lr}
 801ce76:	b082      	sub	sp, #8
 801ce78:	4605      	mov	r5, r0
  (void)memset((void *)&cst_device_info, 0, sizeof(CS_DeviceInfo_t));
 801ce7a:	4cd5      	ldr	r4, [pc, #852]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801ce7c:	f44f 7281 	mov.w	r2, #258	; 0x102
 801ce80:	2100      	movs	r1, #0
 801ce82:	4620      	mov	r0, r4
 801ce84:	f009 fd53 	bl	802692e <memset>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801ce88:	23f4      	movs	r3, #244	; 0xf4
 801ce8a:	4ad2      	ldr	r2, [pc, #840]	; (801d1d4 <CST_get_device_all_infos+0x360>)
 801ce8c:	49d2      	ldr	r1, [pc, #840]	; (801d1d8 <CST_get_device_all_infos+0x364>)
 801ce8e:	8809      	ldrh	r1, [r1, #0]
 801ce90:	48d2      	ldr	r0, [pc, #840]	; (801d1dc <CST_get_device_all_infos+0x368>)
 801ce92:	f005 f94d 	bl	8022130 <dc_com_read>
  cst_device_info.field_requested = CS_DIF_IMEI_PRESENT;
 801ce96:	2301      	movs	r3, #1
 801ce98:	8023      	strh	r3, [r4, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801ce9a:	4620      	mov	r0, r4
 801ce9c:	f7fd fe9a 	bl	801abd4 <osCDS_get_device_info>
 801cea0:	2800      	cmp	r0, #0
 801cea2:	f040 8177 	bne.w	801d194 <CST_get_device_all_infos+0x320>
    (void)memcpy(cst_cellular_info.imei, cst_device_info.u.imei, DC_MAX_SIZE_IMEI - 1U);
 801cea6:	4ece      	ldr	r6, [pc, #824]	; (801d1e0 <CST_get_device_all_infos+0x36c>)
 801cea8:	46b4      	mov	ip, r6
 801ceaa:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801ceae:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801ceb2:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801ceb6:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801ceba:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cebe:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801cec2:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801cec6:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801ceca:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cece:	8be2      	ldrh	r2, [r4, #30]
 801ced0:	f894 3020 	ldrb.w	r3, [r4, #32]
 801ced4:	f8ac 2000 	strh.w	r2, [ip]
 801ced8:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.imei[DC_MAX_SIZE_IMEI - 1U] = 0U;     /* to avoid a non null terminated string */
 801cedc:	2300      	movs	r3, #0
 801cede:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -IMEI: %s\n\r", cst_device_info.u.imei)
 801cee0:	4ec0      	ldr	r6, [pc, #768]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801cee2:	1ca2      	adds	r2, r4, #2
 801cee4:	49c0      	ldr	r1, [pc, #768]	; (801d1e8 <CST_get_device_all_infos+0x374>)
 801cee6:	4630      	mov	r0, r6
 801cee8:	f009 fcae 	bl	8026848 <sprintf>
 801ceec:	4630      	mov	r0, r6
 801ceee:	f002 fa1c 	bl	801f32a <crs_strlen>
 801cef2:	b283      	uxth	r3, r0
 801cef4:	4632      	mov	r2, r6
 801cef6:	2101      	movs	r1, #1
 801cef8:	2007      	movs	r0, #7
 801cefa:	f002 fa59 	bl	801f3b0 <traceIF_itmPrint>
 801cefe:	4630      	mov	r0, r6
 801cf00:	f002 fa13 	bl	801f32a <crs_strlen>
 801cf04:	b283      	uxth	r3, r0
 801cf06:	4632      	mov	r2, r6
 801cf08:	2101      	movs	r1, #1
 801cf0a:	2007      	movs	r0, #7
 801cf0c:	f002 fa72 	bl	801f3f4 <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_MANUF_NAME_PRESENT;
 801cf10:	48af      	ldr	r0, [pc, #700]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801cf12:	2302      	movs	r3, #2
 801cf14:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801cf16:	f7fd fe5d 	bl	801abd4 <osCDS_get_device_info>
 801cf1a:	2800      	cmp	r0, #0
 801cf1c:	f040 817c 	bne.w	801d218 <CST_get_device_all_infos+0x3a4>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.manufacturer_name,
 801cf20:	4eb2      	ldr	r6, [pc, #712]	; (801d1ec <CST_get_device_all_infos+0x378>)
 801cf22:	4cab      	ldr	r4, [pc, #684]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801cf24:	46b4      	mov	ip, r6
 801cf26:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801cf2a:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801cf2e:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801cf32:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801cf36:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cf3a:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801cf3e:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801cf42:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801cf46:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cf4a:	8be2      	ldrh	r2, [r4, #30]
 801cf4c:	f894 3020 	ldrb.w	r3, [r4, #32]
 801cf50:	f8ac 2000 	strh.w	r2, [ip]
 801cf54:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.manufacturer_name[DC_MAX_SIZE_MANUFACT_NAME - 1U] = 0U;
 801cf58:	2300      	movs	r3, #0
 801cf5a:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -MANUFACTURER: %s\n\r", cst_device_info.u.manufacturer_name)
 801cf5c:	4ea1      	ldr	r6, [pc, #644]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801cf5e:	1ca2      	adds	r2, r4, #2
 801cf60:	49a3      	ldr	r1, [pc, #652]	; (801d1f0 <CST_get_device_all_infos+0x37c>)
 801cf62:	4630      	mov	r0, r6
 801cf64:	f009 fc70 	bl	8026848 <sprintf>
 801cf68:	4630      	mov	r0, r6
 801cf6a:	f002 f9de 	bl	801f32a <crs_strlen>
 801cf6e:	b283      	uxth	r3, r0
 801cf70:	4632      	mov	r2, r6
 801cf72:	2101      	movs	r1, #1
 801cf74:	2007      	movs	r0, #7
 801cf76:	f002 fa1b 	bl	801f3b0 <traceIF_itmPrint>
 801cf7a:	4630      	mov	r0, r6
 801cf7c:	f002 f9d5 	bl	801f32a <crs_strlen>
 801cf80:	b283      	uxth	r3, r0
 801cf82:	4632      	mov	r2, r6
 801cf84:	2101      	movs	r1, #1
 801cf86:	2007      	movs	r0, #7
 801cf88:	f002 fa34 	bl	801f3f4 <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_MODEL_PRESENT;
 801cf8c:	4890      	ldr	r0, [pc, #576]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801cf8e:	2304      	movs	r3, #4
 801cf90:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801cf92:	f7fd fe1f 	bl	801abd4 <osCDS_get_device_info>
 801cf96:	2800      	cmp	r0, #0
 801cf98:	f040 8161 	bne.w	801d25e <CST_get_device_all_infos+0x3ea>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.model,
 801cf9c:	4e95      	ldr	r6, [pc, #596]	; (801d1f4 <CST_get_device_all_infos+0x380>)
 801cf9e:	4c8c      	ldr	r4, [pc, #560]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801cfa0:	46b4      	mov	ip, r6
 801cfa2:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801cfa6:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801cfaa:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801cfae:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801cfb2:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801cfb6:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801cfba:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801cfbe:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801cfc2:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801cfc6:	8be2      	ldrh	r2, [r4, #30]
 801cfc8:	f894 3020 	ldrb.w	r3, [r4, #32]
 801cfcc:	f8ac 2000 	strh.w	r2, [ip]
 801cfd0:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.model[DC_MAX_SIZE_MODEL - 1U] = 0U; /* to avoid a non null terminated string */
 801cfd4:	2300      	movs	r3, #0
 801cfd6:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -MODEL: %s\n\r", cst_device_info.u.model)
 801cfd8:	4e82      	ldr	r6, [pc, #520]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801cfda:	1ca2      	adds	r2, r4, #2
 801cfdc:	4986      	ldr	r1, [pc, #536]	; (801d1f8 <CST_get_device_all_infos+0x384>)
 801cfde:	4630      	mov	r0, r6
 801cfe0:	f009 fc32 	bl	8026848 <sprintf>
 801cfe4:	4630      	mov	r0, r6
 801cfe6:	f002 f9a0 	bl	801f32a <crs_strlen>
 801cfea:	b283      	uxth	r3, r0
 801cfec:	4632      	mov	r2, r6
 801cfee:	2101      	movs	r1, #1
 801cff0:	2007      	movs	r0, #7
 801cff2:	f002 f9dd 	bl	801f3b0 <traceIF_itmPrint>
 801cff6:	4630      	mov	r0, r6
 801cff8:	f002 f997 	bl	801f32a <crs_strlen>
 801cffc:	b283      	uxth	r3, r0
 801cffe:	4632      	mov	r2, r6
 801d000:	2101      	movs	r1, #1
 801d002:	2007      	movs	r0, #7
 801d004:	f002 f9f6 	bl	801f3f4 <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_REV_PRESENT;
 801d008:	4871      	ldr	r0, [pc, #452]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801d00a:	2308      	movs	r3, #8
 801d00c:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801d00e:	f7fd fde1 	bl	801abd4 <osCDS_get_device_info>
 801d012:	2800      	cmp	r0, #0
 801d014:	f040 8142 	bne.w	801d29c <CST_get_device_all_infos+0x428>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.revision,
 801d018:	4e78      	ldr	r6, [pc, #480]	; (801d1fc <CST_get_device_all_infos+0x388>)
 801d01a:	4c6d      	ldr	r4, [pc, #436]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801d01c:	46b4      	mov	ip, r6
 801d01e:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801d022:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801d026:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801d02a:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801d02e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801d032:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801d036:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801d03a:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801d03e:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801d042:	8be2      	ldrh	r2, [r4, #30]
 801d044:	f894 3020 	ldrb.w	r3, [r4, #32]
 801d048:	f8ac 2000 	strh.w	r2, [ip]
 801d04c:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.revision[DC_MAX_SIZE_REV - 1U] = 0U; /* to avoid a non null terminated string */
 801d050:	2300      	movs	r3, #0
 801d052:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -REVISION: %s\n\r", cst_device_info.u.revision)
 801d054:	4e63      	ldr	r6, [pc, #396]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801d056:	1ca2      	adds	r2, r4, #2
 801d058:	4969      	ldr	r1, [pc, #420]	; (801d200 <CST_get_device_all_infos+0x38c>)
 801d05a:	4630      	mov	r0, r6
 801d05c:	f009 fbf4 	bl	8026848 <sprintf>
 801d060:	4630      	mov	r0, r6
 801d062:	f002 f962 	bl	801f32a <crs_strlen>
 801d066:	b283      	uxth	r3, r0
 801d068:	4632      	mov	r2, r6
 801d06a:	2101      	movs	r1, #1
 801d06c:	2007      	movs	r0, #7
 801d06e:	f002 f99f 	bl	801f3b0 <traceIF_itmPrint>
 801d072:	4630      	mov	r0, r6
 801d074:	f002 f959 	bl	801f32a <crs_strlen>
 801d078:	b283      	uxth	r3, r0
 801d07a:	4632      	mov	r2, r6
 801d07c:	2101      	movs	r1, #1
 801d07e:	2007      	movs	r0, #7
 801d080:	f002 f9b8 	bl	801f3f4 <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_SN_PRESENT;
 801d084:	4852      	ldr	r0, [pc, #328]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801d086:	2310      	movs	r3, #16
 801d088:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801d08a:	f7fd fda3 	bl	801abd4 <osCDS_get_device_info>
 801d08e:	2800      	cmp	r0, #0
 801d090:	f040 8124 	bne.w	801d2dc <CST_get_device_all_infos+0x468>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.serial_number,
 801d094:	4e5b      	ldr	r6, [pc, #364]	; (801d204 <CST_get_device_all_infos+0x390>)
 801d096:	4c4e      	ldr	r4, [pc, #312]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801d098:	46b4      	mov	ip, r6
 801d09a:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801d09e:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801d0a2:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801d0a6:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801d0aa:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801d0ae:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801d0b2:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801d0b6:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801d0ba:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801d0be:	8be2      	ldrh	r2, [r4, #30]
 801d0c0:	f894 3020 	ldrb.w	r3, [r4, #32]
 801d0c4:	f8ac 2000 	strh.w	r2, [ip]
 801d0c8:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.serial_number[DC_MAX_SIZE_SN - 1U] = 0U; /* to avoid a non null terminated string */
 801d0cc:	2300      	movs	r3, #0
 801d0ce:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -SERIAL NBR: %s\n\r", cst_device_info.u.serial_number)
 801d0d0:	4e44      	ldr	r6, [pc, #272]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801d0d2:	1ca2      	adds	r2, r4, #2
 801d0d4:	494c      	ldr	r1, [pc, #304]	; (801d208 <CST_get_device_all_infos+0x394>)
 801d0d6:	4630      	mov	r0, r6
 801d0d8:	f009 fbb6 	bl	8026848 <sprintf>
 801d0dc:	4630      	mov	r0, r6
 801d0de:	f002 f924 	bl	801f32a <crs_strlen>
 801d0e2:	b283      	uxth	r3, r0
 801d0e4:	4632      	mov	r2, r6
 801d0e6:	2101      	movs	r1, #1
 801d0e8:	2007      	movs	r0, #7
 801d0ea:	f002 f961 	bl	801f3b0 <traceIF_itmPrint>
 801d0ee:	4630      	mov	r0, r6
 801d0f0:	f002 f91b 	bl	801f32a <crs_strlen>
 801d0f4:	b283      	uxth	r3, r0
 801d0f6:	4632      	mov	r2, r6
 801d0f8:	2101      	movs	r1, #1
 801d0fa:	2007      	movs	r0, #7
 801d0fc:	f002 f97a 	bl	801f3f4 <traceIF_uartPrint>
  cst_device_info.field_requested = CS_DIF_ICCID_PRESENT;
 801d100:	4833      	ldr	r0, [pc, #204]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801d102:	2380      	movs	r3, #128	; 0x80
 801d104:	8003      	strh	r3, [r0, #0]
  if (osCDS_get_device_info(&cst_device_info) == CELLULAR_OK)
 801d106:	f7fd fd65 	bl	801abd4 <osCDS_get_device_info>
 801d10a:	2800      	cmp	r0, #0
 801d10c:	f040 8108 	bne.w	801d320 <CST_get_device_all_infos+0x4ac>
    (void)memcpy((CRC_CHAR_t *)cst_cellular_info.iccid,
 801d110:	4e3e      	ldr	r6, [pc, #248]	; (801d20c <CST_get_device_all_infos+0x398>)
 801d112:	4c2f      	ldr	r4, [pc, #188]	; (801d1d0 <CST_get_device_all_infos+0x35c>)
 801d114:	46b4      	mov	ip, r6
 801d116:	f8d4 0002 	ldr.w	r0, [r4, #2]
 801d11a:	f8d4 1006 	ldr.w	r1, [r4, #6]
 801d11e:	f8d4 200a 	ldr.w	r2, [r4, #10]
 801d122:	f8d4 300e 	ldr.w	r3, [r4, #14]
 801d126:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801d12a:	f8d4 0012 	ldr.w	r0, [r4, #18]
 801d12e:	f8d4 1016 	ldr.w	r1, [r4, #22]
 801d132:	f8d4 201a 	ldr.w	r2, [r4, #26]
 801d136:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 801d13a:	8be2      	ldrh	r2, [r4, #30]
 801d13c:	f894 3020 	ldrb.w	r3, [r4, #32]
 801d140:	f8ac 2000 	strh.w	r2, [ip]
 801d144:	f88c 3002 	strb.w	r3, [ip, #2]
    cst_cellular_info.iccid[DC_MAX_SIZE_ICCID - 1U] = 0U; /* to avoid a non null terminated string */
 801d148:	2300      	movs	r3, #0
 801d14a:	77f3      	strb	r3, [r6, #31]
    PRINT_CELLULAR_SERVICE(" -ICCID: %s\n\r", cst_device_info.u.iccid)
 801d14c:	4e25      	ldr	r6, [pc, #148]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801d14e:	1ca2      	adds	r2, r4, #2
 801d150:	492f      	ldr	r1, [pc, #188]	; (801d210 <CST_get_device_all_infos+0x39c>)
 801d152:	4630      	mov	r0, r6
 801d154:	f009 fb78 	bl	8026848 <sprintf>
 801d158:	4630      	mov	r0, r6
 801d15a:	f002 f8e6 	bl	801f32a <crs_strlen>
 801d15e:	b283      	uxth	r3, r0
 801d160:	4632      	mov	r2, r6
 801d162:	2101      	movs	r1, #1
 801d164:	2007      	movs	r0, #7
 801d166:	f002 f923 	bl	801f3b0 <traceIF_itmPrint>
 801d16a:	4630      	mov	r0, r6
 801d16c:	f002 f8dd 	bl	801f32a <crs_strlen>
 801d170:	b283      	uxth	r3, r0
 801d172:	4632      	mov	r2, r6
 801d174:	2101      	movs	r1, #1
 801d176:	2007      	movs	r0, #7
 801d178:	f002 f93c 	bl	801f3f4 <traceIF_uartPrint>
  (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801d17c:	23f4      	movs	r3, #244	; 0xf4
 801d17e:	4a15      	ldr	r2, [pc, #84]	; (801d1d4 <CST_get_device_all_infos+0x360>)
 801d180:	4915      	ldr	r1, [pc, #84]	; (801d1d8 <CST_get_device_all_infos+0x364>)
 801d182:	8809      	ldrh	r1, [r1, #0]
 801d184:	4815      	ldr	r0, [pc, #84]	; (801d1dc <CST_get_device_all_infos+0x368>)
 801d186:	f004 ff87 	bl	8022098 <dc_com_write>
  if (target_state == DC_TARGET_STATE_FULL)
 801d18a:	2d02      	cmp	r5, #2
 801d18c:	f000 80ea 	beq.w	801d364 <CST_get_device_all_infos+0x4f0>
}
 801d190:	b002      	add	sp, #8
 801d192:	bd70      	pop	{r4, r5, r6, pc}
    cst_cellular_info.imei[0] = 0U;
 801d194:	4b0f      	ldr	r3, [pc, #60]	; (801d1d4 <CST_get_device_all_infos+0x360>)
 801d196:	2200      	movs	r2, #0
 801d198:	741a      	strb	r2, [r3, #16]
    PRINT_CELLULAR_SERVICE("IMEI error\n\r")
 801d19a:	4c12      	ldr	r4, [pc, #72]	; (801d1e4 <CST_get_device_all_infos+0x370>)
 801d19c:	4b1d      	ldr	r3, [pc, #116]	; (801d214 <CST_get_device_all_infos+0x3a0>)
 801d19e:	cb07      	ldmia	r3!, {r0, r1, r2}
 801d1a0:	6020      	str	r0, [r4, #0]
 801d1a2:	6061      	str	r1, [r4, #4]
 801d1a4:	60a2      	str	r2, [r4, #8]
 801d1a6:	781b      	ldrb	r3, [r3, #0]
 801d1a8:	7323      	strb	r3, [r4, #12]
 801d1aa:	4620      	mov	r0, r4
 801d1ac:	f002 f8bd 	bl	801f32a <crs_strlen>
 801d1b0:	b283      	uxth	r3, r0
 801d1b2:	4622      	mov	r2, r4
 801d1b4:	2101      	movs	r1, #1
 801d1b6:	2007      	movs	r0, #7
 801d1b8:	f002 f8fa 	bl	801f3b0 <traceIF_itmPrint>
 801d1bc:	4620      	mov	r0, r4
 801d1be:	f002 f8b4 	bl	801f32a <crs_strlen>
 801d1c2:	b283      	uxth	r3, r0
 801d1c4:	4622      	mov	r2, r4
 801d1c6:	2101      	movs	r1, #1
 801d1c8:	2007      	movs	r0, #7
 801d1ca:	f002 f913 	bl	801f3f4 <traceIF_uartPrint>
 801d1ce:	e69f      	b.n	801cf10 <CST_get_device_all_infos+0x9c>
 801d1d0:	200043b0 	.word	0x200043b0
 801d1d4:	2000406c 	.word	0x2000406c
 801d1d8:	20000236 	.word	0x20000236
 801d1dc:	200058b0 	.word	0x200058b0
 801d1e0:	2000407c 	.word	0x2000407c
 801d1e4:	20004ddc 	.word	0x20004ddc
 801d1e8:	080354dc 	.word	0x080354dc
 801d1ec:	200040bc 	.word	0x200040bc
 801d1f0:	080354fc 	.word	0x080354fc
 801d1f4:	200040dc 	.word	0x200040dc
 801d1f8:	08035530 	.word	0x08035530
 801d1fc:	200040fc 	.word	0x200040fc
 801d200:	08035550 	.word	0x08035550
 801d204:	2000411c 	.word	0x2000411c
 801d208:	08035578 	.word	0x08035578
 801d20c:	2000413c 	.word	0x2000413c
 801d210:	080355a4 	.word	0x080355a4
 801d214:	080354ec 	.word	0x080354ec
    cst_cellular_info.manufacturer_name[0] = 0U;
 801d218:	4baa      	ldr	r3, [pc, #680]	; (801d4c4 <CST_get_device_all_infos+0x650>)
 801d21a:	2200      	movs	r2, #0
 801d21c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    PRINT_CELLULAR_SERVICE("Manufacturer Name error\n\r")
 801d220:	4ca9      	ldr	r4, [pc, #676]	; (801d4c8 <CST_get_device_all_infos+0x654>)
 801d222:	4eaa      	ldr	r6, [pc, #680]	; (801d4cc <CST_get_device_all_infos+0x658>)
 801d224:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d226:	6020      	str	r0, [r4, #0]
 801d228:	6061      	str	r1, [r4, #4]
 801d22a:	60a2      	str	r2, [r4, #8]
 801d22c:	60e3      	str	r3, [r4, #12]
 801d22e:	ce03      	ldmia	r6!, {r0, r1}
 801d230:	6120      	str	r0, [r4, #16]
 801d232:	6161      	str	r1, [r4, #20]
 801d234:	8833      	ldrh	r3, [r6, #0]
 801d236:	8323      	strh	r3, [r4, #24]
 801d238:	4620      	mov	r0, r4
 801d23a:	f002 f876 	bl	801f32a <crs_strlen>
 801d23e:	b283      	uxth	r3, r0
 801d240:	4622      	mov	r2, r4
 801d242:	2101      	movs	r1, #1
 801d244:	2007      	movs	r0, #7
 801d246:	f002 f8b3 	bl	801f3b0 <traceIF_itmPrint>
 801d24a:	4620      	mov	r0, r4
 801d24c:	f002 f86d 	bl	801f32a <crs_strlen>
 801d250:	b283      	uxth	r3, r0
 801d252:	4622      	mov	r2, r4
 801d254:	2101      	movs	r1, #1
 801d256:	2007      	movs	r0, #7
 801d258:	f002 f8cc 	bl	801f3f4 <traceIF_uartPrint>
 801d25c:	e696      	b.n	801cf8c <CST_get_device_all_infos+0x118>
    cst_cellular_info.model[0] = 0U;
 801d25e:	4b99      	ldr	r3, [pc, #612]	; (801d4c4 <CST_get_device_all_infos+0x650>)
 801d260:	2200      	movs	r2, #0
 801d262:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
    PRINT_CELLULAR_SERVICE("Model error\n\r")
 801d266:	4c98      	ldr	r4, [pc, #608]	; (801d4c8 <CST_get_device_all_infos+0x654>)
 801d268:	4b99      	ldr	r3, [pc, #612]	; (801d4d0 <CST_get_device_all_infos+0x65c>)
 801d26a:	cb07      	ldmia	r3!, {r0, r1, r2}
 801d26c:	6020      	str	r0, [r4, #0]
 801d26e:	6061      	str	r1, [r4, #4]
 801d270:	60a2      	str	r2, [r4, #8]
 801d272:	881b      	ldrh	r3, [r3, #0]
 801d274:	81a3      	strh	r3, [r4, #12]
 801d276:	4620      	mov	r0, r4
 801d278:	f002 f857 	bl	801f32a <crs_strlen>
 801d27c:	b283      	uxth	r3, r0
 801d27e:	4622      	mov	r2, r4
 801d280:	2101      	movs	r1, #1
 801d282:	2007      	movs	r0, #7
 801d284:	f002 f894 	bl	801f3b0 <traceIF_itmPrint>
 801d288:	4620      	mov	r0, r4
 801d28a:	f002 f84e 	bl	801f32a <crs_strlen>
 801d28e:	b283      	uxth	r3, r0
 801d290:	4622      	mov	r2, r4
 801d292:	2101      	movs	r1, #1
 801d294:	2007      	movs	r0, #7
 801d296:	f002 f8ad 	bl	801f3f4 <traceIF_uartPrint>
 801d29a:	e6b5      	b.n	801d008 <CST_get_device_all_infos+0x194>
    cst_cellular_info.revision[0] = 0U;
 801d29c:	4b89      	ldr	r3, [pc, #548]	; (801d4c4 <CST_get_device_all_infos+0x650>)
 801d29e:	2200      	movs	r2, #0
 801d2a0:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
    PRINT_CELLULAR_SERVICE("Revision error\n\r")
 801d2a4:	4c88      	ldr	r4, [pc, #544]	; (801d4c8 <CST_get_device_all_infos+0x654>)
 801d2a6:	4e8b      	ldr	r6, [pc, #556]	; (801d4d4 <CST_get_device_all_infos+0x660>)
 801d2a8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d2aa:	6020      	str	r0, [r4, #0]
 801d2ac:	6061      	str	r1, [r4, #4]
 801d2ae:	60a2      	str	r2, [r4, #8]
 801d2b0:	60e3      	str	r3, [r4, #12]
 801d2b2:	7833      	ldrb	r3, [r6, #0]
 801d2b4:	7423      	strb	r3, [r4, #16]
 801d2b6:	4620      	mov	r0, r4
 801d2b8:	f002 f837 	bl	801f32a <crs_strlen>
 801d2bc:	b283      	uxth	r3, r0
 801d2be:	4622      	mov	r2, r4
 801d2c0:	2101      	movs	r1, #1
 801d2c2:	2007      	movs	r0, #7
 801d2c4:	f002 f874 	bl	801f3b0 <traceIF_itmPrint>
 801d2c8:	4620      	mov	r0, r4
 801d2ca:	f002 f82e 	bl	801f32a <crs_strlen>
 801d2ce:	b283      	uxth	r3, r0
 801d2d0:	4622      	mov	r2, r4
 801d2d2:	2101      	movs	r1, #1
 801d2d4:	2007      	movs	r0, #7
 801d2d6:	f002 f88d 	bl	801f3f4 <traceIF_uartPrint>
 801d2da:	e6d3      	b.n	801d084 <CST_get_device_all_infos+0x210>
    cst_cellular_info.serial_number[0] = 0U;
 801d2dc:	4b79      	ldr	r3, [pc, #484]	; (801d4c4 <CST_get_device_all_infos+0x650>)
 801d2de:	2200      	movs	r2, #0
 801d2e0:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
    PRINT_CELLULAR_SERVICE("Serial Number error\n\r")
 801d2e4:	4c78      	ldr	r4, [pc, #480]	; (801d4c8 <CST_get_device_all_infos+0x654>)
 801d2e6:	4e7c      	ldr	r6, [pc, #496]	; (801d4d8 <CST_get_device_all_infos+0x664>)
 801d2e8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d2ea:	6020      	str	r0, [r4, #0]
 801d2ec:	6061      	str	r1, [r4, #4]
 801d2ee:	60a2      	str	r2, [r4, #8]
 801d2f0:	60e3      	str	r3, [r4, #12]
 801d2f2:	6830      	ldr	r0, [r6, #0]
 801d2f4:	6120      	str	r0, [r4, #16]
 801d2f6:	88b3      	ldrh	r3, [r6, #4]
 801d2f8:	82a3      	strh	r3, [r4, #20]
 801d2fa:	4620      	mov	r0, r4
 801d2fc:	f002 f815 	bl	801f32a <crs_strlen>
 801d300:	b283      	uxth	r3, r0
 801d302:	4622      	mov	r2, r4
 801d304:	2101      	movs	r1, #1
 801d306:	2007      	movs	r0, #7
 801d308:	f002 f852 	bl	801f3b0 <traceIF_itmPrint>
 801d30c:	4620      	mov	r0, r4
 801d30e:	f002 f80c 	bl	801f32a <crs_strlen>
 801d312:	b283      	uxth	r3, r0
 801d314:	4622      	mov	r2, r4
 801d316:	2101      	movs	r1, #1
 801d318:	2007      	movs	r0, #7
 801d31a:	f002 f86b 	bl	801f3f4 <traceIF_uartPrint>
 801d31e:	e6ef      	b.n	801d100 <CST_get_device_all_infos+0x28c>
    cst_cellular_info.serial_number[0] = 0U;
 801d320:	4b68      	ldr	r3, [pc, #416]	; (801d4c4 <CST_get_device_all_infos+0x650>)
 801d322:	2200      	movs	r2, #0
 801d324:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
    PRINT_CELLULAR_SERVICE("Serial Number error\n\r")
 801d328:	4c67      	ldr	r4, [pc, #412]	; (801d4c8 <CST_get_device_all_infos+0x654>)
 801d32a:	4e6b      	ldr	r6, [pc, #428]	; (801d4d8 <CST_get_device_all_infos+0x664>)
 801d32c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801d32e:	6020      	str	r0, [r4, #0]
 801d330:	6061      	str	r1, [r4, #4]
 801d332:	60a2      	str	r2, [r4, #8]
 801d334:	60e3      	str	r3, [r4, #12]
 801d336:	6830      	ldr	r0, [r6, #0]
 801d338:	6120      	str	r0, [r4, #16]
 801d33a:	88b3      	ldrh	r3, [r6, #4]
 801d33c:	82a3      	strh	r3, [r4, #20]
 801d33e:	4620      	mov	r0, r4
 801d340:	f001 fff3 	bl	801f32a <crs_strlen>
 801d344:	b283      	uxth	r3, r0
 801d346:	4622      	mov	r2, r4
 801d348:	2101      	movs	r1, #1
 801d34a:	2007      	movs	r0, #7
 801d34c:	f002 f830 	bl	801f3b0 <traceIF_itmPrint>
 801d350:	4620      	mov	r0, r4
 801d352:	f001 ffea 	bl	801f32a <crs_strlen>
 801d356:	b283      	uxth	r3, r0
 801d358:	4622      	mov	r2, r4
 801d35a:	2101      	movs	r1, #1
 801d35c:	2007      	movs	r0, #7
 801d35e:	f002 f849 	bl	801f3f4 <traceIF_uartPrint>
 801d362:	e70b      	b.n	801d17c <CST_get_device_all_infos+0x308>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d364:	4e5d      	ldr	r6, [pc, #372]	; (801d4dc <CST_get_device_all_infos+0x668>)
 801d366:	4c5e      	ldr	r4, [pc, #376]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d368:	4d5e      	ldr	r5, [pc, #376]	; (801d4e4 <CST_get_device_all_infos+0x670>)
 801d36a:	2330      	movs	r3, #48	; 0x30
 801d36c:	4622      	mov	r2, r4
 801d36e:	8831      	ldrh	r1, [r6, #0]
 801d370:	4628      	mov	r0, r5
 801d372:	f004 fedd 	bl	8022130 <dc_com_read>
    cst_sim_info.rt_state   = DC_SERVICE_ON;
 801d376:	2307      	movs	r3, #7
 801d378:	7223      	strb	r3, [r4, #8]
    cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_CONNECTION_ON_GOING;
 801d37a:	4b5b      	ldr	r3, [pc, #364]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d37c:	7c1b      	ldrb	r3, [r3, #16]
 801d37e:	4423      	add	r3, r4
 801d380:	2208      	movs	r2, #8
 801d382:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d386:	2330      	movs	r3, #48	; 0x30
 801d388:	4622      	mov	r2, r4
 801d38a:	8831      	ldrh	r1, [r6, #0]
 801d38c:	4628      	mov	r0, r5
 801d38e:	f004 fe83 	bl	8022098 <dc_com_write>
  sim_poll_count = 0U;
 801d392:	2500      	movs	r5, #0
      cst_device_info.field_requested = CS_DIF_IMSI_PRESENT;
 801d394:	4855      	ldr	r0, [pc, #340]	; (801d4ec <CST_get_device_all_infos+0x678>)
 801d396:	2320      	movs	r3, #32
 801d398:	8003      	strh	r3, [r0, #0]
      cs_status = osCDS_get_device_info(&cst_device_info);
 801d39a:	f7fd fc1b 	bl	801abd4 <osCDS_get_device_info>
      if (cs_status == CELLULAR_OK)
 801d39e:	4604      	mov	r4, r0
 801d3a0:	b140      	cbz	r0, 801d3b4 <CST_get_device_all_infos+0x540>
      else if ((cs_status == CELLULAR_SIM_BUSY)
 801d3a2:	1ee3      	subs	r3, r4, #3
 801d3a4:	2b04      	cmp	r3, #4
 801d3a6:	f200 8085 	bhi.w	801d4b4 <CST_get_device_all_infos+0x640>
 801d3aa:	e8df f003 	tbb	[pc, r3]
 801d3ae:	644b      	.short	0x644b
 801d3b0:	7b73      	.short	0x7b73
 801d3b2:	4b          	.byte	0x4b
 801d3b3:	00          	.byte	0x00
        (void)ATutil_convertHexaStringToInt64(cst_device_info.u.imsi, 15U, &cst_imsi_high, &cst_imsi_low);
 801d3b4:	4e4d      	ldr	r6, [pc, #308]	; (801d4ec <CST_get_device_all_infos+0x678>)
 801d3b6:	1cb4      	adds	r4, r6, #2
 801d3b8:	466b      	mov	r3, sp
 801d3ba:	aa01      	add	r2, sp, #4
 801d3bc:	210f      	movs	r1, #15
 801d3be:	4620      	mov	r0, r4
 801d3c0:	f7f7 fcec 	bl	8014d9c <ATutil_convertHexaStringToInt64>
        PRINT_CELLULAR_SERVICE(" -IMSI: %s\n\r", cst_device_info.u.imsi)
 801d3c4:	4d40      	ldr	r5, [pc, #256]	; (801d4c8 <CST_get_device_all_infos+0x654>)
 801d3c6:	4622      	mov	r2, r4
 801d3c8:	4949      	ldr	r1, [pc, #292]	; (801d4f0 <CST_get_device_all_infos+0x67c>)
 801d3ca:	4628      	mov	r0, r5
 801d3cc:	f009 fa3c 	bl	8026848 <sprintf>
 801d3d0:	4628      	mov	r0, r5
 801d3d2:	f001 ffaa 	bl	801f32a <crs_strlen>
 801d3d6:	b283      	uxth	r3, r0
 801d3d8:	462a      	mov	r2, r5
 801d3da:	2101      	movs	r1, #1
 801d3dc:	2007      	movs	r0, #7
 801d3de:	f001 ffe7 	bl	801f3b0 <traceIF_itmPrint>
 801d3e2:	4628      	mov	r0, r5
 801d3e4:	f001 ffa1 	bl	801f32a <crs_strlen>
 801d3e8:	b283      	uxth	r3, r0
 801d3ea:	462a      	mov	r2, r5
 801d3ec:	2101      	movs	r1, #1
 801d3ee:	2007      	movs	r0, #7
 801d3f0:	f002 f800 	bl	801f3f4 <traceIF_uartPrint>
        CST_fill_nfmc_tempo(cst_imsi_high, cst_imsi_low);
 801d3f4:	9900      	ldr	r1, [sp, #0]
 801d3f6:	9801      	ldr	r0, [sp, #4]
 801d3f8:	f7ff fc28 	bl	801cc4c <CST_fill_nfmc_tempo>
        (void)memcpy((CRC_CHAR_t *)cst_sim_info.imsi,
 801d3fc:	4b3d      	ldr	r3, [pc, #244]	; (801d4f4 <CST_get_device_all_infos+0x680>)
 801d3fe:	f8d6 0002 	ldr.w	r0, [r6, #2]
 801d402:	f8d6 1006 	ldr.w	r1, [r6, #6]
 801d406:	f8d6 200a 	ldr.w	r2, [r6, #10]
 801d40a:	f8d6 500e 	ldr.w	r5, [r6, #14]
 801d40e:	6018      	str	r0, [r3, #0]
 801d410:	6059      	str	r1, [r3, #4]
 801d412:	609a      	str	r2, [r3, #8]
 801d414:	60dd      	str	r5, [r3, #12]
 801d416:	f8d6 0012 	ldr.w	r0, [r6, #18]
 801d41a:	f8d6 1016 	ldr.w	r1, [r6, #22]
 801d41e:	f8d6 201a 	ldr.w	r2, [r6, #26]
 801d422:	6118      	str	r0, [r3, #16]
 801d424:	6159      	str	r1, [r3, #20]
 801d426:	619a      	str	r2, [r3, #24]
 801d428:	8bf1      	ldrh	r1, [r6, #30]
 801d42a:	f896 2020 	ldrb.w	r2, [r6, #32]
 801d42e:	8399      	strh	r1, [r3, #28]
 801d430:	779a      	strb	r2, [r3, #30]
        cst_sim_info.imsi[DC_MAX_SIZE_IMSI - 1U] = 0;  /* to avoid a non null terminated string */
 801d432:	2200      	movs	r2, #0
 801d434:	77da      	strb	r2, [r3, #31]
 801d436:	3b09      	subs	r3, #9
        cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_OK;
 801d438:	492b      	ldr	r1, [pc, #172]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d43a:	7c09      	ldrb	r1, [r1, #16]
 801d43c:	440b      	add	r3, r1
 801d43e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    while (end_of_loop != false)
 801d442:	e01f      	b.n	801d484 <CST_get_device_all_infos+0x610>
        (void)rtosalDelay(100U);
 801d444:	2064      	movs	r0, #100	; 0x64
 801d446:	f001 fec8 	bl	801f1da <rtosalDelay>
        sim_poll_count++;
 801d44a:	3501      	adds	r5, #1
 801d44c:	b2ad      	uxth	r5, r5
        if (sim_poll_count > CST_SIM_POLL_COUNT)
 801d44e:	2dc8      	cmp	r5, #200	; 0xc8
 801d450:	d9a0      	bls.n	801d394 <CST_get_device_all_infos+0x520>
          if (cs_status == CELLULAR_SIM_BUSY)
 801d452:	2c03      	cmp	r4, #3
 801d454:	d007      	beq.n	801d466 <CST_get_device_all_infos+0x5f2>
            cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_ERROR;
 801d456:	4b24      	ldr	r3, [pc, #144]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d458:	7c1a      	ldrb	r2, [r3, #16]
 801d45a:	4b21      	ldr	r3, [pc, #132]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d45c:	4413      	add	r3, r2
 801d45e:	2206      	movs	r2, #6
 801d460:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d464:	e00e      	b.n	801d484 <CST_get_device_all_infos+0x610>
            cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_BUSY;
 801d466:	4b20      	ldr	r3, [pc, #128]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d468:	7c1a      	ldrb	r2, [r3, #16]
 801d46a:	4b1d      	ldr	r3, [pc, #116]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d46c:	4413      	add	r3, r2
 801d46e:	2202      	movs	r2, #2
 801d470:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d474:	e006      	b.n	801d484 <CST_get_device_all_infos+0x610>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_NOT_INSERTED;
 801d476:	4b1c      	ldr	r3, [pc, #112]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d478:	7c1a      	ldrb	r2, [r3, #16]
 801d47a:	4b19      	ldr	r3, [pc, #100]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d47c:	4413      	add	r3, r2
 801d47e:	2203      	movs	r2, #3
 801d480:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d484:	2330      	movs	r3, #48	; 0x30
 801d486:	4a16      	ldr	r2, [pc, #88]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d488:	4914      	ldr	r1, [pc, #80]	; (801d4dc <CST_get_device_all_infos+0x668>)
 801d48a:	8809      	ldrh	r1, [r1, #0]
 801d48c:	4815      	ldr	r0, [pc, #84]	; (801d4e4 <CST_get_device_all_infos+0x670>)
 801d48e:	f004 fe03 	bl	8022098 <dc_com_write>
}
 801d492:	e67d      	b.n	801d190 <CST_get_device_all_infos+0x31c>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_PIN_OR_PUK_LOCKED;
 801d494:	4b14      	ldr	r3, [pc, #80]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d496:	7c1a      	ldrb	r2, [r3, #16]
 801d498:	4b11      	ldr	r3, [pc, #68]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d49a:	4413      	add	r3, r2
 801d49c:	2204      	movs	r2, #4
 801d49e:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d4a2:	e7ef      	b.n	801d484 <CST_get_device_all_infos+0x610>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_INCORRECT_PASSWORD;
 801d4a4:	4b10      	ldr	r3, [pc, #64]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d4a6:	7c1a      	ldrb	r2, [r3, #16]
 801d4a8:	4b0d      	ldr	r3, [pc, #52]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d4aa:	4413      	add	r3, r2
 801d4ac:	2205      	movs	r2, #5
 801d4ae:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d4b2:	e7e7      	b.n	801d484 <CST_get_device_all_infos+0x610>
          cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_ERROR;
 801d4b4:	4b0c      	ldr	r3, [pc, #48]	; (801d4e8 <CST_get_device_all_infos+0x674>)
 801d4b6:	7c1a      	ldrb	r2, [r3, #16]
 801d4b8:	4b09      	ldr	r3, [pc, #36]	; (801d4e0 <CST_get_device_all_infos+0x66c>)
 801d4ba:	4413      	add	r3, r2
 801d4bc:	2206      	movs	r2, #6
 801d4be:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
 801d4c2:	e7df      	b.n	801d484 <CST_get_device_all_infos+0x610>
 801d4c4:	2000406c 	.word	0x2000406c
 801d4c8:	20004ddc 	.word	0x20004ddc
 801d4cc:	08035514 	.word	0x08035514
 801d4d0:	08035540 	.word	0x08035540
 801d4d4:	08035564 	.word	0x08035564
 801d4d8:	0803558c 	.word	0x0803558c
 801d4dc:	2000023c 	.word	0x2000023c
 801d4e0:	20004338 	.word	0x20004338
 801d4e4:	200058b0 	.word	0x200058b0
 801d4e8:	200000b0 	.word	0x200000b0
 801d4ec:	200043b0 	.word	0x200043b0
 801d4f0:	080355b4 	.word	0x080355b4
 801d4f4:	20004341 	.word	0x20004341

0801d4f8 <CST_subscribe_all_net_events>:
{
 801d4f8:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("Subscribe URC events: Network registration\n\r")
 801d4fa:	4c37      	ldr	r4, [pc, #220]	; (801d5d8 <CST_subscribe_all_net_events+0xe0>)
 801d4fc:	4d37      	ldr	r5, [pc, #220]	; (801d5dc <CST_subscribe_all_net_events+0xe4>)
 801d4fe:	f104 0e20 	add.w	lr, r4, #32
 801d502:	46a4      	mov	ip, r4
 801d504:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801d508:	6028      	str	r0, [r5, #0]
 801d50a:	6069      	str	r1, [r5, #4]
 801d50c:	60aa      	str	r2, [r5, #8]
 801d50e:	60eb      	str	r3, [r5, #12]
 801d510:	4664      	mov	r4, ip
 801d512:	3510      	adds	r5, #16
 801d514:	45f4      	cmp	ip, lr
 801d516:	d1f4      	bne.n	801d502 <CST_subscribe_all_net_events+0xa>
 801d518:	cc07      	ldmia	r4!, {r0, r1, r2}
 801d51a:	6028      	str	r0, [r5, #0]
 801d51c:	6069      	str	r1, [r5, #4]
 801d51e:	60aa      	str	r2, [r5, #8]
 801d520:	7823      	ldrb	r3, [r4, #0]
 801d522:	732b      	strb	r3, [r5, #12]
 801d524:	4c2d      	ldr	r4, [pc, #180]	; (801d5dc <CST_subscribe_all_net_events+0xe4>)
 801d526:	4620      	mov	r0, r4
 801d528:	f001 feff 	bl	801f32a <crs_strlen>
 801d52c:	b283      	uxth	r3, r0
 801d52e:	4622      	mov	r2, r4
 801d530:	2101      	movs	r1, #1
 801d532:	2007      	movs	r0, #7
 801d534:	f001 ff3c 	bl	801f3b0 <traceIF_itmPrint>
 801d538:	4620      	mov	r0, r4
 801d53a:	f001 fef6 	bl	801f32a <crs_strlen>
 801d53e:	b283      	uxth	r3, r0
 801d540:	4622      	mov	r2, r4
 801d542:	2101      	movs	r1, #1
 801d544:	2007      	movs	r0, #7
 801d546:	f001 ff55 	bl	801f3f4 <traceIF_uartPrint>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_CS_NETWORK_REG_STAT, CST_network_reg_callback);
 801d54a:	4d25      	ldr	r5, [pc, #148]	; (801d5e0 <CST_subscribe_all_net_events+0xe8>)
 801d54c:	4629      	mov	r1, r5
 801d54e:	2005      	movs	r0, #5
 801d550:	f7fd fb54 	bl	801abfc <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_GPRS_NETWORK_REG_STAT, CST_network_reg_callback);
 801d554:	4629      	mov	r1, r5
 801d556:	2003      	movs	r0, #3
 801d558:	f7fd fb50 	bl	801abfc <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_EPS_NETWORK_REG_STAT, CST_network_reg_callback);
 801d55c:	4629      	mov	r1, r5
 801d55e:	2001      	movs	r0, #1
 801d560:	f7fd fb4c 	bl	801abfc <osCDS_subscribe_net_event>
  PRINT_CELLULAR_SERVICE("Subscribe URC events: Location info\n\r")
 801d564:	4d1f      	ldr	r5, [pc, #124]	; (801d5e4 <CST_subscribe_all_net_events+0xec>)
 801d566:	46a4      	mov	ip, r4
 801d568:	f105 0e20 	add.w	lr, r5, #32
 801d56c:	462c      	mov	r4, r5
 801d56e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801d570:	f8cc 0000 	str.w	r0, [ip]
 801d574:	f8cc 1004 	str.w	r1, [ip, #4]
 801d578:	f8cc 2008 	str.w	r2, [ip, #8]
 801d57c:	f8cc 300c 	str.w	r3, [ip, #12]
 801d580:	4625      	mov	r5, r4
 801d582:	f10c 0c10 	add.w	ip, ip, #16
 801d586:	4574      	cmp	r4, lr
 801d588:	d1f0      	bne.n	801d56c <CST_subscribe_all_net_events+0x74>
 801d58a:	6820      	ldr	r0, [r4, #0]
 801d58c:	f8cc 0000 	str.w	r0, [ip]
 801d590:	88a3      	ldrh	r3, [r4, #4]
 801d592:	f8ac 3004 	strh.w	r3, [ip, #4]
 801d596:	4c11      	ldr	r4, [pc, #68]	; (801d5dc <CST_subscribe_all_net_events+0xe4>)
 801d598:	4620      	mov	r0, r4
 801d59a:	f001 fec6 	bl	801f32a <crs_strlen>
 801d59e:	b283      	uxth	r3, r0
 801d5a0:	4622      	mov	r2, r4
 801d5a2:	2101      	movs	r1, #1
 801d5a4:	2007      	movs	r0, #7
 801d5a6:	f001 ff03 	bl	801f3b0 <traceIF_itmPrint>
 801d5aa:	4620      	mov	r0, r4
 801d5ac:	f001 febd 	bl	801f32a <crs_strlen>
 801d5b0:	b283      	uxth	r3, r0
 801d5b2:	4622      	mov	r2, r4
 801d5b4:	2101      	movs	r1, #1
 801d5b6:	2007      	movs	r0, #7
 801d5b8:	f001 ff1c 	bl	801f3f4 <traceIF_uartPrint>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_EPS_LOCATION_INFO, CST_location_info_callback);
 801d5bc:	4c0a      	ldr	r4, [pc, #40]	; (801d5e8 <CST_subscribe_all_net_events+0xf0>)
 801d5be:	4621      	mov	r1, r4
 801d5c0:	2002      	movs	r0, #2
 801d5c2:	f7fd fb1b 	bl	801abfc <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_GPRS_LOCATION_INFO, CST_location_info_callback);
 801d5c6:	4621      	mov	r1, r4
 801d5c8:	2004      	movs	r0, #4
 801d5ca:	f7fd fb17 	bl	801abfc <osCDS_subscribe_net_event>
  (void)osCDS_subscribe_net_event(CS_URCEVENT_CS_LOCATION_INFO, CST_location_info_callback);
 801d5ce:	4621      	mov	r1, r4
 801d5d0:	2006      	movs	r0, #6
 801d5d2:	f7fd fb13 	bl	801abfc <osCDS_subscribe_net_event>
}
 801d5d6:	bd38      	pop	{r3, r4, r5, pc}
 801d5d8:	080355c4 	.word	0x080355c4
 801d5dc:	20004ddc 	.word	0x20004ddc
 801d5e0:	0801cd7d 	.word	0x0801cd7d
 801d5e4:	080355f4 	.word	0x080355f4
 801d5e8:	0801cc01 	.word	0x0801cc01

0801d5ec <CST_data_cache_cellular_info_set>:
{
 801d5ec:	b570      	push	{r4, r5, r6, lr}
 801d5ee:	b084      	sub	sp, #16
 801d5f0:	4604      	mov	r4, r0
 801d5f2:	460d      	mov	r5, r1
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_NIFMAN_INFO, (void *)&nifman_info, sizeof(nifman_info));
 801d5f4:	2310      	movs	r3, #16
 801d5f6:	466a      	mov	r2, sp
 801d5f8:	4918      	ldr	r1, [pc, #96]	; (801d65c <CST_data_cache_cellular_info_set+0x70>)
 801d5fa:	8809      	ldrh	r1, [r1, #0]
 801d5fc:	4818      	ldr	r0, [pc, #96]	; (801d660 <CST_data_cache_cellular_info_set+0x74>)
 801d5fe:	f004 fd97 	bl	8022130 <dc_com_read>
  if (nifman_info.rt_state != dc_service_state)
 801d602:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801d606:	42a3      	cmp	r3, r4
 801d608:	d00e      	beq.n	801d628 <CST_data_cache_cellular_info_set+0x3c>
    nifman_info.rt_state   =  dc_service_state;
 801d60a:	f88d 4008 	strb.w	r4, [sp, #8]
    nifman_info.network    =  DC_CELLULAR_SOCKET_MODEM;
 801d60e:	2301      	movs	r3, #1
 801d610:	f88d 3009 	strb.w	r3, [sp, #9]
    if (ip_addr != NULL)
 801d614:	b10d      	cbz	r5, 801d61a <CST_data_cache_cellular_info_set+0x2e>
      (void)memcpy(&nifman_info.ip_addr, ip_addr, sizeof(dc_network_addr_t));
 801d616:	682b      	ldr	r3, [r5, #0]
 801d618:	9303      	str	r3, [sp, #12]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_NIFMAN_INFO, (void *)&nifman_info, sizeof(nifman_info));
 801d61a:	2310      	movs	r3, #16
 801d61c:	466a      	mov	r2, sp
 801d61e:	490f      	ldr	r1, [pc, #60]	; (801d65c <CST_data_cache_cellular_info_set+0x70>)
 801d620:	8809      	ldrh	r1, [r1, #0]
 801d622:	480f      	ldr	r0, [pc, #60]	; (801d660 <CST_data_cache_cellular_info_set+0x74>)
 801d624:	f004 fd38 	bl	8022098 <dc_com_write>
  (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801d628:	4e0e      	ldr	r6, [pc, #56]	; (801d664 <CST_data_cache_cellular_info_set+0x78>)
 801d62a:	2310      	movs	r3, #16
 801d62c:	4632      	mov	r2, r6
 801d62e:	490e      	ldr	r1, [pc, #56]	; (801d668 <CST_data_cache_cellular_info_set+0x7c>)
 801d630:	8809      	ldrh	r1, [r1, #0]
 801d632:	480b      	ldr	r0, [pc, #44]	; (801d660 <CST_data_cache_cellular_info_set+0x74>)
 801d634:	f004 fd7c 	bl	8022130 <dc_com_read>
  if (cst_cellular_data_info.rt_state != dc_service_state)
 801d638:	7a33      	ldrb	r3, [r6, #8]
 801d63a:	42a3      	cmp	r3, r4
 801d63c:	d00c      	beq.n	801d658 <CST_data_cache_cellular_info_set+0x6c>
    cst_cellular_data_info.rt_state   =  dc_service_state;
 801d63e:	7234      	strb	r4, [r6, #8]
    cst_cellular_data_info.network    =  DC_NETWORK_SOCKET_MODEM;
 801d640:	2201      	movs	r2, #1
 801d642:	7272      	strb	r2, [r6, #9]
    if (ip_addr != NULL)
 801d644:	b10d      	cbz	r5, 801d64a <CST_data_cache_cellular_info_set+0x5e>
      (void)memcpy(&cst_cellular_data_info.ip_addr, ip_addr, sizeof(dc_network_addr_t));
 801d646:	682a      	ldr	r2, [r5, #0]
 801d648:	60f2      	str	r2, [r6, #12]
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801d64a:	2310      	movs	r3, #16
 801d64c:	4a05      	ldr	r2, [pc, #20]	; (801d664 <CST_data_cache_cellular_info_set+0x78>)
 801d64e:	4906      	ldr	r1, [pc, #24]	; (801d668 <CST_data_cache_cellular_info_set+0x7c>)
 801d650:	8809      	ldrh	r1, [r1, #0]
 801d652:	4803      	ldr	r0, [pc, #12]	; (801d660 <CST_data_cache_cellular_info_set+0x74>)
 801d654:	f004 fd20 	bl	8022098 <dc_com_write>
}
 801d658:	b004      	add	sp, #16
 801d65a:	bd70      	pop	{r4, r5, r6, pc}
 801d65c:	2000023a 	.word	0x2000023a
 801d660:	200058b0 	.word	0x200058b0
 801d664:	2000405c 	.word	0x2000405c
 801d668:	20000234 	.word	0x20000234

0801d66c <CST_config_fail>:
{
 801d66c:	b5f0      	push	{r4, r5, r6, r7, lr}
 801d66e:	b083      	sub	sp, #12
 801d670:	460f      	mov	r7, r1
 801d672:	4614      	mov	r4, r2
 801d674:	461e      	mov	r6, r3
  PRINT_CELLULAR_SERVICE("=== %s Fail !!! === \r\n", msg_fail)
 801d676:	4d33      	ldr	r5, [pc, #204]	; (801d744 <CST_config_fail+0xd8>)
 801d678:	4602      	mov	r2, r0
 801d67a:	4933      	ldr	r1, [pc, #204]	; (801d748 <CST_config_fail+0xdc>)
 801d67c:	4628      	mov	r0, r5
 801d67e:	f009 f8e3 	bl	8026848 <sprintf>
 801d682:	4628      	mov	r0, r5
 801d684:	f001 fe51 	bl	801f32a <crs_strlen>
 801d688:	b283      	uxth	r3, r0
 801d68a:	462a      	mov	r2, r5
 801d68c:	2101      	movs	r1, #1
 801d68e:	2007      	movs	r0, #7
 801d690:	f001 fe8e 	bl	801f3b0 <traceIF_itmPrint>
 801d694:	4628      	mov	r0, r5
 801d696:	f001 fe48 	bl	801f32a <crs_strlen>
 801d69a:	b283      	uxth	r3, r0
 801d69c:	462a      	mov	r2, r5
 801d69e:	2101      	movs	r1, #1
 801d6a0:	2007      	movs	r0, #7
 801d6a2:	f001 fea7 	bl	801f3f4 <traceIF_uartPrint>
  ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 1, ERROR_WARNING);
 801d6a6:	2202      	movs	r2, #2
 801d6a8:	2101      	movs	r1, #1
 801d6aa:	2007      	movs	r0, #7
 801d6ac:	f000 fe5a 	bl	801e364 <ERROR_Handler>
  *fail_count = *fail_count + 1U;
 801d6b0:	7823      	ldrb	r3, [r4, #0]
 801d6b2:	3301      	adds	r3, #1
 801d6b4:	7023      	strb	r3, [r4, #0]
  cst_context.global_retry_count++;
 801d6b6:	4825      	ldr	r0, [pc, #148]	; (801d74c <CST_config_fail+0xe0>)
 801d6b8:	7ec3      	ldrb	r3, [r0, #27]
 801d6ba:	3301      	adds	r3, #1
 801d6bc:	76c3      	strb	r3, [r0, #27]
  cst_context.reset_count++;
 801d6be:	7c83      	ldrb	r3, [r0, #18]
 801d6c0:	3301      	adds	r3, #1
 801d6c2:	7483      	strb	r3, [r0, #18]
  CST_data_cache_cellular_info_set(DC_SERVICE_OFF, NULL);
 801d6c4:	2100      	movs	r1, #0
 801d6c6:	2003      	movs	r0, #3
 801d6c8:	f7ff ff90 	bl	801d5ec <CST_data_cache_cellular_info_set>
  if ((*fail_count <= fail_max) && (cst_context.global_retry_count <= CST_GLOBAL_RETRY_MAX))
 801d6cc:	7823      	ldrb	r3, [r4, #0]
 801d6ce:	42b3      	cmp	r3, r6
 801d6d0:	d803      	bhi.n	801d6da <CST_config_fail+0x6e>
 801d6d2:	4b1e      	ldr	r3, [pc, #120]	; (801d74c <CST_config_fail+0xe0>)
 801d6d4:	7edb      	ldrb	r3, [r3, #27]
 801d6d6:	2b05      	cmp	r3, #5
 801d6d8:	d929      	bls.n	801d72e <CST_config_fail+0xc2>
    CST_set_state(CST_MODEM_FAIL_STATE);
 801d6da:	200a      	movs	r0, #10
 801d6dc:	f7fd fe54 	bl	801b388 <CST_set_state>
    CST_fail_setting();
 801d6e0:	f7ff fb1a 	bl	801cd18 <CST_fail_setting>
    cst_context.fail_cause    = CST_MODEM_POWER_ON_FAIL;
 801d6e4:	4b19      	ldr	r3, [pc, #100]	; (801d74c <CST_config_fail+0xe0>)
 801d6e6:	2201      	movs	r2, #1
 801d6e8:	709a      	strb	r2, [r3, #2]
    PRINT_CELLULAR_SERVICE_ERR("=== CST_set_fail_state %d - count %d/%d FATAL !!! ===\n\r",
 801d6ea:	7822      	ldrb	r2, [r4, #0]
 801d6ec:	4c15      	ldr	r4, [pc, #84]	; (801d744 <CST_config_fail+0xd8>)
 801d6ee:	9200      	str	r2, [sp, #0]
 801d6f0:	7edb      	ldrb	r3, [r3, #27]
 801d6f2:	463a      	mov	r2, r7
 801d6f4:	4916      	ldr	r1, [pc, #88]	; (801d750 <CST_config_fail+0xe4>)
 801d6f6:	4620      	mov	r0, r4
 801d6f8:	f009 f8a6 	bl	8026848 <sprintf>
 801d6fc:	4620      	mov	r0, r4
 801d6fe:	f001 fe14 	bl	801f32a <crs_strlen>
 801d702:	b283      	uxth	r3, r0
 801d704:	4622      	mov	r2, r4
 801d706:	2110      	movs	r1, #16
 801d708:	2007      	movs	r0, #7
 801d70a:	f001 fe51 	bl	801f3b0 <traceIF_itmPrint>
 801d70e:	4620      	mov	r0, r4
 801d710:	f001 fe0b 	bl	801f32a <crs_strlen>
 801d714:	b283      	uxth	r3, r0
 801d716:	4622      	mov	r2, r4
 801d718:	2110      	movs	r1, #16
 801d71a:	2007      	movs	r0, #7
 801d71c:	f001 fe6a 	bl	801f3f4 <traceIF_uartPrint>
    ERROR_Handler(DBG_CHAN_CELLULAR_SERVICE, 2, ERROR_FATAL);
 801d720:	2203      	movs	r2, #3
 801d722:	2102      	movs	r1, #2
 801d724:	2007      	movs	r0, #7
 801d726:	f000 fe1d 	bl	801e364 <ERROR_Handler>
}
 801d72a:	b003      	add	sp, #12
 801d72c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CST_set_state(CST_MODEM_RESET_STATE);
 801d72e:	200c      	movs	r0, #12
 801d730:	f7fd fe2a 	bl	801b388 <CST_set_state>
    CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_INIT_EVENT);
 801d734:	2101      	movs	r1, #1
 801d736:	2000      	movs	r0, #0
 801d738:	f7fd fd62 	bl	801b200 <CST_send_message>
    cst_context.fail_cause    = fail_cause;
 801d73c:	4b03      	ldr	r3, [pc, #12]	; (801d74c <CST_config_fail+0xe0>)
 801d73e:	709f      	strb	r7, [r3, #2]
 801d740:	e7f3      	b.n	801d72a <CST_config_fail+0xbe>
 801d742:	bf00      	nop
 801d744:	20004ddc 	.word	0x20004ddc
 801d748:	0803561c 	.word	0x0803561c
 801d74c:	200000b0 	.word	0x200000b0
 801d750:	08035634 	.word	0x08035634

0801d754 <CST_modem_define_pdn>:
{
 801d754:	b570      	push	{r4, r5, r6, lr}
 801d756:	b092      	sub	sp, #72	; 0x48
 801d758:	4604      	mov	r4, r0
 801d75a:	460e      	mov	r6, r1
 801d75c:	4615      	mov	r5, r2
  (void)memset((void *)&pdn_conf, 0, sizeof(CS_PDN_configuration_t));
 801d75e:	2241      	movs	r2, #65	; 0x41
 801d760:	2100      	movs	r1, #0
 801d762:	a801      	add	r0, sp, #4
 801d764:	f009 f8e3 	bl	802692e <memset>
  if (crs_strlen(apn) == 0U)
 801d768:	4620      	mov	r0, r4
 801d76a:	f001 fdde 	bl	801f32a <crs_strlen>
 801d76e:	bb88      	cbnz	r0, 801d7d4 <CST_modem_define_pdn+0x80>
    size =  crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].username) + 1U;
 801d770:	4b39      	ldr	r3, [pc, #228]	; (801d858 <CST_modem_define_pdn+0x104>)
 801d772:	7c18      	ldrb	r0, [r3, #16]
 801d774:	2362      	movs	r3, #98	; 0x62
 801d776:	fb03 f000 	mul.w	r0, r3, r0
 801d77a:	3028      	adds	r0, #40	; 0x28
 801d77c:	4b37      	ldr	r3, [pc, #220]	; (801d85c <CST_modem_define_pdn+0x108>)
 801d77e:	4418      	add	r0, r3
 801d780:	3005      	adds	r0, #5
 801d782:	f001 fdd2 	bl	801f32a <crs_strlen>
 801d786:	1c42      	adds	r2, r0, #1
    if (size <= MAX_SIZE_USERNAME)
 801d788:	2a20      	cmp	r2, #32
 801d78a:	d835      	bhi.n	801d7f8 <CST_modem_define_pdn+0xa4>
                   (CRC_CHAR_t *)cst_cellular_params.sim_slot[cst_context.sim_slot_index].username,
 801d78c:	4b32      	ldr	r3, [pc, #200]	; (801d858 <CST_modem_define_pdn+0x104>)
 801d78e:	7c1d      	ldrb	r5, [r3, #16]
 801d790:	2362      	movs	r3, #98	; 0x62
 801d792:	fb03 f505 	mul.w	r5, r3, r5
 801d796:	f105 0128 	add.w	r1, r5, #40	; 0x28
 801d79a:	4e30      	ldr	r6, [pc, #192]	; (801d85c <CST_modem_define_pdn+0x108>)
 801d79c:	4431      	add	r1, r6
      (void)memcpy((CRC_CHAR_t *)pdn_conf.username,
 801d79e:	3105      	adds	r1, #5
 801d7a0:	f10d 0005 	add.w	r0, sp, #5
 801d7a4:	f009 f9a0 	bl	8026ae8 <memcpy>
      size =  crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].password) + 1U;
 801d7a8:	f105 0048 	add.w	r0, r5, #72	; 0x48
 801d7ac:	4430      	add	r0, r6
 801d7ae:	3005      	adds	r0, #5
 801d7b0:	f001 fdbb 	bl	801f32a <crs_strlen>
 801d7b4:	1c42      	adds	r2, r0, #1
      if (size <= MAX_SIZE_USERNAME)
 801d7b6:	2a20      	cmp	r2, #32
 801d7b8:	d81e      	bhi.n	801d7f8 <CST_modem_define_pdn+0xa4>
                     (CRC_CHAR_t *)cst_cellular_params.sim_slot[cst_context.sim_slot_index].password,
 801d7ba:	4b27      	ldr	r3, [pc, #156]	; (801d858 <CST_modem_define_pdn+0x104>)
 801d7bc:	7c19      	ldrb	r1, [r3, #16]
 801d7be:	2362      	movs	r3, #98	; 0x62
 801d7c0:	fb03 f101 	mul.w	r1, r3, r1
 801d7c4:	3148      	adds	r1, #72	; 0x48
 801d7c6:	4431      	add	r1, r6
        (void)memcpy((CRC_CHAR_t *)pdn_conf.password,
 801d7c8:	3105      	adds	r1, #5
 801d7ca:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 801d7ce:	f009 f98b 	bl	8026ae8 <memcpy>
 801d7d2:	e011      	b.n	801d7f8 <CST_modem_define_pdn+0xa4>
                 crs_strlen(username) + 1U);
 801d7d4:	4630      	mov	r0, r6
 801d7d6:	f001 fda8 	bl	801f32a <crs_strlen>
    (void)memcpy((CRC_CHAR_t *)pdn_conf.username,
 801d7da:	1c42      	adds	r2, r0, #1
 801d7dc:	4631      	mov	r1, r6
 801d7de:	f10d 0005 	add.w	r0, sp, #5
 801d7e2:	f009 f981 	bl	8026ae8 <memcpy>
                 crs_strlen(password) + 1U);
 801d7e6:	4628      	mov	r0, r5
 801d7e8:	f001 fd9f 	bl	801f32a <crs_strlen>
    (void)memcpy((CRC_CHAR_t *)pdn_conf.password,
 801d7ec:	1c42      	adds	r2, r0, #1
 801d7ee:	4629      	mov	r1, r5
 801d7f0:	f10d 0025 	add.w	r0, sp, #37	; 0x25
 801d7f4:	f009 f978 	bl	8026ae8 <memcpy>
  if (crs_strlen(apn) == 0U)
 801d7f8:	4620      	mov	r0, r4
 801d7fa:	f001 fd96 	bl	801f32a <crs_strlen>
 801d7fe:	b9a8      	cbnz	r0, 801d82c <CST_modem_define_pdn+0xd8>
    cs_status = osCDS_define_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801d800:	4e15      	ldr	r6, [pc, #84]	; (801d858 <CST_modem_define_pdn+0x104>)
 801d802:	7c33      	ldrb	r3, [r6, #16]
 801d804:	4c15      	ldr	r4, [pc, #84]	; (801d85c <CST_modem_define_pdn+0x108>)
 801d806:	2562      	movs	r5, #98	; 0x62
 801d808:	fb05 4303 	mla	r3, r5, r3, r4
 801d80c:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801d810:	f7fc fdc3 	bl	801a39a <cst_get_cid_value>
                                 (const uint8_t *)cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn,
 801d814:	7c31      	ldrb	r1, [r6, #16]
 801d816:	fb05 f101 	mul.w	r1, r5, r1
 801d81a:	3108      	adds	r1, #8
 801d81c:	4421      	add	r1, r4
    cs_status = osCDS_define_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801d81e:	aa01      	add	r2, sp, #4
 801d820:	3104      	adds	r1, #4
 801d822:	f7fd fa8f 	bl	801ad44 <osCDS_define_pdn>
  if (cs_status != CELLULAR_OK)
 801d826:	b980      	cbnz	r0, 801d84a <CST_modem_define_pdn+0xf6>
}
 801d828:	b012      	add	sp, #72	; 0x48
 801d82a:	bd70      	pop	{r4, r5, r6, pc}
    cs_status = osCDS_define_pdn(cst_get_cid_value(cst_cellular_params.sim_slot[cst_context.sim_slot_index].cid),
 801d82c:	4b0a      	ldr	r3, [pc, #40]	; (801d858 <CST_modem_define_pdn+0x104>)
 801d82e:	7c1a      	ldrb	r2, [r3, #16]
 801d830:	4b0a      	ldr	r3, [pc, #40]	; (801d85c <CST_modem_define_pdn+0x108>)
 801d832:	2162      	movs	r1, #98	; 0x62
 801d834:	fb01 3302 	mla	r3, r1, r2, r3
 801d838:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
 801d83c:	f7fc fdad 	bl	801a39a <cst_get_cid_value>
 801d840:	aa01      	add	r2, sp, #4
 801d842:	4621      	mov	r1, r4
 801d844:	f7fd fa7e 	bl	801ad44 <osCDS_define_pdn>
 801d848:	e7ed      	b.n	801d826 <CST_modem_define_pdn+0xd2>
    CST_config_fail(((uint8_t *)"CST_modem_define_pdn"),
 801d84a:	2305      	movs	r3, #5
 801d84c:	4a04      	ldr	r2, [pc, #16]	; (801d860 <CST_modem_define_pdn+0x10c>)
 801d84e:	2107      	movs	r1, #7
 801d850:	4804      	ldr	r0, [pc, #16]	; (801d864 <CST_modem_define_pdn+0x110>)
 801d852:	f7ff ff0b 	bl	801d66c <CST_config_fail>
}
 801d856:	e7e7      	b.n	801d828 <CST_modem_define_pdn+0xd4>
 801d858:	200000b0 	.word	0x200000b0
 801d85c:	20004160 	.word	0x20004160
 801d860:	200000c5 	.word	0x200000c5
 801d864:	08035674 	.word	0x08035674

0801d868 <CST_modem_sim_init>:
{
 801d868:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801d86c:	b0e2      	sub	sp, #392	; 0x188
  PRINT_CELLULAR_SERVICE("*********** CST_modem_sim_init ********\n\r")
 801d86e:	4d98      	ldr	r5, [pc, #608]	; (801dad0 <CST_modem_sim_init+0x268>)
 801d870:	4c98      	ldr	r4, [pc, #608]	; (801dad4 <CST_modem_sim_init+0x26c>)
 801d872:	f105 0e20 	add.w	lr, r5, #32
 801d876:	46ac      	mov	ip, r5
 801d878:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801d87c:	6020      	str	r0, [r4, #0]
 801d87e:	6061      	str	r1, [r4, #4]
 801d880:	60a2      	str	r2, [r4, #8]
 801d882:	60e3      	str	r3, [r4, #12]
 801d884:	4665      	mov	r5, ip
 801d886:	3410      	adds	r4, #16
 801d888:	45f4      	cmp	ip, lr
 801d88a:	d1f4      	bne.n	801d876 <CST_modem_sim_init+0xe>
 801d88c:	cd03      	ldmia	r5!, {r0, r1}
 801d88e:	6020      	str	r0, [r4, #0]
 801d890:	6061      	str	r1, [r4, #4]
 801d892:	882b      	ldrh	r3, [r5, #0]
 801d894:	8123      	strh	r3, [r4, #8]
 801d896:	4c8f      	ldr	r4, [pc, #572]	; (801dad4 <CST_modem_sim_init+0x26c>)
 801d898:	4620      	mov	r0, r4
 801d89a:	f001 fd46 	bl	801f32a <crs_strlen>
 801d89e:	b283      	uxth	r3, r0
 801d8a0:	4622      	mov	r2, r4
 801d8a2:	2101      	movs	r1, #1
 801d8a4:	2007      	movs	r0, #7
 801d8a6:	f001 fd83 	bl	801f3b0 <traceIF_itmPrint>
 801d8aa:	4620      	mov	r0, r4
 801d8ac:	f001 fd3d 	bl	801f32a <crs_strlen>
 801d8b0:	b283      	uxth	r3, r0
 801d8b2:	4622      	mov	r2, r4
 801d8b4:	2101      	movs	r1, #1
 801d8b6:	2007      	movs	r0, #7
 801d8b8:	f001 fd9c 	bl	801f3f4 <traceIF_uartPrint>
  (void)osCS_sim_select(cst_convert_sim_socket_type(cst_sim_info.active_slot));
 801d8bc:	4b86      	ldr	r3, [pc, #536]	; (801dad8 <CST_modem_sim_init+0x270>)
 801d8be:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
 801d8c2:	f7ff f96f 	bl	801cba4 <cst_convert_sim_socket_type>
 801d8c6:	f7fd fac1 	bl	801ae4c <osCS_sim_select>
  (void)rtosalDelay(10);  /* waiting for 10ms after sim selection */
 801d8ca:	200a      	movs	r0, #10
 801d8cc:	f001 fc85 	bl	801f1da <rtosalDelay>
  if (cst_cellular_params.target_state == DC_TARGET_STATE_SIM_ONLY)
 801d8d0:	4b82      	ldr	r3, [pc, #520]	; (801dadc <CST_modem_sim_init+0x274>)
 801d8d2:	f893 3131 	ldrb.w	r3, [r3, #305]	; 0x131
 801d8d6:	2b01      	cmp	r3, #1
 801d8d8:	d043      	beq.n	801d962 <CST_modem_sim_init+0xfa>
  else if (cst_cellular_params.target_state == DC_TARGET_STATE_FULL)
 801d8da:	2b02      	cmp	r3, #2
 801d8dc:	f000 8112 	beq.w	801db04 <CST_modem_sim_init+0x29c>
    __NOP(); /* Nothing to do */
 801d8e0:	bf00      	nop
  cs_status = CELLULAR_OK;
 801d8e2:	2400      	movs	r4, #0
  else if (cs_status == CELLULAR_SIM_PIN_OR_PUK_LOCKED)
 801d8e4:	2c05      	cmp	r4, #5
 801d8e6:	f000 826f 	beq.w	801ddc8 <CST_modem_sim_init+0x560>
    __NOP(); /* Nothing to do */
 801d8ea:	bf00      	nop
  if ((cs_status == CELLULAR_SIM_NOT_INSERTED) || (cs_status == CELLULAR_ERROR) || (cs_status == CELLULAR_SIM_ERROR))
 801d8ec:	2c04      	cmp	r4, #4
 801d8ee:	d004      	beq.n	801d8fa <CST_modem_sim_init+0x92>
 801d8f0:	2c01      	cmp	r4, #1
 801d8f2:	d002      	beq.n	801d8fa <CST_modem_sim_init+0x92>
 801d8f4:	2c07      	cmp	r4, #7
 801d8f6:	f040 8317 	bne.w	801df28 <CST_modem_sim_init+0x6c0>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d8fa:	4c77      	ldr	r4, [pc, #476]	; (801dad8 <CST_modem_sim_init+0x270>)
 801d8fc:	2330      	movs	r3, #48	; 0x30
 801d8fe:	4622      	mov	r2, r4
 801d900:	4977      	ldr	r1, [pc, #476]	; (801dae0 <CST_modem_sim_init+0x278>)
 801d902:	8809      	ldrh	r1, [r1, #0]
 801d904:	4877      	ldr	r0, [pc, #476]	; (801dae4 <CST_modem_sim_init+0x27c>)
 801d906:	f004 fc13 	bl	8022130 <dc_com_read>
    cst_sim_info.sim_status[cst_context.sim_slot_index] = DC_SIM_ERROR;
 801d90a:	4a77      	ldr	r2, [pc, #476]	; (801dae8 <CST_modem_sim_init+0x280>)
 801d90c:	7c13      	ldrb	r3, [r2, #16]
 801d90e:	18e1      	adds	r1, r4, r3
 801d910:	2006      	movs	r0, #6
 801d912:	f881 002b 	strb.w	r0, [r1, #43]	; 0x2b
    cst_sim_info.rt_state   = DC_SERVICE_ON;
 801d916:	2107      	movs	r1, #7
 801d918:	7221      	strb	r1, [r4, #8]
    cst_context.sim_slot_index++;
 801d91a:	3301      	adds	r3, #1
 801d91c:	b2db      	uxtb	r3, r3
 801d91e:	7413      	strb	r3, [r2, #16]
    if (cst_context.sim_slot_index  >= cst_cellular_params.sim_slot_nb)
 801d920:	4a6e      	ldr	r2, [pc, #440]	; (801dadc <CST_modem_sim_init+0x274>)
 801d922:	7a92      	ldrb	r2, [r2, #10]
 801d924:	4293      	cmp	r3, r2
 801d926:	f080 82d4 	bcs.w	801ded2 <CST_modem_sim_init+0x66a>
    cst_sim_info.active_slot = cst_cellular_params.sim_slot[cst_context.sim_slot_index].sim_slot_type;
 801d92a:	4c6f      	ldr	r4, [pc, #444]	; (801dae8 <CST_modem_sim_init+0x280>)
 801d92c:	7c21      	ldrb	r1, [r4, #16]
 801d92e:	4b6b      	ldr	r3, [pc, #428]	; (801dadc <CST_modem_sim_init+0x274>)
 801d930:	2262      	movs	r2, #98	; 0x62
 801d932:	fb02 3301 	mla	r3, r2, r1, r3
 801d936:	7adb      	ldrb	r3, [r3, #11]
 801d938:	4a67      	ldr	r2, [pc, #412]	; (801dad8 <CST_modem_sim_init+0x270>)
 801d93a:	f882 302a 	strb.w	r3, [r2, #42]	; 0x2a
    cst_sim_info.index_slot  = cst_context.sim_slot_index;
 801d93e:	f882 1029 	strb.w	r1, [r2, #41]	; 0x29
    (void)dc_com_write(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&cst_sim_info, sizeof(cst_sim_info));
 801d942:	2330      	movs	r3, #48	; 0x30
 801d944:	4966      	ldr	r1, [pc, #408]	; (801dae0 <CST_modem_sim_init+0x278>)
 801d946:	8809      	ldrh	r1, [r1, #0]
 801d948:	4866      	ldr	r0, [pc, #408]	; (801dae4 <CST_modem_sim_init+0x27c>)
 801d94a:	f004 fba5 	bl	8022098 <dc_com_write>
    CST_config_fail(((uint8_t *)"CST_modem_sim_init"),
 801d94e:	2305      	movs	r3, #5
 801d950:	f104 0218 	add.w	r2, r4, #24
 801d954:	2108      	movs	r1, #8
 801d956:	4865      	ldr	r0, [pc, #404]	; (801daec <CST_modem_sim_init+0x284>)
 801d958:	f7ff fe88 	bl	801d66c <CST_config_fail>
}
 801d95c:	b062      	add	sp, #392	; 0x188
 801d95e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    cs_status = osCDS_init_modem(CS_CMI_SIM_ONLY, CELLULAR_FALSE, CST_SIM_PINCODE);
 801d962:	4a63      	ldr	r2, [pc, #396]	; (801daf0 <CST_modem_sim_init+0x288>)
 801d964:	2100      	movs	r1, #0
 801d966:	2002      	movs	r0, #2
 801d968:	f7fd f998 	bl	801ac9c <osCDS_init_modem>
 801d96c:	4604      	mov	r4, r0
  if (cs_status == CELLULAR_SIM_INCORRECT_PASSWORD)
 801d96e:	2c06      	cmp	r4, #6
 801d970:	d1b8      	bne.n	801d8e4 <CST_modem_sim_init+0x7c>
    PRINT_FORCE("==================================\n\r")
 801d972:	4e60      	ldr	r6, [pc, #384]	; (801daf4 <CST_modem_sim_init+0x28c>)
 801d974:	4c57      	ldr	r4, [pc, #348]	; (801dad4 <CST_modem_sim_init+0x26c>)
 801d976:	f106 0c20 	add.w	ip, r6, #32
 801d97a:	4635      	mov	r5, r6
 801d97c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d97e:	6020      	str	r0, [r4, #0]
 801d980:	6061      	str	r1, [r4, #4]
 801d982:	60a2      	str	r2, [r4, #8]
 801d984:	60e3      	str	r3, [r4, #12]
 801d986:	462e      	mov	r6, r5
 801d988:	3410      	adds	r4, #16
 801d98a:	4565      	cmp	r5, ip
 801d98c:	d1f5      	bne.n	801d97a <CST_modem_sim_init+0x112>
 801d98e:	6828      	ldr	r0, [r5, #0]
 801d990:	6020      	str	r0, [r4, #0]
 801d992:	792b      	ldrb	r3, [r5, #4]
 801d994:	7123      	strb	r3, [r4, #4]
 801d996:	4c4f      	ldr	r4, [pc, #316]	; (801dad4 <CST_modem_sim_init+0x26c>)
 801d998:	4620      	mov	r0, r4
 801d99a:	f001 fcc6 	bl	801f32a <crs_strlen>
 801d99e:	b283      	uxth	r3, r0
 801d9a0:	4622      	mov	r2, r4
 801d9a2:	2101      	movs	r1, #1
 801d9a4:	2007      	movs	r0, #7
 801d9a6:	f001 fd03 	bl	801f3b0 <traceIF_itmPrint>
 801d9aa:	4620      	mov	r0, r4
 801d9ac:	f001 fcbd 	bl	801f32a <crs_strlen>
 801d9b0:	b282      	uxth	r2, r0
 801d9b2:	4621      	mov	r1, r4
 801d9b4:	2007      	movs	r0, #7
 801d9b6:	f001 fd35 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE(" WARNING: WRONG PIN CODE !!!\n\r")
 801d9ba:	4d4f      	ldr	r5, [pc, #316]	; (801daf8 <CST_modem_sim_init+0x290>)
 801d9bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801d9be:	6020      	str	r0, [r4, #0]
 801d9c0:	6061      	str	r1, [r4, #4]
 801d9c2:	60a2      	str	r2, [r4, #8]
 801d9c4:	60e3      	str	r3, [r4, #12]
 801d9c6:	cd07      	ldmia	r5!, {r0, r1, r2}
 801d9c8:	6120      	str	r0, [r4, #16]
 801d9ca:	6161      	str	r1, [r4, #20]
 801d9cc:	61a2      	str	r2, [r4, #24]
 801d9ce:	882a      	ldrh	r2, [r5, #0]
 801d9d0:	78ab      	ldrb	r3, [r5, #2]
 801d9d2:	83a2      	strh	r2, [r4, #28]
 801d9d4:	77a3      	strb	r3, [r4, #30]
 801d9d6:	4620      	mov	r0, r4
 801d9d8:	f001 fca7 	bl	801f32a <crs_strlen>
 801d9dc:	b283      	uxth	r3, r0
 801d9de:	4622      	mov	r2, r4
 801d9e0:	2101      	movs	r1, #1
 801d9e2:	2007      	movs	r0, #7
 801d9e4:	f001 fce4 	bl	801f3b0 <traceIF_itmPrint>
 801d9e8:	4620      	mov	r0, r4
 801d9ea:	f001 fc9e 	bl	801f32a <crs_strlen>
 801d9ee:	b282      	uxth	r2, r0
 801d9f0:	4621      	mov	r1, r4
 801d9f2:	2007      	movs	r0, #7
 801d9f4:	f001 fd16 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE(" DO NOT RESTART THE BOARD WITHOUT SETTING A CORRECT PIN CODE\n\r")
 801d9f8:	4d40      	ldr	r5, [pc, #256]	; (801dafc <CST_modem_sim_init+0x294>)
 801d9fa:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 801d9fe:	462e      	mov	r6, r5
 801da00:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801da02:	6020      	str	r0, [r4, #0]
 801da04:	6061      	str	r1, [r4, #4]
 801da06:	60a2      	str	r2, [r4, #8]
 801da08:	60e3      	str	r3, [r4, #12]
 801da0a:	4635      	mov	r5, r6
 801da0c:	3410      	adds	r4, #16
 801da0e:	4566      	cmp	r6, ip
 801da10:	d1f5      	bne.n	801d9fe <CST_modem_sim_init+0x196>
 801da12:	cd07      	ldmia	r5!, {r0, r1, r2}
 801da14:	6020      	str	r0, [r4, #0]
 801da16:	6061      	str	r1, [r4, #4]
 801da18:	60a2      	str	r2, [r4, #8]
 801da1a:	882a      	ldrh	r2, [r5, #0]
 801da1c:	78ab      	ldrb	r3, [r5, #2]
 801da1e:	81a2      	strh	r2, [r4, #12]
 801da20:	73a3      	strb	r3, [r4, #14]
 801da22:	4c2c      	ldr	r4, [pc, #176]	; (801dad4 <CST_modem_sim_init+0x26c>)
 801da24:	4620      	mov	r0, r4
 801da26:	f001 fc80 	bl	801f32a <crs_strlen>
 801da2a:	b283      	uxth	r3, r0
 801da2c:	4622      	mov	r2, r4
 801da2e:	2101      	movs	r1, #1
 801da30:	2007      	movs	r0, #7
 801da32:	f001 fcbd 	bl	801f3b0 <traceIF_itmPrint>
 801da36:	4620      	mov	r0, r4
 801da38:	f001 fc77 	bl	801f32a <crs_strlen>
 801da3c:	b282      	uxth	r2, r0
 801da3e:	4621      	mov	r1, r4
 801da40:	2007      	movs	r0, #7
 801da42:	f001 fcef 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE(" TO AVOID LOCKING THE SIM ! \n\r")
 801da46:	4d2e      	ldr	r5, [pc, #184]	; (801db00 <CST_modem_sim_init+0x298>)
 801da48:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801da4a:	6020      	str	r0, [r4, #0]
 801da4c:	6061      	str	r1, [r4, #4]
 801da4e:	60a2      	str	r2, [r4, #8]
 801da50:	60e3      	str	r3, [r4, #12]
 801da52:	cd07      	ldmia	r5!, {r0, r1, r2}
 801da54:	6120      	str	r0, [r4, #16]
 801da56:	6161      	str	r1, [r4, #20]
 801da58:	61a2      	str	r2, [r4, #24]
 801da5a:	882a      	ldrh	r2, [r5, #0]
 801da5c:	78ab      	ldrb	r3, [r5, #2]
 801da5e:	83a2      	strh	r2, [r4, #28]
 801da60:	77a3      	strb	r3, [r4, #30]
 801da62:	4620      	mov	r0, r4
 801da64:	f001 fc61 	bl	801f32a <crs_strlen>
 801da68:	b283      	uxth	r3, r0
 801da6a:	4622      	mov	r2, r4
 801da6c:	2101      	movs	r1, #1
 801da6e:	2007      	movs	r0, #7
 801da70:	f001 fc9e 	bl	801f3b0 <traceIF_itmPrint>
 801da74:	4620      	mov	r0, r4
 801da76:	f001 fc58 	bl	801f32a <crs_strlen>
 801da7a:	b282      	uxth	r2, r0
 801da7c:	4621      	mov	r1, r4
 801da7e:	2007      	movs	r0, #7
 801da80:	f001 fcd0 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE("==================================\n\r")
 801da84:	4e1b      	ldr	r6, [pc, #108]	; (801daf4 <CST_modem_sim_init+0x28c>)
 801da86:	f106 0c20 	add.w	ip, r6, #32
 801da8a:	4635      	mov	r5, r6
 801da8c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801da8e:	6020      	str	r0, [r4, #0]
 801da90:	6061      	str	r1, [r4, #4]
 801da92:	60a2      	str	r2, [r4, #8]
 801da94:	60e3      	str	r3, [r4, #12]
 801da96:	462e      	mov	r6, r5
 801da98:	3410      	adds	r4, #16
 801da9a:	4565      	cmp	r5, ip
 801da9c:	d1f5      	bne.n	801da8a <CST_modem_sim_init+0x222>
 801da9e:	6828      	ldr	r0, [r5, #0]
 801daa0:	6020      	str	r0, [r4, #0]
 801daa2:	792b      	ldrb	r3, [r5, #4]
 801daa4:	7123      	strb	r3, [r4, #4]
 801daa6:	4c0b      	ldr	r4, [pc, #44]	; (801dad4 <CST_modem_sim_init+0x26c>)
 801daa8:	4620      	mov	r0, r4
 801daaa:	f001 fc3e 	bl	801f32a <crs_strlen>
 801daae:	b283      	uxth	r3, r0
 801dab0:	4622      	mov	r2, r4
 801dab2:	2101      	movs	r1, #1
 801dab4:	2007      	movs	r0, #7
 801dab6:	f001 fc7b 	bl	801f3b0 <traceIF_itmPrint>
 801daba:	4620      	mov	r0, r4
 801dabc:	f001 fc35 	bl	801f32a <crs_strlen>
 801dac0:	b282      	uxth	r2, r0
 801dac2:	4621      	mov	r1, r4
 801dac4:	2007      	movs	r0, #7
 801dac6:	f001 fcad 	bl	801f424 <traceIF_uartPrintForce>
      __NOP(); /* Nothing to do */
 801daca:	bf00      	nop
    for (;;)
 801dacc:	e7fd      	b.n	801daca <CST_modem_sim_init+0x262>
 801dace:	bf00      	nop
 801dad0:	0803568c 	.word	0x0803568c
 801dad4:	20004ddc 	.word	0x20004ddc
 801dad8:	20004338 	.word	0x20004338
 801dadc:	20004160 	.word	0x20004160
 801dae0:	2000023c 	.word	0x2000023c
 801dae4:	200058b0 	.word	0x200058b0
 801dae8:	200000b0 	.word	0x200000b0
 801daec:	080358bc 	.word	0x080358bc
 801daf0:	08035c54 	.word	0x08035c54
 801daf4:	080357ac 	.word	0x080357ac
 801daf8:	080357d4 	.word	0x080357d4
 801dafc:	080357f4 	.word	0x080357f4
 801db00:	08035834 	.word	0x08035834
    PRINT_CELLULAR_SERVICE("CST_modem_sim_init : check SIM First \n\r")
 801db04:	f8df c2b8 	ldr.w	ip, [pc, #696]	; 801ddc0 <CST_modem_sim_init+0x558>
 801db08:	4da3      	ldr	r5, [pc, #652]	; (801dd98 <CST_modem_sim_init+0x530>)
 801db0a:	f10c 0620 	add.w	r6, ip, #32
 801db0e:	4664      	mov	r4, ip
 801db10:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801db12:	6028      	str	r0, [r5, #0]
 801db14:	6069      	str	r1, [r5, #4]
 801db16:	60aa      	str	r2, [r5, #8]
 801db18:	60eb      	str	r3, [r5, #12]
 801db1a:	46a4      	mov	ip, r4
 801db1c:	3510      	adds	r5, #16
 801db1e:	42b4      	cmp	r4, r6
 801db20:	d1f5      	bne.n	801db0e <CST_modem_sim_init+0x2a6>
 801db22:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 801db26:	6028      	str	r0, [r5, #0]
 801db28:	6069      	str	r1, [r5, #4]
 801db2a:	4c9b      	ldr	r4, [pc, #620]	; (801dd98 <CST_modem_sim_init+0x530>)
 801db2c:	4620      	mov	r0, r4
 801db2e:	f001 fbfc 	bl	801f32a <crs_strlen>
 801db32:	b283      	uxth	r3, r0
 801db34:	4622      	mov	r2, r4
 801db36:	2101      	movs	r1, #1
 801db38:	2007      	movs	r0, #7
 801db3a:	f001 fc39 	bl	801f3b0 <traceIF_itmPrint>
 801db3e:	4620      	mov	r0, r4
 801db40:	f001 fbf3 	bl	801f32a <crs_strlen>
 801db44:	b283      	uxth	r3, r0
 801db46:	4622      	mov	r2, r4
 801db48:	2101      	movs	r1, #1
 801db4a:	2007      	movs	r0, #7
 801db4c:	f001 fc52 	bl	801f3f4 <traceIF_uartPrint>
    cs_status = osCDS_init_modem(CS_CMI_SIM_ONLY, CELLULAR_FALSE, CST_SIM_PINCODE);
 801db50:	4a92      	ldr	r2, [pc, #584]	; (801dd9c <CST_modem_sim_init+0x534>)
 801db52:	2100      	movs	r1, #0
 801db54:	2002      	movs	r0, #2
 801db56:	f7fd f8a1 	bl	801ac9c <osCDS_init_modem>
    if (cs_status == CELLULAR_OK)
 801db5a:	4604      	mov	r4, r0
 801db5c:	2800      	cmp	r0, #0
 801db5e:	f47f af06 	bne.w	801d96e <CST_modem_sim_init+0x106>
      cst_imsi_info.field_requested = CS_DIF_IMSI_PRESENT;
 801db62:	2320      	movs	r3, #32
 801db64:	f8ad 3018 	strh.w	r3, [sp, #24]
      cs_status = osCDS_get_device_info(&cst_imsi_info);
 801db68:	a806      	add	r0, sp, #24
 801db6a:	f7fd f833 	bl	801abd4 <osCDS_get_device_info>
 801db6e:	4606      	mov	r6, r0
      (void)ATutil_convertHexaStringToInt64(cst_imsi_info.u.imsi, 15U, &cst_imsi_high, &cst_imsi_low);
 801db70:	ab03      	add	r3, sp, #12
 801db72:	aa02      	add	r2, sp, #8
 801db74:	210f      	movs	r1, #15
 801db76:	f10d 001a 	add.w	r0, sp, #26
 801db7a:	f7f7 f90f 	bl	8014d9c <ATutil_convertHexaStringToInt64>
      (void)memcpy(mmc_mnc, cst_imsi_info.u.imsi, 5);
 801db7e:	ab04      	add	r3, sp, #16
 801db80:	f8dd 001a 	ldr.w	r0, [sp, #26]
 801db84:	9004      	str	r0, [sp, #16]
 801db86:	f89d 201e 	ldrb.w	r2, [sp, #30]
 801db8a:	f88d 2014 	strb.w	r2, [sp, #20]
      mmc_mnc[5] = 0;
 801db8e:	2200      	movs	r2, #0
 801db90:	f88d 2015 	strb.w	r2, [sp, #21]
      PRINT_CELLULAR_SERVICE(" -IMSI: %lx%lx\n\r -MMC/MNC: %s\n\r", cst_imsi_high, cst_imsi_low, mmc_mnc)
 801db94:	4d80      	ldr	r5, [pc, #512]	; (801dd98 <CST_modem_sim_init+0x530>)
 801db96:	9300      	str	r3, [sp, #0]
 801db98:	9b03      	ldr	r3, [sp, #12]
 801db9a:	9a02      	ldr	r2, [sp, #8]
 801db9c:	4980      	ldr	r1, [pc, #512]	; (801dda0 <CST_modem_sim_init+0x538>)
 801db9e:	4628      	mov	r0, r5
 801dba0:	f008 fe52 	bl	8026848 <sprintf>
 801dba4:	4628      	mov	r0, r5
 801dba6:	f001 fbc0 	bl	801f32a <crs_strlen>
 801dbaa:	b283      	uxth	r3, r0
 801dbac:	462a      	mov	r2, r5
 801dbae:	2101      	movs	r1, #1
 801dbb0:	2007      	movs	r0, #7
 801dbb2:	f001 fbfd 	bl	801f3b0 <traceIF_itmPrint>
 801dbb6:	4628      	mov	r0, r5
 801dbb8:	f001 fbb7 	bl	801f32a <crs_strlen>
 801dbbc:	b283      	uxth	r3, r0
 801dbbe:	462a      	mov	r2, r5
 801dbc0:	2101      	movs	r1, #1
 801dbc2:	2007      	movs	r0, #7
 801dbc4:	f001 fc16 	bl	801f3f4 <traceIF_uartPrint>
      if (cst_cellular_params.set_pdn_mode != 0U)
 801dbc8:	4b76      	ldr	r3, [pc, #472]	; (801dda4 <CST_modem_sim_init+0x53c>)
 801dbca:	7a5b      	ldrb	r3, [r3, #9]
 801dbcc:	b90b      	cbnz	r3, 801dbd2 <CST_modem_sim_init+0x36a>
 801dbce:	4634      	mov	r4, r6
 801dbd0:	e6cd      	b.n	801d96e <CST_modem_sim_init+0x106>
        if (crs_strlen(cst_cellular_params.sim_slot[cst_context.sim_slot_index].apn) == 0U)
 801dbd2:	4b75      	ldr	r3, [pc, #468]	; (801dda8 <CST_modem_sim_init+0x540>)
 801dbd4:	7c18      	ldrb	r0, [r3, #16]
 801dbd6:	2362      	movs	r3, #98	; 0x62
 801dbd8:	fb03 f000 	mul.w	r0, r3, r0
 801dbdc:	3008      	adds	r0, #8
 801dbde:	4b71      	ldr	r3, [pc, #452]	; (801dda4 <CST_modem_sim_init+0x53c>)
 801dbe0:	4418      	add	r0, r3
 801dbe2:	3004      	adds	r0, #4
 801dbe4:	f001 fba1 	bl	801f32a <crs_strlen>
 801dbe8:	2800      	cmp	r0, #0
 801dbea:	f040 80b6 	bne.w	801dd5a <CST_modem_sim_init+0x4f2>
          for (uint8_t i = 0U; i < MMCMNC_APN_MAX; i++)
 801dbee:	4625      	mov	r5, r4
          apn_found = false;
 801dbf0:	2600      	movs	r6, #0
 801dbf2:	e001      	b.n	801dbf8 <CST_modem_sim_init+0x390>
          for (uint8_t i = 0U; i < MMCMNC_APN_MAX; i++)
 801dbf4:	3501      	adds	r5, #1
 801dbf6:	b2ed      	uxtb	r5, r5
 801dbf8:	2d04      	cmp	r5, #4
 801dbfa:	d82a      	bhi.n	801dc52 <CST_modem_sim_init+0x3ea>
            if (memcmp(mmc_mnc, mmcmnc_apn_a[i].mmcmnc, sizeof(mmc_mnc)) == 0)
 801dbfc:	eb05 1345 	add.w	r3, r5, r5, lsl #5
 801dc00:	2206      	movs	r2, #6
 801dc02:	496a      	ldr	r1, [pc, #424]	; (801ddac <CST_modem_sim_init+0x544>)
 801dc04:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 801dc08:	a804      	add	r0, sp, #16
 801dc0a:	f008 fe80 	bl	802690e <memcmp>
 801dc0e:	2800      	cmp	r0, #0
 801dc10:	d1f0      	bne.n	801dbf4 <CST_modem_sim_init+0x38c>
              PRINT_CELLULAR_SERVICE(" -Found corresponding APN: \"%s\" in table\n\r", mmcmnc_apn_a[i].apn)
 801dc12:	eb05 1345 	add.w	r3, r5, r5, lsl #5
 801dc16:	4a65      	ldr	r2, [pc, #404]	; (801ddac <CST_modem_sim_init+0x544>)
 801dc18:	eb02 0243 	add.w	r2, r2, r3, lsl #1
 801dc1c:	4c5e      	ldr	r4, [pc, #376]	; (801dd98 <CST_modem_sim_init+0x530>)
 801dc1e:	3206      	adds	r2, #6
 801dc20:	4963      	ldr	r1, [pc, #396]	; (801ddb0 <CST_modem_sim_init+0x548>)
 801dc22:	4620      	mov	r0, r4
 801dc24:	f008 fe10 	bl	8026848 <sprintf>
 801dc28:	4620      	mov	r0, r4
 801dc2a:	f001 fb7e 	bl	801f32a <crs_strlen>
 801dc2e:	b283      	uxth	r3, r0
 801dc30:	4622      	mov	r2, r4
 801dc32:	2101      	movs	r1, #1
 801dc34:	2007      	movs	r0, #7
 801dc36:	f001 fbbb 	bl	801f3b0 <traceIF_itmPrint>
 801dc3a:	4620      	mov	r0, r4
 801dc3c:	f001 fb75 	bl	801f32a <crs_strlen>
 801dc40:	b283      	uxth	r3, r0
 801dc42:	4622      	mov	r2, r4
 801dc44:	2101      	movs	r1, #1
 801dc46:	2007      	movs	r0, #7
 801dc48:	f001 fbd4 	bl	801f3f4 <traceIF_uartPrint>
              idx_apn_found = i;
 801dc4c:	462c      	mov	r4, r5
              apn_found = true;
 801dc4e:	2601      	movs	r6, #1
 801dc50:	e7d0      	b.n	801dbf4 <CST_modem_sim_init+0x38c>
          if (apn_found)
 801dc52:	2e00      	cmp	r6, #0
 801dc54:	d063      	beq.n	801dd1e <CST_modem_sim_init+0x4b6>
            PRINT_CELLULAR_SERVICE("CST_modem_sim_init : CST_modem_define_pdn with APN: \"%s\"\n\r",
 801dc56:	4e55      	ldr	r6, [pc, #340]	; (801ddac <CST_modem_sim_init+0x544>)
 801dc58:	ea4f 1844 	mov.w	r8, r4, lsl #5
 801dc5c:	eb04 1744 	add.w	r7, r4, r4, lsl #5
 801dc60:	eb06 0747 	add.w	r7, r6, r7, lsl #1
 801dc64:	3706      	adds	r7, #6
 801dc66:	4d4c      	ldr	r5, [pc, #304]	; (801dd98 <CST_modem_sim_init+0x530>)
 801dc68:	463a      	mov	r2, r7
 801dc6a:	4952      	ldr	r1, [pc, #328]	; (801ddb4 <CST_modem_sim_init+0x54c>)
 801dc6c:	4628      	mov	r0, r5
 801dc6e:	f008 fdeb 	bl	8026848 <sprintf>
 801dc72:	4628      	mov	r0, r5
 801dc74:	f001 fb59 	bl	801f32a <crs_strlen>
 801dc78:	b283      	uxth	r3, r0
 801dc7a:	462a      	mov	r2, r5
 801dc7c:	2101      	movs	r1, #1
 801dc7e:	2007      	movs	r0, #7
 801dc80:	f001 fb96 	bl	801f3b0 <traceIF_itmPrint>
 801dc84:	4628      	mov	r0, r5
 801dc86:	f001 fb50 	bl	801f32a <crs_strlen>
 801dc8a:	b283      	uxth	r3, r0
 801dc8c:	462a      	mov	r2, r5
 801dc8e:	2101      	movs	r1, #1
 801dc90:	2007      	movs	r0, #7
 801dc92:	f001 fbaf 	bl	801f3f4 <traceIF_uartPrint>
                                 mmcmnc_apn_a[idx_apn_found].username,
 801dc96:	eb08 0504 	add.w	r5, r8, r4
 801dc9a:	006d      	lsls	r5, r5, #1
 801dc9c:	3518      	adds	r5, #24
 801dc9e:	4435      	add	r5, r6
 801dca0:	3502      	adds	r5, #2
                                 mmcmnc_apn_a[idx_apn_found].password);
 801dca2:	eb08 0304 	add.w	r3, r8, r4
 801dca6:	005b      	lsls	r3, r3, #1
 801dca8:	3328      	adds	r3, #40	; 0x28
 801dcaa:	18f4      	adds	r4, r6, r3
 801dcac:	3406      	adds	r4, #6
            CST_modem_define_pdn(mmcmnc_apn_a[idx_apn_found].apn,
 801dcae:	4622      	mov	r2, r4
 801dcb0:	4629      	mov	r1, r5
 801dcb2:	4638      	mov	r0, r7
 801dcb4:	f7ff fd4e 	bl	801d754 <CST_modem_define_pdn>
            (void)dc_com_read(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&apn_config, sizeof(apn_config));
 801dcb8:	f8df 8108 	ldr.w	r8, [pc, #264]	; 801ddc4 <CST_modem_sim_init+0x55c>
 801dcbc:	4e3e      	ldr	r6, [pc, #248]	; (801ddb8 <CST_modem_sim_init+0x550>)
 801dcbe:	236c      	movs	r3, #108	; 0x6c
 801dcc0:	aa47      	add	r2, sp, #284	; 0x11c
 801dcc2:	f8b8 1000 	ldrh.w	r1, [r8]
 801dcc6:	4630      	mov	r0, r6
 801dcc8:	f004 fa32 	bl	8022130 <dc_com_read>
                         crs_strlen(mmcmnc_apn_a[idx_apn_found].apn) + 1U);
 801dccc:	4638      	mov	r0, r7
 801dcce:	f001 fb2c 	bl	801f32a <crs_strlen>
            (void)memcpy(apn_config.apn, mmcmnc_apn_a[idx_apn_found].apn,
 801dcd2:	1c42      	adds	r2, r0, #1
 801dcd4:	4639      	mov	r1, r7
 801dcd6:	f20d 1025 	addw	r0, sp, #293	; 0x125
 801dcda:	f008 ff05 	bl	8026ae8 <memcpy>
                         crs_strlen(mmcmnc_apn_a[idx_apn_found].username) + 1U);
 801dcde:	4628      	mov	r0, r5
 801dce0:	f001 fb23 	bl	801f32a <crs_strlen>
            (void)memcpy(apn_config.apn, mmcmnc_apn_a[idx_apn_found].username,
 801dce4:	1c42      	adds	r2, r0, #1
 801dce6:	4629      	mov	r1, r5
 801dce8:	f20d 1025 	addw	r0, sp, #293	; 0x125
 801dcec:	f008 fefc 	bl	8026ae8 <memcpy>
                         crs_strlen(mmcmnc_apn_a[idx_apn_found].password) + 1U);
 801dcf0:	4620      	mov	r0, r4
 801dcf2:	f001 fb1a 	bl	801f32a <crs_strlen>
            (void)memcpy(apn_config.apn, mmcmnc_apn_a[idx_apn_found].password,
 801dcf6:	1c42      	adds	r2, r0, #1
 801dcf8:	4621      	mov	r1, r4
 801dcfa:	f20d 1025 	addw	r0, sp, #293	; 0x125
 801dcfe:	f008 fef3 	bl	8026ae8 <memcpy>
            (void)dc_com_write(&dc_com_db, DC_CELLULAR_APN_CONFIG, (void *)&apn_config, sizeof(apn_config));
 801dd02:	236c      	movs	r3, #108	; 0x6c
 801dd04:	aa47      	add	r2, sp, #284	; 0x11c
 801dd06:	f8b8 1000 	ldrh.w	r1, [r8]
 801dd0a:	4630      	mov	r0, r6
 801dd0c:	f004 f9c4 	bl	8022098 <dc_com_write>
        cs_status = osCDS_init_modem(CS_CMI_FULL, CELLULAR_FALSE, CST_SIM_PINCODE);
 801dd10:	4a22      	ldr	r2, [pc, #136]	; (801dd9c <CST_modem_sim_init+0x534>)
 801dd12:	2100      	movs	r1, #0
 801dd14:	2001      	movs	r0, #1
 801dd16:	f7fc ffc1 	bl	801ac9c <osCDS_init_modem>
 801dd1a:	4606      	mov	r6, r0
 801dd1c:	e757      	b.n	801dbce <CST_modem_sim_init+0x366>
            PRINT_CELLULAR_SERVICE("CST_modem_sim_init : CST_modem_define_pdn with Flash stored APN\n\r")
 801dd1e:	4c1e      	ldr	r4, [pc, #120]	; (801dd98 <CST_modem_sim_init+0x530>)
 801dd20:	2242      	movs	r2, #66	; 0x42
 801dd22:	4926      	ldr	r1, [pc, #152]	; (801ddbc <CST_modem_sim_init+0x554>)
 801dd24:	4620      	mov	r0, r4
 801dd26:	f008 fedf 	bl	8026ae8 <memcpy>
 801dd2a:	4620      	mov	r0, r4
 801dd2c:	f001 fafd 	bl	801f32a <crs_strlen>
 801dd30:	b283      	uxth	r3, r0
 801dd32:	4622      	mov	r2, r4
 801dd34:	2101      	movs	r1, #1
 801dd36:	2007      	movs	r0, #7
 801dd38:	f001 fb3a 	bl	801f3b0 <traceIF_itmPrint>
 801dd3c:	4620      	mov	r0, r4
 801dd3e:	f001 faf4 	bl	801f32a <crs_strlen>
 801dd42:	b283      	uxth	r3, r0
 801dd44:	4622      	mov	r2, r4
 801dd46:	2101      	movs	r1, #1
 801dd48:	2007      	movs	r0, #7
 801dd4a:	f001 fb53 	bl	801f3f4 <traceIF_uartPrint>
            CST_modem_define_pdn((uint8_t *)"", (uint8_t *)"", (uint8_t *)"");
 801dd4e:	4813      	ldr	r0, [pc, #76]	; (801dd9c <CST_modem_sim_init+0x534>)
 801dd50:	4602      	mov	r2, r0
 801dd52:	4601      	mov	r1, r0
 801dd54:	f7ff fcfe 	bl	801d754 <CST_modem_define_pdn>
 801dd58:	e7da      	b.n	801dd10 <CST_modem_sim_init+0x4a8>
          PRINT_CELLULAR_SERVICE("CST_modem_sim_init : CST_modem_define_pdn with Flash stored APN\n\r")
 801dd5a:	4c0f      	ldr	r4, [pc, #60]	; (801dd98 <CST_modem_sim_init+0x530>)
 801dd5c:	2242      	movs	r2, #66	; 0x42
 801dd5e:	4917      	ldr	r1, [pc, #92]	; (801ddbc <CST_modem_sim_init+0x554>)
 801dd60:	4620      	mov	r0, r4
 801dd62:	f008 fec1 	bl	8026ae8 <memcpy>
 801dd66:	4620      	mov	r0, r4
 801dd68:	f001 fadf 	bl	801f32a <crs_strlen>
 801dd6c:	b283      	uxth	r3, r0
 801dd6e:	4622      	mov	r2, r4
 801dd70:	2101      	movs	r1, #1
 801dd72:	2007      	movs	r0, #7
 801dd74:	f001 fb1c 	bl	801f3b0 <traceIF_itmPrint>
 801dd78:	4620      	mov	r0, r4
 801dd7a:	f001 fad6 	bl	801f32a <crs_strlen>
 801dd7e:	b283      	uxth	r3, r0
 801dd80:	4622      	mov	r2, r4
 801dd82:	2101      	movs	r1, #1
 801dd84:	2007      	movs	r0, #7
 801dd86:	f001 fb35 	bl	801f3f4 <traceIF_uartPrint>
          CST_modem_define_pdn((uint8_t *)"", (uint8_t *)"", (uint8_t *)"");
 801dd8a:	4804      	ldr	r0, [pc, #16]	; (801dd9c <CST_modem_sim_init+0x534>)
 801dd8c:	4602      	mov	r2, r0
 801dd8e:	4601      	mov	r1, r0
 801dd90:	f7ff fce0 	bl	801d754 <CST_modem_define_pdn>
 801dd94:	e7bc      	b.n	801dd10 <CST_modem_sim_init+0x4a8>
 801dd96:	bf00      	nop
 801dd98:	20004ddc 	.word	0x20004ddc
 801dd9c:	08035c54 	.word	0x08035c54
 801dda0:	080356e0 	.word	0x080356e0
 801dda4:	20004160 	.word	0x20004160
 801dda8:	200000b0 	.word	0x200000b0
 801ddac:	200000d0 	.word	0x200000d0
 801ddb0:	08035700 	.word	0x08035700
 801ddb4:	0803572c 	.word	0x0803572c
 801ddb8:	200058b0 	.word	0x200058b0
 801ddbc:	08035768 	.word	0x08035768
 801ddc0:	080356b8 	.word	0x080356b8
 801ddc4:	20000230 	.word	0x20000230
    PRINT_FORCE("==================================\n\r")
 801ddc8:	4e6c      	ldr	r6, [pc, #432]	; (801df7c <CST_modem_sim_init+0x714>)
 801ddca:	4c6d      	ldr	r4, [pc, #436]	; (801df80 <CST_modem_sim_init+0x718>)
 801ddcc:	f106 0c20 	add.w	ip, r6, #32
 801ddd0:	4635      	mov	r5, r6
 801ddd2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ddd4:	6020      	str	r0, [r4, #0]
 801ddd6:	6061      	str	r1, [r4, #4]
 801ddd8:	60a2      	str	r2, [r4, #8]
 801ddda:	60e3      	str	r3, [r4, #12]
 801dddc:	462e      	mov	r6, r5
 801ddde:	3410      	adds	r4, #16
 801dde0:	4565      	cmp	r5, ip
 801dde2:	d1f5      	bne.n	801ddd0 <CST_modem_sim_init+0x568>
 801dde4:	6828      	ldr	r0, [r5, #0]
 801dde6:	6020      	str	r0, [r4, #0]
 801dde8:	792b      	ldrb	r3, [r5, #4]
 801ddea:	7123      	strb	r3, [r4, #4]
 801ddec:	4c64      	ldr	r4, [pc, #400]	; (801df80 <CST_modem_sim_init+0x718>)
 801ddee:	4620      	mov	r0, r4
 801ddf0:	f001 fa9b 	bl	801f32a <crs_strlen>
 801ddf4:	b283      	uxth	r3, r0
 801ddf6:	4622      	mov	r2, r4
 801ddf8:	2101      	movs	r1, #1
 801ddfa:	2007      	movs	r0, #7
 801ddfc:	f001 fad8 	bl	801f3b0 <traceIF_itmPrint>
 801de00:	4620      	mov	r0, r4
 801de02:	f001 fa92 	bl	801f32a <crs_strlen>
 801de06:	b282      	uxth	r2, r0
 801de08:	4621      	mov	r1, r4
 801de0a:	2007      	movs	r0, #7
 801de0c:	f001 fb0a 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE(" WARNING: PIN OK PUK LOCKED !!!  \n\r")
 801de10:	4e5c      	ldr	r6, [pc, #368]	; (801df84 <CST_modem_sim_init+0x71c>)
 801de12:	f106 0c20 	add.w	ip, r6, #32
 801de16:	4635      	mov	r5, r6
 801de18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801de1a:	6020      	str	r0, [r4, #0]
 801de1c:	6061      	str	r1, [r4, #4]
 801de1e:	60a2      	str	r2, [r4, #8]
 801de20:	60e3      	str	r3, [r4, #12]
 801de22:	462e      	mov	r6, r5
 801de24:	3410      	adds	r4, #16
 801de26:	4565      	cmp	r5, ip
 801de28:	d1f5      	bne.n	801de16 <CST_modem_sim_init+0x5ae>
 801de2a:	6828      	ldr	r0, [r5, #0]
 801de2c:	6020      	str	r0, [r4, #0]
 801de2e:	4c54      	ldr	r4, [pc, #336]	; (801df80 <CST_modem_sim_init+0x718>)
 801de30:	4620      	mov	r0, r4
 801de32:	f001 fa7a 	bl	801f32a <crs_strlen>
 801de36:	b283      	uxth	r3, r0
 801de38:	4622      	mov	r2, r4
 801de3a:	2101      	movs	r1, #1
 801de3c:	2007      	movs	r0, #7
 801de3e:	f001 fab7 	bl	801f3b0 <traceIF_itmPrint>
 801de42:	4620      	mov	r0, r4
 801de44:	f001 fa71 	bl	801f32a <crs_strlen>
 801de48:	b282      	uxth	r2, r0
 801de4a:	4621      	mov	r1, r4
 801de4c:	2007      	movs	r0, #7
 801de4e:	f001 fae9 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE(" PROCESSING STOPPED\n\r")
 801de52:	4d4d      	ldr	r5, [pc, #308]	; (801df88 <CST_modem_sim_init+0x720>)
 801de54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801de56:	6020      	str	r0, [r4, #0]
 801de58:	6061      	str	r1, [r4, #4]
 801de5a:	60a2      	str	r2, [r4, #8]
 801de5c:	60e3      	str	r3, [r4, #12]
 801de5e:	6828      	ldr	r0, [r5, #0]
 801de60:	6120      	str	r0, [r4, #16]
 801de62:	88ab      	ldrh	r3, [r5, #4]
 801de64:	82a3      	strh	r3, [r4, #20]
 801de66:	4620      	mov	r0, r4
 801de68:	f001 fa5f 	bl	801f32a <crs_strlen>
 801de6c:	b283      	uxth	r3, r0
 801de6e:	4622      	mov	r2, r4
 801de70:	2101      	movs	r1, #1
 801de72:	2007      	movs	r0, #7
 801de74:	f001 fa9c 	bl	801f3b0 <traceIF_itmPrint>
 801de78:	4620      	mov	r0, r4
 801de7a:	f001 fa56 	bl	801f32a <crs_strlen>
 801de7e:	b282      	uxth	r2, r0
 801de80:	4621      	mov	r1, r4
 801de82:	2007      	movs	r0, #7
 801de84:	f001 face 	bl	801f424 <traceIF_uartPrintForce>
    PRINT_FORCE("==================================\n\r")
 801de88:	4e3c      	ldr	r6, [pc, #240]	; (801df7c <CST_modem_sim_init+0x714>)
 801de8a:	f106 0c20 	add.w	ip, r6, #32
 801de8e:	4635      	mov	r5, r6
 801de90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801de92:	6020      	str	r0, [r4, #0]
 801de94:	6061      	str	r1, [r4, #4]
 801de96:	60a2      	str	r2, [r4, #8]
 801de98:	60e3      	str	r3, [r4, #12]
 801de9a:	462e      	mov	r6, r5
 801de9c:	3410      	adds	r4, #16
 801de9e:	4565      	cmp	r5, ip
 801dea0:	d1f5      	bne.n	801de8e <CST_modem_sim_init+0x626>
 801dea2:	6828      	ldr	r0, [r5, #0]
 801dea4:	6020      	str	r0, [r4, #0]
 801dea6:	792b      	ldrb	r3, [r5, #4]
 801dea8:	7123      	strb	r3, [r4, #4]
 801deaa:	4c35      	ldr	r4, [pc, #212]	; (801df80 <CST_modem_sim_init+0x718>)
 801deac:	4620      	mov	r0, r4
 801deae:	f001 fa3c 	bl	801f32a <crs_strlen>
 801deb2:	b283      	uxth	r3, r0
 801deb4:	4622      	mov	r2, r4
 801deb6:	2101      	movs	r1, #1
 801deb8:	2007      	movs	r0, #7
 801deba:	f001 fa79 	bl	801f3b0 <traceIF_itmPrint>
 801debe:	4620      	mov	r0, r4
 801dec0:	f001 fa33 	bl	801f32a <crs_strlen>
 801dec4:	b282      	uxth	r2, r0
 801dec6:	4621      	mov	r1, r4
 801dec8:	2007      	movs	r0, #7
 801deca:	f001 faab 	bl	801f424 <traceIF_uartPrintForce>
      __NOP(); /* Nothing to do */
 801dece:	bf00      	nop
    for (;;)
 801ded0:	e7fd      	b.n	801dece <CST_modem_sim_init+0x666>
      cst_context.sim_slot_index = 0U; /* No available SIM found: set default SIM socket (Modem socket) */
 801ded2:	4b2e      	ldr	r3, [pc, #184]	; (801df8c <CST_modem_sim_init+0x724>)
 801ded4:	2200      	movs	r2, #0
 801ded6:	741a      	strb	r2, [r3, #16]
      PRINT_CELLULAR_SERVICE("CST_modem_powered_on_state : No SIM found\n\r")
 801ded8:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 801dfa0 <CST_modem_sim_init+0x738>
 801dedc:	4c28      	ldr	r4, [pc, #160]	; (801df80 <CST_modem_sim_init+0x718>)
 801dede:	f10c 0620 	add.w	r6, ip, #32
 801dee2:	4665      	mov	r5, ip
 801dee4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801dee6:	6020      	str	r0, [r4, #0]
 801dee8:	6061      	str	r1, [r4, #4]
 801deea:	60a2      	str	r2, [r4, #8]
 801deec:	60e3      	str	r3, [r4, #12]
 801deee:	46ac      	mov	ip, r5
 801def0:	3410      	adds	r4, #16
 801def2:	42b5      	cmp	r5, r6
 801def4:	d1f5      	bne.n	801dee2 <CST_modem_sim_init+0x67a>
 801def6:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 801defa:	6020      	str	r0, [r4, #0]
 801defc:	6061      	str	r1, [r4, #4]
 801defe:	60a2      	str	r2, [r4, #8]
 801df00:	4c1f      	ldr	r4, [pc, #124]	; (801df80 <CST_modem_sim_init+0x718>)
 801df02:	4620      	mov	r0, r4
 801df04:	f001 fa11 	bl	801f32a <crs_strlen>
 801df08:	b283      	uxth	r3, r0
 801df0a:	4622      	mov	r2, r4
 801df0c:	2101      	movs	r1, #1
 801df0e:	2007      	movs	r0, #7
 801df10:	f001 fa4e 	bl	801f3b0 <traceIF_itmPrint>
 801df14:	4620      	mov	r0, r4
 801df16:	f001 fa08 	bl	801f32a <crs_strlen>
 801df1a:	b283      	uxth	r3, r0
 801df1c:	4622      	mov	r2, r4
 801df1e:	2101      	movs	r1, #1
 801df20:	2007      	movs	r0, #7
 801df22:	f001 fa67 	bl	801f3f4 <traceIF_uartPrint>
 801df26:	e500      	b.n	801d92a <CST_modem_sim_init+0xc2>
    CST_subscribe_all_net_events();
 801df28:	f7ff fae6 	bl	801d4f8 <CST_subscribe_all_net_events>
    CST_get_device_all_infos(cst_cellular_params.target_state);
 801df2c:	4c18      	ldr	r4, [pc, #96]	; (801df90 <CST_modem_sim_init+0x728>)
 801df2e:	f894 0131 	ldrb.w	r0, [r4, #305]	; 0x131
 801df32:	f7fe ff9f 	bl	801ce74 <CST_get_device_all_infos>
    if (cst_cellular_params.target_state != DC_TARGET_STATE_SIM_ONLY)
 801df36:	f894 3131 	ldrb.w	r3, [r4, #305]	; 0x131
 801df3a:	2b01      	cmp	r3, #1
 801df3c:	d007      	beq.n	801df4e <CST_modem_sim_init+0x6e6>
      CST_set_state(CST_MODEM_READY_STATE);
 801df3e:	2002      	movs	r0, #2
 801df40:	f7fd fa22 	bl	801b388 <CST_set_state>
      CST_send_message(CST_MESSAGE_CS_EVENT, CST_MODEM_READY_EVENT);
 801df44:	2102      	movs	r1, #2
 801df46:	2000      	movs	r0, #0
 801df48:	f7fd f95a 	bl	801b200 <CST_send_message>
 801df4c:	e506      	b.n	801d95c <CST_modem_sim_init+0xf4>
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801df4e:	4e11      	ldr	r6, [pc, #68]	; (801df94 <CST_modem_sim_init+0x72c>)
 801df50:	4c11      	ldr	r4, [pc, #68]	; (801df98 <CST_modem_sim_init+0x730>)
 801df52:	4d12      	ldr	r5, [pc, #72]	; (801df9c <CST_modem_sim_init+0x734>)
 801df54:	23f4      	movs	r3, #244	; 0xf4
 801df56:	4622      	mov	r2, r4
 801df58:	8831      	ldrh	r1, [r6, #0]
 801df5a:	4628      	mov	r0, r5
 801df5c:	f004 f8e8 	bl	8022130 <dc_com_read>
      cst_cellular_info.rt_state    = DC_SERVICE_ON;
 801df60:	2307      	movs	r3, #7
 801df62:	7223      	strb	r3, [r4, #8]
      cst_cellular_info.modem_state = DC_MODEM_STATE_SIM_CONNECTED;
 801df64:	2302      	movs	r3, #2
 801df66:	7263      	strb	r3, [r4, #9]
      (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(dc_cellular_info_t));
 801df68:	23f4      	movs	r3, #244	; 0xf4
 801df6a:	4622      	mov	r2, r4
 801df6c:	8831      	ldrh	r1, [r6, #0]
 801df6e:	4628      	mov	r0, r5
 801df70:	f004 f892 	bl	8022098 <dc_com_write>
      CST_set_state(CST_MODEM_SIM_ONLY_STATE);
 801df74:	200b      	movs	r0, #11
 801df76:	f7fd fa07 	bl	801b388 <CST_set_state>
}
 801df7a:	e4ef      	b.n	801d95c <CST_modem_sim_init+0xf4>
 801df7c:	080357ac 	.word	0x080357ac
 801df80:	20004ddc 	.word	0x20004ddc
 801df84:	08035854 	.word	0x08035854
 801df88:	08035878 	.word	0x08035878
 801df8c:	200000b0 	.word	0x200000b0
 801df90:	20004160 	.word	0x20004160
 801df94:	20000236 	.word	0x20000236
 801df98:	2000406c 	.word	0x2000406c
 801df9c:	200058b0 	.word	0x200058b0
 801dfa0:	08035890 	.word	0x08035890

0801dfa4 <CST_set_signal_quality>:
{
 801dfa4:	b570      	push	{r4, r5, r6, lr}
 801dfa6:	b082      	sub	sp, #8
  if (osCS_get_signal_quality(&sig_quality) == CELLULAR_OK)
 801dfa8:	a801      	add	r0, sp, #4
 801dfaa:	f7fc fccb 	bl	801a944 <osCS_get_signal_quality>
 801dfae:	2800      	cmp	r0, #0
 801dfb0:	d164      	bne.n	801e07c <CST_set_signal_quality+0xd8>
 801dfb2:	4605      	mov	r5, r0
    cst_context.csq_count_fail = 0U;
 801dfb4:	4b5c      	ldr	r3, [pc, #368]	; (801e128 <CST_set_signal_quality+0x184>)
 801dfb6:	2200      	movs	r2, #0
 801dfb8:	771a      	strb	r2, [r3, #28]
    if ((sig_quality.rssi != cst_context.signal_quality.rssi) || (sig_quality.ber != cst_context.signal_quality.ber))
 801dfba:	f89d 2004 	ldrb.w	r2, [sp, #4]
 801dfbe:	791b      	ldrb	r3, [r3, #4]
 801dfc0:	429a      	cmp	r2, r3
 801dfc2:	d105      	bne.n	801dfd0 <CST_set_signal_quality+0x2c>
 801dfc4:	f89d 1005 	ldrb.w	r1, [sp, #5]
 801dfc8:	4b57      	ldr	r3, [pc, #348]	; (801e128 <CST_set_signal_quality+0x184>)
 801dfca:	795b      	ldrb	r3, [r3, #5]
 801dfcc:	4299      	cmp	r1, r3
 801dfce:	d01b      	beq.n	801e008 <CST_set_signal_quality+0x64>
      cst_context.signal_quality.rssi = sig_quality.rssi;
 801dfd0:	4b55      	ldr	r3, [pc, #340]	; (801e128 <CST_set_signal_quality+0x184>)
 801dfd2:	711a      	strb	r2, [r3, #4]
      cst_context.signal_quality.ber  = sig_quality.ber;
 801dfd4:	f89d 2005 	ldrb.w	r2, [sp, #5]
 801dfd8:	715a      	strb	r2, [r3, #5]
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801dfda:	23f4      	movs	r3, #244	; 0xf4
 801dfdc:	4a53      	ldr	r2, [pc, #332]	; (801e12c <CST_set_signal_quality+0x188>)
 801dfde:	4954      	ldr	r1, [pc, #336]	; (801e130 <CST_set_signal_quality+0x18c>)
 801dfe0:	8809      	ldrh	r1, [r1, #0]
 801dfe2:	4854      	ldr	r0, [pc, #336]	; (801e134 <CST_set_signal_quality+0x190>)
 801dfe4:	f004 f8a4 	bl	8022130 <dc_com_read>
      if (sig_quality.rssi == CST_BAD_SIG_RSSI)
 801dfe8:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801dfec:	2b63      	cmp	r3, #99	; 0x63
 801dfee:	d03f      	beq.n	801e070 <CST_set_signal_quality+0xcc>
        cst_cellular_info.cs_signal_level     = sig_quality.rssi;                         /* range 0..99 */
 801dff0:	4a4e      	ldr	r2, [pc, #312]	; (801e12c <CST_set_signal_quality+0x188>)
 801dff2:	7293      	strb	r3, [r2, #10]
        cst_cellular_info.cs_signal_level_db  = (-113 + (2 * (int32_t)sig_quality.rssi)); /* dBm value   */
 801dff4:	005b      	lsls	r3, r3, #1
 801dff6:	3b71      	subs	r3, #113	; 0x71
 801dff8:	60d3      	str	r3, [r2, #12]
      (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801dffa:	23f4      	movs	r3, #244	; 0xf4
 801dffc:	4a4b      	ldr	r2, [pc, #300]	; (801e12c <CST_set_signal_quality+0x188>)
 801dffe:	494c      	ldr	r1, [pc, #304]	; (801e130 <CST_set_signal_quality+0x18c>)
 801e000:	8809      	ldrh	r1, [r1, #0]
 801e002:	484c      	ldr	r0, [pc, #304]	; (801e134 <CST_set_signal_quality+0x190>)
 801e004:	f004 f848 	bl	8022098 <dc_com_write>
    PRINT_CELLULAR_SERVICE(" -Sig quality rssi : %d\n\r", sig_quality.rssi)
 801e008:	4c4b      	ldr	r4, [pc, #300]	; (801e138 <CST_set_signal_quality+0x194>)
 801e00a:	f89d 2004 	ldrb.w	r2, [sp, #4]
 801e00e:	494b      	ldr	r1, [pc, #300]	; (801e13c <CST_set_signal_quality+0x198>)
 801e010:	4620      	mov	r0, r4
 801e012:	f008 fc19 	bl	8026848 <sprintf>
 801e016:	4620      	mov	r0, r4
 801e018:	f001 f987 	bl	801f32a <crs_strlen>
 801e01c:	b283      	uxth	r3, r0
 801e01e:	4622      	mov	r2, r4
 801e020:	2101      	movs	r1, #1
 801e022:	2007      	movs	r0, #7
 801e024:	f001 f9c4 	bl	801f3b0 <traceIF_itmPrint>
 801e028:	4620      	mov	r0, r4
 801e02a:	f001 f97e 	bl	801f32a <crs_strlen>
 801e02e:	b283      	uxth	r3, r0
 801e030:	4622      	mov	r2, r4
 801e032:	2101      	movs	r1, #1
 801e034:	2007      	movs	r0, #7
 801e036:	f001 f9dd 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_CELLULAR_SERVICE(" -Sig quality ber  : %d\n\r", sig_quality.ber)
 801e03a:	f89d 2005 	ldrb.w	r2, [sp, #5]
 801e03e:	4940      	ldr	r1, [pc, #256]	; (801e140 <CST_set_signal_quality+0x19c>)
 801e040:	4620      	mov	r0, r4
 801e042:	f008 fc01 	bl	8026848 <sprintf>
 801e046:	4620      	mov	r0, r4
 801e048:	f001 f96f 	bl	801f32a <crs_strlen>
 801e04c:	b283      	uxth	r3, r0
 801e04e:	4622      	mov	r2, r4
 801e050:	2101      	movs	r1, #1
 801e052:	2007      	movs	r0, #7
 801e054:	f001 f9ac 	bl	801f3b0 <traceIF_itmPrint>
 801e058:	4620      	mov	r0, r4
 801e05a:	f001 f966 	bl	801f32a <crs_strlen>
 801e05e:	b283      	uxth	r3, r0
 801e060:	4622      	mov	r2, r4
 801e062:	2101      	movs	r1, #1
 801e064:	2007      	movs	r0, #7
 801e066:	f001 f9c5 	bl	801f3f4 <traceIF_uartPrint>
}
 801e06a:	4628      	mov	r0, r5
 801e06c:	b002      	add	sp, #8
 801e06e:	bd70      	pop	{r4, r5, r6, pc}
        cst_cellular_info.cs_signal_level    = DC_NO_ATTACHED;
 801e070:	4b2e      	ldr	r3, [pc, #184]	; (801e12c <CST_set_signal_quality+0x188>)
 801e072:	2200      	movs	r2, #0
 801e074:	729a      	strb	r2, [r3, #10]
        cst_cellular_info.cs_signal_level_db = (int32_t)DC_NO_ATTACHED;
 801e076:	60da      	str	r2, [r3, #12]
        cs_status = CELLULAR_ERROR;
 801e078:	2501      	movs	r5, #1
 801e07a:	e7be      	b.n	801dffa <CST_set_signal_quality+0x56>
    cst_context.csq_count_fail++;
 801e07c:	4e2a      	ldr	r6, [pc, #168]	; (801e128 <CST_set_signal_quality+0x184>)
 801e07e:	7f33      	ldrb	r3, [r6, #28]
 801e080:	3301      	adds	r3, #1
 801e082:	7733      	strb	r3, [r6, #28]
    PRINT_CELLULAR_SERVICE("Modem signal quality error\n\r")
 801e084:	4c2c      	ldr	r4, [pc, #176]	; (801e138 <CST_set_signal_quality+0x194>)
 801e086:	4d2f      	ldr	r5, [pc, #188]	; (801e144 <CST_set_signal_quality+0x1a0>)
 801e088:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e08a:	6020      	str	r0, [r4, #0]
 801e08c:	6061      	str	r1, [r4, #4]
 801e08e:	60a2      	str	r2, [r4, #8]
 801e090:	60e3      	str	r3, [r4, #12]
 801e092:	cd07      	ldmia	r5!, {r0, r1, r2}
 801e094:	6120      	str	r0, [r4, #16]
 801e096:	6161      	str	r1, [r4, #20]
 801e098:	61a2      	str	r2, [r4, #24]
 801e09a:	782b      	ldrb	r3, [r5, #0]
 801e09c:	7723      	strb	r3, [r4, #28]
 801e09e:	4620      	mov	r0, r4
 801e0a0:	f001 f943 	bl	801f32a <crs_strlen>
 801e0a4:	b283      	uxth	r3, r0
 801e0a6:	4622      	mov	r2, r4
 801e0a8:	2101      	movs	r1, #1
 801e0aa:	2007      	movs	r0, #7
 801e0ac:	f001 f980 	bl	801f3b0 <traceIF_itmPrint>
 801e0b0:	4620      	mov	r0, r4
 801e0b2:	f001 f93a 	bl	801f32a <crs_strlen>
 801e0b6:	b283      	uxth	r3, r0
 801e0b8:	4622      	mov	r2, r4
 801e0ba:	2101      	movs	r1, #1
 801e0bc:	2007      	movs	r0, #7
 801e0be:	f001 f999 	bl	801f3f4 <traceIF_uartPrint>
    if (cst_context.csq_count_fail >= CST_COUNT_FAIL_MAX)
 801e0c2:	7f33      	ldrb	r3, [r6, #28]
 801e0c4:	2b04      	cmp	r3, #4
 801e0c6:	d801      	bhi.n	801e0cc <CST_set_signal_quality+0x128>
    cs_status = CELLULAR_ERROR;
 801e0c8:	2501      	movs	r5, #1
 801e0ca:	e7ce      	b.n	801e06a <CST_set_signal_quality+0xc6>
      PRINT_CELLULAR_SERVICE("Modem signal quality error max\n\r")
 801e0cc:	4e1e      	ldr	r6, [pc, #120]	; (801e148 <CST_set_signal_quality+0x1a4>)
 801e0ce:	4625      	mov	r5, r4
 801e0d0:	f106 0c20 	add.w	ip, r6, #32
 801e0d4:	4634      	mov	r4, r6
 801e0d6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 801e0d8:	6028      	str	r0, [r5, #0]
 801e0da:	6069      	str	r1, [r5, #4]
 801e0dc:	60aa      	str	r2, [r5, #8]
 801e0de:	60eb      	str	r3, [r5, #12]
 801e0e0:	4626      	mov	r6, r4
 801e0e2:	3510      	adds	r5, #16
 801e0e4:	4564      	cmp	r4, ip
 801e0e6:	d1f5      	bne.n	801e0d4 <CST_set_signal_quality+0x130>
 801e0e8:	7823      	ldrb	r3, [r4, #0]
 801e0ea:	702b      	strb	r3, [r5, #0]
 801e0ec:	4c12      	ldr	r4, [pc, #72]	; (801e138 <CST_set_signal_quality+0x194>)
 801e0ee:	4620      	mov	r0, r4
 801e0f0:	f001 f91b 	bl	801f32a <crs_strlen>
 801e0f4:	b283      	uxth	r3, r0
 801e0f6:	4622      	mov	r2, r4
 801e0f8:	2101      	movs	r1, #1
 801e0fa:	2007      	movs	r0, #7
 801e0fc:	f001 f958 	bl	801f3b0 <traceIF_itmPrint>
 801e100:	4620      	mov	r0, r4
 801e102:	f001 f912 	bl	801f32a <crs_strlen>
 801e106:	b283      	uxth	r3, r0
 801e108:	4622      	mov	r2, r4
 801e10a:	2101      	movs	r1, #1
 801e10c:	2007      	movs	r0, #7
 801e10e:	f001 f971 	bl	801f3f4 <traceIF_uartPrint>
      cst_context.csq_count_fail = 0U;
 801e112:	4a05      	ldr	r2, [pc, #20]	; (801e128 <CST_set_signal_quality+0x184>)
 801e114:	2300      	movs	r3, #0
 801e116:	7713      	strb	r3, [r2, #28]
      CST_config_fail(((uint8_t *)"CS_get_signal_quality"),
 801e118:	2305      	movs	r3, #5
 801e11a:	3213      	adds	r2, #19
 801e11c:	2103      	movs	r1, #3
 801e11e:	480b      	ldr	r0, [pc, #44]	; (801e14c <CST_set_signal_quality+0x1a8>)
 801e120:	f7ff faa4 	bl	801d66c <CST_config_fail>
    cs_status = CELLULAR_ERROR;
 801e124:	2501      	movs	r5, #1
 801e126:	e7a0      	b.n	801e06a <CST_set_signal_quality+0xc6>
 801e128:	200000b0 	.word	0x200000b0
 801e12c:	2000406c 	.word	0x2000406c
 801e130:	20000236 	.word	0x20000236
 801e134:	200058b0 	.word	0x200058b0
 801e138:	20004ddc 	.word	0x20004ddc
 801e13c:	080358d0 	.word	0x080358d0
 801e140:	080358ec 	.word	0x080358ec
 801e144:	08035908 	.word	0x08035908
 801e148:	08035928 	.word	0x08035928
 801e14c:	0803594c 	.word	0x0803594c

0801e150 <CST_subscribe_modem_events>:
{
 801e150:	b538      	push	{r3, r4, r5, lr}
  PRINT_CELLULAR_SERVICE("Subscribe modems events\n\r")
 801e152:	4c11      	ldr	r4, [pc, #68]	; (801e198 <CST_subscribe_modem_events+0x48>)
 801e154:	4d11      	ldr	r5, [pc, #68]	; (801e19c <CST_subscribe_modem_events+0x4c>)
 801e156:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e158:	6020      	str	r0, [r4, #0]
 801e15a:	6061      	str	r1, [r4, #4]
 801e15c:	60a2      	str	r2, [r4, #8]
 801e15e:	60e3      	str	r3, [r4, #12]
 801e160:	cd03      	ldmia	r5!, {r0, r1}
 801e162:	6120      	str	r0, [r4, #16]
 801e164:	6161      	str	r1, [r4, #20]
 801e166:	882b      	ldrh	r3, [r5, #0]
 801e168:	8323      	strh	r3, [r4, #24]
 801e16a:	4620      	mov	r0, r4
 801e16c:	f001 f8dd 	bl	801f32a <crs_strlen>
 801e170:	b283      	uxth	r3, r0
 801e172:	4622      	mov	r2, r4
 801e174:	2101      	movs	r1, #1
 801e176:	2007      	movs	r0, #7
 801e178:	f001 f91a 	bl	801f3b0 <traceIF_itmPrint>
 801e17c:	4620      	mov	r0, r4
 801e17e:	f001 f8d4 	bl	801f32a <crs_strlen>
 801e182:	b283      	uxth	r3, r0
 801e184:	4622      	mov	r2, r4
 801e186:	2101      	movs	r1, #1
 801e188:	2007      	movs	r0, #7
 801e18a:	f001 f933 	bl	801f3f4 <traceIF_uartPrint>
  (void)osCDS_subscribe_modem_event(events_mask, CST_modem_event_callback);
 801e18e:	4904      	ldr	r1, [pc, #16]	; (801e1a0 <CST_subscribe_modem_events+0x50>)
 801e190:	200f      	movs	r0, #15
 801e192:	f7fc fd49 	bl	801ac28 <osCDS_subscribe_modem_event>
}
 801e196:	bd38      	pop	{r3, r4, r5, pc}
 801e198:	20004ddc 	.word	0x20004ddc
 801e19c:	08035964 	.word	0x08035964
 801e1a0:	0801cde1 	.word	0x0801cde1

0801e1a4 <CST_get_autom_event>:
  if (GET_AUTOMATON_MSG_TYPE(event) == CST_MESSAGE_CS_EVENT)
 801e1a4:	b283      	uxth	r3, r0
 801e1a6:	b90b      	cbnz	r3, 801e1ac <CST_get_autom_event+0x8>
    autom_event = (cst_autom_event_t)GET_AUTOMATON_MSG_ID(event);
 801e1a8:	0c00      	lsrs	r0, r0, #16
 801e1aa:	4770      	bx	lr
  else if (GET_AUTOMATON_MSG_TYPE(event) == CST_MESSAGE_CMD)
 801e1ac:	2b02      	cmp	r3, #2
 801e1ae:	d004      	beq.n	801e1ba <CST_get_autom_event+0x16>
  else if (GET_AUTOMATON_MSG_TYPE(event) == CST_MESSAGE_DC_EVENT)
 801e1b0:	2b01      	cmp	r3, #1
 801e1b2:	d004      	beq.n	801e1be <CST_get_autom_event+0x1a>
    __NOP(); /* Nothing to do */
 801e1b4:	bf00      	nop
  autom_event = CST_NO_EVENT;
 801e1b6:	200d      	movs	r0, #13
}
 801e1b8:	4770      	bx	lr
    autom_event = (cst_autom_event_t)GET_AUTOMATON_MSG_ID(event);
 801e1ba:	0c00      	lsrs	r0, r0, #16
 801e1bc:	4770      	bx	lr
{
 801e1be:	b510      	push	{r4, lr}
    if (GET_AUTOMATON_MSG_ID(event) == (uint16_t)DC_CELLULAR_DATA_INFO)
 801e1c0:	0c02      	lsrs	r2, r0, #16
 801e1c2:	4b15      	ldr	r3, [pc, #84]	; (801e218 <CST_get_autom_event+0x74>)
 801e1c4:	8819      	ldrh	r1, [r3, #0]
 801e1c6:	ebb1 4f10 	cmp.w	r1, r0, lsr #16
 801e1ca:	d006      	beq.n	801e1da <CST_get_autom_event+0x36>
    else if (GET_AUTOMATON_MSG_ID(event) == (uint16_t)DC_CELLULAR_TARGET_STATE_CMD)
 801e1cc:	4b13      	ldr	r3, [pc, #76]	; (801e21c <CST_get_autom_event+0x78>)
 801e1ce:	8819      	ldrh	r1, [r3, #0]
 801e1d0:	428a      	cmp	r2, r1
 801e1d2:	d00d      	beq.n	801e1f0 <CST_get_autom_event+0x4c>
      __NOP(); /* Nothing to do */
 801e1d4:	bf00      	nop
  autom_event = CST_NO_EVENT;
 801e1d6:	200d      	movs	r0, #13
}
 801e1d8:	bd10      	pop	{r4, pc}
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_DATA_INFO, (void *)&cst_cellular_data_info,
 801e1da:	4c11      	ldr	r4, [pc, #68]	; (801e220 <CST_get_autom_event+0x7c>)
 801e1dc:	2310      	movs	r3, #16
 801e1de:	4622      	mov	r2, r4
 801e1e0:	4810      	ldr	r0, [pc, #64]	; (801e224 <CST_get_autom_event+0x80>)
 801e1e2:	f003 ffa5 	bl	8022130 <dc_com_read>
      if (cst_cellular_data_info.rt_state == DC_SERVICE_FAIL)
 801e1e6:	7a23      	ldrb	r3, [r4, #8]
 801e1e8:	2b08      	cmp	r3, #8
 801e1ea:	d012      	beq.n	801e212 <CST_get_autom_event+0x6e>
  autom_event = CST_NO_EVENT;
 801e1ec:	200d      	movs	r0, #13
 801e1ee:	e7f3      	b.n	801e1d8 <CST_get_autom_event+0x34>
      (void)dc_com_read(&dc_com_db, DC_CELLULAR_TARGET_STATE_CMD, (void *)&cst_target_state, sizeof(cst_target_state));
 801e1f0:	4c0d      	ldr	r4, [pc, #52]	; (801e228 <CST_get_autom_event+0x84>)
 801e1f2:	230c      	movs	r3, #12
 801e1f4:	4622      	mov	r2, r4
 801e1f6:	480b      	ldr	r0, [pc, #44]	; (801e224 <CST_get_autom_event+0x80>)
 801e1f8:	f003 ff9a 	bl	8022130 <dc_com_read>
      if (cst_target_state.rt_state == DC_SERVICE_ON)
 801e1fc:	7a23      	ldrb	r3, [r4, #8]
 801e1fe:	2b07      	cmp	r3, #7
 801e200:	d001      	beq.n	801e206 <CST_get_autom_event+0x62>
  autom_event = CST_NO_EVENT;
 801e202:	200d      	movs	r0, #13
 801e204:	e7e8      	b.n	801e1d8 <CST_get_autom_event+0x34>
        cst_cellular_params.target_state = cst_target_state.target_state;
 801e206:	7a62      	ldrb	r2, [r4, #9]
 801e208:	4b08      	ldr	r3, [pc, #32]	; (801e22c <CST_get_autom_event+0x88>)
 801e20a:	f883 2131 	strb.w	r2, [r3, #305]	; 0x131
        autom_event = CST_TARGET_STATE_CMD_EVENT;
 801e20e:	200f      	movs	r0, #15
 801e210:	e7e2      	b.n	801e1d8 <CST_get_autom_event+0x34>
        autom_event = CST_CELLULAR_DATA_FAIL_EVENT;
 801e212:	200a      	movs	r0, #10
 801e214:	e7e0      	b.n	801e1d8 <CST_get_autom_event+0x34>
 801e216:	bf00      	nop
 801e218:	20000234 	.word	0x20000234
 801e21c:	2000023e 	.word	0x2000023e
 801e220:	2000405c 	.word	0x2000405c
 801e224:	200058b0 	.word	0x200058b0
 801e228:	200044b4 	.word	0x200044b4
 801e22c:	20004160 	.word	0x20004160

0801e230 <CST_get_network_status>:
{
 801e230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e234:	b094      	sub	sp, #80	; 0x50
  (void)memset((void *)&reg_status, 0, sizeof(reg_status));
 801e236:	224e      	movs	r2, #78	; 0x4e
 801e238:	2100      	movs	r1, #0
 801e23a:	4668      	mov	r0, sp
 801e23c:	f008 fb77 	bl	802692e <memset>
  cs_status = osCDS_get_net_status(&reg_status);
 801e240:	4668      	mov	r0, sp
 801e242:	f7fc fcb3 	bl	801abac <osCDS_get_net_status>
  if (cs_status == CELLULAR_OK)
 801e246:	2800      	cmp	r0, #0
 801e248:	d162      	bne.n	801e310 <CST_get_network_status+0xe0>
    cst_context.current_EPS_NetworkRegState  = reg_status.EPS_NetworkRegState;
 801e24a:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 801e24e:	4b33      	ldr	r3, [pc, #204]	; (801e31c <CST_get_network_status+0xec>)
 801e250:	80da      	strh	r2, [r3, #6]
    cst_context.current_GPRS_NetworkRegState = reg_status.GPRS_NetworkRegState;
 801e252:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 801e256:	8119      	strh	r1, [r3, #8]
    cst_context.current_CS_NetworkRegState   = reg_status.CS_NetworkRegState;
 801e258:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 801e25c:	8158      	strh	r0, [r3, #10]
    if ((cst_context.current_EPS_NetworkRegState  != CS_NRS_REGISTERED_HOME_NETWORK)
 801e25e:	2a01      	cmp	r2, #1
 801e260:	d00b      	beq.n	801e27a <CST_get_network_status+0x4a>
        && (cst_context.current_EPS_NetworkRegState  != CS_NRS_REGISTERED_ROAMING)
 801e262:	2a05      	cmp	r2, #5
 801e264:	d009      	beq.n	801e27a <CST_get_network_status+0x4a>
        && (cst_context.current_GPRS_NetworkRegState != CS_NRS_REGISTERED_HOME_NETWORK)
 801e266:	2901      	cmp	r1, #1
 801e268:	d007      	beq.n	801e27a <CST_get_network_status+0x4a>
        && (cst_context.current_GPRS_NetworkRegState != CS_NRS_REGISTERED_ROAMING))
 801e26a:	2905      	cmp	r1, #5
 801e26c:	d005      	beq.n	801e27a <CST_get_network_status+0x4a>
      if (cst_context.current_CS_NetworkRegState == CS_NRS_UNKNOWN)
 801e26e:	2804      	cmp	r0, #4
 801e270:	d001      	beq.n	801e276 <CST_get_network_status+0x46>
        ret = CST_NOT_REGISTERED;
 801e272:	2001      	movs	r0, #1
 801e274:	e006      	b.n	801e284 <CST_get_network_status+0x54>
        ret = CST_NET_UNKNOWN ;
 801e276:	2003      	movs	r0, #3
 801e278:	e004      	b.n	801e284 <CST_get_network_status+0x54>
      if (((uint16_t)reg_status.optional_fields_presence & (uint16_t)CS_RSF_FORMAT_PRESENT) != 0U)
 801e27a:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 801e27e:	f010 0001 	ands.w	r0, r0, #1
 801e282:	d102      	bne.n	801e28a <CST_get_network_status+0x5a>
}
 801e284:	b014      	add	sp, #80	; 0x50
 801e286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        (void)dc_com_read(&dc_com_db,  DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801e28a:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 801e330 <CST_get_network_status+0x100>
 801e28e:	4d24      	ldr	r5, [pc, #144]	; (801e320 <CST_get_network_status+0xf0>)
 801e290:	4f24      	ldr	r7, [pc, #144]	; (801e324 <CST_get_network_status+0xf4>)
 801e292:	23f4      	movs	r3, #244	; 0xf4
 801e294:	462a      	mov	r2, r5
 801e296:	f8b8 1000 	ldrh.w	r1, [r8]
 801e29a:	4638      	mov	r0, r7
 801e29c:	f003 ff48 	bl	8022130 <dc_com_read>
        (void)memcpy(cst_cellular_info.mno_name, reg_status.operator_name, DC_MAX_SIZE_MNO_NAME - 1U);
 801e2a0:	f105 0430 	add.w	r4, r5, #48	; 0x30
 801e2a4:	f10d 0c0c 	add.w	ip, sp, #12
 801e2a8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801e2ac:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801e2ae:	e89c 000f 	ldmia.w	ip, {r0, r1, r2, r3}
 801e2b2:	c407      	stmia	r4!, {r0, r1, r2}
 801e2b4:	f824 3b02 	strh.w	r3, [r4], #2
 801e2b8:	0c1b      	lsrs	r3, r3, #16
 801e2ba:	7023      	strb	r3, [r4, #0]
        cst_cellular_info.mno_name[DC_MAX_SIZE_MNO_NAME - 1U] = 0;  /* to avoid a non null terminated string */
 801e2bc:	2400      	movs	r4, #0
 801e2be:	f885 404f 	strb.w	r4, [r5, #79]	; 0x4f
        cst_cellular_info.rt_state = DC_SERVICE_ON;
 801e2c2:	2607      	movs	r6, #7
 801e2c4:	722e      	strb	r6, [r5, #8]
        cst_cellular_info.access_techno = (dc_access_techno_t)reg_status.AcT;
 801e2c6:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
 801e2ca:	f885 30f0 	strb.w	r3, [r5, #240]	; 0xf0
        (void)dc_com_write(&dc_com_db, DC_CELLULAR_INFO, (void *)&cst_cellular_info, sizeof(cst_cellular_info));
 801e2ce:	23f4      	movs	r3, #244	; 0xf4
 801e2d0:	462a      	mov	r2, r5
 801e2d2:	f8b8 1000 	ldrh.w	r1, [r8]
 801e2d6:	4638      	mov	r0, r7
 801e2d8:	f003 fede 	bl	8022098 <dc_com_write>
        PRINT_CELLULAR_SERVICE(" ->operator_name = %s", reg_status.operator_name)
 801e2dc:	4d12      	ldr	r5, [pc, #72]	; (801e328 <CST_get_network_status+0xf8>)
 801e2de:	aa03      	add	r2, sp, #12
 801e2e0:	4912      	ldr	r1, [pc, #72]	; (801e32c <CST_get_network_status+0xfc>)
 801e2e2:	4628      	mov	r0, r5
 801e2e4:	f008 fab0 	bl	8026848 <sprintf>
 801e2e8:	4628      	mov	r0, r5
 801e2ea:	f001 f81e 	bl	801f32a <crs_strlen>
 801e2ee:	b283      	uxth	r3, r0
 801e2f0:	462a      	mov	r2, r5
 801e2f2:	2101      	movs	r1, #1
 801e2f4:	4630      	mov	r0, r6
 801e2f6:	f001 f85b 	bl	801f3b0 <traceIF_itmPrint>
 801e2fa:	4628      	mov	r0, r5
 801e2fc:	f001 f815 	bl	801f32a <crs_strlen>
 801e300:	b283      	uxth	r3, r0
 801e302:	462a      	mov	r2, r5
 801e304:	2101      	movs	r1, #1
 801e306:	4630      	mov	r0, r6
 801e308:	f001 f874 	bl	801f3f4 <traceIF_uartPrint>
      ret = CST_NET_REGISTERED;
 801e30c:	4620      	mov	r0, r4
 801e30e:	e7b9      	b.n	801e284 <CST_get_network_status+0x54>
    cst_context.current_EPS_NetworkRegState  = CS_NRS_NOT_REGISTERED_SEARCHING;
 801e310:	4b02      	ldr	r3, [pc, #8]	; (801e31c <CST_get_network_status+0xec>)
 801e312:	2002      	movs	r0, #2
 801e314:	80d8      	strh	r0, [r3, #6]
    cst_context.current_GPRS_NetworkRegState = CS_NRS_NOT_REGISTERED_SEARCHING;
 801e316:	8118      	strh	r0, [r3, #8]
    cst_context.current_CS_NetworkRegState   = CS_NRS_NOT_REGISTERED_SEARCHING;
 801e318:	8158      	strh	r0, [r3, #10]
    ret = CST_NET_STATUS_ERROR;
 801e31a:	e7b3      	b.n	801e284 <CST_get_network_status+0x54>
 801e31c:	200000b0 	.word	0x200000b0
 801e320:	2000406c 	.word	0x2000406c
 801e324:	200058b0 	.word	0x200058b0
 801e328:	20004ddc 	.word	0x20004ddc
 801e32c:	08035980 	.word	0x08035980
 801e330:	20000236 	.word	0x20000236

0801e334 <ERROR_Handler_Init>:
void ERROR_Handler_Init(void)
{
  uint32_t i;

  /* initialize error array */
  for (i = 0U; i < MAX_ERROR_ENTRIES; i++)
 801e334:	2300      	movs	r3, #0
 801e336:	e00b      	b.n	801e350 <ERROR_Handler_Init+0x1c>
  {
    errors_table[i].channel = DBG_CHAN_ERROR_LOGGER; /* default value = self (ie no error) */
 801e338:	4908      	ldr	r1, [pc, #32]	; (801e35c <ERROR_Handler_Init+0x28>)
 801e33a:	0118      	lsls	r0, r3, #4
 801e33c:	eb01 1203 	add.w	r2, r1, r3, lsl #4
 801e340:	f04f 0c0b 	mov.w	ip, #11
 801e344:	f801 c000 	strb.w	ip, [r1, r0]
    errors_table[i].errorId = 0;
 801e348:	2100      	movs	r1, #0
 801e34a:	6051      	str	r1, [r2, #4]
    errors_table[i].gravity = ERROR_NO;
 801e34c:	7211      	strb	r1, [r2, #8]
  for (i = 0U; i < MAX_ERROR_ENTRIES; i++)
 801e34e:	3301      	adds	r3, #1
 801e350:	2b1f      	cmp	r3, #31
 801e352:	d9f1      	bls.n	801e338 <ERROR_Handler_Init+0x4>
  }
  error_index = 0U; /* current error index */
 801e354:	4b02      	ldr	r3, [pc, #8]	; (801e360 <ERROR_Handler_Init+0x2c>)
 801e356:	2200      	movs	r2, #0
 801e358:	801a      	strh	r2, [r3, #0]
}
 801e35a:	4770      	bx	lr
 801e35c:	200044c4 	.word	0x200044c4
 801e360:	200044c2 	.word	0x200044c2

0801e364 <ERROR_Handler>:

void ERROR_Handler(dbg_channels_t chan, int32_t errorId, error_gravity_t gravity)
{
 801e364:	b5f0      	push	{r4, r5, r6, r7, lr}
 801e366:	b083      	sub	sp, #12
 801e368:	4606      	mov	r6, r0
 801e36a:	460f      	mov	r7, r1
 801e36c:	4615      	mov	r5, r2
  /* if this is the very first error, init error array */
  if (error_counter == 0U)
 801e36e:	4b2a      	ldr	r3, [pc, #168]	; (801e418 <ERROR_Handler+0xb4>)
 801e370:	881b      	ldrh	r3, [r3, #0]
 801e372:	2b00      	cmp	r3, #0
 801e374:	d03c      	beq.n	801e3f0 <ERROR_Handler+0x8c>
  {
    ERROR_Handler_Init();
  }

  /* log the error */
  error_counter = (error_counter + 1U) % MAX_ERROR_COUNTER;
 801e376:	4928      	ldr	r1, [pc, #160]	; (801e418 <ERROR_Handler+0xb4>)
 801e378:	880b      	ldrh	r3, [r1, #0]
 801e37a:	3301      	adds	r3, #1
 801e37c:	4a27      	ldr	r2, [pc, #156]	; (801e41c <ERROR_Handler+0xb8>)
 801e37e:	fba2 2c03 	umull	r2, ip, r2, r3
 801e382:	ea4f 3cdc 	mov.w	ip, ip, lsr #15
 801e386:	ebcc 4c0c 	rsb	ip, ip, ip, lsl #16
 801e38a:	eba3 0c0c 	sub.w	ip, r3, ip
 801e38e:	fa1f f28c 	uxth.w	r2, ip
 801e392:	800a      	strh	r2, [r1, #0]
  errors_table[error_index].count = error_counter;
 801e394:	4b22      	ldr	r3, [pc, #136]	; (801e420 <ERROR_Handler+0xbc>)
 801e396:	881b      	ldrh	r3, [r3, #0]
 801e398:	4922      	ldr	r1, [pc, #136]	; (801e424 <ERROR_Handler+0xc0>)
 801e39a:	0118      	lsls	r0, r3, #4
 801e39c:	eb01 1303 	add.w	r3, r1, r3, lsl #4
 801e3a0:	60da      	str	r2, [r3, #12]
  errors_table[error_index].channel = chan;
 801e3a2:	540e      	strb	r6, [r1, r0]
  errors_table[error_index].errorId = errorId;
 801e3a4:	605f      	str	r7, [r3, #4]
  errors_table[error_index].gravity = gravity;
 801e3a6:	721d      	strb	r5, [r3, #8]

  PRINT_INFO("LOG ERROR #%d: channel=%d / errorId=%ld / gravity=%d", error_counter, chan, errorId, gravity)
 801e3a8:	4c1f      	ldr	r4, [pc, #124]	; (801e428 <ERROR_Handler+0xc4>)
 801e3aa:	9501      	str	r5, [sp, #4]
 801e3ac:	9700      	str	r7, [sp, #0]
 801e3ae:	4633      	mov	r3, r6
 801e3b0:	491e      	ldr	r1, [pc, #120]	; (801e42c <ERROR_Handler+0xc8>)
 801e3b2:	4620      	mov	r0, r4
 801e3b4:	f008 fa48 	bl	8026848 <sprintf>
 801e3b8:	4620      	mov	r0, r4
 801e3ba:	f000 ffb6 	bl	801f32a <crs_strlen>
 801e3be:	b283      	uxth	r3, r0
 801e3c0:	4622      	mov	r2, r4
 801e3c2:	2101      	movs	r1, #1
 801e3c4:	200b      	movs	r0, #11
 801e3c6:	f000 fff3 	bl	801f3b0 <traceIF_itmPrint>
 801e3ca:	4620      	mov	r0, r4
 801e3cc:	f000 ffad 	bl	801f32a <crs_strlen>
 801e3d0:	b283      	uxth	r3, r0
 801e3d2:	4622      	mov	r2, r4
 801e3d4:	2101      	movs	r1, #1
 801e3d6:	200b      	movs	r0, #11
 801e3d8:	f001 f80c 	bl	801f3f4 <traceIF_uartPrint>

  /* endless loop if error is fatal */
  if (gravity == ERROR_FATAL)
 801e3dc:	2d03      	cmp	r5, #3
 801e3de:	d00a      	beq.n	801e3f6 <ERROR_Handler+0x92>
    NVIC_SystemReset();
    /* Infinite loop is done in NVIC_SystemReset(); */
  }

  /* increment error index */
  error_index = (error_index + 1U) %  MAX_ERROR_ENTRIES;
 801e3e0:	4a0f      	ldr	r2, [pc, #60]	; (801e420 <ERROR_Handler+0xbc>)
 801e3e2:	8813      	ldrh	r3, [r2, #0]
 801e3e4:	3301      	adds	r3, #1
 801e3e6:	f003 031f 	and.w	r3, r3, #31
 801e3ea:	8013      	strh	r3, [r2, #0]
}
 801e3ec:	b003      	add	sp, #12
 801e3ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ERROR_Handler_Init();
 801e3f0:	f7ff ffa0 	bl	801e334 <ERROR_Handler_Init>
 801e3f4:	e7bf      	b.n	801e376 <ERROR_Handler+0x12>
    HAL_Delay(1000U);
 801e3f6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801e3fa:	f7e8 fdd3 	bl	8006fa4 <HAL_Delay>
  __ASM volatile ("dsb 0xF":::"memory");
 801e3fe:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 801e402:	490b      	ldr	r1, [pc, #44]	; (801e430 <ERROR_Handler+0xcc>)
 801e404:	68ca      	ldr	r2, [r1, #12]
 801e406:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 801e40a:	4b0a      	ldr	r3, [pc, #40]	; (801e434 <ERROR_Handler+0xd0>)
 801e40c:	4313      	orrs	r3, r2
 801e40e:	60cb      	str	r3, [r1, #12]
 801e410:	f3bf 8f4f 	dsb	sy
    __NOP();
 801e414:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 801e416:	e7fd      	b.n	801e414 <ERROR_Handler+0xb0>
 801e418:	200044c0 	.word	0x200044c0
 801e41c:	80008001 	.word	0x80008001
 801e420:	200044c2 	.word	0x200044c2
 801e424:	200044c4 	.word	0x200044c4
 801e428:	200051dc 	.word	0x200051dc
 801e42c:	08035998 	.word	0x08035998
 801e430:	e000ed00 	.word	0xe000ed00
 801e434:	05fa0004 	.word	0x05fa0004

0801e438 <HAL_GPIO_EXTI_Callback>:
/* Functions Definition ------------------------------------------------------*/


void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == MODEM_RING_PIN)
 801e438:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 801e43c:	d001      	beq.n	801e442 <HAL_GPIO_EXTI_Callback+0xa>
  }
#endif /* USE_BUTTONS == 1 */
  else
  {
    /* Nothing to do */
    __NOP();
 801e43e:	bf00      	nop
 801e440:	4770      	bx	lr
{
 801e442:	b508      	push	{r3, lr}
    GPIO_PinState gstate = HAL_GPIO_ReadPin(MODEM_RING_GPIO_PORT, MODEM_RING_PIN);
 801e444:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 801e448:	4804      	ldr	r0, [pc, #16]	; (801e45c <HAL_GPIO_EXTI_Callback+0x24>)
 801e44a:	f7e9 fb25 	bl	8007a98 <HAL_GPIO_ReadPin>
 801e44e:	4602      	mov	r2, r0
    atcc_hw_event(DEVTYPE_MODEM_CELLULAR, HWEVT_MODEM_RING, gstate);
 801e450:	2101      	movs	r1, #1
 801e452:	2000      	movs	r0, #0
 801e454:	f7ee f94a 	bl	800c6ec <atcc_hw_event>
  }
}
 801e458:	bd08      	pop	{r3, pc}
 801e45a:	bf00      	nop
 801e45c:	48000400 	.word	0x48000400

0801e460 <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
 801e460:	b508      	push	{r3, lr}
  if (huart->Instance == MODEM_UART_INSTANCE)
 801e462:	6803      	ldr	r3, [r0, #0]
 801e464:	4a06      	ldr	r2, [pc, #24]	; (801e480 <HAL_UART_RxCpltCallback+0x20>)
 801e466:	4293      	cmp	r3, r2
 801e468:	d004      	beq.n	801e474 <HAL_UART_RxCpltCallback+0x14>
  {
    IPC_UART_RxCpltCallback(huart);
  }
#if (USE_CMD_CONSOLE == 1)
  else if (huart->Instance == TRACE_INTERFACE_INSTANCE)
 801e46a:	4a06      	ldr	r2, [pc, #24]	; (801e484 <HAL_UART_RxCpltCallback+0x24>)
 801e46c:	4293      	cmp	r3, r2
 801e46e:	d004      	beq.n	801e47a <HAL_UART_RxCpltCallback+0x1a>
#endif  /* USE_LINK_UART */
#endif  /* USE_CMD_CONSOLE */
  else
  {
    /* Nothing to do */
    __NOP();
 801e470:	bf00      	nop
  }
}
 801e472:	bd08      	pop	{r3, pc}
    IPC_UART_RxCpltCallback(huart);
 801e474:	f000 fe1a 	bl	801f0ac <IPC_UART_RxCpltCallback>
 801e478:	e7fb      	b.n	801e472 <HAL_UART_RxCpltCallback+0x12>
    CMD_RxCpltCallback(huart);
 801e47a:	f004 fa5b 	bl	8022934 <CMD_RxCpltCallback>
 801e47e:	e7f8      	b.n	801e472 <HAL_UART_RxCpltCallback+0x12>
 801e480:	40004800 	.word	0x40004800
 801e484:	40013800 	.word	0x40013800

0801e488 <HAL_UART_TxCpltCallback>:

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
 801e488:	b508      	push	{r3, lr}
  if (huart->Instance == MODEM_UART_INSTANCE)
 801e48a:	6802      	ldr	r2, [r0, #0]
 801e48c:	4b03      	ldr	r3, [pc, #12]	; (801e49c <HAL_UART_TxCpltCallback+0x14>)
 801e48e:	429a      	cmp	r2, r3
 801e490:	d000      	beq.n	801e494 <HAL_UART_TxCpltCallback+0xc>
  {
    IPC_UART_TxCpltCallback(huart);
  }
}
 801e492:	bd08      	pop	{r3, pc}
    IPC_UART_TxCpltCallback(huart);
 801e494:	f000 fe20 	bl	801f0d8 <IPC_UART_TxCpltCallback>
}
 801e498:	e7fb      	b.n	801e492 <HAL_UART_TxCpltCallback+0xa>
 801e49a:	bf00      	nop
 801e49c:	40004800 	.word	0x40004800

0801e4a0 <HAL_UART_ErrorCallback>:

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 801e4a0:	b508      	push	{r3, lr}
  if (huart->Instance == MODEM_UART_INSTANCE)
 801e4a2:	6802      	ldr	r2, [r0, #0]
 801e4a4:	4b03      	ldr	r3, [pc, #12]	; (801e4b4 <HAL_UART_ErrorCallback+0x14>)
 801e4a6:	429a      	cmp	r2, r3
 801e4a8:	d000      	beq.n	801e4ac <HAL_UART_ErrorCallback+0xc>
  {
    IPC_UART_ErrorCallback(huart);
  }
}
 801e4aa:	bd08      	pop	{r3, pc}
    IPC_UART_ErrorCallback(huart);
 801e4ac:	f000 fe26 	bl	801f0fc <IPC_UART_ErrorCallback>
}
 801e4b0:	e7fb      	b.n	801e4aa <HAL_UART_ErrorCallback+0xa>
 801e4b2:	bf00      	nop
 801e4b4:	40004800 	.word	0x40004800

0801e4b8 <board_leds_init>:
  * @brief  Component initialisation
  * @param  -
  * @retval true/false - init OK/NOK
  */
bool board_leds_init(void)
{
 801e4b8:	b508      	push	{r3, lr}
  bool result = true;

  if (BOARD_LEDS_1 != NO_LED)
  {
    BSP_LED_Init((Led_TypeDef)BOARD_LEDS_1);
 801e4ba:	2000      	movs	r0, #0
 801e4bc:	f7e3 fc5a 	bl	8001d74 <BSP_LED_Init>
  }
  if (BOARD_LEDS_2 != NO_LED)
  {
    BSP_LED_Init((Led_TypeDef)BOARD_LEDS_2);
 801e4c0:	2001      	movs	r0, #1
 801e4c2:	f7e3 fc57 	bl	8001d74 <BSP_LED_Init>
  }
  if (BOARD_LEDS_3 != NO_LED)
  {
    BSP_LED_Init((Led_TypeDef)BOARD_LEDS_3);
 801e4c6:	2002      	movs	r0, #2
 801e4c8:	f7e3 fc54 	bl	8001d74 <BSP_LED_Init>
  }

  return (result);
}
 801e4cc:	2001      	movs	r0, #1
 801e4ce:	bd08      	pop	{r3, pc}

0801e4d0 <board_leds_start>:
  */
bool board_leds_start(void)
{
  bool result = true;
  return (result);
}
 801e4d0:	2001      	movs	r0, #1
 801e4d2:	4770      	bx	lr

0801e4d4 <IPC_init>:
IPC_Status_t IPC_init(IPC_Device_t device, IPC_Interface_t itf_type, void *hitf)
{
  IPC_Status_t status;

  /* check that device value is valid */
  if (device >= IPC_MAX_DEVICES)
 801e4d4:	b948      	cbnz	r0, 801e4ea <IPC_init+0x16>
{
 801e4d6:	b508      	push	{r3, lr}
  {
    /* IPC device id exceed maximum size defined */
    status = IPC_ERROR;
  }
  else if (hitf == NULL)
 801e4d8:	b14a      	cbz	r2, 801e4ee <IPC_init+0x1a>
  {
    status = IPC_ERROR;
  }
  else
  {
    if (itf_type == IPC_INTERFACE_UART)
 801e4da:	2901      	cmp	r1, #1
 801e4dc:	d001      	beq.n	801e4e2 <IPC_init+0xe>
      status = IPC_ERROR;
#endif /* IPC_USE_UART == 1U */
    }
    else if (itf_type == IPC_INTERFACE_SPI)
    {
      status = IPC_ERROR;
 801e4de:	2001      	movs	r0, #1
      /* interface not supported yet */
      status = IPC_ERROR;
    }
  }
  return (status);
}
 801e4e0:	bd08      	pop	{r3, pc}
      status = IPC_UART_init(device, (UART_HandleTypeDef *) hitf);
 801e4e2:	4611      	mov	r1, r2
 801e4e4:	f000 fa7a 	bl	801e9dc <IPC_UART_init>
 801e4e8:	e7fa      	b.n	801e4e0 <IPC_init+0xc>
    status = IPC_ERROR;
 801e4ea:	2001      	movs	r0, #1
}
 801e4ec:	4770      	bx	lr
    status = IPC_ERROR;
 801e4ee:	2001      	movs	r0, #1
 801e4f0:	e7f6      	b.n	801e4e0 <IPC_init+0xc>
	...

0801e4f4 <IPC_open>:
                      IPC_CheckEndOfMsgCallbackTypeDef pCheckEndOfMsg)
{
  IPC_Status_t status;

  /* check pointers */
  if ((hipc == NULL) ||
 801e4f4:	b1f0      	cbz	r0, 801e534 <IPC_open+0x40>
 801e4f6:	4684      	mov	ip, r0
 801e4f8:	b1f3      	cbz	r3, 801e538 <IPC_open+0x44>
{
 801e4fa:	b510      	push	{r4, lr}
 801e4fc:	b082      	sub	sp, #8
      (pRxClientCallback == NULL) ||
 801e4fe:	9804      	ldr	r0, [sp, #16]
 801e500:	b1e0      	cbz	r0, 801e53c <IPC_open+0x48>
      (pTxClientCallback == NULL))
  {
    status = IPC_ERROR;
  }
  else if (device >= IPC_MAX_DEVICES)
 801e502:	b9e9      	cbnz	r1, 801e540 <IPC_open+0x4c>
  {
    /* IPC device id exceed maximum size defined */
    status = IPC_ERROR;
  }
  /* check if the device has been correctly initialized */
  else if (IPC_DevicesList[device].state != IPC_STATE_INITIALIZED)
 801e504:	eb01 0041 	add.w	r0, r1, r1, lsl #1
 801e508:	4c0f      	ldr	r4, [pc, #60]	; (801e548 <IPC_open+0x54>)
 801e50a:	f814 0030 	ldrb.w	r0, [r4, r0, lsl #3]
 801e50e:	2801      	cmp	r0, #1
 801e510:	d001      	beq.n	801e516 <IPC_open+0x22>
  {
    status = IPC_ERROR;
 801e512:	2001      	movs	r0, #1
 801e514:	e015      	b.n	801e542 <IPC_open+0x4e>
  }
  else
  {
    if (IPC_DevicesList[device].phy_int.interface_type == IPC_INTERFACE_UART)
 801e516:	eb01 0e41 	add.w	lr, r1, r1, lsl #1
 801e51a:	eb04 04ce 	add.w	r4, r4, lr, lsl #3
 801e51e:	7924      	ldrb	r4, [r4, #4]
 801e520:	2c01      	cmp	r4, #1
 801e522:	d10e      	bne.n	801e542 <IPC_open+0x4e>
    {
#if (IPC_USE_UART == 1U)
      status = IPC_UART_open(hipc, device, mode, pRxClientCallback, pTxClientCallback, pCheckEndOfMsg);
 801e524:	9805      	ldr	r0, [sp, #20]
 801e526:	9001      	str	r0, [sp, #4]
 801e528:	9804      	ldr	r0, [sp, #16]
 801e52a:	9000      	str	r0, [sp, #0]
 801e52c:	4660      	mov	r0, ip
 801e52e:	f000 fa73 	bl	801ea18 <IPC_UART_open>
 801e532:	e006      	b.n	801e542 <IPC_open+0x4e>
    status = IPC_ERROR;
 801e534:	2001      	movs	r0, #1
 801e536:	4770      	bx	lr
 801e538:	2001      	movs	r0, #1
      status = IPC_ERROR;
    }
  }

  return (status);
}
 801e53a:	4770      	bx	lr
    status = IPC_ERROR;
 801e53c:	2001      	movs	r0, #1
 801e53e:	e000      	b.n	801e542 <IPC_open+0x4e>
    status = IPC_ERROR;
 801e540:	2001      	movs	r0, #1
}
 801e542:	b002      	add	sp, #8
 801e544:	bd10      	pop	{r4, pc}
 801e546:	bf00      	nop
 801e548:	200046c4 	.word	0x200046c4

0801e54c <IPC_close>:
  */
IPC_Status_t IPC_close(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e54c:	b118      	cbz	r0, 801e556 <IPC_close+0xa>
{
 801e54e:	b508      	push	{r3, lr}
  {
    status = IPC_UART_close(hipc);
 801e550:	f000 fb60 	bl	801ec14 <IPC_UART_close>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e554:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e556:	2001      	movs	r0, #1
}
 801e558:	4770      	bx	lr

0801e55a <IPC_reset>:
  */
IPC_Status_t IPC_reset(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e55a:	b118      	cbz	r0, 801e564 <IPC_reset+0xa>
{
 801e55c:	b508      	push	{r3, lr}
  {
    status = IPC_UART_reset(hipc);
 801e55e:	f000 fc1b 	bl	801ed98 <IPC_UART_reset>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e562:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e564:	2001      	movs	r0, #1
}
 801e566:	4770      	bx	lr

0801e568 <IPC_abort>:
  */
IPC_Status_t IPC_abort(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e568:	b118      	cbz	r0, 801e572 <IPC_abort+0xa>
{
 801e56a:	b508      	push	{r3, lr}
  {
    status = IPC_UART_abort(hipc);
 801e56c:	f000 fc54 	bl	801ee18 <IPC_UART_abort>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e570:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e572:	2001      	movs	r0, #1
}
 801e574:	4770      	bx	lr

0801e576 <IPC_select>:
  */
IPC_Status_t IPC_select(IPC_Handle_t *hipc)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e576:	b118      	cbz	r0, 801e580 <IPC_select+0xa>
{
 801e578:	b508      	push	{r3, lr}
  {
    status = IPC_UART_select(hipc);
 801e57a:	f000 fc75 	bl	801ee68 <IPC_UART_select>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e57e:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e580:	2001      	movs	r0, #1
}
 801e582:	4770      	bx	lr

0801e584 <IPC_get_other_channel>:
  * @brief  Get other channel handle if exists.
  * @param  hipc IPC handle.
  * @retval IPC_Handle_t*
  */
IPC_Handle_t *IPC_get_other_channel(IPC_Handle_t *hipc)
{
 801e584:	b508      	push	{r3, lr}
  return (IPC_UART_get_other_channel(hipc));
 801e586:	f000 fc9d 	bl	801eec4 <IPC_UART_get_other_channel>
}
 801e58a:	bd08      	pop	{r3, pc}

0801e58c <IPC_send>:
  */
IPC_Status_t IPC_send(IPC_Handle_t *hipc, uint8_t *p_TxBuffer, uint16_t bufsize)
{
  IPC_Status_t status;

  if ((hipc != NULL) && (p_TxBuffer != NULL))
 801e58c:	b120      	cbz	r0, 801e598 <IPC_send+0xc>
{
 801e58e:	b508      	push	{r3, lr}
  if ((hipc != NULL) && (p_TxBuffer != NULL))
 801e590:	b121      	cbz	r1, 801e59c <IPC_send+0x10>
  {
    status = IPC_UART_send(hipc, p_TxBuffer, bufsize);
 801e592:	f000 fcb9 	bl	801ef08 <IPC_UART_send>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e596:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e598:	2001      	movs	r0, #1
}
 801e59a:	4770      	bx	lr
    status = IPC_ERROR;
 801e59c:	2001      	movs	r0, #1
 801e59e:	e7fa      	b.n	801e596 <IPC_send+0xa>

0801e5a0 <IPC_receive>:
  */
IPC_Status_t IPC_receive(IPC_Handle_t *hipc, IPC_RxMessage_t *p_msg)
{
  IPC_Status_t status;

  if (hipc != NULL)
 801e5a0:	b118      	cbz	r0, 801e5aa <IPC_receive+0xa>
{
 801e5a2:	b508      	push	{r3, lr}
  {
    status = IPC_UART_receive(hipc, p_msg);
 801e5a4:	f000 fcc4 	bl	801ef30 <IPC_UART_receive>
  {
    status = IPC_ERROR;
  }

  return (status);
}
 801e5a8:	bd08      	pop	{r3, pc}
    status = IPC_ERROR;
 801e5aa:	2001      	movs	r0, #1
}
 801e5ac:	4770      	bx	lr
	...

0801e5b0 <RXFIFO_incrementTail>:
  * @param  inc_size Size to increment.
  * @retval none.
  */
static void RXFIFO_incrementTail(IPC_Handle_t *hipc, uint16_t inc_size)
{
  hipc->RxQueue.index_read = (hipc->RxQueue.index_read + inc_size) % IPC_RXBUF_MAXSIZE;
 801e5b0:	f8b0 37de 	ldrh.w	r3, [r0, #2014]	; 0x7de
 801e5b4:	4419      	add	r1, r3
 801e5b6:	4b05      	ldr	r3, [pc, #20]	; (801e5cc <RXFIFO_incrementTail+0x1c>)
 801e5b8:	fb83 2301 	smull	r2, r3, r3, r1
 801e5bc:	11db      	asrs	r3, r3, #7
 801e5be:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e5c2:	fb02 1313 	mls	r3, r2, r3, r1
 801e5c6:	f8a0 37de 	strh.w	r3, [r0, #2014]	; 0x7de
}
 801e5ca:	4770      	bx	lr
 801e5cc:	10624dd3 	.word	0x10624dd3

0801e5d0 <RXFIFO_updateMsgHeader>:
  uint8_t header_byte1;
  uint8_t header_byte2;
  uint16_t index;

  /* set header byte 1:  complete bit + size (upper part)*/
  header_byte1 = (uint8_t)(IPC_RXMSG_HEADER_COMPLETE_MASK | ((hipc->RxQueue.current_msg_size >> 8) & 0x9FU));
 801e5d0:	f8b0 17e4 	ldrh.w	r1, [r0, #2020]	; 0x7e4
 801e5d4:	f3c1 2304 	ubfx	r3, r1, #8, #5
 801e5d8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  /* set header byte 2:  size (lower part)*/
  header_byte2 = (uint8_t)(hipc->RxQueue.current_msg_size & 0x00FFU);

  /* write header bytes */
  index = hipc->RxQueue.current_msg_index;
 801e5dc:	f8b0 27e2 	ldrh.w	r2, [r0, #2018]	; 0x7e2
  hipc->RxQueue.data[index] = header_byte1;
 801e5e0:	eb00 0c02 	add.w	ip, r0, r2
 801e5e4:	f88c 300e 	strb.w	r3, [ip, #14]
  index = (index + 1U) % IPC_RXBUF_MAXSIZE;
 801e5e8:	3201      	adds	r2, #1
 801e5ea:	4b06      	ldr	r3, [pc, #24]	; (801e604 <RXFIFO_updateMsgHeader+0x34>)
 801e5ec:	fba3 c302 	umull	ip, r3, r3, r2
 801e5f0:	09db      	lsrs	r3, r3, #7
 801e5f2:	f44f 6cfa 	mov.w	ip, #2000	; 0x7d0
 801e5f6:	fb0c 2313 	mls	r3, ip, r3, r2
  hipc->RxQueue.data[index] = header_byte2;
 801e5fa:	fa10 f383 	uxtah	r3, r0, r3
 801e5fe:	7399      	strb	r1, [r3, #14]
  hipc->dbgRxQueue.msg_info_queue[hipc->dbgRxQueue.queue_pos].complete = 1;
  hipc->dbgRxQueue.queue_pos = (hipc->dbgRxQueue.queue_pos + 1) % DBG_QUEUE_SIZE;
  hipc->dbgRxQueue.msg_info_queue[hipc->dbgRxQueue.queue_pos].start_pos = hipc->RxQueue.current_msg_index;
  hipc->dbgRxQueue.msg_info_queue[hipc->dbgRxQueue.queue_pos].complete = 0;
#endif /* DBG_IPC_RX_FIFO */
}
 801e600:	4770      	bx	lr
 801e602:	bf00      	nop
 801e604:	10624dd3 	.word	0x10624dd3

0801e608 <RXFIFO_rearm_RX_IT>:
    RXFIFO_incrementHead(hipc);
  }
}

static void RXFIFO_rearm_RX_IT(IPC_Handle_t *hipc)
{
 801e608:	b508      	push	{r3, lr}
#if (IPC_USE_UART == 1U)
  IPC_UART_rearm_RX_IT(hipc);
 801e60a:	f000 fd39 	bl	801f080 <IPC_UART_rearm_RX_IT>
#else
  __NOP();
#endif /* IPC_USE_UART == 1U */
}
 801e60e:	bd08      	pop	{r3, pc}

0801e610 <IPC_RXFIFO_init>:
{
 801e610:	b510      	push	{r4, lr}
 801e612:	4604      	mov	r4, r0
  (void) memset(hipc->RxQueue.data, 0, sizeof(uint8_t) * IPC_RXBUF_MAXSIZE);
 801e614:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e618:	2100      	movs	r1, #0
 801e61a:	300e      	adds	r0, #14
 801e61c:	f008 f987 	bl	802692e <memset>
  hipc->RxQueue.index_read = 0U;
 801e620:	2300      	movs	r3, #0
 801e622:	f8a4 37de 	strh.w	r3, [r4, #2014]	; 0x7de
  hipc->RxQueue.index_write = IPC_RXMSG_HEADER_SIZE;
 801e626:	2202      	movs	r2, #2
 801e628:	f8a4 27e0 	strh.w	r2, [r4, #2016]	; 0x7e0
  hipc->RxQueue.current_msg_index = 0U;
 801e62c:	f8a4 37e2 	strh.w	r3, [r4, #2018]	; 0x7e2
  hipc->RxQueue.current_msg_size = 0U;
 801e630:	f8a4 37e4 	strh.w	r3, [r4, #2020]	; 0x7e4
  hipc->RxQueue.nb_unread_msg = 0U;
 801e634:	f884 37e6 	strb.w	r3, [r4, #2022]	; 0x7e6
}
 801e638:	bd10      	pop	{r4, pc}

0801e63a <IPC_RXFIFO_getFreeBytes>:
  if (hipc != NULL)
 801e63a:	b170      	cbz	r0, 801e65a <IPC_RXFIFO_getFreeBytes+0x20>
    if (hipc->RxQueue.index_write > hipc->RxQueue.index_read)
 801e63c:	f8b0 27e0 	ldrh.w	r2, [r0, #2016]	; 0x7e0
 801e640:	f8b0 07de 	ldrh.w	r0, [r0, #2014]	; 0x7de
 801e644:	4282      	cmp	r2, r0
 801e646:	d905      	bls.n	801e654 <IPC_RXFIFO_getFreeBytes+0x1a>
      free_bytes = (IPC_RXBUF_MAXSIZE - hipc->RxQueue.index_write +  hipc->RxQueue.index_read);
 801e648:	1a80      	subs	r0, r0, r2
 801e64a:	b280      	uxth	r0, r0
 801e64c:	f500 60fa 	add.w	r0, r0, #2000	; 0x7d0
 801e650:	b280      	uxth	r0, r0
 801e652:	4770      	bx	lr
      free_bytes =  hipc->RxQueue.index_read - hipc->RxQueue.index_write;
 801e654:	1a80      	subs	r0, r0, r2
 801e656:	b280      	uxth	r0, r0
 801e658:	4770      	bx	lr
    free_bytes = 0U;
 801e65a:	2000      	movs	r0, #0
}
 801e65c:	4770      	bx	lr
	...

0801e660 <RXFIFO_incrementHead>:
{
 801e660:	b510      	push	{r4, lr}
 801e662:	4604      	mov	r4, r0
  hipc->RxQueue.index_write = (hipc->RxQueue.index_write + 1U) % IPC_RXBUF_MAXSIZE;
 801e664:	f8b0 27e0 	ldrh.w	r2, [r0, #2016]	; 0x7e0
 801e668:	3201      	adds	r2, #1
 801e66a:	4b08      	ldr	r3, [pc, #32]	; (801e68c <RXFIFO_incrementHead+0x2c>)
 801e66c:	fba3 1302 	umull	r1, r3, r3, r2
 801e670:	09db      	lsrs	r3, r3, #7
 801e672:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 801e676:	fb01 2313 	mls	r3, r1, r3, r2
 801e67a:	f8a0 37e0 	strh.w	r3, [r0, #2016]	; 0x7e0
  free_bytes = IPC_RXFIFO_getFreeBytes(hipc);
 801e67e:	f7ff ffdc 	bl	801e63a <IPC_RXFIFO_getFreeBytes>
  if (free_bytes <= IPC_RXBUF_THRESHOLD)
 801e682:	2814      	cmp	r0, #20
 801e684:	d801      	bhi.n	801e68a <RXFIFO_incrementHead+0x2a>
    hipc->State = IPC_STATE_PAUSED;
 801e686:	2303      	movs	r3, #3
 801e688:	7363      	strb	r3, [r4, #13]
}
 801e68a:	bd10      	pop	{r4, pc}
 801e68c:	10624dd3 	.word	0x10624dd3

0801e690 <RXFIFO_prepareNextMsgHeader>:
{
 801e690:	b538      	push	{r3, r4, r5, lr}
 801e692:	4605      	mov	r5, r0
  for (idx = 0U; idx < IPC_RXMSG_HEADER_SIZE; idx++)
 801e694:	2400      	movs	r4, #0
 801e696:	e009      	b.n	801e6ac <RXFIFO_prepareNextMsgHeader+0x1c>
    hipc->RxQueue.data[hipc->RxQueue.index_write] = 0U;
 801e698:	f8b5 37e0 	ldrh.w	r3, [r5, #2016]	; 0x7e0
 801e69c:	442b      	add	r3, r5
 801e69e:	2200      	movs	r2, #0
 801e6a0:	739a      	strb	r2, [r3, #14]
    RXFIFO_incrementHead(hipc);
 801e6a2:	4628      	mov	r0, r5
 801e6a4:	f7ff ffdc 	bl	801e660 <RXFIFO_incrementHead>
  for (idx = 0U; idx < IPC_RXMSG_HEADER_SIZE; idx++)
 801e6a8:	3401      	adds	r4, #1
 801e6aa:	b2e4      	uxtb	r4, r4
 801e6ac:	2c01      	cmp	r4, #1
 801e6ae:	d9f3      	bls.n	801e698 <RXFIFO_prepareNextMsgHeader+0x8>
}
 801e6b0:	bd38      	pop	{r3, r4, r5, pc}

0801e6b2 <IPC_RXFIFO_writeCharacter>:
  if (hipc != NULL)
 801e6b2:	b390      	cbz	r0, 801e71a <IPC_RXFIFO_writeCharacter+0x68>
{
 801e6b4:	b538      	push	{r3, r4, r5, lr}
 801e6b6:	460d      	mov	r5, r1
 801e6b8:	4604      	mov	r4, r0
    hipc->RxQueue.data[hipc->RxQueue.index_write] = rxChar;
 801e6ba:	f8b0 37e0 	ldrh.w	r3, [r0, #2016]	; 0x7e0
 801e6be:	4403      	add	r3, r0
 801e6c0:	7399      	strb	r1, [r3, #14]
    hipc->RxQueue.current_msg_size++;
 801e6c2:	f8b0 37e4 	ldrh.w	r3, [r0, #2020]	; 0x7e4
 801e6c6:	3301      	adds	r3, #1
 801e6c8:	f8a0 37e4 	strh.w	r3, [r0, #2020]	; 0x7e4
    RXFIFO_incrementHead(hipc);
 801e6cc:	f7ff ffc8 	bl	801e660 <RXFIFO_incrementHead>
    if (hipc->State != IPC_STATE_PAUSED)
 801e6d0:	7b63      	ldrb	r3, [r4, #13]
 801e6d2:	2b03      	cmp	r3, #3
 801e6d4:	d106      	bne.n	801e6e4 <IPC_RXFIFO_writeCharacter+0x32>
    if ((*hipc->CheckEndOfMsgCallback)(rxChar) == 1U)
 801e6d6:	f8d4 37f0 	ldr.w	r3, [r4, #2032]	; 0x7f0
 801e6da:	4628      	mov	r0, r5
 801e6dc:	4798      	blx	r3
 801e6de:	2801      	cmp	r0, #1
 801e6e0:	d004      	beq.n	801e6ec <IPC_RXFIFO_writeCharacter+0x3a>
}
 801e6e2:	bd38      	pop	{r3, r4, r5, pc}
      RXFIFO_rearm_RX_IT(hipc);
 801e6e4:	4620      	mov	r0, r4
 801e6e6:	f7ff ff8f 	bl	801e608 <RXFIFO_rearm_RX_IT>
 801e6ea:	e7f4      	b.n	801e6d6 <IPC_RXFIFO_writeCharacter+0x24>
      hipc->RxQueue.nb_unread_msg++;
 801e6ec:	f894 37e6 	ldrb.w	r3, [r4, #2022]	; 0x7e6
 801e6f0:	3301      	adds	r3, #1
 801e6f2:	f884 37e6 	strb.w	r3, [r4, #2022]	; 0x7e6
      RXFIFO_updateMsgHeader(hipc);
 801e6f6:	4620      	mov	r0, r4
 801e6f8:	f7ff ff6a 	bl	801e5d0 <RXFIFO_updateMsgHeader>
      hipc->RxQueue.current_msg_index = hipc->RxQueue.index_write;
 801e6fc:	f8b4 37e0 	ldrh.w	r3, [r4, #2016]	; 0x7e0
 801e700:	f8a4 37e2 	strh.w	r3, [r4, #2018]	; 0x7e2
      hipc->RxQueue.current_msg_size = 0U;
 801e704:	2300      	movs	r3, #0
 801e706:	f8a4 37e4 	strh.w	r3, [r4, #2020]	; 0x7e4
      RXFIFO_prepareNextMsgHeader(hipc);
 801e70a:	4620      	mov	r0, r4
 801e70c:	f7ff ffc0 	bl	801e690 <RXFIFO_prepareNextMsgHeader>
      (* hipc->RxClientCallback)((IPC_Handle_t *)hipc);
 801e710:	f8d4 37e8 	ldr.w	r3, [r4, #2024]	; 0x7e8
 801e714:	4620      	mov	r0, r4
 801e716:	4798      	blx	r3
}
 801e718:	e7e3      	b.n	801e6e2 <IPC_RXFIFO_writeCharacter+0x30>
 801e71a:	4770      	bx	lr

0801e71c <IPC_RXFIFO_readMsgHeader_at_pos>:
  if (hipc != NULL)
 801e71c:	2800      	cmp	r0, #0
 801e71e:	d064      	beq.n	801e7ea <IPC_RXFIFO_readMsgHeader_at_pos+0xce>
{
 801e720:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e724:	460f      	mov	r7, r1
 801e726:	4616      	mov	r6, r2
 801e728:	4680      	mov	r8, r0
    PRINT_DBG("DBG IPC_RXFIFO_readMsgHeader: index_read = %d", hipc->RxQueue.index_read)
 801e72a:	4c30      	ldr	r4, [pc, #192]	; (801e7ec <IPC_RXFIFO_readMsgHeader_at_pos+0xd0>)
 801e72c:	f8b0 27de 	ldrh.w	r2, [r0, #2014]	; 0x7de
 801e730:	492f      	ldr	r1, [pc, #188]	; (801e7f0 <IPC_RXFIFO_readMsgHeader_at_pos+0xd4>)
 801e732:	4620      	mov	r0, r4
 801e734:	f008 f888 	bl	8026848 <sprintf>
 801e738:	4620      	mov	r0, r4
 801e73a:	f000 fdf6 	bl	801f32a <crs_strlen>
 801e73e:	b283      	uxth	r3, r0
 801e740:	4622      	mov	r2, r4
 801e742:	2102      	movs	r1, #2
 801e744:	2005      	movs	r0, #5
 801e746:	f000 fe33 	bl	801f3b0 <traceIF_itmPrint>
 801e74a:	4620      	mov	r0, r4
 801e74c:	f000 fded 	bl	801f32a <crs_strlen>
 801e750:	b283      	uxth	r3, r0
 801e752:	4622      	mov	r2, r4
 801e754:	2102      	movs	r1, #2
 801e756:	2005      	movs	r0, #5
 801e758:	f000 fe4c 	bl	801f3f4 <traceIF_uartPrint>
    header_byte1 = hipc->RxQueue.data[index];
 801e75c:	eb08 0306 	add.w	r3, r8, r6
 801e760:	7b9d      	ldrb	r5, [r3, #14]
    index = (index + 1U) % IPC_RXBUF_MAXSIZE;
 801e762:	3601      	adds	r6, #1
 801e764:	4b23      	ldr	r3, [pc, #140]	; (801e7f4 <IPC_RXFIFO_readMsgHeader_at_pos+0xd8>)
 801e766:	fba3 2306 	umull	r2, r3, r3, r6
 801e76a:	09db      	lsrs	r3, r3, #7
 801e76c:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 801e770:	fb02 6313 	mls	r3, r2, r3, r6
    header_byte2 = hipc->RxQueue.data[index];
 801e774:	fa18 f383 	uxtah	r3, r8, r3
 801e778:	7b9e      	ldrb	r6, [r3, #14]
    PRINT_DBG("header_byte1[0x%x] header_byte2[0x%x]", header_byte1, header_byte2)
 801e77a:	4633      	mov	r3, r6
 801e77c:	462a      	mov	r2, r5
 801e77e:	491e      	ldr	r1, [pc, #120]	; (801e7f8 <IPC_RXFIFO_readMsgHeader_at_pos+0xdc>)
 801e780:	4620      	mov	r0, r4
 801e782:	f008 f861 	bl	8026848 <sprintf>
 801e786:	4620      	mov	r0, r4
 801e788:	f000 fdcf 	bl	801f32a <crs_strlen>
 801e78c:	b283      	uxth	r3, r0
 801e78e:	4622      	mov	r2, r4
 801e790:	2102      	movs	r1, #2
 801e792:	2005      	movs	r0, #5
 801e794:	f000 fe0c 	bl	801f3b0 <traceIF_itmPrint>
 801e798:	4620      	mov	r0, r4
 801e79a:	f000 fdc6 	bl	801f32a <crs_strlen>
 801e79e:	b283      	uxth	r3, r0
 801e7a0:	4622      	mov	r2, r4
 801e7a2:	2102      	movs	r1, #2
 801e7a4:	2005      	movs	r0, #5
 801e7a6:	f000 fe25 	bl	801f3f4 <traceIF_uartPrint>
    pHeader->complete = (IPC_RXMSG_HEADER_COMPLETE_MASK & header_byte1) >> 7;
 801e7aa:	09ea      	lsrs	r2, r5, #7
 801e7ac:	703a      	strb	r2, [r7, #0]
    pHeader->size = (((uint16_t)IPC_RXMSG_HEADER_SIZE_MASK & (uint16_t)header_byte1) << 8);
 801e7ae:	022b      	lsls	r3, r5, #8
 801e7b0:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 801e7b4:	807b      	strh	r3, [r7, #2]
    pHeader->size = pHeader->size + header_byte2;
 801e7b6:	4433      	add	r3, r6
 801e7b8:	807b      	strh	r3, [r7, #2]
    PRINT_DBG("complete=%d size=%d", pHeader->complete, pHeader->size)
 801e7ba:	4910      	ldr	r1, [pc, #64]	; (801e7fc <IPC_RXFIFO_readMsgHeader_at_pos+0xe0>)
 801e7bc:	4620      	mov	r0, r4
 801e7be:	f008 f843 	bl	8026848 <sprintf>
 801e7c2:	4620      	mov	r0, r4
 801e7c4:	f000 fdb1 	bl	801f32a <crs_strlen>
 801e7c8:	b283      	uxth	r3, r0
 801e7ca:	4622      	mov	r2, r4
 801e7cc:	2102      	movs	r1, #2
 801e7ce:	2005      	movs	r0, #5
 801e7d0:	f000 fdee 	bl	801f3b0 <traceIF_itmPrint>
 801e7d4:	4620      	mov	r0, r4
 801e7d6:	f000 fda8 	bl	801f32a <crs_strlen>
 801e7da:	b283      	uxth	r3, r0
 801e7dc:	4622      	mov	r2, r4
 801e7de:	2102      	movs	r1, #2
 801e7e0:	2005      	movs	r0, #5
 801e7e2:	f000 fe07 	bl	801f3f4 <traceIF_uartPrint>
}
 801e7e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801e7ea:	4770      	bx	lr
 801e7ec:	20004bdc 	.word	0x20004bdc
 801e7f0:	080359d0 	.word	0x080359d0
 801e7f4:	10624dd3 	.word	0x10624dd3
 801e7f8:	08035a04 	.word	0x08035a04
 801e7fc:	08035a30 	.word	0x08035a30

0801e800 <IPC_RXFIFO_read>:
  if (hipc != NULL)
 801e800:	2800      	cmp	r0, #0
 801e802:	d044      	beq.n	801e88e <IPC_RXFIFO_read+0x8e>
{
 801e804:	b570      	push	{r4, r5, r6, lr}
 801e806:	b082      	sub	sp, #8
 801e808:	460d      	mov	r5, r1
 801e80a:	4604      	mov	r4, r0
    IPC_RXFIFO_readMsgHeader_at_pos(hipc, &header, hipc->RxQueue.index_read);
 801e80c:	f8b0 27de 	ldrh.w	r2, [r0, #2014]	; 0x7de
 801e810:	a901      	add	r1, sp, #4
 801e812:	f7ff ff83 	bl	801e71c <IPC_RXFIFO_readMsgHeader_at_pos>
    if (header.complete != 1U)
 801e816:	f89d 3004 	ldrb.w	r3, [sp, #4]
 801e81a:	2b01      	cmp	r3, #1
 801e81c:	d13a      	bne.n	801e894 <IPC_RXFIFO_read+0x94>
      RXFIFO_incrementTail(hipc, IPC_RXMSG_HEADER_SIZE);
 801e81e:	2102      	movs	r1, #2
 801e820:	4620      	mov	r0, r4
 801e822:	f7ff fec5 	bl	801e5b0 <RXFIFO_incrementTail>
      pMsg->size = header.size;
 801e826:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 801e82a:	f8a5 27d0 	strh.w	r2, [r5, #2000]	; 0x7d0
      if ((hipc->RxQueue.index_read + header.size) > IPC_RXBUF_MAXSIZE)
 801e82e:	f8b4 37de 	ldrh.w	r3, [r4, #2014]	; 0x7de
 801e832:	1899      	adds	r1, r3, r2
 801e834:	f5b1 6ffa 	cmp.w	r1, #2000	; 0x7d0
 801e838:	dd22      	ble.n	801e880 <IPC_RXFIFO_read+0x80>
        oversize = (hipc->RxQueue.index_read + header.size - IPC_RXBUF_MAXSIZE);
 801e83a:	b28e      	uxth	r6, r1
 801e83c:	f5a6 66fa 	sub.w	r6, r6, #2000	; 0x7d0
 801e840:	b2b6      	uxth	r6, r6
        uint16_t remaining_size = header.size - oversize;
 801e842:	1b92      	subs	r2, r2, r6
                      (void *) & (hipc->RxQueue.data[hipc->RxQueue.index_read]),
 801e844:	3308      	adds	r3, #8
 801e846:	4423      	add	r3, r4
        (void) memcpy((void *) & (pMsg->buffer[0]),
 801e848:	b292      	uxth	r2, r2
 801e84a:	1d99      	adds	r1, r3, #6
 801e84c:	4628      	mov	r0, r5
 801e84e:	f008 f94b 	bl	8026ae8 <memcpy>
        (void) memcpy((void *) & (pMsg->buffer[header.size - oversize]),
 801e852:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 801e856:	1b80      	subs	r0, r0, r6
 801e858:	4632      	mov	r2, r6
 801e85a:	f104 010e 	add.w	r1, r4, #14
 801e85e:	4428      	add	r0, r5
 801e860:	f008 f942 	bl	8026ae8 <memcpy>
      RXFIFO_incrementTail(hipc, header.size);
 801e864:	f8bd 1006 	ldrh.w	r1, [sp, #6]
 801e868:	4620      	mov	r0, r4
 801e86a:	f7ff fea1 	bl	801e5b0 <RXFIFO_incrementTail>
      hipc->RxQueue.nb_unread_msg--;
 801e86e:	f894 07e6 	ldrb.w	r0, [r4, #2022]	; 0x7e6
 801e872:	3801      	subs	r0, #1
 801e874:	b2c0      	uxtb	r0, r0
 801e876:	f884 07e6 	strb.w	r0, [r4, #2022]	; 0x7e6
      retval = (int16_t)hipc->RxQueue.nb_unread_msg;
 801e87a:	b200      	sxth	r0, r0
}
 801e87c:	b002      	add	sp, #8
 801e87e:	bd70      	pop	{r4, r5, r6, pc}
                      (void *) & (hipc->RxQueue.data[hipc->RxQueue.index_read]),
 801e880:	3308      	adds	r3, #8
 801e882:	4423      	add	r3, r4
        (void) memcpy((void *)pMsg->buffer,
 801e884:	1d99      	adds	r1, r3, #6
 801e886:	4628      	mov	r0, r5
 801e888:	f008 f92e 	bl	8026ae8 <memcpy>
 801e88c:	e7ea      	b.n	801e864 <IPC_RXFIFO_read+0x64>
    retval = -1;
 801e88e:	f04f 30ff 	mov.w	r0, #4294967295
}
 801e892:	4770      	bx	lr
      retval = -1;
 801e894:	f04f 30ff 	mov.w	r0, #4294967295
 801e898:	e7f0      	b.n	801e87c <IPC_RXFIFO_read+0x7c>
	...

0801e89c <find_Device_Id>:
  bool leave_loop = false;

  do
  {
    /* search the device corresponding to this instance */
    if (huart->Instance == IPC_DevicesList[idx].phy_int.h_uart->Instance)
 801e89c:	6802      	ldr	r2, [r0, #0]
 801e89e:	4b04      	ldr	r3, [pc, #16]	; (801e8b0 <find_Device_Id+0x14>)
 801e8a0:	689b      	ldr	r3, [r3, #8]
 801e8a2:	681b      	ldr	r3, [r3, #0]
 801e8a4:	429a      	cmp	r2, r3
 801e8a6:	d001      	beq.n	801e8ac <find_Device_Id+0x10>
 801e8a8:	20ff      	movs	r0, #255	; 0xff
 801e8aa:	4770      	bx	lr
    {
      /* force loop exit */
      device_id = idx;
 801e8ac:	2000      	movs	r0, #0
    }
    idx++;
  } while ((leave_loop == false) && (idx < IPC_MAX_DEVICES));

  return (device_id);
}
 801e8ae:	4770      	bx	lr
 801e8b0:	200046c4 	.word	0x200046c4

0801e8b4 <change_ipc_channel>:
  * brief  Change the IPC channel.
  * param  hipc IPC handle.
  * retval status
  */
static IPC_Status_t change_ipc_channel(IPC_Handle_t *hipc)
{
 801e8b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e8b6:	4607      	mov	r7, r0
  IPC_Handle_t *tmp_handle;
  tmp_handle = IPC_DevicesList[hipc->Device_ID].h_current_channel;
 801e8b8:	7803      	ldrb	r3, [r0, #0]
 801e8ba:	4e42      	ldr	r6, [pc, #264]	; (801e9c4 <change_ipc_channel+0x110>)
 801e8bc:	eb03 0243 	add.w	r2, r3, r3, lsl #1
 801e8c0:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 801e8c4:	6912      	ldr	r2, [r2, #16]

  /* swap channels */
  IPC_DevicesList[hipc->Device_ID].h_current_channel = hipc;
 801e8c6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e8ca:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801e8ce:	6118      	str	r0, [r3, #16]
  IPC_DevicesList[hipc->Device_ID].h_inactive_channel = tmp_handle;
 801e8d0:	7803      	ldrb	r3, [r0, #0]
 801e8d2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e8d6:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801e8da:	615a      	str	r2, [r3, #20]

  PRINT_DBG("Change IPC channels")
 801e8dc:	4c3a      	ldr	r4, [pc, #232]	; (801e9c8 <change_ipc_channel+0x114>)
 801e8de:	4d3b      	ldr	r5, [pc, #236]	; (801e9cc <change_ipc_channel+0x118>)
 801e8e0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801e8e2:	6020      	str	r0, [r4, #0]
 801e8e4:	6061      	str	r1, [r4, #4]
 801e8e6:	60a2      	str	r2, [r4, #8]
 801e8e8:	60e3      	str	r3, [r4, #12]
 801e8ea:	cd03      	ldmia	r5!, {r0, r1}
 801e8ec:	6120      	str	r0, [r4, #16]
 801e8ee:	6161      	str	r1, [r4, #20]
 801e8f0:	882b      	ldrh	r3, [r5, #0]
 801e8f2:	8323      	strh	r3, [r4, #24]
 801e8f4:	4620      	mov	r0, r4
 801e8f6:	f000 fd18 	bl	801f32a <crs_strlen>
 801e8fa:	b283      	uxth	r3, r0
 801e8fc:	4622      	mov	r2, r4
 801e8fe:	2102      	movs	r1, #2
 801e900:	2005      	movs	r0, #5
 801e902:	f000 fd55 	bl	801f3b0 <traceIF_itmPrint>
 801e906:	4620      	mov	r0, r4
 801e908:	f000 fd0f 	bl	801f32a <crs_strlen>
 801e90c:	b283      	uxth	r3, r0
 801e90e:	4622      	mov	r2, r4
 801e910:	2102      	movs	r1, #2
 801e912:	2005      	movs	r0, #5
 801e914:	f000 fd6e 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("state 0x%x", IPC_DevicesList[hipc->Device_ID].state)
 801e918:	783b      	ldrb	r3, [r7, #0]
 801e91a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e91e:	f816 2033 	ldrb.w	r2, [r6, r3, lsl #3]
 801e922:	492b      	ldr	r1, [pc, #172]	; (801e9d0 <change_ipc_channel+0x11c>)
 801e924:	4620      	mov	r0, r4
 801e926:	f007 ff8f 	bl	8026848 <sprintf>
 801e92a:	4620      	mov	r0, r4
 801e92c:	f000 fcfd 	bl	801f32a <crs_strlen>
 801e930:	b283      	uxth	r3, r0
 801e932:	4622      	mov	r2, r4
 801e934:	2102      	movs	r1, #2
 801e936:	2005      	movs	r0, #5
 801e938:	f000 fd3a 	bl	801f3b0 <traceIF_itmPrint>
 801e93c:	4620      	mov	r0, r4
 801e93e:	f000 fcf4 	bl	801f32a <crs_strlen>
 801e942:	b283      	uxth	r3, r0
 801e944:	4622      	mov	r2, r4
 801e946:	2102      	movs	r1, #2
 801e948:	2005      	movs	r0, #5
 801e94a:	f000 fd53 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("active channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801e94e:	783b      	ldrb	r3, [r7, #0]
 801e950:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e954:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801e958:	691a      	ldr	r2, [r3, #16]
 801e95a:	491e      	ldr	r1, [pc, #120]	; (801e9d4 <change_ipc_channel+0x120>)
 801e95c:	4620      	mov	r0, r4
 801e95e:	f007 ff73 	bl	8026848 <sprintf>
 801e962:	4620      	mov	r0, r4
 801e964:	f000 fce1 	bl	801f32a <crs_strlen>
 801e968:	b283      	uxth	r3, r0
 801e96a:	4622      	mov	r2, r4
 801e96c:	2102      	movs	r1, #2
 801e96e:	2005      	movs	r0, #5
 801e970:	f000 fd1e 	bl	801f3b0 <traceIF_itmPrint>
 801e974:	4620      	mov	r0, r4
 801e976:	f000 fcd8 	bl	801f32a <crs_strlen>
 801e97a:	b283      	uxth	r3, r0
 801e97c:	4622      	mov	r2, r4
 801e97e:	2102      	movs	r1, #2
 801e980:	2005      	movs	r0, #5
 801e982:	f000 fd37 	bl	801f3f4 <traceIF_uartPrint>
  PRINT_DBG("inactive channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_inactive_channel)
 801e986:	783b      	ldrb	r3, [r7, #0]
 801e988:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e98c:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 801e990:	6972      	ldr	r2, [r6, #20]
 801e992:	4911      	ldr	r1, [pc, #68]	; (801e9d8 <change_ipc_channel+0x124>)
 801e994:	4620      	mov	r0, r4
 801e996:	f007 ff57 	bl	8026848 <sprintf>
 801e99a:	4620      	mov	r0, r4
 801e99c:	f000 fcc5 	bl	801f32a <crs_strlen>
 801e9a0:	b283      	uxth	r3, r0
 801e9a2:	4622      	mov	r2, r4
 801e9a4:	2102      	movs	r1, #2
 801e9a6:	2005      	movs	r0, #5
 801e9a8:	f000 fd02 	bl	801f3b0 <traceIF_itmPrint>
 801e9ac:	4620      	mov	r0, r4
 801e9ae:	f000 fcbc 	bl	801f32a <crs_strlen>
 801e9b2:	b283      	uxth	r3, r0
 801e9b4:	4622      	mov	r2, r4
 801e9b6:	2102      	movs	r1, #2
 801e9b8:	2005      	movs	r0, #5
 801e9ba:	f000 fd1b 	bl	801f3f4 <traceIF_uartPrint>

  return (IPC_OK);
}
 801e9be:	2000      	movs	r0, #0
 801e9c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801e9c2:	bf00      	nop
 801e9c4:	200046c4 	.word	0x200046c4
 801e9c8:	20004bdc 	.word	0x20004bdc
 801e9cc:	08035a4c 	.word	0x08035a4c
 801e9d0:	08035a68 	.word	0x08035a68
 801e9d4:	08035a7c 	.word	0x08035a7c
 801e9d8:	08035a9c 	.word	0x08035a9c

0801e9dc <IPC_UART_init>:
{
 801e9dc:	4603      	mov	r3, r0
  if (IPC_DevicesList[device].state != IPC_STATE_NOT_INITIALIZED)
 801e9de:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801e9e2:	4a0c      	ldr	r2, [pc, #48]	; (801ea14 <IPC_UART_init+0x38>)
 801e9e4:	f812 0030 	ldrb.w	r0, [r2, r0, lsl #3]
 801e9e8:	b990      	cbnz	r0, 801ea10 <IPC_UART_init+0x34>
{
 801e9ea:	b510      	push	{r4, lr}
    IPC_DevicesList[device].state = IPC_STATE_INITIALIZED;
 801e9ec:	eb03 0443 	add.w	r4, r3, r3, lsl #1
 801e9f0:	eb02 0cc4 	add.w	ip, r2, r4, lsl #3
 801e9f4:	f04f 0e01 	mov.w	lr, #1
 801e9f8:	f802 e034 	strb.w	lr, [r2, r4, lsl #3]
    IPC_DevicesList[device].phy_int.interface_type = IPC_INTERFACE_UART;
 801e9fc:	f88c e004 	strb.w	lr, [ip, #4]
    IPC_DevicesList[device].phy_int.h_uart = huart;
 801ea00:	f8cc 1008 	str.w	r1, [ip, #8]
    IPC_DevicesList[device].h_current_channel = NULL;
 801ea04:	2100      	movs	r1, #0
 801ea06:	f8cc 1010 	str.w	r1, [ip, #16]
    IPC_DevicesList[device].h_inactive_channel = NULL;
 801ea0a:	f8cc 1014 	str.w	r1, [ip, #20]
}
 801ea0e:	bd10      	pop	{r4, pc}
    retval = IPC_ERROR;
 801ea10:	2001      	movs	r0, #1
}
 801ea12:	4770      	bx	lr
 801ea14:	200046c4 	.word	0x200046c4

0801ea18 <IPC_UART_open>:
  if ((mode != IPC_MODE_UART_CHARACTER) && (mode != IPC_MODE_UART_STREAM))
 801ea18:	2a01      	cmp	r2, #1
 801ea1a:	d901      	bls.n	801ea20 <IPC_UART_open+0x8>
    retval = IPC_ERROR;
 801ea1c:	2001      	movs	r0, #1
}
 801ea1e:	4770      	bx	lr
{
 801ea20:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ea24:	4605      	mov	r5, r0
 801ea26:	460c      	mov	r4, r1
 801ea28:	4616      	mov	r6, r2
 801ea2a:	4698      	mov	r8, r3
  else if ((mode == IPC_MODE_UART_CHARACTER) && (pCheckEndOfMsg == NULL))
 801ea2c:	b91a      	cbnz	r2, 801ea36 <IPC_UART_open+0x1e>
 801ea2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801ea30:	2b00      	cmp	r3, #0
 801ea32:	f000 80dc 	beq.w	801ebee <IPC_UART_open+0x1d6>
    if (IPC_DevicesList[device].h_current_channel == NULL)
 801ea36:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801ea3a:	4b6e      	ldr	r3, [pc, #440]	; (801ebf4 <IPC_UART_open+0x1dc>)
 801ea3c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801ea40:	691b      	ldr	r3, [r3, #16]
 801ea42:	b15b      	cbz	r3, 801ea5c <IPC_UART_open+0x44>
    else if (IPC_DevicesList[device].h_inactive_channel == NULL)
 801ea44:	eb04 0244 	add.w	r2, r4, r4, lsl #1
 801ea48:	4b6a      	ldr	r3, [pc, #424]	; (801ebf4 <IPC_UART_open+0x1dc>)
 801ea4a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801ea4e:	695b      	ldr	r3, [r3, #20]
 801ea50:	2b00      	cmp	r3, #0
 801ea52:	f000 80a0 	beq.w	801eb96 <IPC_UART_open+0x17e>
      retval = IPC_ERROR;
 801ea56:	2001      	movs	r0, #1
}
 801ea58:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      IPC_DevicesList[device].h_current_channel = hipc;
 801ea5c:	4b65      	ldr	r3, [pc, #404]	; (801ebf4 <IPC_UART_open+0x1dc>)
 801ea5e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801ea62:	611d      	str	r5, [r3, #16]
    IPC_DevicesList[device].RxChar[0] = (IPC_CHAR_t)('\0');
 801ea64:	f8df a18c 	ldr.w	sl, [pc, #396]	; 801ebf4 <IPC_UART_open+0x1dc>
 801ea68:	eb04 0944 	add.w	r9, r4, r4, lsl #1
 801ea6c:	ea4f 0bc9 	mov.w	fp, r9, lsl #3
 801ea70:	eb0a 09c9 	add.w	r9, sl, r9, lsl #3
 801ea74:	2300      	movs	r3, #0
 801ea76:	f889 300c 	strb.w	r3, [r9, #12]
    PRINT_DBG("IPC channel %p registered", IPC_DevicesList[device].h_current_channel)
 801ea7a:	4f5f      	ldr	r7, [pc, #380]	; (801ebf8 <IPC_UART_open+0x1e0>)
 801ea7c:	f8d9 2010 	ldr.w	r2, [r9, #16]
 801ea80:	495e      	ldr	r1, [pc, #376]	; (801ebfc <IPC_UART_open+0x1e4>)
 801ea82:	4638      	mov	r0, r7
 801ea84:	f007 fee0 	bl	8026848 <sprintf>
 801ea88:	4638      	mov	r0, r7
 801ea8a:	f000 fc4e 	bl	801f32a <crs_strlen>
 801ea8e:	b283      	uxth	r3, r0
 801ea90:	463a      	mov	r2, r7
 801ea92:	2102      	movs	r1, #2
 801ea94:	2005      	movs	r0, #5
 801ea96:	f000 fc8b 	bl	801f3b0 <traceIF_itmPrint>
 801ea9a:	4638      	mov	r0, r7
 801ea9c:	f000 fc45 	bl	801f32a <crs_strlen>
 801eaa0:	b283      	uxth	r3, r0
 801eaa2:	463a      	mov	r2, r7
 801eaa4:	2102      	movs	r1, #2
 801eaa6:	2005      	movs	r0, #5
 801eaa8:	f000 fca4 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_DBG("state 0x%x", IPC_DevicesList[device].state)
 801eaac:	f81a 200b 	ldrb.w	r2, [sl, fp]
 801eab0:	4953      	ldr	r1, [pc, #332]	; (801ec00 <IPC_UART_open+0x1e8>)
 801eab2:	4638      	mov	r0, r7
 801eab4:	f007 fec8 	bl	8026848 <sprintf>
 801eab8:	4638      	mov	r0, r7
 801eaba:	f000 fc36 	bl	801f32a <crs_strlen>
 801eabe:	b283      	uxth	r3, r0
 801eac0:	463a      	mov	r2, r7
 801eac2:	2102      	movs	r1, #2
 801eac4:	2005      	movs	r0, #5
 801eac6:	f000 fc73 	bl	801f3b0 <traceIF_itmPrint>
 801eaca:	4638      	mov	r0, r7
 801eacc:	f000 fc2d 	bl	801f32a <crs_strlen>
 801ead0:	b283      	uxth	r3, r0
 801ead2:	463a      	mov	r2, r7
 801ead4:	2102      	movs	r1, #2
 801ead6:	2005      	movs	r0, #5
 801ead8:	f000 fc8c 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_DBG("active channel handle: %p", IPC_DevicesList[device].h_current_channel)
 801eadc:	f8d9 2010 	ldr.w	r2, [r9, #16]
 801eae0:	4948      	ldr	r1, [pc, #288]	; (801ec04 <IPC_UART_open+0x1ec>)
 801eae2:	4638      	mov	r0, r7
 801eae4:	f007 feb0 	bl	8026848 <sprintf>
 801eae8:	4638      	mov	r0, r7
 801eaea:	f000 fc1e 	bl	801f32a <crs_strlen>
 801eaee:	b283      	uxth	r3, r0
 801eaf0:	463a      	mov	r2, r7
 801eaf2:	2102      	movs	r1, #2
 801eaf4:	2005      	movs	r0, #5
 801eaf6:	f000 fc5b 	bl	801f3b0 <traceIF_itmPrint>
 801eafa:	4638      	mov	r0, r7
 801eafc:	f000 fc15 	bl	801f32a <crs_strlen>
 801eb00:	b283      	uxth	r3, r0
 801eb02:	463a      	mov	r2, r7
 801eb04:	2102      	movs	r1, #2
 801eb06:	2005      	movs	r0, #5
 801eb08:	f000 fc74 	bl	801f3f4 <traceIF_uartPrint>
    PRINT_DBG("inactive channel handle: %p", IPC_DevicesList[device].h_inactive_channel)
 801eb0c:	f8d9 2014 	ldr.w	r2, [r9, #20]
 801eb10:	493d      	ldr	r1, [pc, #244]	; (801ec08 <IPC_UART_open+0x1f0>)
 801eb12:	4638      	mov	r0, r7
 801eb14:	f007 fe98 	bl	8026848 <sprintf>
 801eb18:	4638      	mov	r0, r7
 801eb1a:	f000 fc06 	bl	801f32a <crs_strlen>
 801eb1e:	b283      	uxth	r3, r0
 801eb20:	463a      	mov	r2, r7
 801eb22:	2102      	movs	r1, #2
 801eb24:	2005      	movs	r0, #5
 801eb26:	f000 fc43 	bl	801f3b0 <traceIF_itmPrint>
 801eb2a:	4638      	mov	r0, r7
 801eb2c:	f000 fbfd 	bl	801f32a <crs_strlen>
 801eb30:	b283      	uxth	r3, r0
 801eb32:	463a      	mov	r2, r7
 801eb34:	2102      	movs	r1, #2
 801eb36:	2005      	movs	r0, #5
 801eb38:	f000 fc5c 	bl	801f3f4 <traceIF_uartPrint>
    if (mode == IPC_MODE_UART_CHARACTER)
 801eb3c:	b916      	cbnz	r6, 801eb44 <IPC_UART_open+0x12c>
      hipc->RxFifoWrite = IPC_RXFIFO_writeCharacter;
 801eb3e:	4b33      	ldr	r3, [pc, #204]	; (801ec0c <IPC_UART_open+0x1f4>)
 801eb40:	f8c5 37f4 	str.w	r3, [r5, #2036]	; 0x7f4
    hipc->Device_ID = device;
 801eb44:	702c      	strb	r4, [r5, #0]
    hipc->Interface.interface_type = IPC_DevicesList[device].phy_int.interface_type;
 801eb46:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 801ebf4 <IPC_UART_open+0x1dc>
 801eb4a:	0067      	lsls	r7, r4, #1
 801eb4c:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 801eb50:	eb0a 03c3 	add.w	r3, sl, r3, lsl #3
 801eb54:	791a      	ldrb	r2, [r3, #4]
 801eb56:	712a      	strb	r2, [r5, #4]
    hipc->Interface.h_uart = IPC_DevicesList[device].phy_int.h_uart;
 801eb58:	689b      	ldr	r3, [r3, #8]
 801eb5a:	60ab      	str	r3, [r5, #8]
    hipc->State = IPC_STATE_INITIALIZED;
 801eb5c:	f04f 0901 	mov.w	r9, #1
 801eb60:	f885 900d 	strb.w	r9, [r5, #13]
    hipc->RxClientCallback = pRxClientCallback;
 801eb64:	f8c5 87e8 	str.w	r8, [r5, #2024]	; 0x7e8
    hipc->TxClientCallback = pTxClientCallback;
 801eb68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801eb6a:	f8c5 37ec 	str.w	r3, [r5, #2028]	; 0x7ec
    hipc->CheckEndOfMsgCallback = pCheckEndOfMsg;
 801eb6e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801eb70:	f8c5 37f0 	str.w	r3, [r5, #2032]	; 0x7f0
    hipc->Mode = mode;
 801eb74:	732e      	strb	r6, [r5, #12]
    IPC_RXFIFO_init(hipc);
 801eb76:	4628      	mov	r0, r5
 801eb78:	f7ff fd4a 	bl	801e610 <IPC_RXFIFO_init>
    uart_status = HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[device].RxChar, 1U);
 801eb7c:	1939      	adds	r1, r7, r4
 801eb7e:	00c9      	lsls	r1, r1, #3
 801eb80:	3108      	adds	r1, #8
 801eb82:	4451      	add	r1, sl
 801eb84:	464a      	mov	r2, r9
 801eb86:	3104      	adds	r1, #4
 801eb88:	68a8      	ldr	r0, [r5, #8]
 801eb8a:	f7eb fa81 	bl	800a090 <HAL_UART_Receive_IT>
    if (uart_status != HAL_OK)
 801eb8e:	b938      	cbnz	r0, 801eba0 <IPC_UART_open+0x188>
      hipc->State = IPC_STATE_ACTIVE;
 801eb90:	2302      	movs	r3, #2
 801eb92:	736b      	strb	r3, [r5, #13]
 801eb94:	e760      	b.n	801ea58 <IPC_UART_open+0x40>
      IPC_DevicesList[device].h_inactive_channel = hipc;
 801eb96:	4b17      	ldr	r3, [pc, #92]	; (801ebf4 <IPC_UART_open+0x1dc>)
 801eb98:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 801eb9c:	615d      	str	r5, [r3, #20]
  if (retval != IPC_ERROR)
 801eb9e:	e761      	b.n	801ea64 <IPC_UART_open+0x4c>
      PRINT_ERR("HAL_UART_Receive_IT error")
 801eba0:	4e1b      	ldr	r6, [pc, #108]	; (801ec10 <IPC_UART_open+0x1f8>)
 801eba2:	4c15      	ldr	r4, [pc, #84]	; (801ebf8 <IPC_UART_open+0x1e0>)
 801eba4:	f106 0720 	add.w	r7, r6, #32
 801eba8:	4635      	mov	r5, r6
 801ebaa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ebac:	6020      	str	r0, [r4, #0]
 801ebae:	6061      	str	r1, [r4, #4]
 801ebb0:	60a2      	str	r2, [r4, #8]
 801ebb2:	60e3      	str	r3, [r4, #12]
 801ebb4:	462e      	mov	r6, r5
 801ebb6:	3410      	adds	r4, #16
 801ebb8:	42bd      	cmp	r5, r7
 801ebba:	d1f5      	bne.n	801eba8 <IPC_UART_open+0x190>
 801ebbc:	6828      	ldr	r0, [r5, #0]
 801ebbe:	6020      	str	r0, [r4, #0]
 801ebc0:	88ab      	ldrh	r3, [r5, #4]
 801ebc2:	80a3      	strh	r3, [r4, #4]
 801ebc4:	4c0c      	ldr	r4, [pc, #48]	; (801ebf8 <IPC_UART_open+0x1e0>)
 801ebc6:	4620      	mov	r0, r4
 801ebc8:	f000 fbaf 	bl	801f32a <crs_strlen>
 801ebcc:	b283      	uxth	r3, r0
 801ebce:	4622      	mov	r2, r4
 801ebd0:	2110      	movs	r1, #16
 801ebd2:	2005      	movs	r0, #5
 801ebd4:	f000 fbec 	bl	801f3b0 <traceIF_itmPrint>
 801ebd8:	4620      	mov	r0, r4
 801ebda:	f000 fba6 	bl	801f32a <crs_strlen>
 801ebde:	b283      	uxth	r3, r0
 801ebe0:	4622      	mov	r2, r4
 801ebe2:	2110      	movs	r1, #16
 801ebe4:	2005      	movs	r0, #5
 801ebe6:	f000 fc05 	bl	801f3f4 <traceIF_uartPrint>
      retval = IPC_ERROR;
 801ebea:	2001      	movs	r0, #1
 801ebec:	e734      	b.n	801ea58 <IPC_UART_open+0x40>
    retval = IPC_ERROR;
 801ebee:	2001      	movs	r0, #1
 801ebf0:	e732      	b.n	801ea58 <IPC_UART_open+0x40>
 801ebf2:	bf00      	nop
 801ebf4:	200046c4 	.word	0x200046c4
 801ebf8:	20004bdc 	.word	0x20004bdc
 801ebfc:	08035ac0 	.word	0x08035ac0
 801ec00:	08035a68 	.word	0x08035a68
 801ec04:	08035a7c 	.word	0x08035a7c
 801ec08:	08035a9c 	.word	0x08035a9c
 801ec0c:	0801e6b3 	.word	0x0801e6b3
 801ec10:	08035ae0 	.word	0x08035ae0

0801ec14 <IPC_UART_close>:
  if (hipc->State != IPC_STATE_NOT_INITIALIZED)
 801ec14:	7b43      	ldrb	r3, [r0, #13]
 801ec16:	b90b      	cbnz	r3, 801ec1c <IPC_UART_close+0x8>
    retval = IPC_ERROR;
 801ec18:	2001      	movs	r0, #1
}
 801ec1a:	4770      	bx	lr
{
 801ec1c:	b570      	push	{r4, r5, r6, lr}
 801ec1e:	4604      	mov	r4, r0
    hipc->State = IPC_STATE_NOT_INITIALIZED;
 801ec20:	2300      	movs	r3, #0
 801ec22:	7343      	strb	r3, [r0, #13]
    hipc->RxClientCallback = NULL;
 801ec24:	f8c0 37e8 	str.w	r3, [r0, #2024]	; 0x7e8
    hipc->CheckEndOfMsgCallback = NULL;
 801ec28:	f8c0 37f0 	str.w	r3, [r0, #2032]	; 0x7f0
    IPC_RXFIFO_init(hipc);
 801ec2c:	f7ff fcf0 	bl	801e610 <IPC_RXFIFO_init>
    uint8_t device_id = hipc->Device_ID;
 801ec30:	7823      	ldrb	r3, [r4, #0]
    if (device_id != IPC_DEVICE_NOT_FOUND)
 801ec32:	2bff      	cmp	r3, #255	; 0xff
 801ec34:	f000 80a2 	beq.w	801ed7c <IPC_UART_close+0x168>
      if (IPC_DevicesList[device_id].h_current_channel == hipc)
 801ec38:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801ec3c:	4a50      	ldr	r2, [pc, #320]	; (801ed80 <IPC_UART_close+0x16c>)
 801ec3e:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ec42:	6912      	ldr	r2, [r2, #16]
 801ec44:	42a2      	cmp	r2, r4
 801ec46:	d07d      	beq.n	801ed44 <IPC_UART_close+0x130>
      else if (IPC_DevicesList[device_id].h_inactive_channel == hipc)
 801ec48:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801ec4c:	4a4c      	ldr	r2, [pc, #304]	; (801ed80 <IPC_UART_close+0x16c>)
 801ec4e:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ec52:	6952      	ldr	r2, [r2, #20]
 801ec54:	42a2      	cmp	r2, r4
 801ec56:	d07d      	beq.n	801ed54 <IPC_UART_close+0x140>
      if ((IPC_DevicesList[device_id].h_current_channel == NULL) &&
 801ec58:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801ec5c:	4a48      	ldr	r2, [pc, #288]	; (801ed80 <IPC_UART_close+0x16c>)
 801ec5e:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ec62:	6912      	ldr	r2, [r2, #16]
 801ec64:	2a00      	cmp	r2, #0
 801ec66:	d07b      	beq.n	801ed60 <IPC_UART_close+0x14c>
      PRINT_DBG("IPC channel %p closed", hipc)
 801ec68:	4d46      	ldr	r5, [pc, #280]	; (801ed84 <IPC_UART_close+0x170>)
 801ec6a:	4622      	mov	r2, r4
 801ec6c:	4946      	ldr	r1, [pc, #280]	; (801ed88 <IPC_UART_close+0x174>)
 801ec6e:	4628      	mov	r0, r5
 801ec70:	f007 fdea 	bl	8026848 <sprintf>
 801ec74:	4628      	mov	r0, r5
 801ec76:	f000 fb58 	bl	801f32a <crs_strlen>
 801ec7a:	b283      	uxth	r3, r0
 801ec7c:	462a      	mov	r2, r5
 801ec7e:	2102      	movs	r1, #2
 801ec80:	2005      	movs	r0, #5
 801ec82:	f000 fb95 	bl	801f3b0 <traceIF_itmPrint>
 801ec86:	4628      	mov	r0, r5
 801ec88:	f000 fb4f 	bl	801f32a <crs_strlen>
 801ec8c:	b283      	uxth	r3, r0
 801ec8e:	462a      	mov	r2, r5
 801ec90:	2102      	movs	r1, #2
 801ec92:	2005      	movs	r0, #5
 801ec94:	f000 fbae 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_DBG("state 0x%x", IPC_DevicesList[hipc->Device_ID].state)
 801ec98:	7823      	ldrb	r3, [r4, #0]
 801ec9a:	4e39      	ldr	r6, [pc, #228]	; (801ed80 <IPC_UART_close+0x16c>)
 801ec9c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eca0:	f816 2033 	ldrb.w	r2, [r6, r3, lsl #3]
 801eca4:	4939      	ldr	r1, [pc, #228]	; (801ed8c <IPC_UART_close+0x178>)
 801eca6:	4628      	mov	r0, r5
 801eca8:	f007 fdce 	bl	8026848 <sprintf>
 801ecac:	4628      	mov	r0, r5
 801ecae:	f000 fb3c 	bl	801f32a <crs_strlen>
 801ecb2:	b283      	uxth	r3, r0
 801ecb4:	462a      	mov	r2, r5
 801ecb6:	2102      	movs	r1, #2
 801ecb8:	2005      	movs	r0, #5
 801ecba:	f000 fb79 	bl	801f3b0 <traceIF_itmPrint>
 801ecbe:	4628      	mov	r0, r5
 801ecc0:	f000 fb33 	bl	801f32a <crs_strlen>
 801ecc4:	b283      	uxth	r3, r0
 801ecc6:	462a      	mov	r2, r5
 801ecc8:	2102      	movs	r1, #2
 801ecca:	2005      	movs	r0, #5
 801eccc:	f000 fb92 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_DBG("active channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801ecd0:	7823      	ldrb	r3, [r4, #0]
 801ecd2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ecd6:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 801ecda:	691a      	ldr	r2, [r3, #16]
 801ecdc:	492c      	ldr	r1, [pc, #176]	; (801ed90 <IPC_UART_close+0x17c>)
 801ecde:	4628      	mov	r0, r5
 801ece0:	f007 fdb2 	bl	8026848 <sprintf>
 801ece4:	4628      	mov	r0, r5
 801ece6:	f000 fb20 	bl	801f32a <crs_strlen>
 801ecea:	b283      	uxth	r3, r0
 801ecec:	462a      	mov	r2, r5
 801ecee:	2102      	movs	r1, #2
 801ecf0:	2005      	movs	r0, #5
 801ecf2:	f000 fb5d 	bl	801f3b0 <traceIF_itmPrint>
 801ecf6:	4628      	mov	r0, r5
 801ecf8:	f000 fb17 	bl	801f32a <crs_strlen>
 801ecfc:	b283      	uxth	r3, r0
 801ecfe:	462a      	mov	r2, r5
 801ed00:	2102      	movs	r1, #2
 801ed02:	2005      	movs	r0, #5
 801ed04:	f000 fb76 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_DBG("inactive channel handle: %p", IPC_DevicesList[hipc->Device_ID].h_inactive_channel)
 801ed08:	7823      	ldrb	r3, [r4, #0]
 801ed0a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ed0e:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
 801ed12:	6972      	ldr	r2, [r6, #20]
 801ed14:	491f      	ldr	r1, [pc, #124]	; (801ed94 <IPC_UART_close+0x180>)
 801ed16:	4628      	mov	r0, r5
 801ed18:	f007 fd96 	bl	8026848 <sprintf>
 801ed1c:	4628      	mov	r0, r5
 801ed1e:	f000 fb04 	bl	801f32a <crs_strlen>
 801ed22:	b283      	uxth	r3, r0
 801ed24:	462a      	mov	r2, r5
 801ed26:	2102      	movs	r1, #2
 801ed28:	2005      	movs	r0, #5
 801ed2a:	f000 fb41 	bl	801f3b0 <traceIF_itmPrint>
 801ed2e:	4628      	mov	r0, r5
 801ed30:	f000 fafb 	bl	801f32a <crs_strlen>
 801ed34:	b283      	uxth	r3, r0
 801ed36:	462a      	mov	r2, r5
 801ed38:	2102      	movs	r1, #2
 801ed3a:	2005      	movs	r0, #5
 801ed3c:	f000 fb5a 	bl	801f3f4 <traceIF_uartPrint>
      retval = IPC_OK;
 801ed40:	2000      	movs	r0, #0
}
 801ed42:	bd70      	pop	{r4, r5, r6, pc}
        IPC_DevicesList[device_id].h_current_channel = IPC_DevicesList[device_id].h_inactive_channel;
 801ed44:	4a0e      	ldr	r2, [pc, #56]	; (801ed80 <IPC_UART_close+0x16c>)
 801ed46:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ed4a:	6951      	ldr	r1, [r2, #20]
 801ed4c:	6111      	str	r1, [r2, #16]
        IPC_DevicesList[device_id].h_inactive_channel = NULL;
 801ed4e:	2100      	movs	r1, #0
 801ed50:	6151      	str	r1, [r2, #20]
 801ed52:	e781      	b.n	801ec58 <IPC_UART_close+0x44>
        IPC_DevicesList[device_id].h_inactive_channel = NULL;
 801ed54:	4a0a      	ldr	r2, [pc, #40]	; (801ed80 <IPC_UART_close+0x16c>)
 801ed56:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801ed5a:	2100      	movs	r1, #0
 801ed5c:	6151      	str	r1, [r2, #20]
 801ed5e:	e77b      	b.n	801ec58 <IPC_UART_close+0x44>
          (IPC_DevicesList[device_id].h_inactive_channel == NULL))
 801ed60:	4a07      	ldr	r2, [pc, #28]	; (801ed80 <IPC_UART_close+0x16c>)
 801ed62:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
 801ed66:	695b      	ldr	r3, [r3, #20]
      if ((IPC_DevicesList[device_id].h_current_channel == NULL) &&
 801ed68:	2b00      	cmp	r3, #0
 801ed6a:	f47f af7d 	bne.w	801ec68 <IPC_UART_close+0x54>
        if (hipc->Interface.h_uart != NULL)
 801ed6e:	68a0      	ldr	r0, [r4, #8]
 801ed70:	2800      	cmp	r0, #0
 801ed72:	f43f af79 	beq.w	801ec68 <IPC_UART_close+0x54>
          (void)HAL_UART_AbortTransmit_IT(hipc->Interface.h_uart);
 801ed76:	f7eb fb35 	bl	800a3e4 <HAL_UART_AbortTransmit_IT>
 801ed7a:	e775      	b.n	801ec68 <IPC_UART_close+0x54>
      retval = IPC_ERROR;
 801ed7c:	2001      	movs	r0, #1
 801ed7e:	e7e0      	b.n	801ed42 <IPC_UART_close+0x12e>
 801ed80:	200046c4 	.word	0x200046c4
 801ed84:	20004bdc 	.word	0x20004bdc
 801ed88:	08035b08 	.word	0x08035b08
 801ed8c:	08035a68 	.word	0x08035a68
 801ed90:	08035a7c 	.word	0x08035a7c
 801ed94:	08035a9c 	.word	0x08035a9c

0801ed98 <IPC_UART_reset>:
{
 801ed98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801ed9c:	4604      	mov	r4, r0
  PRINT_DBG("IPC reset %p", hipc)
 801ed9e:	4d1b      	ldr	r5, [pc, #108]	; (801ee0c <IPC_UART_reset+0x74>)
 801eda0:	4602      	mov	r2, r0
 801eda2:	491b      	ldr	r1, [pc, #108]	; (801ee10 <IPC_UART_reset+0x78>)
 801eda4:	4628      	mov	r0, r5
 801eda6:	f007 fd4f 	bl	8026848 <sprintf>
 801edaa:	4628      	mov	r0, r5
 801edac:	f000 fabd 	bl	801f32a <crs_strlen>
 801edb0:	b283      	uxth	r3, r0
 801edb2:	462a      	mov	r2, r5
 801edb4:	2102      	movs	r1, #2
 801edb6:	2005      	movs	r0, #5
 801edb8:	f000 fafa 	bl	801f3b0 <traceIF_itmPrint>
 801edbc:	4628      	mov	r0, r5
 801edbe:	f000 fab4 	bl	801f32a <crs_strlen>
 801edc2:	b283      	uxth	r3, r0
 801edc4:	462a      	mov	r2, r5
 801edc6:	2102      	movs	r1, #2
 801edc8:	2005      	movs	r0, #5
 801edca:	f000 fb13 	bl	801f3f4 <traceIF_uartPrint>
  uint8_t device_id = hipc->Device_ID;
 801edce:	7826      	ldrb	r6, [r4, #0]
  if (device_id != IPC_DEVICE_NOT_FOUND)
 801edd0:	2eff      	cmp	r6, #255	; 0xff
 801edd2:	d102      	bne.n	801edda <IPC_UART_reset+0x42>
  IPC_Status_t retval = IPC_ERROR;
 801edd4:	2001      	movs	r0, #1
}
 801edd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    IPC_DevicesList[device_id].RxChar[0] = (IPC_CHAR_t)('\0');
 801edda:	f8df 8038 	ldr.w	r8, [pc, #56]	; 801ee14 <IPC_UART_reset+0x7c>
 801edde:	0075      	lsls	r5, r6, #1
 801ede0:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 801ede4:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 801ede8:	2700      	movs	r7, #0
 801edea:	731f      	strb	r7, [r3, #12]
    IPC_RXFIFO_init(hipc);
 801edec:	4620      	mov	r0, r4
 801edee:	f7ff fc0f 	bl	801e610 <IPC_RXFIFO_init>
    (void) HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[device_id].RxChar, 1U);
 801edf2:	19a9      	adds	r1, r5, r6
 801edf4:	00c9      	lsls	r1, r1, #3
 801edf6:	3108      	adds	r1, #8
 801edf8:	4441      	add	r1, r8
 801edfa:	2201      	movs	r2, #1
 801edfc:	3104      	adds	r1, #4
 801edfe:	68a0      	ldr	r0, [r4, #8]
 801ee00:	f7eb f946 	bl	800a090 <HAL_UART_Receive_IT>
    hipc->State = IPC_STATE_ACTIVE;
 801ee04:	2302      	movs	r3, #2
 801ee06:	7363      	strb	r3, [r4, #13]
    retval = IPC_OK;
 801ee08:	4638      	mov	r0, r7
 801ee0a:	e7e4      	b.n	801edd6 <IPC_UART_reset+0x3e>
 801ee0c:	20004bdc 	.word	0x20004bdc
 801ee10:	08035b24 	.word	0x08035b24
 801ee14:	200046c4 	.word	0x200046c4

0801ee18 <IPC_UART_abort>:
{
 801ee18:	b538      	push	{r3, r4, r5, lr}
 801ee1a:	4605      	mov	r5, r0
  PRINT_DBG("IPC abort %p", hipc)
 801ee1c:	4c10      	ldr	r4, [pc, #64]	; (801ee60 <IPC_UART_abort+0x48>)
 801ee1e:	4602      	mov	r2, r0
 801ee20:	4910      	ldr	r1, [pc, #64]	; (801ee64 <IPC_UART_abort+0x4c>)
 801ee22:	4620      	mov	r0, r4
 801ee24:	f007 fd10 	bl	8026848 <sprintf>
 801ee28:	4620      	mov	r0, r4
 801ee2a:	f000 fa7e 	bl	801f32a <crs_strlen>
 801ee2e:	b283      	uxth	r3, r0
 801ee30:	4622      	mov	r2, r4
 801ee32:	2102      	movs	r1, #2
 801ee34:	2005      	movs	r0, #5
 801ee36:	f000 fabb 	bl	801f3b0 <traceIF_itmPrint>
 801ee3a:	4620      	mov	r0, r4
 801ee3c:	f000 fa75 	bl	801f32a <crs_strlen>
 801ee40:	b283      	uxth	r3, r0
 801ee42:	4622      	mov	r2, r4
 801ee44:	2102      	movs	r1, #2
 801ee46:	2005      	movs	r0, #5
 801ee48:	f000 fad4 	bl	801f3f4 <traceIF_uartPrint>
  if (hipc->Interface.h_uart != NULL)
 801ee4c:	68a8      	ldr	r0, [r5, #8]
 801ee4e:	b108      	cbz	r0, 801ee54 <IPC_UART_abort+0x3c>
    if (hipc->Interface.h_uart->gState != HAL_UART_STATE_RESET)
 801ee50:	6f43      	ldr	r3, [r0, #116]	; 0x74
 801ee52:	b90b      	cbnz	r3, 801ee58 <IPC_UART_abort+0x40>
}
 801ee54:	2000      	movs	r0, #0
 801ee56:	bd38      	pop	{r3, r4, r5, pc}
      (void)HAL_UART_AbortTransmit_IT(hipc->Interface.h_uart);
 801ee58:	f7eb fac4 	bl	800a3e4 <HAL_UART_AbortTransmit_IT>
 801ee5c:	e7fa      	b.n	801ee54 <IPC_UART_abort+0x3c>
 801ee5e:	bf00      	nop
 801ee60:	20004bdc 	.word	0x20004bdc
 801ee64:	08035b38 	.word	0x08035b38

0801ee68 <IPC_UART_select>:
{
 801ee68:	b538      	push	{r3, r4, r5, lr}
 801ee6a:	4604      	mov	r4, r0
  PRINT_DBG("IPC select %p", hipc)
 801ee6c:	4d12      	ldr	r5, [pc, #72]	; (801eeb8 <IPC_UART_select+0x50>)
 801ee6e:	4602      	mov	r2, r0
 801ee70:	4912      	ldr	r1, [pc, #72]	; (801eebc <IPC_UART_select+0x54>)
 801ee72:	4628      	mov	r0, r5
 801ee74:	f007 fce8 	bl	8026848 <sprintf>
 801ee78:	4628      	mov	r0, r5
 801ee7a:	f000 fa56 	bl	801f32a <crs_strlen>
 801ee7e:	b283      	uxth	r3, r0
 801ee80:	462a      	mov	r2, r5
 801ee82:	2102      	movs	r1, #2
 801ee84:	2005      	movs	r0, #5
 801ee86:	f000 fa93 	bl	801f3b0 <traceIF_itmPrint>
 801ee8a:	4628      	mov	r0, r5
 801ee8c:	f000 fa4d 	bl	801f32a <crs_strlen>
 801ee90:	b283      	uxth	r3, r0
 801ee92:	462a      	mov	r2, r5
 801ee94:	2102      	movs	r1, #2
 801ee96:	2005      	movs	r0, #5
 801ee98:	f000 faac 	bl	801f3f4 <traceIF_uartPrint>
  if (hipc != IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801ee9c:	7823      	ldrb	r3, [r4, #0]
 801ee9e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eea2:	4a07      	ldr	r2, [pc, #28]	; (801eec0 <IPC_UART_select+0x58>)
 801eea4:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801eea8:	691b      	ldr	r3, [r3, #16]
 801eeaa:	42a3      	cmp	r3, r4
 801eeac:	d002      	beq.n	801eeb4 <IPC_UART_select+0x4c>
    (void) change_ipc_channel(hipc);
 801eeae:	4620      	mov	r0, r4
 801eeb0:	f7ff fd00 	bl	801e8b4 <change_ipc_channel>
}
 801eeb4:	2000      	movs	r0, #0
 801eeb6:	bd38      	pop	{r3, r4, r5, pc}
 801eeb8:	20004bdc 	.word	0x20004bdc
 801eebc:	08035b4c 	.word	0x08035b4c
 801eec0:	200046c4 	.word	0x200046c4

0801eec4 <IPC_UART_get_other_channel>:
{
 801eec4:	b410      	push	{r4}
 801eec6:	4602      	mov	r2, r0
  if ((IPC_DevicesList[hipc->Device_ID].h_current_channel == hipc) &&
 801eec8:	7803      	ldrb	r3, [r0, #0]
 801eeca:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 801eece:	490d      	ldr	r1, [pc, #52]	; (801ef04 <IPC_UART_get_other_channel+0x40>)
 801eed0:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801eed4:	690c      	ldr	r4, [r1, #16]
 801eed6:	4294      	cmp	r4, r2
 801eed8:	d00b      	beq.n	801eef2 <IPC_UART_get_other_channel+0x2e>
  IPC_Handle_t *handle = NULL;
 801eeda:	2000      	movs	r0, #0
  if ((IPC_DevicesList[hipc->Device_ID].h_inactive_channel == hipc) &&
 801eedc:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eee0:	4908      	ldr	r1, [pc, #32]	; (801ef04 <IPC_UART_get_other_channel+0x40>)
 801eee2:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 801eee6:	695b      	ldr	r3, [r3, #20]
 801eee8:	4293      	cmp	r3, r2
 801eeea:	d007      	beq.n	801eefc <IPC_UART_get_other_channel+0x38>
}
 801eeec:	f85d 4b04 	ldr.w	r4, [sp], #4
 801eef0:	4770      	bx	lr
      (IPC_DevicesList[hipc->Device_ID].h_inactive_channel != NULL))
 801eef2:	4904      	ldr	r1, [pc, #16]	; (801ef04 <IPC_UART_get_other_channel+0x40>)
 801eef4:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801eef8:	6948      	ldr	r0, [r1, #20]
 801eefa:	e7ef      	b.n	801eedc <IPC_UART_get_other_channel+0x18>
  if ((IPC_DevicesList[hipc->Device_ID].h_inactive_channel == hipc) &&
 801eefc:	2c00      	cmp	r4, #0
 801eefe:	d0f5      	beq.n	801eeec <IPC_UART_get_other_channel+0x28>
    handle = IPC_DevicesList[hipc->Device_ID].h_current_channel;
 801ef00:	4620      	mov	r0, r4
  return (handle);
 801ef02:	e7f3      	b.n	801eeec <IPC_UART_get_other_channel+0x28>
 801ef04:	200046c4 	.word	0x200046c4

0801ef08 <IPC_UART_send>:
{
 801ef08:	b510      	push	{r4, lr}
  if (hipc != IPC_DevicesList[hipc->Device_ID].h_current_channel)
 801ef0a:	7803      	ldrb	r3, [r0, #0]
 801ef0c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801ef10:	4c06      	ldr	r4, [pc, #24]	; (801ef2c <IPC_UART_send+0x24>)
 801ef12:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 801ef16:	691b      	ldr	r3, [r3, #16]
 801ef18:	4283      	cmp	r3, r0
 801ef1a:	d001      	beq.n	801ef20 <IPC_UART_send+0x18>
    retval = IPC_ERROR;
 801ef1c:	2001      	movs	r0, #1
}
 801ef1e:	bd10      	pop	{r4, pc}
    (void)HAL_UART_Transmit_IT(hipc->Interface.h_uart, (uint8_t *)p_TxBuffer, bufsize);
 801ef20:	6880      	ldr	r0, [r0, #8]
 801ef22:	f7eb f87d 	bl	800a020 <HAL_UART_Transmit_IT>
    retval = IPC_OK;
 801ef26:	2000      	movs	r0, #0
 801ef28:	e7f9      	b.n	801ef1e <IPC_UART_send+0x16>
 801ef2a:	bf00      	nop
 801ef2c:	200046c4 	.word	0x200046c4

0801ef30 <IPC_UART_receive>:
{
 801ef30:	b538      	push	{r3, r4, r5, lr}
  if (hipc->Mode == IPC_MODE_UART_CHARACTER)
 801ef32:	7b03      	ldrb	r3, [r0, #12]
 801ef34:	2b00      	cmp	r3, #0
 801ef36:	d16f      	bne.n	801f018 <IPC_UART_receive+0xe8>
 801ef38:	4604      	mov	r4, r0
    if (p_msg == NULL)
 801ef3a:	b169      	cbz	r1, 801ef58 <IPC_UART_receive+0x28>
      unread_msg = IPC_RXFIFO_read(hipc, p_msg);
 801ef3c:	f7ff fc60 	bl	801e800 <IPC_RXFIFO_read>
 801ef40:	4605      	mov	r5, r0
      if (unread_msg == -1)
 801ef42:	f1b0 3fff 	cmp.w	r0, #4294967295
 801ef46:	d030      	beq.n	801efaa <IPC_UART_receive+0x7a>
        if (hipc->State == IPC_STATE_PAUSED)
 801ef48:	7b63      	ldrb	r3, [r4, #13]
 801ef4a:	2b03      	cmp	r3, #3
 801ef4c:	d055      	beq.n	801effa <IPC_UART_receive+0xca>
        if (unread_msg == 0)
 801ef4e:	2d00      	cmp	r5, #0
 801ef50:	f040 8089 	bne.w	801f066 <IPC_UART_receive+0x136>
          retval = IPC_RXQUEUE_EMPTY;
 801ef54:	2002      	movs	r0, #2
 801ef56:	e085      	b.n	801f064 <IPC_UART_receive+0x134>
      PRINT_ERR("IPC_receive err - p_msg NULL")
 801ef58:	4d44      	ldr	r5, [pc, #272]	; (801f06c <IPC_UART_receive+0x13c>)
 801ef5a:	4c45      	ldr	r4, [pc, #276]	; (801f070 <IPC_UART_receive+0x140>)
 801ef5c:	f105 0e20 	add.w	lr, r5, #32
 801ef60:	46ac      	mov	ip, r5
 801ef62:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801ef66:	6020      	str	r0, [r4, #0]
 801ef68:	6061      	str	r1, [r4, #4]
 801ef6a:	60a2      	str	r2, [r4, #8]
 801ef6c:	60e3      	str	r3, [r4, #12]
 801ef6e:	4665      	mov	r5, ip
 801ef70:	3410      	adds	r4, #16
 801ef72:	45f4      	cmp	ip, lr
 801ef74:	d1f4      	bne.n	801ef60 <IPC_UART_receive+0x30>
 801ef76:	cd03      	ldmia	r5!, {r0, r1}
 801ef78:	6020      	str	r0, [r4, #0]
 801ef7a:	6061      	str	r1, [r4, #4]
 801ef7c:	782b      	ldrb	r3, [r5, #0]
 801ef7e:	7223      	strb	r3, [r4, #8]
 801ef80:	4c3b      	ldr	r4, [pc, #236]	; (801f070 <IPC_UART_receive+0x140>)
 801ef82:	4620      	mov	r0, r4
 801ef84:	f000 f9d1 	bl	801f32a <crs_strlen>
 801ef88:	b283      	uxth	r3, r0
 801ef8a:	4622      	mov	r2, r4
 801ef8c:	2110      	movs	r1, #16
 801ef8e:	2005      	movs	r0, #5
 801ef90:	f000 fa0e 	bl	801f3b0 <traceIF_itmPrint>
 801ef94:	4620      	mov	r0, r4
 801ef96:	f000 f9c8 	bl	801f32a <crs_strlen>
 801ef9a:	b283      	uxth	r3, r0
 801ef9c:	4622      	mov	r2, r4
 801ef9e:	2110      	movs	r1, #16
 801efa0:	2005      	movs	r0, #5
 801efa2:	f000 fa27 	bl	801f3f4 <traceIF_uartPrint>
      retval = IPC_ERROR;
 801efa6:	2001      	movs	r0, #1
 801efa8:	e05c      	b.n	801f064 <IPC_UART_receive+0x134>
        PRINT_ERR("IPC_receive err - no unread msg")
 801efaa:	4d32      	ldr	r5, [pc, #200]	; (801f074 <IPC_UART_receive+0x144>)
 801efac:	4c30      	ldr	r4, [pc, #192]	; (801f070 <IPC_UART_receive+0x140>)
 801efae:	f105 0e20 	add.w	lr, r5, #32
 801efb2:	46ac      	mov	ip, r5
 801efb4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801efb8:	6020      	str	r0, [r4, #0]
 801efba:	6061      	str	r1, [r4, #4]
 801efbc:	60a2      	str	r2, [r4, #8]
 801efbe:	60e3      	str	r3, [r4, #12]
 801efc0:	4665      	mov	r5, ip
 801efc2:	3410      	adds	r4, #16
 801efc4:	45f4      	cmp	ip, lr
 801efc6:	d1f4      	bne.n	801efb2 <IPC_UART_receive+0x82>
 801efc8:	cd07      	ldmia	r5!, {r0, r1, r2}
 801efca:	6020      	str	r0, [r4, #0]
 801efcc:	6061      	str	r1, [r4, #4]
 801efce:	60a2      	str	r2, [r4, #8]
 801efd0:	4c27      	ldr	r4, [pc, #156]	; (801f070 <IPC_UART_receive+0x140>)
 801efd2:	4620      	mov	r0, r4
 801efd4:	f000 f9a9 	bl	801f32a <crs_strlen>
 801efd8:	b283      	uxth	r3, r0
 801efda:	4622      	mov	r2, r4
 801efdc:	2110      	movs	r1, #16
 801efde:	2005      	movs	r0, #5
 801efe0:	f000 f9e6 	bl	801f3b0 <traceIF_itmPrint>
 801efe4:	4620      	mov	r0, r4
 801efe6:	f000 f9a0 	bl	801f32a <crs_strlen>
 801efea:	b283      	uxth	r3, r0
 801efec:	4622      	mov	r2, r4
 801efee:	2110      	movs	r1, #16
 801eff0:	2005      	movs	r0, #5
 801eff2:	f000 f9ff 	bl	801f3f4 <traceIF_uartPrint>
        retval = IPC_ERROR;
 801eff6:	2001      	movs	r0, #1
 801eff8:	e034      	b.n	801f064 <IPC_UART_receive+0x134>
          hipc->State = IPC_STATE_ACTIVE;
 801effa:	2302      	movs	r3, #2
 801effc:	7363      	strb	r3, [r4, #13]
          (void) HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[hipc->Device_ID].RxChar, 1U);
 801effe:	7823      	ldrb	r3, [r4, #0]
 801f000:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 801f004:	00c9      	lsls	r1, r1, #3
 801f006:	3108      	adds	r1, #8
 801f008:	4b1b      	ldr	r3, [pc, #108]	; (801f078 <IPC_UART_receive+0x148>)
 801f00a:	4419      	add	r1, r3
 801f00c:	2201      	movs	r2, #1
 801f00e:	3104      	adds	r1, #4
 801f010:	68a0      	ldr	r0, [r4, #8]
 801f012:	f7eb f83d 	bl	800a090 <HAL_UART_Receive_IT>
 801f016:	e79a      	b.n	801ef4e <IPC_UART_receive+0x1e>
    PRINT_ERR("IPC_receive err - IPC mode not matching")
 801f018:	4d18      	ldr	r5, [pc, #96]	; (801f07c <IPC_UART_receive+0x14c>)
 801f01a:	4c15      	ldr	r4, [pc, #84]	; (801f070 <IPC_UART_receive+0x140>)
 801f01c:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 801f020:	46ac      	mov	ip, r5
 801f022:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 801f026:	6020      	str	r0, [r4, #0]
 801f028:	6061      	str	r1, [r4, #4]
 801f02a:	60a2      	str	r2, [r4, #8]
 801f02c:	60e3      	str	r3, [r4, #12]
 801f02e:	4665      	mov	r5, ip
 801f030:	3410      	adds	r4, #16
 801f032:	45f4      	cmp	ip, lr
 801f034:	d1f4      	bne.n	801f020 <IPC_UART_receive+0xf0>
 801f036:	f8dc 0000 	ldr.w	r0, [ip]
 801f03a:	6020      	str	r0, [r4, #0]
 801f03c:	4c0c      	ldr	r4, [pc, #48]	; (801f070 <IPC_UART_receive+0x140>)
 801f03e:	4620      	mov	r0, r4
 801f040:	f000 f973 	bl	801f32a <crs_strlen>
 801f044:	b283      	uxth	r3, r0
 801f046:	4622      	mov	r2, r4
 801f048:	2110      	movs	r1, #16
 801f04a:	2005      	movs	r0, #5
 801f04c:	f000 f9b0 	bl	801f3b0 <traceIF_itmPrint>
 801f050:	4620      	mov	r0, r4
 801f052:	f000 f96a 	bl	801f32a <crs_strlen>
 801f056:	b283      	uxth	r3, r0
 801f058:	4622      	mov	r2, r4
 801f05a:	2110      	movs	r1, #16
 801f05c:	2005      	movs	r0, #5
 801f05e:	f000 f9c9 	bl	801f3f4 <traceIF_uartPrint>
    retval = IPC_ERROR;
 801f062:	2001      	movs	r0, #1
}
 801f064:	bd38      	pop	{r3, r4, r5, pc}
          retval = IPC_RXQUEUE_MSG_AVAIL;
 801f066:	2003      	movs	r0, #3
 801f068:	e7fc      	b.n	801f064 <IPC_UART_receive+0x134>
 801f06a:	bf00      	nop
 801f06c:	08035b60 	.word	0x08035b60
 801f070:	20004bdc 	.word	0x20004bdc
 801f074:	08035b8c 	.word	0x08035b8c
 801f078:	200046c4 	.word	0x200046c4
 801f07c:	08035bb8 	.word	0x08035bb8

0801f080 <IPC_UART_rearm_RX_IT>:
  if (hipc != NULL)
 801f080:	b188      	cbz	r0, 801f0a6 <IPC_UART_rearm_RX_IT+0x26>
{
 801f082:	b508      	push	{r3, lr}
    if (hipc->Interface.interface_type == IPC_INTERFACE_UART)
 801f084:	7902      	ldrb	r2, [r0, #4]
 801f086:	2a01      	cmp	r2, #1
 801f088:	d000      	beq.n	801f08c <IPC_UART_rearm_RX_IT+0xc>
}
 801f08a:	bd08      	pop	{r3, pc}
      (void)HAL_UART_Receive_IT(hipc->Interface.h_uart, (uint8_t *)IPC_DevicesList[hipc->Device_ID].RxChar, 1U);
 801f08c:	7802      	ldrb	r2, [r0, #0]
 801f08e:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 801f092:	00c9      	lsls	r1, r1, #3
 801f094:	3108      	adds	r1, #8
 801f096:	4a04      	ldr	r2, [pc, #16]	; (801f0a8 <IPC_UART_rearm_RX_IT+0x28>)
 801f098:	4411      	add	r1, r2
 801f09a:	2201      	movs	r2, #1
 801f09c:	3104      	adds	r1, #4
 801f09e:	6880      	ldr	r0, [r0, #8]
 801f0a0:	f7ea fff6 	bl	800a090 <HAL_UART_Receive_IT>
}
 801f0a4:	e7f1      	b.n	801f08a <IPC_UART_rearm_RX_IT+0xa>
 801f0a6:	4770      	bx	lr
 801f0a8:	200046c4 	.word	0x200046c4

0801f0ac <IPC_UART_RxCpltCallback>:
{
 801f0ac:	b510      	push	{r4, lr}
  uint8_t device_id = find_Device_Id(UartHandle);
 801f0ae:	f7ff fbf5 	bl	801e89c <find_Device_Id>
  if (device_id < IPC_MAX_DEVICES)
 801f0b2:	b968      	cbnz	r0, 801f0d0 <IPC_UART_RxCpltCallback+0x24>
    if (IPC_DevicesList[device_id].h_current_channel != NULL)
 801f0b4:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 801f0b8:	4a06      	ldr	r2, [pc, #24]	; (801f0d4 <IPC_UART_RxCpltCallback+0x28>)
 801f0ba:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 801f0be:	6910      	ldr	r0, [r2, #16]
 801f0c0:	b130      	cbz	r0, 801f0d0 <IPC_UART_RxCpltCallback+0x24>
      IPC_DevicesList[device_id].h_current_channel->RxFifoWrite(IPC_DevicesList[device_id].h_current_channel,
 801f0c2:	f8d0 47f4 	ldr.w	r4, [r0, #2036]	; 0x7f4
 801f0c6:	4a03      	ldr	r2, [pc, #12]	; (801f0d4 <IPC_UART_RxCpltCallback+0x28>)
 801f0c8:	eb02 03c1 	add.w	r3, r2, r1, lsl #3
 801f0cc:	7b19      	ldrb	r1, [r3, #12]
 801f0ce:	47a0      	blx	r4
}
 801f0d0:	bd10      	pop	{r4, pc}
 801f0d2:	bf00      	nop
 801f0d4:	200046c4 	.word	0x200046c4

0801f0d8 <IPC_UART_TxCpltCallback>:
{
 801f0d8:	b508      	push	{r3, lr}
  uint8_t device_id = find_Device_Id(UartHandle);
 801f0da:	f7ff fbdf 	bl	801e89c <find_Device_Id>
  if (device_id < IPC_MAX_DEVICES)
 801f0de:	b948      	cbnz	r0, 801f0f4 <IPC_UART_TxCpltCallback+0x1c>
    if (IPC_DevicesList[device_id].h_current_channel != NULL)
 801f0e0:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 801f0e4:	4a04      	ldr	r2, [pc, #16]	; (801f0f8 <IPC_UART_TxCpltCallback+0x20>)
 801f0e6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 801f0ea:	6918      	ldr	r0, [r3, #16]
 801f0ec:	b110      	cbz	r0, 801f0f4 <IPC_UART_TxCpltCallback+0x1c>
      IPC_DevicesList[device_id].h_current_channel->TxClientCallback(
 801f0ee:	f8d0 37ec 	ldr.w	r3, [r0, #2028]	; 0x7ec
 801f0f2:	4798      	blx	r3
}
 801f0f4:	bd08      	pop	{r3, pc}
 801f0f6:	bf00      	nop
 801f0f8:	200046c4 	.word	0x200046c4

0801f0fc <IPC_UART_ErrorCallback>:
}
 801f0fc:	4770      	bx	lr

0801f0fe <rtosalGetSysTimerCount>:
/**
  * @brief  Get the RTOS kernel system timer count.
  * @retval uint32_t - RTOS kernel current system timer count as 32-bit value.
  */
uint32_t rtosalGetSysTimerCount(void)
{
 801f0fe:	b508      	push	{r3, lr}
  uint32_t retval;
#if (osCMSIS < 0x20000U)
  retval = osKernelSysTick();
 801f100:	f005 f843 	bl	802418a <osKernelSysTick>
#else
  retval = osKernelGetSysTimerCount();
#endif /* osCMSIS < 0x20000U */
  return (retval);
}
 801f104:	bd08      	pop	{r3, pc}

0801f106 <rtosalThreadNew>:
  * @param  p_arg      - argument passed to the thread function when it is started.
  * @retval osThreadId - thread ID for reference by other functions or NULL in case of error.
  */
osThreadId rtosalThreadNew(const rtosal_char_t *p_name, os_pthread func, osPriority priority, uint32_t stacksize,
                           void *p_arg)
{
 801f106:	b500      	push	{lr}
 801f108:	b087      	sub	sp, #28
  osThreadId retval;

#if (osCMSIS < 0x20000U)
  /* Thread definition */

  const osThreadDef_t rtosal_thread_def =
 801f10a:	9001      	str	r0, [sp, #4]
 801f10c:	9102      	str	r1, [sp, #8]
 801f10e:	f8ad 200c 	strh.w	r2, [sp, #12]
 801f112:	2200      	movs	r2, #0
 801f114:	9204      	str	r2, [sp, #16]
 801f116:	9305      	str	r3, [sp, #20]
    .tpriority = priority,
    .instances = 0U,
    .stacksize = stacksize /* allocated size : stacksize * sizeof(StackType_t) done by CMSIS */
  };

  retval = osThreadCreate(&rtosal_thread_def, p_arg);
 801f118:	9908      	ldr	r1, [sp, #32]
 801f11a:	a801      	add	r0, sp, #4
 801f11c:	f005 f83f 	bl	802419e <osThreadCreate>

  retval = osThreadNew((osThreadFunc_t)func, p_arg, &rtosal_thread_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801f120:	b007      	add	sp, #28
 801f122:	f85d fb04 	ldr.w	pc, [sp], #4

0801f126 <rtosalSemaphoreNew>:
  * @param  count         - number of available resources.
  * @note   At creation semaphore max count is set to count.
  * @retval osSemaphoreId - semaphore ID for reference by other functions or NULL in case of error.
  */
osSemaphoreId rtosalSemaphoreNew(const rtosal_char_t *p_name, uint32_t count)
{
 801f126:	b500      	push	{lr}
 801f128:	b083      	sub	sp, #12
  osSemaphoreId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  osSemaphoreDef(SEM); /* true name can not be used when (osCMSIS < 0x20000U) */
 801f12a:	2300      	movs	r3, #0
 801f12c:	9301      	str	r3, [sp, #4]
  retval = osSemaphoreCreate(osSemaphore(SEM), (int32_t)count); /* No issue with cast to (int32_t) */
 801f12e:	a801      	add	r0, sp, #4
 801f130:	f005 f932 	bl	8024398 <osSemaphoreCreate>

  retval = osSemaphoreNew(count, count, &rtosal_sem_attr); /* maximum count is set to initial count */
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801f134:	b003      	add	sp, #12
 801f136:	f85d fb04 	ldr.w	pc, [sp], #4

0801f13a <rtosalSemaphoreAcquire>:
  * @note   With CMSIS RTOS V1, this function returns osErrorOS when no token is available.
  *         With CMSIS RTOS V2, this function returns osErrorResource when no token is available.
  *         Conclusion: test (rtosalStatus != osOK) to be independent of osCMSIS version.
  */
rtosalStatus rtosalSemaphoreAcquire(osSemaphoreId semaphore_id, uint32_t timeout)
{
 801f13a:	b508      	push	{r3, lr}
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  /* Due to incompatibility between V1 and V2 return type retval is converted to osStatus
     see V1 API documentation for more details */
  status = (osStatus)osSemaphoreWait(semaphore_id, timeout);
 801f13c:	f005 f943 	bl	80243c6 <osSemaphoreWait>
#else
  status = osSemaphoreAcquire(semaphore_id, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801f140:	bd08      	pop	{r3, pc}

0801f142 <rtosalSemaphoreRelease>:
  * @brief  Release a Semaphore token.
  * @param  semaphore_id - semaphore ID obtained by rtosalSemaphoreNew.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalSemaphoreRelease(osSemaphoreId semaphore_id)
{
 801f142:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osSemaphoreRelease(semaphore_id);
 801f144:	f005 f96e 	bl	8024424 <osSemaphoreRelease>
  return (status);
}
 801f148:	bd08      	pop	{r3, pc}

0801f14a <rtosalMutexNew>:
  * @param  p_name    - mutex name.
  * @note   With CMSIS RTOS V1, name is unused.
  * @retval osMutexId - mutex ID for reference by other functions or NULL in case of error.
  */
osMutexId rtosalMutexNew(const rtosal_char_t *p_name)
{
 801f14a:	b500      	push	{lr}
 801f14c:	b083      	sub	sp, #12
  osMutexId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  osMutexDef(MUTEX); /* true name can not be used when (osCMSIS < 0x20000U) */
 801f14e:	2300      	movs	r3, #0
 801f150:	9301      	str	r3, [sp, #4]
  retval = osMutexCreate(osMutex(MUTEX));
 801f152:	a801      	add	r0, sp, #4
 801f154:	f005 f8be 	bl	80242d4 <osMutexCreate>

  retval = osMutexNew(&rtosal_mutex_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801f158:	b003      	add	sp, #12
 801f15a:	f85d fb04 	ldr.w	pc, [sp], #4

0801f15e <rtosalMutexAcquire>:
  * @note   With CMSIS RTOS V1, this function returns osErrorOS when no mutex is available.
  *         With CMSIS RTOS V2, this function returns osErrorResource when no mutex is available.
  *         Conclusion: test (rtosalStatus != osOK) to be independent of osCMSIS version.
  */
rtosalStatus rtosalMutexAcquire(osMutexId mutex_id, uint32_t timeout)
{
 801f15e:	b508      	push	{r3, lr}
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  status = osMutexWait(mutex_id, timeout);
 801f160:	f005 f8bd 	bl	80242de <osMutexWait>
#else
  status = osMutexAcquire(mutex_id, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801f164:	bd08      	pop	{r3, pc}

0801f166 <rtosalMutexRelease>:
  * @brief  Release a Mutex that was acquired by rtosalMutexAcquire.
  * @param  mutex_id     - mutex ID obtained by rtosalMutexNew.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalMutexRelease(osMutexId mutex_id)
{
 801f166:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osMutexRelease(mutex_id);
 801f168:	f005 f8e9 	bl	802433e <osMutexRelease>
  return (status);
}
 801f16c:	bd08      	pop	{r3, pc}

0801f16e <rtosalMessageQueueNew>:
  * @note   With CMSIS RTOS V1, name is unused.
  * @param  queue_size   - maximum number of messages in queue.
  * @retval osMessageQId - message queue ID for reference by other functions or NULL in case of error.
  */
osMessageQId rtosalMessageQueueNew(const rtosal_char_t *p_name, uint32_t queue_size)
{
 801f16e:	b500      	push	{lr}
 801f170:	b083      	sub	sp, #12
  osMessageQId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  const osMessageQDef_t rtosal_queue_def =
 801f172:	9100      	str	r1, [sp, #0]
 801f174:	2304      	movs	r3, #4
 801f176:	9301      	str	r3, [sp, #4]
  {
    .queue_sz = queue_size,
    .item_sz = sizeof(uint32_t) /* This implementation supports 32-bit sized messages only */
  };

  retval = osMessageCreate(&rtosal_queue_def, NULL);
 801f178:	2100      	movs	r1, #0
 801f17a:	4668      	mov	r0, sp
 801f17c:	f005 f97f 	bl	802447e <osMessageCreate>
  /* This implementation supports 32-bit sized messages only */
  retval = osMessageQueueNew(queue_size, sizeof(uint32_t), &rtosal_message_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801f180:	b003      	add	sp, #12
 801f182:	f85d fb04 	ldr.w	pc, [sp], #4

0801f186 <rtosalMessageQueuePut>:
  * @note   With CMSIS RTOS V1, this function returns osErrorOS if the queue is full.
  *         With CMSIS RTOS V2, this function returns osErrorResource if the queue is fulle.
  *         Conclusion: test (rtosalStatus != osOK) to be independent of osCMSIS version.
  */
rtosalStatus rtosalMessageQueuePut(osMessageQId mq_id, uint32_t msg, uint32_t timeout)
{
 801f186:	b508      	push	{r3, lr}
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  status = osMessagePut(mq_id, msg, timeout);
 801f188:	f005 f980 	bl	802448c <osMessagePut>
  /* Message priority always set to same priority : 0 */
  status = osMessageQueuePut(mq_id, (const void *)&msg, 0U, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801f18c:	bd08      	pop	{r3, pc}

0801f18e <rtosalMessageQueueGet>:
  rtosalStatus status;

#if (osCMSIS < 0x20000U)
  osEvent event;

  if (p_msg == NULL)  /* Check parameter */
 801f18e:	b171      	cbz	r1, 801f1ae <rtosalMessageQueueGet+0x20>
{
 801f190:	b510      	push	{r4, lr}
 801f192:	b084      	sub	sp, #16
 801f194:	460c      	mov	r4, r1
  {
    status = osErrorParameter;
  }
  else
  {
    event = osMessageGet(mq_id, timeout);
 801f196:	4601      	mov	r1, r0
 801f198:	a801      	add	r0, sp, #4
 801f19a:	f005 f9aa 	bl	80244f2 <osMessageGet>

    /* Retrieve the status from the returned structure */
    status = event.status;
 801f19e:	9801      	ldr	r0, [sp, #4]
    /* if a msg has been received then store it in user buffer */
    if (status == osEventMessage)
 801f1a0:	2810      	cmp	r0, #16
 801f1a2:	d001      	beq.n	801f1a8 <rtosalMessageQueueGet+0x1a>
  /* msg_prio is not managed, so set to NULL */
  status = osMessageQueueGet(mq_id, p_msg, NULL, timeout);
#endif /* osCMSIS < 0x20000U */

  return (status);
}
 801f1a4:	b004      	add	sp, #16
 801f1a6:	bd10      	pop	{r4, pc}
      *p_msg = event.value.v;
 801f1a8:	9b02      	ldr	r3, [sp, #8]
 801f1aa:	6023      	str	r3, [r4, #0]
 801f1ac:	e7fa      	b.n	801f1a4 <rtosalMessageQueueGet+0x16>
    status = osErrorParameter;
 801f1ae:	2080      	movs	r0, #128	; 0x80
}
 801f1b0:	4770      	bx	lr

0801f1b2 <rtosalTimerNew>:
  * @param   type     - osTimerOnce for one-shot or osTimerPeriodic for periodic behavior
  * @param   p_arg    - argument passed to the timer callback function when it is called.
  * @retval osTimerId - timer ID for reference by other functions or NULL in case of error.
  */
osTimerId rtosalTimerNew(const rtosal_char_t *p_name, os_ptimer func, os_timer_type type, void *p_arg)
{
 801f1b2:	b500      	push	{lr}
 801f1b4:	b083      	sub	sp, #12
 801f1b6:	4608      	mov	r0, r1
 801f1b8:	4611      	mov	r1, r2
  osTimerId retval;

#if (osCMSIS < 0x20000U)
  (void)(p_name); /* To avoid gcc/g++ warnings */
  osTimerDef(TIM, func); /* true name can not be used when (osCMSIS < 0x20000U) */
 801f1ba:	9001      	str	r0, [sp, #4]
  retval = osTimerCreate(osTimer(TIM), type, p_arg);
 801f1bc:	461a      	mov	r2, r3
 801f1be:	a801      	add	r0, sp, #4
 801f1c0:	f005 f80e 	bl	80241e0 <osTimerCreate>

  retval = osTimerNew((osTimerFunc_t)func, (osTimerType_t)type, p_arg, &rtosal_timer_attr);
#endif /* osCMSIS < 0x20000U */

  return (retval);
}
 801f1c4:	b003      	add	sp, #12
 801f1c6:	f85d fb04 	ldr.w	pc, [sp], #4

0801f1ca <rtosalTimerStart>:
  * @param  timer_id     - timer ID obtained by rtosalTimerNew.
  * @param  ticks        - "time ticks" value of the timer.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalTimerStart(osTimerId timer_id, uint32_t ticks)
{
 801f1ca:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osTimerStart(timer_id, ticks);
 801f1cc:	f005 f81c 	bl	8024208 <osTimerStart>
  return (status);
}
 801f1d0:	bd08      	pop	{r3, pc}

0801f1d2 <rtosalTimerStop>:
  * @retval rtosalStatus - indicate the execution status of the function.
  * @note   With CMSIS RTOS V1, this function returns osOK if the timer is not started.
  *         With CMSIS RTOS V2, this function returns osErrorResource if the timer is not started.
  */
rtosalStatus rtosalTimerStop(osTimerId timer_id)
{
 801f1d2:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osTimerStop(timer_id);
 801f1d4:	f005 f84d 	bl	8024272 <osTimerStop>
  return (status);
}
 801f1d8:	bd08      	pop	{r3, pc}

0801f1da <rtosalDelay>:
  * @brief Wait for Timeout (Time Delay).
  * @param ticks         - "time ticks" value.
  * @retval rtosalStatus - indicate the execution status of the function.
  */
rtosalStatus rtosalDelay(uint32_t ticks)
{
 801f1da:	b508      	push	{r3, lr}
  rtosalStatus status;
  status = osDelay(ticks);
 801f1dc:	f004 fff9 	bl	80241d2 <osDelay>
  return (status);
}
 801f1e0:	bd08      	pop	{r3, pc}

0801f1e2 <crc_get_ip_addr>:
  * @param  port      (out) optional ip port
  * @note             if no port is needed put this parameter to NULL
  * @retval validity of conversion: retval==0 conversion OK /   retval!=0 conversion KO
  */
uint32_t crc_get_ip_addr(uint8_t *string, uint8_t *addr, uint16_t *port)
{
 801f1e2:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801f1e6:	4606      	mov	r6, r0
 801f1e8:	4689      	mov	r9, r1
 801f1ea:	4693      	mov	fp, r2
  bool leave;

  ret    = 0U;
  offset = 0;

  leave = false;
 801f1ec:	f04f 0800 	mov.w	r8, #0
  offset = 0;
 801f1f0:	4647      	mov	r7, r8
  ret    = 0U;
 801f1f2:	46c2      	mov	sl, r8

  /* parse the 4 byte of the IP addr */
  for (i = 0U ; (i < 4U) && (leave == false) ; i++)
 801f1f4:	4645      	mov	r5, r8
 801f1f6:	e011      	b.n	801f21c <crc_get_ip_addr+0x3a>
  {
    /* parse the digits (max 3) of the IP addr */
    for (j = 0U ; j <= CRC_IP_ADDR_DIGIT_SIZE ; j++)
 801f1f8:	3401      	adds	r4, #1
 801f1fa:	b2e4      	uxtb	r4, r4
 801f1fc:	2c03      	cmp	r4, #3
 801f1fe:	d805      	bhi.n	801f20c <crc_get_ip_addr+0x2a>
    {
      if ((string[j + offset] < (uint8_t)'0') || (string[j + offset] > (uint8_t)'9'))
 801f200:	19e3      	adds	r3, r4, r7
 801f202:	5cf3      	ldrb	r3, [r6, r3]
 801f204:	3b30      	subs	r3, #48	; 0x30
 801f206:	b2db      	uxtb	r3, r3
 801f208:	2b09      	cmp	r3, #9
 801f20a:	d9f5      	bls.n	801f1f8 <crc_get_ip_addr+0x16>
        /* not a decimal digit => end of  addr byte */
        break;
      }
    }

    if ((j == (CRC_IP_ADDR_DIGIT_SIZE + 1U)) || (j == 0U))
 801f20c:	2c04      	cmp	r4, #4
 801f20e:	d019      	beq.n	801f244 <crc_get_ip_addr+0x62>
 801f210:	b95c      	cbnz	r4, 801f22a <crc_get_ip_addr+0x48>
    {
      /* not a correct addr byte found => return error */
      ret = 1;
      leave = true;
 801f212:	f04f 0801 	mov.w	r8, #1
      ret = 1;
 801f216:	46c2      	mov	sl, r8
  for (i = 0U ; (i < 4U) && (leave == false) ; i++)
 801f218:	3501      	adds	r5, #1
 801f21a:	b2ed      	uxtb	r5, r5
 801f21c:	2d03      	cmp	r5, #3
 801f21e:	d815      	bhi.n	801f24c <crc_get_ip_addr+0x6a>
 801f220:	f1b8 0f00 	cmp.w	r8, #0
 801f224:	d112      	bne.n	801f24c <crc_get_ip_addr+0x6a>
    for (j = 0U ; j <= CRC_IP_ADDR_DIGIT_SIZE ; j++)
 801f226:	2400      	movs	r4, #0
 801f228:	e7e8      	b.n	801f1fc <crc_get_ip_addr+0x1a>
    }
    else
    {
      /* correct addr byte found: convert it ito integer */
      addr[i] = (uint8_t)crs_atoi(&string[offset]);
 801f22a:	19f0      	adds	r0, r6, r7
 801f22c:	f000 f838 	bl	801f2a0 <crs_atoi>
 801f230:	f809 0005 	strb.w	r0, [r9, r5]
      if (string[offset + j] != (uint8_t)'.')
 801f234:	443c      	add	r4, r7
 801f236:	5d33      	ldrb	r3, [r6, r4]
 801f238:	2b2e      	cmp	r3, #46	; 0x2e
 801f23a:	d001      	beq.n	801f240 <crc_get_ip_addr+0x5e>
      {
        /* not the byte separator => end of parsing */
        leave = true;
 801f23c:	f04f 0801 	mov.w	r8, #1
      }
      offset = offset + j + 1U;
 801f240:	1c67      	adds	r7, r4, #1
 801f242:	e7e9      	b.n	801f218 <crc_get_ip_addr+0x36>
      leave = true;
 801f244:	f04f 0801 	mov.w	r8, #1
      ret = 1;
 801f248:	46c2      	mov	sl, r8
 801f24a:	e7e5      	b.n	801f218 <crc_get_ip_addr+0x36>
    }
  }

  if (i != 4U)
 801f24c:	2d04      	cmp	r5, #4
 801f24e:	d012      	beq.n	801f276 <crc_get_ip_addr+0x94>
  {
    /* number of arrd bytes != 4 => not an ip addr */
    ret = 1;
 801f250:	f04f 0a01 	mov.w	sl, #1
  }

  if (ret == 1U)
  {
    /* conversion fail => set returned ip addr to 0  */
    addr[0] = 0U;
 801f254:	2300      	movs	r3, #0
 801f256:	f889 3000 	strb.w	r3, [r9]
    addr[1] = 0U;
 801f25a:	f889 3001 	strb.w	r3, [r9, #1]
    addr[2] = 0U;
 801f25e:	f889 3002 	strb.w	r3, [r9, #2]
    addr[3] = 0U;
 801f262:	f889 3003 	strb.w	r3, [r9, #3]
    if (port != NULL)
 801f266:	f1bb 0f00 	cmp.w	fp, #0
 801f26a:	d001      	beq.n	801f270 <crc_get_ip_addr+0x8e>
    {
      /* set returned port number to 0  */
      *port = 0;
 801f26c:	f8ab 3000 	strh.w	r3, [fp]
    }
  }
  return ret;
}
 801f270:	4650      	mov	r0, sl
 801f272:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (port != NULL)
 801f276:	f1bb 0f00 	cmp.w	fp, #0
 801f27a:	d007      	beq.n	801f28c <crc_get_ip_addr+0xaa>
      if (string[offset - 1U] == (uint8_t)':')
 801f27c:	19f3      	adds	r3, r6, r7
 801f27e:	f813 3c01 	ldrb.w	r3, [r3, #-1]
 801f282:	2b3a      	cmp	r3, #58	; 0x3a
 801f284:	d006      	beq.n	801f294 <crc_get_ip_addr+0xb2>
        *port = 0;
 801f286:	2300      	movs	r3, #0
 801f288:	f8ab 3000 	strh.w	r3, [fp]
  if (ret == 1U)
 801f28c:	f1ba 0f00 	cmp.w	sl, #0
 801f290:	d0ee      	beq.n	801f270 <crc_get_ip_addr+0x8e>
 801f292:	e7df      	b.n	801f254 <crc_get_ip_addr+0x72>
        *port = (uint16_t)crs_atoi(&string[offset]);
 801f294:	19f0      	adds	r0, r6, r7
 801f296:	f000 f803 	bl	801f2a0 <crs_atoi>
 801f29a:	f8ab 0000 	strh.w	r0, [fp]
 801f29e:	e7f5      	b.n	801f28c <crc_get_ip_addr+0xaa>

0801f2a0 <crs_atoi>:
  * @brief  convert a ascci number to an integer
  * @param  string  ascii string number to convert
  * @retval result of conversion
  */
int32_t crs_atoi(const uint8_t *string)
{
 801f2a0:	b410      	push	{r4}
 801f2a2:	4684      	mov	ip, r0
  bool  leave;

  result = 0;
  offset = 0U;

  if (*string == (uint8_t)'-')
 801f2a4:	7803      	ldrb	r3, [r0, #0]
 801f2a6:	2b2d      	cmp	r3, #45	; 0x2d
 801f2a8:	d006      	beq.n	801f2b8 <crs_atoi+0x18>
  }
  else
  {
    /* positive number */
    sign = 0;
    if (string[offset] == (uint8_t)'+')
 801f2aa:	2b2b      	cmp	r3, #43	; 0x2b
 801f2ac:	d007      	beq.n	801f2be <crs_atoi+0x1e>
    sign = 0;
 801f2ae:	2400      	movs	r4, #0
  offset = 0U;
 801f2b0:	4622      	mov	r2, r4
    {
      offset++;
    }
  }

  leave = false;
 801f2b2:	2100      	movs	r1, #0
  result = 0;
 801f2b4:	4608      	mov	r0, r1

  /* partsing string while decimal digit are found */
  while (leave == false)
 801f2b6:	e006      	b.n	801f2c6 <crs_atoi+0x26>
    sign = 1;
 801f2b8:	2401      	movs	r4, #1
    offset++;
 801f2ba:	4622      	mov	r2, r4
 801f2bc:	e7f9      	b.n	801f2b2 <crs_atoi+0x12>
    sign = 0;
 801f2be:	2400      	movs	r4, #0
      offset++;
 801f2c0:	2201      	movs	r2, #1
 801f2c2:	e7f6      	b.n	801f2b2 <crs_atoi+0x12>
  {
    if ((string[offset] < (uint8_t)'0') || (string[offset] > (uint8_t)'9'))
    {
      /* not a digit => end of parsing */
      leave = true;
 801f2c4:	2101      	movs	r1, #1
  while (leave == false)
 801f2c6:	b959      	cbnz	r1, 801f2e0 <crs_atoi+0x40>
    if ((string[offset] < (uint8_t)'0') || (string[offset] > (uint8_t)'9'))
 801f2c8:	f81c 3002 	ldrb.w	r3, [ip, r2]
 801f2cc:	3b30      	subs	r3, #48	; 0x30
 801f2ce:	b2db      	uxtb	r3, r3
 801f2d0:	2b09      	cmp	r3, #9
 801f2d2:	d8f7      	bhi.n	801f2c4 <crs_atoi+0x24>
    else
    {
      /* digit found => adding it in the integer result */
      digit8 = string[offset] - (uint8_t)'0';
      digit  = (int32_t)digit8;
      result = (10 * result) + digit;
 801f2d4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 801f2d8:	eb03 0040 	add.w	r0, r3, r0, lsl #1
      offset++;
 801f2dc:	3201      	adds	r2, #1
 801f2de:	e7f2      	b.n	801f2c6 <crs_atoi+0x26>
    }
  }

  if (sign != 0)
 801f2e0:	b104      	cbz	r4, 801f2e4 <crs_atoi+0x44>
  {
    /* negative number => set the opposite */
    result = -result;
 801f2e2:	4240      	negs	r0, r0
  }
  return result;
}
 801f2e4:	f85d 4b04 	ldr.w	r4, [sp], #4
 801f2e8:	4770      	bx	lr

0801f2ea <crs_atoi_hex>:
  uint32_t offset;

  result = 0;
  offset = 0;

  if (string != NULL)
 801f2ea:	4684      	mov	ip, r0
 801f2ec:	b1d8      	cbz	r0, 801f326 <crs_atoi_hex+0x3c>
  offset = 0;
 801f2ee:	2100      	movs	r1, #0
  result = 0;
 801f2f0:	4608      	mov	r0, r1
 801f2f2:	e009      	b.n	801f308 <crs_atoi_hex+0x1e>
      {
        /* hexa decimal digit found */
        digit8 = string[offset] - (uint8_t)'a' + 10U;
        digit  = (uint32_t)digit8;
      }
      else if ((string[offset] >= (uint8_t)'A') && (string[offset] <= (uint8_t)'F'))
 801f2f4:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
 801f2f8:	b2db      	uxtb	r3, r3
 801f2fa:	2b05      	cmp	r3, #5
 801f2fc:	d814      	bhi.n	801f328 <crs_atoi_hex+0x3e>
      {
        /* hexa decimal digit found */
        digit8 =  string[offset] - (uint8_t)'A' + 10U;
 801f2fe:	3a37      	subs	r2, #55	; 0x37
 801f300:	b2d3      	uxtb	r3, r2
        /* not a digit => end of number */
        break;
      }

      /*  adding the current digit in the integer result */
      result = (16 * result) + (int32_t)digit;
 801f302:	eb03 1000 	add.w	r0, r3, r0, lsl #4
      offset++;
 801f306:	3101      	adds	r1, #1
      if ((string[offset] >= (uint8_t)'0') && (string[offset] <= (uint8_t)'9'))
 801f308:	f81c 2001 	ldrb.w	r2, [ip, r1]
 801f30c:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 801f310:	b2db      	uxtb	r3, r3
 801f312:	2b09      	cmp	r3, #9
 801f314:	d9f5      	bls.n	801f302 <crs_atoi_hex+0x18>
      else if ((string[offset] >= (uint8_t)'a') && (string[offset] <= (uint8_t)'f'))
 801f316:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
 801f31a:	b2db      	uxtb	r3, r3
 801f31c:	2b05      	cmp	r3, #5
 801f31e:	d8e9      	bhi.n	801f2f4 <crs_atoi_hex+0xa>
        digit8 = string[offset] - (uint8_t)'a' + 10U;
 801f320:	3a57      	subs	r2, #87	; 0x57
 801f322:	b2d3      	uxtb	r3, r2
        digit  = (uint32_t)digit8;
 801f324:	e7ed      	b.n	801f302 <crs_atoi_hex+0x18>
  result = 0;
 801f326:	2000      	movs	r0, #0
    }
  }
  return result;
}
 801f328:	4770      	bx	lr

0801f32a <crs_strlen>:
{
  uint32_t i;
  uint32_t res;
  res = 0;

  if (string != NULL)
 801f32a:	4602      	mov	r2, r0
 801f32c:	b138      	cbz	r0, 801f33e <crs_strlen+0x14>
  {
    /* parsing string looking for '0' char */
    for (i = 0U ; i < CRS_STRLEN_MAX ; i++)
 801f32e:	2000      	movs	r0, #0
 801f330:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 801f334:	d204      	bcs.n	801f340 <crs_strlen+0x16>
    {
      if (string[i] == 0U)
 801f336:	5c13      	ldrb	r3, [r2, r0]
 801f338:	b11b      	cbz	r3, 801f342 <crs_strlen+0x18>
    for (i = 0U ; i < CRS_STRLEN_MAX ; i++)
 801f33a:	3001      	adds	r0, #1
 801f33c:	e7f8      	b.n	801f330 <crs_strlen+0x6>
 801f33e:	4770      	bx	lr
  res = 0;
 801f340:	2000      	movs	r0, #0
        break;
      }
    }
  }
  return res;
}
 801f342:	4770      	bx	lr

0801f344 <ITM_Out>:
  * @retval -
  */
static void ITM_Out(uint32_t port, uint32_t ch)
{
  /* Check port validity (0-31)*/
  if (port <= 31U)
 801f344:	281f      	cmp	r0, #31
 801f346:	d819      	bhi.n	801f37c <ITM_Out+0x38>
  {
    uint32_t tmp_mask;
    tmp_mask = (ITM->TER & (1UL << port));
 801f348:	f04f 4c60 	mov.w	ip, #3758096384	; 0xe0000000
 801f34c:	f8dc 2e00 	ldr.w	r2, [ip, #3584]	; 0xe00
 801f350:	2301      	movs	r3, #1
 801f352:	4083      	lsls	r3, r0
 801f354:	401a      	ands	r2, r3
    if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&   /* ITM enabled ? */
 801f356:	f8dc 3e80 	ldr.w	r3, [ip, #3712]	; 0xe80
 801f35a:	f013 0f01 	tst.w	r3, #1
 801f35e:	d00d      	beq.n	801f37c <ITM_Out+0x38>
 801f360:	b90a      	cbnz	r2, 801f366 <ITM_Out+0x22>
 801f362:	4770      	bx	lr
    {
      /* Wait until ITM port is ready */
      while (ITM->PORT[port].u32 == 0UL)
      {
        /* Nothing to do except continue to wait */
        __NOP();
 801f364:	bf00      	nop
      while (ITM->PORT[port].u32 == 0UL)
 801f366:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 801f36a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 801f36e:	2b00      	cmp	r3, #0
 801f370:	d0f8      	beq.n	801f364 <ITM_Out+0x20>
      }

      /* ITM port is ready, send data, one byte at a time */
      ITM->PORT[port].u8 = (uint8_t) ch;
 801f372:	b2c9      	uxtb	r1, r1
 801f374:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
 801f378:	f803 1020 	strb.w	r1, [r3, r0, lsl #2]
    }
  }
}
 801f37c:	4770      	bx	lr
	...

0801f380 <traceIF_uartTransmit>:
  * @param  ptr - pointer on the trace string
  * @param  len - length of the trace string
  * @retval -
  */
static void traceIF_uartTransmit(uint8_t *ptr, uint16_t len)
{
 801f380:	b570      	push	{r4, r5, r6, lr}
 801f382:	4604      	mov	r4, r0
 801f384:	460d      	mov	r5, r1
#if (RTOS_USED == 1)
  /* Mutex is used to avoid trace mixing between components */
  (void)rtosalMutexAcquire(traceIF_uart_mutex, RTOSAL_WAIT_FOREVER);
 801f386:	4e08      	ldr	r6, [pc, #32]	; (801f3a8 <traceIF_uartTransmit+0x28>)
 801f388:	f04f 31ff 	mov.w	r1, #4294967295
 801f38c:	6830      	ldr	r0, [r6, #0]
 801f38e:	f7ff fee6 	bl	801f15e <rtosalMutexAcquire>
#endif /* (RTOS_USED == 1) */

  /* Send the trace */
  (void)HAL_UART_Transmit(&TRACE_INTERFACE_UART_HANDLE, (uint8_t *)ptr, len, HAL_MAX_DELAY);
 801f392:	f04f 33ff 	mov.w	r3, #4294967295
 801f396:	462a      	mov	r2, r5
 801f398:	4621      	mov	r1, r4
 801f39a:	4804      	ldr	r0, [pc, #16]	; (801f3ac <traceIF_uartTransmit+0x2c>)
 801f39c:	f7eb fa84 	bl	800a8a8 <HAL_UART_Transmit>

#if (RTOS_USED == 1)
  (void)rtosalMutexRelease(traceIF_uart_mutex);
 801f3a0:	6830      	ldr	r0, [r6, #0]
 801f3a2:	f7ff fee0 	bl	801f166 <rtosalMutexRelease>
#endif /* (RTOS_USED == 1) */
}
 801f3a6:	bd70      	pop	{r4, r5, r6, pc}
 801f3a8:	200054dc 	.word	0x200054dc
 801f3ac:	20000c04 	.word	0x20000c04

0801f3b0 <traceIF_itmPrint>:
  * @param  pptr - pointer on the trace
  * @param  len - length of the trace
  * @retval -
  */
void traceIF_itmPrint(uint8_t port, uint8_t lvl, uint8_t *pptr, uint16_t len)
{
 801f3b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f3b2:	461f      	mov	r7, r3
  /* Is trace enable ? */
  if (traceIF_traceEnable == true)
 801f3b4:	4b0c      	ldr	r3, [pc, #48]	; (801f3e8 <traceIF_itmPrint+0x38>)
 801f3b6:	781b      	ldrb	r3, [r3, #0]
 801f3b8:	b143      	cbz	r3, 801f3cc <traceIF_itmPrint+0x1c>
 801f3ba:	4606      	mov	r6, r0
 801f3bc:	4615      	mov	r5, r2
  {
    /* Is this level of trace activated ? */
    if ((traceIF_Level & lvl) != 0U)
 801f3be:	4b0b      	ldr	r3, [pc, #44]	; (801f3ec <traceIF_itmPrint+0x3c>)
 801f3c0:	681b      	ldr	r3, [r3, #0]
 801f3c2:	4219      	tst	r1, r3
 801f3c4:	d002      	beq.n	801f3cc <traceIF_itmPrint+0x1c>
    {
      /* Is the trace for this component activated ? */
      if (traceIF_traceComponent[port] != 0U)
 801f3c6:	4b0a      	ldr	r3, [pc, #40]	; (801f3f0 <traceIF_itmPrint+0x40>)
 801f3c8:	5c1b      	ldrb	r3, [r3, r0]
 801f3ca:	b953      	cbnz	r3, 801f3e2 <traceIF_itmPrint+0x32>
          ptr++;
        }
      }
    }
  }
}
 801f3cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          ITM_Out((uint32_t) port, (uint32_t) *ptr);
 801f3ce:	f815 1b01 	ldrb.w	r1, [r5], #1
 801f3d2:	4630      	mov	r0, r6
 801f3d4:	f7ff ffb6 	bl	801f344 <ITM_Out>
        for (uint16_t i = 0U; i < len; i++)
 801f3d8:	3401      	adds	r4, #1
 801f3da:	b2a4      	uxth	r4, r4
 801f3dc:	42bc      	cmp	r4, r7
 801f3de:	d3f6      	bcc.n	801f3ce <traceIF_itmPrint+0x1e>
 801f3e0:	e7f4      	b.n	801f3cc <traceIF_itmPrint+0x1c>
 801f3e2:	2400      	movs	r4, #0
 801f3e4:	e7fa      	b.n	801f3dc <traceIF_itmPrint+0x2c>
 801f3e6:	bf00      	nop
 801f3e8:	2000022e 	.word	0x2000022e
 801f3ec:	2000021c 	.word	0x2000021c
 801f3f0:	20000220 	.word	0x20000220

0801f3f4 <traceIF_uartPrint>:
  * @param  pptr - pointer on the trace
  * @param  len - length of the trace
  * @retval -
  */
void traceIF_uartPrint(uint8_t port, uint8_t lvl, uint8_t *pptr, uint16_t len)
{
 801f3f4:	b510      	push	{r4, lr}
  /* Is trace enable ? */
  if (traceIF_traceEnable == true)
 801f3f6:	4c08      	ldr	r4, [pc, #32]	; (801f418 <traceIF_uartPrint+0x24>)
 801f3f8:	7824      	ldrb	r4, [r4, #0]
 801f3fa:	b134      	cbz	r4, 801f40a <traceIF_uartPrint+0x16>
  {
    /* Is this level of trace activated ? */
    if ((traceIF_Level & lvl) != 0U)
 801f3fc:	4c07      	ldr	r4, [pc, #28]	; (801f41c <traceIF_uartPrint+0x28>)
 801f3fe:	6824      	ldr	r4, [r4, #0]
 801f400:	4221      	tst	r1, r4
 801f402:	d002      	beq.n	801f40a <traceIF_uartPrint+0x16>
    {
      /* Is the trace for this component activated ? */
      if (traceIF_traceComponent[port] != 0U)
 801f404:	4906      	ldr	r1, [pc, #24]	; (801f420 <traceIF_uartPrint+0x2c>)
 801f406:	5c09      	ldrb	r1, [r1, r0]
 801f408:	b901      	cbnz	r1, 801f40c <traceIF_uartPrint+0x18>
        /* Print bytes of the trace  */
        traceIF_uartTransmit(ptr, len);
      }
    }
  }
}
 801f40a:	bd10      	pop	{r4, pc}
        traceIF_uartTransmit(ptr, len);
 801f40c:	4619      	mov	r1, r3
 801f40e:	4610      	mov	r0, r2
 801f410:	f7ff ffb6 	bl	801f380 <traceIF_uartTransmit>
}
 801f414:	e7f9      	b.n	801f40a <traceIF_uartPrint+0x16>
 801f416:	bf00      	nop
 801f418:	2000022e 	.word	0x2000022e
 801f41c:	2000021c 	.word	0x2000021c
 801f420:	20000220 	.word	0x20000220

0801f424 <traceIF_uartPrintForce>:
  * @param  pptr - pointer on the trace
  * @param  len - length of the trace
  * @retval -
  */
void traceIF_uartPrintForce(uint8_t port, uint8_t *pptr, uint16_t len)
{
 801f424:	b508      	push	{r3, lr}
 801f426:	4608      	mov	r0, r1

  uint8_t *ptr;
  ptr = pptr;

  /* Print bytes of the trace */
  traceIF_uartTransmit(ptr, len);
 801f428:	4611      	mov	r1, r2
 801f42a:	f7ff ffa9 	bl	801f380 <traceIF_uartTransmit>
}
 801f42e:	bd08      	pop	{r3, pc}

0801f430 <CMD_ComponentEnableDisable>:
{
 801f430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801f432:	4606      	mov	r6, r0
 801f434:	460d      	mov	r5, r1
  if (strncmp((CRC_CHAR_t *)component,
 801f436:	f7e0 fedd 	bl	80001f4 <strlen>
 801f43a:	4607      	mov	r7, r0
 801f43c:	4602      	mov	r2, r0
 801f43e:	491c      	ldr	r1, [pc, #112]	; (801f4b0 <CMD_ComponentEnableDisable+0x80>)
 801f440:	4630      	mov	r0, r6
 801f442:	f007 fa7c 	bl	802693e <strncmp>
 801f446:	b1a0      	cbz	r0, 801f472 <CMD_ComponentEnableDisable+0x42>
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f448:	2400      	movs	r4, #0
 801f44a:	2c0d      	cmp	r4, #13
 801f44c:	d813      	bhi.n	801f476 <CMD_ComponentEnableDisable+0x46>
      if (strncmp((CRC_CHAR_t *)component,
 801f44e:	463a      	mov	r2, r7
 801f450:	4b18      	ldr	r3, [pc, #96]	; (801f4b4 <CMD_ComponentEnableDisable+0x84>)
 801f452:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 801f456:	4630      	mov	r0, r6
 801f458:	f007 fa71 	bl	802693e <strncmp>
 801f45c:	b158      	cbz	r0, 801f476 <CMD_ComponentEnableDisable+0x46>
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f45e:	3401      	adds	r4, #1
 801f460:	b2e4      	uxtb	r4, r4
 801f462:	e7f2      	b.n	801f44a <CMD_ComponentEnableDisable+0x1a>
      traceIF_traceComponent[i] = enable;
 801f464:	4a14      	ldr	r2, [pc, #80]	; (801f4b8 <CMD_ComponentEnableDisable+0x88>)
 801f466:	54d5      	strb	r5, [r2, r3]
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f468:	3301      	adds	r3, #1
 801f46a:	b2db      	uxtb	r3, r3
 801f46c:	2b0d      	cmp	r3, #13
 801f46e:	d9f9      	bls.n	801f464 <CMD_ComponentEnableDisable+0x34>
}
 801f470:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    for (i = 0U; i < (uint8_t)DBG_CHAN_MAX_VALUE ; i++)
 801f472:	2300      	movs	r3, #0
 801f474:	e7fa      	b.n	801f46c <CMD_ComponentEnableDisable+0x3c>
    if (i >= (uint8_t)DBG_CHAN_MAX_VALUE)
 801f476:	2c0d      	cmp	r4, #13
 801f478:	d802      	bhi.n	801f480 <CMD_ComponentEnableDisable+0x50>
      traceIF_traceComponent[i] = enable;
 801f47a:	4b0f      	ldr	r3, [pc, #60]	; (801f4b8 <CMD_ComponentEnableDisable+0x88>)
 801f47c:	551d      	strb	r5, [r3, r4]
}
 801f47e:	e7f7      	b.n	801f470 <CMD_ComponentEnableDisable+0x40>
      PRINT_FORCE("invalid canal name %s\r\n", component);
 801f480:	4c0e      	ldr	r4, [pc, #56]	; (801f4bc <CMD_ComponentEnableDisable+0x8c>)
 801f482:	4632      	mov	r2, r6
 801f484:	490e      	ldr	r1, [pc, #56]	; (801f4c0 <CMD_ComponentEnableDisable+0x90>)
 801f486:	4620      	mov	r0, r4
 801f488:	f007 f9de 	bl	8026848 <sprintf>
 801f48c:	4620      	mov	r0, r4
 801f48e:	f7ff ff4c 	bl	801f32a <crs_strlen>
 801f492:	b283      	uxth	r3, r0
 801f494:	4622      	mov	r2, r4
 801f496:	2101      	movs	r1, #1
 801f498:	200a      	movs	r0, #10
 801f49a:	f7ff ff89 	bl	801f3b0 <traceIF_itmPrint>
 801f49e:	4620      	mov	r0, r4
 801f4a0:	f7ff ff43 	bl	801f32a <crs_strlen>
 801f4a4:	b282      	uxth	r2, r0
 801f4a6:	4621      	mov	r1, r4
 801f4a8:	200a      	movs	r0, #10
 801f4aa:	f7ff ffbb 	bl	801f424 <traceIF_uartPrintForce>
 801f4ae:	e7df      	b.n	801f470 <CMD_ComponentEnableDisable+0x40>
 801f4b0:	08035bec 	.word	0x08035bec
 801f4b4:	08035f20 	.word	0x08035f20
 801f4b8:	20000220 	.word	0x20000220
 801f4bc:	200050dc 	.word	0x200050dc
 801f4c0:	08035bf0 	.word	0x08035bf0

0801f4c4 <traceIF_cmd_Help>:
{
 801f4c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  CMD_print_help(trace_cmd_label);
 801f4c8:	f8df 8210 	ldr.w	r8, [pc, #528]	; 801f6dc <traceIF_cmd_Help+0x218>
 801f4cc:	4640      	mov	r0, r8
 801f4ce:	f003 fa73 	bl	80229b8 <CMD_print_help>
  PRINT_FORCE("%s help\r\n", trace_cmd_label);
 801f4d2:	4c79      	ldr	r4, [pc, #484]	; (801f6b8 <traceIF_cmd_Help+0x1f4>)
 801f4d4:	4642      	mov	r2, r8
 801f4d6:	4979      	ldr	r1, [pc, #484]	; (801f6bc <traceIF_cmd_Help+0x1f8>)
 801f4d8:	4620      	mov	r0, r4
 801f4da:	f007 f9b5 	bl	8026848 <sprintf>
 801f4de:	4620      	mov	r0, r4
 801f4e0:	f7ff ff23 	bl	801f32a <crs_strlen>
 801f4e4:	b283      	uxth	r3, r0
 801f4e6:	4622      	mov	r2, r4
 801f4e8:	2101      	movs	r1, #1
 801f4ea:	200a      	movs	r0, #10
 801f4ec:	f7ff ff60 	bl	801f3b0 <traceIF_itmPrint>
 801f4f0:	4620      	mov	r0, r4
 801f4f2:	f7ff ff1a 	bl	801f32a <crs_strlen>
 801f4f6:	b282      	uxth	r2, r0
 801f4f8:	4621      	mov	r1, r4
 801f4fa:	200a      	movs	r0, #10
 801f4fc:	f7ff ff92 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s on (activate traces)\r\n", trace_cmd_label);
 801f500:	4642      	mov	r2, r8
 801f502:	496f      	ldr	r1, [pc, #444]	; (801f6c0 <traceIF_cmd_Help+0x1fc>)
 801f504:	4620      	mov	r0, r4
 801f506:	f007 f99f 	bl	8026848 <sprintf>
 801f50a:	4620      	mov	r0, r4
 801f50c:	f7ff ff0d 	bl	801f32a <crs_strlen>
 801f510:	b283      	uxth	r3, r0
 801f512:	4622      	mov	r2, r4
 801f514:	2101      	movs	r1, #1
 801f516:	200a      	movs	r0, #10
 801f518:	f7ff ff4a 	bl	801f3b0 <traceIF_itmPrint>
 801f51c:	4620      	mov	r0, r4
 801f51e:	f7ff ff04 	bl	801f32a <crs_strlen>
 801f522:	b282      	uxth	r2, r0
 801f524:	4621      	mov	r1, r4
 801f526:	200a      	movs	r0, #10
 801f528:	f7ff ff7c 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s off (deactivate traces)\r\n", trace_cmd_label);
 801f52c:	4642      	mov	r2, r8
 801f52e:	4965      	ldr	r1, [pc, #404]	; (801f6c4 <traceIF_cmd_Help+0x200>)
 801f530:	4620      	mov	r0, r4
 801f532:	f007 f989 	bl	8026848 <sprintf>
 801f536:	4620      	mov	r0, r4
 801f538:	f7ff fef7 	bl	801f32a <crs_strlen>
 801f53c:	b283      	uxth	r3, r0
 801f53e:	4622      	mov	r2, r4
 801f540:	2101      	movs	r1, #1
 801f542:	200a      	movs	r0, #10
 801f544:	f7ff ff34 	bl	801f3b0 <traceIF_itmPrint>
 801f548:	4620      	mov	r0, r4
 801f54a:	f7ff feee 	bl	801f32a <crs_strlen>
 801f54e:	b282      	uxth	r2, r0
 801f550:	4621      	mov	r1, r4
 801f552:	200a      	movs	r0, #10
 801f554:	f7ff ff66 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s enable  all|generic|main|atcmd|comlib|echoclt|http|ping|ipc|ppposif|cellular_service|nifman",
 801f558:	4642      	mov	r2, r8
 801f55a:	495b      	ldr	r1, [pc, #364]	; (801f6c8 <traceIF_cmd_Help+0x204>)
 801f55c:	4620      	mov	r0, r4
 801f55e:	f007 f973 	bl	8026848 <sprintf>
 801f562:	4620      	mov	r0, r4
 801f564:	f7ff fee1 	bl	801f32a <crs_strlen>
 801f568:	b283      	uxth	r3, r0
 801f56a:	4622      	mov	r2, r4
 801f56c:	2101      	movs	r1, #1
 801f56e:	200a      	movs	r0, #10
 801f570:	f7ff ff1e 	bl	801f3b0 <traceIF_itmPrint>
 801f574:	4620      	mov	r0, r4
 801f576:	f7ff fed8 	bl	801f32a <crs_strlen>
 801f57a:	b282      	uxth	r2, r0
 801f57c:	4621      	mov	r1, r4
 801f57e:	200a      	movs	r0, #10
 801f580:	f7ff ff50 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("           |data_cache|utilities|error\r\n")
 801f584:	4e51      	ldr	r6, [pc, #324]	; (801f6cc <traceIF_cmd_Help+0x208>)
 801f586:	46a4      	mov	ip, r4
 801f588:	4635      	mov	r5, r6
 801f58a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f58c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f590:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f592:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f596:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f59a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f59e:	f88c 2000 	strb.w	r2, [ip]
 801f5a2:	4620      	mov	r0, r4
 801f5a4:	f7ff fec1 	bl	801f32a <crs_strlen>
 801f5a8:	b283      	uxth	r3, r0
 801f5aa:	4622      	mov	r2, r4
 801f5ac:	2101      	movs	r1, #1
 801f5ae:	200a      	movs	r0, #10
 801f5b0:	f7ff fefe 	bl	801f3b0 <traceIF_itmPrint>
 801f5b4:	4620      	mov	r0, r4
 801f5b6:	f7ff feb8 	bl	801f32a <crs_strlen>
 801f5ba:	b282      	uxth	r2, r0
 801f5bc:	4621      	mov	r1, r4
 801f5be:	200a      	movs	r0, #10
 801f5c0:	f7ff ff30 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE(" -> enable traces of selected component\r\n")
 801f5c4:	46a4      	mov	ip, r4
 801f5c6:	4f42      	ldr	r7, [pc, #264]	; (801f6d0 <traceIF_cmd_Help+0x20c>)
 801f5c8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801f5ca:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f5ce:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 801f5d0:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f5d4:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
 801f5d8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f5dc:	f8ac 2000 	strh.w	r2, [ip]
 801f5e0:	4620      	mov	r0, r4
 801f5e2:	f7ff fea2 	bl	801f32a <crs_strlen>
 801f5e6:	b283      	uxth	r3, r0
 801f5e8:	4622      	mov	r2, r4
 801f5ea:	2101      	movs	r1, #1
 801f5ec:	200a      	movs	r0, #10
 801f5ee:	f7ff fedf 	bl	801f3b0 <traceIF_itmPrint>
 801f5f2:	4620      	mov	r0, r4
 801f5f4:	f7ff fe99 	bl	801f32a <crs_strlen>
 801f5f8:	b282      	uxth	r2, r0
 801f5fa:	4621      	mov	r1, r4
 801f5fc:	200a      	movs	r0, #10
 801f5fe:	f7ff ff11 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s disable all|generic|main|atcmd|comlib|echoclt|http|ping|ipc|ppposif|cellular_service|nifman",
 801f602:	4642      	mov	r2, r8
 801f604:	4933      	ldr	r1, [pc, #204]	; (801f6d4 <traceIF_cmd_Help+0x210>)
 801f606:	4620      	mov	r0, r4
 801f608:	f007 f91e 	bl	8026848 <sprintf>
 801f60c:	4620      	mov	r0, r4
 801f60e:	f7ff fe8c 	bl	801f32a <crs_strlen>
 801f612:	b283      	uxth	r3, r0
 801f614:	4622      	mov	r2, r4
 801f616:	2101      	movs	r1, #1
 801f618:	200a      	movs	r0, #10
 801f61a:	f7ff fec9 	bl	801f3b0 <traceIF_itmPrint>
 801f61e:	4620      	mov	r0, r4
 801f620:	f7ff fe83 	bl	801f32a <crs_strlen>
 801f624:	b282      	uxth	r2, r0
 801f626:	4621      	mov	r1, r4
 801f628:	200a      	movs	r0, #10
 801f62a:	f7ff fefb 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("           |data_cache|utilities|error\r\n")
 801f62e:	46a4      	mov	ip, r4
 801f630:	46b6      	mov	lr, r6
 801f632:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801f636:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f63a:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 801f63e:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f642:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f646:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f64a:	f88c 2000 	strb.w	r2, [ip]
 801f64e:	4620      	mov	r0, r4
 801f650:	f7ff fe6b 	bl	801f32a <crs_strlen>
 801f654:	b283      	uxth	r3, r0
 801f656:	4622      	mov	r2, r4
 801f658:	2101      	movs	r1, #1
 801f65a:	200a      	movs	r0, #10
 801f65c:	f7ff fea8 	bl	801f3b0 <traceIF_itmPrint>
 801f660:	4620      	mov	r0, r4
 801f662:	f7ff fe62 	bl	801f32a <crs_strlen>
 801f666:	b282      	uxth	r2, r0
 801f668:	4621      	mov	r1, r4
 801f66a:	200a      	movs	r0, #10
 801f66c:	f7ff feda 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE(" -> disable traces of selected component\r\n")
 801f670:	46a4      	mov	ip, r4
 801f672:	4d19      	ldr	r5, [pc, #100]	; (801f6d8 <traceIF_cmd_Help+0x214>)
 801f674:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f676:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f67a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f67c:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 801f680:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f684:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 801f688:	f82c 2b02 	strh.w	r2, [ip], #2
 801f68c:	0c12      	lsrs	r2, r2, #16
 801f68e:	f88c 2000 	strb.w	r2, [ip]
 801f692:	4620      	mov	r0, r4
 801f694:	f7ff fe49 	bl	801f32a <crs_strlen>
 801f698:	b283      	uxth	r3, r0
 801f69a:	4622      	mov	r2, r4
 801f69c:	2101      	movs	r1, #1
 801f69e:	200a      	movs	r0, #10
 801f6a0:	f7ff fe86 	bl	801f3b0 <traceIF_itmPrint>
 801f6a4:	4620      	mov	r0, r4
 801f6a6:	f7ff fe40 	bl	801f32a <crs_strlen>
 801f6aa:	b282      	uxth	r2, r0
 801f6ac:	4621      	mov	r1, r4
 801f6ae:	200a      	movs	r0, #10
 801f6b0:	f7ff feb8 	bl	801f424 <traceIF_uartPrintForce>
}
 801f6b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801f6b8:	200050dc 	.word	0x200050dc
 801f6bc:	08035c10 	.word	0x08035c10
 801f6c0:	08035c1c 	.word	0x08035c1c
 801f6c4:	08035c38 	.word	0x08035c38
 801f6c8:	08035c58 	.word	0x08035c58
 801f6cc:	08035cb8 	.word	0x08035cb8
 801f6d0:	08035ce4 	.word	0x08035ce4
 801f6d4:	08035d10 	.word	0x08035d10
 801f6d8:	08035d70 	.word	0x08035d70
 801f6dc:	08035c08 	.word	0x08035c08

0801f6e0 <traceIF_cmd>:
{
 801f6e0:	b5f0      	push	{r4, r5, r6, r7, lr}
 801f6e2:	b08d      	sub	sp, #52	; 0x34
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 801f6e4:	4997      	ldr	r1, [pc, #604]	; (801f944 <traceIF_cmd+0x264>)
 801f6e6:	f007 f93d 	bl	8026964 <strtok>
  if (cmd_p != NULL)
 801f6ea:	2800      	cmp	r0, #0
 801f6ec:	f000 8128 	beq.w	801f940 <traceIF_cmd+0x260>
 801f6f0:	4604      	mov	r4, r0
    if (strncmp((const CRC_CHAR_t *)cmd_p,
 801f6f2:	f7e0 fd7f 	bl	80001f4 <strlen>
 801f6f6:	4602      	mov	r2, r0
 801f6f8:	4993      	ldr	r1, [pc, #588]	; (801f948 <traceIF_cmd+0x268>)
 801f6fa:	4620      	mov	r0, r4
 801f6fc:	f007 f91f 	bl	802693e <strncmp>
 801f700:	b110      	cbz	r0, 801f708 <traceIF_cmd+0x28>
  cmd_status = CMD_OK;
 801f702:	2000      	movs	r0, #0
}
 801f704:	b00d      	add	sp, #52	; 0x34
 801f706:	bdf0      	pop	{r4, r5, r6, r7, pc}
      for (argc = 0U ; argc < 10U ; argc++)
 801f708:	2400      	movs	r4, #0
 801f70a:	2c09      	cmp	r4, #9
 801f70c:	d80b      	bhi.n	801f726 <traceIF_cmd+0x46>
        argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 801f70e:	498d      	ldr	r1, [pc, #564]	; (801f944 <traceIF_cmd+0x264>)
 801f710:	2000      	movs	r0, #0
 801f712:	f007 f927 	bl	8026964 <strtok>
 801f716:	ab0c      	add	r3, sp, #48	; 0x30
 801f718:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 801f71c:	f843 0c28 	str.w	r0, [r3, #-40]
        if (argv_p[argc] == NULL)
 801f720:	b108      	cbz	r0, 801f726 <traceIF_cmd+0x46>
      for (argc = 0U ; argc < 10U ; argc++)
 801f722:	3401      	adds	r4, #1
 801f724:	e7f1      	b.n	801f70a <traceIF_cmd+0x2a>
      if ((argc == 0U)
 801f726:	b154      	cbz	r4, 801f73e <traceIF_cmd+0x5e>
          || (strncmp((CRC_CHAR_t *)argv_p[0],
 801f728:	9d02      	ldr	r5, [sp, #8]
 801f72a:	4628      	mov	r0, r5
 801f72c:	f7e0 fd62 	bl	80001f4 <strlen>
 801f730:	4604      	mov	r4, r0
 801f732:	4602      	mov	r2, r0
 801f734:	4985      	ldr	r1, [pc, #532]	; (801f94c <traceIF_cmd+0x26c>)
 801f736:	4628      	mov	r0, r5
 801f738:	f007 f901 	bl	802693e <strncmp>
 801f73c:	b918      	cbnz	r0, 801f746 <traceIF_cmd+0x66>
        traceIF_cmd_Help();
 801f73e:	f7ff fec1 	bl	801f4c4 <traceIF_cmd_Help>
  cmd_status = CMD_OK;
 801f742:	2000      	movs	r0, #0
        traceIF_cmd_Help();
 801f744:	e7de      	b.n	801f704 <traceIF_cmd+0x24>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f746:	4622      	mov	r2, r4
 801f748:	4981      	ldr	r1, [pc, #516]	; (801f950 <traceIF_cmd+0x270>)
 801f74a:	4628      	mov	r0, r5
 801f74c:	f007 f8f7 	bl	802693e <strncmp>
 801f750:	2800      	cmp	r0, #0
 801f752:	d03c      	beq.n	801f7ce <traceIF_cmd+0xee>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f754:	4622      	mov	r2, r4
 801f756:	497f      	ldr	r1, [pc, #508]	; (801f954 <traceIF_cmd+0x274>)
 801f758:	4628      	mov	r0, r5
 801f75a:	f007 f8f0 	bl	802693e <strncmp>
 801f75e:	2800      	cmp	r0, #0
 801f760:	d054      	beq.n	801f80c <traceIF_cmd+0x12c>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f762:	4622      	mov	r2, r4
 801f764:	497c      	ldr	r1, [pc, #496]	; (801f958 <traceIF_cmd+0x278>)
 801f766:	4628      	mov	r0, r5
 801f768:	f007 f8e9 	bl	802693e <strncmp>
 801f76c:	2800      	cmp	r0, #0
 801f76e:	d06d      	beq.n	801f84c <traceIF_cmd+0x16c>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f770:	4622      	mov	r2, r4
 801f772:	497a      	ldr	r1, [pc, #488]	; (801f95c <traceIF_cmd+0x27c>)
 801f774:	4628      	mov	r0, r5
 801f776:	f007 f8e2 	bl	802693e <strncmp>
 801f77a:	2800      	cmp	r0, #0
 801f77c:	f000 8089 	beq.w	801f892 <traceIF_cmd+0x1b2>
      else if (strncmp((CRC_CHAR_t *)argv_p[0],
 801f780:	4622      	mov	r2, r4
 801f782:	4977      	ldr	r1, [pc, #476]	; (801f960 <traceIF_cmd+0x280>)
 801f784:	4628      	mov	r0, r5
 801f786:	f007 f8da 	bl	802693e <strncmp>
 801f78a:	2800      	cmp	r0, #0
 801f78c:	f040 80be 	bne.w	801f90c <traceIF_cmd+0x22c>
        traceIF_traceEnable = false;
 801f790:	2400      	movs	r4, #0
 801f792:	4b74      	ldr	r3, [pc, #464]	; (801f964 <traceIF_cmd+0x284>)
 801f794:	701c      	strb	r4, [r3, #0]
        PRINT_FORCE("\n\r <<< TRACE INACTIVE >>>\n\r")
 801f796:	4f74      	ldr	r7, [pc, #464]	; (801f968 <traceIF_cmd+0x288>)
 801f798:	463d      	mov	r5, r7
 801f79a:	4e74      	ldr	r6, [pc, #464]	; (801f96c <traceIF_cmd+0x28c>)
 801f79c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 801f79e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 801f7a0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 801f7a4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
 801f7a8:	4638      	mov	r0, r7
 801f7aa:	f7ff fdbe 	bl	801f32a <crs_strlen>
 801f7ae:	b283      	uxth	r3, r0
 801f7b0:	463a      	mov	r2, r7
 801f7b2:	2101      	movs	r1, #1
 801f7b4:	200a      	movs	r0, #10
 801f7b6:	f7ff fdfb 	bl	801f3b0 <traceIF_itmPrint>
 801f7ba:	4638      	mov	r0, r7
 801f7bc:	f7ff fdb5 	bl	801f32a <crs_strlen>
 801f7c0:	b282      	uxth	r2, r0
 801f7c2:	4639      	mov	r1, r7
 801f7c4:	200a      	movs	r0, #10
 801f7c6:	f7ff fe2d 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 801f7ca:	4620      	mov	r0, r4
 801f7cc:	e79a      	b.n	801f704 <traceIF_cmd+0x24>
        traceIF_traceEnable = true;
 801f7ce:	2701      	movs	r7, #1
 801f7d0:	4b64      	ldr	r3, [pc, #400]	; (801f964 <traceIF_cmd+0x284>)
 801f7d2:	701f      	strb	r7, [r3, #0]
        PRINT_FORCE("\n\r <<< TRACE ACTIVE >>>\n\r")
 801f7d4:	4e64      	ldr	r6, [pc, #400]	; (801f968 <traceIF_cmd+0x288>)
 801f7d6:	4634      	mov	r4, r6
 801f7d8:	4d65      	ldr	r5, [pc, #404]	; (801f970 <traceIF_cmd+0x290>)
 801f7da:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f7dc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f7de:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f7e2:	c403      	stmia	r4!, {r0, r1}
 801f7e4:	8022      	strh	r2, [r4, #0]
 801f7e6:	4630      	mov	r0, r6
 801f7e8:	f7ff fd9f 	bl	801f32a <crs_strlen>
 801f7ec:	b283      	uxth	r3, r0
 801f7ee:	4632      	mov	r2, r6
 801f7f0:	4639      	mov	r1, r7
 801f7f2:	200a      	movs	r0, #10
 801f7f4:	f7ff fddc 	bl	801f3b0 <traceIF_itmPrint>
 801f7f8:	4630      	mov	r0, r6
 801f7fa:	f7ff fd96 	bl	801f32a <crs_strlen>
 801f7fe:	b282      	uxth	r2, r0
 801f800:	4631      	mov	r1, r6
 801f802:	200a      	movs	r0, #10
 801f804:	f7ff fe0e 	bl	801f424 <traceIF_uartPrintForce>
  cmd_status = CMD_OK;
 801f808:	2000      	movs	r0, #0
 801f80a:	e77b      	b.n	801f704 <traceIF_cmd+0x24>
        PRINT_FORCE("\n\r <<< TRACE ENABLE >>>\n\r")
 801f80c:	4e56      	ldr	r6, [pc, #344]	; (801f968 <traceIF_cmd+0x288>)
 801f80e:	4634      	mov	r4, r6
 801f810:	4d58      	ldr	r5, [pc, #352]	; (801f974 <traceIF_cmd+0x294>)
 801f812:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f814:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f816:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f81a:	c403      	stmia	r4!, {r0, r1}
 801f81c:	8022      	strh	r2, [r4, #0]
 801f81e:	4630      	mov	r0, r6
 801f820:	f7ff fd83 	bl	801f32a <crs_strlen>
 801f824:	b283      	uxth	r3, r0
 801f826:	4632      	mov	r2, r6
 801f828:	2101      	movs	r1, #1
 801f82a:	200a      	movs	r0, #10
 801f82c:	f7ff fdc0 	bl	801f3b0 <traceIF_itmPrint>
 801f830:	4630      	mov	r0, r6
 801f832:	f7ff fd7a 	bl	801f32a <crs_strlen>
 801f836:	b282      	uxth	r2, r0
 801f838:	4631      	mov	r1, r6
 801f83a:	200a      	movs	r0, #10
 801f83c:	f7ff fdf2 	bl	801f424 <traceIF_uartPrintForce>
        CMD_ComponentEnableDisable(argv_p[1], 1);
 801f840:	2101      	movs	r1, #1
 801f842:	9803      	ldr	r0, [sp, #12]
 801f844:	f7ff fdf4 	bl	801f430 <CMD_ComponentEnableDisable>
  cmd_status = CMD_OK;
 801f848:	2000      	movs	r0, #0
 801f84a:	e75b      	b.n	801f704 <traceIF_cmd+0x24>
        PRINT_FORCE("\n\r <<< TRACE DISABLE >>>\n\r")
 801f84c:	4e46      	ldr	r6, [pc, #280]	; (801f968 <traceIF_cmd+0x288>)
 801f84e:	4634      	mov	r4, r6
 801f850:	4d49      	ldr	r5, [pc, #292]	; (801f978 <traceIF_cmd+0x298>)
 801f852:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f854:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f856:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f85a:	c403      	stmia	r4!, {r0, r1}
 801f85c:	f824 2b02 	strh.w	r2, [r4], #2
 801f860:	0c12      	lsrs	r2, r2, #16
 801f862:	7022      	strb	r2, [r4, #0]
 801f864:	4630      	mov	r0, r6
 801f866:	f7ff fd60 	bl	801f32a <crs_strlen>
 801f86a:	b283      	uxth	r3, r0
 801f86c:	4632      	mov	r2, r6
 801f86e:	2101      	movs	r1, #1
 801f870:	200a      	movs	r0, #10
 801f872:	f7ff fd9d 	bl	801f3b0 <traceIF_itmPrint>
 801f876:	4630      	mov	r0, r6
 801f878:	f7ff fd57 	bl	801f32a <crs_strlen>
 801f87c:	b282      	uxth	r2, r0
 801f87e:	4631      	mov	r1, r6
 801f880:	200a      	movs	r0, #10
 801f882:	f7ff fdcf 	bl	801f424 <traceIF_uartPrintForce>
        CMD_ComponentEnableDisable(argv_p[1], 0);
 801f886:	2100      	movs	r1, #0
 801f888:	9803      	ldr	r0, [sp, #12]
 801f88a:	f7ff fdd1 	bl	801f430 <CMD_ComponentEnableDisable>
  cmd_status = CMD_OK;
 801f88e:	2000      	movs	r0, #0
 801f890:	e738      	b.n	801f704 <traceIF_cmd+0x24>
        PRINT_FORCE("\n\r <<< TRACE LEVEL >>>\n\r")
 801f892:	4e35      	ldr	r6, [pc, #212]	; (801f968 <traceIF_cmd+0x288>)
 801f894:	4634      	mov	r4, r6
 801f896:	4d39      	ldr	r5, [pc, #228]	; (801f97c <traceIF_cmd+0x29c>)
 801f898:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801f89a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801f89c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
 801f8a0:	c403      	stmia	r4!, {r0, r1}
 801f8a2:	7022      	strb	r2, [r4, #0]
 801f8a4:	4630      	mov	r0, r6
 801f8a6:	f7ff fd40 	bl	801f32a <crs_strlen>
 801f8aa:	b283      	uxth	r3, r0
 801f8ac:	4632      	mov	r2, r6
 801f8ae:	2101      	movs	r1, #1
 801f8b0:	200a      	movs	r0, #10
 801f8b2:	f7ff fd7d 	bl	801f3b0 <traceIF_itmPrint>
 801f8b6:	4630      	mov	r0, r6
 801f8b8:	f7ff fd37 	bl	801f32a <crs_strlen>
 801f8bc:	b282      	uxth	r2, r0
 801f8be:	4631      	mov	r1, r6
 801f8c0:	200a      	movs	r0, #10
 801f8c2:	f7ff fdaf 	bl	801f424 <traceIF_uartPrintForce>
        ret = CMD_GetValue(argv_p[1], (uint32_t *)&level);
 801f8c6:	9c03      	ldr	r4, [sp, #12]
 801f8c8:	a901      	add	r1, sp, #4
 801f8ca:	4620      	mov	r0, r4
 801f8cc:	f002 fff0 	bl	80228b0 <CMD_GetValue>
        if (ret != 0U)
 801f8d0:	b920      	cbnz	r0, 801f8dc <traceIF_cmd+0x1fc>
          traceIF_Level = level;
 801f8d2:	4b2b      	ldr	r3, [pc, #172]	; (801f980 <traceIF_cmd+0x2a0>)
 801f8d4:	9a01      	ldr	r2, [sp, #4]
 801f8d6:	601a      	str	r2, [r3, #0]
  cmd_status = CMD_OK;
 801f8d8:	2000      	movs	r0, #0
 801f8da:	e713      	b.n	801f704 <traceIF_cmd+0x24>
          PRINT_FORCE("invalid level %s\r\n", argv_p[1]);
 801f8dc:	4622      	mov	r2, r4
 801f8de:	4929      	ldr	r1, [pc, #164]	; (801f984 <traceIF_cmd+0x2a4>)
 801f8e0:	4630      	mov	r0, r6
 801f8e2:	f006 ffb1 	bl	8026848 <sprintf>
 801f8e6:	4630      	mov	r0, r6
 801f8e8:	f7ff fd1f 	bl	801f32a <crs_strlen>
 801f8ec:	b283      	uxth	r3, r0
 801f8ee:	4632      	mov	r2, r6
 801f8f0:	2101      	movs	r1, #1
 801f8f2:	200a      	movs	r0, #10
 801f8f4:	f7ff fd5c 	bl	801f3b0 <traceIF_itmPrint>
 801f8f8:	4630      	mov	r0, r6
 801f8fa:	f7ff fd16 	bl	801f32a <crs_strlen>
 801f8fe:	b282      	uxth	r2, r0
 801f900:	4631      	mov	r1, r6
 801f902:	200a      	movs	r0, #10
 801f904:	f7ff fd8e 	bl	801f424 <traceIF_uartPrintForce>
          cmd_status = CMD_SYNTAX_ERROR;
 801f908:	2001      	movs	r0, #1
 801f90a:	e6fb      	b.n	801f704 <traceIF_cmd+0x24>
        PRINT_FORCE("\n\rTRACE usage\n\r")
 801f90c:	4c16      	ldr	r4, [pc, #88]	; (801f968 <traceIF_cmd+0x288>)
 801f90e:	4b1e      	ldr	r3, [pc, #120]	; (801f988 <traceIF_cmd+0x2a8>)
 801f910:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801f912:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801f916:	4620      	mov	r0, r4
 801f918:	f7ff fd07 	bl	801f32a <crs_strlen>
 801f91c:	b283      	uxth	r3, r0
 801f91e:	4622      	mov	r2, r4
 801f920:	2101      	movs	r1, #1
 801f922:	200a      	movs	r0, #10
 801f924:	f7ff fd44 	bl	801f3b0 <traceIF_itmPrint>
 801f928:	4620      	mov	r0, r4
 801f92a:	f7ff fcfe 	bl	801f32a <crs_strlen>
 801f92e:	b282      	uxth	r2, r0
 801f930:	4621      	mov	r1, r4
 801f932:	200a      	movs	r0, #10
 801f934:	f7ff fd76 	bl	801f424 <traceIF_uartPrintForce>
        traceIF_cmd_Help();
 801f938:	f7ff fdc4 	bl	801f4c4 <traceIF_cmd_Help>
  cmd_status = CMD_OK;
 801f93c:	2000      	movs	r0, #0
 801f93e:	e6e1      	b.n	801f704 <traceIF_cmd+0x24>
 801f940:	2000      	movs	r0, #0
 801f942:	e6df      	b.n	801f704 <traceIF_cmd+0x24>
 801f944:	0803382c 	.word	0x0803382c
 801f948:	08035c08 	.word	0x08035c08
 801f94c:	08033830 	.word	0x08033830
 801f950:	08033fa8 	.word	0x08033fa8
 801f954:	08035db8 	.word	0x08035db8
 801f958:	08035ddc 	.word	0x08035ddc
 801f95c:	08035e00 	.word	0x08035e00
 801f960:	08033a68 	.word	0x08033a68
 801f964:	2000022e 	.word	0x2000022e
 801f968:	200050dc 	.word	0x200050dc
 801f96c:	08035e38 	.word	0x08035e38
 801f970:	08035d9c 	.word	0x08035d9c
 801f974:	08035dc0 	.word	0x08035dc0
 801f978:	08035de4 	.word	0x08035de4
 801f97c:	08035e08 	.word	0x08035e08
 801f980:	2000021c 	.word	0x2000021c
 801f984:	08035e24 	.word	0x08035e24
 801f988:	08035e54 	.word	0x08035e54

0801f98c <traceIF_BufCharPrint>:
  * @param  buf   - pointer on the trace
  * @param  size  - size of the trace
  * @retval -
  */
void traceIF_BufCharPrint(dbg_channels_t chan, dbg_levels_t level, const CRC_CHAR_t *buf, uint16_t size)
{
 801f98c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 801f990:	4606      	mov	r6, r0
 801f992:	460f      	mov	r7, r1
 801f994:	4691      	mov	r9, r2
 801f996:	4698      	mov	r8, r3
  for (uint16_t cpt = 0U; cpt < size; cpt++)
 801f998:	2400      	movs	r4, #0
 801f99a:	e01f      	b.n	801f9dc <traceIF_BufCharPrint+0x50>
  {
    if (buf[cpt] == (CRC_CHAR_t)0)
    {
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<NULL CHAR>")
 801f99c:	f8df e1b8 	ldr.w	lr, [pc, #440]	; 801fb58 <traceIF_BufCharPrint+0x1cc>
 801f9a0:	ea4f 2c06 	mov.w	ip, r6, lsl #8
 801f9a4:	eb0e 2506 	add.w	r5, lr, r6, lsl #8
 801f9a8:	4b6a      	ldr	r3, [pc, #424]	; (801fb54 <traceIF_BufCharPrint+0x1c8>)
 801f9aa:	cb07      	ldmia	r3!, {r0, r1, r2}
 801f9ac:	f84e 000c 	str.w	r0, [lr, ip]
 801f9b0:	6069      	str	r1, [r5, #4]
 801f9b2:	60aa      	str	r2, [r5, #8]
 801f9b4:	4628      	mov	r0, r5
 801f9b6:	f7ff fcb8 	bl	801f32a <crs_strlen>
 801f9ba:	b283      	uxth	r3, r0
 801f9bc:	462a      	mov	r2, r5
 801f9be:	4639      	mov	r1, r7
 801f9c0:	4630      	mov	r0, r6
 801f9c2:	f7ff fcf5 	bl	801f3b0 <traceIF_itmPrint>
 801f9c6:	4628      	mov	r0, r5
 801f9c8:	f7ff fcaf 	bl	801f32a <crs_strlen>
 801f9cc:	b283      	uxth	r3, r0
 801f9ce:	462a      	mov	r2, r5
 801f9d0:	4639      	mov	r1, r7
 801f9d2:	4630      	mov	r0, r6
 801f9d4:	f7ff fd0e 	bl	801f3f4 <traceIF_uartPrint>
  for (uint16_t cpt = 0U; cpt < size; cpt++)
 801f9d8:	3401      	adds	r4, #1
 801f9da:	b2a4      	uxth	r4, r4
 801f9dc:	4544      	cmp	r4, r8
 801f9de:	f080 809c 	bcs.w	801fb1a <traceIF_BufCharPrint+0x18e>
    if (buf[cpt] == (CRC_CHAR_t)0)
 801f9e2:	f819 2004 	ldrb.w	r2, [r9, r4]
 801f9e6:	2a00      	cmp	r2, #0
 801f9e8:	d0d8      	beq.n	801f99c <traceIF_BufCharPrint+0x10>
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if (buf[cpt] == '\r')
 801f9ea:	2a0d      	cmp	r2, #13
 801f9ec:	d022      	beq.n	801fa34 <traceIF_BufCharPrint+0xa8>
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<CR>")
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if (buf[cpt] == '\n')
 801f9ee:	2a0a      	cmp	r2, #10
 801f9f0:	d03c      	beq.n	801fa6c <traceIF_BufCharPrint+0xe0>
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<LF>")
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if (buf[cpt] == (CRC_CHAR_t)0x1A)
 801f9f2:	2a1a      	cmp	r2, #26
 801f9f4:	d056      	beq.n	801faa4 <traceIF_BufCharPrint+0x118>
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      TRACE_PRINT(chan, level, "<CTRL-Z>")
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
    else if ((buf[cpt] >= (CRC_CHAR_t)0x20) && (buf[cpt] <= (CRC_CHAR_t)0x7E))
 801f9f6:	f1a2 0320 	sub.w	r3, r2, #32
 801f9fa:	b2db      	uxtb	r3, r3
 801f9fc:	2b5e      	cmp	r3, #94	; 0x5e
 801f9fe:	d870      	bhi.n	801fae2 <traceIF_BufCharPrint+0x156>
    {
      /* printable CRC_CHAR_t */
      TRACE_PRINT(chan, level, "%c", buf[cpt])
 801fa00:	4d55      	ldr	r5, [pc, #340]	; (801fb58 <traceIF_BufCharPrint+0x1cc>)
 801fa02:	eb05 2506 	add.w	r5, r5, r6, lsl #8
 801fa06:	4955      	ldr	r1, [pc, #340]	; (801fb5c <traceIF_BufCharPrint+0x1d0>)
 801fa08:	4628      	mov	r0, r5
 801fa0a:	f006 ff1d 	bl	8026848 <sprintf>
 801fa0e:	4628      	mov	r0, r5
 801fa10:	f7ff fc8b 	bl	801f32a <crs_strlen>
 801fa14:	b283      	uxth	r3, r0
 801fa16:	462a      	mov	r2, r5
 801fa18:	4639      	mov	r1, r7
 801fa1a:	4630      	mov	r0, r6
 801fa1c:	f7ff fcc8 	bl	801f3b0 <traceIF_itmPrint>
 801fa20:	4628      	mov	r0, r5
 801fa22:	f7ff fc82 	bl	801f32a <crs_strlen>
 801fa26:	b283      	uxth	r3, r0
 801fa28:	462a      	mov	r2, r5
 801fa2a:	4639      	mov	r1, r7
 801fa2c:	4630      	mov	r0, r6
 801fa2e:	f7ff fce1 	bl	801f3f4 <traceIF_uartPrint>
 801fa32:	e7d1      	b.n	801f9d8 <traceIF_BufCharPrint+0x4c>
      TRACE_PRINT(chan, level, "<CR>")
 801fa34:	4948      	ldr	r1, [pc, #288]	; (801fb58 <traceIF_BufCharPrint+0x1cc>)
 801fa36:	0233      	lsls	r3, r6, #8
 801fa38:	eb01 2506 	add.w	r5, r1, r6, lsl #8
 801fa3c:	4a48      	ldr	r2, [pc, #288]	; (801fb60 <traceIF_BufCharPrint+0x1d4>)
 801fa3e:	6810      	ldr	r0, [r2, #0]
 801fa40:	50c8      	str	r0, [r1, r3]
 801fa42:	7913      	ldrb	r3, [r2, #4]
 801fa44:	712b      	strb	r3, [r5, #4]
 801fa46:	4628      	mov	r0, r5
 801fa48:	f7ff fc6f 	bl	801f32a <crs_strlen>
 801fa4c:	b283      	uxth	r3, r0
 801fa4e:	462a      	mov	r2, r5
 801fa50:	4639      	mov	r1, r7
 801fa52:	4630      	mov	r0, r6
 801fa54:	f7ff fcac 	bl	801f3b0 <traceIF_itmPrint>
 801fa58:	4628      	mov	r0, r5
 801fa5a:	f7ff fc66 	bl	801f32a <crs_strlen>
 801fa5e:	b283      	uxth	r3, r0
 801fa60:	462a      	mov	r2, r5
 801fa62:	4639      	mov	r1, r7
 801fa64:	4630      	mov	r0, r6
 801fa66:	f7ff fcc5 	bl	801f3f4 <traceIF_uartPrint>
 801fa6a:	e7b5      	b.n	801f9d8 <traceIF_BufCharPrint+0x4c>
      TRACE_PRINT(chan, level, "<LF>")
 801fa6c:	493a      	ldr	r1, [pc, #232]	; (801fb58 <traceIF_BufCharPrint+0x1cc>)
 801fa6e:	0233      	lsls	r3, r6, #8
 801fa70:	eb01 2506 	add.w	r5, r1, r6, lsl #8
 801fa74:	4a3b      	ldr	r2, [pc, #236]	; (801fb64 <traceIF_BufCharPrint+0x1d8>)
 801fa76:	6810      	ldr	r0, [r2, #0]
 801fa78:	50c8      	str	r0, [r1, r3]
 801fa7a:	7913      	ldrb	r3, [r2, #4]
 801fa7c:	712b      	strb	r3, [r5, #4]
 801fa7e:	4628      	mov	r0, r5
 801fa80:	f7ff fc53 	bl	801f32a <crs_strlen>
 801fa84:	b283      	uxth	r3, r0
 801fa86:	462a      	mov	r2, r5
 801fa88:	4639      	mov	r1, r7
 801fa8a:	4630      	mov	r0, r6
 801fa8c:	f7ff fc90 	bl	801f3b0 <traceIF_itmPrint>
 801fa90:	4628      	mov	r0, r5
 801fa92:	f7ff fc4a 	bl	801f32a <crs_strlen>
 801fa96:	b283      	uxth	r3, r0
 801fa98:	462a      	mov	r2, r5
 801fa9a:	4639      	mov	r1, r7
 801fa9c:	4630      	mov	r0, r6
 801fa9e:	f7ff fca9 	bl	801f3f4 <traceIF_uartPrint>
 801faa2:	e799      	b.n	801f9d8 <traceIF_BufCharPrint+0x4c>
      TRACE_PRINT(chan, level, "<CTRL-Z>")
 801faa4:	f8df c0b0 	ldr.w	ip, [pc, #176]	; 801fb58 <traceIF_BufCharPrint+0x1cc>
 801faa8:	0232      	lsls	r2, r6, #8
 801faaa:	eb0c 2506 	add.w	r5, ip, r6, lsl #8
 801faae:	4b2e      	ldr	r3, [pc, #184]	; (801fb68 <traceIF_BufCharPrint+0x1dc>)
 801fab0:	cb03      	ldmia	r3!, {r0, r1}
 801fab2:	f84c 0002 	str.w	r0, [ip, r2]
 801fab6:	6069      	str	r1, [r5, #4]
 801fab8:	781b      	ldrb	r3, [r3, #0]
 801faba:	722b      	strb	r3, [r5, #8]
 801fabc:	4628      	mov	r0, r5
 801fabe:	f7ff fc34 	bl	801f32a <crs_strlen>
 801fac2:	b283      	uxth	r3, r0
 801fac4:	462a      	mov	r2, r5
 801fac6:	4639      	mov	r1, r7
 801fac8:	4630      	mov	r0, r6
 801faca:	f7ff fc71 	bl	801f3b0 <traceIF_itmPrint>
 801face:	4628      	mov	r0, r5
 801fad0:	f7ff fc2b 	bl	801f32a <crs_strlen>
 801fad4:	b283      	uxth	r3, r0
 801fad6:	462a      	mov	r2, r5
 801fad8:	4639      	mov	r1, r7
 801fada:	4630      	mov	r0, r6
 801fadc:	f7ff fc8a 	bl	801f3f4 <traceIF_uartPrint>
 801fae0:	e77a      	b.n	801f9d8 <traceIF_BufCharPrint+0x4c>
    else
    {
#if defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR)
#else
      /* Special Character - not printable */
      TRACE_PRINT(chan, level, "<SC>")
 801fae2:	491d      	ldr	r1, [pc, #116]	; (801fb58 <traceIF_BufCharPrint+0x1cc>)
 801fae4:	0233      	lsls	r3, r6, #8
 801fae6:	eb01 2506 	add.w	r5, r1, r6, lsl #8
 801faea:	4a20      	ldr	r2, [pc, #128]	; (801fb6c <traceIF_BufCharPrint+0x1e0>)
 801faec:	6810      	ldr	r0, [r2, #0]
 801faee:	50c8      	str	r0, [r1, r3]
 801faf0:	7913      	ldrb	r3, [r2, #4]
 801faf2:	712b      	strb	r3, [r5, #4]
 801faf4:	4628      	mov	r0, r5
 801faf6:	f7ff fc18 	bl	801f32a <crs_strlen>
 801fafa:	b283      	uxth	r3, r0
 801fafc:	462a      	mov	r2, r5
 801fafe:	4639      	mov	r1, r7
 801fb00:	4630      	mov	r0, r6
 801fb02:	f7ff fc55 	bl	801f3b0 <traceIF_itmPrint>
 801fb06:	4628      	mov	r0, r5
 801fb08:	f7ff fc0f 	bl	801f32a <crs_strlen>
 801fb0c:	b283      	uxth	r3, r0
 801fb0e:	462a      	mov	r2, r5
 801fb10:	4639      	mov	r1, r7
 801fb12:	4630      	mov	r0, r6
 801fb14:	f7ff fc6e 	bl	801f3f4 <traceIF_uartPrint>
 801fb18:	e75e      	b.n	801f9d8 <traceIF_BufCharPrint+0x4c>
#endif /* defined(USER_FLAG_TRACE_NO_SPECIAL_CHAR) */
    }
  }

  /* Force to go to next line to prepare next trace */
  TRACE_PRINT(chan, level, "\n\r")
 801fb1a:	4b0f      	ldr	r3, [pc, #60]	; (801fb58 <traceIF_BufCharPrint+0x1cc>)
 801fb1c:	0231      	lsls	r1, r6, #8
 801fb1e:	eb03 2406 	add.w	r4, r3, r6, lsl #8
 801fb22:	4a13      	ldr	r2, [pc, #76]	; (801fb70 <traceIF_BufCharPrint+0x1e4>)
 801fb24:	8810      	ldrh	r0, [r2, #0]
 801fb26:	7892      	ldrb	r2, [r2, #2]
 801fb28:	5258      	strh	r0, [r3, r1]
 801fb2a:	70a2      	strb	r2, [r4, #2]
 801fb2c:	4620      	mov	r0, r4
 801fb2e:	f7ff fbfc 	bl	801f32a <crs_strlen>
 801fb32:	b283      	uxth	r3, r0
 801fb34:	4622      	mov	r2, r4
 801fb36:	4639      	mov	r1, r7
 801fb38:	4630      	mov	r0, r6
 801fb3a:	f7ff fc39 	bl	801f3b0 <traceIF_itmPrint>
 801fb3e:	4620      	mov	r0, r4
 801fb40:	f7ff fbf3 	bl	801f32a <crs_strlen>
 801fb44:	b283      	uxth	r3, r0
 801fb46:	4622      	mov	r2, r4
 801fb48:	4639      	mov	r1, r7
 801fb4a:	4630      	mov	r0, r6
 801fb4c:	f7ff fc52 	bl	801f3f4 <traceIF_uartPrint>
}
 801fb50:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 801fb54:	08035e64 	.word	0x08035e64
 801fb58:	200046dc 	.word	0x200046dc
 801fb5c:	08035e8c 	.word	0x08035e8c
 801fb60:	08035e70 	.word	0x08035e70
 801fb64:	08035e78 	.word	0x08035e78
 801fb68:	08035e80 	.word	0x08035e80
 801fb6c:	08035e90 	.word	0x08035e90
 801fb70:	0802eac4 	.word	0x0802eac4

0801fb74 <traceIF_BufHexPrint>:
  * @param  buf   - pointer on the trace
  * @param  size  - size of the trace
  * @retval -
  */
void traceIF_BufHexPrint(dbg_channels_t chan, dbg_levels_t level, const CRC_CHAR_t *buf, uint16_t size)
{
 801fb74:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801fb78:	4606      	mov	r6, r0
 801fb7a:	460f      	mov	r7, r1
 801fb7c:	4692      	mov	sl, r2
 801fb7e:	4699      	mov	r9, r3
  for (uint16_t cpt = 0U; cpt < size; cpt++)
 801fb80:	2400      	movs	r4, #0
 801fb82:	e001      	b.n	801fb88 <traceIF_BufHexPrint+0x14>
 801fb84:	3401      	adds	r4, #1
 801fb86:	b2a4      	uxth	r4, r4
 801fb88:	454c      	cmp	r4, r9
 801fb8a:	d23c      	bcs.n	801fc06 <traceIF_BufHexPrint+0x92>
  {
    /* Print bytes one per one */
    TRACE_PRINT(chan, level, "0x%02x ", (uint8_t) buf[cpt])
 801fb8c:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 801fc48 <traceIF_BufHexPrint+0xd4>
 801fb90:	ea4f 2b06 	mov.w	fp, r6, lsl #8
 801fb94:	eb08 2506 	add.w	r5, r8, r6, lsl #8
 801fb98:	f81a 2004 	ldrb.w	r2, [sl, r4]
 801fb9c:	4928      	ldr	r1, [pc, #160]	; (801fc40 <traceIF_BufHexPrint+0xcc>)
 801fb9e:	4628      	mov	r0, r5
 801fba0:	f006 fe52 	bl	8026848 <sprintf>
 801fba4:	4628      	mov	r0, r5
 801fba6:	f7ff fbc0 	bl	801f32a <crs_strlen>
 801fbaa:	b283      	uxth	r3, r0
 801fbac:	462a      	mov	r2, r5
 801fbae:	4639      	mov	r1, r7
 801fbb0:	4630      	mov	r0, r6
 801fbb2:	f7ff fbfd 	bl	801f3b0 <traceIF_itmPrint>
 801fbb6:	4628      	mov	r0, r5
 801fbb8:	f7ff fbb7 	bl	801f32a <crs_strlen>
 801fbbc:	b283      	uxth	r3, r0
 801fbbe:	462a      	mov	r2, r5
 801fbc0:	4639      	mov	r1, r7
 801fbc2:	4630      	mov	r0, r6
 801fbc4:	f7ff fc16 	bl	801f3f4 <traceIF_uartPrint>

    /* Print only 16 bytes on same line */
    if ((cpt != 0U) && (((cpt + 1U) % 16U) == 0U))
 801fbc8:	2c00      	cmp	r4, #0
 801fbca:	d0db      	beq.n	801fb84 <traceIF_BufHexPrint+0x10>
 801fbcc:	1c63      	adds	r3, r4, #1
 801fbce:	f013 0f0f 	tst.w	r3, #15
 801fbd2:	d1d7      	bne.n	801fb84 <traceIF_BufHexPrint+0x10>
    {
      /* Force to go to next line to prepare next trace */
      TRACE_PRINT(chan, level, "\n\r")
 801fbd4:	4b1b      	ldr	r3, [pc, #108]	; (801fc44 <traceIF_BufHexPrint+0xd0>)
 801fbd6:	881a      	ldrh	r2, [r3, #0]
 801fbd8:	789b      	ldrb	r3, [r3, #2]
 801fbda:	f828 200b 	strh.w	r2, [r8, fp]
 801fbde:	70ab      	strb	r3, [r5, #2]
 801fbe0:	4628      	mov	r0, r5
 801fbe2:	f7ff fba2 	bl	801f32a <crs_strlen>
 801fbe6:	b283      	uxth	r3, r0
 801fbe8:	462a      	mov	r2, r5
 801fbea:	4639      	mov	r1, r7
 801fbec:	4630      	mov	r0, r6
 801fbee:	f7ff fbdf 	bl	801f3b0 <traceIF_itmPrint>
 801fbf2:	4628      	mov	r0, r5
 801fbf4:	f7ff fb99 	bl	801f32a <crs_strlen>
 801fbf8:	b283      	uxth	r3, r0
 801fbfa:	462a      	mov	r2, r5
 801fbfc:	4639      	mov	r1, r7
 801fbfe:	4630      	mov	r0, r6
 801fc00:	f7ff fbf8 	bl	801f3f4 <traceIF_uartPrint>
 801fc04:	e7be      	b.n	801fb84 <traceIF_BufHexPrint+0x10>
    }
  }

  /* Force to go to next line to prepare next trace */
  TRACE_PRINT(chan, level, "\n\r")
 801fc06:	4b10      	ldr	r3, [pc, #64]	; (801fc48 <traceIF_BufHexPrint+0xd4>)
 801fc08:	0231      	lsls	r1, r6, #8
 801fc0a:	eb03 2406 	add.w	r4, r3, r6, lsl #8
 801fc0e:	4a0d      	ldr	r2, [pc, #52]	; (801fc44 <traceIF_BufHexPrint+0xd0>)
 801fc10:	8810      	ldrh	r0, [r2, #0]
 801fc12:	7892      	ldrb	r2, [r2, #2]
 801fc14:	5258      	strh	r0, [r3, r1]
 801fc16:	70a2      	strb	r2, [r4, #2]
 801fc18:	4620      	mov	r0, r4
 801fc1a:	f7ff fb86 	bl	801f32a <crs_strlen>
 801fc1e:	b283      	uxth	r3, r0
 801fc20:	4622      	mov	r2, r4
 801fc22:	4639      	mov	r1, r7
 801fc24:	4630      	mov	r0, r6
 801fc26:	f7ff fbc3 	bl	801f3b0 <traceIF_itmPrint>
 801fc2a:	4620      	mov	r0, r4
 801fc2c:	f7ff fb7d 	bl	801f32a <crs_strlen>
 801fc30:	b283      	uxth	r3, r0
 801fc32:	4622      	mov	r2, r4
 801fc34:	4639      	mov	r1, r7
 801fc36:	4630      	mov	r0, r6
 801fc38:	f7ff fbdc 	bl	801f3f4 <traceIF_uartPrint>
}
 801fc3c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fc40:	08035e98 	.word	0x08035e98
 801fc44:	0802eac4 	.word	0x0802eac4
 801fc48:	200046dc 	.word	0x200046dc

0801fc4c <traceIF_init>:
  *         - before using any other functions of traceIF_*
  * @param  -
  * @retval -
  */
void traceIF_init(void)
{
 801fc4c:	b508      	push	{r3, lr}
#if (RTOS_USED == 1)
  /* Multi call protection */
  if (traceIF_uart_mutex == NULL)
 801fc4e:	4b05      	ldr	r3, [pc, #20]	; (801fc64 <traceIF_init+0x18>)
 801fc50:	681b      	ldr	r3, [r3, #0]
 801fc52:	b103      	cbz	r3, 801fc56 <traceIF_init+0xa>
  }
#else
  /* Nothing to do in no RTOS used */
  __NOP();
#endif /* (RTOS_USED == 1) */
}
 801fc54:	bd08      	pop	{r3, pc}
    traceIF_uart_mutex = rtosalMutexNew(NULL);
 801fc56:	2000      	movs	r0, #0
 801fc58:	f7ff fa77 	bl	801f14a <rtosalMutexNew>
 801fc5c:	4b01      	ldr	r3, [pc, #4]	; (801fc64 <traceIF_init+0x18>)
 801fc5e:	6018      	str	r0, [r3, #0]
}
 801fc60:	e7f8      	b.n	801fc54 <traceIF_init+0x8>
 801fc62:	bf00      	nop
 801fc64:	200054dc 	.word	0x200054dc

0801fc68 <traceIF_start>:
            and before using any other functions of traceIF_*
  * @param  -
  * @retval -
  */
void traceIF_start(void)
{
 801fc68:	b508      	push	{r3, lr}
#if (USE_CMD_CONSOLE == 1)
#if (SW_DEBUG_VERSION == 1)
  /* Registration to cmd module to support cmd 'trace' */
  CMD_Declare((uint8_t *)"trace", traceIF_cmd, (uint8_t *)"trace management");
 801fc6a:	4a03      	ldr	r2, [pc, #12]	; (801fc78 <traceIF_start+0x10>)
 801fc6c:	4903      	ldr	r1, [pc, #12]	; (801fc7c <traceIF_start+0x14>)
 801fc6e:	4804      	ldr	r0, [pc, #16]	; (801fc80 <traceIF_start+0x18>)
 801fc70:	f002 fe42 	bl	80228f8 <CMD_Declare>
#endif /* SW_DEBUG_VERSION == 1 */
#endif /* USE_CMD_CONSOLE == 1 */
}
 801fc74:	bd08      	pop	{r3, pc}
 801fc76:	bf00      	nop
 801fc78:	08035ea0 	.word	0x08035ea0
 801fc7c:	0801f6e1 	.word	0x0801f6e1
 801fc80:	08035c08 	.word	0x08035c08

0801fc84 <cellular_datacache_init>:
  * @brief  Initialize all cellular entries of Data Cache
  * @param  -
  * @retval -
  */
static void cellular_datacache_init(void)
{
 801fc84:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  static dc_apn_config_t             dc_apn_config;
#if (USE_LOW_POWER == 1)
  static dc_cellular_power_config_t  dc_cellular_power_config;
#endif  /* (USE_LOW_POWER == 1) */

  (void)memset((void *)&dc_cellular_info,         0, sizeof(dc_cellular_info_t));
 801fc88:	f04f 0bf4 	mov.w	fp, #244	; 0xf4
 801fc8c:	465a      	mov	r2, fp
 801fc8e:	2100      	movs	r1, #0
 801fc90:	4836      	ldr	r0, [pc, #216]	; (801fd6c <cellular_datacache_init+0xe8>)
 801fc92:	f006 fe4c 	bl	802692e <memset>
  (void)memset((void *)&dc_ppp_client_info,       0, sizeof(dc_ppp_client_info_t));
 801fc96:	4b36      	ldr	r3, [pc, #216]	; (801fd70 <cellular_datacache_init+0xec>)
 801fc98:	2400      	movs	r4, #0
 801fc9a:	601c      	str	r4, [r3, #0]
 801fc9c:	605c      	str	r4, [r3, #4]
 801fc9e:	609c      	str	r4, [r3, #8]
 801fca0:	60dc      	str	r4, [r3, #12]
 801fca2:	611c      	str	r4, [r3, #16]
 801fca4:	615c      	str	r4, [r3, #20]
  (void)memset((void *)&dc_cellular_data_info,    0, sizeof(dc_cellular_data_info_t));
 801fca6:	4e33      	ldr	r6, [pc, #204]	; (801fd74 <cellular_datacache_init+0xf0>)
 801fca8:	6034      	str	r4, [r6, #0]
 801fcaa:	6074      	str	r4, [r6, #4]
 801fcac:	60b4      	str	r4, [r6, #8]
 801fcae:	60f4      	str	r4, [r6, #12]
  (void)memset((void *)&dc_nifman_info,           0, sizeof(dc_nifman_info_t));
 801fcb0:	4d31      	ldr	r5, [pc, #196]	; (801fd78 <cellular_datacache_init+0xf4>)
 801fcb2:	602c      	str	r4, [r5, #0]
 801fcb4:	606c      	str	r4, [r5, #4]
 801fcb6:	60ac      	str	r4, [r5, #8]
 801fcb8:	60ec      	str	r4, [r5, #12]
  (void)memset((void *)&dc_nfmc_info,             0, sizeof(dc_nfmc_info_t));
 801fcba:	f04f 092c 	mov.w	r9, #44	; 0x2c
 801fcbe:	464a      	mov	r2, r9
 801fcc0:	4621      	mov	r1, r4
 801fcc2:	482e      	ldr	r0, [pc, #184]	; (801fd7c <cellular_datacache_init+0xf8>)
 801fcc4:	f006 fe33 	bl	802692e <memset>
  (void)memset((void *)&dc_sim_info,              0, sizeof(dc_sim_info_t));
 801fcc8:	2230      	movs	r2, #48	; 0x30
 801fcca:	4621      	mov	r1, r4
 801fccc:	482c      	ldr	r0, [pc, #176]	; (801fd80 <cellular_datacache_init+0xfc>)
 801fcce:	f006 fe2e 	bl	802692e <memset>
  (void)memset((void *)&dc_cellular_params,       0, sizeof(dc_cellular_params_t));
 801fcd2:	f44f 7ad0 	mov.w	sl, #416	; 0x1a0
 801fcd6:	4652      	mov	r2, sl
 801fcd8:	4621      	mov	r1, r4
 801fcda:	482a      	ldr	r0, [pc, #168]	; (801fd84 <cellular_datacache_init+0x100>)
 801fcdc:	f006 fe27 	bl	802692e <memset>
  (void)memset((void *)&dc_cellular_target_state, 0, sizeof(dc_cellular_target_state_t));
 801fce0:	4f29      	ldr	r7, [pc, #164]	; (801fd88 <cellular_datacache_init+0x104>)
 801fce2:	603c      	str	r4, [r7, #0]
 801fce4:	607c      	str	r4, [r7, #4]
 801fce6:	60bc      	str	r4, [r7, #8]
  (void)memset((void *)&dc_apn_config,            0, sizeof(dc_apn_config_t));
 801fce8:	f04f 086c 	mov.w	r8, #108	; 0x6c
 801fcec:	4642      	mov	r2, r8
 801fcee:	4621      	mov	r1, r4
 801fcf0:	4826      	ldr	r0, [pc, #152]	; (801fd8c <cellular_datacache_init+0x108>)
 801fcf2:	f006 fe1c 	bl	802692e <memset>
#if (USE_LOW_POWER == 1)
  (void)memset((void *)&dc_cellular_power_config, 0, sizeof(dc_cellular_power_config_t));
#endif  /* (USE_LOW_POWER == 1) */

  /* register all all cellular entries of Data Cache */
  DC_CELLULAR_INFO             = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_info,
 801fcf6:	4c26      	ldr	r4, [pc, #152]	; (801fd90 <cellular_datacache_init+0x10c>)
 801fcf8:	465a      	mov	r2, fp
 801fcfa:	491c      	ldr	r1, [pc, #112]	; (801fd6c <cellular_datacache_init+0xe8>)
 801fcfc:	4620      	mov	r0, r4
 801fcfe:	f002 f967 	bl	8021fd0 <dc_com_register_serv>
 801fd02:	4b24      	ldr	r3, [pc, #144]	; (801fd94 <cellular_datacache_init+0x110>)
 801fd04:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_info_t));
  DC_CELLULAR_DATA_INFO        = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_data_info,
 801fd06:	2210      	movs	r2, #16
 801fd08:	4631      	mov	r1, r6
 801fd0a:	4620      	mov	r0, r4
 801fd0c:	f002 f960 	bl	8021fd0 <dc_com_register_serv>
 801fd10:	4b21      	ldr	r3, [pc, #132]	; (801fd98 <cellular_datacache_init+0x114>)
 801fd12:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_data_info_t));
  DC_CELLULAR_NIFMAN_INFO      = dc_com_register_serv(&dc_com_db, (void *)&dc_nifman_info,
 801fd14:	2210      	movs	r2, #16
 801fd16:	4629      	mov	r1, r5
 801fd18:	4620      	mov	r0, r4
 801fd1a:	f002 f959 	bl	8021fd0 <dc_com_register_serv>
 801fd1e:	4b1f      	ldr	r3, [pc, #124]	; (801fd9c <cellular_datacache_init+0x118>)
 801fd20:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_nifman_info_t));
  DC_CELLULAR_NFMC_INFO        = dc_com_register_serv(&dc_com_db, (void *)&dc_nfmc_info,
 801fd22:	464a      	mov	r2, r9
 801fd24:	4915      	ldr	r1, [pc, #84]	; (801fd7c <cellular_datacache_init+0xf8>)
 801fd26:	4620      	mov	r0, r4
 801fd28:	f002 f952 	bl	8021fd0 <dc_com_register_serv>
 801fd2c:	4b1c      	ldr	r3, [pc, #112]	; (801fda0 <cellular_datacache_init+0x11c>)
 801fd2e:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_nfmc_info_t));
  DC_CELLULAR_SIM_INFO         = dc_com_register_serv(&dc_com_db, (void *)&dc_sim_info,
 801fd30:	2230      	movs	r2, #48	; 0x30
 801fd32:	4913      	ldr	r1, [pc, #76]	; (801fd80 <cellular_datacache_init+0xfc>)
 801fd34:	4620      	mov	r0, r4
 801fd36:	f002 f94b 	bl	8021fd0 <dc_com_register_serv>
 801fd3a:	4b1a      	ldr	r3, [pc, #104]	; (801fda4 <cellular_datacache_init+0x120>)
 801fd3c:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_sim_info_t));
  DC_CELLULAR_CONFIG           = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_params,
 801fd3e:	4652      	mov	r2, sl
 801fd40:	4910      	ldr	r1, [pc, #64]	; (801fd84 <cellular_datacache_init+0x100>)
 801fd42:	4620      	mov	r0, r4
 801fd44:	f002 f944 	bl	8021fd0 <dc_com_register_serv>
 801fd48:	4b17      	ldr	r3, [pc, #92]	; (801fda8 <cellular_datacache_init+0x124>)
 801fd4a:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_params_t));
  DC_CELLULAR_TARGET_STATE_CMD = dc_com_register_serv(&dc_com_db, (void *)&dc_cellular_target_state,
 801fd4c:	220c      	movs	r2, #12
 801fd4e:	4639      	mov	r1, r7
 801fd50:	4620      	mov	r0, r4
 801fd52:	f002 f93d 	bl	8021fd0 <dc_com_register_serv>
 801fd56:	4b15      	ldr	r3, [pc, #84]	; (801fdac <cellular_datacache_init+0x128>)
 801fd58:	8018      	strh	r0, [r3, #0]
                                                      (uint16_t)sizeof(dc_cellular_target_state_t));
  DC_CELLULAR_APN_CONFIG       = dc_com_register_serv(&dc_com_db, (void *)&dc_apn_config,
 801fd5a:	4642      	mov	r2, r8
 801fd5c:	490b      	ldr	r1, [pc, #44]	; (801fd8c <cellular_datacache_init+0x108>)
 801fd5e:	4620      	mov	r0, r4
 801fd60:	f002 f936 	bl	8021fd0 <dc_com_register_serv>
 801fd64:	4b12      	ldr	r3, [pc, #72]	; (801fdb0 <cellular_datacache_init+0x12c>)
 801fd66:	8018      	strh	r0, [r3, #0]
#endif  /* (USE_LOW_POWER == 1) */
#if (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP)
  DC_PPP_CLIENT_INFO           = dc_com_register_serv(&dc_com_db, (void *)&dc_ppp_client_info,
                                                      (uint16_t)sizeof(dc_ppp_client_info_t));
#endif   /* (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP) */
}
 801fd68:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801fd6c:	2000555c 	.word	0x2000555c
 801fd70:	20005838 	.word	0x20005838
 801fd74:	2000554c 	.word	0x2000554c
 801fd78:	20005828 	.word	0x20005828
 801fd7c:	200057fc 	.word	0x200057fc
 801fd80:	20005850 	.word	0x20005850
 801fd84:	20005650 	.word	0x20005650
 801fd88:	200057f0 	.word	0x200057f0
 801fd8c:	200054e0 	.word	0x200054e0
 801fd90:	200058b0 	.word	0x200058b0
 801fd94:	20000236 	.word	0x20000236
 801fd98:	20000234 	.word	0x20000234
 801fd9c:	2000023a 	.word	0x2000023a
 801fda0:	20000238 	.word	0x20000238
 801fda4:	2000023c 	.word	0x2000023c
 801fda8:	20000232 	.word	0x20000232
 801fdac:	2000023e 	.word	0x2000023e
 801fdb0:	20000230 	.word	0x20000230

0801fdb4 <cellular_init>:
  * @brief  Initialize cellular features
  * @param  -
  * @retval -
  */
void cellular_init(void)
{
 801fdb4:	b508      	push	{r3, lr}
#if (USE_PRINTF == 0U)
  /* Error Handler in the modules below may use trace print */
  /* Recall traceIF_init() in case StartDefaultTask is not used or is redefined */
  traceIF_init();
 801fdb6:	f7ff ff49 	bl	801fc4c <traceIF_init>
  /* Recall stackAnalysis_init() in case StartDefaultTask is not used or is redefined */
  stackAnalysis_init();
#endif /* USE_STACK_ANALYSIS == 1 */

  /* Data Cache initialization */
  (void)dc_com_init(&dc_com_db);
 801fdba:	4805      	ldr	r0, [pc, #20]	; (801fdd0 <cellular_init+0x1c>)
 801fdbc:	f002 f9d6 	bl	802216c <dc_com_init>

  /* cellular entries of Data Cache initialization */
  cellular_datacache_init();
 801fdc0:	f7ff ff60 	bl	801fc84 <cellular_datacache_init>

  /* communication interface initialization */
  (void)com_init();
 801fdc4:	f000 f816 	bl	801fdf4 <com_init>

  /* cellular service initialization */
  (void)CST_cellular_service_init();
 801fdc8:	f7fc fde2 	bl	801c990 <CST_cellular_service_init>

#if (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP)
  /* if LWIP is used, PPP component initialization */
  (void)ppposif_client_init();
#endif  /* (USE_SOCKETS_TYPE == USE_SOCKETS_LWIP) */
}
 801fdcc:	bd08      	pop	{r3, pc}
 801fdce:	bf00      	nop
 801fdd0:	200058b0 	.word	0x200058b0

0801fdd4 <cellular_start>:
  * @brief  Start cellular features with boot modem and network registration
  * @param  -
  * @retval -
  */
void cellular_start(void)
{
 801fdd4:	b508      	push	{r3, lr}
#if (USE_PRINTF == 0U)
  traceIF_start();
 801fdd6:	f7ff ff47 	bl	801fc68 <traceIF_start>

#if (USE_STACK_ANALYSIS == 1)
  stackAnalysis_start();
#endif /* USE_STACK_ANALYSIS == 1 */

  dc_com_start(&dc_com_db);
 801fdda:	4805      	ldr	r0, [pc, #20]	; (801fdf0 <cellular_start+0x1c>)
 801fddc:	f002 f9da 	bl	8022194 <dc_com_start>

#if (USE_LOW_POWER == 1)
  CSP_Start();
#endif  /* (USE_LOW_POWER == 1) */
  (void)com_start();
 801fde0:	f000 f814 	bl	801fe0c <com_start>
#if defined(AT_TEST)
  at_modem_start();
#endif   /* defined(AT_TEST) */

#if !defined(AT_TEST)
  (void)CST_cellular_service_start();
 801fde4:	f7fc fe02 	bl	801c9ec <CST_cellular_service_start>
#endif  /* !defined(AT_TEST) */

#if !defined(AT_TEST)
  (void)CST_radio_on();
 801fde8:	f7fc fc7c 	bl	801c6e4 <CST_radio_on>
#endif   /*  !defined(AT_TEST) */
}
 801fdec:	bd08      	pop	{r3, pc}
 801fdee:	bf00      	nop
 801fdf0:	200058b0 	.word	0x200058b0

0801fdf4 <com_init>:
  *         - before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_init(void)
{
 801fdf4:	b510      	push	{r4, lr}
  bool init_socket, init_icc, result;

  /* Init socket services */
  init_socket = com_sockets_init();
 801fdf6:	f000 f9cb 	bl	8020190 <com_sockets_init>
 801fdfa:	4604      	mov	r4, r0

  /* Init icc services */
#if (USE_COM_ICC == 1)
  init_icc    = com_icc_init();
 801fdfc:	f000 f8a8 	bl	801ff50 <com_icc_init>
#else /* USE_COM_ICC == 0 */
  init_icc    = true;
#endif /* USE_COM_ICC == 1 */

  result = true;
  if ((init_socket == false)
 801fe00:	b114      	cbz	r4, 801fe08 <com_init+0x14>
      || (init_icc == false))
 801fe02:	b910      	cbnz	r0, 801fe0a <com_init+0x16>
  {
    result = false;
 801fe04:	2000      	movs	r0, #0
 801fe06:	e000      	b.n	801fe0a <com_init+0x16>
 801fe08:	2000      	movs	r0, #0
  }

  return (result);
}
 801fe0a:	bd10      	pop	{r4, pc}

0801fe0c <com_start>:
            and before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false start ok/nok
  */
bool com_start(void)
{
 801fe0c:	b508      	push	{r3, lr}
  bool result;

  result = true;

  /* Start socket services */
  com_sockets_start();
 801fe0e:	f000 f9c9 	bl	80201a4 <com_sockets_start>

#if (USE_COM_ICC == 1)
  /* Start icc services */
  com_icc_start();
 801fe12:	f000 f8c7 	bl	801ffa4 <com_icc_start>
#endif /* USE_COM_ICC == 1 */

  return (result);
}
 801fe16:	2001      	movs	r0, #1
 801fe18:	bd08      	pop	{r3, pc}
	...

0801fe1c <com_icc_init_icc_desc>:
  * @note   Supported values: COM_PROTO_CSIM : communication with ICC using AT+CSIM command
  *                           COM_PROTO_NDLC : communication with ICC using NDLC command
  * @retval -
  */
static void com_icc_init_icc_desc(uint8_t icc_index, uint8_t protocol)
{
 801fe1c:	b570      	push	{r4, r5, r6, lr}
 801fe1e:	4604      	mov	r4, r0
 801fe20:	460d      	mov	r5, r1
  /* Protect Icc descriptor access */
  (void)rtosalMutexAcquire(ComIccMutexHandle, RTOSAL_WAIT_FOREVER);
 801fe22:	4e0a      	ldr	r6, [pc, #40]	; (801fe4c <com_icc_init_icc_desc+0x30>)
 801fe24:	f04f 31ff 	mov.w	r1, #4294967295
 801fe28:	6830      	ldr	r0, [r6, #0]
 801fe2a:	f7ff f998 	bl	801f15e <rtosalMutexAcquire>

  com_icc_desc[icc_index].state     = COM_ICC_INVALID;
 801fe2e:	4808      	ldr	r0, [pc, #32]	; (801fe50 <com_icc_init_icc_desc+0x34>)
 801fe30:	2200      	movs	r2, #0
 801fe32:	f800 2034 	strb.w	r2, [r0, r4, lsl #3]
  com_icc_desc[icc_index].protocol  = protocol;
 801fe36:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
 801fe3a:	7045      	strb	r5, [r0, #1]
  com_icc_desc[icc_index].handle    = COM_HANDLE_INVALID_ID;
 801fe3c:	f04f 33ff 	mov.w	r3, #4294967295
 801fe40:	6043      	str	r3, [r0, #4]

  /* Access to Icc descriptor finished */
  (void)rtosalMutexRelease(ComIccMutexHandle);
 801fe42:	6830      	ldr	r0, [r6, #0]
 801fe44:	f7ff f98f 	bl	801f166 <rtosalMutexRelease>
}
 801fe48:	bd70      	pop	{r4, r5, r6, pc}
 801fe4a:	bf00      	nop
 801fe4c:	20005880 	.word	0x20005880
 801fe50:	20005884 	.word	0x20005884

0801fe54 <com_icc_datacache_cb>:
{
 801fe54:	b510      	push	{r4, lr}
 801fe56:	b0c0      	sub	sp, #256	; 0x100
  if (dc_event_id == DC_CELLULAR_SIM_INFO)
 801fe58:	4b35      	ldr	r3, [pc, #212]	; (801ff30 <com_icc_datacache_cb+0xdc>)
 801fe5a:	8819      	ldrh	r1, [r3, #0]
 801fe5c:	4288      	cmp	r0, r1
 801fe5e:	d006      	beq.n	801fe6e <com_icc_datacache_cb+0x1a>
  else if (dc_event_id == DC_CELLULAR_INFO)
 801fe60:	4b34      	ldr	r3, [pc, #208]	; (801ff34 <com_icc_datacache_cb+0xe0>)
 801fe62:	8819      	ldrh	r1, [r3, #0]
 801fe64:	4288      	cmp	r0, r1
 801fe66:	d046      	beq.n	801fef6 <com_icc_datacache_cb+0xa2>
    __NOP();
 801fe68:	bf00      	nop
}
 801fe6a:	b040      	add	sp, #256	; 0x100
 801fe6c:	bd10      	pop	{r4, pc}
    com_icc_is_available[0] = false;
 801fe6e:	2300      	movs	r3, #0
 801fe70:	4a31      	ldr	r2, [pc, #196]	; (801ff38 <com_icc_datacache_cb+0xe4>)
 801fe72:	7013      	strb	r3, [r2, #0]
    com_icc_is_power_on[0] = false;
 801fe74:	4a31      	ldr	r2, [pc, #196]	; (801ff3c <com_icc_datacache_cb+0xe8>)
 801fe76:	7013      	strb	r3, [r2, #0]
    com_icc_is_initialized[0] = false;
 801fe78:	4a31      	ldr	r2, [pc, #196]	; (801ff40 <com_icc_datacache_cb+0xec>)
 801fe7a:	7013      	strb	r3, [r2, #0]
    if (dc_com_read(&dc_com_db, DC_CELLULAR_SIM_INFO, (void *)&dc_sim_rt_info, sizeof(dc_sim_rt_info))
 801fe7c:	2330      	movs	r3, #48	; 0x30
 801fe7e:	aa03      	add	r2, sp, #12
 801fe80:	4830      	ldr	r0, [pc, #192]	; (801ff44 <com_icc_datacache_cb+0xf0>)
 801fe82:	f002 f955 	bl	8022130 <dc_com_read>
 801fe86:	2800      	cmp	r0, #0
 801fe88:	d0ef      	beq.n	801fe6a <com_icc_datacache_cb+0x16>
      PRINT_DBG("sim state: rt_state:%d index_slot:%d sim_status:%d",
 801fe8a:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 801fe8e:	f503 7280 	add.w	r2, r3, #256	; 0x100
 801fe92:	446a      	add	r2, sp
 801fe94:	f812 2cc9 	ldrb.w	r2, [r2, #-201]
 801fe98:	4c2b      	ldr	r4, [pc, #172]	; (801ff48 <com_icc_datacache_cb+0xf4>)
 801fe9a:	9200      	str	r2, [sp, #0]
 801fe9c:	f89d 2014 	ldrb.w	r2, [sp, #20]
 801fea0:	492a      	ldr	r1, [pc, #168]	; (801ff4c <com_icc_datacache_cb+0xf8>)
 801fea2:	4620      	mov	r0, r4
 801fea4:	f006 fcd0 	bl	8026848 <sprintf>
 801fea8:	4620      	mov	r0, r4
 801feaa:	f7ff fa3e 	bl	801f32a <crs_strlen>
 801feae:	b283      	uxth	r3, r0
 801feb0:	4622      	mov	r2, r4
 801feb2:	2102      	movs	r1, #2
 801feb4:	2003      	movs	r0, #3
 801feb6:	f7ff fa7b 	bl	801f3b0 <traceIF_itmPrint>
 801feba:	4620      	mov	r0, r4
 801febc:	f7ff fa35 	bl	801f32a <crs_strlen>
 801fec0:	b283      	uxth	r3, r0
 801fec2:	4622      	mov	r2, r4
 801fec4:	2102      	movs	r1, #2
 801fec6:	2003      	movs	r0, #3
 801fec8:	f7ff fa94 	bl	801f3f4 <traceIF_uartPrint>
      if (dc_sim_rt_info.rt_state == DC_SERVICE_ON)
 801fecc:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801fed0:	2b07      	cmp	r3, #7
 801fed2:	d1ca      	bne.n	801fe6a <com_icc_datacache_cb+0x16>
        if (dc_sim_rt_info.sim_status[dc_sim_rt_info.index_slot] == DC_SIM_OK)
 801fed4:	f89d 3035 	ldrb.w	r3, [sp, #53]	; 0x35
 801fed8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 801fedc:	446b      	add	r3, sp
 801fede:	f813 3cc9 	ldrb.w	r3, [r3, #-201]
 801fee2:	2b00      	cmp	r3, #0
 801fee4:	d1c1      	bne.n	801fe6a <com_icc_datacache_cb+0x16>
          com_icc_is_available[0]   = true;
 801fee6:	2301      	movs	r3, #1
 801fee8:	4a13      	ldr	r2, [pc, #76]	; (801ff38 <com_icc_datacache_cb+0xe4>)
 801feea:	7013      	strb	r3, [r2, #0]
          com_icc_is_initialized[0] = true;
 801feec:	4a14      	ldr	r2, [pc, #80]	; (801ff40 <com_icc_datacache_cb+0xec>)
 801feee:	7013      	strb	r3, [r2, #0]
          com_icc_is_power_on[0]    = true;
 801fef0:	4a12      	ldr	r2, [pc, #72]	; (801ff3c <com_icc_datacache_cb+0xe8>)
 801fef2:	7013      	strb	r3, [r2, #0]
 801fef4:	e7b9      	b.n	801fe6a <com_icc_datacache_cb+0x16>
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_INFO, (void *)&dc_cellular_info, sizeof(dc_cellular_info));
 801fef6:	23f4      	movs	r3, #244	; 0xf4
 801fef8:	aa03      	add	r2, sp, #12
 801fefa:	4812      	ldr	r0, [pc, #72]	; (801ff44 <com_icc_datacache_cb+0xf0>)
 801fefc:	f002 f918 	bl	8022130 <dc_com_read>
    if (dc_cellular_info.modem_state == DC_MODEM_STATE_OFF)
 801ff00:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801ff04:	b163      	cbz	r3, 801ff20 <com_icc_datacache_cb+0xcc>
    else if (dc_cellular_info.modem_state == DC_MODEM_STATE_POWERED_ON)
 801ff06:	2b01      	cmp	r3, #1
 801ff08:	d00d      	beq.n	801ff26 <com_icc_datacache_cb+0xd2>
      __NOP();
 801ff0a:	bf00      	nop
 801ff0c:	e7ad      	b.n	801fe6a <com_icc_datacache_cb+0x16>
        com_icc_is_available[i]   = false;
 801ff0e:	2200      	movs	r2, #0
 801ff10:	4909      	ldr	r1, [pc, #36]	; (801ff38 <com_icc_datacache_cb+0xe4>)
 801ff12:	54ca      	strb	r2, [r1, r3]
        com_icc_is_initialized[i] = false;
 801ff14:	490a      	ldr	r1, [pc, #40]	; (801ff40 <com_icc_datacache_cb+0xec>)
 801ff16:	54ca      	strb	r2, [r1, r3]
        com_icc_is_power_on[i]    = false;
 801ff18:	4908      	ldr	r1, [pc, #32]	; (801ff3c <com_icc_datacache_cb+0xe8>)
 801ff1a:	54ca      	strb	r2, [r1, r3]
      for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801ff1c:	3301      	adds	r3, #1
 801ff1e:	b2db      	uxtb	r3, r3
 801ff20:	2b01      	cmp	r3, #1
 801ff22:	d9f4      	bls.n	801ff0e <com_icc_datacache_cb+0xba>
 801ff24:	e7a1      	b.n	801fe6a <com_icc_datacache_cb+0x16>
      com_icc_is_available[1]   = true;
 801ff26:	4b04      	ldr	r3, [pc, #16]	; (801ff38 <com_icc_datacache_cb+0xe4>)
 801ff28:	2201      	movs	r2, #1
 801ff2a:	705a      	strb	r2, [r3, #1]
 801ff2c:	e79d      	b.n	801fe6a <com_icc_datacache_cb+0x16>
 801ff2e:	bf00      	nop
 801ff30:	2000023c 	.word	0x2000023c
 801ff34:	20000236 	.word	0x20000236
 801ff38:	20005894 	.word	0x20005894
 801ff3c:	2000589c 	.word	0x2000589c
 801ff40:	20005898 	.word	0x20005898
 801ff44:	200058b0 	.word	0x200058b0
 801ff48:	200049dc 	.word	0x200049dc
 801ff4c:	08035f58 	.word	0x08035f58

0801ff50 <com_icc_init>:
  *         - before using any other functions of com_icc*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_icc_init(void)
{
 801ff50:	b510      	push	{r4, lr}
  bool result = true;

  /* Initialize ICC availability */
  for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801ff52:	2300      	movs	r3, #0
 801ff54:	e008      	b.n	801ff68 <com_icc_init+0x18>
  {
    com_icc_is_available[i]   = false;
 801ff56:	2200      	movs	r2, #0
 801ff58:	490e      	ldr	r1, [pc, #56]	; (801ff94 <com_icc_init+0x44>)
 801ff5a:	54ca      	strb	r2, [r1, r3]
    com_icc_is_initialized[i] = false;
 801ff5c:	490e      	ldr	r1, [pc, #56]	; (801ff98 <com_icc_init+0x48>)
 801ff5e:	54ca      	strb	r2, [r1, r3]
    com_icc_is_power_on[i]    = false;
 801ff60:	490e      	ldr	r1, [pc, #56]	; (801ff9c <com_icc_init+0x4c>)
 801ff62:	54ca      	strb	r2, [r1, r3]
  for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801ff64:	3301      	adds	r3, #1
 801ff66:	b2db      	uxtb	r3, r3
 801ff68:	2b01      	cmp	r3, #1
 801ff6a:	d9f4      	bls.n	801ff56 <com_icc_init+0x6>
  }

  /* Initialize Mutex to protect ICC handle descriptor access */
  ComIccMutexHandle = rtosalMutexNew(NULL);
 801ff6c:	2000      	movs	r0, #0
 801ff6e:	f7ff f8ec 	bl	801f14a <rtosalMutexNew>
 801ff72:	4b0b      	ldr	r3, [pc, #44]	; (801ffa0 <com_icc_init+0x50>)
 801ff74:	6018      	str	r0, [r3, #0]
  if (ComIccMutexHandle != NULL)
 801ff76:	b160      	cbz	r0, 801ff92 <com_icc_init+0x42>
  {
    for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801ff78:	2400      	movs	r4, #0
 801ff7a:	e007      	b.n	801ff8c <com_icc_init+0x3c>
    {
      com_icc_init_icc_desc(i, ((uint8_t)COM_PROTO_CSIM + i));
 801ff7c:	f1a4 016f 	sub.w	r1, r4, #111	; 0x6f
 801ff80:	b2c9      	uxtb	r1, r1
 801ff82:	4620      	mov	r0, r4
 801ff84:	f7ff ff4a 	bl	801fe1c <com_icc_init_icc_desc>
    for (uint8_t i = 0U; i < COM_ICC_SESSION_MAX_NB; i++)
 801ff88:	3401      	adds	r4, #1
 801ff8a:	b2e4      	uxtb	r4, r4
 801ff8c:	2c01      	cmp	r4, #1
 801ff8e:	d9f5      	bls.n	801ff7c <com_icc_init+0x2c>
  bool result = true;
 801ff90:	2001      	movs	r0, #1
  {
    result = false;
  }

  return (result);
}
 801ff92:	bd10      	pop	{r4, pc}
 801ff94:	20005894 	.word	0x20005894
 801ff98:	20005898 	.word	0x20005898
 801ff9c:	2000589c 	.word	0x2000589c
 801ffa0:	20005880 	.word	0x20005880

0801ffa4 <com_icc_start>:
            - and before using any other functions of com_icc_*
  * @param  -
  * @retval -
  */
void com_icc_start(void)
{
 801ffa4:	b508      	push	{r3, lr}
#if (USE_DATACACHE == 1)
  /* Datacache registration for icc status */
  (void)dc_com_register_gen_event_cb(&dc_com_db, com_icc_datacache_cb, (void *)NULL);
 801ffa6:	2200      	movs	r2, #0
 801ffa8:	4902      	ldr	r1, [pc, #8]	; (801ffb4 <com_icc_start+0x10>)
 801ffaa:	4803      	ldr	r0, [pc, #12]	; (801ffb8 <com_icc_start+0x14>)
 801ffac:	f002 f844 	bl	8022038 <dc_com_register_gen_event_cb>
#endif /* USE_DATACACHE == 1 */
}
 801ffb0:	bd08      	pop	{r3, pc}
 801ffb2:	bf00      	nop
 801ffb4:	0801fe55 	.word	0x0801fe55
 801ffb8:	200058b0 	.word	0x200058b0

0801ffbc <com_help_cmd>:
  * @param  -
  * @note   -
  * @retval -
  */
static void com_help_cmd(void)
{
 801ffbc:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help((uint8_t *)"com");
 801ffbe:	481c      	ldr	r0, [pc, #112]	; (8020030 <com_help_cmd+0x74>)
 801ffc0:	f002 fcfa 	bl	80229b8 <CMD_print_help>
  PRINT_FORCE("comsocket help")
 801ffc4:	4c1b      	ldr	r4, [pc, #108]	; (8020034 <com_help_cmd+0x78>)
 801ffc6:	4d1c      	ldr	r5, [pc, #112]	; (8020038 <com_help_cmd+0x7c>)
 801ffc8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801ffca:	6020      	str	r0, [r4, #0]
 801ffcc:	6061      	str	r1, [r4, #4]
 801ffce:	60a2      	str	r2, [r4, #8]
 801ffd0:	60e3      	str	r3, [r4, #12]
 801ffd2:	782b      	ldrb	r3, [r5, #0]
 801ffd4:	7423      	strb	r3, [r4, #16]
 801ffd6:	4620      	mov	r0, r4
 801ffd8:	f7ff f9a7 	bl	801f32a <crs_strlen>
 801ffdc:	b283      	uxth	r3, r0
 801ffde:	4622      	mov	r2, r4
 801ffe0:	2101      	movs	r1, #1
 801ffe2:	2003      	movs	r0, #3
 801ffe4:	f7ff f9e4 	bl	801f3b0 <traceIF_itmPrint>
 801ffe8:	4620      	mov	r0, r4
 801ffea:	f7ff f99e 	bl	801f32a <crs_strlen>
 801ffee:	b282      	uxth	r2, r0
 801fff0:	4621      	mov	r1, r4
 801fff2:	2003      	movs	r0, #3
 801fff4:	f7ff fa16 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("comsocket stat\n\r")
 801fff8:	4d10      	ldr	r5, [pc, #64]	; (802003c <com_help_cmd+0x80>)
 801fffa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801fffc:	6020      	str	r0, [r4, #0]
 801fffe:	6061      	str	r1, [r4, #4]
 8020000:	60a2      	str	r2, [r4, #8]
 8020002:	60e3      	str	r3, [r4, #12]
 8020004:	882a      	ldrh	r2, [r5, #0]
 8020006:	78ab      	ldrb	r3, [r5, #2]
 8020008:	8222      	strh	r2, [r4, #16]
 802000a:	74a3      	strb	r3, [r4, #18]
 802000c:	4620      	mov	r0, r4
 802000e:	f7ff f98c 	bl	801f32a <crs_strlen>
 8020012:	b283      	uxth	r3, r0
 8020014:	4622      	mov	r2, r4
 8020016:	2101      	movs	r1, #1
 8020018:	2003      	movs	r0, #3
 802001a:	f7ff f9c9 	bl	801f3b0 <traceIF_itmPrint>
 802001e:	4620      	mov	r0, r4
 8020020:	f7ff f983 	bl	801f32a <crs_strlen>
 8020024:	b282      	uxth	r2, r0
 8020026:	4621      	mov	r1, r4
 8020028:	2003      	movs	r0, #3
 802002a:	f7ff f9fb 	bl	801f424 <traceIF_uartPrintForce>
}
 802002e:	bd38      	pop	{r3, r4, r5, pc}
 8020030:	08035f98 	.word	0x08035f98
 8020034:	200049dc 	.word	0x200049dc
 8020038:	08035f9c 	.word	0x08035f9c
 802003c:	08035fb0 	.word	0x08035fb0

08020040 <com_sockets_cmd>:
  * @param  cmd_line_p - command line
  * @note   command parameters
  * @retval cmd_status_t - status of cmd management
  */
static cmd_status_t com_sockets_cmd(uint8_t *cmd_line_p)
{
 8020040:	b530      	push	{r4, r5, lr}
 8020042:	b08b      	sub	sp, #44	; 0x2c
 8020044:	4605      	mov	r5, r0
  uint32_t argc;
  uint8_t  *argv_p[10];
  const uint8_t *cmd_p;

  PRINT_FORCE("")
 8020046:	4c3d      	ldr	r4, [pc, #244]	; (802013c <com_sockets_cmd+0xfc>)
 8020048:	4b3d      	ldr	r3, [pc, #244]	; (8020140 <com_sockets_cmd+0x100>)
 802004a:	881a      	ldrh	r2, [r3, #0]
 802004c:	789b      	ldrb	r3, [r3, #2]
 802004e:	8022      	strh	r2, [r4, #0]
 8020050:	70a3      	strb	r3, [r4, #2]
 8020052:	4620      	mov	r0, r4
 8020054:	f7ff f969 	bl	801f32a <crs_strlen>
 8020058:	b283      	uxth	r3, r0
 802005a:	4622      	mov	r2, r4
 802005c:	2101      	movs	r1, #1
 802005e:	2003      	movs	r0, #3
 8020060:	f7ff f9a6 	bl	801f3b0 <traceIF_itmPrint>
 8020064:	4620      	mov	r0, r4
 8020066:	f7ff f960 	bl	801f32a <crs_strlen>
 802006a:	b282      	uxth	r2, r0
 802006c:	4621      	mov	r1, r4
 802006e:	2003      	movs	r0, #3
 8020070:	f7ff f9d8 	bl	801f424 <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((COM_SOCKETS_CHAR_t *)cmd_line_p, " \t");
 8020074:	4933      	ldr	r1, [pc, #204]	; (8020144 <com_sockets_cmd+0x104>)
 8020076:	4628      	mov	r0, r5
 8020078:	f006 fc74 	bl	8026964 <strtok>

  if (cmd_p != NULL)
 802007c:	b140      	cbz	r0, 8020090 <com_sockets_cmd+0x50>
 802007e:	4604      	mov	r4, r0
  {
    if (strncmp((const COM_SOCKETS_CHAR_t *)cmd_p,
 8020080:	f7e0 f8b8 	bl	80001f4 <strlen>
 8020084:	4602      	mov	r2, r0
 8020086:	4930      	ldr	r1, [pc, #192]	; (8020148 <com_sockets_cmd+0x108>)
 8020088:	4620      	mov	r0, r4
 802008a:	f006 fc58 	bl	802693e <strncmp>
 802008e:	b110      	cbz	r0, 8020096 <com_sockets_cmd+0x56>
        com_help_cmd();
      }
    }
  }
  return CMD_OK;
}
 8020090:	2000      	movs	r0, #0
 8020092:	b00b      	add	sp, #44	; 0x2c
 8020094:	bd30      	pop	{r4, r5, pc}
      for (argc = 0U; argc < 10U; argc++)
 8020096:	2400      	movs	r4, #0
 8020098:	2c09      	cmp	r4, #9
 802009a:	d80b      	bhi.n	80200b4 <com_sockets_cmd+0x74>
        argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 802009c:	4929      	ldr	r1, [pc, #164]	; (8020144 <com_sockets_cmd+0x104>)
 802009e:	2000      	movs	r0, #0
 80200a0:	f006 fc60 	bl	8026964 <strtok>
 80200a4:	ab0a      	add	r3, sp, #40	; 0x28
 80200a6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 80200aa:	f843 0c28 	str.w	r0, [r3, #-40]
        if (argv_p[argc] == NULL)
 80200ae:	b108      	cbz	r0, 80200b4 <com_sockets_cmd+0x74>
      for (argc = 0U; argc < 10U; argc++)
 80200b0:	3401      	adds	r4, #1
 80200b2:	e7f1      	b.n	8020098 <com_sockets_cmd+0x58>
      if (argc == 0U)
 80200b4:	b19c      	cbz	r4, 80200de <com_sockets_cmd+0x9e>
      else if (strncmp((COM_SOCKETS_CHAR_t *)argv_p[0],
 80200b6:	9d00      	ldr	r5, [sp, #0]
 80200b8:	4628      	mov	r0, r5
 80200ba:	f7e0 f89b 	bl	80001f4 <strlen>
 80200be:	4604      	mov	r4, r0
 80200c0:	4602      	mov	r2, r0
 80200c2:	4922      	ldr	r1, [pc, #136]	; (802014c <com_sockets_cmd+0x10c>)
 80200c4:	4628      	mov	r0, r5
 80200c6:	f006 fc3a 	bl	802693e <strncmp>
 80200ca:	b158      	cbz	r0, 80200e4 <com_sockets_cmd+0xa4>
      else if (strncmp((COM_SOCKETS_CHAR_t *)argv_p[0],
 80200cc:	4622      	mov	r2, r4
 80200ce:	4920      	ldr	r1, [pc, #128]	; (8020150 <com_sockets_cmd+0x110>)
 80200d0:	4628      	mov	r0, r5
 80200d2:	f006 fc34 	bl	802693e <strncmp>
 80200d6:	b940      	cbnz	r0, 80200ea <com_sockets_cmd+0xaa>
        com_sockets_statistic_display();
 80200d8:	f001 ff79 	bl	8021fce <com_sockets_statistic_display>
 80200dc:	e7d8      	b.n	8020090 <com_sockets_cmd+0x50>
        com_help_cmd();
 80200de:	f7ff ff6d 	bl	801ffbc <com_help_cmd>
 80200e2:	e7d5      	b.n	8020090 <com_sockets_cmd+0x50>
        com_help_cmd();
 80200e4:	f7ff ff6a 	bl	801ffbc <com_help_cmd>
 80200e8:	e7d2      	b.n	8020090 <com_sockets_cmd+0x50>
        PRINT_FORCE("comsocket: Unrecognized command. Usage:")
 80200ea:	4d1a      	ldr	r5, [pc, #104]	; (8020154 <com_sockets_cmd+0x114>)
 80200ec:	4c13      	ldr	r4, [pc, #76]	; (802013c <com_sockets_cmd+0xfc>)
 80200ee:	f105 0e20 	add.w	lr, r5, #32
 80200f2:	46ac      	mov	ip, r5
 80200f4:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80200f8:	6020      	str	r0, [r4, #0]
 80200fa:	6061      	str	r1, [r4, #4]
 80200fc:	60a2      	str	r2, [r4, #8]
 80200fe:	60e3      	str	r3, [r4, #12]
 8020100:	4665      	mov	r5, ip
 8020102:	3410      	adds	r4, #16
 8020104:	45f4      	cmp	ip, lr
 8020106:	d1f4      	bne.n	80200f2 <com_sockets_cmd+0xb2>
 8020108:	cd03      	ldmia	r5!, {r0, r1}
 802010a:	6020      	str	r0, [r4, #0]
 802010c:	6061      	str	r1, [r4, #4]
 802010e:	882b      	ldrh	r3, [r5, #0]
 8020110:	8123      	strh	r3, [r4, #8]
 8020112:	4c0a      	ldr	r4, [pc, #40]	; (802013c <com_sockets_cmd+0xfc>)
 8020114:	4620      	mov	r0, r4
 8020116:	f7ff f908 	bl	801f32a <crs_strlen>
 802011a:	b283      	uxth	r3, r0
 802011c:	4622      	mov	r2, r4
 802011e:	2101      	movs	r1, #1
 8020120:	2003      	movs	r0, #3
 8020122:	f7ff f945 	bl	801f3b0 <traceIF_itmPrint>
 8020126:	4620      	mov	r0, r4
 8020128:	f7ff f8ff 	bl	801f32a <crs_strlen>
 802012c:	b282      	uxth	r2, r0
 802012e:	4621      	mov	r1, r4
 8020130:	2003      	movs	r0, #3
 8020132:	f7ff f977 	bl	801f424 <traceIF_uartPrintForce>
        com_help_cmd();
 8020136:	f7ff ff41 	bl	801ffbc <com_help_cmd>
 802013a:	e7a9      	b.n	8020090 <com_sockets_cmd+0x50>
 802013c:	200049dc 	.word	0x200049dc
 8020140:	0802eac4 	.word	0x0802eac4
 8020144:	0803382c 	.word	0x0803382c
 8020148:	08035fc4 	.word	0x08035fc4
 802014c:	08033830 	.word	0x08033830
 8020150:	08035fd0 	.word	0x08035fd0
 8020154:	08035fd8 	.word	0x08035fd8

08020158 <com_socket>:
  * @param  type     - connection type
  * @param  protocol - protocol type
  * @retval int32_t  - socket handle or error value
  */
int32_t com_socket(int32_t family, int32_t type, int32_t protocol)
{
 8020158:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_socket_ip_modem(family, type, protocol);
 802015a:	f001 fceb 	bl	8021b34 <com_socket_ip_modem>
#else
  result = com_socket_lwip_mcu(family, type, protocol);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 802015e:	bd08      	pop	{r3, pc}

08020160 <com_setsockopt>:
  * @param  optlen    - size of the buffer containing the option value
  * @retval int32_t   - ok or error value
  */
int32_t com_setsockopt(int32_t sock, int32_t level, int32_t optname,
                       const void *optval, int32_t optlen)
{
 8020160:	b510      	push	{r4, lr}
 8020162:	b082      	sub	sp, #8
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_setsockopt_ip_modem(sock, level, optname, optval, optlen);
 8020164:	9c04      	ldr	r4, [sp, #16]
 8020166:	9400      	str	r4, [sp, #0]
 8020168:	f000 fcf0 	bl	8020b4c <com_setsockopt_ip_modem>
#else
  result = com_setsockopt_lwip_mcu(sock, level, optname, optval, optlen);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 802016c:	b002      	add	sp, #8
 802016e:	bd10      	pop	{r4, pc}

08020170 <com_connect>:
  * @param  addrlen   - addr length
  * @retval int32_t   - ok or error value
  */
int32_t com_connect(int32_t sock,
                    const com_sockaddr_t *addr, int32_t addrlen)
{
 8020170:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_connect_ip_modem(sock, addr, addrlen);
 8020172:	f000 fd2b 	bl	8020bcc <com_connect_ip_modem>
#else
  result = com_connect_lwip_mcu(sock, addr, addrlen);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 8020176:	bd08      	pop	{r3, pc}

08020178 <com_send>:
  * @retval int32_t   - number of bytes sent or error value
  */
int32_t com_send(int32_t sock,
                 const com_char_t *buf, int32_t len,
                 int32_t flags)
{
 8020178:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_send_ip_modem(sock, buf, len, flags);
 802017a:	f001 f80d 	bl	8021198 <com_send_ip_modem>
#else
  result = com_send_lwip_mcu(sock, buf, len, flags);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 802017e:	bd08      	pop	{r3, pc}

08020180 <com_recv>:
  * @retval int32_t   - number of bytes received or error value
  */
int32_t com_recv(int32_t sock,
                 com_char_t *buf, int32_t len,
                 int32_t flags)
{
 8020180:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_recv_ip_modem(sock, buf, len, flags);
 8020182:	f001 f9cb 	bl	802151c <com_recv_ip_modem>
#else
  result = com_recv_lwip_mcu(sock, buf, len, flags);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 8020186:	bd08      	pop	{r3, pc}

08020188 <com_closesocket>:
  * @note   Close a socket and release socket handle
  * @param  sock      - socket handle obtained with com_socket
  * @retval int32_t   - ok or error value
  */
int32_t com_closesocket(int32_t sock)
{
 8020188:	b508      	push	{r3, lr}
  int32_t result;

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_closesocket_ip_modem(sock);
 802018a:	f001 fc33 	bl	80219f4 <com_closesocket_ip_modem>
#else
  result = com_closesocket_lwip_mcu(sock);
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  return (result);
}
 802018e:	bd08      	pop	{r3, pc}

08020190 <com_sockets_init>:
  *         - before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_sockets_init(void)
{
 8020190:	b510      	push	{r4, lr}
  bool result;

  (void)osCDS_cellular_service_init();
 8020192:	f7fa fcdf 	bl	801ab54 <osCDS_cellular_service_init>

#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  result = com_init_ip_modem();
 8020196:	f001 fecb 	bl	8021f30 <com_init_ip_modem>
 802019a:	4604      	mov	r4, r0
#else
  result = com_init_lwip_mcu();
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  com_sockets_statistic_init();
 802019c:	f001 ff14 	bl	8021fc8 <com_sockets_statistic_init>

  return (result);
}
 80201a0:	4620      	mov	r0, r4
 80201a2:	bd10      	pop	{r4, pc}

080201a4 <com_sockets_start>:
            and before using any other functions of com_*
  * @param  -
  * @retval -
  */
void com_sockets_start(void)
{
 80201a4:	b508      	push	{r3, lr}
#if (USE_SOCKETS_TYPE == USE_SOCKETS_MODEM)
  com_start_ip_modem();
 80201a6:	f001 feeb 	bl	8021f80 <com_start_ip_modem>
#endif /* USE_SOCKETS_TYPE == USE_SOCKETS_MODEM */

  /* no com_sockets_statistic_start(); */

#if (USE_CMD_CONSOLE == 1)
  CMD_Declare((uint8_t *)"comsocket", com_sockets_cmd, (uint8_t *)"com socket commands");
 80201aa:	4a03      	ldr	r2, [pc, #12]	; (80201b8 <com_sockets_start+0x14>)
 80201ac:	4903      	ldr	r1, [pc, #12]	; (80201bc <com_sockets_start+0x18>)
 80201ae:	4804      	ldr	r0, [pc, #16]	; (80201c0 <com_sockets_start+0x1c>)
 80201b0:	f002 fba2 	bl	80228f8 <CMD_Declare>
#endif /* USE_CMD_CONSOLE == 1 */
}
 80201b4:	bd08      	pop	{r3, pc}
 80201b6:	bf00      	nop
 80201b8:	08036004 	.word	0x08036004
 80201bc:	08020041 	.word	0x08020041
 80201c0:	08035fc4 	.word	0x08035fc4

080201c4 <com_ip_modem_find_socket>:
  */
static socket_desc_t *com_ip_modem_find_socket(int32_t sock, bool local)
{
  socket_desc_t *socket_desc;

  if (sock >= 0)
 80201c4:	1e02      	subs	r2, r0, #0
 80201c6:	db0f      	blt.n	80201e8 <com_ip_modem_find_socket+0x24>
{
 80201c8:	b410      	push	{r4}
  {
    bool found;

    socket_desc = socket_desc_list;
 80201ca:	4b0a      	ldr	r3, [pc, #40]	; (80201f4 <com_ip_modem_find_socket+0x30>)
 80201cc:	6818      	ldr	r0, [r3, #0]
    found = false;
 80201ce:	2400      	movs	r4, #0

    /* Search the socket descriptor */
    while ((socket_desc != NULL)
 80201d0:	e000      	b.n	80201d4 <com_ip_modem_find_socket+0x10>
        found = true;
      }
      else
      {
        /* Not the searched one ... Next */
        socket_desc = socket_desc->next;
 80201d2:	6a40      	ldr	r0, [r0, #36]	; 0x24
           && (found != true))
 80201d4:	b150      	cbz	r0, 80201ec <com_ip_modem_find_socket+0x28>
 80201d6:	b94c      	cbnz	r4, 80201ec <com_ip_modem_find_socket+0x28>
      if ((socket_desc->id == sock)
 80201d8:	6883      	ldr	r3, [r0, #8]
 80201da:	4293      	cmp	r3, r2
 80201dc:	d1f9      	bne.n	80201d2 <com_ip_modem_find_socket+0xe>
          && (socket_desc->local == local))
 80201de:	7843      	ldrb	r3, [r0, #1]
 80201e0:	428b      	cmp	r3, r1
 80201e2:	d1f6      	bne.n	80201d2 <com_ip_modem_find_socket+0xe>
        found = true;
 80201e4:	2401      	movs	r4, #1
 80201e6:	e7f5      	b.n	80201d4 <com_ip_modem_find_socket+0x10>
      }
    }
  }
  else
  {
    socket_desc = NULL;
 80201e8:	2000      	movs	r0, #0
  }

  /* If found == false then socket_desc = NULL */
  return socket_desc;
}
 80201ea:	4770      	bx	lr
 80201ec:	f85d 4b04 	ldr.w	r4, [sp], #4
 80201f0:	4770      	bx	lr
 80201f2:	bf00      	nop
 80201f4:	200058a8 	.word	0x200058a8

080201f8 <com_convert_sockaddr_to_ipaddr_port>:
  */
static void com_convert_sockaddr_to_ipaddr_port(const com_sockaddr_in_t *sockaddr_in,
                                                com_ip_addr_t *ip_addr,
                                                uint16_t *port)
{
  ip_addr->addr = sockaddr_in->sin_addr.s_addr;
 80201f8:	6843      	ldr	r3, [r0, #4]
 80201fa:	600b      	str	r3, [r1, #0]
  *port = COM_NTOHS(sockaddr_in->sin_port);
 80201fc:	8843      	ldrh	r3, [r0, #2]
 80201fe:	ba5b      	rev16	r3, r3
 8020200:	8013      	strh	r3, [r2, #0]
}
 8020202:	4770      	bx	lr

08020204 <com_ip_modem_is_network_up>:
  * @retval true/false network is up/down
  */
static bool com_ip_modem_is_network_up(void)
{
  return (com_sockets_network_is_up);
}
 8020204:	4b01      	ldr	r3, [pc, #4]	; (802020c <com_ip_modem_is_network_up+0x8>)
 8020206:	7818      	ldrb	r0, [r3, #0]
 8020208:	4770      	bx	lr
 802020a:	bf00      	nop
 802020c:	200058a6 	.word	0x200058a6

08020210 <com_ip_modem_new_local_port>:
  * @note   -
  * @retval new local port value in [COM_LOCAL_PORT_BEGIN, COM_LOCAL_PORT_END]
  *         or 0U if impossible to find a free port
  */
static uint16_t com_ip_modem_new_local_port(void)
{
 8020210:	b410      	push	{r4}
  uint16_t iter;
  uint16_t result;
  socket_desc_t *socket_desc;

  local_port_ok = false;
  iter = 0U;
 8020212:	f04f 0c00 	mov.w	ip, #0
  local_port_ok = false;
 8020216:	4664      	mov	r4, ip

  while ((local_port_ok != true)
 8020218:	e010      	b.n	802023c <com_ip_modem_new_local_port+0x2c>
    /* Test the next local port value */
    com_local_port++;
    iter++;
    if (com_local_port == COM_LOCAL_PORT_END)
    {
      com_local_port = COM_LOCAL_PORT_BEGIN;
 802021a:	4b17      	ldr	r3, [pc, #92]	; (8020278 <com_ip_modem_new_local_port+0x68>)
 802021c:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8020220:	801a      	strh	r2, [r3, #0]
 8020222:	e01d      	b.n	8020260 <com_ip_modem_new_local_port+0x50>
        /* Local port already used */
        found = true;
      }
      else
      {
        socket_desc = socket_desc->next;
 8020224:	6a5b      	ldr	r3, [r3, #36]	; 0x24
           && (found != true))
 8020226:	b13b      	cbz	r3, 8020238 <com_ip_modem_new_local_port+0x28>
 8020228:	b930      	cbnz	r0, 8020238 <com_ip_modem_new_local_port+0x28>
      if (socket_desc->local_port == com_local_port)
 802022a:	8999      	ldrh	r1, [r3, #12]
 802022c:	4a12      	ldr	r2, [pc, #72]	; (8020278 <com_ip_modem_new_local_port+0x68>)
 802022e:	8812      	ldrh	r2, [r2, #0]
 8020230:	4291      	cmp	r1, r2
 8020232:	d1f7      	bne.n	8020224 <com_ip_modem_new_local_port+0x14>
        found = true;
 8020234:	2001      	movs	r0, #1
 8020236:	e7f6      	b.n	8020226 <com_ip_modem_new_local_port+0x16>
      }
    }

    if (found == false)
 8020238:	b900      	cbnz	r0, 802023c <com_ip_modem_new_local_port+0x2c>
    {
      /* Local port is unused */
      local_port_ok = true;
 802023a:	2401      	movs	r4, #1
         && (iter < (COM_LOCAL_PORT_END - COM_LOCAL_PORT_BEGIN)))
 802023c:	b9a4      	cbnz	r4, 8020268 <com_ip_modem_new_local_port+0x58>
 802023e:	f643 73fe 	movw	r3, #16382	; 0x3ffe
 8020242:	459c      	cmp	ip, r3
 8020244:	d810      	bhi.n	8020268 <com_ip_modem_new_local_port+0x58>
    com_local_port++;
 8020246:	4a0c      	ldr	r2, [pc, #48]	; (8020278 <com_ip_modem_new_local_port+0x68>)
 8020248:	8813      	ldrh	r3, [r2, #0]
 802024a:	3301      	adds	r3, #1
 802024c:	b29b      	uxth	r3, r3
 802024e:	8013      	strh	r3, [r2, #0]
    iter++;
 8020250:	f10c 0c01 	add.w	ip, ip, #1
 8020254:	fa1f fc8c 	uxth.w	ip, ip
    if (com_local_port == COM_LOCAL_PORT_END)
 8020258:	f64f 72ff 	movw	r2, #65535	; 0xffff
 802025c:	4293      	cmp	r3, r2
 802025e:	d0dc      	beq.n	802021a <com_ip_modem_new_local_port+0xa>
    socket_desc = socket_desc_list;
 8020260:	4b06      	ldr	r3, [pc, #24]	; (802027c <com_ip_modem_new_local_port+0x6c>)
 8020262:	681b      	ldr	r3, [r3, #0]
    found = false;
 8020264:	4620      	mov	r0, r4
    while ((socket_desc != NULL)
 8020266:	e7de      	b.n	8020226 <com_ip_modem_new_local_port+0x16>
    }
    /* Continue to search a free value */
  }
  if (local_port_ok != true)
 8020268:	b114      	cbz	r4, 8020270 <com_ip_modem_new_local_port+0x60>
  {
    result = 0U;
  }
  else
  {
    result = com_local_port;
 802026a:	4b03      	ldr	r3, [pc, #12]	; (8020278 <com_ip_modem_new_local_port+0x68>)
 802026c:	8818      	ldrh	r0, [r3, #0]
 802026e:	e000      	b.n	8020272 <com_ip_modem_new_local_port+0x62>
    result = 0U;
 8020270:	2000      	movs	r0, #0
  }

  return result;
}
 8020272:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020276:	4770      	bx	lr
 8020278:	200058a4 	.word	0x200058a4
 802027c:	200058a8 	.word	0x200058a8

08020280 <com_ip_modem_wakeup_request>:
    PRINT_INFO("Inactivity: WakeUp request NOK")
  }

  (void)rtosalMutexRelease(ComTimerInactivityMutexHandle);
#else /* USE_LOW_POWER == 0 */
  __NOP();
 8020280:	bf00      	nop
#endif /* USE_LOW_POWER == 1 */
}
 8020282:	4770      	bx	lr

08020284 <com_ip_modem_closing_cb>:
  * @param  sock - socket handle
  * @note   -
  * @retval -
  */
static void com_ip_modem_closing_cb(socket_handle_t sock)
{
 8020284:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020286:	b083      	sub	sp, #12
 8020288:	4606      	mov	r6, r0
  PRINT_DBG("callback socket closing called")
 802028a:	4c75      	ldr	r4, [pc, #468]	; (8020460 <com_ip_modem_closing_cb+0x1dc>)
 802028c:	4d75      	ldr	r5, [pc, #468]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 802028e:	f104 0720 	add.w	r7, r4, #32
 8020292:	46a4      	mov	ip, r4
 8020294:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020298:	6028      	str	r0, [r5, #0]
 802029a:	6069      	str	r1, [r5, #4]
 802029c:	60aa      	str	r2, [r5, #8]
 802029e:	60eb      	str	r3, [r5, #12]
 80202a0:	4664      	mov	r4, ip
 80202a2:	3510      	adds	r5, #16
 80202a4:	45bc      	cmp	ip, r7
 80202a6:	d1f4      	bne.n	8020292 <com_ip_modem_closing_cb+0xe>
 80202a8:	cc03      	ldmia	r4!, {r0, r1}
 80202aa:	6028      	str	r0, [r5, #0]
 80202ac:	6069      	str	r1, [r5, #4]
 80202ae:	7823      	ldrb	r3, [r4, #0]
 80202b0:	722b      	strb	r3, [r5, #8]
 80202b2:	4c6c      	ldr	r4, [pc, #432]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 80202b4:	4620      	mov	r0, r4
 80202b6:	f7ff f838 	bl	801f32a <crs_strlen>
 80202ba:	b283      	uxth	r3, r0
 80202bc:	4622      	mov	r2, r4
 80202be:	2102      	movs	r1, #2
 80202c0:	2003      	movs	r0, #3
 80202c2:	f7ff f875 	bl	801f3b0 <traceIF_itmPrint>
 80202c6:	4620      	mov	r0, r4
 80202c8:	f7ff f82f 	bl	801f32a <crs_strlen>
 80202cc:	b283      	uxth	r3, r0
 80202ce:	4622      	mov	r2, r4
 80202d0:	2102      	movs	r1, #2
 80202d2:	2003      	movs	r0, #3
 80202d4:	f7ff f88e 	bl	801f3f4 <traceIF_uartPrint>

  com_socket_msg_t msg_queue;
  socket_desc_t    *socket_desc;

  msg_queue = 0U;
  socket_desc = com_ip_modem_find_socket(sock, false);
 80202d8:	2100      	movs	r1, #0
 80202da:	4630      	mov	r0, r6
 80202dc:	f7ff ff72 	bl	80201c4 <com_ip_modem_find_socket>

  if (socket_desc != NULL)
 80202e0:	4606      	mov	r6, r0
 80202e2:	2800      	cmp	r0, #0
 80202e4:	f000 8093 	beq.w	802040e <com_ip_modem_closing_cb+0x18a>
  {
    PRINT_INFO("cb socket closing called: close rqt")
 80202e8:	4c5f      	ldr	r4, [pc, #380]	; (8020468 <com_ip_modem_closing_cb+0x1e4>)
 80202ea:	4d5e      	ldr	r5, [pc, #376]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 80202ec:	f104 0720 	add.w	r7, r4, #32
 80202f0:	46a4      	mov	ip, r4
 80202f2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80202f6:	6028      	str	r0, [r5, #0]
 80202f8:	6069      	str	r1, [r5, #4]
 80202fa:	60aa      	str	r2, [r5, #8]
 80202fc:	60eb      	str	r3, [r5, #12]
 80202fe:	4664      	mov	r4, ip
 8020300:	3510      	adds	r5, #16
 8020302:	45bc      	cmp	ip, r7
 8020304:	d1f4      	bne.n	80202f0 <com_ip_modem_closing_cb+0x6c>
 8020306:	cc07      	ldmia	r4!, {r0, r1, r2}
 8020308:	6028      	str	r0, [r5, #0]
 802030a:	6069      	str	r1, [r5, #4]
 802030c:	60aa      	str	r2, [r5, #8]
 802030e:	8823      	ldrh	r3, [r4, #0]
 8020310:	81ab      	strh	r3, [r5, #12]
 8020312:	4c54      	ldr	r4, [pc, #336]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 8020314:	4620      	mov	r0, r4
 8020316:	f7ff f808 	bl	801f32a <crs_strlen>
 802031a:	b283      	uxth	r3, r0
 802031c:	4622      	mov	r2, r4
 802031e:	2101      	movs	r1, #1
 8020320:	2003      	movs	r0, #3
 8020322:	f7ff f845 	bl	801f3b0 <traceIF_itmPrint>
 8020326:	4620      	mov	r0, r4
 8020328:	f7fe ffff 	bl	801f32a <crs_strlen>
 802032c:	b283      	uxth	r3, r0
 802032e:	4622      	mov	r2, r4
 8020330:	2101      	movs	r1, #1
 8020332:	2003      	movs	r0, #3
 8020334:	f7ff f85e 	bl	801f3f4 <traceIF_uartPrint>
    if (socket_desc->closing == false)
 8020338:	78b3      	ldrb	r3, [r6, #2]
 802033a:	b133      	cbz	r3, 802034a <com_ip_modem_closing_cb+0xc6>
    {
      socket_desc->closing = true;
      PRINT_INFO("cb socket closing: close rqt")
    }
    if ((socket_desc->state == COM_SOCKET_WAITING_RSP)
 802033c:	7833      	ldrb	r3, [r6, #0]
        || (socket_desc->state == COM_SOCKET_WAITING_FROM))
 802033e:	3b05      	subs	r3, #5
 8020340:	b2db      	uxtb	r3, r3
    if ((socket_desc->state == COM_SOCKET_WAITING_RSP)
 8020342:	2b01      	cmp	r3, #1
 8020344:	d92a      	bls.n	802039c <com_ip_modem_closing_cb+0x118>
  }
  else
  {
    PRINT_ERR("cb socket closing called: unknown socket")
  }
}
 8020346:	b003      	add	sp, #12
 8020348:	bdf0      	pop	{r4, r5, r6, r7, pc}
      socket_desc->closing = true;
 802034a:	2301      	movs	r3, #1
 802034c:	70b3      	strb	r3, [r6, #2]
      PRINT_INFO("cb socket closing: close rqt")
 802034e:	4f47      	ldr	r7, [pc, #284]	; (802046c <com_ip_modem_closing_cb+0x1e8>)
 8020350:	f107 0c20 	add.w	ip, r7, #32
 8020354:	463d      	mov	r5, r7
 8020356:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020358:	6020      	str	r0, [r4, #0]
 802035a:	6061      	str	r1, [r4, #4]
 802035c:	60a2      	str	r2, [r4, #8]
 802035e:	60e3      	str	r3, [r4, #12]
 8020360:	462f      	mov	r7, r5
 8020362:	3410      	adds	r4, #16
 8020364:	4565      	cmp	r5, ip
 8020366:	d1f5      	bne.n	8020354 <com_ip_modem_closing_cb+0xd0>
 8020368:	6828      	ldr	r0, [r5, #0]
 802036a:	6020      	str	r0, [r4, #0]
 802036c:	88aa      	ldrh	r2, [r5, #4]
 802036e:	79ab      	ldrb	r3, [r5, #6]
 8020370:	80a2      	strh	r2, [r4, #4]
 8020372:	71a3      	strb	r3, [r4, #6]
 8020374:	4c3b      	ldr	r4, [pc, #236]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 8020376:	4620      	mov	r0, r4
 8020378:	f7fe ffd7 	bl	801f32a <crs_strlen>
 802037c:	b283      	uxth	r3, r0
 802037e:	4622      	mov	r2, r4
 8020380:	2101      	movs	r1, #1
 8020382:	2003      	movs	r0, #3
 8020384:	f7ff f814 	bl	801f3b0 <traceIF_itmPrint>
 8020388:	4620      	mov	r0, r4
 802038a:	f7fe ffce 	bl	801f32a <crs_strlen>
 802038e:	b283      	uxth	r3, r0
 8020390:	4622      	mov	r2, r4
 8020392:	2101      	movs	r1, #1
 8020394:	2003      	movs	r0, #3
 8020396:	f7ff f82d 	bl	801f3f4 <traceIF_uartPrint>
 802039a:	e7cf      	b.n	802033c <com_ip_modem_closing_cb+0xb8>
      PRINT_ERR("!!! cb socket %ld closing called: data_expected !!!", socket_desc->id)
 802039c:	4c31      	ldr	r4, [pc, #196]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 802039e:	68b2      	ldr	r2, [r6, #8]
 80203a0:	4933      	ldr	r1, [pc, #204]	; (8020470 <com_ip_modem_closing_cb+0x1ec>)
 80203a2:	4620      	mov	r0, r4
 80203a4:	f006 fa50 	bl	8026848 <sprintf>
 80203a8:	4620      	mov	r0, r4
 80203aa:	f7fe ffbe 	bl	801f32a <crs_strlen>
 80203ae:	b283      	uxth	r3, r0
 80203b0:	4622      	mov	r2, r4
 80203b2:	2110      	movs	r1, #16
 80203b4:	2003      	movs	r0, #3
 80203b6:	f7fe fffb 	bl	801f3b0 <traceIF_itmPrint>
 80203ba:	4620      	mov	r0, r4
 80203bc:	f7fe ffb5 	bl	801f32a <crs_strlen>
 80203c0:	b283      	uxth	r3, r0
 80203c2:	4622      	mov	r2, r4
 80203c4:	2110      	movs	r1, #16
 80203c6:	2003      	movs	r0, #3
 80203c8:	f7ff f814 	bl	801f3f4 <traceIF_uartPrint>
      PRINT_DBG("cb socket %ld MSGput %lu queue %p", socket_desc->id, msg_queue, socket_desc->queue)
 80203cc:	4d29      	ldr	r5, [pc, #164]	; (8020474 <com_ip_modem_closing_cb+0x1f0>)
 80203ce:	68b2      	ldr	r2, [r6, #8]
 80203d0:	69f3      	ldr	r3, [r6, #28]
 80203d2:	9300      	str	r3, [sp, #0]
 80203d4:	462b      	mov	r3, r5
 80203d6:	4928      	ldr	r1, [pc, #160]	; (8020478 <com_ip_modem_closing_cb+0x1f4>)
 80203d8:	4620      	mov	r0, r4
 80203da:	f006 fa35 	bl	8026848 <sprintf>
 80203de:	4620      	mov	r0, r4
 80203e0:	f7fe ffa3 	bl	801f32a <crs_strlen>
 80203e4:	b283      	uxth	r3, r0
 80203e6:	4622      	mov	r2, r4
 80203e8:	2102      	movs	r1, #2
 80203ea:	2003      	movs	r0, #3
 80203ec:	f7fe ffe0 	bl	801f3b0 <traceIF_itmPrint>
 80203f0:	4620      	mov	r0, r4
 80203f2:	f7fe ff9a 	bl	801f32a <crs_strlen>
 80203f6:	b283      	uxth	r3, r0
 80203f8:	4622      	mov	r2, r4
 80203fa:	2102      	movs	r1, #2
 80203fc:	2003      	movs	r0, #3
 80203fe:	f7fe fff9 	bl	801f3f4 <traceIF_uartPrint>
      (void)rtosalMessageQueuePut(socket_desc->queue, msg_queue, 0U);
 8020402:	2200      	movs	r2, #0
 8020404:	4629      	mov	r1, r5
 8020406:	69f0      	ldr	r0, [r6, #28]
 8020408:	f7fe febd 	bl	801f186 <rtosalMessageQueuePut>
 802040c:	e79b      	b.n	8020346 <com_ip_modem_closing_cb+0xc2>
    PRINT_ERR("cb socket closing called: unknown socket")
 802040e:	4d1b      	ldr	r5, [pc, #108]	; (802047c <com_ip_modem_closing_cb+0x1f8>)
 8020410:	4c14      	ldr	r4, [pc, #80]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 8020412:	f105 0630 	add.w	r6, r5, #48	; 0x30
 8020416:	46ac      	mov	ip, r5
 8020418:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 802041c:	6020      	str	r0, [r4, #0]
 802041e:	6061      	str	r1, [r4, #4]
 8020420:	60a2      	str	r2, [r4, #8]
 8020422:	60e3      	str	r3, [r4, #12]
 8020424:	4665      	mov	r5, ip
 8020426:	3410      	adds	r4, #16
 8020428:	45b4      	cmp	ip, r6
 802042a:	d1f4      	bne.n	8020416 <com_ip_modem_closing_cb+0x192>
 802042c:	cd03      	ldmia	r5!, {r0, r1}
 802042e:	6020      	str	r0, [r4, #0]
 8020430:	6061      	str	r1, [r4, #4]
 8020432:	782b      	ldrb	r3, [r5, #0]
 8020434:	7223      	strb	r3, [r4, #8]
 8020436:	4c0b      	ldr	r4, [pc, #44]	; (8020464 <com_ip_modem_closing_cb+0x1e0>)
 8020438:	4620      	mov	r0, r4
 802043a:	f7fe ff76 	bl	801f32a <crs_strlen>
 802043e:	b283      	uxth	r3, r0
 8020440:	4622      	mov	r2, r4
 8020442:	2110      	movs	r1, #16
 8020444:	2003      	movs	r0, #3
 8020446:	f7fe ffb3 	bl	801f3b0 <traceIF_itmPrint>
 802044a:	4620      	mov	r0, r4
 802044c:	f7fe ff6d 	bl	801f32a <crs_strlen>
 8020450:	b283      	uxth	r3, r0
 8020452:	4622      	mov	r2, r4
 8020454:	2110      	movs	r1, #16
 8020456:	2003      	movs	r0, #3
 8020458:	f7fe ffcc 	bl	801f3f4 <traceIF_uartPrint>
}
 802045c:	e773      	b.n	8020346 <com_ip_modem_closing_cb+0xc2>
 802045e:	bf00      	nop
 8020460:	08036018 	.word	0x08036018
 8020464:	200049dc 	.word	0x200049dc
 8020468:	08036044 	.word	0x08036044
 802046c:	08036074 	.word	0x08036074
 8020470:	0803609c 	.word	0x0803609c
 8020474:	00020001 	.word	0x00020001
 8020478:	080360e0 	.word	0x080360e0
 802047c:	0803610c 	.word	0x0803610c

08020480 <com_ip_modem_data_ready_cb>:
{
 8020480:	b530      	push	{r4, r5, lr}
 8020482:	b083      	sub	sp, #12
  socket_desc = com_ip_modem_find_socket(sock, false);
 8020484:	2100      	movs	r1, #0
 8020486:	f7ff fe9d 	bl	80201c4 <com_ip_modem_find_socket>
  if (socket_desc != NULL)
 802048a:	2800      	cmp	r0, #0
 802048c:	f000 80c2 	beq.w	8020614 <com_ip_modem_data_ready_cb+0x194>
 8020490:	4604      	mov	r4, r0
    if (socket_desc->closing != true)
 8020492:	7883      	ldrb	r3, [r0, #2]
 8020494:	2b00      	cmp	r3, #0
 8020496:	f040 8092 	bne.w	80205be <com_ip_modem_data_ready_cb+0x13e>
      if (socket_desc->state == COM_SOCKET_WAITING_RSP)
 802049a:	7802      	ldrb	r2, [r0, #0]
 802049c:	2a05      	cmp	r2, #5
 802049e:	d01a      	beq.n	80204d6 <com_ip_modem_data_ready_cb+0x56>
      else if (socket_desc->state == COM_SOCKET_WAITING_FROM)
 80204a0:	2a06      	cmp	r2, #6
 80204a2:	d052      	beq.n	802054a <com_ip_modem_data_ready_cb+0xca>
        PRINT_INFO("cb socket data ready called: socket_state:%i NOK",
 80204a4:	4c6f      	ldr	r4, [pc, #444]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 80204a6:	4970      	ldr	r1, [pc, #448]	; (8020668 <com_ip_modem_data_ready_cb+0x1e8>)
 80204a8:	4620      	mov	r0, r4
 80204aa:	f006 f9cd 	bl	8026848 <sprintf>
 80204ae:	4620      	mov	r0, r4
 80204b0:	f7fe ff3b 	bl	801f32a <crs_strlen>
 80204b4:	b283      	uxth	r3, r0
 80204b6:	4622      	mov	r2, r4
 80204b8:	2101      	movs	r1, #1
 80204ba:	2003      	movs	r0, #3
 80204bc:	f7fe ff78 	bl	801f3b0 <traceIF_itmPrint>
 80204c0:	4620      	mov	r0, r4
 80204c2:	f7fe ff32 	bl	801f32a <crs_strlen>
 80204c6:	b283      	uxth	r3, r0
 80204c8:	4622      	mov	r2, r4
 80204ca:	2101      	movs	r1, #1
 80204cc:	2003      	movs	r0, #3
 80204ce:	f7fe ff91 	bl	801f3f4 <traceIF_uartPrint>
}
 80204d2:	b003      	add	sp, #12
 80204d4:	bd30      	pop	{r4, r5, pc}
        PRINT_INFO("cb socket %ld data ready called: waiting rsp", socket_desc->id)
 80204d6:	4d63      	ldr	r5, [pc, #396]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 80204d8:	6882      	ldr	r2, [r0, #8]
 80204da:	4964      	ldr	r1, [pc, #400]	; (802066c <com_ip_modem_data_ready_cb+0x1ec>)
 80204dc:	4628      	mov	r0, r5
 80204de:	f006 f9b3 	bl	8026848 <sprintf>
 80204e2:	4628      	mov	r0, r5
 80204e4:	f7fe ff21 	bl	801f32a <crs_strlen>
 80204e8:	b283      	uxth	r3, r0
 80204ea:	462a      	mov	r2, r5
 80204ec:	2101      	movs	r1, #1
 80204ee:	2003      	movs	r0, #3
 80204f0:	f7fe ff5e 	bl	801f3b0 <traceIF_itmPrint>
 80204f4:	4628      	mov	r0, r5
 80204f6:	f7fe ff18 	bl	801f32a <crs_strlen>
 80204fa:	b283      	uxth	r3, r0
 80204fc:	462a      	mov	r2, r5
 80204fe:	2101      	movs	r1, #1
 8020500:	2003      	movs	r0, #3
 8020502:	f7fe ff77 	bl	801f3f4 <traceIF_uartPrint>
        PRINT_DBG("cb socket %ld MSGput %lu queue %p", socket_desc->id, msg_queue, socket_desc->queue)
 8020506:	68a2      	ldr	r2, [r4, #8]
 8020508:	69e3      	ldr	r3, [r4, #28]
 802050a:	9300      	str	r3, [sp, #0]
 802050c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8020510:	4957      	ldr	r1, [pc, #348]	; (8020670 <com_ip_modem_data_ready_cb+0x1f0>)
 8020512:	4628      	mov	r0, r5
 8020514:	f006 f998 	bl	8026848 <sprintf>
 8020518:	4628      	mov	r0, r5
 802051a:	f7fe ff06 	bl	801f32a <crs_strlen>
 802051e:	b283      	uxth	r3, r0
 8020520:	462a      	mov	r2, r5
 8020522:	2102      	movs	r1, #2
 8020524:	2003      	movs	r0, #3
 8020526:	f7fe ff43 	bl	801f3b0 <traceIF_itmPrint>
 802052a:	4628      	mov	r0, r5
 802052c:	f7fe fefd 	bl	801f32a <crs_strlen>
 8020530:	b283      	uxth	r3, r0
 8020532:	462a      	mov	r2, r5
 8020534:	2102      	movs	r1, #2
 8020536:	2003      	movs	r0, #3
 8020538:	f7fe ff5c 	bl	801f3f4 <traceIF_uartPrint>
        (void)rtosalMessageQueuePut(socket_desc->queue, msg_queue, 0U);
 802053c:	2200      	movs	r2, #0
 802053e:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8020542:	69e0      	ldr	r0, [r4, #28]
 8020544:	f7fe fe1f 	bl	801f186 <rtosalMessageQueuePut>
 8020548:	e7c3      	b.n	80204d2 <com_ip_modem_data_ready_cb+0x52>
        PRINT_INFO("cb socket %ld data ready called: waiting from", socket_desc->id)
 802054a:	4d46      	ldr	r5, [pc, #280]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 802054c:	6882      	ldr	r2, [r0, #8]
 802054e:	4949      	ldr	r1, [pc, #292]	; (8020674 <com_ip_modem_data_ready_cb+0x1f4>)
 8020550:	4628      	mov	r0, r5
 8020552:	f006 f979 	bl	8026848 <sprintf>
 8020556:	4628      	mov	r0, r5
 8020558:	f7fe fee7 	bl	801f32a <crs_strlen>
 802055c:	b283      	uxth	r3, r0
 802055e:	462a      	mov	r2, r5
 8020560:	2101      	movs	r1, #1
 8020562:	2003      	movs	r0, #3
 8020564:	f7fe ff24 	bl	801f3b0 <traceIF_itmPrint>
 8020568:	4628      	mov	r0, r5
 802056a:	f7fe fede 	bl	801f32a <crs_strlen>
 802056e:	b283      	uxth	r3, r0
 8020570:	462a      	mov	r2, r5
 8020572:	2101      	movs	r1, #1
 8020574:	2003      	movs	r0, #3
 8020576:	f7fe ff3d 	bl	801f3f4 <traceIF_uartPrint>
        PRINT_DBG("cb socket %ld MSGput %lu queue %p", socket_desc->id, msg_queue, socket_desc->queue)
 802057a:	68a2      	ldr	r2, [r4, #8]
 802057c:	69e3      	ldr	r3, [r4, #28]
 802057e:	9300      	str	r3, [sp, #0]
 8020580:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8020584:	493a      	ldr	r1, [pc, #232]	; (8020670 <com_ip_modem_data_ready_cb+0x1f0>)
 8020586:	4628      	mov	r0, r5
 8020588:	f006 f95e 	bl	8026848 <sprintf>
 802058c:	4628      	mov	r0, r5
 802058e:	f7fe fecc 	bl	801f32a <crs_strlen>
 8020592:	b283      	uxth	r3, r0
 8020594:	462a      	mov	r2, r5
 8020596:	2102      	movs	r1, #2
 8020598:	2003      	movs	r0, #3
 802059a:	f7fe ff09 	bl	801f3b0 <traceIF_itmPrint>
 802059e:	4628      	mov	r0, r5
 80205a0:	f7fe fec3 	bl	801f32a <crs_strlen>
 80205a4:	b283      	uxth	r3, r0
 80205a6:	462a      	mov	r2, r5
 80205a8:	2102      	movs	r1, #2
 80205aa:	2003      	movs	r0, #3
 80205ac:	f7fe ff22 	bl	801f3f4 <traceIF_uartPrint>
        (void)rtosalMessageQueuePut(socket_desc->queue, msg_queue, 0U);
 80205b0:	2200      	movs	r2, #0
 80205b2:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 80205b6:	69e0      	ldr	r0, [r4, #28]
 80205b8:	f7fe fde5 	bl	801f186 <rtosalMessageQueuePut>
 80205bc:	e789      	b.n	80204d2 <com_ip_modem_data_ready_cb+0x52>
      PRINT_ERR("cb socket data ready called: socket is closing")
 80205be:	4d2e      	ldr	r5, [pc, #184]	; (8020678 <com_ip_modem_data_ready_cb+0x1f8>)
 80205c0:	4c28      	ldr	r4, [pc, #160]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 80205c2:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 80205c6:	46ac      	mov	ip, r5
 80205c8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80205cc:	6020      	str	r0, [r4, #0]
 80205ce:	6061      	str	r1, [r4, #4]
 80205d0:	60a2      	str	r2, [r4, #8]
 80205d2:	60e3      	str	r3, [r4, #12]
 80205d4:	4665      	mov	r5, ip
 80205d6:	3410      	adds	r4, #16
 80205d8:	45f4      	cmp	ip, lr
 80205da:	d1f4      	bne.n	80205c6 <com_ip_modem_data_ready_cb+0x146>
 80205dc:	cd07      	ldmia	r5!, {r0, r1, r2}
 80205de:	6020      	str	r0, [r4, #0]
 80205e0:	6061      	str	r1, [r4, #4]
 80205e2:	60a2      	str	r2, [r4, #8]
 80205e4:	882a      	ldrh	r2, [r5, #0]
 80205e6:	78ab      	ldrb	r3, [r5, #2]
 80205e8:	81a2      	strh	r2, [r4, #12]
 80205ea:	73a3      	strb	r3, [r4, #14]
 80205ec:	4c1d      	ldr	r4, [pc, #116]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 80205ee:	4620      	mov	r0, r4
 80205f0:	f7fe fe9b 	bl	801f32a <crs_strlen>
 80205f4:	b283      	uxth	r3, r0
 80205f6:	4622      	mov	r2, r4
 80205f8:	2110      	movs	r1, #16
 80205fa:	2003      	movs	r0, #3
 80205fc:	f7fe fed8 	bl	801f3b0 <traceIF_itmPrint>
 8020600:	4620      	mov	r0, r4
 8020602:	f7fe fe92 	bl	801f32a <crs_strlen>
 8020606:	b283      	uxth	r3, r0
 8020608:	4622      	mov	r2, r4
 802060a:	2110      	movs	r1, #16
 802060c:	2003      	movs	r0, #3
 802060e:	f7fe fef1 	bl	801f3f4 <traceIF_uartPrint>
 8020612:	e75e      	b.n	80204d2 <com_ip_modem_data_ready_cb+0x52>
    PRINT_ERR("cb socket data ready called: unknown socket")
 8020614:	4d19      	ldr	r5, [pc, #100]	; (802067c <com_ip_modem_data_ready_cb+0x1fc>)
 8020616:	4c13      	ldr	r4, [pc, #76]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 8020618:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 802061c:	46ac      	mov	ip, r5
 802061e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020622:	6020      	str	r0, [r4, #0]
 8020624:	6061      	str	r1, [r4, #4]
 8020626:	60a2      	str	r2, [r4, #8]
 8020628:	60e3      	str	r3, [r4, #12]
 802062a:	4665      	mov	r5, ip
 802062c:	3410      	adds	r4, #16
 802062e:	45f4      	cmp	ip, lr
 8020630:	d1f4      	bne.n	802061c <com_ip_modem_data_ready_cb+0x19c>
 8020632:	cd07      	ldmia	r5!, {r0, r1, r2}
 8020634:	6020      	str	r0, [r4, #0]
 8020636:	6061      	str	r1, [r4, #4]
 8020638:	60a2      	str	r2, [r4, #8]
 802063a:	4c0a      	ldr	r4, [pc, #40]	; (8020664 <com_ip_modem_data_ready_cb+0x1e4>)
 802063c:	4620      	mov	r0, r4
 802063e:	f7fe fe74 	bl	801f32a <crs_strlen>
 8020642:	b283      	uxth	r3, r0
 8020644:	4622      	mov	r2, r4
 8020646:	2110      	movs	r1, #16
 8020648:	2003      	movs	r0, #3
 802064a:	f7fe feb1 	bl	801f3b0 <traceIF_itmPrint>
 802064e:	4620      	mov	r0, r4
 8020650:	f7fe fe6b 	bl	801f32a <crs_strlen>
 8020654:	b283      	uxth	r3, r0
 8020656:	4622      	mov	r2, r4
 8020658:	2110      	movs	r1, #16
 802065a:	2003      	movs	r0, #3
 802065c:	f7fe feca 	bl	801f3f4 <traceIF_uartPrint>
}
 8020660:	e737      	b.n	80204d2 <com_ip_modem_data_ready_cb+0x52>
 8020662:	bf00      	nop
 8020664:	200049dc 	.word	0x200049dc
 8020668:	080361b8 	.word	0x080361b8
 802066c:	08036148 	.word	0x08036148
 8020670:	080360e0 	.word	0x080360e0
 8020674:	08036180 	.word	0x08036180
 8020678:	080361f4 	.word	0x080361f4
 802067c:	08036234 	.word	0x08036234

08020680 <com_ip_modem_init_socket_desc>:
  socket_desc->state            = COM_SOCKET_INVALID;
 8020680:	2300      	movs	r3, #0
 8020682:	7003      	strb	r3, [r0, #0]
  socket_desc->local            = false;
 8020684:	7043      	strb	r3, [r0, #1]
  socket_desc->closing          = false;
 8020686:	7083      	strb	r3, [r0, #2]
  socket_desc->id               = COM_SOCKET_INVALID_ID;
 8020688:	f04f 32ff 	mov.w	r2, #4294967295
 802068c:	6082      	str	r2, [r0, #8]
  socket_desc->local_port       = 0U;
 802068e:	8183      	strh	r3, [r0, #12]
  socket_desc->remote_port      = 0U;
 8020690:	81c3      	strh	r3, [r0, #14]
  socket_desc->remote_addr.addr = 0U;
 8020692:	6103      	str	r3, [r0, #16]
  (void)memset((void *)&socket_desc->remote_addr, 0, sizeof(socket_desc->remote_addr));
 8020694:	6103      	str	r3, [r0, #16]
  socket_desc->rcv_timeout      = RTOSAL_WAIT_FOREVER;
 8020696:	6182      	str	r2, [r0, #24]
  socket_desc->snd_timeout      = RTOSAL_WAIT_FOREVER;
 8020698:	6142      	str	r2, [r0, #20]
  socket_desc->error            = COM_SOCKETS_ERR_OK;
 802069a:	6043      	str	r3, [r0, #4]
}
 802069c:	4770      	bx	lr

0802069e <com_ip_modem_create_socket_desc>:
{
 802069e:	b538      	push	{r3, r4, r5, lr}
  socket_desc = (socket_desc_t *)pvPortMalloc(sizeof(socket_desc_t));
 80206a0:	2028      	movs	r0, #40	; 0x28
 80206a2:	f003 ffd1 	bl	8024648 <pvPortMalloc>
  if (socket_desc != NULL)
 80206a6:	4604      	mov	r4, r0
 80206a8:	b158      	cbz	r0, 80206c2 <com_ip_modem_create_socket_desc+0x24>
    socket_desc->queue = rtosalMessageQueueNew(NULL, 4U);
 80206aa:	2104      	movs	r1, #4
 80206ac:	2000      	movs	r0, #0
 80206ae:	f7fe fd5e 	bl	801f16e <rtosalMessageQueueNew>
 80206b2:	4605      	mov	r5, r0
 80206b4:	61e0      	str	r0, [r4, #28]
    if (socket_desc->queue == NULL)
 80206b6:	b130      	cbz	r0, 80206c6 <com_ip_modem_create_socket_desc+0x28>
      socket_desc->next = NULL;
 80206b8:	2300      	movs	r3, #0
 80206ba:	6263      	str	r3, [r4, #36]	; 0x24
      com_ip_modem_init_socket_desc(socket_desc);
 80206bc:	4620      	mov	r0, r4
 80206be:	f7ff ffdf 	bl	8020680 <com_ip_modem_init_socket_desc>
}
 80206c2:	4620      	mov	r0, r4
 80206c4:	bd38      	pop	{r3, r4, r5, pc}
      vPortFree(socket_desc);
 80206c6:	4620      	mov	r0, r4
 80206c8:	f004 f836 	bl	8024738 <vPortFree>
      socket_desc = NULL;
 80206cc:	462c      	mov	r4, r5
 80206ce:	e7f8      	b.n	80206c2 <com_ip_modem_create_socket_desc+0x24>

080206d0 <com_ip_modem_provide_socket_desc>:
{
 80206d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80206d4:	4606      	mov	r6, r0
  (void)rtosalMutexAcquire(ComSocketsMutexHandle, RTOSAL_WAIT_FOREVER);
 80206d6:	f04f 31ff 	mov.w	r1, #4294967295
 80206da:	4b2e      	ldr	r3, [pc, #184]	; (8020794 <com_ip_modem_provide_socket_desc+0xc4>)
 80206dc:	6818      	ldr	r0, [r3, #0]
 80206de:	f7fe fd3e 	bl	801f15e <rtosalMutexAcquire>
  socket_desc = socket_desc_list;
 80206e2:	4b2d      	ldr	r3, [pc, #180]	; (8020798 <com_ip_modem_provide_socket_desc+0xc8>)
 80206e4:	681d      	ldr	r5, [r3, #0]
  if (local == true)
 80206e6:	b996      	cbnz	r6, 802070e <com_ip_modem_provide_socket_desc+0x3e>
  i = 0U;
 80206e8:	2400      	movs	r4, #0
  if ((found == true) && (i < COM_SOCKET_LOCAL_ID_NB))
 80206ea:	b1bc      	cbz	r4, 802071c <com_ip_modem_provide_socket_desc+0x4c>
  (void)rtosalMutexRelease(ComSocketsMutexHandle);
 80206ec:	4b29      	ldr	r3, [pc, #164]	; (8020794 <com_ip_modem_provide_socket_desc+0xc4>)
 80206ee:	6818      	ldr	r0, [r3, #0]
 80206f0:	f7fe fd39 	bl	801f166 <rtosalMutexRelease>
}
 80206f4:	4628      	mov	r0, r5
 80206f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        i++;
 80206fa:	3401      	adds	r4, #1
 80206fc:	b2e4      	uxtb	r4, r4
    while ((i < COM_SOCKET_LOCAL_ID_NB) && (found == false))
 80206fe:	b94c      	cbnz	r4, 8020714 <com_ip_modem_provide_socket_desc+0x44>
 8020700:	b942      	cbnz	r2, 8020714 <com_ip_modem_provide_socket_desc+0x44>
      if (socket_local_id[i] == false)
 8020702:	4b26      	ldr	r3, [pc, #152]	; (802079c <com_ip_modem_provide_socket_desc+0xcc>)
 8020704:	5d1b      	ldrb	r3, [r3, r4]
 8020706:	2b00      	cmp	r3, #0
 8020708:	d1f7      	bne.n	80206fa <com_ip_modem_provide_socket_desc+0x2a>
        found = true; /* an unused local id has been found */
 802070a:	4632      	mov	r2, r6
 802070c:	e7f7      	b.n	80206fe <com_ip_modem_provide_socket_desc+0x2e>
  i = 0U;
 802070e:	2400      	movs	r4, #0
  found = false;
 8020710:	4622      	mov	r2, r4
 8020712:	e7f4      	b.n	80206fe <com_ip_modem_provide_socket_desc+0x2e>
  if ((found == true) && (i < COM_SOCKET_LOCAL_ID_NB))
 8020714:	2a00      	cmp	r2, #0
 8020716:	d0e9      	beq.n	80206ec <com_ip_modem_provide_socket_desc+0x1c>
 8020718:	e7e7      	b.n	80206ea <com_ip_modem_provide_socket_desc+0x1a>
      socket_desc = socket_desc->next; /* Check next descriptor */
 802071a:	461d      	mov	r5, r3
    while ((socket_desc->state != COM_SOCKET_INVALID)
 802071c:	782a      	ldrb	r2, [r5, #0]
           && (socket_desc->next != NULL))
 802071e:	b112      	cbz	r2, 8020726 <com_ip_modem_provide_socket_desc+0x56>
 8020720:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8020722:	2b00      	cmp	r3, #0
 8020724:	d1f9      	bne.n	802071a <com_ip_modem_provide_socket_desc+0x4a>
    if (socket_desc->state != COM_SOCKET_INVALID)
 8020726:	b94a      	cbnz	r2, 802073c <com_ip_modem_provide_socket_desc+0x6c>
      socket_desc->state = COM_SOCKET_CREATING;
 8020728:	2301      	movs	r3, #1
 802072a:	702b      	strb	r3, [r5, #0]
      socket_desc->local = local;
 802072c:	706e      	strb	r6, [r5, #1]
      if (local == true)
 802072e:	2e00      	cmp	r6, #0
 8020730:	d0dc      	beq.n	80206ec <com_ip_modem_provide_socket_desc+0x1c>
        socket_desc->id = (int32_t)i;
 8020732:	60ac      	str	r4, [r5, #8]
        socket_local_id[i] = true;
 8020734:	4b19      	ldr	r3, [pc, #100]	; (802079c <com_ip_modem_provide_socket_desc+0xcc>)
 8020736:	2201      	movs	r2, #1
 8020738:	551a      	strb	r2, [r3, r4]
 802073a:	e7d7      	b.n	80206ec <com_ip_modem_provide_socket_desc+0x1c>
      socket_desc = com_ip_modem_create_socket_desc();
 802073c:	f7ff ffaf 	bl	802069e <com_ip_modem_create_socket_desc>
      if (socket_desc != NULL)
 8020740:	4607      	mov	r7, r0
 8020742:	b320      	cbz	r0, 802078e <com_ip_modem_provide_socket_desc+0xbe>
        PRINT_DBG("socket desc created %ld queue %p", socket_desc->id, socket_desc->queue)
 8020744:	f8df 805c 	ldr.w	r8, [pc, #92]	; 80207a4 <com_ip_modem_provide_socket_desc+0xd4>
 8020748:	69c3      	ldr	r3, [r0, #28]
 802074a:	6882      	ldr	r2, [r0, #8]
 802074c:	4914      	ldr	r1, [pc, #80]	; (80207a0 <com_ip_modem_provide_socket_desc+0xd0>)
 802074e:	4640      	mov	r0, r8
 8020750:	f006 f87a 	bl	8026848 <sprintf>
 8020754:	4640      	mov	r0, r8
 8020756:	f7fe fde8 	bl	801f32a <crs_strlen>
 802075a:	b283      	uxth	r3, r0
 802075c:	4642      	mov	r2, r8
 802075e:	2102      	movs	r1, #2
 8020760:	2003      	movs	r0, #3
 8020762:	f7fe fe25 	bl	801f3b0 <traceIF_itmPrint>
 8020766:	4640      	mov	r0, r8
 8020768:	f7fe fddf 	bl	801f32a <crs_strlen>
 802076c:	b283      	uxth	r3, r0
 802076e:	4642      	mov	r2, r8
 8020770:	2102      	movs	r1, #2
 8020772:	2003      	movs	r0, #3
 8020774:	f7fe fe3e 	bl	801f3f4 <traceIF_uartPrint>
        socket_desc->state = COM_SOCKET_CREATING;
 8020778:	2301      	movs	r3, #1
 802077a:	703b      	strb	r3, [r7, #0]
        socket_desc->local = local;
 802077c:	707e      	strb	r6, [r7, #1]
        if (local == true)
 802077e:	b11e      	cbz	r6, 8020788 <com_ip_modem_provide_socket_desc+0xb8>
          socket_desc->id = (int32_t)i;
 8020780:	60bc      	str	r4, [r7, #8]
          socket_local_id[i] = true;
 8020782:	4b06      	ldr	r3, [pc, #24]	; (802079c <com_ip_modem_provide_socket_desc+0xcc>)
 8020784:	2201      	movs	r2, #1
 8020786:	551a      	strb	r2, [r3, r4]
        socket_desc_previous->next = socket_desc;
 8020788:	626f      	str	r7, [r5, #36]	; 0x24
      socket_desc = com_ip_modem_create_socket_desc();
 802078a:	463d      	mov	r5, r7
 802078c:	e7ae      	b.n	80206ec <com_ip_modem_provide_socket_desc+0x1c>
 802078e:	4605      	mov	r5, r0
 8020790:	e7ac      	b.n	80206ec <com_ip_modem_provide_socket_desc+0x1c>
 8020792:	bf00      	nop
 8020794:	200058a0 	.word	0x200058a0
 8020798:	200058a8 	.word	0x200058a8
 802079c:	200058ac 	.word	0x200058ac
 80207a0:	08036270 	.word	0x08036270
 80207a4:	200049dc 	.word	0x200049dc

080207a8 <com_ip_modem_delete_socket_desc>:
{
 80207a8:	b538      	push	{r3, r4, r5, lr}
 80207aa:	4604      	mov	r4, r0
 80207ac:	460d      	mov	r5, r1
  (void)rtosalMutexAcquire(ComSocketsMutexHandle, RTOSAL_WAIT_FOREVER);
 80207ae:	f04f 31ff 	mov.w	r1, #4294967295
 80207b2:	4b10      	ldr	r3, [pc, #64]	; (80207f4 <com_ip_modem_delete_socket_desc+0x4c>)
 80207b4:	6818      	ldr	r0, [r3, #0]
 80207b6:	f7fe fcd2 	bl	801f15e <rtosalMutexAcquire>
  socket_desc = socket_desc_list;
 80207ba:	4b0f      	ldr	r3, [pc, #60]	; (80207f8 <com_ip_modem_delete_socket_desc+0x50>)
 80207bc:	6818      	ldr	r0, [r3, #0]
  found = false;
 80207be:	2200      	movs	r2, #0
  while ((socket_desc != NULL)
 80207c0:	e000      	b.n	80207c4 <com_ip_modem_delete_socket_desc+0x1c>
      socket_desc = socket_desc->next;
 80207c2:	6a40      	ldr	r0, [r0, #36]	; 0x24
         && (found != true))
 80207c4:	b140      	cbz	r0, 80207d8 <com_ip_modem_delete_socket_desc+0x30>
 80207c6:	b93a      	cbnz	r2, 80207d8 <com_ip_modem_delete_socket_desc+0x30>
    if ((socket_desc->id == sock)
 80207c8:	6883      	ldr	r3, [r0, #8]
 80207ca:	42a3      	cmp	r3, r4
 80207cc:	d1f9      	bne.n	80207c2 <com_ip_modem_delete_socket_desc+0x1a>
        && (socket_desc->local == local))
 80207ce:	7843      	ldrb	r3, [r0, #1]
 80207d0:	42ab      	cmp	r3, r5
 80207d2:	d1f6      	bne.n	80207c2 <com_ip_modem_delete_socket_desc+0x1a>
      found = true;
 80207d4:	2201      	movs	r2, #1
 80207d6:	e7f5      	b.n	80207c4 <com_ip_modem_delete_socket_desc+0x1c>
  if (found == true)
 80207d8:	b922      	cbnz	r2, 80207e4 <com_ip_modem_delete_socket_desc+0x3c>
  (void)rtosalMutexRelease(ComSocketsMutexHandle);
 80207da:	4b06      	ldr	r3, [pc, #24]	; (80207f4 <com_ip_modem_delete_socket_desc+0x4c>)
 80207dc:	6818      	ldr	r0, [r3, #0]
 80207de:	f7fe fcc2 	bl	801f166 <rtosalMutexRelease>
}
 80207e2:	bd38      	pop	{r3, r4, r5, pc}
    com_ip_modem_init_socket_desc(socket_desc);
 80207e4:	f7ff ff4c 	bl	8020680 <com_ip_modem_init_socket_desc>
    if (local == true)
 80207e8:	2d00      	cmp	r5, #0
 80207ea:	d0f6      	beq.n	80207da <com_ip_modem_delete_socket_desc+0x32>
      socket_local_id[sock] = false;
 80207ec:	4b03      	ldr	r3, [pc, #12]	; (80207fc <com_ip_modem_delete_socket_desc+0x54>)
 80207ee:	2200      	movs	r2, #0
 80207f0:	551a      	strb	r2, [r3, r4]
 80207f2:	e7f2      	b.n	80207da <com_ip_modem_delete_socket_desc+0x32>
 80207f4:	200058a0 	.word	0x200058a0
 80207f8:	200058a8 	.word	0x200058a8
 80207fc:	200058ac 	.word	0x200058ac

08020800 <com_convert_ipaddr_port_to_sockaddr>:
  sockaddr_in->sin_len         = (uint8_t)sizeof(com_sockaddr_in_t);
 8020800:	2310      	movs	r3, #16
 8020802:	7013      	strb	r3, [r2, #0]
  sockaddr_in->sin_family      = COM_AF_INET;
 8020804:	2302      	movs	r3, #2
 8020806:	7053      	strb	r3, [r2, #1]
  sockaddr_in->sin_addr.s_addr = ip_addr->addr;
 8020808:	6803      	ldr	r3, [r0, #0]
 802080a:	6053      	str	r3, [r2, #4]
  sockaddr_in->sin_port        = COM_HTONS(port);
 802080c:	ba49      	rev16	r1, r1
 802080e:	8051      	strh	r1, [r2, #2]
  (void) memset(sockaddr_in->sin_zero, 0, COM_SIN_ZERO_LEN);
 8020810:	2300      	movs	r3, #0
 8020812:	6093      	str	r3, [r2, #8]
 8020814:	60d3      	str	r3, [r2, #12]
}
 8020816:	4770      	bx	lr

08020818 <com_translate_ip_address>:
  if (addrlen == (int32_t)sizeof(com_sockaddr_in_t))
 8020818:	2910      	cmp	r1, #16
 802081a:	d001      	beq.n	8020820 <com_translate_ip_address+0x8>
  result = false;
 802081c:	2000      	movs	r0, #0
}
 802081e:	4770      	bx	lr
{
 8020820:	b530      	push	{r4, r5, lr}
 8020822:	b083      	sub	sp, #12
 8020824:	4604      	mov	r4, r0
 8020826:	4615      	mov	r5, r2
    if ((addr != NULL)
 8020828:	b328      	cbz	r0, 8020876 <com_translate_ip_address+0x5e>
        && (socket_addr != NULL))
 802082a:	b332      	cbz	r2, 802087a <com_translate_ip_address+0x62>
      if (addr->sa_family == (uint8_t)COM_AF_INET)
 802082c:	7843      	ldrb	r3, [r0, #1]
 802082e:	2b02      	cmp	r3, #2
 8020830:	d002      	beq.n	8020838 <com_translate_ip_address+0x20>
  result = false;
 8020832:	2000      	movs	r0, #0
}
 8020834:	b003      	add	sp, #12
 8020836:	bd30      	pop	{r4, r5, pc}
        socket_addr->ip_type = CS_IPAT_IPV4;
 8020838:	2301      	movs	r3, #1
 802083a:	7013      	strb	r3, [r2, #0]
        if (p_sockaddr_in->sin_addr.s_addr == COM_INADDR_ANY)
 802083c:	6842      	ldr	r2, [r0, #4]
 802083e:	b96a      	cbnz	r2, 802085c <com_translate_ip_address+0x44>
          (void)memcpy(&socket_addr->ip_value[0], "0.0.0.0", strlen("0.0.0.0"));
 8020840:	4b0f      	ldr	r3, [pc, #60]	; (8020880 <com_translate_ip_address+0x68>)
 8020842:	6818      	ldr	r0, [r3, #0]
 8020844:	f8c5 0001 	str.w	r0, [r5, #1]
 8020848:	889a      	ldrh	r2, [r3, #4]
 802084a:	799b      	ldrb	r3, [r3, #6]
 802084c:	f8a5 2005 	strh.w	r2, [r5, #5]
 8020850:	71eb      	strb	r3, [r5, #7]
        socket_addr->port = COM_NTOHS(((const com_sockaddr_in_t *)addr)->sin_port);
 8020852:	8863      	ldrh	r3, [r4, #2]
 8020854:	ba5b      	rev16	r3, r3
 8020856:	856b      	strh	r3, [r5, #42]	; 0x2a
        result = true;
 8020858:	2001      	movs	r0, #1
 802085a:	e7eb      	b.n	8020834 <com_translate_ip_address+0x1c>
          (void)sprintf((CSIP_CHAR_t *)socket_addr->ip_value,
 802085c:	0e13      	lsrs	r3, r2, #24
 802085e:	9301      	str	r3, [sp, #4]
 8020860:	f3c2 4307 	ubfx	r3, r2, #16, #8
 8020864:	9300      	str	r3, [sp, #0]
 8020866:	f3c2 2307 	ubfx	r3, r2, #8, #8
 802086a:	b2d2      	uxtb	r2, r2
 802086c:	4905      	ldr	r1, [pc, #20]	; (8020884 <com_translate_ip_address+0x6c>)
 802086e:	1c68      	adds	r0, r5, #1
 8020870:	f005 ffea 	bl	8026848 <sprintf>
 8020874:	e7ed      	b.n	8020852 <com_translate_ip_address+0x3a>
  result = false;
 8020876:	2000      	movs	r0, #0
 8020878:	e7dc      	b.n	8020834 <com_translate_ip_address+0x1c>
 802087a:	2000      	movs	r0, #0
 802087c:	e7da      	b.n	8020834 <com_translate_ip_address+0x1c>
 802087e:	bf00      	nop
 8020880:	0802b85c 	.word	0x0802b85c
 8020884:	0803629c 	.word	0x0803629c

08020888 <com_ip_modem_connect_udp_service>:
{
 8020888:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (socket_desc->state == COM_SOCKET_CREATED)
 802088a:	7803      	ldrb	r3, [r0, #0]
 802088c:	2b02      	cmp	r3, #2
 802088e:	d004      	beq.n	802089a <com_ip_modem_connect_udp_service+0x12>
  else if (socket_desc->state == COM_SOCKET_CONNECTED)
 8020890:	2b03      	cmp	r3, #3
 8020892:	f040 80bb 	bne.w	8020a0c <com_ip_modem_connect_udp_service+0x184>
    result = COM_SOCKETS_ERR_OK;
 8020896:	2000      	movs	r0, #0
}
 8020898:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802089a:	4604      	mov	r4, r0
    if (socket_desc->local_port == 0U)
 802089c:	8983      	ldrh	r3, [r0, #12]
 802089e:	b92b      	cbnz	r3, 80208ac <com_ip_modem_connect_udp_service+0x24>
      socket_desc->local_port = com_ip_modem_new_local_port();
 80208a0:	f7ff fcb6 	bl	8020210 <com_ip_modem_new_local_port>
 80208a4:	81a0      	strh	r0, [r4, #12]
      if (socket_desc->local_port == 0U)
 80208a6:	2800      	cmp	r0, #0
 80208a8:	f000 80d6 	beq.w	8020a58 <com_ip_modem_connect_udp_service+0x1d0>
      com_ip_modem_wakeup_request();
 80208ac:	f7ff fce8 	bl	8020280 <com_ip_modem_wakeup_request>
      if (osCDS_socket_bind(socket_desc->id,
 80208b0:	89a1      	ldrh	r1, [r4, #12]
 80208b2:	68a0      	ldr	r0, [r4, #8]
 80208b4:	f7fa f890 	bl	801a9d8 <osCDS_socket_bind>
 80208b8:	2800      	cmp	r0, #0
 80208ba:	d17c      	bne.n	80209b6 <com_ip_modem_connect_udp_service+0x12e>
        PRINT_INFO("socket internal bind ok")
 80208bc:	4e68      	ldr	r6, [pc, #416]	; (8020a60 <com_ip_modem_connect_udp_service+0x1d8>)
 80208be:	4d69      	ldr	r5, [pc, #420]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 80208c0:	f106 0720 	add.w	r7, r6, #32
 80208c4:	46b4      	mov	ip, r6
 80208c6:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80208ca:	6028      	str	r0, [r5, #0]
 80208cc:	6069      	str	r1, [r5, #4]
 80208ce:	60aa      	str	r2, [r5, #8]
 80208d0:	60eb      	str	r3, [r5, #12]
 80208d2:	4666      	mov	r6, ip
 80208d4:	3510      	adds	r5, #16
 80208d6:	45bc      	cmp	ip, r7
 80208d8:	d1f4      	bne.n	80208c4 <com_ip_modem_connect_udp_service+0x3c>
 80208da:	f8bc 3000 	ldrh.w	r3, [ip]
 80208de:	802b      	strh	r3, [r5, #0]
 80208e0:	4d60      	ldr	r5, [pc, #384]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 80208e2:	4628      	mov	r0, r5
 80208e4:	f7fe fd21 	bl	801f32a <crs_strlen>
 80208e8:	b283      	uxth	r3, r0
 80208ea:	462a      	mov	r2, r5
 80208ec:	2101      	movs	r1, #1
 80208ee:	2003      	movs	r0, #3
 80208f0:	f7fe fd5e 	bl	801f3b0 <traceIF_itmPrint>
 80208f4:	4628      	mov	r0, r5
 80208f6:	f7fe fd18 	bl	801f32a <crs_strlen>
 80208fa:	b283      	uxth	r3, r0
 80208fc:	462a      	mov	r2, r5
 80208fe:	2101      	movs	r1, #1
 8020900:	2003      	movs	r0, #3
 8020902:	f7fe fd77 	bl	801f3f4 <traceIF_uartPrint>
        if (osCDS_socket_connect(socket_desc->id,
 8020906:	2300      	movs	r3, #0
 8020908:	4a57      	ldr	r2, [pc, #348]	; (8020a68 <com_ip_modem_connect_udp_service+0x1e0>)
 802090a:	2101      	movs	r1, #1
 802090c:	68a0      	ldr	r0, [r4, #8]
 802090e:	f7fa f87f 	bl	801aa10 <osCDS_socket_connect>
 8020912:	bb38      	cbnz	r0, 8020964 <com_ip_modem_connect_udp_service+0xdc>
          PRINT_INFO("socket internal connect ok")
 8020914:	4f55      	ldr	r7, [pc, #340]	; (8020a6c <com_ip_modem_connect_udp_service+0x1e4>)
 8020916:	f107 0c20 	add.w	ip, r7, #32
 802091a:	463e      	mov	r6, r7
 802091c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 802091e:	6028      	str	r0, [r5, #0]
 8020920:	6069      	str	r1, [r5, #4]
 8020922:	60aa      	str	r2, [r5, #8]
 8020924:	60eb      	str	r3, [r5, #12]
 8020926:	4637      	mov	r7, r6
 8020928:	3510      	adds	r5, #16
 802092a:	4566      	cmp	r6, ip
 802092c:	d1f5      	bne.n	802091a <com_ip_modem_connect_udp_service+0x92>
 802092e:	6830      	ldr	r0, [r6, #0]
 8020930:	6028      	str	r0, [r5, #0]
 8020932:	7933      	ldrb	r3, [r6, #4]
 8020934:	712b      	strb	r3, [r5, #4]
 8020936:	4d4b      	ldr	r5, [pc, #300]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 8020938:	4628      	mov	r0, r5
 802093a:	f7fe fcf6 	bl	801f32a <crs_strlen>
 802093e:	b283      	uxth	r3, r0
 8020940:	462a      	mov	r2, r5
 8020942:	2101      	movs	r1, #1
 8020944:	2003      	movs	r0, #3
 8020946:	f7fe fd33 	bl	801f3b0 <traceIF_itmPrint>
 802094a:	4628      	mov	r0, r5
 802094c:	f7fe fced 	bl	801f32a <crs_strlen>
 8020950:	b283      	uxth	r3, r0
 8020952:	462a      	mov	r2, r5
 8020954:	2101      	movs	r1, #1
 8020956:	2003      	movs	r0, #3
 8020958:	f7fe fd4c 	bl	801f3f4 <traceIF_uartPrint>
          socket_desc->state = COM_SOCKET_CONNECTED;
 802095c:	2303      	movs	r3, #3
 802095e:	7023      	strb	r3, [r4, #0]
          result = COM_SOCKETS_ERR_OK;
 8020960:	2000      	movs	r0, #0
 8020962:	e799      	b.n	8020898 <com_ip_modem_connect_udp_service+0x10>
          PRINT_ERR("socket internal connect NOK at low level")
 8020964:	4d42      	ldr	r5, [pc, #264]	; (8020a70 <com_ip_modem_connect_udp_service+0x1e8>)
 8020966:	4c3f      	ldr	r4, [pc, #252]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 8020968:	f105 0730 	add.w	r7, r5, #48	; 0x30
 802096c:	462e      	mov	r6, r5
 802096e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020970:	6020      	str	r0, [r4, #0]
 8020972:	6061      	str	r1, [r4, #4]
 8020974:	60a2      	str	r2, [r4, #8]
 8020976:	60e3      	str	r3, [r4, #12]
 8020978:	4635      	mov	r5, r6
 802097a:	3410      	adds	r4, #16
 802097c:	42be      	cmp	r6, r7
 802097e:	d1f5      	bne.n	802096c <com_ip_modem_connect_udp_service+0xe4>
 8020980:	cd03      	ldmia	r5!, {r0, r1}
 8020982:	6020      	str	r0, [r4, #0]
 8020984:	6061      	str	r1, [r4, #4]
 8020986:	782b      	ldrb	r3, [r5, #0]
 8020988:	7223      	strb	r3, [r4, #8]
 802098a:	4c36      	ldr	r4, [pc, #216]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 802098c:	4620      	mov	r0, r4
 802098e:	f7fe fccc 	bl	801f32a <crs_strlen>
 8020992:	b283      	uxth	r3, r0
 8020994:	4622      	mov	r2, r4
 8020996:	2110      	movs	r1, #16
 8020998:	2003      	movs	r0, #3
 802099a:	f7fe fd09 	bl	801f3b0 <traceIF_itmPrint>
 802099e:	4620      	mov	r0, r4
 80209a0:	f7fe fcc3 	bl	801f32a <crs_strlen>
 80209a4:	b283      	uxth	r3, r0
 80209a6:	4622      	mov	r2, r4
 80209a8:	2110      	movs	r1, #16
 80209aa:	2003      	movs	r0, #3
 80209ac:	f7fe fd22 	bl	801f3f4 <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_GENERAL;
 80209b0:	f04f 30ff 	mov.w	r0, #4294967295
 80209b4:	e770      	b.n	8020898 <com_ip_modem_connect_udp_service+0x10>
        PRINT_ERR("socket internal bind NOK at low level")
 80209b6:	4d2f      	ldr	r5, [pc, #188]	; (8020a74 <com_ip_modem_connect_udp_service+0x1ec>)
 80209b8:	4c2a      	ldr	r4, [pc, #168]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 80209ba:	f105 0630 	add.w	r6, r5, #48	; 0x30
 80209be:	46ac      	mov	ip, r5
 80209c0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80209c4:	6020      	str	r0, [r4, #0]
 80209c6:	6061      	str	r1, [r4, #4]
 80209c8:	60a2      	str	r2, [r4, #8]
 80209ca:	60e3      	str	r3, [r4, #12]
 80209cc:	4665      	mov	r5, ip
 80209ce:	3410      	adds	r4, #16
 80209d0:	45b4      	cmp	ip, r6
 80209d2:	d1f4      	bne.n	80209be <com_ip_modem_connect_udp_service+0x136>
 80209d4:	f8dc 0000 	ldr.w	r0, [ip]
 80209d8:	6020      	str	r0, [r4, #0]
 80209da:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80209de:	80a3      	strh	r3, [r4, #4]
 80209e0:	4c20      	ldr	r4, [pc, #128]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 80209e2:	4620      	mov	r0, r4
 80209e4:	f7fe fca1 	bl	801f32a <crs_strlen>
 80209e8:	b283      	uxth	r3, r0
 80209ea:	4622      	mov	r2, r4
 80209ec:	2110      	movs	r1, #16
 80209ee:	2003      	movs	r0, #3
 80209f0:	f7fe fcde 	bl	801f3b0 <traceIF_itmPrint>
 80209f4:	4620      	mov	r0, r4
 80209f6:	f7fe fc98 	bl	801f32a <crs_strlen>
 80209fa:	b283      	uxth	r3, r0
 80209fc:	4622      	mov	r2, r4
 80209fe:	2110      	movs	r1, #16
 8020a00:	2003      	movs	r0, #3
 8020a02:	f7fe fcf7 	bl	801f3f4 <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_GENERAL;
 8020a06:	f04f 30ff 	mov.w	r0, #4294967295
      com_ip_modem_idlemode_request(false);
 8020a0a:	e745      	b.n	8020898 <com_ip_modem_connect_udp_service+0x10>
    PRINT_ERR("socket internal connect - err state")
 8020a0c:	4e1a      	ldr	r6, [pc, #104]	; (8020a78 <com_ip_modem_connect_udp_service+0x1f0>)
 8020a0e:	4d15      	ldr	r5, [pc, #84]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 8020a10:	f106 0730 	add.w	r7, r6, #48	; 0x30
 8020a14:	4634      	mov	r4, r6
 8020a16:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020a18:	6028      	str	r0, [r5, #0]
 8020a1a:	6069      	str	r1, [r5, #4]
 8020a1c:	60aa      	str	r2, [r5, #8]
 8020a1e:	60eb      	str	r3, [r5, #12]
 8020a20:	4626      	mov	r6, r4
 8020a22:	3510      	adds	r5, #16
 8020a24:	42bc      	cmp	r4, r7
 8020a26:	d1f5      	bne.n	8020a14 <com_ip_modem_connect_udp_service+0x18c>
 8020a28:	6820      	ldr	r0, [r4, #0]
 8020a2a:	6028      	str	r0, [r5, #0]
 8020a2c:	4c0d      	ldr	r4, [pc, #52]	; (8020a64 <com_ip_modem_connect_udp_service+0x1dc>)
 8020a2e:	4620      	mov	r0, r4
 8020a30:	f7fe fc7b 	bl	801f32a <crs_strlen>
 8020a34:	b283      	uxth	r3, r0
 8020a36:	4622      	mov	r2, r4
 8020a38:	2110      	movs	r1, #16
 8020a3a:	2003      	movs	r0, #3
 8020a3c:	f7fe fcb8 	bl	801f3b0 <traceIF_itmPrint>
 8020a40:	4620      	mov	r0, r4
 8020a42:	f7fe fc72 	bl	801f32a <crs_strlen>
 8020a46:	b283      	uxth	r3, r0
 8020a48:	4622      	mov	r2, r4
 8020a4a:	2110      	movs	r1, #16
 8020a4c:	2003      	movs	r0, #3
 8020a4e:	f7fe fcd1 	bl	801f3f4 <traceIF_uartPrint>
  result = COM_SOCKETS_ERR_STATE;
 8020a52:	f06f 000c 	mvn.w	r0, #12
 8020a56:	e71f      	b.n	8020898 <com_ip_modem_connect_udp_service+0x10>
        result = COM_SOCKETS_ERR_LOCKED;
 8020a58:	f06f 0006 	mvn.w	r0, #6
 8020a5c:	e71c      	b.n	8020898 <com_ip_modem_connect_udp_service+0x10>
 8020a5e:	bf00      	nop
 8020a60:	080362b4 	.word	0x080362b4
 8020a64:	200049dc 	.word	0x200049dc
 8020a68:	0802b85c 	.word	0x0802b85c
 8020a6c:	080362d8 	.word	0x080362d8
 8020a70:	08036300 	.word	0x08036300
 8020a74:	0803633c 	.word	0x0803633c
 8020a78:	08036374 	.word	0x08036374

08020a7c <com_ip_modem_empty_queue>:
{
 8020a7c:	b570      	push	{r4, r5, r6, lr}
 8020a7e:	b082      	sub	sp, #8
 8020a80:	4606      	mov	r6, r0
 8020a82:	e001      	b.n	8020a88 <com_ip_modem_empty_queue+0xc>
  } while (msg_queue != 0U);
 8020a84:	9b01      	ldr	r3, [sp, #4]
 8020a86:	b353      	cbz	r3, 8020ade <com_ip_modem_empty_queue+0x62>
    msg_queue = 0U;
 8020a88:	2200      	movs	r2, #0
 8020a8a:	9201      	str	r2, [sp, #4]
    (void)rtosalMessageQueueGet(queue, &msg_queue, 0U);
 8020a8c:	a901      	add	r1, sp, #4
 8020a8e:	4630      	mov	r0, r6
 8020a90:	f7fe fb7d 	bl	801f18e <rtosalMessageQueueGet>
    if (msg_queue != 0U)
 8020a94:	9b01      	ldr	r3, [sp, #4]
 8020a96:	2b00      	cmp	r3, #0
 8020a98:	d0f4      	beq.n	8020a84 <com_ip_modem_empty_queue+0x8>
      PRINT_DBG("rcv cleanup MSGqueue")
 8020a9a:	4c12      	ldr	r4, [pc, #72]	; (8020ae4 <com_ip_modem_empty_queue+0x68>)
 8020a9c:	4d12      	ldr	r5, [pc, #72]	; (8020ae8 <com_ip_modem_empty_queue+0x6c>)
 8020a9e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020aa0:	6020      	str	r0, [r4, #0]
 8020aa2:	6061      	str	r1, [r4, #4]
 8020aa4:	60a2      	str	r2, [r4, #8]
 8020aa6:	60e3      	str	r3, [r4, #12]
 8020aa8:	cd07      	ldmia	r5!, {r0, r1, r2}
 8020aaa:	6120      	str	r0, [r4, #16]
 8020aac:	6161      	str	r1, [r4, #20]
 8020aae:	61a2      	str	r2, [r4, #24]
 8020ab0:	882a      	ldrh	r2, [r5, #0]
 8020ab2:	78ab      	ldrb	r3, [r5, #2]
 8020ab4:	83a2      	strh	r2, [r4, #28]
 8020ab6:	77a3      	strb	r3, [r4, #30]
 8020ab8:	4620      	mov	r0, r4
 8020aba:	f7fe fc36 	bl	801f32a <crs_strlen>
 8020abe:	b283      	uxth	r3, r0
 8020ac0:	4622      	mov	r2, r4
 8020ac2:	2102      	movs	r1, #2
 8020ac4:	2003      	movs	r0, #3
 8020ac6:	f7fe fc73 	bl	801f3b0 <traceIF_itmPrint>
 8020aca:	4620      	mov	r0, r4
 8020acc:	f7fe fc2d 	bl	801f32a <crs_strlen>
 8020ad0:	b283      	uxth	r3, r0
 8020ad2:	4622      	mov	r2, r4
 8020ad4:	2102      	movs	r1, #2
 8020ad6:	2003      	movs	r0, #3
 8020ad8:	f7fe fc8c 	bl	801f3f4 <traceIF_uartPrint>
 8020adc:	e7d2      	b.n	8020a84 <com_ip_modem_empty_queue+0x8>
}
 8020ade:	b002      	add	sp, #8
 8020ae0:	bd70      	pop	{r4, r5, r6, pc}
 8020ae2:	bf00      	nop
 8020ae4:	200049dc 	.word	0x200049dc
 8020ae8:	080363a8 	.word	0x080363a8

08020aec <com_socket_datacache_cb>:
                                    const void *private_gui_data)
{
  UNUSED(private_gui_data);

  /* Used to know Network status */
  if (dc_event_id == DC_COM_NIFMAN_INFO)
 8020aec:	4b14      	ldr	r3, [pc, #80]	; (8020b40 <com_socket_datacache_cb+0x54>)
 8020aee:	8819      	ldrh	r1, [r3, #0]
 8020af0:	4288      	cmp	r0, r1
 8020af2:	d000      	beq.n	8020af6 <com_socket_datacache_cb+0xa>
 8020af4:	4770      	bx	lr
{
 8020af6:	b500      	push	{lr}
 8020af8:	b085      	sub	sp, #20
  {
    dc_nifman_info_t  dc_nifman_rt_info;

    if (dc_com_read(&dc_com_db, DC_COM_NIFMAN_INFO,
 8020afa:	2310      	movs	r3, #16
 8020afc:	466a      	mov	r2, sp
 8020afe:	4811      	ldr	r0, [pc, #68]	; (8020b44 <com_socket_datacache_cb+0x58>)
 8020b00:	f001 fb16 	bl	8022130 <dc_com_read>
 8020b04:	b130      	cbz	r0, 8020b14 <com_socket_datacache_cb+0x28>
                    (void *)&dc_nifman_rt_info,
                    sizeof(dc_nifman_rt_info))
        == DC_COM_OK)
    {
      if (dc_nifman_rt_info.rt_state == DC_SERVICE_ON)
 8020b06:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8020b0a:	2b07      	cmp	r3, #7
 8020b0c:	d005      	beq.n	8020b1a <com_socket_datacache_cb+0x2e>
        }
      }
      else
      {
        /* Filtering multiple same notification */
        if (com_ip_modem_is_network_up() == true)
 8020b0e:	f7ff fb79 	bl	8020204 <com_ip_modem_is_network_up>
 8020b12:	b968      	cbnz	r0, 8020b30 <com_socket_datacache_cb+0x44>
  }
  else
  {
    /* Nothing to do */
  }
}
 8020b14:	b005      	add	sp, #20
 8020b16:	f85d fb04 	ldr.w	pc, [sp], #4
        if (com_ip_modem_is_network_up() == false)
 8020b1a:	f7ff fb73 	bl	8020204 <com_ip_modem_is_network_up>
 8020b1e:	2800      	cmp	r0, #0
 8020b20:	d1f8      	bne.n	8020b14 <com_socket_datacache_cb+0x28>
          com_sockets_network_is_up = true;
 8020b22:	4b09      	ldr	r3, [pc, #36]	; (8020b48 <com_socket_datacache_cb+0x5c>)
 8020b24:	2201      	movs	r2, #1
 8020b26:	701a      	strb	r2, [r3, #0]
          com_sockets_statistic_update(COM_SOCKET_STAT_NWK_UP);
 8020b28:	200a      	movs	r0, #10
 8020b2a:	f001 fa4f 	bl	8021fcc <com_sockets_statistic_update>
 8020b2e:	e7f1      	b.n	8020b14 <com_socket_datacache_cb+0x28>
          com_sockets_network_is_up = false;
 8020b30:	4b05      	ldr	r3, [pc, #20]	; (8020b48 <com_socket_datacache_cb+0x5c>)
 8020b32:	2200      	movs	r2, #0
 8020b34:	701a      	strb	r2, [r3, #0]
          com_sockets_statistic_update(COM_SOCKET_STAT_NWK_DWN);
 8020b36:	200b      	movs	r0, #11
 8020b38:	f001 fa48 	bl	8021fcc <com_sockets_statistic_update>
}
 8020b3c:	e7ea      	b.n	8020b14 <com_socket_datacache_cb+0x28>
 8020b3e:	bf00      	nop
 8020b40:	2000023a 	.word	0x2000023a
 8020b44:	200058b0 	.word	0x200058b0
 8020b48:	200058a6 	.word	0x200058a6

08020b4c <com_setsockopt_ip_modem>:
  * @param  optlen    - size of the buffer containing the option value
  * @retval int32_t   - ok or error value
  */
int32_t com_setsockopt_ip_modem(int32_t sock, int32_t level, int32_t optname,
                                const void *optval, int32_t optlen)
{
 8020b4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8020b50:	4688      	mov	r8, r1
 8020b52:	4617      	mov	r7, r2
 8020b54:	461c      	mov	r4, r3
 8020b56:	9e06      	ldr	r6, [sp, #24]
  int32_t result;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;
  socket_desc = com_ip_modem_find_socket(sock, false);
 8020b58:	2100      	movs	r1, #0
 8020b5a:	f7ff fb33 	bl	80201c4 <com_ip_modem_find_socket>

  if (socket_desc != NULL)
 8020b5e:	4605      	mov	r5, r0
 8020b60:	b358      	cbz	r0, 8020bba <com_setsockopt_ip_modem+0x6e>
  {
    if ((optval != NULL)
 8020b62:	b36c      	cbz	r4, 8020bc0 <com_setsockopt_ip_modem+0x74>
        && (optlen > 0))
 8020b64:	2e00      	cmp	r6, #0
 8020b66:	dd2e      	ble.n	8020bc6 <com_setsockopt_ip_modem+0x7a>
    {
      com_ip_modem_wakeup_request();
 8020b68:	f7ff fb8a 	bl	8020280 <com_ip_modem_wakeup_request>
      if (level == COM_SOL_SOCKET)
 8020b6c:	f640 73ff 	movw	r3, #4095	; 0xfff
 8020b70:	4598      	cmp	r8, r3
 8020b72:	d005      	beq.n	8020b80 <com_setsockopt_ip_modem+0x34>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020b74:	f06f 0002 	mvn.w	r0, #2
  else
  {
    result = COM_SOCKETS_ERR_DESCRIPTOR;
  }

  SOCKET_SET_ERROR(socket_desc, result);
 8020b78:	b105      	cbz	r5, 8020b7c <com_setsockopt_ip_modem+0x30>
 8020b7a:	6068      	str	r0, [r5, #4]
  return result;
}
 8020b7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        switch (optname)
 8020b80:	f241 0305 	movw	r3, #4101	; 0x1005
 8020b84:	429f      	cmp	r7, r3
 8020b86:	d006      	beq.n	8020b96 <com_setsockopt_ip_modem+0x4a>
 8020b88:	f241 0306 	movw	r3, #4102	; 0x1006
 8020b8c:	429f      	cmp	r7, r3
 8020b8e:	d008      	beq.n	8020ba2 <com_setsockopt_ip_modem+0x56>
 8020b90:	f06f 0002 	mvn.w	r0, #2
 8020b94:	e7f0      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
            if ((uint32_t)optlen <= sizeof(socket_desc->rcv_timeout))
 8020b96:	2e04      	cmp	r6, #4
 8020b98:	d809      	bhi.n	8020bae <com_setsockopt_ip_modem+0x62>
              socket_desc->snd_timeout = *(const uint32_t *)optval;
 8020b9a:	6823      	ldr	r3, [r4, #0]
 8020b9c:	616b      	str	r3, [r5, #20]
              result = COM_SOCKETS_ERR_OK;
 8020b9e:	2000      	movs	r0, #0
 8020ba0:	e7ea      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
            if ((uint32_t)optlen <= sizeof(socket_desc->rcv_timeout))
 8020ba2:	2e04      	cmp	r6, #4
 8020ba4:	d806      	bhi.n	8020bb4 <com_setsockopt_ip_modem+0x68>
              socket_desc->rcv_timeout = *(const uint32_t *)optval;
 8020ba6:	6823      	ldr	r3, [r4, #0]
 8020ba8:	61ab      	str	r3, [r5, #24]
              result = COM_SOCKETS_ERR_OK;
 8020baa:	2000      	movs	r0, #0
 8020bac:	e7e4      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020bae:	f06f 0002 	mvn.w	r0, #2
 8020bb2:	e7e1      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
 8020bb4:	f06f 0002 	mvn.w	r0, #2
      com_ip_modem_idlemode_request(false);
 8020bb8:	e7de      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
    result = COM_SOCKETS_ERR_DESCRIPTOR;
 8020bba:	f06f 0001 	mvn.w	r0, #1
 8020bbe:	e7db      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020bc0:	f06f 0002 	mvn.w	r0, #2
 8020bc4:	e7d8      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>
 8020bc6:	f06f 0002 	mvn.w	r0, #2
 8020bca:	e7d5      	b.n	8020b78 <com_setsockopt_ip_modem+0x2c>

08020bcc <com_connect_ip_modem>:
  * @param  addrlen   - addr length
  * @retval int32_t   - ok or error value
  */
int32_t com_connect_ip_modem(int32_t sock,
                             const com_sockaddr_t *addr, int32_t addrlen)
{
 8020bcc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8020bce:	b08f      	sub	sp, #60	; 0x3c
 8020bd0:	460f      	mov	r7, r1
 8020bd2:	4615      	mov	r5, r2
  socket_addr_t socket_addr;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;

  socket_desc = com_ip_modem_find_socket(sock, false);
 8020bd4:	2100      	movs	r1, #0
 8020bd6:	f7ff faf5 	bl	80201c4 <com_ip_modem_find_socket>

  /* Check parameters validity */
  if (socket_desc != NULL)
 8020bda:	4604      	mov	r4, r0
 8020bdc:	2800      	cmp	r0, #0
 8020bde:	f000 80ca 	beq.w	8020d76 <com_connect_ip_modem+0x1aa>
  {
    if (com_translate_ip_address(addr, addrlen,
 8020be2:	aa03      	add	r2, sp, #12
 8020be4:	4629      	mov	r1, r5
 8020be6:	4638      	mov	r0, r7
 8020be8:	f7ff fe16 	bl	8020818 <com_translate_ip_address>
 8020bec:	2800      	cmp	r0, #0
 8020bee:	f000 80c5 	beq.w	8020d7c <com_connect_ip_modem+0x1b0>
  }

  /* If parameters are valid continue the treatment */
  if (result == COM_SOCKETS_ERR_OK)
  {
    if (socket_desc->type == (uint8_t)COM_SOCK_STREAM)
 8020bf2:	78e3      	ldrb	r3, [r4, #3]
 8020bf4:	2b01      	cmp	r3, #1
 8020bf6:	f040 80b0 	bne.w	8020d5a <com_connect_ip_modem+0x18e>
    {
      if (socket_desc->state == COM_SOCKET_CREATED)
 8020bfa:	7823      	ldrb	r3, [r4, #0]
 8020bfc:	2b02      	cmp	r3, #2
 8020bfe:	f040 8081 	bne.w	8020d04 <com_connect_ip_modem+0x138>
      {
        /* Check Network status */
        if (com_ip_modem_is_network_up() == true)
 8020c02:	f7ff faff 	bl	8020204 <com_ip_modem_is_network_up>
 8020c06:	2800      	cmp	r0, #0
 8020c08:	d051      	beq.n	8020cae <com_connect_ip_modem+0xe2>
        {
          com_ip_modem_wakeup_request();
 8020c0a:	f7ff fb39 	bl	8020280 <com_ip_modem_wakeup_request>
          if (osCDS_socket_connect(socket_desc->id,
 8020c0e:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 8020c12:	f10d 020d 	add.w	r2, sp, #13
 8020c16:	f89d 100c 	ldrb.w	r1, [sp, #12]
 8020c1a:	68a0      	ldr	r0, [r4, #8]
 8020c1c:	f7f9 fef8 	bl	801aa10 <osCDS_socket_connect>
 8020c20:	bb00      	cbnz	r0, 8020c64 <com_connect_ip_modem+0x98>
                                   socket_addr.port)
              == CELLULAR_OK)
          {
            /* result already set to the correct value COM_SOCKETS_ERR_OK */
            /* result = COM_SOCKETS_ERR_OK; */
            PRINT_INFO("socket connect ok")
 8020c22:	4d5f      	ldr	r5, [pc, #380]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020c24:	4e5f      	ldr	r6, [pc, #380]	; (8020da4 <com_connect_ip_modem+0x1d8>)
 8020c26:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020c28:	6028      	str	r0, [r5, #0]
 8020c2a:	6069      	str	r1, [r5, #4]
 8020c2c:	60aa      	str	r2, [r5, #8]
 8020c2e:	60eb      	str	r3, [r5, #12]
 8020c30:	ce07      	ldmia	r6!, {r0, r1, r2}
 8020c32:	6128      	str	r0, [r5, #16]
 8020c34:	6169      	str	r1, [r5, #20]
 8020c36:	61aa      	str	r2, [r5, #24]
 8020c38:	4628      	mov	r0, r5
 8020c3a:	f7fe fb76 	bl	801f32a <crs_strlen>
 8020c3e:	b283      	uxth	r3, r0
 8020c40:	462a      	mov	r2, r5
 8020c42:	2101      	movs	r1, #1
 8020c44:	2003      	movs	r0, #3
 8020c46:	f7fe fbb3 	bl	801f3b0 <traceIF_itmPrint>
 8020c4a:	4628      	mov	r0, r5
 8020c4c:	f7fe fb6d 	bl	801f32a <crs_strlen>
 8020c50:	b283      	uxth	r3, r0
 8020c52:	462a      	mov	r2, r5
 8020c54:	2101      	movs	r1, #1
 8020c56:	2003      	movs	r0, #3
 8020c58:	f7fe fbcc 	bl	801f3f4 <traceIF_uartPrint>
            socket_desc->state = COM_SOCKET_CONNECTED;
 8020c5c:	2303      	movs	r3, #3
 8020c5e:	7023      	strb	r3, [r4, #0]
      result = COM_SOCKETS_ERR_OK;
 8020c60:	2500      	movs	r5, #0
 8020c62:	e07e      	b.n	8020d62 <com_connect_ip_modem+0x196>
          }
          else
          {
            result = COM_SOCKETS_ERR_GENERAL;
            PRINT_ERR("socket connect NOK at low level")
 8020c64:	f8df c148 	ldr.w	ip, [pc, #328]	; 8020db0 <com_connect_ip_modem+0x1e4>
 8020c68:	4e4d      	ldr	r6, [pc, #308]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020c6a:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 8020c6e:	4665      	mov	r5, ip
 8020c70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020c72:	6030      	str	r0, [r6, #0]
 8020c74:	6071      	str	r1, [r6, #4]
 8020c76:	60b2      	str	r2, [r6, #8]
 8020c78:	60f3      	str	r3, [r6, #12]
 8020c7a:	46ac      	mov	ip, r5
 8020c7c:	3610      	adds	r6, #16
 8020c7e:	4575      	cmp	r5, lr
 8020c80:	d1f5      	bne.n	8020c6e <com_connect_ip_modem+0xa2>
 8020c82:	4d47      	ldr	r5, [pc, #284]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020c84:	4628      	mov	r0, r5
 8020c86:	f7fe fb50 	bl	801f32a <crs_strlen>
 8020c8a:	b283      	uxth	r3, r0
 8020c8c:	462a      	mov	r2, r5
 8020c8e:	2110      	movs	r1, #16
 8020c90:	2003      	movs	r0, #3
 8020c92:	f7fe fb8d 	bl	801f3b0 <traceIF_itmPrint>
 8020c96:	4628      	mov	r0, r5
 8020c98:	f7fe fb47 	bl	801f32a <crs_strlen>
 8020c9c:	b283      	uxth	r3, r0
 8020c9e:	462a      	mov	r2, r5
 8020ca0:	2110      	movs	r1, #16
 8020ca2:	2003      	movs	r0, #3
 8020ca4:	f7fe fba6 	bl	801f3f4 <traceIF_uartPrint>
            result = COM_SOCKETS_ERR_GENERAL;
 8020ca8:	f04f 35ff 	mov.w	r5, #4294967295
          }
          com_ip_modem_idlemode_request(false);
 8020cac:	e059      	b.n	8020d62 <com_connect_ip_modem+0x196>
        }
        else
        {
          result = COM_SOCKETS_ERR_NONETWORK;
          PRINT_ERR("socket connect NOK no network")
 8020cae:	4e3e      	ldr	r6, [pc, #248]	; (8020da8 <com_connect_ip_modem+0x1dc>)
 8020cb0:	4d3b      	ldr	r5, [pc, #236]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020cb2:	f106 0e20 	add.w	lr, r6, #32
 8020cb6:	46b4      	mov	ip, r6
 8020cb8:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020cbc:	6028      	str	r0, [r5, #0]
 8020cbe:	6069      	str	r1, [r5, #4]
 8020cc0:	60aa      	str	r2, [r5, #8]
 8020cc2:	60eb      	str	r3, [r5, #12]
 8020cc4:	4666      	mov	r6, ip
 8020cc6:	3510      	adds	r5, #16
 8020cc8:	45f4      	cmp	ip, lr
 8020cca:	d1f4      	bne.n	8020cb6 <com_connect_ip_modem+0xea>
 8020ccc:	ce07      	ldmia	r6!, {r0, r1, r2}
 8020cce:	6028      	str	r0, [r5, #0]
 8020cd0:	6069      	str	r1, [r5, #4]
 8020cd2:	60aa      	str	r2, [r5, #8]
 8020cd4:	8833      	ldrh	r3, [r6, #0]
 8020cd6:	81ab      	strh	r3, [r5, #12]
 8020cd8:	4d31      	ldr	r5, [pc, #196]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020cda:	4628      	mov	r0, r5
 8020cdc:	f7fe fb25 	bl	801f32a <crs_strlen>
 8020ce0:	b283      	uxth	r3, r0
 8020ce2:	462a      	mov	r2, r5
 8020ce4:	2110      	movs	r1, #16
 8020ce6:	2003      	movs	r0, #3
 8020ce8:	f7fe fb62 	bl	801f3b0 <traceIF_itmPrint>
 8020cec:	4628      	mov	r0, r5
 8020cee:	f7fe fb1c 	bl	801f32a <crs_strlen>
 8020cf2:	b283      	uxth	r3, r0
 8020cf4:	462a      	mov	r2, r5
 8020cf6:	2110      	movs	r1, #16
 8020cf8:	2003      	movs	r0, #3
 8020cfa:	f7fe fb7b 	bl	801f3f4 <traceIF_uartPrint>
          result = COM_SOCKETS_ERR_NONETWORK;
 8020cfe:	f06f 050a 	mvn.w	r5, #10
 8020d02:	e02e      	b.n	8020d62 <com_connect_ip_modem+0x196>
        }
      }
      else
      {
        result = COM_SOCKETS_ERR_STATE;
        PRINT_ERR("socket connect NOK err state")
 8020d04:	4e29      	ldr	r6, [pc, #164]	; (8020dac <com_connect_ip_modem+0x1e0>)
 8020d06:	4d26      	ldr	r5, [pc, #152]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020d08:	f106 0e20 	add.w	lr, r6, #32
 8020d0c:	46b4      	mov	ip, r6
 8020d0e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020d12:	6028      	str	r0, [r5, #0]
 8020d14:	6069      	str	r1, [r5, #4]
 8020d16:	60aa      	str	r2, [r5, #8]
 8020d18:	60eb      	str	r3, [r5, #12]
 8020d1a:	4666      	mov	r6, ip
 8020d1c:	3510      	adds	r5, #16
 8020d1e:	45f4      	cmp	ip, lr
 8020d20:	d1f4      	bne.n	8020d0c <com_connect_ip_modem+0x140>
 8020d22:	ce07      	ldmia	r6!, {r0, r1, r2}
 8020d24:	6028      	str	r0, [r5, #0]
 8020d26:	6069      	str	r1, [r5, #4]
 8020d28:	60aa      	str	r2, [r5, #8]
 8020d2a:	7833      	ldrb	r3, [r6, #0]
 8020d2c:	732b      	strb	r3, [r5, #12]
 8020d2e:	4d1c      	ldr	r5, [pc, #112]	; (8020da0 <com_connect_ip_modem+0x1d4>)
 8020d30:	4628      	mov	r0, r5
 8020d32:	f7fe fafa 	bl	801f32a <crs_strlen>
 8020d36:	b283      	uxth	r3, r0
 8020d38:	462a      	mov	r2, r5
 8020d3a:	2110      	movs	r1, #16
 8020d3c:	2003      	movs	r0, #3
 8020d3e:	f7fe fb37 	bl	801f3b0 <traceIF_itmPrint>
 8020d42:	4628      	mov	r0, r5
 8020d44:	f7fe faf1 	bl	801f32a <crs_strlen>
 8020d48:	b283      	uxth	r3, r0
 8020d4a:	462a      	mov	r2, r5
 8020d4c:	2110      	movs	r1, #16
 8020d4e:	2003      	movs	r0, #3
 8020d50:	f7fe fb50 	bl	801f3f4 <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_STATE;
 8020d54:	f06f 050c 	mvn.w	r5, #12
 8020d58:	e003      	b.n	8020d62 <com_connect_ip_modem+0x196>
        PRINT_ERR("socket connect NOK err state")
      }
#else /* UDP_SERVICES_SUPPORTED == 1U */
      /* A specific udp service connection is done
         in order to be able to use sendto/recvfrom services */
      result = com_ip_modem_connect_udp_service(socket_desc);
 8020d5a:	4620      	mov	r0, r4
 8020d5c:	f7ff fd94 	bl	8020888 <com_ip_modem_connect_udp_service>
 8020d60:	4605      	mov	r5, r0
#endif /* UDP_SERVICES_SUPPORTED == 0U */
    }
  }
  if (socket_desc != NULL)
 8020d62:	b124      	cbz	r4, 8020d6e <com_connect_ip_modem+0x1a2>
  {
    /* if com_translate_ip_address == FALSE, result already set to COM_SOCKETS_ERR_PARAMETER */
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8020d64:	b96d      	cbnz	r5, 8020d82 <com_connect_ip_modem+0x1b6>
 8020d66:	2002      	movs	r0, #2
 8020d68:	f001 f930 	bl	8021fcc <com_sockets_statistic_update>
                                 COM_SOCKET_STAT_CNT_OK : COM_SOCKET_STAT_CNT_NOK);
    SOCKET_SET_ERROR(socket_desc, result);
 8020d6c:	6065      	str	r5, [r4, #4]
  }

  if (result == COM_SOCKETS_ERR_OK)
 8020d6e:	b155      	cbz	r5, 8020d86 <com_connect_ip_modem+0x1ba>
    socket_desc->remote_addr.addr = remote_addr.addr;
    socket_desc->remote_port = remote_port;
  }

  return result;
}
 8020d70:	4628      	mov	r0, r5
 8020d72:	b00f      	add	sp, #60	; 0x3c
 8020d74:	bdf0      	pop	{r4, r5, r6, r7, pc}
  result = COM_SOCKETS_ERR_PARAMETER;
 8020d76:	f06f 0502 	mvn.w	r5, #2
 8020d7a:	e7f2      	b.n	8020d62 <com_connect_ip_modem+0x196>
 8020d7c:	f06f 0502 	mvn.w	r5, #2
 8020d80:	e7ef      	b.n	8020d62 <com_connect_ip_modem+0x196>
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8020d82:	2003      	movs	r0, #3
 8020d84:	e7f0      	b.n	8020d68 <com_connect_ip_modem+0x19c>
    com_convert_sockaddr_to_ipaddr_port((const com_sockaddr_in_t *)addr,
 8020d86:	f10d 0206 	add.w	r2, sp, #6
 8020d8a:	a902      	add	r1, sp, #8
 8020d8c:	4638      	mov	r0, r7
 8020d8e:	f7ff fa33 	bl	80201f8 <com_convert_sockaddr_to_ipaddr_port>
    socket_desc->remote_addr.addr = remote_addr.addr;
 8020d92:	9b02      	ldr	r3, [sp, #8]
 8020d94:	6123      	str	r3, [r4, #16]
    socket_desc->remote_port = remote_port;
 8020d96:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8020d9a:	81e3      	strh	r3, [r4, #14]
  return result;
 8020d9c:	e7e8      	b.n	8020d70 <com_connect_ip_modem+0x1a4>
 8020d9e:	bf00      	nop
 8020da0:	200049dc 	.word	0x200049dc
 8020da4:	080363c8 	.word	0x080363c8
 8020da8:	08036414 	.word	0x08036414
 8020dac:	08036444 	.word	0x08036444
 8020db0:	080363e4 	.word	0x080363e4

08020db4 <com_sendto_ip_modem>:
  */
int32_t com_sendto_ip_modem(int32_t sock,
                            const com_char_t *buf, int32_t len,
                            int32_t flags,
                            const com_sockaddr_t *to, int32_t tolen)
{
 8020db4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8020db8:	b092      	sub	sp, #72	; 0x48
 8020dba:	4606      	mov	r6, r0
 8020dbc:	460c      	mov	r4, r1
 8020dbe:	4690      	mov	r8, r2
 8020dc0:	461d      	mov	r5, r3
  socket_desc_t *socket_desc;
  int32_t result;

  result = COM_SOCKETS_ERR_PARAMETER;
  socket_desc = com_ip_modem_find_socket(sock, false);
 8020dc2:	2100      	movs	r1, #0
 8020dc4:	f7ff f9fe 	bl	80201c4 <com_ip_modem_find_socket>

  if ((socket_desc != NULL)
 8020dc8:	4607      	mov	r7, r0
 8020dca:	2800      	cmp	r0, #0
 8020dcc:	f000 81d2 	beq.w	8021174 <com_sendto_ip_modem+0x3c0>
      && (buf != NULL)
 8020dd0:	2c00      	cmp	r4, #0
 8020dd2:	f000 81d7 	beq.w	8021184 <com_sendto_ip_modem+0x3d0>
      && (len > 0))
 8020dd6:	f1b8 0f00 	cmp.w	r8, #0
 8020dda:	f340 81d6 	ble.w	802118a <com_sendto_ip_modem+0x3d6>
  {
    if (socket_desc->type == (uint8_t)COM_SOCK_STREAM)
 8020dde:	78c3      	ldrb	r3, [r0, #3]
 8020de0:	2b01      	cmp	r3, #1
 8020de2:	d00d      	beq.n	8020e00 <com_sendto_ip_modem+0x4c>
      {
        bool is_network_up;
        socket_addr_t socket_addr;

        /* Check remote addr is valid */
        if ((to != NULL) && (tolen != 0))
 8020de4:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8020de6:	b10b      	cbz	r3, 8020dec <com_sendto_ip_modem+0x38>
 8020de8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8020dea:	bb4b      	cbnz	r3, 8020e40 <com_sendto_ip_modem+0x8c>
          /* else result = COM_SOCKETS_ERR_PARAMETER */
        }
        /* No address provided by connect previously done */
        /* a send translate to sendto */
        /* Use IPaddress of connect */
        else if ((to == NULL) && (tolen == 0)
 8020dec:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8020dee:	b383      	cbz	r3, 8020e52 <com_sendto_ip_modem+0x9e>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020df0:	f06f 0602 	mvn.w	r6, #2
      }
#endif /* UDP_SERVICE_SUPPORTED == 0U */
    }
  }

  if (result >= 0)
 8020df4:	2e00      	cmp	r6, #0
 8020df6:	f2c0 81bf 	blt.w	8021178 <com_sendto_ip_modem+0x3c4>
  {
    SOCKET_SET_ERROR(socket_desc, COM_SOCKETS_ERR_OK);
 8020dfa:	2300      	movs	r3, #0
 8020dfc:	607b      	str	r3, [r7, #4]
 8020dfe:	e1bd      	b.n	802117c <com_sendto_ip_modem+0x3c8>
      result = com_send_ip_modem(sock, buf, len, flags);
 8020e00:	462b      	mov	r3, r5
 8020e02:	4642      	mov	r2, r8
 8020e04:	4621      	mov	r1, r4
 8020e06:	4630      	mov	r0, r6
 8020e08:	f000 f9c6 	bl	8021198 <com_send_ip_modem>
 8020e0c:	4606      	mov	r6, r0
      PRINT_INFO("send data %s", buf)
 8020e0e:	4db9      	ldr	r5, [pc, #740]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020e10:	4622      	mov	r2, r4
 8020e12:	49b9      	ldr	r1, [pc, #740]	; (80210f8 <com_sendto_ip_modem+0x344>)
 8020e14:	4628      	mov	r0, r5
 8020e16:	f005 fd17 	bl	8026848 <sprintf>
 8020e1a:	4628      	mov	r0, r5
 8020e1c:	f7fe fa85 	bl	801f32a <crs_strlen>
 8020e20:	b283      	uxth	r3, r0
 8020e22:	462a      	mov	r2, r5
 8020e24:	2101      	movs	r1, #1
 8020e26:	2003      	movs	r0, #3
 8020e28:	f7fe fac2 	bl	801f3b0 <traceIF_itmPrint>
 8020e2c:	4628      	mov	r0, r5
 8020e2e:	f7fe fa7c 	bl	801f32a <crs_strlen>
 8020e32:	b283      	uxth	r3, r0
 8020e34:	462a      	mov	r2, r5
 8020e36:	2101      	movs	r1, #1
 8020e38:	2003      	movs	r0, #3
 8020e3a:	f7fe fadb 	bl	801f3f4 <traceIF_uartPrint>
 8020e3e:	e7d9      	b.n	8020df4 <com_sendto_ip_modem+0x40>
          if (com_translate_ip_address(to, tolen,
 8020e40:	aa07      	add	r2, sp, #28
 8020e42:	4619      	mov	r1, r3
 8020e44:	981a      	ldr	r0, [sp, #104]	; 0x68
 8020e46:	f7ff fce7 	bl	8020818 <com_translate_ip_address>
 8020e4a:	b9d0      	cbnz	r0, 8020e82 <com_sendto_ip_modem+0xce>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020e4c:	f06f 0602 	mvn.w	r6, #2
 8020e50:	e7d0      	b.n	8020df4 <com_sendto_ip_modem+0x40>
        else if ((to == NULL) && (tolen == 0)
 8020e52:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 8020e54:	2b00      	cmp	r3, #0
 8020e56:	f040 818a 	bne.w	802116e <com_sendto_ip_modem+0x3ba>
                 && (socket_desc->remote_addr.addr != 0U))
 8020e5a:	693b      	ldr	r3, [r7, #16]
 8020e5c:	b913      	cbnz	r3, 8020e64 <com_sendto_ip_modem+0xb0>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020e5e:	f06f 0602 	mvn.w	r6, #2
        }
 8020e62:	e7c7      	b.n	8020df4 <com_sendto_ip_modem+0x40>
          remote_addr.addr = socket_desc->remote_addr.addr;
 8020e64:	9302      	str	r3, [sp, #8]
          com_convert_ipaddr_port_to_sockaddr(&remote_addr,
 8020e66:	aa03      	add	r2, sp, #12
 8020e68:	89f9      	ldrh	r1, [r7, #14]
 8020e6a:	a802      	add	r0, sp, #8
 8020e6c:	f7ff fcc8 	bl	8020800 <com_convert_ipaddr_port_to_sockaddr>
          if (com_translate_ip_address((com_sockaddr_t *)&sockaddr_in,
 8020e70:	aa07      	add	r2, sp, #28
 8020e72:	2110      	movs	r1, #16
 8020e74:	a803      	add	r0, sp, #12
 8020e76:	f7ff fccf 	bl	8020818 <com_translate_ip_address>
 8020e7a:	b910      	cbnz	r0, 8020e82 <com_sendto_ip_modem+0xce>
  result = COM_SOCKETS_ERR_PARAMETER;
 8020e7c:	f06f 0602 	mvn.w	r6, #2
 8020e80:	e7b8      	b.n	8020df4 <com_sendto_ip_modem+0x40>
          result = com_ip_modem_connect_udp_service(socket_desc);
 8020e82:	4638      	mov	r0, r7
 8020e84:	f7ff fd00 	bl	8020888 <com_ip_modem_connect_udp_service>
          if ((result == COM_SOCKETS_ERR_OK)
 8020e88:	4606      	mov	r6, r0
 8020e8a:	b920      	cbnz	r0, 8020e96 <com_sendto_ip_modem+0xe2>
              && (socket_desc->closing == false)
 8020e8c:	78bb      	ldrb	r3, [r7, #2]
 8020e8e:	b913      	cbnz	r3, 8020e96 <com_sendto_ip_modem+0xe2>
              && (socket_desc->state == COM_SOCKET_CONNECTED))
 8020e90:	783b      	ldrb	r3, [r7, #0]
 8020e92:	2b03      	cmp	r3, #3
 8020e94:	d00a      	beq.n	8020eac <com_sendto_ip_modem+0xf8>
            if (socket_desc->closing == true)
 8020e96:	78bb      	ldrb	r3, [r7, #2]
 8020e98:	2b00      	cmp	r3, #0
 8020e9a:	f040 813b 	bne.w	8021114 <com_sendto_ip_modem+0x360>
          com_sockets_statistic_update((result >= 0) ? \
 8020e9e:	2e00      	cmp	r6, #0
 8020ea0:	f2c0 8163 	blt.w	802116a <com_sendto_ip_modem+0x3b6>
 8020ea4:	2004      	movs	r0, #4
 8020ea6:	f001 f891 	bl	8021fcc <com_sockets_statistic_update>
 8020eaa:	e7a3      	b.n	8020df4 <com_sendto_ip_modem+0x40>
            if (com_ip_modem_is_network_up() == false)
 8020eac:	f7ff f9aa 	bl	8020204 <com_ip_modem_is_network_up>
 8020eb0:	bb48      	cbnz	r0, 8020f06 <com_sendto_ip_modem+0x152>
              PRINT_ERR("sndto data NOK no network")
 8020eb2:	4e92      	ldr	r6, [pc, #584]	; (80210fc <com_sendto_ip_modem+0x348>)
 8020eb4:	4c8f      	ldr	r4, [pc, #572]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020eb6:	f106 0c20 	add.w	ip, r6, #32
 8020eba:	4635      	mov	r5, r6
 8020ebc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8020ebe:	6020      	str	r0, [r4, #0]
 8020ec0:	6061      	str	r1, [r4, #4]
 8020ec2:	60a2      	str	r2, [r4, #8]
 8020ec4:	60e3      	str	r3, [r4, #12]
 8020ec6:	462e      	mov	r6, r5
 8020ec8:	3410      	adds	r4, #16
 8020eca:	4565      	cmp	r5, ip
 8020ecc:	d1f5      	bne.n	8020eba <com_sendto_ip_modem+0x106>
 8020ece:	ce03      	ldmia	r6!, {r0, r1}
 8020ed0:	6020      	str	r0, [r4, #0]
 8020ed2:	6061      	str	r1, [r4, #4]
 8020ed4:	8833      	ldrh	r3, [r6, #0]
 8020ed6:	8123      	strh	r3, [r4, #8]
 8020ed8:	4c86      	ldr	r4, [pc, #536]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020eda:	4620      	mov	r0, r4
 8020edc:	f7fe fa25 	bl	801f32a <crs_strlen>
 8020ee0:	b283      	uxth	r3, r0
 8020ee2:	4622      	mov	r2, r4
 8020ee4:	2110      	movs	r1, #16
 8020ee6:	2003      	movs	r0, #3
 8020ee8:	f7fe fa62 	bl	801f3b0 <traceIF_itmPrint>
 8020eec:	4620      	mov	r0, r4
 8020eee:	f7fe fa1c 	bl	801f32a <crs_strlen>
 8020ef2:	b283      	uxth	r3, r0
 8020ef4:	4622      	mov	r2, r4
 8020ef6:	2110      	movs	r1, #16
 8020ef8:	2003      	movs	r0, #3
 8020efa:	f7fe fa7b 	bl	801f3f4 <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_NONETWORK;
 8020efe:	f06f 060a 	mvn.w	r6, #10
          com_sockets_statistic_update((result >= 0) ? \
 8020f02:	2005      	movs	r0, #5
 8020f04:	e7cf      	b.n	8020ea6 <com_sendto_ip_modem+0xf2>
              socket_desc->state = COM_SOCKET_SENDING;
 8020f06:	2304      	movs	r3, #4
 8020f08:	703b      	strb	r3, [r7, #0]
              com_ip_modem_wakeup_request();
 8020f0a:	f7ff f9b9 	bl	8020280 <com_ip_modem_wakeup_request>
              if (flags == COM_MSG_DONTWAIT)
 8020f0e:	2d01      	cmp	r5, #1
 8020f10:	d005      	beq.n	8020f1e <com_sendto_ip_modem+0x16a>
                is_network_up = com_ip_modem_is_network_up();
 8020f12:	f7ff f977 	bl	8020204 <com_ip_modem_is_network_up>
 8020f16:	4682      	mov	sl, r0
              length_send = 0U;
 8020f18:	f04f 0900 	mov.w	r9, #0
                while ((length_send != (uint32_t)len)
 8020f1c:	e08a      	b.n	8021034 <com_sendto_ip_modem+0x280>
                length_to_send = COM_MIN((uint32_t)len, COM_MODEM_MAX_TX_DATA_SIZE);
 8020f1e:	f240 26c6 	movw	r6, #710	; 0x2c6
 8020f22:	4546      	cmp	r6, r8
 8020f24:	bf28      	it	cs
 8020f26:	4646      	movcs	r6, r8
                if (osCDS_socket_sendto(socket_desc->id,
 8020f28:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
 8020f2c:	9301      	str	r3, [sp, #4]
 8020f2e:	f10d 031d 	add.w	r3, sp, #29
 8020f32:	9300      	str	r3, [sp, #0]
 8020f34:	f89d 301c 	ldrb.w	r3, [sp, #28]
 8020f38:	4632      	mov	r2, r6
 8020f3a:	4621      	mov	r1, r4
 8020f3c:	68b8      	ldr	r0, [r7, #8]
 8020f3e:	f7f9 fdc7 	bl	801aad0 <osCDS_socket_sendto>
 8020f42:	bb38      	cbnz	r0, 8020f94 <com_sendto_ip_modem+0x1e0>
                  PRINT_INFO("sndto data DONTWAIT ok")
 8020f44:	4d6e      	ldr	r5, [pc, #440]	; (8021100 <com_sendto_ip_modem+0x34c>)
 8020f46:	4c6b      	ldr	r4, [pc, #428]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020f48:	f105 0e20 	add.w	lr, r5, #32
 8020f4c:	46ac      	mov	ip, r5
 8020f4e:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020f52:	6020      	str	r0, [r4, #0]
 8020f54:	6061      	str	r1, [r4, #4]
 8020f56:	60a2      	str	r2, [r4, #8]
 8020f58:	60e3      	str	r3, [r4, #12]
 8020f5a:	4665      	mov	r5, ip
 8020f5c:	3410      	adds	r4, #16
 8020f5e:	45f4      	cmp	ip, lr
 8020f60:	d1f4      	bne.n	8020f4c <com_sendto_ip_modem+0x198>
 8020f62:	f89c 3000 	ldrb.w	r3, [ip]
 8020f66:	7023      	strb	r3, [r4, #0]
 8020f68:	4c62      	ldr	r4, [pc, #392]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020f6a:	4620      	mov	r0, r4
 8020f6c:	f7fe f9dd 	bl	801f32a <crs_strlen>
 8020f70:	b283      	uxth	r3, r0
 8020f72:	4622      	mov	r2, r4
 8020f74:	2101      	movs	r1, #1
 8020f76:	2003      	movs	r0, #3
 8020f78:	f7fe fa1a 	bl	801f3b0 <traceIF_itmPrint>
 8020f7c:	4620      	mov	r0, r4
 8020f7e:	f7fe f9d4 	bl	801f32a <crs_strlen>
 8020f82:	b283      	uxth	r3, r0
 8020f84:	4622      	mov	r2, r4
 8020f86:	2101      	movs	r1, #1
 8020f88:	2003      	movs	r0, #3
 8020f8a:	f7fe fa33 	bl	801f3f4 <traceIF_uartPrint>
                socket_desc->state = COM_SOCKET_CONNECTED;
 8020f8e:	2303      	movs	r3, #3
 8020f90:	703b      	strb	r3, [r7, #0]
 8020f92:	e784      	b.n	8020e9e <com_sendto_ip_modem+0xea>
                  PRINT_ERR("sndto data DONTWAIT NOK at low level")
 8020f94:	4d5b      	ldr	r5, [pc, #364]	; (8021104 <com_sendto_ip_modem+0x350>)
 8020f96:	4c57      	ldr	r4, [pc, #348]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020f98:	f105 0c30 	add.w	ip, r5, #48	; 0x30
 8020f9c:	462e      	mov	r6, r5
 8020f9e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8020fa0:	6020      	str	r0, [r4, #0]
 8020fa2:	6061      	str	r1, [r4, #4]
 8020fa4:	60a2      	str	r2, [r4, #8]
 8020fa6:	60e3      	str	r3, [r4, #12]
 8020fa8:	4635      	mov	r5, r6
 8020faa:	3410      	adds	r4, #16
 8020fac:	4566      	cmp	r6, ip
 8020fae:	d1f5      	bne.n	8020f9c <com_sendto_ip_modem+0x1e8>
 8020fb0:	6830      	ldr	r0, [r6, #0]
 8020fb2:	6020      	str	r0, [r4, #0]
 8020fb4:	7933      	ldrb	r3, [r6, #4]
 8020fb6:	7123      	strb	r3, [r4, #4]
 8020fb8:	4c4e      	ldr	r4, [pc, #312]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020fba:	4620      	mov	r0, r4
 8020fbc:	f7fe f9b5 	bl	801f32a <crs_strlen>
 8020fc0:	b283      	uxth	r3, r0
 8020fc2:	4622      	mov	r2, r4
 8020fc4:	2110      	movs	r1, #16
 8020fc6:	2003      	movs	r0, #3
 8020fc8:	f7fe f9f2 	bl	801f3b0 <traceIF_itmPrint>
 8020fcc:	4620      	mov	r0, r4
 8020fce:	f7fe f9ac 	bl	801f32a <crs_strlen>
 8020fd2:	b283      	uxth	r3, r0
 8020fd4:	4622      	mov	r2, r4
 8020fd6:	2110      	movs	r1, #16
 8020fd8:	2003      	movs	r0, #3
 8020fda:	f7fe fa0b 	bl	801f3f4 <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_GENERAL;
 8020fde:	f04f 36ff 	mov.w	r6, #4294967295
 8020fe2:	e7d4      	b.n	8020f8e <com_sendto_ip_modem+0x1da>
                    socket_desc->state = COM_SOCKET_CONNECTED;
 8020fe4:	2303      	movs	r3, #3
 8020fe6:	703b      	strb	r3, [r7, #0]
                    PRINT_ERR("sndto data NOK at low level")
 8020fe8:	4e47      	ldr	r6, [pc, #284]	; (8021108 <com_sendto_ip_modem+0x354>)
 8020fea:	4d42      	ldr	r5, [pc, #264]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8020fec:	f106 0e20 	add.w	lr, r6, #32
 8020ff0:	46b4      	mov	ip, r6
 8020ff2:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8020ff6:	6028      	str	r0, [r5, #0]
 8020ff8:	6069      	str	r1, [r5, #4]
 8020ffa:	60aa      	str	r2, [r5, #8]
 8020ffc:	60eb      	str	r3, [r5, #12]
 8020ffe:	4666      	mov	r6, ip
 8021000:	3510      	adds	r5, #16
 8021002:	45f4      	cmp	ip, lr
 8021004:	d1f4      	bne.n	8020ff0 <com_sendto_ip_modem+0x23c>
 8021006:	ce07      	ldmia	r6!, {r0, r1, r2}
 8021008:	6028      	str	r0, [r5, #0]
 802100a:	6069      	str	r1, [r5, #4]
 802100c:	60aa      	str	r2, [r5, #8]
 802100e:	4d39      	ldr	r5, [pc, #228]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8021010:	4628      	mov	r0, r5
 8021012:	f7fe f98a 	bl	801f32a <crs_strlen>
 8021016:	b283      	uxth	r3, r0
 8021018:	462a      	mov	r2, r5
 802101a:	2110      	movs	r1, #16
 802101c:	2003      	movs	r0, #3
 802101e:	f7fe f9c7 	bl	801f3b0 <traceIF_itmPrint>
 8021022:	4628      	mov	r0, r5
 8021024:	f7fe f981 	bl	801f32a <crs_strlen>
 8021028:	b283      	uxth	r3, r0
 802102a:	462a      	mov	r2, r5
 802102c:	2110      	movs	r1, #16
 802102e:	2003      	movs	r0, #3
 8021030:	f7fe f9e0 	bl	801f3f4 <traceIF_uartPrint>
                       && (socket_desc->state == COM_SOCKET_SENDING))
 8021034:	45c8      	cmp	r8, r9
 8021036:	d059      	beq.n	80210ec <com_sendto_ip_modem+0x338>
                       && (socket_desc->closing == false)
 8021038:	78bb      	ldrb	r3, [r7, #2]
 802103a:	2b00      	cmp	r3, #0
 802103c:	d156      	bne.n	80210ec <com_sendto_ip_modem+0x338>
                       && (is_network_up == true)
 802103e:	f1ba 0f00 	cmp.w	sl, #0
 8021042:	d053      	beq.n	80210ec <com_sendto_ip_modem+0x338>
                       && (socket_desc->state == COM_SOCKET_SENDING))
 8021044:	783b      	ldrb	r3, [r7, #0]
 8021046:	2b04      	cmp	r3, #4
 8021048:	d150      	bne.n	80210ec <com_sendto_ip_modem+0x338>
                  length_to_send = COM_MIN((((uint32_t)len) - length_send),
 802104a:	eba8 0509 	sub.w	r5, r8, r9
 802104e:	f240 23c6 	movw	r3, #710	; 0x2c6
 8021052:	429d      	cmp	r5, r3
 8021054:	bf28      	it	cs
 8021056:	461d      	movcs	r5, r3
                  com_ip_modem_wakeup_request();
 8021058:	f7ff f912 	bl	8020280 <com_ip_modem_wakeup_request>
                  if (osCDS_socket_sendto(socket_desc->id,
 802105c:	68b8      	ldr	r0, [r7, #8]
 802105e:	f8bd 3046 	ldrh.w	r3, [sp, #70]	; 0x46
 8021062:	9301      	str	r3, [sp, #4]
 8021064:	f10d 031d 	add.w	r3, sp, #29
 8021068:	9300      	str	r3, [sp, #0]
 802106a:	f89d 301c 	ldrb.w	r3, [sp, #28]
 802106e:	462a      	mov	r2, r5
 8021070:	eb04 0109 	add.w	r1, r4, r9
 8021074:	f7f9 fd2c 	bl	801aad0 <osCDS_socket_sendto>
 8021078:	2800      	cmp	r0, #0
 802107a:	d1b3      	bne.n	8020fe4 <com_sendto_ip_modem+0x230>
                    length_send += length_to_send;
 802107c:	44a9      	add	r9, r5
                    PRINT_INFO("send data = %s", buf)
 802107e:	4d1d      	ldr	r5, [pc, #116]	; (80210f4 <com_sendto_ip_modem+0x340>)
 8021080:	4622      	mov	r2, r4
 8021082:	4922      	ldr	r1, [pc, #136]	; (802110c <com_sendto_ip_modem+0x358>)
 8021084:	4628      	mov	r0, r5
 8021086:	f005 fbdf 	bl	8026848 <sprintf>
 802108a:	4628      	mov	r0, r5
 802108c:	f7fe f94d 	bl	801f32a <crs_strlen>
 8021090:	b283      	uxth	r3, r0
 8021092:	462a      	mov	r2, r5
 8021094:	2101      	movs	r1, #1
 8021096:	2003      	movs	r0, #3
 8021098:	f7fe f98a 	bl	801f3b0 <traceIF_itmPrint>
 802109c:	4628      	mov	r0, r5
 802109e:	f7fe f944 	bl	801f32a <crs_strlen>
 80210a2:	b283      	uxth	r3, r0
 80210a4:	462a      	mov	r2, r5
 80210a6:	2101      	movs	r1, #1
 80210a8:	2003      	movs	r0, #3
 80210aa:	f7fe f9a3 	bl	801f3f4 <traceIF_uartPrint>
                    PRINT_INFO("sndto data ok")
 80210ae:	4e18      	ldr	r6, [pc, #96]	; (8021110 <com_sendto_ip_modem+0x35c>)
 80210b0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80210b2:	6028      	str	r0, [r5, #0]
 80210b4:	6069      	str	r1, [r5, #4]
 80210b6:	60aa      	str	r2, [r5, #8]
 80210b8:	60eb      	str	r3, [r5, #12]
 80210ba:	ce03      	ldmia	r6!, {r0, r1}
 80210bc:	6128      	str	r0, [r5, #16]
 80210be:	6169      	str	r1, [r5, #20]
 80210c0:	4628      	mov	r0, r5
 80210c2:	f7fe f932 	bl	801f32a <crs_strlen>
 80210c6:	b283      	uxth	r3, r0
 80210c8:	462a      	mov	r2, r5
 80210ca:	2101      	movs	r1, #1
 80210cc:	2003      	movs	r0, #3
 80210ce:	f7fe f96f 	bl	801f3b0 <traceIF_itmPrint>
 80210d2:	4628      	mov	r0, r5
 80210d4:	f7fe f929 	bl	801f32a <crs_strlen>
 80210d8:	b283      	uxth	r3, r0
 80210da:	462a      	mov	r2, r5
 80210dc:	2101      	movs	r1, #1
 80210de:	2003      	movs	r0, #3
 80210e0:	f7fe f988 	bl	801f3f4 <traceIF_uartPrint>
                    is_network_up = com_ip_modem_is_network_up();
 80210e4:	f7ff f88e 	bl	8020204 <com_ip_modem_is_network_up>
 80210e8:	4682      	mov	sl, r0
 80210ea:	e7a3      	b.n	8021034 <com_sendto_ip_modem+0x280>
                socket_desc->state = COM_SOCKET_CONNECTED;
 80210ec:	2303      	movs	r3, #3
 80210ee:	703b      	strb	r3, [r7, #0]
                result = (int32_t)length_send;
 80210f0:	464e      	mov	r6, r9
              com_ip_modem_idlemode_request(false);
 80210f2:	e6d4      	b.n	8020e9e <com_sendto_ip_modem+0xea>
 80210f4:	200049dc 	.word	0x200049dc
 80210f8:	08036474 	.word	0x08036474
 80210fc:	0803648c 	.word	0x0803648c
 8021100:	080364b8 	.word	0x080364b8
 8021104:	080364dc 	.word	0x080364dc
 8021108:	08036548 	.word	0x08036548
 802110c:	08036514 	.word	0x08036514
 8021110:	08036530 	.word	0x08036530
              PRINT_ERR("sndto data NOK socket closing")
 8021114:	4d1e      	ldr	r5, [pc, #120]	; (8021190 <com_sendto_ip_modem+0x3dc>)
 8021116:	4c1f      	ldr	r4, [pc, #124]	; (8021194 <com_sendto_ip_modem+0x3e0>)
 8021118:	f105 0c20 	add.w	ip, r5, #32
 802111c:	462e      	mov	r6, r5
 802111e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8021120:	6020      	str	r0, [r4, #0]
 8021122:	6061      	str	r1, [r4, #4]
 8021124:	60a2      	str	r2, [r4, #8]
 8021126:	60e3      	str	r3, [r4, #12]
 8021128:	4635      	mov	r5, r6
 802112a:	3410      	adds	r4, #16
 802112c:	4566      	cmp	r6, ip
 802112e:	d1f5      	bne.n	802111c <com_sendto_ip_modem+0x368>
 8021130:	cd07      	ldmia	r5!, {r0, r1, r2}
 8021132:	6020      	str	r0, [r4, #0]
 8021134:	6061      	str	r1, [r4, #4]
 8021136:	60a2      	str	r2, [r4, #8]
 8021138:	882b      	ldrh	r3, [r5, #0]
 802113a:	81a3      	strh	r3, [r4, #12]
 802113c:	4c15      	ldr	r4, [pc, #84]	; (8021194 <com_sendto_ip_modem+0x3e0>)
 802113e:	4620      	mov	r0, r4
 8021140:	f7fe f8f3 	bl	801f32a <crs_strlen>
 8021144:	b283      	uxth	r3, r0
 8021146:	4622      	mov	r2, r4
 8021148:	2110      	movs	r1, #16
 802114a:	2003      	movs	r0, #3
 802114c:	f7fe f930 	bl	801f3b0 <traceIF_itmPrint>
 8021150:	4620      	mov	r0, r4
 8021152:	f7fe f8ea 	bl	801f32a <crs_strlen>
 8021156:	b283      	uxth	r3, r0
 8021158:	4622      	mov	r2, r4
 802115a:	2110      	movs	r1, #16
 802115c:	2003      	movs	r0, #3
 802115e:	f7fe f949 	bl	801f3f4 <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_CLOSING;
 8021162:	f06f 0605 	mvn.w	r6, #5
          com_sockets_statistic_update((result >= 0) ? \
 8021166:	2005      	movs	r0, #5
 8021168:	e69d      	b.n	8020ea6 <com_sendto_ip_modem+0xf2>
 802116a:	2005      	movs	r0, #5
 802116c:	e69b      	b.n	8020ea6 <com_sendto_ip_modem+0xf2>
  result = COM_SOCKETS_ERR_PARAMETER;
 802116e:	f06f 0602 	mvn.w	r6, #2
 8021172:	e63f      	b.n	8020df4 <com_sendto_ip_modem+0x40>
 8021174:	f06f 0602 	mvn.w	r6, #2
  }
  else
  {
    SOCKET_SET_ERROR(socket_desc, result);
 8021178:	b107      	cbz	r7, 802117c <com_sendto_ip_modem+0x3c8>
 802117a:	607e      	str	r6, [r7, #4]
  }

  return (result);
}
 802117c:	4630      	mov	r0, r6
 802117e:	b012      	add	sp, #72	; 0x48
 8021180:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  result = COM_SOCKETS_ERR_PARAMETER;
 8021184:	f06f 0602 	mvn.w	r6, #2
 8021188:	e7f6      	b.n	8021178 <com_sendto_ip_modem+0x3c4>
 802118a:	f06f 0602 	mvn.w	r6, #2
 802118e:	e7f3      	b.n	8021178 <com_sendto_ip_modem+0x3c4>
 8021190:	08036574 	.word	0x08036574
 8021194:	200049dc 	.word	0x200049dc

08021198 <com_send_ip_modem>:
{
 8021198:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802119c:	b082      	sub	sp, #8
 802119e:	4680      	mov	r8, r0
 80211a0:	460f      	mov	r7, r1
 80211a2:	4616      	mov	r6, r2
 80211a4:	461d      	mov	r5, r3
  socket_desc = com_ip_modem_find_socket(sock, false);
 80211a6:	2100      	movs	r1, #0
 80211a8:	f7ff f80c 	bl	80201c4 <com_ip_modem_find_socket>
  if ((socket_desc != NULL)
 80211ac:	4604      	mov	r4, r0
 80211ae:	2800      	cmp	r0, #0
 80211b0:	f000 8195 	beq.w	80214de <com_send_ip_modem+0x346>
      && (buf != NULL)
 80211b4:	2f00      	cmp	r7, #0
 80211b6:	f000 819a 	beq.w	80214ee <com_send_ip_modem+0x356>
      && (len > 0))
 80211ba:	2e00      	cmp	r6, #0
 80211bc:	f340 819a 	ble.w	80214f4 <com_send_ip_modem+0x35c>
    if (socket_desc->state == COM_SOCKET_CONNECTED)
 80211c0:	7803      	ldrb	r3, [r0, #0]
 80211c2:	2b03      	cmp	r3, #3
 80211c4:	f040 8147 	bne.w	8021456 <com_send_ip_modem+0x2be>
      if (socket_desc->closing == false)
 80211c8:	7883      	ldrb	r3, [r0, #2]
 80211ca:	2b00      	cmp	r3, #0
 80211cc:	f040 811b 	bne.w	8021406 <com_send_ip_modem+0x26e>
        if (com_ip_modem_is_network_up() == false)
 80211d0:	f7ff f818 	bl	8020204 <com_ip_modem_is_network_up>
 80211d4:	bb30      	cbnz	r0, 8021224 <com_send_ip_modem+0x8c>
          PRINT_ERR("snd data NOK no network")
 80211d6:	4fc9      	ldr	r7, [pc, #804]	; (80214fc <com_send_ip_modem+0x364>)
 80211d8:	4dc9      	ldr	r5, [pc, #804]	; (8021500 <com_send_ip_modem+0x368>)
 80211da:	f107 0c20 	add.w	ip, r7, #32
 80211de:	463e      	mov	r6, r7
 80211e0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80211e2:	6028      	str	r0, [r5, #0]
 80211e4:	6069      	str	r1, [r5, #4]
 80211e6:	60aa      	str	r2, [r5, #8]
 80211e8:	60eb      	str	r3, [r5, #12]
 80211ea:	4637      	mov	r7, r6
 80211ec:	3510      	adds	r5, #16
 80211ee:	4566      	cmp	r6, ip
 80211f0:	d1f5      	bne.n	80211de <com_send_ip_modem+0x46>
 80211f2:	cf03      	ldmia	r7!, {r0, r1}
 80211f4:	6028      	str	r0, [r5, #0]
 80211f6:	6069      	str	r1, [r5, #4]
 80211f8:	4dc1      	ldr	r5, [pc, #772]	; (8021500 <com_send_ip_modem+0x368>)
 80211fa:	4628      	mov	r0, r5
 80211fc:	f7fe f895 	bl	801f32a <crs_strlen>
 8021200:	b283      	uxth	r3, r0
 8021202:	462a      	mov	r2, r5
 8021204:	2110      	movs	r1, #16
 8021206:	2003      	movs	r0, #3
 8021208:	f7fe f8d2 	bl	801f3b0 <traceIF_itmPrint>
 802120c:	4628      	mov	r0, r5
 802120e:	f7fe f88c 	bl	801f32a <crs_strlen>
 8021212:	b283      	uxth	r3, r0
 8021214:	462a      	mov	r2, r5
 8021216:	2110      	movs	r1, #16
 8021218:	2003      	movs	r0, #3
 802121a:	f7fe f8eb 	bl	801f3f4 <traceIF_uartPrint>
          result = COM_SOCKETS_ERR_NONETWORK;
 802121e:	f06f 050a 	mvn.w	r5, #10
 8021222:	e14c      	b.n	80214be <com_send_ip_modem+0x326>
          com_ip_modem_wakeup_request();
 8021224:	f7ff f82c 	bl	8020280 <com_ip_modem_wakeup_request>
          if ((socket_desc->type == (uint8_t)COM_SOCK_DGRAM)
 8021228:	78e3      	ldrb	r3, [r4, #3]
 802122a:	2b02      	cmp	r3, #2
 802122c:	d008      	beq.n	8021240 <com_send_ip_modem+0xa8>
            socket_desc->state = COM_SOCKET_SENDING;
 802122e:	2304      	movs	r3, #4
 8021230:	7023      	strb	r3, [r4, #0]
            if (flags == COM_MSG_DONTWAIT)
 8021232:	2d01      	cmp	r5, #1
 8021234:	d00f      	beq.n	8021256 <com_send_ip_modem+0xbe>
              is_network_up = com_ip_modem_is_network_up();
 8021236:	f7fe ffe5 	bl	8020204 <com_ip_modem_is_network_up>
 802123a:	4680      	mov	r8, r0
            length_send = 0U;
 802123c:	2500      	movs	r5, #0
              while ((length_send != (uint32_t)len)
 802123e:	e097      	b.n	8021370 <com_send_ip_modem+0x1d8>
            result = com_sendto_ip_modem(sock, buf, len, flags, NULL, 0);
 8021240:	2300      	movs	r3, #0
 8021242:	9301      	str	r3, [sp, #4]
 8021244:	9300      	str	r3, [sp, #0]
 8021246:	462b      	mov	r3, r5
 8021248:	4632      	mov	r2, r6
 802124a:	4639      	mov	r1, r7
 802124c:	4640      	mov	r0, r8
 802124e:	f7ff fdb1 	bl	8020db4 <com_sendto_ip_modem>
 8021252:	4605      	mov	r5, r0
 8021254:	e133      	b.n	80214be <com_send_ip_modem+0x326>
              length_to_send = COM_MIN((uint32_t)len, COM_MODEM_MAX_TX_DATA_SIZE);
 8021256:	f240 25c6 	movw	r5, #710	; 0x2c6
 802125a:	42b5      	cmp	r5, r6
 802125c:	bf28      	it	cs
 802125e:	4635      	movcs	r5, r6
              if (osCDS_socket_send(socket_desc->id,
 8021260:	462a      	mov	r2, r5
 8021262:	4639      	mov	r1, r7
 8021264:	68a0      	ldr	r0, [r4, #8]
 8021266:	f7f9 fbf7 	bl	801aa58 <osCDS_socket_send>
 802126a:	bb08      	cbnz	r0, 80212b0 <com_send_ip_modem+0x118>
                PRINT_INFO("snd data DONTWAIT ok")
 802126c:	4ea4      	ldr	r6, [pc, #656]	; (8021500 <com_send_ip_modem+0x368>)
 802126e:	4fa5      	ldr	r7, [pc, #660]	; (8021504 <com_send_ip_modem+0x36c>)
 8021270:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021272:	6030      	str	r0, [r6, #0]
 8021274:	6071      	str	r1, [r6, #4]
 8021276:	60b2      	str	r2, [r6, #8]
 8021278:	60f3      	str	r3, [r6, #12]
 802127a:	cf07      	ldmia	r7!, {r0, r1, r2}
 802127c:	6130      	str	r0, [r6, #16]
 802127e:	6171      	str	r1, [r6, #20]
 8021280:	61b2      	str	r2, [r6, #24]
 8021282:	883a      	ldrh	r2, [r7, #0]
 8021284:	78bb      	ldrb	r3, [r7, #2]
 8021286:	83b2      	strh	r2, [r6, #28]
 8021288:	77b3      	strb	r3, [r6, #30]
 802128a:	4630      	mov	r0, r6
 802128c:	f7fe f84d 	bl	801f32a <crs_strlen>
 8021290:	b283      	uxth	r3, r0
 8021292:	4632      	mov	r2, r6
 8021294:	2101      	movs	r1, #1
 8021296:	2003      	movs	r0, #3
 8021298:	f7fe f88a 	bl	801f3b0 <traceIF_itmPrint>
 802129c:	4630      	mov	r0, r6
 802129e:	f7fe f844 	bl	801f32a <crs_strlen>
 80212a2:	b283      	uxth	r3, r0
 80212a4:	4632      	mov	r2, r6
 80212a6:	2101      	movs	r1, #1
 80212a8:	2003      	movs	r0, #3
 80212aa:	f7fe f8a3 	bl	801f3f4 <traceIF_uartPrint>
 80212ae:	e026      	b.n	80212fe <com_send_ip_modem+0x166>
                PRINT_ERR("snd data DONTWAIT NOK at low level")
 80212b0:	4f95      	ldr	r7, [pc, #596]	; (8021508 <com_send_ip_modem+0x370>)
 80212b2:	4d93      	ldr	r5, [pc, #588]	; (8021500 <com_send_ip_modem+0x368>)
 80212b4:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 80212b8:	463e      	mov	r6, r7
 80212ba:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80212bc:	6028      	str	r0, [r5, #0]
 80212be:	6069      	str	r1, [r5, #4]
 80212c0:	60aa      	str	r2, [r5, #8]
 80212c2:	60eb      	str	r3, [r5, #12]
 80212c4:	4637      	mov	r7, r6
 80212c6:	3510      	adds	r5, #16
 80212c8:	4566      	cmp	r6, ip
 80212ca:	d1f5      	bne.n	80212b8 <com_send_ip_modem+0x120>
 80212cc:	8832      	ldrh	r2, [r6, #0]
 80212ce:	78b3      	ldrb	r3, [r6, #2]
 80212d0:	802a      	strh	r2, [r5, #0]
 80212d2:	70ab      	strb	r3, [r5, #2]
 80212d4:	4d8a      	ldr	r5, [pc, #552]	; (8021500 <com_send_ip_modem+0x368>)
 80212d6:	4628      	mov	r0, r5
 80212d8:	f7fe f827 	bl	801f32a <crs_strlen>
 80212dc:	b283      	uxth	r3, r0
 80212de:	462a      	mov	r2, r5
 80212e0:	2110      	movs	r1, #16
 80212e2:	2003      	movs	r0, #3
 80212e4:	f7fe f864 	bl	801f3b0 <traceIF_itmPrint>
 80212e8:	4628      	mov	r0, r5
 80212ea:	f7fe f81e 	bl	801f32a <crs_strlen>
 80212ee:	b283      	uxth	r3, r0
 80212f0:	462a      	mov	r2, r5
 80212f2:	2110      	movs	r1, #16
 80212f4:	2003      	movs	r0, #3
 80212f6:	f7fe f87d 	bl	801f3f4 <traceIF_uartPrint>
            result = COM_SOCKETS_ERR_GENERAL;
 80212fa:	f04f 35ff 	mov.w	r5, #4294967295
              socket_desc->state = COM_SOCKET_CONNECTED;
 80212fe:	2303      	movs	r3, #3
 8021300:	7023      	strb	r3, [r4, #0]
 8021302:	e0dc      	b.n	80214be <com_send_ip_modem+0x326>
                  socket_desc->state = COM_SOCKET_CONNECTED;
 8021304:	2303      	movs	r3, #3
 8021306:	7023      	strb	r3, [r4, #0]
                  PRINT_ERR("snd data NOK at low level")
 8021308:	f8df c208 	ldr.w	ip, [pc, #520]	; 8021514 <com_send_ip_modem+0x37c>
 802130c:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8021500 <com_send_ip_modem+0x368>
 8021310:	f10c 0a20 	add.w	sl, ip, #32
 8021314:	46e6      	mov	lr, ip
 8021316:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 802131a:	f8c9 0000 	str.w	r0, [r9]
 802131e:	f8c9 1004 	str.w	r1, [r9, #4]
 8021322:	f8c9 2008 	str.w	r2, [r9, #8]
 8021326:	f8c9 300c 	str.w	r3, [r9, #12]
 802132a:	46f4      	mov	ip, lr
 802132c:	f109 0910 	add.w	r9, r9, #16
 8021330:	45d6      	cmp	lr, sl
 8021332:	d1ef      	bne.n	8021314 <com_send_ip_modem+0x17c>
 8021334:	e8bc 0003 	ldmia.w	ip!, {r0, r1}
 8021338:	f8c9 0000 	str.w	r0, [r9]
 802133c:	f8c9 1004 	str.w	r1, [r9, #4]
 8021340:	f8bc 3000 	ldrh.w	r3, [ip]
 8021344:	f8a9 3008 	strh.w	r3, [r9, #8]
 8021348:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8021500 <com_send_ip_modem+0x368>
 802134c:	4648      	mov	r0, r9
 802134e:	f7fd ffec 	bl	801f32a <crs_strlen>
 8021352:	b283      	uxth	r3, r0
 8021354:	464a      	mov	r2, r9
 8021356:	2110      	movs	r1, #16
 8021358:	2003      	movs	r0, #3
 802135a:	f7fe f829 	bl	801f3b0 <traceIF_itmPrint>
 802135e:	4648      	mov	r0, r9
 8021360:	f7fd ffe3 	bl	801f32a <crs_strlen>
 8021364:	b283      	uxth	r3, r0
 8021366:	464a      	mov	r2, r9
 8021368:	2110      	movs	r1, #16
 802136a:	2003      	movs	r0, #3
 802136c:	f7fe f842 	bl	801f3f4 <traceIF_uartPrint>
                     && (socket_desc->state == COM_SOCKET_SENDING))
 8021370:	42ae      	cmp	r6, r5
 8021372:	d045      	beq.n	8021400 <com_send_ip_modem+0x268>
                     && (socket_desc->closing == false)
 8021374:	78a3      	ldrb	r3, [r4, #2]
 8021376:	2b00      	cmp	r3, #0
 8021378:	d142      	bne.n	8021400 <com_send_ip_modem+0x268>
                     && (is_network_up == true)
 802137a:	f1b8 0f00 	cmp.w	r8, #0
 802137e:	d03f      	beq.n	8021400 <com_send_ip_modem+0x268>
                     && (socket_desc->state == COM_SOCKET_SENDING))
 8021380:	7823      	ldrb	r3, [r4, #0]
 8021382:	2b04      	cmp	r3, #4
 8021384:	d13c      	bne.n	8021400 <com_send_ip_modem+0x268>
                length_to_send = COM_MIN((((uint32_t)len) - length_send),
 8021386:	eba6 0905 	sub.w	r9, r6, r5
 802138a:	f240 23c6 	movw	r3, #710	; 0x2c6
 802138e:	4599      	cmp	r9, r3
 8021390:	bf28      	it	cs
 8021392:	4699      	movcs	r9, r3
                com_ip_modem_wakeup_request();
 8021394:	f7fe ff74 	bl	8020280 <com_ip_modem_wakeup_request>
                if (osCDS_socket_send(socket_desc->id,
 8021398:	464a      	mov	r2, r9
 802139a:	1979      	adds	r1, r7, r5
 802139c:	68a0      	ldr	r0, [r4, #8]
 802139e:	f7f9 fb5b 	bl	801aa58 <osCDS_socket_send>
 80213a2:	2800      	cmp	r0, #0
 80213a4:	d1ae      	bne.n	8021304 <com_send_ip_modem+0x16c>
                  length_send += length_to_send;
 80213a6:	444d      	add	r5, r9
                  PRINT_INFO("snd data ok")
 80213a8:	f8df 8154 	ldr.w	r8, [pc, #340]	; 8021500 <com_send_ip_modem+0x368>
 80213ac:	f8df c168 	ldr.w	ip, [pc, #360]	; 8021518 <com_send_ip_modem+0x380>
 80213b0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80213b4:	f8c8 0000 	str.w	r0, [r8]
 80213b8:	f8c8 1004 	str.w	r1, [r8, #4]
 80213bc:	f8c8 2008 	str.w	r2, [r8, #8]
 80213c0:	f8c8 300c 	str.w	r3, [r8, #12]
 80213c4:	f8dc 0000 	ldr.w	r0, [ip]
 80213c8:	f8c8 0010 	str.w	r0, [r8, #16]
 80213cc:	f8bc 3004 	ldrh.w	r3, [ip, #4]
 80213d0:	f8a8 3014 	strh.w	r3, [r8, #20]
 80213d4:	4640      	mov	r0, r8
 80213d6:	f7fd ffa8 	bl	801f32a <crs_strlen>
 80213da:	b283      	uxth	r3, r0
 80213dc:	4642      	mov	r2, r8
 80213de:	2101      	movs	r1, #1
 80213e0:	2003      	movs	r0, #3
 80213e2:	f7fd ffe5 	bl	801f3b0 <traceIF_itmPrint>
 80213e6:	4640      	mov	r0, r8
 80213e8:	f7fd ff9f 	bl	801f32a <crs_strlen>
 80213ec:	b283      	uxth	r3, r0
 80213ee:	4642      	mov	r2, r8
 80213f0:	2101      	movs	r1, #1
 80213f2:	2003      	movs	r0, #3
 80213f4:	f7fd fffe 	bl	801f3f4 <traceIF_uartPrint>
                  is_network_up = com_ip_modem_is_network_up();
 80213f8:	f7fe ff04 	bl	8020204 <com_ip_modem_is_network_up>
 80213fc:	4680      	mov	r8, r0
 80213fe:	e7b7      	b.n	8021370 <com_send_ip_modem+0x1d8>
              socket_desc->state = COM_SOCKET_CONNECTED;
 8021400:	2303      	movs	r3, #3
 8021402:	7023      	strb	r3, [r4, #0]
          com_ip_modem_idlemode_request(false);
 8021404:	e05b      	b.n	80214be <com_send_ip_modem+0x326>
        PRINT_ERR("snd data NOK socket closing")
 8021406:	4e41      	ldr	r6, [pc, #260]	; (802150c <com_send_ip_modem+0x374>)
 8021408:	4d3d      	ldr	r5, [pc, #244]	; (8021500 <com_send_ip_modem+0x368>)
 802140a:	f106 0c20 	add.w	ip, r6, #32
 802140e:	4637      	mov	r7, r6
 8021410:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021412:	6028      	str	r0, [r5, #0]
 8021414:	6069      	str	r1, [r5, #4]
 8021416:	60aa      	str	r2, [r5, #8]
 8021418:	60eb      	str	r3, [r5, #12]
 802141a:	463e      	mov	r6, r7
 802141c:	3510      	adds	r5, #16
 802141e:	4567      	cmp	r7, ip
 8021420:	d1f5      	bne.n	802140e <com_send_ip_modem+0x276>
 8021422:	ce07      	ldmia	r6!, {r0, r1, r2}
 8021424:	6028      	str	r0, [r5, #0]
 8021426:	6069      	str	r1, [r5, #4]
 8021428:	60aa      	str	r2, [r5, #8]
 802142a:	4d35      	ldr	r5, [pc, #212]	; (8021500 <com_send_ip_modem+0x368>)
 802142c:	4628      	mov	r0, r5
 802142e:	f7fd ff7c 	bl	801f32a <crs_strlen>
 8021432:	b283      	uxth	r3, r0
 8021434:	462a      	mov	r2, r5
 8021436:	2110      	movs	r1, #16
 8021438:	2003      	movs	r0, #3
 802143a:	f7fd ffb9 	bl	801f3b0 <traceIF_itmPrint>
 802143e:	4628      	mov	r0, r5
 8021440:	f7fd ff73 	bl	801f32a <crs_strlen>
 8021444:	b283      	uxth	r3, r0
 8021446:	462a      	mov	r2, r5
 8021448:	2110      	movs	r1, #16
 802144a:	2003      	movs	r0, #3
 802144c:	f7fd ffd2 	bl	801f3f4 <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_CLOSING;
 8021450:	f06f 0505 	mvn.w	r5, #5
 8021454:	e033      	b.n	80214be <com_send_ip_modem+0x326>
      PRINT_ERR("snd data NOK err state")
 8021456:	4f2e      	ldr	r7, [pc, #184]	; (8021510 <com_send_ip_modem+0x378>)
 8021458:	4d29      	ldr	r5, [pc, #164]	; (8021500 <com_send_ip_modem+0x368>)
 802145a:	f107 0c20 	add.w	ip, r7, #32
 802145e:	463e      	mov	r6, r7
 8021460:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8021462:	6028      	str	r0, [r5, #0]
 8021464:	6069      	str	r1, [r5, #4]
 8021466:	60aa      	str	r2, [r5, #8]
 8021468:	60eb      	str	r3, [r5, #12]
 802146a:	4637      	mov	r7, r6
 802146c:	3510      	adds	r5, #16
 802146e:	4566      	cmp	r6, ip
 8021470:	d1f5      	bne.n	802145e <com_send_ip_modem+0x2c6>
 8021472:	6830      	ldr	r0, [r6, #0]
 8021474:	6028      	str	r0, [r5, #0]
 8021476:	88b2      	ldrh	r2, [r6, #4]
 8021478:	79b3      	ldrb	r3, [r6, #6]
 802147a:	80aa      	strh	r2, [r5, #4]
 802147c:	71ab      	strb	r3, [r5, #6]
 802147e:	4d20      	ldr	r5, [pc, #128]	; (8021500 <com_send_ip_modem+0x368>)
 8021480:	4628      	mov	r0, r5
 8021482:	f7fd ff52 	bl	801f32a <crs_strlen>
 8021486:	b283      	uxth	r3, r0
 8021488:	462a      	mov	r2, r5
 802148a:	2110      	movs	r1, #16
 802148c:	2003      	movs	r0, #3
 802148e:	f7fd ff8f 	bl	801f3b0 <traceIF_itmPrint>
 8021492:	4628      	mov	r0, r5
 8021494:	f7fd ff49 	bl	801f32a <crs_strlen>
 8021498:	b283      	uxth	r3, r0
 802149a:	462a      	mov	r2, r5
 802149c:	2110      	movs	r1, #16
 802149e:	2003      	movs	r0, #3
 80214a0:	f7fd ffa8 	bl	801f3f4 <traceIF_uartPrint>
      if (socket_desc->state < COM_SOCKET_CONNECTED)
 80214a4:	7823      	ldrb	r3, [r4, #0]
 80214a6:	2b02      	cmp	r3, #2
 80214a8:	d907      	bls.n	80214ba <com_send_ip_modem+0x322>
                 COM_SOCKETS_ERR_CLOSING : COM_SOCKETS_ERR_INPROGRESS;
 80214aa:	2b07      	cmp	r3, #7
 80214ac:	d002      	beq.n	80214b4 <com_send_ip_modem+0x31c>
 80214ae:	f06f 0508 	mvn.w	r5, #8
 80214b2:	e004      	b.n	80214be <com_send_ip_modem+0x326>
 80214b4:	f06f 0505 	mvn.w	r5, #5
 80214b8:	e001      	b.n	80214be <com_send_ip_modem+0x326>
        result = COM_SOCKETS_ERR_STATE;
 80214ba:	f06f 050c 	mvn.w	r5, #12
    if ((socket_desc->type == (uint8_t)COM_SOCK_STREAM)
 80214be:	78e3      	ldrb	r3, [r4, #3]
 80214c0:	2b01      	cmp	r3, #1
 80214c2:	d004      	beq.n	80214ce <com_send_ip_modem+0x336>
  if (result >= 0)
 80214c4:	2d00      	cmp	r5, #0
 80214c6:	db0c      	blt.n	80214e2 <com_send_ip_modem+0x34a>
    SOCKET_SET_ERROR(socket_desc, COM_SOCKETS_ERR_OK);
 80214c8:	2300      	movs	r3, #0
 80214ca:	6063      	str	r3, [r4, #4]
 80214cc:	e00b      	b.n	80214e6 <com_send_ip_modem+0x34e>
      com_sockets_statistic_update((result >= 0) ? \
 80214ce:	2d00      	cmp	r5, #0
 80214d0:	db03      	blt.n	80214da <com_send_ip_modem+0x342>
 80214d2:	2004      	movs	r0, #4
 80214d4:	f000 fd7a 	bl	8021fcc <com_sockets_statistic_update>
 80214d8:	e7f4      	b.n	80214c4 <com_send_ip_modem+0x32c>
 80214da:	2005      	movs	r0, #5
 80214dc:	e7fa      	b.n	80214d4 <com_send_ip_modem+0x33c>
  result = COM_SOCKETS_ERR_PARAMETER;
 80214de:	f06f 0502 	mvn.w	r5, #2
    SOCKET_SET_ERROR(socket_desc, result);
 80214e2:	b104      	cbz	r4, 80214e6 <com_send_ip_modem+0x34e>
 80214e4:	6065      	str	r5, [r4, #4]
}
 80214e6:	4628      	mov	r0, r5
 80214e8:	b002      	add	sp, #8
 80214ea:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  result = COM_SOCKETS_ERR_PARAMETER;
 80214ee:	f06f 0502 	mvn.w	r5, #2
 80214f2:	e7f6      	b.n	80214e2 <com_send_ip_modem+0x34a>
 80214f4:	f06f 0502 	mvn.w	r5, #2
 80214f8:	e7f3      	b.n	80214e2 <com_send_ip_modem+0x34a>
 80214fa:	bf00      	nop
 80214fc:	080365a4 	.word	0x080365a4
 8021500:	200049dc 	.word	0x200049dc
 8021504:	080365cc 	.word	0x080365cc
 8021508:	080365ec 	.word	0x080365ec
 802150c:	08036664 	.word	0x08036664
 8021510:	08036690 	.word	0x08036690
 8021514:	08036638 	.word	0x08036638
 8021518:	08036620 	.word	0x08036620

0802151c <com_recv_ip_modem>:
  * @retval int32_t   - number of bytes received or error value
  */
int32_t com_recv_ip_modem(int32_t sock,
                          com_char_t *buf, int32_t len,
                          int32_t flags)
{
 802151c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021520:	b082      	sub	sp, #8
 8021522:	460f      	mov	r7, r1
 8021524:	4614      	mov	r4, r2
 8021526:	461e      	mov	r6, r3
  rtosalStatus status_queue;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;
  len_rcv = 0;
  socket_desc = com_ip_modem_find_socket(sock, false);
 8021528:	2100      	movs	r1, #0
 802152a:	f7fe fe4b 	bl	80201c4 <com_ip_modem_find_socket>

  if ((socket_desc != NULL)
 802152e:	4605      	mov	r5, r0
 8021530:	2800      	cmp	r0, #0
 8021532:	f000 8244 	beq.w	80219be <com_recv_ip_modem+0x4a2>
      && (buf != NULL)
 8021536:	2f00      	cmp	r7, #0
 8021538:	f000 824c 	beq.w	80219d4 <com_recv_ip_modem+0x4b8>
      && (len > 0))
 802153c:	2c00      	cmp	r4, #0
 802153e:	f340 824d 	ble.w	80219dc <com_recv_ip_modem+0x4c0>
  {
    /* Closing maybe received or Network maybe done
       but still some data to read */
    if (socket_desc->state == COM_SOCKET_CONNECTED)
 8021542:	7803      	ldrb	r3, [r0, #0]
 8021544:	2b03      	cmp	r3, #3
 8021546:	d035      	beq.n	80215b4 <com_recv_ip_modem+0x98>

      com_ip_modem_idlemode_request(false);
    }
    else
    {
      PRINT_ERR("rcv data NOK err state")
 8021548:	4ec6      	ldr	r6, [pc, #792]	; (8021864 <com_recv_ip_modem+0x348>)
 802154a:	4cc7      	ldr	r4, [pc, #796]	; (8021868 <com_recv_ip_modem+0x34c>)
 802154c:	f106 0720 	add.w	r7, r6, #32
 8021550:	46b4      	mov	ip, r6
 8021552:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021556:	6020      	str	r0, [r4, #0]
 8021558:	6061      	str	r1, [r4, #4]
 802155a:	60a2      	str	r2, [r4, #8]
 802155c:	60e3      	str	r3, [r4, #12]
 802155e:	4666      	mov	r6, ip
 8021560:	3410      	adds	r4, #16
 8021562:	45bc      	cmp	ip, r7
 8021564:	d1f4      	bne.n	8021550 <com_recv_ip_modem+0x34>
 8021566:	f8dc 0000 	ldr.w	r0, [ip]
 802156a:	6020      	str	r0, [r4, #0]
 802156c:	f8bc 2004 	ldrh.w	r2, [ip, #4]
 8021570:	f89c 3006 	ldrb.w	r3, [ip, #6]
 8021574:	80a2      	strh	r2, [r4, #4]
 8021576:	71a3      	strb	r3, [r4, #6]
 8021578:	4cbb      	ldr	r4, [pc, #748]	; (8021868 <com_recv_ip_modem+0x34c>)
 802157a:	4620      	mov	r0, r4
 802157c:	f7fd fed5 	bl	801f32a <crs_strlen>
 8021580:	b283      	uxth	r3, r0
 8021582:	4622      	mov	r2, r4
 8021584:	2110      	movs	r1, #16
 8021586:	2003      	movs	r0, #3
 8021588:	f7fd ff12 	bl	801f3b0 <traceIF_itmPrint>
 802158c:	4620      	mov	r0, r4
 802158e:	f7fd fecc 	bl	801f32a <crs_strlen>
 8021592:	b283      	uxth	r3, r0
 8021594:	4622      	mov	r2, r4
 8021596:	2110      	movs	r1, #16
 8021598:	2003      	movs	r0, #3
 802159a:	f7fd ff2b 	bl	801f3f4 <traceIF_uartPrint>
      if (socket_desc->state < COM_SOCKET_CONNECTED)
 802159e:	782b      	ldrb	r3, [r5, #0]
 80215a0:	2b02      	cmp	r3, #2
 80215a2:	f240 8205 	bls.w	80219b0 <com_recv_ip_modem+0x494>
        result = COM_SOCKETS_ERR_STATE;
      }
      else
      {
        result = (socket_desc->state == COM_SOCKET_CLOSING) ? \
                 COM_SOCKETS_ERR_CLOSING : COM_SOCKETS_ERR_INPROGRESS;
 80215a6:	2b07      	cmp	r3, #7
 80215a8:	f000 81fe 	beq.w	80219a8 <com_recv_ip_modem+0x48c>
  len_rcv = 0;
 80215ac:	2600      	movs	r6, #0
                 COM_SOCKETS_ERR_CLOSING : COM_SOCKETS_ERR_INPROGRESS;
 80215ae:	f06f 0408 	mvn.w	r4, #8
 80215b2:	e097      	b.n	80216e4 <com_recv_ip_modem+0x1c8>
      length_to_read = COM_MIN((uint32_t)len, COM_MODEM_MAX_RX_DATA_SIZE);
 80215b4:	f240 23ee 	movw	r3, #750	; 0x2ee
 80215b8:	429c      	cmp	r4, r3
 80215ba:	bf28      	it	cs
 80215bc:	461c      	movcs	r4, r3
      socket_desc->state = COM_SOCKET_WAITING_RSP;
 80215be:	2305      	movs	r3, #5
 80215c0:	7003      	strb	r3, [r0, #0]
      com_ip_modem_wakeup_request();
 80215c2:	f7fe fe5d 	bl	8020280 <com_ip_modem_wakeup_request>
      com_ip_modem_empty_queue(socket_desc->queue);
 80215c6:	69e8      	ldr	r0, [r5, #28]
 80215c8:	f7ff fa58 	bl	8020a7c <com_ip_modem_empty_queue>
      if (flags == COM_MSG_DONTWAIT)
 80215cc:	2e01      	cmp	r6, #1
 80215ce:	f000 8090 	beq.w	80216f2 <com_recv_ip_modem+0x1d6>
        PRINT_DBG("rcv data waiting")
 80215d2:	f8df 8294 	ldr.w	r8, [pc, #660]	; 8021868 <com_recv_ip_modem+0x34c>
 80215d6:	4ea5      	ldr	r6, [pc, #660]	; (802186c <com_recv_ip_modem+0x350>)
 80215d8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80215da:	f8c8 0000 	str.w	r0, [r8]
 80215de:	f8c8 1004 	str.w	r1, [r8, #4]
 80215e2:	f8c8 2008 	str.w	r2, [r8, #8]
 80215e6:	f8c8 300c 	str.w	r3, [r8, #12]
 80215ea:	ce03      	ldmia	r6!, {r0, r1}
 80215ec:	f8c8 0010 	str.w	r0, [r8, #16]
 80215f0:	f8c8 1014 	str.w	r1, [r8, #20]
 80215f4:	8832      	ldrh	r2, [r6, #0]
 80215f6:	78b3      	ldrb	r3, [r6, #2]
 80215f8:	f8a8 2018 	strh.w	r2, [r8, #24]
 80215fc:	f888 301a 	strb.w	r3, [r8, #26]
 8021600:	4640      	mov	r0, r8
 8021602:	f7fd fe92 	bl	801f32a <crs_strlen>
 8021606:	b283      	uxth	r3, r0
 8021608:	4642      	mov	r2, r8
 802160a:	2102      	movs	r1, #2
 802160c:	2003      	movs	r0, #3
 802160e:	f7fd fecf 	bl	801f3b0 <traceIF_itmPrint>
 8021612:	4640      	mov	r0, r8
 8021614:	f7fd fe89 	bl	801f32a <crs_strlen>
 8021618:	b283      	uxth	r3, r0
 802161a:	4642      	mov	r2, r8
 802161c:	2102      	movs	r1, #2
 802161e:	2003      	movs	r0, #3
 8021620:	f7fd fee8 	bl	801f3f4 <traceIF_uartPrint>
        len_rcv = osCDS_socket_receive(socket_desc->id,
 8021624:	4622      	mov	r2, r4
 8021626:	4639      	mov	r1, r7
 8021628:	68a8      	ldr	r0, [r5, #8]
 802162a:	f7f9 fa33 	bl	801aa94 <osCDS_socket_receive>
 802162e:	4606      	mov	r6, r0
        PRINT_DBG("rcv data waiting exit")
 8021630:	f8df c240 	ldr.w	ip, [pc, #576]	; 8021874 <com_recv_ip_modem+0x358>
 8021634:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021638:	f8c8 0000 	str.w	r0, [r8]
 802163c:	f8c8 1004 	str.w	r1, [r8, #4]
 8021640:	f8c8 2008 	str.w	r2, [r8, #8]
 8021644:	f8c8 300c 	str.w	r3, [r8, #12]
 8021648:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 802164c:	f8c8 0010 	str.w	r0, [r8, #16]
 8021650:	f8c8 1014 	str.w	r1, [r8, #20]
 8021654:	f8c8 2018 	str.w	r2, [r8, #24]
 8021658:	f8c8 301c 	str.w	r3, [r8, #28]
 802165c:	4640      	mov	r0, r8
 802165e:	f7fd fe64 	bl	801f32a <crs_strlen>
 8021662:	b283      	uxth	r3, r0
 8021664:	4642      	mov	r2, r8
 8021666:	2102      	movs	r1, #2
 8021668:	2003      	movs	r0, #3
 802166a:	f7fd fea1 	bl	801f3b0 <traceIF_itmPrint>
 802166e:	4640      	mov	r0, r8
 8021670:	f7fd fe5b 	bl	801f32a <crs_strlen>
 8021674:	b283      	uxth	r3, r0
 8021676:	4642      	mov	r2, r8
 8021678:	2102      	movs	r1, #2
 802167a:	2003      	movs	r0, #3
 802167c:	f7fd feba 	bl	801f3f4 <traceIF_uartPrint>
        if (len_rcv == 0)
 8021680:	2e00      	cmp	r6, #0
 8021682:	d066      	beq.n	8021752 <com_recv_ip_modem+0x236>
          result = (len_rcv < 0) ? COM_SOCKETS_ERR_GENERAL : COM_SOCKETS_ERR_OK;
 8021684:	2e00      	cmp	r6, #0
 8021686:	f2c0 818c 	blt.w	80219a2 <com_recv_ip_modem+0x486>
 802168a:	2400      	movs	r4, #0
          socket_desc->state = COM_SOCKET_CONNECTED;
 802168c:	2303      	movs	r3, #3
 802168e:	702b      	strb	r3, [r5, #0]
          PRINT_INFO("rcv data exit data available or err low level")
 8021690:	f8df e1e4 	ldr.w	lr, [pc, #484]	; 8021878 <com_recv_ip_modem+0x35c>
 8021694:	4f74      	ldr	r7, [pc, #464]	; (8021868 <com_recv_ip_modem+0x34c>)
 8021696:	f10e 0830 	add.w	r8, lr, #48	; 0x30
 802169a:	46f4      	mov	ip, lr
 802169c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80216a0:	6038      	str	r0, [r7, #0]
 80216a2:	6079      	str	r1, [r7, #4]
 80216a4:	60ba      	str	r2, [r7, #8]
 80216a6:	60fb      	str	r3, [r7, #12]
 80216a8:	46e6      	mov	lr, ip
 80216aa:	3710      	adds	r7, #16
 80216ac:	45c4      	cmp	ip, r8
 80216ae:	d1f4      	bne.n	802169a <com_recv_ip_modem+0x17e>
 80216b0:	e8be 0003 	ldmia.w	lr!, {r0, r1}
 80216b4:	6038      	str	r0, [r7, #0]
 80216b6:	6079      	str	r1, [r7, #4]
 80216b8:	4f6b      	ldr	r7, [pc, #428]	; (8021868 <com_recv_ip_modem+0x34c>)
 80216ba:	4638      	mov	r0, r7
 80216bc:	f7fd fe35 	bl	801f32a <crs_strlen>
 80216c0:	b283      	uxth	r3, r0
 80216c2:	463a      	mov	r2, r7
 80216c4:	2101      	movs	r1, #1
 80216c6:	2003      	movs	r0, #3
 80216c8:	f7fd fe72 	bl	801f3b0 <traceIF_itmPrint>
 80216cc:	4638      	mov	r0, r7
 80216ce:	f7fd fe2c 	bl	801f32a <crs_strlen>
 80216d2:	b283      	uxth	r3, r0
 80216d4:	463a      	mov	r2, r7
 80216d6:	2101      	movs	r1, #1
 80216d8:	2003      	movs	r0, #3
 80216da:	f7fd fe8b 	bl	801f3f4 <traceIF_uartPrint>
      com_ip_modem_empty_queue(socket_desc->queue);
 80216de:	69e8      	ldr	r0, [r5, #28]
 80216e0:	f7ff f9cc 	bl	8020a7c <com_ip_modem_empty_queue>
      }
    }

    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 80216e4:	2c00      	cmp	r4, #0
 80216e6:	f040 8168 	bne.w	80219ba <com_recv_ip_modem+0x49e>
 80216ea:	2006      	movs	r0, #6
 80216ec:	f000 fc6e 	bl	8021fcc <com_sockets_statistic_update>
 80216f0:	e168      	b.n	80219c4 <com_recv_ip_modem+0x4a8>
        len_rcv = osCDS_socket_receive(socket_desc->id,
 80216f2:	4622      	mov	r2, r4
 80216f4:	4639      	mov	r1, r7
 80216f6:	68a8      	ldr	r0, [r5, #8]
 80216f8:	f7f9 f9cc 	bl	801aa94 <osCDS_socket_receive>
        result = (len_rcv < 0) ? COM_SOCKETS_ERR_GENERAL : COM_SOCKETS_ERR_OK;
 80216fc:	1e06      	subs	r6, r0, #0
 80216fe:	db25      	blt.n	802174c <com_recv_ip_modem+0x230>
 8021700:	2400      	movs	r4, #0
        socket_desc->state = COM_SOCKET_CONNECTED;
 8021702:	f04f 0803 	mov.w	r8, #3
 8021706:	f885 8000 	strb.w	r8, [r5]
        PRINT_INFO("rcv data DONTWAIT")
 802170a:	4f57      	ldr	r7, [pc, #348]	; (8021868 <com_recv_ip_modem+0x34c>)
 802170c:	f8df c16c 	ldr.w	ip, [pc, #364]	; 802187c <com_recv_ip_modem+0x360>
 8021710:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021714:	6038      	str	r0, [r7, #0]
 8021716:	6079      	str	r1, [r7, #4]
 8021718:	60ba      	str	r2, [r7, #8]
 802171a:	60fb      	str	r3, [r7, #12]
 802171c:	e8bc 0007 	ldmia.w	ip!, {r0, r1, r2}
 8021720:	6138      	str	r0, [r7, #16]
 8021722:	6179      	str	r1, [r7, #20]
 8021724:	61ba      	str	r2, [r7, #24]
 8021726:	4638      	mov	r0, r7
 8021728:	f7fd fdff 	bl	801f32a <crs_strlen>
 802172c:	b283      	uxth	r3, r0
 802172e:	463a      	mov	r2, r7
 8021730:	2101      	movs	r1, #1
 8021732:	4640      	mov	r0, r8
 8021734:	f7fd fe3c 	bl	801f3b0 <traceIF_itmPrint>
 8021738:	4638      	mov	r0, r7
 802173a:	f7fd fdf6 	bl	801f32a <crs_strlen>
 802173e:	b283      	uxth	r3, r0
 8021740:	463a      	mov	r2, r7
 8021742:	2101      	movs	r1, #1
 8021744:	4640      	mov	r0, r8
 8021746:	f7fd fe55 	bl	801f3f4 <traceIF_uartPrint>
 802174a:	e7c8      	b.n	80216de <com_recv_ip_modem+0x1c2>
        result = (len_rcv < 0) ? COM_SOCKETS_ERR_GENERAL : COM_SOCKETS_ERR_OK;
 802174c:	f04f 34ff 	mov.w	r4, #4294967295
 8021750:	e7d7      	b.n	8021702 <com_recv_ip_modem+0x1e6>
          msg_queue = 0U;
 8021752:	2300      	movs	r3, #0
 8021754:	9301      	str	r3, [sp, #4]
          status_queue = rtosalMessageQueueGet(socket_desc->queue, &msg_queue, socket_desc->rcv_timeout);
 8021756:	69aa      	ldr	r2, [r5, #24]
 8021758:	a901      	add	r1, sp, #4
 802175a:	69e8      	ldr	r0, [r5, #28]
 802175c:	f7fd fd17 	bl	801f18e <rtosalMessageQueueGet>
          if (status_queue == osEventTimeout)
 8021760:	2840      	cmp	r0, #64	; 0x40
 8021762:	d02b      	beq.n	80217bc <com_recv_ip_modem+0x2a0>
            if ((msg_queue != 0U) && (GET_SOCKET_MSG_TYPE(msg_queue) == COM_SOCKET_MSG))
 8021764:	9b01      	ldr	r3, [sp, #4]
 8021766:	b113      	cbz	r3, 802176e <com_recv_ip_modem+0x252>
 8021768:	b29a      	uxth	r2, r3
 802176a:	2a01      	cmp	r2, #1
 802176c:	d04b      	beq.n	8021806 <com_recv_ip_modem+0x2ea>
              socket_desc->state = COM_SOCKET_CONNECTED;
 802176e:	2303      	movs	r3, #3
 8021770:	702b      	strb	r3, [r5, #0]
              PRINT_ERR("rcv data msg NOK or empty queue")
 8021772:	f8df c10c 	ldr.w	ip, [pc, #268]	; 8021880 <com_recv_ip_modem+0x364>
 8021776:	4f3c      	ldr	r7, [pc, #240]	; (8021868 <com_recv_ip_modem+0x34c>)
 8021778:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 802177c:	4664      	mov	r4, ip
 802177e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8021780:	6038      	str	r0, [r7, #0]
 8021782:	6079      	str	r1, [r7, #4]
 8021784:	60ba      	str	r2, [r7, #8]
 8021786:	60fb      	str	r3, [r7, #12]
 8021788:	46a4      	mov	ip, r4
 802178a:	3710      	adds	r7, #16
 802178c:	4574      	cmp	r4, lr
 802178e:	d1f5      	bne.n	802177c <com_recv_ip_modem+0x260>
 8021790:	4c35      	ldr	r4, [pc, #212]	; (8021868 <com_recv_ip_modem+0x34c>)
 8021792:	4620      	mov	r0, r4
 8021794:	f7fd fdc9 	bl	801f32a <crs_strlen>
 8021798:	b283      	uxth	r3, r0
 802179a:	4622      	mov	r2, r4
 802179c:	2110      	movs	r1, #16
 802179e:	2003      	movs	r0, #3
 80217a0:	f7fd fe06 	bl	801f3b0 <traceIF_itmPrint>
 80217a4:	4620      	mov	r0, r4
 80217a6:	f7fd fdc0 	bl	801f32a <crs_strlen>
 80217aa:	b283      	uxth	r3, r0
 80217ac:	4622      	mov	r2, r4
 80217ae:	2110      	movs	r1, #16
 80217b0:	2003      	movs	r0, #3
 80217b2:	f7fd fe1f 	bl	801f3f4 <traceIF_uartPrint>
              result = COM_SOCKETS_ERR_GENERAL;
 80217b6:	f04f 34ff 	mov.w	r4, #4294967295
 80217ba:	e790      	b.n	80216de <com_recv_ip_modem+0x1c2>
            socket_desc->state = COM_SOCKET_CONNECTED;
 80217bc:	f04f 0803 	mov.w	r8, #3
 80217c0:	f885 8000 	strb.w	r8, [r5]
            PRINT_INFO("rcv data exit timeout")
 80217c4:	4c28      	ldr	r4, [pc, #160]	; (8021868 <com_recv_ip_modem+0x34c>)
 80217c6:	4f2a      	ldr	r7, [pc, #168]	; (8021870 <com_recv_ip_modem+0x354>)
 80217c8:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80217ca:	6020      	str	r0, [r4, #0]
 80217cc:	6061      	str	r1, [r4, #4]
 80217ce:	60a2      	str	r2, [r4, #8]
 80217d0:	60e3      	str	r3, [r4, #12]
 80217d2:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 80217d4:	6120      	str	r0, [r4, #16]
 80217d6:	6161      	str	r1, [r4, #20]
 80217d8:	61a2      	str	r2, [r4, #24]
 80217da:	61e3      	str	r3, [r4, #28]
 80217dc:	4620      	mov	r0, r4
 80217de:	f7fd fda4 	bl	801f32a <crs_strlen>
 80217e2:	b283      	uxth	r3, r0
 80217e4:	4622      	mov	r2, r4
 80217e6:	2101      	movs	r1, #1
 80217e8:	4640      	mov	r0, r8
 80217ea:	f7fd fde1 	bl	801f3b0 <traceIF_itmPrint>
 80217ee:	4620      	mov	r0, r4
 80217f0:	f7fd fd9b 	bl	801f32a <crs_strlen>
 80217f4:	b283      	uxth	r3, r0
 80217f6:	4622      	mov	r2, r4
 80217f8:	2101      	movs	r1, #1
 80217fa:	4640      	mov	r0, r8
 80217fc:	f7fd fdfa 	bl	801f3f4 <traceIF_uartPrint>
            result = COM_SOCKETS_ERR_TIMEOUT;
 8021800:	f06f 0407 	mvn.w	r4, #7
 8021804:	e76b      	b.n	80216de <com_recv_ip_modem+0x1c2>
              switch (GET_SOCKET_MSG_ID(msg_queue))
 8021806:	0c1b      	lsrs	r3, r3, #16
 8021808:	2b01      	cmp	r3, #1
 802180a:	d03d      	beq.n	8021888 <com_recv_ip_modem+0x36c>
 802180c:	2b02      	cmp	r3, #2
 802180e:	f000 809b 	beq.w	8021948 <com_recv_ip_modem+0x42c>
                  socket_desc->state = COM_SOCKET_CONNECTED;
 8021812:	2303      	movs	r3, #3
 8021814:	702b      	strb	r3, [r5, #0]
                  PRINT_ERR("rcv data exit NOK impossible case")
 8021816:	f8df c06c 	ldr.w	ip, [pc, #108]	; 8021884 <com_recv_ip_modem+0x368>
 802181a:	4f13      	ldr	r7, [pc, #76]	; (8021868 <com_recv_ip_modem+0x34c>)
 802181c:	f10c 0e30 	add.w	lr, ip, #48	; 0x30
 8021820:	4664      	mov	r4, ip
 8021822:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8021824:	6038      	str	r0, [r7, #0]
 8021826:	6079      	str	r1, [r7, #4]
 8021828:	60ba      	str	r2, [r7, #8]
 802182a:	60fb      	str	r3, [r7, #12]
 802182c:	46a4      	mov	ip, r4
 802182e:	3710      	adds	r7, #16
 8021830:	4574      	cmp	r4, lr
 8021832:	d1f5      	bne.n	8021820 <com_recv_ip_modem+0x304>
 8021834:	8823      	ldrh	r3, [r4, #0]
 8021836:	803b      	strh	r3, [r7, #0]
 8021838:	4c0b      	ldr	r4, [pc, #44]	; (8021868 <com_recv_ip_modem+0x34c>)
 802183a:	4620      	mov	r0, r4
 802183c:	f7fd fd75 	bl	801f32a <crs_strlen>
 8021840:	b283      	uxth	r3, r0
 8021842:	4622      	mov	r2, r4
 8021844:	2110      	movs	r1, #16
 8021846:	2003      	movs	r0, #3
 8021848:	f7fd fdb2 	bl	801f3b0 <traceIF_itmPrint>
 802184c:	4620      	mov	r0, r4
 802184e:	f7fd fd6c 	bl	801f32a <crs_strlen>
 8021852:	b283      	uxth	r3, r0
 8021854:	4622      	mov	r2, r4
 8021856:	2110      	movs	r1, #16
 8021858:	2003      	movs	r0, #3
 802185a:	f7fd fdcb 	bl	801f3f4 <traceIF_uartPrint>
                  result = COM_SOCKETS_ERR_GENERAL;
 802185e:	f04f 34ff 	mov.w	r4, #4294967295
                  break;
 8021862:	e73c      	b.n	80216de <com_recv_ip_modem+0x1c2>
 8021864:	08036840 	.word	0x08036840
 8021868:	200049dc 	.word	0x200049dc
 802186c:	080366d4 	.word	0x080366d4
 8021870:	08036710 	.word	0x08036710
 8021874:	080366f0 	.word	0x080366f0
 8021878:	08036808 	.word	0x08036808
 802187c:	080366b8 	.word	0x080366b8
 8021880:	080367d8 	.word	0x080367d8
 8021884:	080367a4 	.word	0x080367a4
                  len_rcv = osCDS_socket_receive(socket_desc->id,
 8021888:	4622      	mov	r2, r4
 802188a:	4639      	mov	r1, r7
 802188c:	68a8      	ldr	r0, [r5, #8]
 802188e:	f7f9 f901 	bl	801aa94 <osCDS_socket_receive>
                           COM_SOCKETS_ERR_GENERAL : COM_SOCKETS_ERR_OK;
 8021892:	f1b0 0800 	subs.w	r8, r0, #0
 8021896:	db2b      	blt.n	80218f0 <com_recv_ip_modem+0x3d4>
 8021898:	4634      	mov	r4, r6
                  socket_desc->state = COM_SOCKET_CONNECTED;
 802189a:	2303      	movs	r3, #3
 802189c:	702b      	strb	r3, [r5, #0]
                  if (len_rcv == 0)
 802189e:	f1b8 0f00 	cmp.w	r8, #0
 80218a2:	d028      	beq.n	80218f6 <com_recv_ip_modem+0x3da>
                  PRINT_INFO("rcv data exit with data")
 80218a4:	f8df c144 	ldr.w	ip, [pc, #324]	; 80219ec <com_recv_ip_modem+0x4d0>
 80218a8:	4f4e      	ldr	r7, [pc, #312]	; (80219e4 <com_recv_ip_modem+0x4c8>)
 80218aa:	f10c 0e20 	add.w	lr, ip, #32
 80218ae:	4666      	mov	r6, ip
 80218b0:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80218b2:	6038      	str	r0, [r7, #0]
 80218b4:	6079      	str	r1, [r7, #4]
 80218b6:	60ba      	str	r2, [r7, #8]
 80218b8:	60fb      	str	r3, [r7, #12]
 80218ba:	46b4      	mov	ip, r6
 80218bc:	3710      	adds	r7, #16
 80218be:	4576      	cmp	r6, lr
 80218c0:	d1f5      	bne.n	80218ae <com_recv_ip_modem+0x392>
 80218c2:	8833      	ldrh	r3, [r6, #0]
 80218c4:	803b      	strh	r3, [r7, #0]
 80218c6:	4e47      	ldr	r6, [pc, #284]	; (80219e4 <com_recv_ip_modem+0x4c8>)
 80218c8:	4630      	mov	r0, r6
 80218ca:	f7fd fd2e 	bl	801f32a <crs_strlen>
 80218ce:	b283      	uxth	r3, r0
 80218d0:	4632      	mov	r2, r6
 80218d2:	2101      	movs	r1, #1
 80218d4:	2003      	movs	r0, #3
 80218d6:	f7fd fd6b 	bl	801f3b0 <traceIF_itmPrint>
 80218da:	4630      	mov	r0, r6
 80218dc:	f7fd fd25 	bl	801f32a <crs_strlen>
 80218e0:	b283      	uxth	r3, r0
 80218e2:	4632      	mov	r2, r6
 80218e4:	2101      	movs	r1, #1
 80218e6:	2003      	movs	r0, #3
 80218e8:	f7fd fd84 	bl	801f3f4 <traceIF_uartPrint>
                  len_rcv = osCDS_socket_receive(socket_desc->id,
 80218ec:	4646      	mov	r6, r8
                  break;
 80218ee:	e6f6      	b.n	80216de <com_recv_ip_modem+0x1c2>
                           COM_SOCKETS_ERR_GENERAL : COM_SOCKETS_ERR_OK;
 80218f0:	f04f 34ff 	mov.w	r4, #4294967295
 80218f4:	e7d1      	b.n	802189a <com_recv_ip_modem+0x37e>
                    PRINT_DBG("rcv data exit with no data")
 80218f6:	4f3c      	ldr	r7, [pc, #240]	; (80219e8 <com_recv_ip_modem+0x4cc>)
 80218f8:	4e3a      	ldr	r6, [pc, #232]	; (80219e4 <com_recv_ip_modem+0x4c8>)
 80218fa:	f107 0e20 	add.w	lr, r7, #32
 80218fe:	46bc      	mov	ip, r7
 8021900:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021904:	6030      	str	r0, [r6, #0]
 8021906:	6071      	str	r1, [r6, #4]
 8021908:	60b2      	str	r2, [r6, #8]
 802190a:	60f3      	str	r3, [r6, #12]
 802190c:	4667      	mov	r7, ip
 802190e:	3610      	adds	r6, #16
 8021910:	45f4      	cmp	ip, lr
 8021912:	d1f4      	bne.n	80218fe <com_recv_ip_modem+0x3e2>
 8021914:	f8dc 0000 	ldr.w	r0, [ip]
 8021918:	6030      	str	r0, [r6, #0]
 802191a:	f89c 3004 	ldrb.w	r3, [ip, #4]
 802191e:	7133      	strb	r3, [r6, #4]
 8021920:	4e30      	ldr	r6, [pc, #192]	; (80219e4 <com_recv_ip_modem+0x4c8>)
 8021922:	4630      	mov	r0, r6
 8021924:	f7fd fd01 	bl	801f32a <crs_strlen>
 8021928:	b283      	uxth	r3, r0
 802192a:	4632      	mov	r2, r6
 802192c:	2102      	movs	r1, #2
 802192e:	2003      	movs	r0, #3
 8021930:	f7fd fd3e 	bl	801f3b0 <traceIF_itmPrint>
 8021934:	4630      	mov	r0, r6
 8021936:	f7fd fcf8 	bl	801f32a <crs_strlen>
 802193a:	b283      	uxth	r3, r0
 802193c:	4632      	mov	r2, r6
 802193e:	2102      	movs	r1, #2
 8021940:	2003      	movs	r0, #3
 8021942:	f7fd fd57 	bl	801f3f4 <traceIF_uartPrint>
 8021946:	e7ad      	b.n	80218a4 <com_recv_ip_modem+0x388>
                  socket_desc->state = COM_SOCKET_CLOSING;
 8021948:	2307      	movs	r3, #7
 802194a:	702b      	strb	r3, [r5, #0]
                  PRINT_INFO("rcv data exit socket closing")
 802194c:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 80219f0 <com_recv_ip_modem+0x4d4>
 8021950:	4c24      	ldr	r4, [pc, #144]	; (80219e4 <com_recv_ip_modem+0x4c8>)
 8021952:	f10c 0e20 	add.w	lr, ip, #32
 8021956:	4667      	mov	r7, ip
 8021958:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 802195a:	6020      	str	r0, [r4, #0]
 802195c:	6061      	str	r1, [r4, #4]
 802195e:	60a2      	str	r2, [r4, #8]
 8021960:	60e3      	str	r3, [r4, #12]
 8021962:	46bc      	mov	ip, r7
 8021964:	3410      	adds	r4, #16
 8021966:	4577      	cmp	r7, lr
 8021968:	d1f5      	bne.n	8021956 <com_recv_ip_modem+0x43a>
 802196a:	6838      	ldr	r0, [r7, #0]
 802196c:	6020      	str	r0, [r4, #0]
 802196e:	88ba      	ldrh	r2, [r7, #4]
 8021970:	79bb      	ldrb	r3, [r7, #6]
 8021972:	80a2      	strh	r2, [r4, #4]
 8021974:	71a3      	strb	r3, [r4, #6]
 8021976:	4c1b      	ldr	r4, [pc, #108]	; (80219e4 <com_recv_ip_modem+0x4c8>)
 8021978:	4620      	mov	r0, r4
 802197a:	f7fd fcd6 	bl	801f32a <crs_strlen>
 802197e:	b283      	uxth	r3, r0
 8021980:	4622      	mov	r2, r4
 8021982:	2101      	movs	r1, #1
 8021984:	2003      	movs	r0, #3
 8021986:	f7fd fd13 	bl	801f3b0 <traceIF_itmPrint>
 802198a:	4620      	mov	r0, r4
 802198c:	f7fd fccd 	bl	801f32a <crs_strlen>
 8021990:	b283      	uxth	r3, r0
 8021992:	4622      	mov	r2, r4
 8021994:	2101      	movs	r1, #1
 8021996:	2003      	movs	r0, #3
 8021998:	f7fd fd2c 	bl	801f3f4 <traceIF_uartPrint>
                  result = COM_SOCKETS_ERR_CLOSING;
 802199c:	f06f 0405 	mvn.w	r4, #5
                  break;
 80219a0:	e69d      	b.n	80216de <com_recv_ip_modem+0x1c2>
          result = (len_rcv < 0) ? COM_SOCKETS_ERR_GENERAL : COM_SOCKETS_ERR_OK;
 80219a2:	f04f 34ff 	mov.w	r4, #4294967295
 80219a6:	e671      	b.n	802168c <com_recv_ip_modem+0x170>
  len_rcv = 0;
 80219a8:	2600      	movs	r6, #0
                 COM_SOCKETS_ERR_CLOSING : COM_SOCKETS_ERR_INPROGRESS;
 80219aa:	f06f 0405 	mvn.w	r4, #5
 80219ae:	e699      	b.n	80216e4 <com_recv_ip_modem+0x1c8>
  len_rcv = 0;
 80219b0:	2600      	movs	r6, #0
        result = COM_SOCKETS_ERR_STATE;
 80219b2:	f06f 040c 	mvn.w	r4, #12
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 80219b6:	2007      	movs	r0, #7
 80219b8:	e698      	b.n	80216ec <com_recv_ip_modem+0x1d0>
 80219ba:	2007      	movs	r0, #7
 80219bc:	e696      	b.n	80216ec <com_recv_ip_modem+0x1d0>
  len_rcv = 0;
 80219be:	2600      	movs	r6, #0
  result = COM_SOCKETS_ERR_PARAMETER;
 80219c0:	f06f 0402 	mvn.w	r4, #2
                                 COM_SOCKET_STAT_RCV_OK : COM_SOCKET_STAT_RCV_NOK);
  }

  SOCKET_SET_ERROR(socket_desc, result);
 80219c4:	b105      	cbz	r5, 80219c8 <com_recv_ip_modem+0x4ac>
 80219c6:	606c      	str	r4, [r5, #4]
  return ((result == COM_SOCKETS_ERR_OK) ? len_rcv : result);
 80219c8:	b904      	cbnz	r4, 80219cc <com_recv_ip_modem+0x4b0>
 80219ca:	4634      	mov	r4, r6
}
 80219cc:	4620      	mov	r0, r4
 80219ce:	b002      	add	sp, #8
 80219d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  len_rcv = 0;
 80219d4:	2600      	movs	r6, #0
  result = COM_SOCKETS_ERR_PARAMETER;
 80219d6:	f06f 0402 	mvn.w	r4, #2
 80219da:	e7f3      	b.n	80219c4 <com_recv_ip_modem+0x4a8>
  len_rcv = 0;
 80219dc:	2600      	movs	r6, #0
  result = COM_SOCKETS_ERR_PARAMETER;
 80219de:	f06f 0402 	mvn.w	r4, #2
 80219e2:	e7ef      	b.n	80219c4 <com_recv_ip_modem+0x4a8>
 80219e4:	200049dc 	.word	0x200049dc
 80219e8:	08036730 	.word	0x08036730
 80219ec:	08036758 	.word	0x08036758
 80219f0:	0803677c 	.word	0x0803677c

080219f4 <com_closesocket_ip_modem>:
  *         socket must be considered as not closed and handle as not released
  * @param  sock      - socket handle obtained with com_socket
  * @retval int32_t   - ok or error value
  */
int32_t com_closesocket_ip_modem(int32_t sock)
{
 80219f4:	b570      	push	{r4, r5, r6, lr}
 80219f6:	4604      	mov	r4, r0
  int32_t result;
  socket_desc_t *socket_desc;

  result = COM_SOCKETS_ERR_PARAMETER;
  socket_desc = com_ip_modem_find_socket(sock, false);
 80219f8:	2100      	movs	r1, #0
 80219fa:	f7fe fbe3 	bl	80201c4 <com_ip_modem_find_socket>

  if (socket_desc != NULL)
 80219fe:	2800      	cmp	r0, #0
 8021a00:	f000 808d 	beq.w	8021b1e <com_closesocket_ip_modem+0x12a>
  {
    /* If socket is currently under process refused to close it */
    if ((socket_desc->state == COM_SOCKET_SENDING)
 8021a04:	7803      	ldrb	r3, [r0, #0]
        || (socket_desc->state == COM_SOCKET_WAITING_RSP))
 8021a06:	3b04      	subs	r3, #4
 8021a08:	b2db      	uxtb	r3, r3
    if ((socket_desc->state == COM_SOCKET_SENDING)
 8021a0a:	2b01      	cmp	r3, #1
 8021a0c:	d92b      	bls.n	8021a66 <com_closesocket_ip_modem+0x72>
      result = COM_SOCKETS_ERR_INPROGRESS;
    }
    else
    {
      result = COM_SOCKETS_ERR_GENERAL;
      com_ip_modem_wakeup_request();
 8021a0e:	f7fe fc37 	bl	8020280 <com_ip_modem_wakeup_request>
      if (osCDS_socket_close(sock, 0U)
 8021a12:	2100      	movs	r1, #0
 8021a14:	4620      	mov	r0, r4
 8021a16:	f7f9 f887 	bl	801ab28 <osCDS_socket_close>
 8021a1a:	2800      	cmp	r0, #0
 8021a1c:	d153      	bne.n	8021ac6 <com_closesocket_ip_modem+0xd2>
          == CELLULAR_OK)
      {
        com_ip_modem_delete_socket_desc(sock, false);
 8021a1e:	2100      	movs	r1, #0
 8021a20:	4620      	mov	r0, r4
 8021a22:	f7fe fec1 	bl	80207a8 <com_ip_modem_delete_socket_desc>
        result = COM_SOCKETS_ERR_OK;
        PRINT_INFO("close socket ok")
 8021a26:	4c3f      	ldr	r4, [pc, #252]	; (8021b24 <com_closesocket_ip_modem+0x130>)
 8021a28:	4d3f      	ldr	r5, [pc, #252]	; (8021b28 <com_closesocket_ip_modem+0x134>)
 8021a2a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021a2c:	6020      	str	r0, [r4, #0]
 8021a2e:	6061      	str	r1, [r4, #4]
 8021a30:	60a2      	str	r2, [r4, #8]
 8021a32:	60e3      	str	r3, [r4, #12]
 8021a34:	cd03      	ldmia	r5!, {r0, r1}
 8021a36:	6120      	str	r0, [r4, #16]
 8021a38:	6161      	str	r1, [r4, #20]
 8021a3a:	882b      	ldrh	r3, [r5, #0]
 8021a3c:	8323      	strh	r3, [r4, #24]
 8021a3e:	4620      	mov	r0, r4
 8021a40:	f7fd fc73 	bl	801f32a <crs_strlen>
 8021a44:	b283      	uxth	r3, r0
 8021a46:	4622      	mov	r2, r4
 8021a48:	2101      	movs	r1, #1
 8021a4a:	2003      	movs	r0, #3
 8021a4c:	f7fd fcb0 	bl	801f3b0 <traceIF_itmPrint>
 8021a50:	4620      	mov	r0, r4
 8021a52:	f7fd fc6a 	bl	801f32a <crs_strlen>
 8021a56:	b283      	uxth	r3, r0
 8021a58:	4622      	mov	r2, r4
 8021a5a:	2101      	movs	r1, #1
 8021a5c:	2003      	movs	r0, #3
 8021a5e:	f7fd fcc9 	bl	801f3f4 <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_OK;
 8021a62:	2400      	movs	r4, #0
 8021a64:	e056      	b.n	8021b14 <com_closesocket_ip_modem+0x120>
      PRINT_ERR("close socket NOK err state")
 8021a66:	4c31      	ldr	r4, [pc, #196]	; (8021b2c <com_closesocket_ip_modem+0x138>)
 8021a68:	4d2e      	ldr	r5, [pc, #184]	; (8021b24 <com_closesocket_ip_modem+0x130>)
 8021a6a:	f104 0620 	add.w	r6, r4, #32
 8021a6e:	46a4      	mov	ip, r4
 8021a70:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021a74:	6028      	str	r0, [r5, #0]
 8021a76:	6069      	str	r1, [r5, #4]
 8021a78:	60aa      	str	r2, [r5, #8]
 8021a7a:	60eb      	str	r3, [r5, #12]
 8021a7c:	4664      	mov	r4, ip
 8021a7e:	3510      	adds	r5, #16
 8021a80:	45b4      	cmp	ip, r6
 8021a82:	d1f4      	bne.n	8021a6e <com_closesocket_ip_modem+0x7a>
 8021a84:	cc03      	ldmia	r4!, {r0, r1}
 8021a86:	6028      	str	r0, [r5, #0]
 8021a88:	6069      	str	r1, [r5, #4]
 8021a8a:	8822      	ldrh	r2, [r4, #0]
 8021a8c:	78a3      	ldrb	r3, [r4, #2]
 8021a8e:	812a      	strh	r2, [r5, #8]
 8021a90:	72ab      	strb	r3, [r5, #10]
 8021a92:	4c24      	ldr	r4, [pc, #144]	; (8021b24 <com_closesocket_ip_modem+0x130>)
 8021a94:	4620      	mov	r0, r4
 8021a96:	f7fd fc48 	bl	801f32a <crs_strlen>
 8021a9a:	b283      	uxth	r3, r0
 8021a9c:	4622      	mov	r2, r4
 8021a9e:	2110      	movs	r1, #16
 8021aa0:	2003      	movs	r0, #3
 8021aa2:	f7fd fc85 	bl	801f3b0 <traceIF_itmPrint>
 8021aa6:	4620      	mov	r0, r4
 8021aa8:	f7fd fc3f 	bl	801f32a <crs_strlen>
 8021aac:	b283      	uxth	r3, r0
 8021aae:	4622      	mov	r2, r4
 8021ab0:	2110      	movs	r1, #16
 8021ab2:	2003      	movs	r0, #3
 8021ab4:	f7fd fc9e 	bl	801f3f4 <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_INPROGRESS;
 8021ab8:	f06f 0408 	mvn.w	r4, #8
      {
        PRINT_INFO("close socket NOK low level")
      }
      com_ip_modem_idlemode_request(true);
    }
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8021abc:	2009      	movs	r0, #9
 8021abe:	f000 fa85 	bl	8021fcc <com_sockets_statistic_update>
                                 COM_SOCKET_STAT_CLS_OK : COM_SOCKET_STAT_CLS_NOK);
  }


  return (result);
}
 8021ac2:	4620      	mov	r0, r4
 8021ac4:	bd70      	pop	{r4, r5, r6, pc}
        PRINT_INFO("close socket NOK low level")
 8021ac6:	4e1a      	ldr	r6, [pc, #104]	; (8021b30 <com_closesocket_ip_modem+0x13c>)
 8021ac8:	4c16      	ldr	r4, [pc, #88]	; (8021b24 <com_closesocket_ip_modem+0x130>)
 8021aca:	f106 0c20 	add.w	ip, r6, #32
 8021ace:	4635      	mov	r5, r6
 8021ad0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8021ad2:	6020      	str	r0, [r4, #0]
 8021ad4:	6061      	str	r1, [r4, #4]
 8021ad6:	60a2      	str	r2, [r4, #8]
 8021ad8:	60e3      	str	r3, [r4, #12]
 8021ada:	462e      	mov	r6, r5
 8021adc:	3410      	adds	r4, #16
 8021ade:	4565      	cmp	r5, ip
 8021ae0:	d1f5      	bne.n	8021ace <com_closesocket_ip_modem+0xda>
 8021ae2:	6828      	ldr	r0, [r5, #0]
 8021ae4:	6020      	str	r0, [r4, #0]
 8021ae6:	792b      	ldrb	r3, [r5, #4]
 8021ae8:	7123      	strb	r3, [r4, #4]
 8021aea:	4c0e      	ldr	r4, [pc, #56]	; (8021b24 <com_closesocket_ip_modem+0x130>)
 8021aec:	4620      	mov	r0, r4
 8021aee:	f7fd fc1c 	bl	801f32a <crs_strlen>
 8021af2:	b283      	uxth	r3, r0
 8021af4:	4622      	mov	r2, r4
 8021af6:	2101      	movs	r1, #1
 8021af8:	2003      	movs	r0, #3
 8021afa:	f7fd fc59 	bl	801f3b0 <traceIF_itmPrint>
 8021afe:	4620      	mov	r0, r4
 8021b00:	f7fd fc13 	bl	801f32a <crs_strlen>
 8021b04:	b283      	uxth	r3, r0
 8021b06:	4622      	mov	r2, r4
 8021b08:	2101      	movs	r1, #1
 8021b0a:	2003      	movs	r0, #3
 8021b0c:	f7fd fc72 	bl	801f3f4 <traceIF_uartPrint>
      result = COM_SOCKETS_ERR_GENERAL;
 8021b10:	f04f 34ff 	mov.w	r4, #4294967295
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8021b14:	b90c      	cbnz	r4, 8021b1a <com_closesocket_ip_modem+0x126>
 8021b16:	2008      	movs	r0, #8
 8021b18:	e7d1      	b.n	8021abe <com_closesocket_ip_modem+0xca>
 8021b1a:	2009      	movs	r0, #9
 8021b1c:	e7cf      	b.n	8021abe <com_closesocket_ip_modem+0xca>
  result = COM_SOCKETS_ERR_PARAMETER;
 8021b1e:	f06f 0402 	mvn.w	r4, #2
  return (result);
 8021b22:	e7ce      	b.n	8021ac2 <com_closesocket_ip_modem+0xce>
 8021b24:	200049dc 	.word	0x200049dc
 8021b28:	08036894 	.word	0x08036894
 8021b2c:	08036868 	.word	0x08036868
 8021b30:	080368b0 	.word	0x080368b0

08021b34 <com_socket_ip_modem>:
{
 8021b34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8021b38:	460c      	mov	r4, r1
  if (family == COM_AF_INET)
 8021b3a:	2802      	cmp	r0, #2
 8021b3c:	d005      	beq.n	8021b4a <com_socket_ip_modem+0x16>
  else if (family == COM_AF_INET6)
 8021b3e:	bbb0      	cbnz	r0, 8021bae <com_socket_ip_modem+0x7a>
    IPaddrType = CS_IPAT_IPV6; /* To avoid a warning */
 8021b40:	f04f 0802 	mov.w	r8, #2
    result = COM_SOCKETS_ERR_UNSUPPORTED;
 8021b44:	f06f 060b 	mvn.w	r6, #11
 8021b48:	e002      	b.n	8021b50 <com_socket_ip_modem+0x1c>
    IPaddrType = CS_IPAT_IPV4;
 8021b4a:	f04f 0801 	mov.w	r8, #1
  result = COM_SOCKETS_ERR_OK;
 8021b4e:	2600      	movs	r6, #0
  if ((type == COM_SOCK_STREAM)
 8021b50:	2c01      	cmp	r4, #1
 8021b52:	d031      	beq.n	8021bb8 <com_socket_ip_modem+0x84>
  else if ((type == COM_SOCK_DGRAM)
 8021b54:	2c02      	cmp	r4, #2
 8021b56:	d036      	beq.n	8021bc6 <com_socket_ip_modem+0x92>
    result = COM_SOCKETS_ERR_UNSUPPORTED;
 8021b58:	f06f 060b 	mvn.w	r6, #11
    PRINT_ERR("create socket NOK parameter NOK")
 8021b5c:	4dba      	ldr	r5, [pc, #744]	; (8021e48 <com_socket_ip_modem+0x314>)
 8021b5e:	4cbb      	ldr	r4, [pc, #748]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021b60:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 8021b64:	46ac      	mov	ip, r5
 8021b66:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021b6a:	6020      	str	r0, [r4, #0]
 8021b6c:	6061      	str	r1, [r4, #4]
 8021b6e:	60a2      	str	r2, [r4, #8]
 8021b70:	60e3      	str	r3, [r4, #12]
 8021b72:	4665      	mov	r5, ip
 8021b74:	3410      	adds	r4, #16
 8021b76:	45f4      	cmp	ip, lr
 8021b78:	d1f4      	bne.n	8021b64 <com_socket_ip_modem+0x30>
 8021b7a:	4cb4      	ldr	r4, [pc, #720]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021b7c:	4620      	mov	r0, r4
 8021b7e:	f7fd fbd4 	bl	801f32a <crs_strlen>
 8021b82:	b283      	uxth	r3, r0
 8021b84:	4622      	mov	r2, r4
 8021b86:	2110      	movs	r1, #16
 8021b88:	2003      	movs	r0, #3
 8021b8a:	f7fd fc11 	bl	801f3b0 <traceIF_itmPrint>
 8021b8e:	4620      	mov	r0, r4
 8021b90:	f7fd fbcb 	bl	801f32a <crs_strlen>
 8021b94:	b283      	uxth	r3, r0
 8021b96:	4622      	mov	r2, r4
 8021b98:	2110      	movs	r1, #16
 8021b9a:	2003      	movs	r0, #3
 8021b9c:	f7fd fc2a 	bl	801f3f4 <traceIF_uartPrint>
  sock = COM_SOCKET_INVALID_ID;
 8021ba0:	f04f 35ff 	mov.w	r5, #4294967295
  return ((result == COM_SOCKETS_ERR_OK) ? sock : result);
 8021ba4:	b906      	cbnz	r6, 8021ba8 <com_socket_ip_modem+0x74>
 8021ba6:	462e      	mov	r6, r5
}
 8021ba8:	4630      	mov	r0, r6
 8021baa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    IPaddrType = CS_IPAT_INVALID; /* To avoid a warning */
 8021bae:	f04f 0800 	mov.w	r8, #0
    result = COM_SOCKETS_ERR_PARAMETER;
 8021bb2:	f06f 0602 	mvn.w	r6, #2
 8021bb6:	e7cb      	b.n	8021b50 <com_socket_ip_modem+0x1c>
      && ((protocol == COM_IPPROTO_TCP)
 8021bb8:	2a06      	cmp	r2, #6
 8021bba:	d00d      	beq.n	8021bd8 <com_socket_ip_modem+0xa4>
          || (protocol == COM_IPPROTO_IP)))
 8021bbc:	2a00      	cmp	r2, #0
 8021bbe:	d1c9      	bne.n	8021b54 <com_socket_ip_modem+0x20>
    TransportProtocol = CS_TCP_PROTOCOL;
 8021bc0:	f04f 0900 	mov.w	r9, #0
 8021bc4:	e00a      	b.n	8021bdc <com_socket_ip_modem+0xa8>
           && ((protocol == COM_IPPROTO_UDP)
 8021bc6:	2a02      	cmp	r2, #2
 8021bc8:	f000 80c0 	beq.w	8021d4c <com_socket_ip_modem+0x218>
               || (protocol == COM_IPPROTO_IP)))
 8021bcc:	2a00      	cmp	r2, #0
 8021bce:	f040 81a6 	bne.w	8021f1e <com_socket_ip_modem+0x3ea>
    TransportProtocol = CS_UDP_PROTOCOL;
 8021bd2:	f04f 0901 	mov.w	r9, #1
 8021bd6:	e001      	b.n	8021bdc <com_socket_ip_modem+0xa8>
    TransportProtocol = CS_TCP_PROTOCOL;
 8021bd8:	f04f 0900 	mov.w	r9, #0
  if (result == COM_SOCKETS_ERR_OK)
 8021bdc:	2e00      	cmp	r6, #0
 8021bde:	d1bd      	bne.n	8021b5c <com_socket_ip_modem+0x28>
    PRINT_DBG("socket create request")
 8021be0:	4d9a      	ldr	r5, [pc, #616]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021be2:	4f9b      	ldr	r7, [pc, #620]	; (8021e50 <com_socket_ip_modem+0x31c>)
 8021be4:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021be6:	6028      	str	r0, [r5, #0]
 8021be8:	6069      	str	r1, [r5, #4]
 8021bea:	60aa      	str	r2, [r5, #8]
 8021bec:	60eb      	str	r3, [r5, #12]
 8021bee:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021bf0:	6128      	str	r0, [r5, #16]
 8021bf2:	6169      	str	r1, [r5, #20]
 8021bf4:	61aa      	str	r2, [r5, #24]
 8021bf6:	61eb      	str	r3, [r5, #28]
 8021bf8:	4628      	mov	r0, r5
 8021bfa:	f7fd fb96 	bl	801f32a <crs_strlen>
 8021bfe:	b283      	uxth	r3, r0
 8021c00:	462a      	mov	r2, r5
 8021c02:	2102      	movs	r1, #2
 8021c04:	2003      	movs	r0, #3
 8021c06:	f7fd fbd3 	bl	801f3b0 <traceIF_itmPrint>
 8021c0a:	4628      	mov	r0, r5
 8021c0c:	f7fd fb8d 	bl	801f32a <crs_strlen>
 8021c10:	b283      	uxth	r3, r0
 8021c12:	462a      	mov	r2, r5
 8021c14:	2102      	movs	r1, #2
 8021c16:	2003      	movs	r0, #3
 8021c18:	f7fd fbec 	bl	801f3f4 <traceIF_uartPrint>
    com_ip_modem_wakeup_request();
 8021c1c:	f7fe fb30 	bl	8020280 <com_ip_modem_wakeup_request>
    sock = osCDS_socket_create(IPaddrType,
 8021c20:	220b      	movs	r2, #11
 8021c22:	4649      	mov	r1, r9
 8021c24:	4640      	mov	r0, r8
 8021c26:	f7f8 fea1 	bl	801a96c <osCDS_socket_create>
 8021c2a:	4605      	mov	r5, r0
    if (sock != CS_INVALID_SOCKET_HANDLE)
 8021c2c:	f1b0 3fff 	cmp.w	r0, #4294967295
 8021c30:	f000 8149 	beq.w	8021ec6 <com_socket_ip_modem+0x392>
      PRINT_INFO("create socket ok low level")
 8021c34:	f8df e234 	ldr.w	lr, [pc, #564]	; 8021e6c <com_socket_ip_modem+0x338>
 8021c38:	4f84      	ldr	r7, [pc, #528]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021c3a:	f10e 0820 	add.w	r8, lr, #32
 8021c3e:	46f4      	mov	ip, lr
 8021c40:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8021c44:	6038      	str	r0, [r7, #0]
 8021c46:	6079      	str	r1, [r7, #4]
 8021c48:	60ba      	str	r2, [r7, #8]
 8021c4a:	60fb      	str	r3, [r7, #12]
 8021c4c:	46e6      	mov	lr, ip
 8021c4e:	3710      	adds	r7, #16
 8021c50:	45c4      	cmp	ip, r8
 8021c52:	d1f4      	bne.n	8021c3e <com_socket_ip_modem+0x10a>
 8021c54:	f8dc 0000 	ldr.w	r0, [ip]
 8021c58:	6038      	str	r0, [r7, #0]
 8021c5a:	f89c 3004 	ldrb.w	r3, [ip, #4]
 8021c5e:	713b      	strb	r3, [r7, #4]
 8021c60:	4f7a      	ldr	r7, [pc, #488]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021c62:	4638      	mov	r0, r7
 8021c64:	f7fd fb61 	bl	801f32a <crs_strlen>
 8021c68:	b283      	uxth	r3, r0
 8021c6a:	463a      	mov	r2, r7
 8021c6c:	2101      	movs	r1, #1
 8021c6e:	2003      	movs	r0, #3
 8021c70:	f7fd fb9e 	bl	801f3b0 <traceIF_itmPrint>
 8021c74:	4638      	mov	r0, r7
 8021c76:	f7fd fb58 	bl	801f32a <crs_strlen>
 8021c7a:	b283      	uxth	r3, r0
 8021c7c:	463a      	mov	r2, r7
 8021c7e:	2101      	movs	r1, #1
 8021c80:	2003      	movs	r0, #3
 8021c82:	f7fd fbb7 	bl	801f3f4 <traceIF_uartPrint>
      socket_desc = com_ip_modem_provide_socket_desc(false);
 8021c86:	2000      	movs	r0, #0
 8021c88:	f7fe fd22 	bl	80206d0 <com_ip_modem_provide_socket_desc>
      if (socket_desc == NULL)
 8021c8c:	2800      	cmp	r0, #0
 8021c8e:	d060      	beq.n	8021d52 <com_socket_ip_modem+0x21e>
        socket_desc->id    = sock;
 8021c90:	6085      	str	r5, [r0, #8]
        socket_desc->type  = (uint8_t)type;
 8021c92:	70c4      	strb	r4, [r0, #3]
        socket_desc->state = COM_SOCKET_CREATED;
 8021c94:	2202      	movs	r2, #2
 8021c96:	7002      	strb	r2, [r0, #0]
        if (osCDS_socket_set_callbacks(sock,
 8021c98:	4b6e      	ldr	r3, [pc, #440]	; (8021e54 <com_socket_ip_modem+0x320>)
 8021c9a:	2200      	movs	r2, #0
 8021c9c:	496e      	ldr	r1, [pc, #440]	; (8021e58 <com_socket_ip_modem+0x324>)
 8021c9e:	4628      	mov	r0, r5
 8021ca0:	f7f8 fe7c 	bl	801a99c <osCDS_socket_set_callbacks>
 8021ca4:	2800      	cmp	r0, #0
 8021ca6:	f000 8134 	beq.w	8021f12 <com_socket_ip_modem+0x3de>
          PRINT_ERR("rqt close socket issue at creation")
 8021caa:	4f6c      	ldr	r7, [pc, #432]	; (8021e5c <com_socket_ip_modem+0x328>)
 8021cac:	4c67      	ldr	r4, [pc, #412]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021cae:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8021cb2:	463e      	mov	r6, r7
 8021cb4:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8021cb6:	6020      	str	r0, [r4, #0]
 8021cb8:	6061      	str	r1, [r4, #4]
 8021cba:	60a2      	str	r2, [r4, #8]
 8021cbc:	60e3      	str	r3, [r4, #12]
 8021cbe:	4637      	mov	r7, r6
 8021cc0:	3410      	adds	r4, #16
 8021cc2:	4566      	cmp	r6, ip
 8021cc4:	d1f5      	bne.n	8021cb2 <com_socket_ip_modem+0x17e>
 8021cc6:	8832      	ldrh	r2, [r6, #0]
 8021cc8:	78b3      	ldrb	r3, [r6, #2]
 8021cca:	8022      	strh	r2, [r4, #0]
 8021ccc:	70a3      	strb	r3, [r4, #2]
 8021cce:	4c5f      	ldr	r4, [pc, #380]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021cd0:	4620      	mov	r0, r4
 8021cd2:	f7fd fb2a 	bl	801f32a <crs_strlen>
 8021cd6:	b283      	uxth	r3, r0
 8021cd8:	4622      	mov	r2, r4
 8021cda:	2110      	movs	r1, #16
 8021cdc:	2003      	movs	r0, #3
 8021cde:	f7fd fb67 	bl	801f3b0 <traceIF_itmPrint>
 8021ce2:	4620      	mov	r0, r4
 8021ce4:	f7fd fb21 	bl	801f32a <crs_strlen>
 8021ce8:	b283      	uxth	r3, r0
 8021cea:	4622      	mov	r2, r4
 8021cec:	2110      	movs	r1, #16
 8021cee:	2003      	movs	r0, #3
 8021cf0:	f7fd fb80 	bl	801f3f4 <traceIF_uartPrint>
          if (com_closesocket_ip_modem(sock)
 8021cf4:	4628      	mov	r0, r5
 8021cf6:	f7ff fe7d 	bl	80219f4 <com_closesocket_ip_modem>
 8021cfa:	2800      	cmp	r0, #0
 8021cfc:	f040 80b8 	bne.w	8021e70 <com_socket_ip_modem+0x33c>
            PRINT_INFO("close socket ok low level")
 8021d00:	4f57      	ldr	r7, [pc, #348]	; (8021e60 <com_socket_ip_modem+0x32c>)
 8021d02:	4626      	mov	r6, r4
 8021d04:	f107 0c20 	add.w	ip, r7, #32
 8021d08:	463c      	mov	r4, r7
 8021d0a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8021d0c:	6030      	str	r0, [r6, #0]
 8021d0e:	6071      	str	r1, [r6, #4]
 8021d10:	60b2      	str	r2, [r6, #8]
 8021d12:	60f3      	str	r3, [r6, #12]
 8021d14:	4627      	mov	r7, r4
 8021d16:	3610      	adds	r6, #16
 8021d18:	4564      	cmp	r4, ip
 8021d1a:	d1f5      	bne.n	8021d08 <com_socket_ip_modem+0x1d4>
 8021d1c:	6820      	ldr	r0, [r4, #0]
 8021d1e:	6030      	str	r0, [r6, #0]
 8021d20:	4c4a      	ldr	r4, [pc, #296]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021d22:	4620      	mov	r0, r4
 8021d24:	f7fd fb01 	bl	801f32a <crs_strlen>
 8021d28:	b283      	uxth	r3, r0
 8021d2a:	4622      	mov	r2, r4
 8021d2c:	2101      	movs	r1, #1
 8021d2e:	2003      	movs	r0, #3
 8021d30:	f7fd fb3e 	bl	801f3b0 <traceIF_itmPrint>
 8021d34:	4620      	mov	r0, r4
 8021d36:	f7fd faf8 	bl	801f32a <crs_strlen>
 8021d3a:	b283      	uxth	r3, r0
 8021d3c:	4622      	mov	r2, r4
 8021d3e:	2101      	movs	r1, #1
 8021d40:	2003      	movs	r0, #3
 8021d42:	f7fd fb57 	bl	801f3f4 <traceIF_uartPrint>
    result = COM_SOCKETS_ERR_GENERAL;
 8021d46:	f04f 36ff 	mov.w	r6, #4294967295
 8021d4a:	e0e2      	b.n	8021f12 <com_socket_ip_modem+0x3de>
    TransportProtocol = CS_UDP_PROTOCOL;
 8021d4c:	f04f 0901 	mov.w	r9, #1
 8021d50:	e744      	b.n	8021bdc <com_socket_ip_modem+0xa8>
        PRINT_ERR("create socket NOK no memory")
 8021d52:	4f44      	ldr	r7, [pc, #272]	; (8021e64 <com_socket_ip_modem+0x330>)
 8021d54:	4c3d      	ldr	r4, [pc, #244]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021d56:	f107 0c20 	add.w	ip, r7, #32
 8021d5a:	463e      	mov	r6, r7
 8021d5c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8021d5e:	6020      	str	r0, [r4, #0]
 8021d60:	6061      	str	r1, [r4, #4]
 8021d62:	60a2      	str	r2, [r4, #8]
 8021d64:	60e3      	str	r3, [r4, #12]
 8021d66:	4637      	mov	r7, r6
 8021d68:	3410      	adds	r4, #16
 8021d6a:	4566      	cmp	r6, ip
 8021d6c:	d1f5      	bne.n	8021d5a <com_socket_ip_modem+0x226>
 8021d6e:	cf07      	ldmia	r7!, {r0, r1, r2}
 8021d70:	6020      	str	r0, [r4, #0]
 8021d72:	6061      	str	r1, [r4, #4]
 8021d74:	60a2      	str	r2, [r4, #8]
 8021d76:	4c35      	ldr	r4, [pc, #212]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021d78:	4620      	mov	r0, r4
 8021d7a:	f7fd fad6 	bl	801f32a <crs_strlen>
 8021d7e:	b283      	uxth	r3, r0
 8021d80:	4622      	mov	r2, r4
 8021d82:	2110      	movs	r1, #16
 8021d84:	2003      	movs	r0, #3
 8021d86:	f7fd fb13 	bl	801f3b0 <traceIF_itmPrint>
 8021d8a:	4620      	mov	r0, r4
 8021d8c:	f7fd facd 	bl	801f32a <crs_strlen>
 8021d90:	b283      	uxth	r3, r0
 8021d92:	4622      	mov	r2, r4
 8021d94:	2110      	movs	r1, #16
 8021d96:	2003      	movs	r0, #3
 8021d98:	f7fd fb2c 	bl	801f3f4 <traceIF_uartPrint>
        if (osCDS_socket_close(sock, 0U)
 8021d9c:	2100      	movs	r1, #0
 8021d9e:	4628      	mov	r0, r5
 8021da0:	f7f8 fec2 	bl	801ab28 <osCDS_socket_close>
 8021da4:	bb28      	cbnz	r0, 8021df2 <com_socket_ip_modem+0x2be>
          PRINT_INFO("close socket ok low level")
 8021da6:	4f2e      	ldr	r7, [pc, #184]	; (8021e60 <com_socket_ip_modem+0x32c>)
 8021da8:	4626      	mov	r6, r4
 8021daa:	f107 0c20 	add.w	ip, r7, #32
 8021dae:	463c      	mov	r4, r7
 8021db0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8021db2:	6030      	str	r0, [r6, #0]
 8021db4:	6071      	str	r1, [r6, #4]
 8021db6:	60b2      	str	r2, [r6, #8]
 8021db8:	60f3      	str	r3, [r6, #12]
 8021dba:	4627      	mov	r7, r4
 8021dbc:	3610      	adds	r6, #16
 8021dbe:	4564      	cmp	r4, ip
 8021dc0:	d1f5      	bne.n	8021dae <com_socket_ip_modem+0x27a>
 8021dc2:	6820      	ldr	r0, [r4, #0]
 8021dc4:	6030      	str	r0, [r6, #0]
 8021dc6:	4c21      	ldr	r4, [pc, #132]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021dc8:	4620      	mov	r0, r4
 8021dca:	f7fd faae 	bl	801f32a <crs_strlen>
 8021dce:	b283      	uxth	r3, r0
 8021dd0:	4622      	mov	r2, r4
 8021dd2:	2101      	movs	r1, #1
 8021dd4:	2003      	movs	r0, #3
 8021dd6:	f7fd faeb 	bl	801f3b0 <traceIF_itmPrint>
 8021dda:	4620      	mov	r0, r4
 8021ddc:	f7fd faa5 	bl	801f32a <crs_strlen>
 8021de0:	b283      	uxth	r3, r0
 8021de2:	4622      	mov	r2, r4
 8021de4:	2101      	movs	r1, #1
 8021de6:	2003      	movs	r0, #3
 8021de8:	f7fd fb04 	bl	801f3f4 <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_NOMEMORY;
 8021dec:	f06f 0604 	mvn.w	r6, #4
 8021df0:	e08f      	b.n	8021f12 <com_socket_ip_modem+0x3de>
          PRINT_ERR("close socket NOK low level")
 8021df2:	4e1d      	ldr	r6, [pc, #116]	; (8021e68 <com_socket_ip_modem+0x334>)
 8021df4:	4c15      	ldr	r4, [pc, #84]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021df6:	f106 0c20 	add.w	ip, r6, #32
 8021dfa:	4637      	mov	r7, r6
 8021dfc:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021dfe:	6020      	str	r0, [r4, #0]
 8021e00:	6061      	str	r1, [r4, #4]
 8021e02:	60a2      	str	r2, [r4, #8]
 8021e04:	60e3      	str	r3, [r4, #12]
 8021e06:	463e      	mov	r6, r7
 8021e08:	3410      	adds	r4, #16
 8021e0a:	4567      	cmp	r7, ip
 8021e0c:	d1f5      	bne.n	8021dfa <com_socket_ip_modem+0x2c6>
 8021e0e:	ce03      	ldmia	r6!, {r0, r1}
 8021e10:	6020      	str	r0, [r4, #0]
 8021e12:	6061      	str	r1, [r4, #4]
 8021e14:	8832      	ldrh	r2, [r6, #0]
 8021e16:	78b3      	ldrb	r3, [r6, #2]
 8021e18:	8122      	strh	r2, [r4, #8]
 8021e1a:	72a3      	strb	r3, [r4, #10]
 8021e1c:	4c0b      	ldr	r4, [pc, #44]	; (8021e4c <com_socket_ip_modem+0x318>)
 8021e1e:	4620      	mov	r0, r4
 8021e20:	f7fd fa83 	bl	801f32a <crs_strlen>
 8021e24:	b283      	uxth	r3, r0
 8021e26:	4622      	mov	r2, r4
 8021e28:	2110      	movs	r1, #16
 8021e2a:	2003      	movs	r0, #3
 8021e2c:	f7fd fac0 	bl	801f3b0 <traceIF_itmPrint>
 8021e30:	4620      	mov	r0, r4
 8021e32:	f7fd fa7a 	bl	801f32a <crs_strlen>
 8021e36:	b283      	uxth	r3, r0
 8021e38:	4622      	mov	r2, r4
 8021e3a:	2110      	movs	r1, #16
 8021e3c:	2003      	movs	r0, #3
 8021e3e:	f7fd fad9 	bl	801f3f4 <traceIF_uartPrint>
        result = COM_SOCKETS_ERR_NOMEMORY;
 8021e42:	f06f 0604 	mvn.w	r6, #4
 8021e46:	e064      	b.n	8021f12 <com_socket_ip_modem+0x3de>
 8021e48:	080369fc 	.word	0x080369fc
 8021e4c:	200049dc 	.word	0x200049dc
 8021e50:	080368d8 	.word	0x080368d8
 8021e54:	08020285 	.word	0x08020285
 8021e58:	08020481 	.word	0x08020481
 8021e5c:	0803699c 	.word	0x0803699c
 8021e60:	0803694c 	.word	0x0803694c
 8021e64:	08036920 	.word	0x08036920
 8021e68:	08036970 	.word	0x08036970
 8021e6c:	080368f8 	.word	0x080368f8
            PRINT_ERR("close socket NOK low level")
 8021e70:	4e2c      	ldr	r6, [pc, #176]	; (8021f24 <com_socket_ip_modem+0x3f0>)
 8021e72:	4c2d      	ldr	r4, [pc, #180]	; (8021f28 <com_socket_ip_modem+0x3f4>)
 8021e74:	f106 0c20 	add.w	ip, r6, #32
 8021e78:	4637      	mov	r7, r6
 8021e7a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021e7c:	6020      	str	r0, [r4, #0]
 8021e7e:	6061      	str	r1, [r4, #4]
 8021e80:	60a2      	str	r2, [r4, #8]
 8021e82:	60e3      	str	r3, [r4, #12]
 8021e84:	463e      	mov	r6, r7
 8021e86:	3410      	adds	r4, #16
 8021e88:	4567      	cmp	r7, ip
 8021e8a:	d1f5      	bne.n	8021e78 <com_socket_ip_modem+0x344>
 8021e8c:	ce03      	ldmia	r6!, {r0, r1}
 8021e8e:	6020      	str	r0, [r4, #0]
 8021e90:	6061      	str	r1, [r4, #4]
 8021e92:	8832      	ldrh	r2, [r6, #0]
 8021e94:	78b3      	ldrb	r3, [r6, #2]
 8021e96:	8122      	strh	r2, [r4, #8]
 8021e98:	72a3      	strb	r3, [r4, #10]
 8021e9a:	4c23      	ldr	r4, [pc, #140]	; (8021f28 <com_socket_ip_modem+0x3f4>)
 8021e9c:	4620      	mov	r0, r4
 8021e9e:	f7fd fa44 	bl	801f32a <crs_strlen>
 8021ea2:	b283      	uxth	r3, r0
 8021ea4:	4622      	mov	r2, r4
 8021ea6:	2110      	movs	r1, #16
 8021ea8:	2003      	movs	r0, #3
 8021eaa:	f7fd fa81 	bl	801f3b0 <traceIF_itmPrint>
 8021eae:	4620      	mov	r0, r4
 8021eb0:	f7fd fa3b 	bl	801f32a <crs_strlen>
 8021eb4:	b283      	uxth	r3, r0
 8021eb6:	4622      	mov	r2, r4
 8021eb8:	2110      	movs	r1, #16
 8021eba:	2003      	movs	r0, #3
 8021ebc:	f7fd fa9a 	bl	801f3f4 <traceIF_uartPrint>
    result = COM_SOCKETS_ERR_GENERAL;
 8021ec0:	f04f 36ff 	mov.w	r6, #4294967295
 8021ec4:	e025      	b.n	8021f12 <com_socket_ip_modem+0x3de>
      PRINT_ERR("create socket NOK low level")
 8021ec6:	4e19      	ldr	r6, [pc, #100]	; (8021f2c <com_socket_ip_modem+0x3f8>)
 8021ec8:	4c17      	ldr	r4, [pc, #92]	; (8021f28 <com_socket_ip_modem+0x3f4>)
 8021eca:	f106 0c20 	add.w	ip, r6, #32
 8021ece:	4637      	mov	r7, r6
 8021ed0:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8021ed2:	6020      	str	r0, [r4, #0]
 8021ed4:	6061      	str	r1, [r4, #4]
 8021ed6:	60a2      	str	r2, [r4, #8]
 8021ed8:	60e3      	str	r3, [r4, #12]
 8021eda:	463e      	mov	r6, r7
 8021edc:	3410      	adds	r4, #16
 8021ede:	4567      	cmp	r7, ip
 8021ee0:	d1f5      	bne.n	8021ece <com_socket_ip_modem+0x39a>
 8021ee2:	ce07      	ldmia	r6!, {r0, r1, r2}
 8021ee4:	6020      	str	r0, [r4, #0]
 8021ee6:	6061      	str	r1, [r4, #4]
 8021ee8:	60a2      	str	r2, [r4, #8]
 8021eea:	4c0f      	ldr	r4, [pc, #60]	; (8021f28 <com_socket_ip_modem+0x3f4>)
 8021eec:	4620      	mov	r0, r4
 8021eee:	f7fd fa1c 	bl	801f32a <crs_strlen>
 8021ef2:	b283      	uxth	r3, r0
 8021ef4:	4622      	mov	r2, r4
 8021ef6:	2110      	movs	r1, #16
 8021ef8:	2003      	movs	r0, #3
 8021efa:	f7fd fa59 	bl	801f3b0 <traceIF_itmPrint>
 8021efe:	4620      	mov	r0, r4
 8021f00:	f7fd fa13 	bl	801f32a <crs_strlen>
 8021f04:	b283      	uxth	r3, r0
 8021f06:	4622      	mov	r2, r4
 8021f08:	2110      	movs	r1, #16
 8021f0a:	2003      	movs	r0, #3
 8021f0c:	f7fd fa72 	bl	801f3f4 <traceIF_uartPrint>
    result = COM_SOCKETS_ERR_GENERAL;
 8021f10:	462e      	mov	r6, r5
    com_sockets_statistic_update((result == COM_SOCKETS_ERR_OK) ? \
 8021f12:	1e30      	subs	r0, r6, #0
 8021f14:	bf18      	it	ne
 8021f16:	2001      	movne	r0, #1
 8021f18:	f000 f858 	bl	8021fcc <com_sockets_statistic_update>
 8021f1c:	e642      	b.n	8021ba4 <com_socket_ip_modem+0x70>
    result = COM_SOCKETS_ERR_UNSUPPORTED;
 8021f1e:	f06f 060b 	mvn.w	r6, #11
 8021f22:	e61b      	b.n	8021b5c <com_socket_ip_modem+0x28>
 8021f24:	08036970 	.word	0x08036970
 8021f28:	200049dc 	.word	0x200049dc
 8021f2c:	080369d0 	.word	0x080369d0

08021f30 <com_init_ip_modem>:
  *         before using any other functions of com_*
  * @param  -
  * @retval bool      - true/false init ok/nok
  */
bool com_init_ip_modem(void)
{
 8021f30:	b508      	push	{r3, lr}
  bool result;

  result = false;

  /* Inititalize Network status */
  com_sockets_network_is_up = false; /* Network status update by Datacache see com_socket_datacache_cb() */
 8021f32:	2300      	movs	r3, #0
 8021f34:	4a0d      	ldr	r2, [pc, #52]	; (8021f6c <com_init_ip_modem+0x3c>)
 8021f36:	7013      	strb	r3, [r2, #0]

#if (USE_COM_PING == 1)
  ping_socket_id = COM_SOCKET_INVALID_ID;
#endif /* USE_COM_PING == 1 */

  for (uint8_t i = 0U; i < COM_SOCKET_LOCAL_ID_NB; i++)
 8021f38:	b163      	cbz	r3, 8021f54 <com_init_ip_modem+0x24>
  {
    socket_local_id[i] = false; /* set socket local id to unused */
  }

  /* Initialize Mutex to protect socket descriptor list access */
  ComSocketsMutexHandle = rtosalMutexNew(NULL);
 8021f3a:	2000      	movs	r0, #0
 8021f3c:	f7fd f905 	bl	801f14a <rtosalMutexNew>
 8021f40:	4b0b      	ldr	r3, [pc, #44]	; (8021f70 <com_init_ip_modem+0x40>)
 8021f42:	6018      	str	r0, [r3, #0]
  if (ComSocketsMutexHandle != NULL)
 8021f44:	b160      	cbz	r0, 8021f60 <com_init_ip_modem+0x30>
  {
    /* Create always the first element of the list */
    socket_desc_list = com_ip_modem_create_socket_desc();
 8021f46:	f7fe fbaa 	bl	802069e <com_ip_modem_create_socket_desc>
 8021f4a:	4b0a      	ldr	r3, [pc, #40]	; (8021f74 <com_init_ip_modem+0x44>)
 8021f4c:	6018      	str	r0, [r3, #0]
    if (socket_desc_list != NULL)
 8021f4e:	b140      	cbz	r0, 8021f62 <com_init_ip_modem+0x32>
    {
      result = true;
 8021f50:	2001      	movs	r0, #1
 8021f52:	e006      	b.n	8021f62 <com_init_ip_modem+0x32>
    socket_local_id[i] = false; /* set socket local id to unused */
 8021f54:	4a08      	ldr	r2, [pc, #32]	; (8021f78 <com_init_ip_modem+0x48>)
 8021f56:	2100      	movs	r1, #0
 8021f58:	54d1      	strb	r1, [r2, r3]
  for (uint8_t i = 0U; i < COM_SOCKET_LOCAL_ID_NB; i++)
 8021f5a:	3301      	adds	r3, #1
 8021f5c:	b2db      	uxtb	r3, r3
 8021f5e:	e7eb      	b.n	8021f38 <com_init_ip_modem+0x8>
  result = false;
 8021f60:	2000      	movs	r0, #0
  }
  com_nb_wake_up = 0U;
#endif /* USE_LOW_POWER == 1 */

#if (UDP_SERVICE_SUPPORTED == 1U)
  com_local_port = 0U; /* com_start_ip in charge to initialize it to a random value */
 8021f62:	4b06      	ldr	r3, [pc, #24]	; (8021f7c <com_init_ip_modem+0x4c>)
 8021f64:	2200      	movs	r2, #0
 8021f66:	801a      	strh	r2, [r3, #0]
#endif /* UDP_SERVICE_SUPPORTED == 1U */

  return result;
}
 8021f68:	bd08      	pop	{r3, pc}
 8021f6a:	bf00      	nop
 8021f6c:	200058a6 	.word	0x200058a6
 8021f70:	200058a0 	.word	0x200058a0
 8021f74:	200058a8 	.word	0x200058a8
 8021f78:	200058ac 	.word	0x200058ac
 8021f7c:	200058a4 	.word	0x200058a4

08021f80 <com_start_ip_modem>:
  *         and before using any other functions of com_*
  * @param  -
  * @retval -
  */
void com_start_ip_modem(void)
{
 8021f80:	b500      	push	{lr}
 8021f82:	b083      	sub	sp, #12
#if (USE_DATACACHE == 1)
  /* Datacache registration for netwok on/off status */
  (void)dc_com_register_gen_event_cb(&dc_com_db, com_socket_datacache_cb, (void *)NULL);
 8021f84:	2200      	movs	r2, #0
 8021f86:	490c      	ldr	r1, [pc, #48]	; (8021fb8 <com_start_ip_modem+0x38>)
 8021f88:	480c      	ldr	r0, [pc, #48]	; (8021fbc <com_start_ip_modem+0x3c>)
 8021f8a:	f000 f855 	bl	8022038 <dc_com_register_gen_event_cb>

#if (UDP_SERVICE_SUPPORTED == 1U)
  uint32_t random;

  /* Initialize local port to a random value */
  if (HAL_OK != HAL_RNG_GenerateRandomNumber(&hrng, &random))
 8021f8e:	a901      	add	r1, sp, #4
 8021f90:	480b      	ldr	r0, [pc, #44]	; (8021fc0 <com_start_ip_modem+0x40>)
 8021f92:	f7e7 fac8 	bl	8009526 <HAL_RNG_GenerateRandomNumber>
 8021f96:	b958      	cbnz	r0, 8021fb0 <com_start_ip_modem+0x30>
  {
    random = (uint32_t)rand();
  }
  random = random & ~COM_LOCAL_PORT_BEGIN;
 8021f98:	9b01      	ldr	r3, [sp, #4]
 8021f9a:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8021f9e:	9301      	str	r3, [sp, #4]
  random = random + COM_LOCAL_PORT_BEGIN;
 8021fa0:	f503 4340 	add.w	r3, r3, #49152	; 0xc000
 8021fa4:	9301      	str	r3, [sp, #4]
  com_local_port = (uint16_t)(random);
 8021fa6:	4a07      	ldr	r2, [pc, #28]	; (8021fc4 <com_start_ip_modem+0x44>)
 8021fa8:	8013      	strh	r3, [r2, #0]
#endif /* UDP_SERVICE_SUPPORTED == 1U */
}
 8021faa:	b003      	add	sp, #12
 8021fac:	f85d fb04 	ldr.w	pc, [sp], #4
    random = (uint32_t)rand();
 8021fb0:	f004 fb38 	bl	8026624 <rand>
 8021fb4:	9001      	str	r0, [sp, #4]
 8021fb6:	e7ef      	b.n	8021f98 <com_start_ip_modem+0x18>
 8021fb8:	08020aed 	.word	0x08020aed
 8021fbc:	200058b0 	.word	0x200058b0
 8021fc0:	20000a20 	.word	0x20000a20
 8021fc4:	200058a4 	.word	0x200058a4

08021fc8 <com_sockets_statistic_init>:
  * @retval -
  */
void com_sockets_statistic_init(void)
{
  /* Nothing to do */
  __NOP();
 8021fc8:	bf00      	nop
}
 8021fca:	4770      	bx	lr

08021fcc <com_sockets_statistic_update>:
  */
void com_sockets_statistic_update(com_sockets_stat_update_t stat)
{
  UNUSED(stat);
  /* Nothing to do */
}
 8021fcc:	4770      	bx	lr

08021fce <com_sockets_statistic_display>:
  * @retval -
  */
void com_sockets_statistic_display(void)
{
  /* Nothing to do */
}
 8021fce:	4770      	bx	lr

08021fd0 <dc_com_register_serv>:
  * @note                     this structure must be a persistent variable.
  * @param size             - size of p_data structure.
  * @retval dc_com_res_id_t - returns the identifier of the registered Data Cache entry
  */
dc_com_res_id_t dc_com_register_serv(dc_com_db_t *p_dc_db, void *p_data, uint16_t size)
{
 8021fd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  dc_com_res_id_t res_id;
  dc_base_rt_info_t *p_base_rt;

  if ((p_dc_db != NULL) &&
 8021fd4:	b340      	cbz	r0, 8022028 <dc_com_register_serv+0x58>
 8021fd6:	460e      	mov	r6, r1
 8021fd8:	4614      	mov	r4, r2
 8021fda:	4607      	mov	r7, r0
      (p_dc_db->serv_number < DC_COM_ENTRY_MAX_NB) &&
 8021fdc:	8843      	ldrh	r3, [r0, #2]
  if ((p_dc_db != NULL) &&
 8021fde:	2b13      	cmp	r3, #19
 8021fe0:	d824      	bhi.n	802202c <dc_com_register_serv+0x5c>
      (p_dc_db->serv_number < DC_COM_ENTRY_MAX_NB) &&
 8021fe2:	2a0b      	cmp	r2, #11
 8021fe4:	d801      	bhi.n	8021fea <dc_com_register_serv+0x1a>
    p_dc_db->serv_number++;
    (void)rtosalMutexRelease(dc_common_mutex);
  }
  else
  {
    res_id = DC_COM_INVALID_ENTRY;
 8021fe6:	25ff      	movs	r5, #255	; 0xff
 8021fe8:	e021      	b.n	802202e <dc_com_register_serv+0x5e>
    (void)rtosalMutexAcquire(dc_common_mutex, RTOSAL_WAIT_FOREVER);
 8021fea:	f8df 8048 	ldr.w	r8, [pc, #72]	; 8022034 <dc_com_register_serv+0x64>
 8021fee:	f04f 31ff 	mov.w	r1, #4294967295
 8021ff2:	f8d8 0000 	ldr.w	r0, [r8]
 8021ff6:	f7fd f8b2 	bl	801f15e <rtosalMutexAcquire>
    res_id = p_dc_db->serv_number;
 8021ffa:	887d      	ldrh	r5, [r7, #2]
    p_dc_db->p_dc_db[res_id]   = p_data;
 8021ffc:	f105 031e 	add.w	r3, r5, #30
 8022000:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8022004:	605e      	str	r6, [r3, #4]
    p_dc_db->dc_db_len[res_id] = size;
 8022006:	f105 0364 	add.w	r3, r5, #100	; 0x64
 802200a:	eb07 0343 	add.w	r3, r7, r3, lsl #1
 802200e:	809c      	strh	r4, [r3, #4]
    p_base_rt->header.res_id = res_id;
 8022010:	8035      	strh	r5, [r6, #0]
    p_base_rt->header.size   = size;
 8022012:	6074      	str	r4, [r6, #4]
    p_base_rt->rt_state      = DC_SERVICE_OFF;
 8022014:	2303      	movs	r3, #3
 8022016:	7233      	strb	r3, [r6, #8]
    p_dc_db->serv_number++;
 8022018:	887b      	ldrh	r3, [r7, #2]
 802201a:	3301      	adds	r3, #1
 802201c:	807b      	strh	r3, [r7, #2]
    (void)rtosalMutexRelease(dc_common_mutex);
 802201e:	f8d8 0000 	ldr.w	r0, [r8]
 8022022:	f7fd f8a0 	bl	801f166 <rtosalMutexRelease>
 8022026:	e002      	b.n	802202e <dc_com_register_serv+0x5e>
    res_id = DC_COM_INVALID_ENTRY;
 8022028:	25ff      	movs	r5, #255	; 0xff
 802202a:	e000      	b.n	802202e <dc_com_register_serv+0x5e>
 802202c:	25ff      	movs	r5, #255	; 0xff
  }

  return res_id;
}
 802202e:	4628      	mov	r0, r5
 8022030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8022034:	200059a4 	.word	0x200059a4

08022038 <dc_com_register_gen_event_cb>:
  *                           DC_COM_INVALID_ENTRY in case of error
  */
dc_com_reg_id_t dc_com_register_gen_event_cb(dc_com_db_t *p_dc_db,
                                             dc_com_gen_event_callback_t notif_cb,
                                             const void *p_private_data)
{
 8022038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  dc_com_reg_id_t consumer_id;

  if ((p_dc_db != NULL) && (notif_cb != NULL)  && (p_dc_db->consumer_number < DC_COM_MAX_NB_SUBSCRIBER))
 802203c:	b328      	cbz	r0, 802208a <dc_com_register_gen_event_cb+0x52>
 802203e:	460c      	mov	r4, r1
 8022040:	4617      	mov	r7, r2
 8022042:	4606      	mov	r6, r0
 8022044:	b319      	cbz	r1, 802208e <dc_com_register_gen_event_cb+0x56>
 8022046:	7803      	ldrb	r3, [r0, #0]
 8022048:	2b09      	cmp	r3, #9
 802204a:	d903      	bls.n	8022054 <dc_com_register_gen_event_cb+0x1c>
    p_dc_db->consumer_number++;
    (void)rtosalMutexRelease(dc_common_mutex);
  }
  else
  {
    consumer_id = DC_COM_INVALID_ENTRY;
 802204c:	25ff      	movs	r5, #255	; 0xff
  }

  return consumer_id;
}
 802204e:	4628      	mov	r0, r5
 8022050:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (void)rtosalMutexAcquire(dc_common_mutex, RTOSAL_WAIT_FOREVER);
 8022054:	f8df 803c 	ldr.w	r8, [pc, #60]	; 8022094 <dc_com_register_gen_event_cb+0x5c>
 8022058:	f04f 31ff 	mov.w	r1, #4294967295
 802205c:	f8d8 0000 	ldr.w	r0, [r8]
 8022060:	f7fd f87d 	bl	801f15e <rtosalMutexAcquire>
    consumer_id = p_dc_db->consumer_number;
 8022064:	7835      	ldrb	r5, [r6, #0]
    p_dc_db->consumer_info[consumer_id].consumer_reg_id       = consumer_id;
 8022066:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 802206a:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 802206e:	711d      	strb	r5, [r3, #4]
    p_dc_db->consumer_info[consumer_id].notif_cb          = notif_cb;
 8022070:	609c      	str	r4, [r3, #8]
    p_dc_db->consumer_info[consumer_id].private_consumer_data = p_private_data;
 8022072:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8022076:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 802207a:	60df      	str	r7, [r3, #12]
    p_dc_db->consumer_number++;
 802207c:	1c6b      	adds	r3, r5, #1
 802207e:	7033      	strb	r3, [r6, #0]
    (void)rtosalMutexRelease(dc_common_mutex);
 8022080:	f8d8 0000 	ldr.w	r0, [r8]
 8022084:	f7fd f86f 	bl	801f166 <rtosalMutexRelease>
 8022088:	e7e1      	b.n	802204e <dc_com_register_gen_event_cb+0x16>
    consumer_id = DC_COM_INVALID_ENTRY;
 802208a:	25ff      	movs	r5, #255	; 0xff
 802208c:	e7df      	b.n	802204e <dc_com_register_gen_event_cb+0x16>
 802208e:	25ff      	movs	r5, #255	; 0xff
 8022090:	e7dd      	b.n	802204e <dc_com_register_gen_event_cb+0x16>
 8022092:	bf00      	nop
 8022094:	200059a4 	.word	0x200059a4

08022098 <dc_com_write>:
  dc_com_reg_id_t reg_id;
  dc_base_rt_info_t *dc_base_rt_info;
  dc_com_status_t res;
  const dc_com_db_t *com_db = (dc_com_db_t *)p_dc;

  if ((p_dc != NULL) && (res_id < com_db->serv_number) && (com_db->dc_db_len[res_id] >= len))
 8022098:	2800      	cmp	r0, #0
 802209a:	d041      	beq.n	8022120 <dc_com_write+0x88>
{
 802209c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80220a0:	460d      	mov	r5, r1
 80220a2:	4617      	mov	r7, r2
 80220a4:	461c      	mov	r4, r3
 80220a6:	4606      	mov	r6, r0
  if ((p_dc != NULL) && (res_id < com_db->serv_number) && (com_db->dc_db_len[res_id] >= len))
 80220a8:	8843      	ldrh	r3, [r0, #2]
 80220aa:	428b      	cmp	r3, r1
 80220ac:	d93a      	bls.n	8022124 <dc_com_write+0x8c>
 80220ae:	f101 0364 	add.w	r3, r1, #100	; 0x64
 80220b2:	eb00 0343 	add.w	r3, r0, r3, lsl #1
 80220b6:	889b      	ldrh	r3, [r3, #4]
 80220b8:	42a3      	cmp	r3, r4
 80220ba:	d201      	bcs.n	80220c0 <dc_com_write+0x28>
    (void)rtosalMutexRelease(dc_common_mutex);
    res = DC_COM_OK;
  }
  else
  {
    res = DC_COM_ERROR;
 80220bc:	2000      	movs	r0, #0
 80220be:	e032      	b.n	8022126 <dc_com_write+0x8e>
    (void)rtosalMutexAcquire(dc_common_mutex, RTOSAL_WAIT_FOREVER);
 80220c0:	f04f 31ff 	mov.w	r1, #4294967295
 80220c4:	4b19      	ldr	r3, [pc, #100]	; (802212c <dc_com_write+0x94>)
 80220c6:	6818      	ldr	r0, [r3, #0]
 80220c8:	f7fd f849 	bl	801f15e <rtosalMutexAcquire>
    (void)memcpy((void *)(com_db->p_dc_db[res_id]), p_data, (uint32_t)len);
 80220cc:	f105 081e 	add.w	r8, r5, #30
 80220d0:	eb06 0888 	add.w	r8, r6, r8, lsl #2
 80220d4:	4622      	mov	r2, r4
 80220d6:	4639      	mov	r1, r7
 80220d8:	f8d8 0004 	ldr.w	r0, [r8, #4]
 80220dc:	f004 fd04 	bl	8026ae8 <memcpy>
    dc_base_rt_info = (dc_base_rt_info_t *)(com_db->p_dc_db[res_id]);
 80220e0:	f8d8 3004 	ldr.w	r3, [r8, #4]
    dc_base_rt_info->header.res_id = res_id;
 80220e4:	801d      	strh	r5, [r3, #0]
    dc_base_rt_info->header.size   = len;
 80220e6:	605c      	str	r4, [r3, #4]
    for (reg_id = 0U; reg_id < p_dc->consumer_number; reg_id++)
 80220e8:	2400      	movs	r4, #0
 80220ea:	e001      	b.n	80220f0 <dc_com_write+0x58>
 80220ec:	3401      	adds	r4, #1
 80220ee:	b2e4      	uxtb	r4, r4
 80220f0:	7833      	ldrb	r3, [r6, #0]
 80220f2:	42a3      	cmp	r3, r4
 80220f4:	d90e      	bls.n	8022114 <dc_com_write+0x7c>
      if (consumer_info->notif_cb != NULL)
 80220f6:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 80220fa:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 80220fe:	689a      	ldr	r2, [r3, #8]
 8022100:	2a00      	cmp	r2, #0
 8022102:	d0f3      	beq.n	80220ec <dc_com_write+0x54>
        consumer_info->notif_cb((dc_com_event_id_t)res_id, consumer_info->private_consumer_data);
 8022104:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 8022108:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 802210c:	68d9      	ldr	r1, [r3, #12]
 802210e:	b2e8      	uxtb	r0, r5
 8022110:	4790      	blx	r2
 8022112:	e7eb      	b.n	80220ec <dc_com_write+0x54>
    (void)rtosalMutexRelease(dc_common_mutex);
 8022114:	4b05      	ldr	r3, [pc, #20]	; (802212c <dc_com_write+0x94>)
 8022116:	6818      	ldr	r0, [r3, #0]
 8022118:	f7fd f825 	bl	801f166 <rtosalMutexRelease>
    res = DC_COM_OK;
 802211c:	2001      	movs	r0, #1
 802211e:	e002      	b.n	8022126 <dc_com_write+0x8e>
    res = DC_COM_ERROR;
 8022120:	2000      	movs	r0, #0
  }

  return res;
}
 8022122:	4770      	bx	lr
    res = DC_COM_ERROR;
 8022124:	2000      	movs	r0, #0
}
 8022126:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802212a:	bf00      	nop
 802212c:	200059a4 	.word	0x200059a4

08022130 <dc_com_read>:
  * @param  p_data          - data to read
  * @param  len             - length of p_data to read
  * @retval dc_com_status_t - return status with DC_COM_OK or DC_COM_ERROR
  */
dc_com_status_t dc_com_read(dc_com_db_t *p_dc, dc_com_res_id_t res_id, void *p_data, uint32_t len)
{
 8022130:	b510      	push	{r4, lr}
 8022132:	4604      	mov	r4, r0
 8022134:	4610      	mov	r0, r2
 8022136:	461a      	mov	r2, r3
  dc_com_status_t res;

  if ((p_dc != NULL) && (res_id < p_dc->serv_number) && (p_dc->dc_db_len[res_id] >= len))
 8022138:	b154      	cbz	r4, 8022150 <dc_com_read+0x20>
 802213a:	4623      	mov	r3, r4
 802213c:	8864      	ldrh	r4, [r4, #2]
 802213e:	428c      	cmp	r4, r1
 8022140:	d906      	bls.n	8022150 <dc_com_read+0x20>
 8022142:	f101 0464 	add.w	r4, r1, #100	; 0x64
 8022146:	eb03 0444 	add.w	r4, r3, r4, lsl #1
 802214a:	88a4      	ldrh	r4, [r4, #4]
 802214c:	4294      	cmp	r4, r2
 802214e:	d204      	bcs.n	802215a <dc_com_read+0x2a>
    (void)memcpy(p_data, (void *)p_dc->p_dc_db[res_id], (uint32_t)len);
    res = DC_COM_OK;
  }
  else
  {
    (void)memset(p_data, 0, (uint32_t)len); /* p_data->rt_state == 0 is DC_SERVICE_UNAVAIL */
 8022150:	2100      	movs	r1, #0
 8022152:	f004 fbec 	bl	802692e <memset>
    res = DC_COM_ERROR;
 8022156:	2000      	movs	r0, #0
  }
  return res;
}
 8022158:	bd10      	pop	{r4, pc}
    (void)memcpy(p_data, (void *)p_dc->p_dc_db[res_id], (uint32_t)len);
 802215a:	311e      	adds	r1, #30
 802215c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8022160:	6859      	ldr	r1, [r3, #4]
 8022162:	f004 fcc1 	bl	8026ae8 <memcpy>
    res = DC_COM_OK;
 8022166:	2001      	movs	r0, #1
 8022168:	e7f6      	b.n	8022158 <dc_com_read+0x28>
	...

0802216c <dc_com_init>:
  * @brief  Initialize the Data Cache module.
  * @param  p_dc - data base reference (Must be set to &dc_com_db)
  * @retval -
  */
void dc_com_init(dc_com_db_t *p_dc)
{
 802216c:	b508      	push	{r3, lr}
  (void)memset(p_dc, 0, sizeof(dc_com_db_t));
 802216e:	22f4      	movs	r2, #244	; 0xf4
 8022170:	2100      	movs	r1, #0
 8022172:	f004 fbdc 	bl	802692e <memset>

  dc_common_mutex = rtosalMutexNew(NULL);
 8022176:	2000      	movs	r0, #0
 8022178:	f7fc ffe7 	bl	801f14a <rtosalMutexNew>
 802217c:	4b04      	ldr	r3, [pc, #16]	; (8022190 <dc_com_init+0x24>)
 802217e:	6018      	str	r0, [r3, #0]
  if (dc_common_mutex == NULL)
 8022180:	b100      	cbz	r0, 8022184 <dc_com_init+0x18>
  {
    ERROR_Handler(DBG_CHAN_DATA_CACHE, 1, ERROR_FATAL);
  }
}
 8022182:	bd08      	pop	{r3, pc}
    ERROR_Handler(DBG_CHAN_DATA_CACHE, 1, ERROR_FATAL);
 8022184:	2203      	movs	r2, #3
 8022186:	2101      	movs	r1, #1
 8022188:	2009      	movs	r0, #9
 802218a:	f7fc f8eb 	bl	801e364 <ERROR_Handler>
}
 802218e:	e7f8      	b.n	8022182 <dc_com_init+0x16>
 8022190:	200059a4 	.word	0x200059a4

08022194 <dc_com_start>:
  */
void dc_com_start(dc_com_db_t *p_dc)
{
  UNUSED(p_dc);
  /* Nothing to do */
  __NOP();
 8022194:	bf00      	nop
}
 8022196:	4770      	bx	lr

08022198 <CMD_GetLine>:
  * @brief board reset command management
  * @param  p_Cmd_p command (not used because not parameter for this command)
  * @retval -
  */
static void CMD_GetLine(uint8_t *command_line, uint32_t max_size)
{
 8022198:	b538      	push	{r3, r4, r5, lr}
 802219a:	4605      	mov	r5, r0
 802219c:	460c      	mov	r4, r1
  uint32_t size;
  (void)rtosalSemaphoreAcquire(CMD_rcvSemaphore, RTOSAL_WAIT_FOREVER);
 802219e:	f04f 31ff 	mov.w	r1, #4294967295
 80221a2:	4b09      	ldr	r3, [pc, #36]	; (80221c8 <CMD_GetLine+0x30>)
 80221a4:	6818      	ldr	r0, [r3, #0]
 80221a6:	f7fc ffc8 	bl	801f13a <rtosalSemaphoreAcquire>

  size = crs_strlen(CMD_current_cmd) + 1U;
 80221aa:	4b08      	ldr	r3, [pc, #32]	; (80221cc <CMD_GetLine+0x34>)
 80221ac:	6818      	ldr	r0, [r3, #0]
 80221ae:	f7fd f8bc 	bl	801f32a <crs_strlen>
 80221b2:	1c43      	adds	r3, r0, #1
  if (max_size < size)
 80221b4:	42a3      	cmp	r3, r4
 80221b6:	d800      	bhi.n	80221ba <CMD_GetLine+0x22>
  size = crs_strlen(CMD_current_cmd) + 1U;
 80221b8:	461c      	mov	r4, r3
  {
    size = max_size;
  }

  (void)memcpy((CRC_CHAR_t *)command_line, (CRC_CHAR_t *)CMD_current_cmd, size);
 80221ba:	4622      	mov	r2, r4
 80221bc:	4b03      	ldr	r3, [pc, #12]	; (80221cc <CMD_GetLine+0x34>)
 80221be:	6819      	ldr	r1, [r3, #0]
 80221c0:	4628      	mov	r0, r5
 80221c2:	f004 fc91 	bl	8026ae8 <memcpy>
}
 80221c6:	bd38      	pop	{r3, r4, r5, pc}
 80221c8:	20005c08 	.word	0x20005c08
 80221cc:	20005c00 	.word	0x20005c00

080221d0 <CMD_BoardReset>:
  * @brief board reset command management
  * @param  p_Cmd_p command (not used because not parameter for this command)
  * @retval -
  */
static void CMD_BoardReset(uint8_t *p_Cmd_p)
{
 80221d0:	b508      	push	{r3, lr}
  UNUSED(p_Cmd_p);
  PRINT_FORCE("Board reset requested !\r\n");
 80221d2:	4c17      	ldr	r4, [pc, #92]	; (8022230 <CMD_BoardReset+0x60>)
 80221d4:	4d17      	ldr	r5, [pc, #92]	; (8022234 <CMD_BoardReset+0x64>)
 80221d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80221d8:	6020      	str	r0, [r4, #0]
 80221da:	6061      	str	r1, [r4, #4]
 80221dc:	60a2      	str	r2, [r4, #8]
 80221de:	60e3      	str	r3, [r4, #12]
 80221e0:	cd03      	ldmia	r5!, {r0, r1}
 80221e2:	6120      	str	r0, [r4, #16]
 80221e4:	6161      	str	r1, [r4, #20]
 80221e6:	882b      	ldrh	r3, [r5, #0]
 80221e8:	8323      	strh	r3, [r4, #24]
 80221ea:	4620      	mov	r0, r4
 80221ec:	f7fd f89d 	bl	801f32a <crs_strlen>
 80221f0:	b283      	uxth	r3, r0
 80221f2:	4622      	mov	r2, r4
 80221f4:	2101      	movs	r1, #1
 80221f6:	200a      	movs	r0, #10
 80221f8:	f7fd f8da 	bl	801f3b0 <traceIF_itmPrint>
 80221fc:	4620      	mov	r0, r4
 80221fe:	f7fd f894 	bl	801f32a <crs_strlen>
 8022202:	b282      	uxth	r2, r0
 8022204:	4621      	mov	r1, r4
 8022206:	200a      	movs	r0, #10
 8022208:	f7fd f90c 	bl	801f424 <traceIF_uartPrintForce>
  (void)rtosalDelay(1000);
 802220c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8022210:	f7fc ffe3 	bl	801f1da <rtosalDelay>
 8022214:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8022218:	4907      	ldr	r1, [pc, #28]	; (8022238 <CMD_BoardReset+0x68>)
 802221a:	68ca      	ldr	r2, [r1, #12]
 802221c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 8022220:	4b06      	ldr	r3, [pc, #24]	; (802223c <CMD_BoardReset+0x6c>)
 8022222:	4313      	orrs	r3, r2
 8022224:	60cb      	str	r3, [r1, #12]
 8022226:	f3bf 8f4f 	dsb	sy
    __NOP();
 802222a:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 802222c:	e7fd      	b.n	802222a <CMD_BoardReset+0x5a>
 802222e:	bf00      	nop
 8022230:	200050dc 	.word	0x200050dc
 8022234:	08036a2c 	.word	0x08036a2c
 8022238:	e000ed00 	.word	0xe000ed00
 802223c:	05fa0004 	.word	0x05fa0004

08022240 <CMD_Help>:
  * @note  display all recorded component (component command header and description)
  * @param  -
  * @retval return value
  */
static cmd_status_t CMD_Help(uint8_t *p_Cmd_p)
{
 8022240:	b570      	push	{r4, r5, r6, lr}
 8022242:	b086      	sub	sp, #24
  UNUSED(p_Cmd_p);
  uint32_t i;
  uint32_t align_offset;
  uint32_t cmd_size;
  PRINT_FORCE("***** help *****\r\n");
 8022244:	4c48      	ldr	r4, [pc, #288]	; (8022368 <CMD_Help+0x128>)
 8022246:	4d49      	ldr	r5, [pc, #292]	; (802236c <CMD_Help+0x12c>)
 8022248:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802224a:	6020      	str	r0, [r4, #0]
 802224c:	6061      	str	r1, [r4, #4]
 802224e:	60a2      	str	r2, [r4, #8]
 8022250:	60e3      	str	r3, [r4, #12]
 8022252:	882a      	ldrh	r2, [r5, #0]
 8022254:	78ab      	ldrb	r3, [r5, #2]
 8022256:	8222      	strh	r2, [r4, #16]
 8022258:	74a3      	strb	r3, [r4, #18]
 802225a:	4620      	mov	r0, r4
 802225c:	f7fd f865 	bl	801f32a <crs_strlen>
 8022260:	b283      	uxth	r3, r0
 8022262:	4622      	mov	r2, r4
 8022264:	2101      	movs	r1, #1
 8022266:	200a      	movs	r0, #10
 8022268:	f7fd f8a2 	bl	801f3b0 <traceIF_itmPrint>
 802226c:	4620      	mov	r0, r4
 802226e:	f7fd f85c 	bl	801f32a <crs_strlen>
 8022272:	b282      	uxth	r2, r0
 8022274:	4621      	mov	r1, r4
 8022276:	200a      	movs	r0, #10
 8022278:	f7fd f8d4 	bl	801f424 <traceIF_uartPrintForce>

  PRINT_FORCE("\r\nList of commands\r\n")
 802227c:	4d3c      	ldr	r5, [pc, #240]	; (8022370 <CMD_Help+0x130>)
 802227e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022280:	6020      	str	r0, [r4, #0]
 8022282:	6061      	str	r1, [r4, #4]
 8022284:	60a2      	str	r2, [r4, #8]
 8022286:	60e3      	str	r3, [r4, #12]
 8022288:	6828      	ldr	r0, [r5, #0]
 802228a:	6120      	str	r0, [r4, #16]
 802228c:	792b      	ldrb	r3, [r5, #4]
 802228e:	7523      	strb	r3, [r4, #20]
 8022290:	4620      	mov	r0, r4
 8022292:	f7fd f84a 	bl	801f32a <crs_strlen>
 8022296:	b283      	uxth	r3, r0
 8022298:	4622      	mov	r2, r4
 802229a:	2101      	movs	r1, #1
 802229c:	200a      	movs	r0, #10
 802229e:	f7fd f887 	bl	801f3b0 <traceIF_itmPrint>
 80222a2:	4620      	mov	r0, r4
 80222a4:	f7fd f841 	bl	801f32a <crs_strlen>
 80222a8:	b282      	uxth	r2, r0
 80222aa:	4621      	mov	r1, r4
 80222ac:	200a      	movs	r0, #10
 80222ae:	f7fd f8b9 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("----------------\r\n")
 80222b2:	4d30      	ldr	r5, [pc, #192]	; (8022374 <CMD_Help+0x134>)
 80222b4:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80222b6:	6020      	str	r0, [r4, #0]
 80222b8:	6061      	str	r1, [r4, #4]
 80222ba:	60a2      	str	r2, [r4, #8]
 80222bc:	60e3      	str	r3, [r4, #12]
 80222be:	882a      	ldrh	r2, [r5, #0]
 80222c0:	78ab      	ldrb	r3, [r5, #2]
 80222c2:	8222      	strh	r2, [r4, #16]
 80222c4:	74a3      	strb	r3, [r4, #18]
 80222c6:	4620      	mov	r0, r4
 80222c8:	f7fd f82f 	bl	801f32a <crs_strlen>
 80222cc:	b283      	uxth	r3, r0
 80222ce:	4622      	mov	r2, r4
 80222d0:	2101      	movs	r1, #1
 80222d2:	200a      	movs	r0, #10
 80222d4:	f7fd f86c 	bl	801f3b0 <traceIF_itmPrint>
 80222d8:	4620      	mov	r0, r4
 80222da:	f7fd f826 	bl	801f32a <crs_strlen>
 80222de:	b282      	uxth	r2, r0
 80222e0:	4621      	mov	r1, r4
 80222e2:	200a      	movs	r0, #10
 80222e4:	f7fd f89e 	bl	801f424 <traceIF_uartPrintForce>
  uint8_t   CMD_CmdAlignOffsetString[CMD_COMMAND_ALIGN_COLUMN];

  /* display registered commands  */
  for (i = 0U; i < CMD_NbCmd ; i++)
 80222e8:	2400      	movs	r4, #0
 80222ea:	e020      	b.n	802232e <CMD_Help+0xee>
    {
      /* alignment of the component descriptions */
      (void)memset(CMD_CmdAlignOffsetString, (int32_t)' ', align_offset);
      CMD_CmdAlignOffsetString[align_offset] = 0U;
    }
    PRINT_FORCE("%s%s %s\r\n", CMD_a_cmd_list[i].CmdName, CMD_CmdAlignOffsetString, CMD_a_cmd_list[i].CmdLabel);
 80222ec:	4a22      	ldr	r2, [pc, #136]	; (8022378 <CMD_Help+0x138>)
 80222ee:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 80222f2:	eb02 0381 	add.w	r3, r2, r1, lsl #2
 80222f6:	4d1c      	ldr	r5, [pc, #112]	; (8022368 <CMD_Help+0x128>)
 80222f8:	685b      	ldr	r3, [r3, #4]
 80222fa:	9300      	str	r3, [sp, #0]
 80222fc:	ab02      	add	r3, sp, #8
 80222fe:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 8022302:	491e      	ldr	r1, [pc, #120]	; (802237c <CMD_Help+0x13c>)
 8022304:	4628      	mov	r0, r5
 8022306:	f004 fa9f 	bl	8026848 <sprintf>
 802230a:	4628      	mov	r0, r5
 802230c:	f7fd f80d 	bl	801f32a <crs_strlen>
 8022310:	b283      	uxth	r3, r0
 8022312:	462a      	mov	r2, r5
 8022314:	2101      	movs	r1, #1
 8022316:	200a      	movs	r0, #10
 8022318:	f7fd f84a 	bl	801f3b0 <traceIF_itmPrint>
 802231c:	4628      	mov	r0, r5
 802231e:	f7fd f804 	bl	801f32a <crs_strlen>
 8022322:	b282      	uxth	r2, r0
 8022324:	4629      	mov	r1, r5
 8022326:	200a      	movs	r0, #10
 8022328:	f7fd f87c 	bl	801f424 <traceIF_uartPrintForce>
  for (i = 0U; i < CMD_NbCmd ; i++)
 802232c:	3401      	adds	r4, #1
 802232e:	4b14      	ldr	r3, [pc, #80]	; (8022380 <CMD_Help+0x140>)
 8022330:	681b      	ldr	r3, [r3, #0]
 8022332:	42a3      	cmp	r3, r4
 8022334:	d926      	bls.n	8022384 <CMD_Help+0x144>
    cmd_size = (uint32_t)crs_strlen(CMD_a_cmd_list[i].CmdName);
 8022336:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 802233a:	4a0f      	ldr	r2, [pc, #60]	; (8022378 <CMD_Help+0x138>)
 802233c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8022340:	f7fc fff3 	bl	801f32a <crs_strlen>
    align_offset = CMD_COMMAND_ALIGN_COLUMN - cmd_size;
 8022344:	f1c0 0510 	rsb	r5, r0, #16
    if ((align_offset < CMD_COMMAND_ALIGN_COLUMN))
 8022348:	2d0f      	cmp	r5, #15
 802234a:	d8cf      	bhi.n	80222ec <CMD_Help+0xac>
      (void)memset(CMD_CmdAlignOffsetString, (int32_t)' ', align_offset);
 802234c:	462a      	mov	r2, r5
 802234e:	2120      	movs	r1, #32
 8022350:	a802      	add	r0, sp, #8
 8022352:	f004 faec 	bl	802692e <memset>
      CMD_CmdAlignOffsetString[align_offset] = 0U;
 8022356:	f105 0318 	add.w	r3, r5, #24
 802235a:	eb0d 0503 	add.w	r5, sp, r3
 802235e:	2300      	movs	r3, #0
 8022360:	f805 3c10 	strb.w	r3, [r5, #-16]
 8022364:	e7c2      	b.n	80222ec <CMD_Help+0xac>
 8022366:	bf00      	nop
 8022368:	200050dc 	.word	0x200050dc
 802236c:	08036a48 	.word	0x08036a48
 8022370:	08036a5c 	.word	0x08036a5c
 8022374:	08036a74 	.word	0x08036a74
 8022378:	20005ae8 	.word	0x20005ae8
 802237c:	08036a88 	.word	0x08036a88
 8022380:	20005adc 	.word	0x20005adc
  }

  /* display general syntax of the commands */
  PRINT_FORCE("\r\nHelp syntax\r\n");
 8022384:	4ccb      	ldr	r4, [pc, #812]	; (80226b4 <CMD_Help+0x474>)
 8022386:	4dcc      	ldr	r5, [pc, #816]	; (80226b8 <CMD_Help+0x478>)
 8022388:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802238a:	6020      	str	r0, [r4, #0]
 802238c:	6061      	str	r1, [r4, #4]
 802238e:	60a2      	str	r2, [r4, #8]
 8022390:	60e3      	str	r3, [r4, #12]
 8022392:	4620      	mov	r0, r4
 8022394:	f7fc ffc9 	bl	801f32a <crs_strlen>
 8022398:	b283      	uxth	r3, r0
 802239a:	4622      	mov	r2, r4
 802239c:	2101      	movs	r1, #1
 802239e:	200a      	movs	r0, #10
 80223a0:	f7fd f806 	bl	801f3b0 <traceIF_itmPrint>
 80223a4:	4620      	mov	r0, r4
 80223a6:	f7fc ffc0 	bl	801f32a <crs_strlen>
 80223aa:	b282      	uxth	r2, r0
 80223ac:	4621      	mov	r1, r4
 80223ae:	200a      	movs	r0, #10
 80223b0:	f7fd f838 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("-----------\r\n");
 80223b4:	4bc1      	ldr	r3, [pc, #772]	; (80226bc <CMD_Help+0x47c>)
 80223b6:	cb07      	ldmia	r3!, {r0, r1, r2}
 80223b8:	6020      	str	r0, [r4, #0]
 80223ba:	6061      	str	r1, [r4, #4]
 80223bc:	60a2      	str	r2, [r4, #8]
 80223be:	881b      	ldrh	r3, [r3, #0]
 80223c0:	81a3      	strh	r3, [r4, #12]
 80223c2:	4620      	mov	r0, r4
 80223c4:	f7fc ffb1 	bl	801f32a <crs_strlen>
 80223c8:	b283      	uxth	r3, r0
 80223ca:	4622      	mov	r2, r4
 80223cc:	2101      	movs	r1, #1
 80223ce:	200a      	movs	r0, #10
 80223d0:	f7fc ffee 	bl	801f3b0 <traceIF_itmPrint>
 80223d4:	4620      	mov	r0, r4
 80223d6:	f7fc ffa8 	bl	801f32a <crs_strlen>
 80223da:	b282      	uxth	r2, r0
 80223dc:	4621      	mov	r1, r4
 80223de:	200a      	movs	r0, #10
 80223e0:	f7fd f820 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("warning: case sensitive commands\r\n");
 80223e4:	4eb6      	ldr	r6, [pc, #728]	; (80226c0 <CMD_Help+0x480>)
 80223e6:	f106 0c20 	add.w	ip, r6, #32
 80223ea:	4635      	mov	r5, r6
 80223ec:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80223ee:	6020      	str	r0, [r4, #0]
 80223f0:	6061      	str	r1, [r4, #4]
 80223f2:	60a2      	str	r2, [r4, #8]
 80223f4:	60e3      	str	r3, [r4, #12]
 80223f6:	462e      	mov	r6, r5
 80223f8:	3410      	adds	r4, #16
 80223fa:	4565      	cmp	r5, ip
 80223fc:	d1f5      	bne.n	80223ea <CMD_Help+0x1aa>
 80223fe:	882a      	ldrh	r2, [r5, #0]
 8022400:	78ab      	ldrb	r3, [r5, #2]
 8022402:	8022      	strh	r2, [r4, #0]
 8022404:	70a3      	strb	r3, [r4, #2]
 8022406:	4cab      	ldr	r4, [pc, #684]	; (80226b4 <CMD_Help+0x474>)
 8022408:	4620      	mov	r0, r4
 802240a:	f7fc ff8e 	bl	801f32a <crs_strlen>
 802240e:	b283      	uxth	r3, r0
 8022410:	4622      	mov	r2, r4
 8022412:	2101      	movs	r1, #1
 8022414:	200a      	movs	r0, #10
 8022416:	f7fc ffcb 	bl	801f3b0 <traceIF_itmPrint>
 802241a:	4620      	mov	r0, r4
 802241c:	f7fc ff85 	bl	801f32a <crs_strlen>
 8022420:	b282      	uxth	r2, r0
 8022422:	4621      	mov	r1, r4
 8022424:	200a      	movs	r0, #10
 8022426:	f7fc fffd 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("[optional parameter]\r\n");
 802242a:	4da6      	ldr	r5, [pc, #664]	; (80226c4 <CMD_Help+0x484>)
 802242c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802242e:	6020      	str	r0, [r4, #0]
 8022430:	6061      	str	r1, [r4, #4]
 8022432:	60a2      	str	r2, [r4, #8]
 8022434:	60e3      	str	r3, [r4, #12]
 8022436:	6828      	ldr	r0, [r5, #0]
 8022438:	6120      	str	r0, [r4, #16]
 802243a:	88aa      	ldrh	r2, [r5, #4]
 802243c:	79ab      	ldrb	r3, [r5, #6]
 802243e:	82a2      	strh	r2, [r4, #20]
 8022440:	75a3      	strb	r3, [r4, #22]
 8022442:	4620      	mov	r0, r4
 8022444:	f7fc ff71 	bl	801f32a <crs_strlen>
 8022448:	b283      	uxth	r3, r0
 802244a:	4622      	mov	r2, r4
 802244c:	2101      	movs	r1, #1
 802244e:	200a      	movs	r0, #10
 8022450:	f7fc ffae 	bl	801f3b0 <traceIF_itmPrint>
 8022454:	4620      	mov	r0, r4
 8022456:	f7fc ff68 	bl	801f32a <crs_strlen>
 802245a:	b282      	uxth	r2, r0
 802245c:	4621      	mov	r1, r4
 802245e:	200a      	movs	r0, #10
 8022460:	f7fc ffe0 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("<parameter value>\r\n");
 8022464:	4d98      	ldr	r5, [pc, #608]	; (80226c8 <CMD_Help+0x488>)
 8022466:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022468:	6020      	str	r0, [r4, #0]
 802246a:	6061      	str	r1, [r4, #4]
 802246c:	60a2      	str	r2, [r4, #8]
 802246e:	60e3      	str	r3, [r4, #12]
 8022470:	6828      	ldr	r0, [r5, #0]
 8022472:	6120      	str	r0, [r4, #16]
 8022474:	4620      	mov	r0, r4
 8022476:	f7fc ff58 	bl	801f32a <crs_strlen>
 802247a:	b283      	uxth	r3, r0
 802247c:	4622      	mov	r2, r4
 802247e:	2101      	movs	r1, #1
 8022480:	200a      	movs	r0, #10
 8022482:	f7fc ff95 	bl	801f3b0 <traceIF_itmPrint>
 8022486:	4620      	mov	r0, r4
 8022488:	f7fc ff4f 	bl	801f32a <crs_strlen>
 802248c:	b282      	uxth	r2, r0
 802248e:	4621      	mov	r1, r4
 8022490:	200a      	movs	r0, #10
 8022492:	f7fc ffc7 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("<val_1>|<val_2>|...|<val_n>: parameter value list\r\n");
 8022496:	4e8d      	ldr	r6, [pc, #564]	; (80226cc <CMD_Help+0x48c>)
 8022498:	f106 0c30 	add.w	ip, r6, #48	; 0x30
 802249c:	4635      	mov	r5, r6
 802249e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80224a0:	6020      	str	r0, [r4, #0]
 80224a2:	6061      	str	r1, [r4, #4]
 80224a4:	60a2      	str	r2, [r4, #8]
 80224a6:	60e3      	str	r3, [r4, #12]
 80224a8:	462e      	mov	r6, r5
 80224aa:	3410      	adds	r4, #16
 80224ac:	4565      	cmp	r5, ip
 80224ae:	d1f5      	bne.n	802249c <CMD_Help+0x25c>
 80224b0:	6828      	ldr	r0, [r5, #0]
 80224b2:	6020      	str	r0, [r4, #0]
 80224b4:	4c7f      	ldr	r4, [pc, #508]	; (80226b4 <CMD_Help+0x474>)
 80224b6:	4620      	mov	r0, r4
 80224b8:	f7fc ff37 	bl	801f32a <crs_strlen>
 80224bc:	b283      	uxth	r3, r0
 80224be:	4622      	mov	r2, r4
 80224c0:	2101      	movs	r1, #1
 80224c2:	200a      	movs	r0, #10
 80224c4:	f7fc ff74 	bl	801f3b0 <traceIF_itmPrint>
 80224c8:	4620      	mov	r0, r4
 80224ca:	f7fc ff2e 	bl	801f32a <crs_strlen>
 80224ce:	b282      	uxth	r2, r0
 80224d0:	4621      	mov	r1, r4
 80224d2:	200a      	movs	r0, #10
 80224d4:	f7fc ffa6 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("(command description)\r\n");
 80224d8:	4d7d      	ldr	r5, [pc, #500]	; (80226d0 <CMD_Help+0x490>)
 80224da:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80224dc:	6020      	str	r0, [r4, #0]
 80224de:	6061      	str	r1, [r4, #4]
 80224e0:	60a2      	str	r2, [r4, #8]
 80224e2:	60e3      	str	r3, [r4, #12]
 80224e4:	cd03      	ldmia	r5!, {r0, r1}
 80224e6:	6120      	str	r0, [r4, #16]
 80224e8:	6161      	str	r1, [r4, #20]
 80224ea:	4620      	mov	r0, r4
 80224ec:	f7fc ff1d 	bl	801f32a <crs_strlen>
 80224f0:	b283      	uxth	r3, r0
 80224f2:	4622      	mov	r2, r4
 80224f4:	2101      	movs	r1, #1
 80224f6:	200a      	movs	r0, #10
 80224f8:	f7fc ff5a 	bl	801f3b0 <traceIF_itmPrint>
 80224fc:	4620      	mov	r0, r4
 80224fe:	f7fc ff14 	bl	801f32a <crs_strlen>
 8022502:	b282      	uxth	r2, r0
 8022504:	4621      	mov	r1, r4
 8022506:	200a      	movs	r0, #10
 8022508:	f7fc ff8c 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("return key: last command re-execution\r\n");
 802250c:	4e71      	ldr	r6, [pc, #452]	; (80226d4 <CMD_Help+0x494>)
 802250e:	f106 0c20 	add.w	ip, r6, #32
 8022512:	4635      	mov	r5, r6
 8022514:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022516:	6020      	str	r0, [r4, #0]
 8022518:	6061      	str	r1, [r4, #4]
 802251a:	60a2      	str	r2, [r4, #8]
 802251c:	60e3      	str	r3, [r4, #12]
 802251e:	462e      	mov	r6, r5
 8022520:	3410      	adds	r4, #16
 8022522:	4565      	cmp	r5, ip
 8022524:	d1f5      	bne.n	8022512 <CMD_Help+0x2d2>
 8022526:	ce03      	ldmia	r6!, {r0, r1}
 8022528:	6020      	str	r0, [r4, #0]
 802252a:	6061      	str	r1, [r4, #4]
 802252c:	4c61      	ldr	r4, [pc, #388]	; (80226b4 <CMD_Help+0x474>)
 802252e:	4620      	mov	r0, r4
 8022530:	f7fc fefb 	bl	801f32a <crs_strlen>
 8022534:	b283      	uxth	r3, r0
 8022536:	4622      	mov	r2, r4
 8022538:	2101      	movs	r1, #1
 802253a:	200a      	movs	r0, #10
 802253c:	f7fc ff38 	bl	801f3b0 <traceIF_itmPrint>
 8022540:	4620      	mov	r0, r4
 8022542:	f7fc fef2 	bl	801f32a <crs_strlen>
 8022546:	b282      	uxth	r2, r0
 8022548:	4621      	mov	r1, r4
 802254a:	200a      	movs	r0, #10
 802254c:	f7fc ff6a 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("#: comment line\r\n");
 8022550:	4d61      	ldr	r5, [pc, #388]	; (80226d8 <CMD_Help+0x498>)
 8022552:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022554:	6020      	str	r0, [r4, #0]
 8022556:	6061      	str	r1, [r4, #4]
 8022558:	60a2      	str	r2, [r4, #8]
 802255a:	60e3      	str	r3, [r4, #12]
 802255c:	882b      	ldrh	r3, [r5, #0]
 802255e:	8223      	strh	r3, [r4, #16]
 8022560:	4620      	mov	r0, r4
 8022562:	f7fc fee2 	bl	801f32a <crs_strlen>
 8022566:	b283      	uxth	r3, r0
 8022568:	4622      	mov	r2, r4
 802256a:	2101      	movs	r1, #1
 802256c:	200a      	movs	r0, #10
 802256e:	f7fc ff1f 	bl	801f3b0 <traceIF_itmPrint>
 8022572:	4620      	mov	r0, r4
 8022574:	f7fc fed9 	bl	801f32a <crs_strlen>
 8022578:	b282      	uxth	r2, r0
 802257a:	4621      	mov	r1, r4
 802257c:	200a      	movs	r0, #10
 802257e:	f7fc ff51 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\r\nAdvice\r\n");
 8022582:	4b56      	ldr	r3, [pc, #344]	; (80226dc <CMD_Help+0x49c>)
 8022584:	cb03      	ldmia	r3!, {r0, r1}
 8022586:	6020      	str	r0, [r4, #0]
 8022588:	6061      	str	r1, [r4, #4]
 802258a:	881a      	ldrh	r2, [r3, #0]
 802258c:	789b      	ldrb	r3, [r3, #2]
 802258e:	8122      	strh	r2, [r4, #8]
 8022590:	72a3      	strb	r3, [r4, #10]
 8022592:	4620      	mov	r0, r4
 8022594:	f7fc fec9 	bl	801f32a <crs_strlen>
 8022598:	b283      	uxth	r3, r0
 802259a:	4622      	mov	r2, r4
 802259c:	2101      	movs	r1, #1
 802259e:	200a      	movs	r0, #10
 80225a0:	f7fc ff06 	bl	801f3b0 <traceIF_itmPrint>
 80225a4:	4620      	mov	r0, r4
 80225a6:	f7fc fec0 	bl	801f32a <crs_strlen>
 80225aa:	b282      	uxth	r2, r0
 80225ac:	4621      	mov	r1, r4
 80225ae:	200a      	movs	r0, #10
 80225b0:	f7fc ff38 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("-----------\r\n");
 80225b4:	4b41      	ldr	r3, [pc, #260]	; (80226bc <CMD_Help+0x47c>)
 80225b6:	cb07      	ldmia	r3!, {r0, r1, r2}
 80225b8:	6020      	str	r0, [r4, #0]
 80225ba:	6061      	str	r1, [r4, #4]
 80225bc:	60a2      	str	r2, [r4, #8]
 80225be:	881b      	ldrh	r3, [r3, #0]
 80225c0:	81a3      	strh	r3, [r4, #12]
 80225c2:	4620      	mov	r0, r4
 80225c4:	f7fc feb1 	bl	801f32a <crs_strlen>
 80225c8:	b283      	uxth	r3, r0
 80225ca:	4622      	mov	r2, r4
 80225cc:	2101      	movs	r1, #1
 80225ce:	200a      	movs	r0, #10
 80225d0:	f7fc feee 	bl	801f3b0 <traceIF_itmPrint>
 80225d4:	4620      	mov	r0, r4
 80225d6:	f7fc fea8 	bl	801f32a <crs_strlen>
 80225da:	b282      	uxth	r2, r0
 80225dc:	4621      	mov	r1, r4
 80225de:	200a      	movs	r0, #10
 80225e0:	f7fc ff20 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("to use commands it is advised to use one of the following command to disable traces\r\n");
 80225e4:	2256      	movs	r2, #86	; 0x56
 80225e6:	493e      	ldr	r1, [pc, #248]	; (80226e0 <CMD_Help+0x4a0>)
 80225e8:	4620      	mov	r0, r4
 80225ea:	f004 fa7d 	bl	8026ae8 <memcpy>
 80225ee:	4620      	mov	r0, r4
 80225f0:	f7fc fe9b 	bl	801f32a <crs_strlen>
 80225f4:	b283      	uxth	r3, r0
 80225f6:	4622      	mov	r2, r4
 80225f8:	2101      	movs	r1, #1
 80225fa:	200a      	movs	r0, #10
 80225fc:	f7fc fed8 	bl	801f3b0 <traceIF_itmPrint>
 8022600:	4620      	mov	r0, r4
 8022602:	f7fc fe92 	bl	801f32a <crs_strlen>
 8022606:	b282      	uxth	r2, r0
 8022608:	4621      	mov	r1, r4
 802260a:	200a      	movs	r0, #10
 802260c:	f7fc ff0a 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("trace off (allows disable all traces)\r\n");
 8022610:	4e34      	ldr	r6, [pc, #208]	; (80226e4 <CMD_Help+0x4a4>)
 8022612:	f106 0c20 	add.w	ip, r6, #32
 8022616:	4635      	mov	r5, r6
 8022618:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802261a:	6020      	str	r0, [r4, #0]
 802261c:	6061      	str	r1, [r4, #4]
 802261e:	60a2      	str	r2, [r4, #8]
 8022620:	60e3      	str	r3, [r4, #12]
 8022622:	462e      	mov	r6, r5
 8022624:	3410      	adds	r4, #16
 8022626:	4565      	cmp	r5, ip
 8022628:	d1f5      	bne.n	8022616 <CMD_Help+0x3d6>
 802262a:	ce03      	ldmia	r6!, {r0, r1}
 802262c:	6020      	str	r0, [r4, #0]
 802262e:	6061      	str	r1, [r4, #4]
 8022630:	4c20      	ldr	r4, [pc, #128]	; (80226b4 <CMD_Help+0x474>)
 8022632:	4620      	mov	r0, r4
 8022634:	f7fc fe79 	bl	801f32a <crs_strlen>
 8022638:	b283      	uxth	r3, r0
 802263a:	4622      	mov	r2, r4
 802263c:	2101      	movs	r1, #1
 802263e:	200a      	movs	r0, #10
 8022640:	f7fc feb6 	bl	801f3b0 <traceIF_itmPrint>
 8022644:	4620      	mov	r0, r4
 8022646:	f7fc fe70 	bl	801f32a <crs_strlen>
 802264a:	b282      	uxth	r2, r0
 802264c:	4621      	mov	r1, r4
 802264e:	200a      	movs	r0, #10
 8022650:	f7fc fee8 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("cst polling off  (allows to disable modem polling and avoid to display uncomfortable modem traces\r\n");
 8022654:	2264      	movs	r2, #100	; 0x64
 8022656:	4924      	ldr	r1, [pc, #144]	; (80226e8 <CMD_Help+0x4a8>)
 8022658:	4620      	mov	r0, r4
 802265a:	f004 fa45 	bl	8026ae8 <memcpy>
 802265e:	4620      	mov	r0, r4
 8022660:	f7fc fe63 	bl	801f32a <crs_strlen>
 8022664:	b283      	uxth	r3, r0
 8022666:	4622      	mov	r2, r4
 8022668:	2101      	movs	r1, #1
 802266a:	200a      	movs	r0, #10
 802266c:	f7fc fea0 	bl	801f3b0 <traceIF_itmPrint>
 8022670:	4620      	mov	r0, r4
 8022672:	f7fc fe5a 	bl	801f32a <crs_strlen>
 8022676:	b282      	uxth	r2, r0
 8022678:	4621      	mov	r1, r4
 802267a:	200a      	movs	r0, #10
 802267c:	f7fc fed2 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("\r\n");
 8022680:	4b1a      	ldr	r3, [pc, #104]	; (80226ec <CMD_Help+0x4ac>)
 8022682:	881a      	ldrh	r2, [r3, #0]
 8022684:	789b      	ldrb	r3, [r3, #2]
 8022686:	8022      	strh	r2, [r4, #0]
 8022688:	70a3      	strb	r3, [r4, #2]
 802268a:	4620      	mov	r0, r4
 802268c:	f7fc fe4d 	bl	801f32a <crs_strlen>
 8022690:	b283      	uxth	r3, r0
 8022692:	4622      	mov	r2, r4
 8022694:	2101      	movs	r1, #1
 8022696:	200a      	movs	r0, #10
 8022698:	f7fc fe8a 	bl	801f3b0 <traceIF_itmPrint>
 802269c:	4620      	mov	r0, r4
 802269e:	f7fc fe44 	bl	801f32a <crs_strlen>
 80226a2:	b282      	uxth	r2, r0
 80226a4:	4621      	mov	r1, r4
 80226a6:	200a      	movs	r0, #10
 80226a8:	f7fc febc 	bl	801f424 <traceIF_uartPrintForce>

  return CMD_OK;
}
 80226ac:	2000      	movs	r0, #0
 80226ae:	b006      	add	sp, #24
 80226b0:	bd70      	pop	{r4, r5, r6, pc}
 80226b2:	bf00      	nop
 80226b4:	200050dc 	.word	0x200050dc
 80226b8:	08036a94 	.word	0x08036a94
 80226bc:	08036aa4 	.word	0x08036aa4
 80226c0:	08036ab4 	.word	0x08036ab4
 80226c4:	08036ad8 	.word	0x08036ad8
 80226c8:	08036af0 	.word	0x08036af0
 80226cc:	08036b04 	.word	0x08036b04
 80226d0:	08036b38 	.word	0x08036b38
 80226d4:	08036b50 	.word	0x08036b50
 80226d8:	08036b78 	.word	0x08036b78
 80226dc:	08036b8c 	.word	0x08036b8c
 80226e0:	08036b98 	.word	0x08036b98
 80226e4:	08036bf0 	.word	0x08036bf0
 80226e8:	08036c18 	.word	0x08036c18
 80226ec:	08035630 	.word	0x08035630

080226f0 <CMD_process>:
{
 80226f0:	b530      	push	{r4, r5, lr}
 80226f2:	b09b      	sub	sp, #108	; 0x6c
  CMD_GetLine(command_line, CMD_MAX_LINE_SIZE);
 80226f4:	2164      	movs	r1, #100	; 0x64
 80226f6:	a801      	add	r0, sp, #4
 80226f8:	f7ff fd4e 	bl	8022198 <CMD_GetLine>
  if (command_line[0] != (uint8_t)'#')
 80226fc:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8022700:	2b23      	cmp	r3, #35	; 0x23
 8022702:	f000 80a7 	beq.w	8022854 <CMD_process+0x164>
    if (command_line[0] == 0U)
 8022706:	bb13      	cbnz	r3, 802274e <CMD_process+0x5e>
      if (CMD_LastCommandLine[0] == 0U)
 8022708:	4b5e      	ldr	r3, [pc, #376]	; (8022884 <CMD_process+0x194>)
 802270a:	781b      	ldrb	r3, [r3, #0]
 802270c:	b9ab      	cbnz	r3, 802273a <CMD_process+0x4a>
        (void)memcpy((CRC_CHAR_t *)command_line, (CRC_CHAR_t *)"help", crs_strlen((const uint8_t *)"help") + 1U);
 802270e:	4c5e      	ldr	r4, [pc, #376]	; (8022888 <CMD_process+0x198>)
 8022710:	4620      	mov	r0, r4
 8022712:	f7fc fe0a 	bl	801f32a <crs_strlen>
 8022716:	1c42      	adds	r2, r0, #1
 8022718:	4621      	mov	r1, r4
 802271a:	a801      	add	r0, sp, #4
 802271c:	f004 f9e4 	bl	8026ae8 <memcpy>
    for (i = 0; i < CMD_MAX_LINE_SIZE ;  i++)
 8022720:	2400      	movs	r4, #0
 8022722:	2c63      	cmp	r4, #99	; 0x63
 8022724:	d821      	bhi.n	802276a <CMD_process+0x7a>
      if ((command_line[i] == (uint8_t)' ') || (command_line[i] == (uint8_t)0))
 8022726:	f104 0368 	add.w	r3, r4, #104	; 0x68
 802272a:	446b      	add	r3, sp
 802272c:	f813 3c64 	ldrb.w	r3, [r3, #-100]
 8022730:	2b20      	cmp	r3, #32
 8022732:	d01a      	beq.n	802276a <CMD_process+0x7a>
 8022734:	b1cb      	cbz	r3, 802276a <CMD_process+0x7a>
    for (i = 0; i < CMD_MAX_LINE_SIZE ;  i++)
 8022736:	3401      	adds	r4, #1
 8022738:	e7f3      	b.n	8022722 <CMD_process+0x32>
                     crs_strlen(CMD_LastCommandLine) + 1U);
 802273a:	4c52      	ldr	r4, [pc, #328]	; (8022884 <CMD_process+0x194>)
 802273c:	4620      	mov	r0, r4
 802273e:	f7fc fdf4 	bl	801f32a <crs_strlen>
        (void)memcpy((CRC_CHAR_t *)command_line, (CRC_CHAR_t *)CMD_LastCommandLine,
 8022742:	1c42      	adds	r2, r0, #1
 8022744:	4621      	mov	r1, r4
 8022746:	a801      	add	r0, sp, #4
 8022748:	f004 f9ce 	bl	8026ae8 <memcpy>
 802274c:	e7e8      	b.n	8022720 <CMD_process+0x30>
      cmd_line_len = crs_strlen(command_line);
 802274e:	a801      	add	r0, sp, #4
 8022750:	f7fc fdeb 	bl	801f32a <crs_strlen>
      if (cmd_line_len > 1U)
 8022754:	2801      	cmp	r0, #1
 8022756:	d9e3      	bls.n	8022720 <CMD_process+0x30>
        (void)memcpy((CRC_CHAR_t *)CMD_LastCommandLine, (CRC_CHAR_t *)command_line, crs_strlen(command_line) + 1U);
 8022758:	a801      	add	r0, sp, #4
 802275a:	f7fc fde6 	bl	801f32a <crs_strlen>
 802275e:	1c42      	adds	r2, r0, #1
 8022760:	a901      	add	r1, sp, #4
 8022762:	4848      	ldr	r0, [pc, #288]	; (8022884 <CMD_process+0x194>)
 8022764:	f004 f9c0 	bl	8026ae8 <memcpy>
 8022768:	e7da      	b.n	8022720 <CMD_process+0x30>
    if (memcmp((CRC_CHAR_t *)"reset", (CRC_CHAR_t *)command_line, cmd_size) == 0)
 802276a:	4622      	mov	r2, r4
 802276c:	a901      	add	r1, sp, #4
 802276e:	4847      	ldr	r0, [pc, #284]	; (802288c <CMD_process+0x19c>)
 8022770:	f004 f8cd 	bl	802690e <memcmp>
 8022774:	b190      	cbz	r0, 802279c <CMD_process+0xac>
    else if (i != CMD_MAX_LINE_SIZE)
 8022776:	2c64      	cmp	r4, #100	; 0x64
 8022778:	d06a      	beq.n	8022850 <CMD_process+0x160>
      for (i = 0U; i < CMD_NbCmd ; i++)
 802277a:	2500      	movs	r5, #0
 802277c:	4b44      	ldr	r3, [pc, #272]	; (8022890 <CMD_process+0x1a0>)
 802277e:	681b      	ldr	r3, [r3, #0]
 8022780:	42ab      	cmp	r3, r5
 8022782:	d92d      	bls.n	80227e0 <CMD_process+0xf0>
        if (memcmp((CRC_CHAR_t *)CMD_a_cmd_list[i].CmdName, (CRC_CHAR_t *)command_line, cmd_size) == 0)
 8022784:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8022788:	4622      	mov	r2, r4
 802278a:	a901      	add	r1, sp, #4
 802278c:	4841      	ldr	r0, [pc, #260]	; (8022894 <CMD_process+0x1a4>)
 802278e:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
 8022792:	f004 f8bc 	bl	802690e <memcmp>
 8022796:	b120      	cbz	r0, 80227a2 <CMD_process+0xb2>
      for (i = 0U; i < CMD_NbCmd ; i++)
 8022798:	3501      	adds	r5, #1
 802279a:	e7ef      	b.n	802277c <CMD_process+0x8c>
      CMD_BoardReset((uint8_t *)command_line);
 802279c:	a801      	add	r0, sp, #4
 802279e:	f7ff fd17 	bl	80221d0 <CMD_BoardReset>
          PRINT_FORCE("\r\n")
 80227a2:	4c3d      	ldr	r4, [pc, #244]	; (8022898 <CMD_process+0x1a8>)
 80227a4:	4b3d      	ldr	r3, [pc, #244]	; (802289c <CMD_process+0x1ac>)
 80227a6:	881a      	ldrh	r2, [r3, #0]
 80227a8:	789b      	ldrb	r3, [r3, #2]
 80227aa:	8022      	strh	r2, [r4, #0]
 80227ac:	70a3      	strb	r3, [r4, #2]
 80227ae:	4620      	mov	r0, r4
 80227b0:	f7fc fdbb 	bl	801f32a <crs_strlen>
 80227b4:	b283      	uxth	r3, r0
 80227b6:	4622      	mov	r2, r4
 80227b8:	2101      	movs	r1, #1
 80227ba:	200a      	movs	r0, #10
 80227bc:	f7fc fdf8 	bl	801f3b0 <traceIF_itmPrint>
 80227c0:	4620      	mov	r0, r4
 80227c2:	f7fc fdb2 	bl	801f32a <crs_strlen>
 80227c6:	b282      	uxth	r2, r0
 80227c8:	4621      	mov	r1, r4
 80227ca:	200a      	movs	r0, #10
 80227cc:	f7fc fe2a 	bl	801f424 <traceIF_uartPrintForce>
          (void)CMD_a_cmd_list[i].CmdHandler((uint8_t *)command_line);
 80227d0:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 80227d4:	4b2f      	ldr	r3, [pc, #188]	; (8022894 <CMD_process+0x1a4>)
 80227d6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80227da:	689b      	ldr	r3, [r3, #8]
 80227dc:	a801      	add	r0, sp, #4
 80227de:	4798      	blx	r3
      if (i >= CMD_NbCmd)
 80227e0:	4b2b      	ldr	r3, [pc, #172]	; (8022890 <CMD_process+0x1a0>)
 80227e2:	681b      	ldr	r3, [r3, #0]
 80227e4:	42ab      	cmp	r3, r5
 80227e6:	d918      	bls.n	802281a <CMD_process+0x12a>
  PRINT_FORCE("%s", (CRC_CHAR_t *)cmd_prompt)
 80227e8:	4c2b      	ldr	r4, [pc, #172]	; (8022898 <CMD_process+0x1a8>)
 80227ea:	4b2d      	ldr	r3, [pc, #180]	; (80228a0 <CMD_process+0x1b0>)
 80227ec:	881a      	ldrh	r2, [r3, #0]
 80227ee:	789b      	ldrb	r3, [r3, #2]
 80227f0:	8022      	strh	r2, [r4, #0]
 80227f2:	70a3      	strb	r3, [r4, #2]
 80227f4:	4620      	mov	r0, r4
 80227f6:	f7fc fd98 	bl	801f32a <crs_strlen>
 80227fa:	b283      	uxth	r3, r0
 80227fc:	4622      	mov	r2, r4
 80227fe:	2101      	movs	r1, #1
 8022800:	200a      	movs	r0, #10
 8022802:	f7fc fdd5 	bl	801f3b0 <traceIF_itmPrint>
 8022806:	4620      	mov	r0, r4
 8022808:	f7fc fd8f 	bl	801f32a <crs_strlen>
 802280c:	b282      	uxth	r2, r0
 802280e:	4621      	mov	r1, r4
 8022810:	200a      	movs	r0, #10
 8022812:	f7fc fe07 	bl	801f424 <traceIF_uartPrintForce>
}
 8022816:	b01b      	add	sp, #108	; 0x6c
 8022818:	bd30      	pop	{r4, r5, pc}
        PRINT_FORCE("\r\nCMD : unknown command : %s\r\n", command_line)
 802281a:	4c1f      	ldr	r4, [pc, #124]	; (8022898 <CMD_process+0x1a8>)
 802281c:	aa01      	add	r2, sp, #4
 802281e:	4921      	ldr	r1, [pc, #132]	; (80228a4 <CMD_process+0x1b4>)
 8022820:	4620      	mov	r0, r4
 8022822:	f004 f811 	bl	8026848 <sprintf>
 8022826:	4620      	mov	r0, r4
 8022828:	f7fc fd7f 	bl	801f32a <crs_strlen>
 802282c:	b283      	uxth	r3, r0
 802282e:	4622      	mov	r2, r4
 8022830:	2101      	movs	r1, #1
 8022832:	200a      	movs	r0, #10
 8022834:	f7fc fdbc 	bl	801f3b0 <traceIF_itmPrint>
 8022838:	4620      	mov	r0, r4
 802283a:	f7fc fd76 	bl	801f32a <crs_strlen>
 802283e:	b282      	uxth	r2, r0
 8022840:	4621      	mov	r1, r4
 8022842:	200a      	movs	r0, #10
 8022844:	f7fc fdee 	bl	801f424 <traceIF_uartPrintForce>
        (void)CMD_Help(command_line);
 8022848:	a801      	add	r0, sp, #4
 802284a:	f7ff fcf9 	bl	8022240 <CMD_Help>
 802284e:	e7cb      	b.n	80227e8 <CMD_process+0xf8>
      __NOP(); /* Nothing to do */
 8022850:	bf00      	nop
 8022852:	e7c9      	b.n	80227e8 <CMD_process+0xf8>
    PRINT_FORCE("\r\n")
 8022854:	4c10      	ldr	r4, [pc, #64]	; (8022898 <CMD_process+0x1a8>)
 8022856:	4b11      	ldr	r3, [pc, #68]	; (802289c <CMD_process+0x1ac>)
 8022858:	881a      	ldrh	r2, [r3, #0]
 802285a:	789b      	ldrb	r3, [r3, #2]
 802285c:	8022      	strh	r2, [r4, #0]
 802285e:	70a3      	strb	r3, [r4, #2]
 8022860:	4620      	mov	r0, r4
 8022862:	f7fc fd62 	bl	801f32a <crs_strlen>
 8022866:	b283      	uxth	r3, r0
 8022868:	4622      	mov	r2, r4
 802286a:	2101      	movs	r1, #1
 802286c:	200a      	movs	r0, #10
 802286e:	f7fc fd9f 	bl	801f3b0 <traceIF_itmPrint>
 8022872:	4620      	mov	r0, r4
 8022874:	f7fc fd59 	bl	801f32a <crs_strlen>
 8022878:	b282      	uxth	r2, r0
 802287a:	4621      	mov	r1, r4
 802287c:	200a      	movs	r0, #10
 802287e:	f7fc fdd1 	bl	801f424 <traceIF_uartPrintForce>
 8022882:	e7b1      	b.n	80227e8 <CMD_process+0xf8>
 8022884:	20005a78 	.word	0x20005a78
 8022888:	08033830 	.word	0x08033830
 802288c:	08036c7c 	.word	0x08036c7c
 8022890:	20005adc 	.word	0x20005adc
 8022894:	20005ae8 	.word	0x20005ae8
 8022898:	200050dc 	.word	0x200050dc
 802289c:	08035630 	.word	0x08035630
 80228a0:	08036ca4 	.word	0x08036ca4
 80228a4:	08036c84 	.word	0x08036c84

080228a8 <cmd_thread>:
  * @brief thread core of the command management
  * @param  argument (not used)
  * @retval -
  */
static void cmd_thread(const void *argument)
{
 80228a8:	b508      	push	{r3, lr}
  for (;;)
  {
    CMD_process();
 80228aa:	f7ff ff21 	bl	80226f0 <CMD_process>
  for (;;)
 80228ae:	e7fc      	b.n	80228aa <cmd_thread+0x2>

080228b0 <CMD_GetValue>:
  * @param  string_p   (IN) acscii value to convert
  * @param  value_p    (OUT) converted uint32_t value
  * @retval return value
  */
uint32_t CMD_GetValue(uint8_t *string_p, uint32_t *value_p)
{
 80228b0:	b538      	push	{r3, r4, r5, lr}
 80228b2:	460d      	mov	r5, r1
  uint32_t ret;
  uint8_t digit8;
  uint32_t digit;
  ret = 0U;

  if (string_p == NULL)
 80228b4:	b170      	cbz	r0, 80228d4 <CMD_GetValue+0x24>
 80228b6:	4604      	mov	r4, r0
    ret = 1U;
    *value_p = 0U;
  }
  else
  {
    if (memcmp((CRC_CHAR_t *)string_p, "0x", 2U) == 0)
 80228b8:	2202      	movs	r2, #2
 80228ba:	490e      	ldr	r1, [pc, #56]	; (80228f4 <CMD_GetValue+0x44>)
 80228bc:	f004 f827 	bl	802690e <memcmp>
 80228c0:	b160      	cbz	r0, 80228dc <CMD_GetValue+0x2c>
    {
      *value_p = (uint32_t)crs_atoi_hex(&string_p[2]);
    }
    else
    {
      digit8 = (*string_p - (uint8_t)'0');
 80228c2:	7823      	ldrb	r3, [r4, #0]
 80228c4:	3b30      	subs	r3, #48	; 0x30
 80228c6:	b2db      	uxtb	r3, r3
      digit  = (uint32_t)digit8;
      if (digit <= 9U)
 80228c8:	2b09      	cmp	r3, #9
 80228ca:	d90d      	bls.n	80228e8 <CMD_GetValue+0x38>
        *value_p = (uint32_t)crs_atoi(string_p);
      }
      else
      {
        ret = 1U;
        *value_p = 0U;
 80228cc:	2300      	movs	r3, #0
 80228ce:	602b      	str	r3, [r5, #0]
        ret = 1U;
 80228d0:	2001      	movs	r0, #1
      }
    }
  }
  return ret;
}
 80228d2:	bd38      	pop	{r3, r4, r5, pc}
    *value_p = 0U;
 80228d4:	2300      	movs	r3, #0
 80228d6:	600b      	str	r3, [r1, #0]
    ret = 1U;
 80228d8:	2001      	movs	r0, #1
 80228da:	e7fa      	b.n	80228d2 <CMD_GetValue+0x22>
      *value_p = (uint32_t)crs_atoi_hex(&string_p[2]);
 80228dc:	1ca0      	adds	r0, r4, #2
 80228de:	f7fc fd04 	bl	801f2ea <crs_atoi_hex>
 80228e2:	6028      	str	r0, [r5, #0]
  ret = 0U;
 80228e4:	2000      	movs	r0, #0
 80228e6:	e7f4      	b.n	80228d2 <CMD_GetValue+0x22>
        *value_p = (uint32_t)crs_atoi(string_p);
 80228e8:	4620      	mov	r0, r4
 80228ea:	f7fc fcd9 	bl	801f2a0 <crs_atoi>
 80228ee:	6028      	str	r0, [r5, #0]
  ret = 0U;
 80228f0:	2000      	movs	r0, #0
 80228f2:	e7ee      	b.n	80228d2 <CMD_GetValue+0x22>
 80228f4:	08036ca8 	.word	0x08036ca8

080228f8 <CMD_Declare>:
  * @param  cmd_handler    callback of the component to manage the command
  * @param  cmd_label_p    description of the component to display at the help  command
  * @retval -
  */
void CMD_Declare(uint8_t *cmd_name_p, CMD_HandlerCmd cmd_handler, uint8_t *cmd_label_p)
{
 80228f8:	b510      	push	{r4, lr}
  if (CMD_NbCmd >= CMD_MAX_CMD)
 80228fa:	4b0c      	ldr	r3, [pc, #48]	; (802292c <CMD_Declare+0x34>)
 80228fc:	681b      	ldr	r3, [r3, #0]
 80228fe:	2b16      	cmp	r3, #22
 8022900:	d80e      	bhi.n	8022920 <CMD_Declare+0x28>
    /* too many recorded components */
    ERROR_Handler(DBG_CHAN_UTILITIES, 10, ERROR_WARNING);
  }
  else
  {
    CMD_a_cmd_list[CMD_NbCmd].CmdName    = cmd_name_p;
 8022902:	4c0b      	ldr	r4, [pc, #44]	; (8022930 <CMD_Declare+0x38>)
 8022904:	eb03 0e43 	add.w	lr, r3, r3, lsl #1
 8022908:	eb04 0c8e 	add.w	ip, r4, lr, lsl #2
 802290c:	f844 002e 	str.w	r0, [r4, lr, lsl #2]
    CMD_a_cmd_list[CMD_NbCmd].CmdLabel   = cmd_label_p;
 8022910:	f8cc 2004 	str.w	r2, [ip, #4]
    CMD_a_cmd_list[CMD_NbCmd].CmdHandler = cmd_handler;
 8022914:	f8cc 1008 	str.w	r1, [ip, #8]

    CMD_NbCmd++;
 8022918:	3301      	adds	r3, #1
 802291a:	4a04      	ldr	r2, [pc, #16]	; (802292c <CMD_Declare+0x34>)
 802291c:	6013      	str	r3, [r2, #0]
  }
}
 802291e:	bd10      	pop	{r4, pc}
    ERROR_Handler(DBG_CHAN_UTILITIES, 10, ERROR_WARNING);
 8022920:	2202      	movs	r2, #2
 8022922:	210a      	movs	r1, #10
 8022924:	4608      	mov	r0, r1
 8022926:	f7fb fd1d 	bl	801e364 <ERROR_Handler>
 802292a:	e7f8      	b.n	802291e <CMD_Declare+0x26>
 802292c:	20005adc 	.word	0x20005adc
 8022930:	20005ae8 	.word	0x20005ae8

08022934 <CMD_RxCpltCallback>:
  * @brief console UART receive IT Callback
  * @param  uart_handle_p       console UART handle
  * @retval -
  */
void CMD_RxCpltCallback(UART_HandleTypeDef *uart_handle_p)
{
 8022934:	b538      	push	{r3, r4, r5, lr}
  static UART_HandleTypeDef *CMD_CurrentUart;

  CMD_CurrentUart = uart_handle_p;
 8022936:	4b19      	ldr	r3, [pc, #100]	; (802299c <CMD_RxCpltCallback+0x68>)
 8022938:	6018      	str	r0, [r3, #0]
  uint8_t rec_char;
  uint8_t *temp;

  /* store the received char */
  rec_char = CMD_ReceivedChar;
 802293a:	4919      	ldr	r1, [pc, #100]	; (80229a0 <CMD_RxCpltCallback+0x6c>)
 802293c:	780c      	ldrb	r4, [r1, #0]

  /* rearm the IT  receveive for the next char */
  if (HAL_UART_Receive_IT(CMD_CurrentUart, (uint8_t *)&CMD_ReceivedChar, 1U) != HAL_OK)
 802293e:	2201      	movs	r2, #1
 8022940:	f7e7 fba6 	bl	800a090 <HAL_UART_Receive_IT>
 8022944:	b100      	cbz	r0, 8022948 <CMD_RxCpltCallback+0x14>
  {
    __NOP(); /* Nothing to do */
 8022946:	bf00      	nop
  }

  /* ignore '\n' char */
  if (rec_char != (uint8_t)'\n')
 8022948:	2c0a      	cmp	r4, #10
 802294a:	d016      	beq.n	802297a <CMD_RxCpltCallback+0x46>
  {
    if ((rec_char == (uint8_t)'\r') || (CMD_CurrentPos >= (CMD_MAX_LINE_SIZE - 1U)))
 802294c:	2c0d      	cmp	r4, #13
 802294e:	d003      	beq.n	8022958 <CMD_RxCpltCallback+0x24>
 8022950:	4b14      	ldr	r3, [pc, #80]	; (80229a4 <CMD_RxCpltCallback+0x70>)
 8022952:	681b      	ldr	r3, [r3, #0]
 8022954:	2b62      	cmp	r3, #98	; 0x62
 8022956:	d911      	bls.n	802297c <CMD_RxCpltCallback+0x48>
    {
      /* end of line reached: switch between reveived buffer and receiving buffer */
      CMD_current_rcv_line[CMD_CurrentPos] = 0;
 8022958:	4813      	ldr	r0, [pc, #76]	; (80229a8 <CMD_RxCpltCallback+0x74>)
 802295a:	6803      	ldr	r3, [r0, #0]
 802295c:	4a11      	ldr	r2, [pc, #68]	; (80229a4 <CMD_RxCpltCallback+0x70>)
 802295e:	6814      	ldr	r4, [r2, #0]
 8022960:	2100      	movs	r1, #0
 8022962:	5519      	strb	r1, [r3, r4]
      temp = CMD_completed_line;
 8022964:	4c11      	ldr	r4, [pc, #68]	; (80229ac <CMD_RxCpltCallback+0x78>)
 8022966:	6825      	ldr	r5, [r4, #0]
      CMD_completed_line = CMD_current_rcv_line;
 8022968:	6023      	str	r3, [r4, #0]
      CMD_current_cmd    = CMD_completed_line;
 802296a:	4c11      	ldr	r4, [pc, #68]	; (80229b0 <CMD_RxCpltCallback+0x7c>)
 802296c:	6023      	str	r3, [r4, #0]
      CMD_current_rcv_line = temp;
 802296e:	6005      	str	r5, [r0, #0]
      CMD_CurrentPos = 0;
 8022970:	6011      	str	r1, [r2, #0]
      (void)rtosalSemaphoreRelease(CMD_rcvSemaphore);
 8022972:	4b10      	ldr	r3, [pc, #64]	; (80229b4 <CMD_RxCpltCallback+0x80>)
 8022974:	6818      	ldr	r0, [r3, #0]
 8022976:	f7fc fbe4 	bl	801f142 <rtosalSemaphoreRelease>
        CMD_current_rcv_line[CMD_CurrentPos] = rec_char;
        CMD_CurrentPos++;
      }
    }
  }
}
 802297a:	bd38      	pop	{r3, r4, r5, pc}
      if (rec_char == (uint8_t)'\b')
 802297c:	2c08      	cmp	r4, #8
 802297e:	d006      	beq.n	802298e <CMD_RxCpltCallback+0x5a>
        CMD_current_rcv_line[CMD_CurrentPos] = rec_char;
 8022980:	4a09      	ldr	r2, [pc, #36]	; (80229a8 <CMD_RxCpltCallback+0x74>)
 8022982:	6812      	ldr	r2, [r2, #0]
 8022984:	54d4      	strb	r4, [r2, r3]
        CMD_CurrentPos++;
 8022986:	3301      	adds	r3, #1
 8022988:	4a06      	ldr	r2, [pc, #24]	; (80229a4 <CMD_RxCpltCallback+0x70>)
 802298a:	6013      	str	r3, [r2, #0]
}
 802298c:	e7f5      	b.n	802297a <CMD_RxCpltCallback+0x46>
        if (CMD_CurrentPos > 0U)
 802298e:	2b00      	cmp	r3, #0
 8022990:	d0f3      	beq.n	802297a <CMD_RxCpltCallback+0x46>
          CMD_CurrentPos--;
 8022992:	3b01      	subs	r3, #1
 8022994:	4a03      	ldr	r2, [pc, #12]	; (80229a4 <CMD_RxCpltCallback+0x70>)
 8022996:	6013      	str	r3, [r2, #0]
 8022998:	e7ef      	b.n	802297a <CMD_RxCpltCallback+0x46>
 802299a:	bf00      	nop
 802299c:	20005a74 	.word	0x20005a74
 80229a0:	20005ae0 	.word	0x20005ae0
 80229a4:	20005a70 	.word	0x20005a70
 80229a8:	20005c04 	.word	0x20005c04
 80229ac:	20005bfc 	.word	0x20005bfc
 80229b0:	20005c00 	.word	0x20005c00
 80229b4:	20005c08 	.word	0x20005c08

080229b8 <CMD_print_help>:
  * @brief display component help
  * @param  label   component description
  * @retval -
  */
void CMD_print_help(uint8_t *label)
{
 80229b8:	b510      	push	{r4, lr}
 80229ba:	4602      	mov	r2, r0
  PRINT_FORCE("***** %s help *****\r\n", label);
 80229bc:	4c0b      	ldr	r4, [pc, #44]	; (80229ec <CMD_print_help+0x34>)
 80229be:	490c      	ldr	r1, [pc, #48]	; (80229f0 <CMD_print_help+0x38>)
 80229c0:	4620      	mov	r0, r4
 80229c2:	f003 ff41 	bl	8026848 <sprintf>
 80229c6:	4620      	mov	r0, r4
 80229c8:	f7fc fcaf 	bl	801f32a <crs_strlen>
 80229cc:	b283      	uxth	r3, r0
 80229ce:	4622      	mov	r2, r4
 80229d0:	2101      	movs	r1, #1
 80229d2:	200a      	movs	r0, #10
 80229d4:	f7fc fcec 	bl	801f3b0 <traceIF_itmPrint>
 80229d8:	4620      	mov	r0, r4
 80229da:	f7fc fca6 	bl	801f32a <crs_strlen>
 80229de:	b282      	uxth	r2, r0
 80229e0:	4621      	mov	r1, r4
 80229e2:	200a      	movs	r0, #10
 80229e4:	f7fc fd1e 	bl	801f424 <traceIF_uartPrintForce>
}
 80229e8:	bd10      	pop	{r4, pc}
 80229ea:	bf00      	nop
 80229ec:	200050dc 	.word	0x200050dc
 80229f0:	08036cac 	.word	0x08036cac

080229f4 <CMD_init>:
  * @brief  module initialization
  * @param  -
  * @retval -
  */
void CMD_init(void)
{
 80229f4:	b510      	push	{r4, lr}
 80229f6:	b082      	sub	sp, #8
#if (USE_LINK_UART == 1)
  static uint8_t   CMD_LinkCommandLine[2][CMD_MAX_LINE_SIZE];
#endif  /* (USE_LINK_UART == 1) */
  static osThreadId CMD_ThreadId;

  CMD_NbCmd           = 0U;
 80229f8:	2400      	movs	r4, #0
 80229fa:	4b1a      	ldr	r3, [pc, #104]	; (8022a64 <CMD_init+0x70>)
 80229fc:	601c      	str	r4, [r3, #0]

  CMD_CommandLine[0][0] = 0;
 80229fe:	4b1a      	ldr	r3, [pc, #104]	; (8022a68 <CMD_init+0x74>)
 8022a00:	701c      	strb	r4, [r3, #0]
  CMD_CommandLine[1][0] = 0;
 8022a02:	f883 4064 	strb.w	r4, [r3, #100]	; 0x64
  CMD_current_rcv_line  = CMD_CommandLine[0];
 8022a06:	4a19      	ldr	r2, [pc, #100]	; (8022a6c <CMD_init+0x78>)
 8022a08:	6013      	str	r3, [r2, #0]
  CMD_current_cmd       = CMD_CommandLine[1];
 8022a0a:	3364      	adds	r3, #100	; 0x64
 8022a0c:	4a18      	ldr	r2, [pc, #96]	; (8022a70 <CMD_init+0x7c>)
 8022a0e:	6013      	str	r3, [r2, #0]
  CMD_completed_line    = CMD_CommandLine[1];
 8022a10:	4a18      	ldr	r2, [pc, #96]	; (8022a74 <CMD_init+0x80>)
 8022a12:	6013      	str	r3, [r2, #0]
  CMD_CurrentPos        = 0;
 8022a14:	4b18      	ldr	r3, [pc, #96]	; (8022a78 <CMD_init+0x84>)
 8022a16:	601c      	str	r4, [r3, #0]
#if (USE_LINK_UART == 1)
  CMD_link_current_rcv_line = CMD_LinkCommandLine[0];
  CMD_link_completed_line   = CMD_LinkCommandLine[1];
#endif  /* (USE_LINK_UART == 1) */

  CMD_Declare((uint8_t *)"help", CMD_Help, (uint8_t *)"help command");
 8022a18:	4a18      	ldr	r2, [pc, #96]	; (8022a7c <CMD_init+0x88>)
 8022a1a:	4919      	ldr	r1, [pc, #100]	; (8022a80 <CMD_init+0x8c>)
 8022a1c:	4819      	ldr	r0, [pc, #100]	; (8022a84 <CMD_init+0x90>)
 8022a1e:	f7ff ff6b 	bl	80228f8 <CMD_Declare>
#if (USE_LINK_UART == 1)
  CMD_Declare((uint8_t *)"uartcmd", CMD_UartCmd, "send command to link uart");
#endif  /* (USE_LINK_UART == 1) */

  CMD_LastCommandLine[0] = 0;
 8022a22:	4b19      	ldr	r3, [pc, #100]	; (8022a88 <CMD_init+0x94>)
 8022a24:	701c      	strb	r4, [r3, #0]

  CMD_rcvSemaphore = rtosalSemaphoreNew(NULL, 1);
 8022a26:	2101      	movs	r1, #1
 8022a28:	4620      	mov	r0, r4
 8022a2a:	f7fc fb7c 	bl	801f126 <rtosalSemaphoreNew>
 8022a2e:	4b17      	ldr	r3, [pc, #92]	; (8022a8c <CMD_init+0x98>)
 8022a30:	6018      	str	r0, [r3, #0]
  (void)rtosalSemaphoreAcquire(CMD_rcvSemaphore, RTOSAL_WAIT_FOREVER);
 8022a32:	f04f 31ff 	mov.w	r1, #4294967295
 8022a36:	f7fc fb80 	bl	801f13a <rtosalSemaphoreAcquire>

  CMD_ThreadId = rtosalThreadNew((const rtosal_char_t *)"CMD_THREAD_DEF", cmd_thread, CMD_THREAD_PRIO,
 8022a3a:	9400      	str	r4, [sp, #0]
 8022a3c:	f44f 7316 	mov.w	r3, #600	; 0x258
 8022a40:	f04f 32ff 	mov.w	r2, #4294967295
 8022a44:	4912      	ldr	r1, [pc, #72]	; (8022a90 <CMD_init+0x9c>)
 8022a46:	4813      	ldr	r0, [pc, #76]	; (8022a94 <CMD_init+0xa0>)
 8022a48:	f7fc fb5d 	bl	801f106 <rtosalThreadNew>
 8022a4c:	4b12      	ldr	r3, [pc, #72]	; (8022a98 <CMD_init+0xa4>)
 8022a4e:	6018      	str	r0, [r3, #0]
                                 USED_CMD_THREAD_STACK_SIZE, NULL);
  if (CMD_ThreadId == NULL)
 8022a50:	b108      	cbz	r0, 8022a56 <CMD_init+0x62>
  {
#if (USE_STACK_ANALYSIS == 1U)
    (void)stackAnalysis_addStackSizeByHandle(CMD_ThreadId, USED_CMD_THREAD_STACK_SIZE);
#endif /* USE_STACK_ANALYSIS == 1 */
  }
}
 8022a52:	b002      	add	sp, #8
 8022a54:	bd10      	pop	{r4, pc}
    ERROR_Handler(DBG_CHAN_UTILITIES, 2, ERROR_FATAL);
 8022a56:	2203      	movs	r2, #3
 8022a58:	2102      	movs	r1, #2
 8022a5a:	200a      	movs	r0, #10
 8022a5c:	f7fb fc82 	bl	801e364 <ERROR_Handler>
}
 8022a60:	e7f7      	b.n	8022a52 <CMD_init+0x5e>
 8022a62:	bf00      	nop
 8022a64:	20005adc 	.word	0x20005adc
 8022a68:	200059a8 	.word	0x200059a8
 8022a6c:	20005c04 	.word	0x20005c04
 8022a70:	20005c00 	.word	0x20005c00
 8022a74:	20005bfc 	.word	0x20005bfc
 8022a78:	20005a70 	.word	0x20005a70
 8022a7c:	08036cc4 	.word	0x08036cc4
 8022a80:	08022241 	.word	0x08022241
 8022a84:	08033830 	.word	0x08033830
 8022a88:	20005a78 	.word	0x20005a78
 8022a8c:	20005c08 	.word	0x20005c08
 8022a90:	080228a9 	.word	0x080228a9
 8022a94:	08036cd4 	.word	0x08036cd4
 8022a98:	20005ae4 	.word	0x20005ae4

08022a9c <CMD_start>:
  * @brief  module start
  * @param  -
  * @retval -
  */
void CMD_start(void)
{
 8022a9c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef ret;

  CMD_CommandLine[0][0] = 0;
 8022a9e:	4b08      	ldr	r3, [pc, #32]	; (8022ac0 <CMD_start+0x24>)
 8022aa0:	2200      	movs	r2, #0
 8022aa2:	701a      	strb	r2, [r3, #0]
  CMD_CommandLine[1][0] = 0;
 8022aa4:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
 8022aa8:	e002      	b.n	8022ab0 <CMD_start+0x14>
    ret = HAL_UART_Receive_IT(&TRACE_INTERFACE_UART_HANDLE, &CMD_ReceivedChar, 1U);
    if (ret == HAL_OK)
    {
      break;
    }
    (void)rtosalDelay(10);
 8022aaa:	200a      	movs	r0, #10
 8022aac:	f7fc fb95 	bl	801f1da <rtosalDelay>
    ret = HAL_UART_Receive_IT(&TRACE_INTERFACE_UART_HANDLE, &CMD_ReceivedChar, 1U);
 8022ab0:	2201      	movs	r2, #1
 8022ab2:	4904      	ldr	r1, [pc, #16]	; (8022ac4 <CMD_start+0x28>)
 8022ab4:	4804      	ldr	r0, [pc, #16]	; (8022ac8 <CMD_start+0x2c>)
 8022ab6:	f7e7 faeb 	bl	800a090 <HAL_UART_Receive_IT>
    if (ret == HAL_OK)
 8022aba:	2800      	cmp	r0, #0
 8022abc:	d1f5      	bne.n	8022aaa <CMD_start+0xe>
  }
}
 8022abe:	bd08      	pop	{r3, pc}
 8022ac0:	200059a8 	.word	0x200059a8
 8022ac4:	20005ae0 	.word	0x20005ae0
 8022ac8:	20000c04 	.word	0x20000c04

08022acc <mems_init_sensors>:
#endif /* USE_STACK_ANALYSIS == 1 */
  }
}

static void mems_init_sensors(void)
{
 8022acc:	b508      	push	{r3, lr}
  if (PSENSOR_OK == BSP_PSENSOR_Init())
  {
    mems_init_status |= FLAG_MEMS_PRESSURE;
  }
#elif defined (USE_STM32L462E_CELL01) /* USE B-L462E-CELL1 MEMS */
  if (TSENSOR_OK == BSP_TSENSOR_Init())
 8022ace:	f7df fa15 	bl	8001efc <BSP_TSENSOR_Init>
 8022ad2:	b920      	cbnz	r0, 8022ade <mems_init_sensors+0x12>
  {
    mems_init_status |= FLAG_MEMS_TEMPERATURE;
 8022ad4:	4a0a      	ldr	r2, [pc, #40]	; (8022b00 <mems_init_sensors+0x34>)
 8022ad6:	7813      	ldrb	r3, [r2, #0]
 8022ad8:	f043 0310 	orr.w	r3, r3, #16
 8022adc:	7013      	strb	r3, [r2, #0]
  }
  if (HSENSOR_OK == BSP_HSENSOR_Init())
 8022ade:	f7df f9cd 	bl	8001e7c <BSP_HSENSOR_Init>
 8022ae2:	b920      	cbnz	r0, 8022aee <mems_init_sensors+0x22>
  {
    mems_init_status |= FLAG_MEMS_HUMIDTY;
 8022ae4:	4a06      	ldr	r2, [pc, #24]	; (8022b00 <mems_init_sensors+0x34>)
 8022ae6:	7813      	ldrb	r3, [r2, #0]
 8022ae8:	f043 0308 	orr.w	r3, r3, #8
 8022aec:	7013      	strb	r3, [r2, #0]
  }
  if (PSENSOR_OK == BSP_PSENSOR_Init())
 8022aee:	f7df f9e5 	bl	8001ebc <BSP_PSENSOR_Init>
 8022af2:	b920      	cbnz	r0, 8022afe <mems_init_sensors+0x32>
  {
    mems_init_status |= FLAG_MEMS_PRESSURE;
 8022af4:	4a02      	ldr	r2, [pc, #8]	; (8022b00 <mems_init_sensors+0x34>)
 8022af6:	7813      	ldrb	r3, [r2, #0]
 8022af8:	f043 0320 	orr.w	r3, r3, #32
 8022afc:	7013      	strb	r3, [r2, #0]
    BSP_MOTION_SENSOR_Enable(GYRO_INSTANCE, MOTION_GYRO);
    BSP_MOTION_SENSOR_SetOutputDataRate(GYRO_INSTANCE, MOTION_GYRO, 833);
  }
#endif /* USE_STM32L496G_DISCO */
#endif /* USE_DC_MEMS */
}
 8022afe:	bd08      	pop	{r3, pc}
 8022b00:	20005c94 	.word	0x20005c94

08022b04 <mems_get_acc_datas>:
  * @brief  accelerometer data managememnt
  * @param  none
  * @retval none
  */
static void mems_get_acc_datas(void)
{
 8022b04:	b538      	push	{r3, r4, r5, lr}
#if (USE_DC_MEMS == 1)

	PRINT_INFO("USE_DC_MEMS\n\r");
 8022b06:	4c0f      	ldr	r4, [pc, #60]	; (8022b44 <mems_get_acc_datas+0x40>)
 8022b08:	4d0f      	ldr	r5, [pc, #60]	; (8022b48 <mems_get_acc_datas+0x44>)
 8022b0a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022b0c:	6020      	str	r0, [r4, #0]
 8022b0e:	6061      	str	r1, [r4, #4]
 8022b10:	60a2      	str	r2, [r4, #8]
 8022b12:	60e3      	str	r3, [r4, #12]
 8022b14:	6828      	ldr	r0, [r5, #0]
 8022b16:	6120      	str	r0, [r4, #16]
 8022b18:	792b      	ldrb	r3, [r5, #4]
 8022b1a:	7523      	strb	r3, [r4, #20]
 8022b1c:	4620      	mov	r0, r4
 8022b1e:	f7fc fc04 	bl	801f32a <crs_strlen>
 8022b22:	b283      	uxth	r3, r0
 8022b24:	4622      	mov	r2, r4
 8022b26:	2101      	movs	r1, #1
 8022b28:	4608      	mov	r0, r1
 8022b2a:	f7fc fc41 	bl	801f3b0 <traceIF_itmPrint>
 8022b2e:	4620      	mov	r0, r4
 8022b30:	f7fc fbfb 	bl	801f32a <crs_strlen>
 8022b34:	b283      	uxth	r3, r0
 8022b36:	4622      	mov	r2, r4
 8022b38:	2101      	movs	r1, #1
 8022b3a:	4608      	mov	r0, r1
 8022b3c:	f7fc fc5a 	bl	801f3f4 <traceIF_uartPrint>
    accelerometer_info.accelerometer.AXIS_Z  =  ACC_Value.z;
    (void)dc_com_write(&dc_com_db, DC_COM_ACCELEROMETER, (void *)&accelerometer_info, sizeof(accelerometer_info));
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
}
 8022b40:	bd38      	pop	{r3, r4, r5, pc}
 8022b42:	bf00      	nop
 8022b44:	200047dc 	.word	0x200047dc
 8022b48:	08036ce4 	.word	0x08036ce4

08022b4c <mems_get_pressure_datas>:
    success = 1U;
  }
#elif defined (USE_STM32L475E_IOT01)|| defined (USE_STM32L462E_CELL01) /* USE B-L475E-IOT1 MEMS */
  static float_t PRESSURE_Value; /*!< Pressure Value */
  dc_pressure_info_t        pressure_info;
  if (mems_init_status & FLAG_MEMS_PRESSURE)
 8022b4c:	4b1c      	ldr	r3, [pc, #112]	; (8022bc0 <mems_get_pressure_datas+0x74>)
 8022b4e:	7818      	ldrb	r0, [r3, #0]
 8022b50:	f010 0020 	ands.w	r0, r0, #32
 8022b54:	d100      	bne.n	8022b58 <mems_get_pressure_datas+0xc>
    success = 1U;
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
  return (success);
}
 8022b56:	4770      	bx	lr
{
 8022b58:	b530      	push	{r4, r5, lr}
 8022b5a:	b085      	sub	sp, #20
    PRESSURE_Value = BSP_PSENSOR_ReadPressure();
 8022b5c:	f7df f9c4 	bl	8001ee8 <BSP_PSENSOR_ReadPressure>
 8022b60:	ee10 0a10 	vmov	r0, s0
 8022b64:	4d17      	ldr	r5, [pc, #92]	; (8022bc4 <mems_get_pressure_datas+0x78>)
 8022b66:	ed85 0a00 	vstr	s0, [r5]
    PRINT_DBG("### PRESSURE_Value = %f\n\r", PRESSURE_Value)
 8022b6a:	f7dd fd05 	bl	8000578 <__aeabi_f2d>
 8022b6e:	4602      	mov	r2, r0
 8022b70:	460b      	mov	r3, r1
 8022b72:	4c15      	ldr	r4, [pc, #84]	; (8022bc8 <mems_get_pressure_datas+0x7c>)
 8022b74:	4915      	ldr	r1, [pc, #84]	; (8022bcc <mems_get_pressure_datas+0x80>)
 8022b76:	4620      	mov	r0, r4
 8022b78:	f003 fe66 	bl	8026848 <sprintf>
 8022b7c:	4620      	mov	r0, r4
 8022b7e:	f7fc fbd4 	bl	801f32a <crs_strlen>
 8022b82:	b283      	uxth	r3, r0
 8022b84:	4622      	mov	r2, r4
 8022b86:	2102      	movs	r1, #2
 8022b88:	2001      	movs	r0, #1
 8022b8a:	f7fc fc11 	bl	801f3b0 <traceIF_itmPrint>
 8022b8e:	4620      	mov	r0, r4
 8022b90:	f7fc fbcb 	bl	801f32a <crs_strlen>
 8022b94:	b283      	uxth	r3, r0
 8022b96:	4622      	mov	r2, r4
 8022b98:	2102      	movs	r1, #2
 8022b9a:	2001      	movs	r0, #1
 8022b9c:	f7fc fc2a 	bl	801f3f4 <traceIF_uartPrint>
    pressure_info.rt_state         =  DC_SERVICE_ON;
 8022ba0:	2307      	movs	r3, #7
 8022ba2:	f88d 3008 	strb.w	r3, [sp, #8]
    pressure_info.pressure         =  PRESSURE_Value;
 8022ba6:	682b      	ldr	r3, [r5, #0]
 8022ba8:	9303      	str	r3, [sp, #12]
    dc_com_write(&dc_com_db, DC_COM_PRESSURE, (void *)&pressure_info, sizeof(pressure_info));
 8022baa:	2310      	movs	r3, #16
 8022bac:	466a      	mov	r2, sp
 8022bae:	4908      	ldr	r1, [pc, #32]	; (8022bd0 <mems_get_pressure_datas+0x84>)
 8022bb0:	8809      	ldrh	r1, [r1, #0]
 8022bb2:	4808      	ldr	r0, [pc, #32]	; (8022bd4 <mems_get_pressure_datas+0x88>)
 8022bb4:	f7ff fa70 	bl	8022098 <dc_com_write>
    success = 1U;
 8022bb8:	2001      	movs	r0, #1
}
 8022bba:	b005      	add	sp, #20
 8022bbc:	bd30      	pop	{r4, r5, pc}
 8022bbe:	bf00      	nop
 8022bc0:	20005c94 	.word	0x20005c94
 8022bc4:	20005c10 	.word	0x20005c10
 8022bc8:	200047dc 	.word	0x200047dc
 8022bcc:	08036cfc 	.word	0x08036cfc
 8022bd0:	20000248 	.word	0x20000248
 8022bd4:	200058b0 	.word	0x200058b0

08022bd8 <mems_get_humidity_datas>:
    success = 1U;
  }
#elif defined (USE_STM32L475E_IOT01) || defined (USE_STM32L462E_CELL01) /* USE B-L475E-IOT1 MEMS */
  static float_t HUMIDITY_Value;    /*!< Humidity Value */
  dc_humidity_info_t        humidity_info;
  if (mems_init_status & FLAG_MEMS_HUMIDTY)
 8022bd8:	4b1c      	ldr	r3, [pc, #112]	; (8022c4c <mems_get_humidity_datas+0x74>)
 8022bda:	7818      	ldrb	r0, [r3, #0]
 8022bdc:	f010 0008 	ands.w	r0, r0, #8
 8022be0:	d100      	bne.n	8022be4 <mems_get_humidity_datas+0xc>
    success = 1U;
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
  return (success);
}
 8022be2:	4770      	bx	lr
{
 8022be4:	b530      	push	{r4, r5, lr}
 8022be6:	b085      	sub	sp, #20
    HUMIDITY_Value = BSP_HSENSOR_ReadHumidity();
 8022be8:	f7df f95e 	bl	8001ea8 <BSP_HSENSOR_ReadHumidity>
 8022bec:	ee10 0a10 	vmov	r0, s0
 8022bf0:	4d17      	ldr	r5, [pc, #92]	; (8022c50 <mems_get_humidity_datas+0x78>)
 8022bf2:	ed85 0a00 	vstr	s0, [r5]
    PRINT_DBG("### HUMIDITY_Value = %f\n\r", HUMIDITY_Value)
 8022bf6:	f7dd fcbf 	bl	8000578 <__aeabi_f2d>
 8022bfa:	4602      	mov	r2, r0
 8022bfc:	460b      	mov	r3, r1
 8022bfe:	4c15      	ldr	r4, [pc, #84]	; (8022c54 <mems_get_humidity_datas+0x7c>)
 8022c00:	4915      	ldr	r1, [pc, #84]	; (8022c58 <mems_get_humidity_datas+0x80>)
 8022c02:	4620      	mov	r0, r4
 8022c04:	f003 fe20 	bl	8026848 <sprintf>
 8022c08:	4620      	mov	r0, r4
 8022c0a:	f7fc fb8e 	bl	801f32a <crs_strlen>
 8022c0e:	b283      	uxth	r3, r0
 8022c10:	4622      	mov	r2, r4
 8022c12:	2102      	movs	r1, #2
 8022c14:	2001      	movs	r0, #1
 8022c16:	f7fc fbcb 	bl	801f3b0 <traceIF_itmPrint>
 8022c1a:	4620      	mov	r0, r4
 8022c1c:	f7fc fb85 	bl	801f32a <crs_strlen>
 8022c20:	b283      	uxth	r3, r0
 8022c22:	4622      	mov	r2, r4
 8022c24:	2102      	movs	r1, #2
 8022c26:	2001      	movs	r0, #1
 8022c28:	f7fc fbe4 	bl	801f3f4 <traceIF_uartPrint>
    humidity_info.rt_state         =  DC_SERVICE_ON;
 8022c2c:	2307      	movs	r3, #7
 8022c2e:	f88d 3008 	strb.w	r3, [sp, #8]
    humidity_info.humidity         =  HUMIDITY_Value;
 8022c32:	682b      	ldr	r3, [r5, #0]
 8022c34:	9303      	str	r3, [sp, #12]
    dc_com_write(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8022c36:	2310      	movs	r3, #16
 8022c38:	466a      	mov	r2, sp
 8022c3a:	4908      	ldr	r1, [pc, #32]	; (8022c5c <mems_get_humidity_datas+0x84>)
 8022c3c:	8809      	ldrh	r1, [r1, #0]
 8022c3e:	4808      	ldr	r0, [pc, #32]	; (8022c60 <mems_get_humidity_datas+0x88>)
 8022c40:	f7ff fa2a 	bl	8022098 <dc_com_write>
    success = 1U;
 8022c44:	2001      	movs	r0, #1
}
 8022c46:	b005      	add	sp, #20
 8022c48:	bd30      	pop	{r4, r5, pc}
 8022c4a:	bf00      	nop
 8022c4c:	20005c94 	.word	0x20005c94
 8022c50:	20005c0c 	.word	0x20005c0c
 8022c54:	200047dc 	.word	0x200047dc
 8022c58:	08036d20 	.word	0x08036d20
 8022c5c:	20000244 	.word	0x20000244
 8022c60:	200058b0 	.word	0x200058b0

08022c64 <mems_get_temperature_datas>:
    success = 1U;
  }
#elif defined (USE_STM32L475E_IOT01) || defined (USE_STM32L462E_CELL01)/* USE B-L475E-IOT1 MEMS */
  static float_t TEMPERATURE_Value;    /*!< Temperature Value */
  dc_temperature_info_t     temperature_info;
  if (mems_init_status & FLAG_MEMS_TEMPERATURE)
 8022c64:	4b1c      	ldr	r3, [pc, #112]	; (8022cd8 <mems_get_temperature_datas+0x74>)
 8022c66:	7818      	ldrb	r0, [r3, #0]
 8022c68:	f010 0010 	ands.w	r0, r0, #16
 8022c6c:	d100      	bne.n	8022c70 <mems_get_temperature_datas+0xc>
    success = 1U;
  }
#endif /* USE_STM32L475E_IOT01 */
#endif /* USE_DC_MEMS */
  return (success);
}
 8022c6e:	4770      	bx	lr
{
 8022c70:	b530      	push	{r4, r5, lr}
 8022c72:	b085      	sub	sp, #20
    TEMPERATURE_Value = BSP_TSENSOR_ReadTemp();
 8022c74:	f7df f954 	bl	8001f20 <BSP_TSENSOR_ReadTemp>
 8022c78:	ee10 0a10 	vmov	r0, s0
 8022c7c:	4d17      	ldr	r5, [pc, #92]	; (8022cdc <mems_get_temperature_datas+0x78>)
 8022c7e:	ed85 0a00 	vstr	s0, [r5]
    PRINT_DBG("### TEMPERATURE_Value = %f\n\r", TEMPERATURE_Value)
 8022c82:	f7dd fc79 	bl	8000578 <__aeabi_f2d>
 8022c86:	4602      	mov	r2, r0
 8022c88:	460b      	mov	r3, r1
 8022c8a:	4c15      	ldr	r4, [pc, #84]	; (8022ce0 <mems_get_temperature_datas+0x7c>)
 8022c8c:	4915      	ldr	r1, [pc, #84]	; (8022ce4 <mems_get_temperature_datas+0x80>)
 8022c8e:	4620      	mov	r0, r4
 8022c90:	f003 fdda 	bl	8026848 <sprintf>
 8022c94:	4620      	mov	r0, r4
 8022c96:	f7fc fb48 	bl	801f32a <crs_strlen>
 8022c9a:	b283      	uxth	r3, r0
 8022c9c:	4622      	mov	r2, r4
 8022c9e:	2102      	movs	r1, #2
 8022ca0:	2001      	movs	r0, #1
 8022ca2:	f7fc fb85 	bl	801f3b0 <traceIF_itmPrint>
 8022ca6:	4620      	mov	r0, r4
 8022ca8:	f7fc fb3f 	bl	801f32a <crs_strlen>
 8022cac:	b283      	uxth	r3, r0
 8022cae:	4622      	mov	r2, r4
 8022cb0:	2102      	movs	r1, #2
 8022cb2:	2001      	movs	r0, #1
 8022cb4:	f7fc fb9e 	bl	801f3f4 <traceIF_uartPrint>
    temperature_info.rt_state         =  DC_SERVICE_ON;
 8022cb8:	2307      	movs	r3, #7
 8022cba:	f88d 3008 	strb.w	r3, [sp, #8]
    temperature_info.temperature      =  TEMPERATURE_Value;
 8022cbe:	682b      	ldr	r3, [r5, #0]
 8022cc0:	9303      	str	r3, [sp, #12]
    dc_com_write(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8022cc2:	2310      	movs	r3, #16
 8022cc4:	466a      	mov	r2, sp
 8022cc6:	4908      	ldr	r1, [pc, #32]	; (8022ce8 <mems_get_temperature_datas+0x84>)
 8022cc8:	8809      	ldrh	r1, [r1, #0]
 8022cca:	4808      	ldr	r0, [pc, #32]	; (8022cec <mems_get_temperature_datas+0x88>)
 8022ccc:	f7ff f9e4 	bl	8022098 <dc_com_write>
    success = 1U;
 8022cd0:	2001      	movs	r0, #1
}
 8022cd2:	b005      	add	sp, #20
 8022cd4:	bd30      	pop	{r4, r5, pc}
 8022cd6:	bf00      	nop
 8022cd8:	20005c94 	.word	0x20005c94
 8022cdc:	20005c14 	.word	0x20005c14
 8022ce0:	200047dc 	.word	0x200047dc
 8022ce4:	08036d44 	.word	0x08036d44
 8022ce8:	2000024a 	.word	0x2000024a
 8022cec:	200058b0 	.word	0x200058b0

08022cf0 <StartMemsDclibTask>:
{
 8022cf0:	b508      	push	{r3, lr}
  mems_init_sensors();
 8022cf2:	f7ff feeb 	bl	8022acc <mems_init_sensors>
  (void)rtosalDelay(1000U);
 8022cf6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8022cfa:	f7fc fa6e 	bl	801f1da <rtosalDelay>
 8022cfe:	e00b      	b.n	8022d18 <StartMemsDclibTask+0x28>
      mems_get_acc_datas();
 8022d00:	f7ff ff00 	bl	8022b04 <mems_get_acc_datas>
      if (mems_get_pressure_datas() != 1U)
 8022d04:	f7ff ff22 	bl	8022b4c <mems_get_pressure_datas>
      if (mems_get_humidity_datas() != 1U)
 8022d08:	f7ff ff66 	bl	8022bd8 <mems_get_humidity_datas>
      if (mems_get_temperature_datas() != 1U)
 8022d0c:	f7ff ffaa 	bl	8022c64 <mems_get_temperature_datas>
    (void)rtosalDelay(mems_polling_period);
 8022d10:	4b04      	ldr	r3, [pc, #16]	; (8022d24 <StartMemsDclibTask+0x34>)
 8022d12:	6818      	ldr	r0, [r3, #0]
 8022d14:	f7fc fa61 	bl	801f1da <rtosalDelay>
    if (mems_state == 0U)
 8022d18:	4b03      	ldr	r3, [pc, #12]	; (8022d28 <StartMemsDclibTask+0x38>)
 8022d1a:	681b      	ldr	r3, [r3, #0]
 8022d1c:	2b00      	cmp	r3, #0
 8022d1e:	d0ef      	beq.n	8022d00 <StartMemsDclibTask+0x10>
 8022d20:	e7f6      	b.n	8022d10 <StartMemsDclibTask+0x20>
 8022d22:	bf00      	nop
 8022d24:	20005c98 	.word	0x20005c98
 8022d28:	20005c9c 	.word	0x20005c9c

08022d2c <mems_cmd_help>:
{
 8022d2c:	b538      	push	{r3, r4, r5, lr}
  CMD_print_help(mems_cmd_label);
 8022d2e:	4d7c      	ldr	r5, [pc, #496]	; (8022f20 <mems_cmd_help+0x1f4>)
 8022d30:	4628      	mov	r0, r5
 8022d32:	f7ff fe41 	bl	80229b8 <CMD_print_help>
  PRINT_FORCE("%s help", mems_cmd_label);
 8022d36:	4c7b      	ldr	r4, [pc, #492]	; (8022f24 <mems_cmd_help+0x1f8>)
 8022d38:	462a      	mov	r2, r5
 8022d3a:	497b      	ldr	r1, [pc, #492]	; (8022f28 <mems_cmd_help+0x1fc>)
 8022d3c:	4620      	mov	r0, r4
 8022d3e:	f003 fd83 	bl	8026848 <sprintf>
 8022d42:	4620      	mov	r0, r4
 8022d44:	f7fc faf1 	bl	801f32a <crs_strlen>
 8022d48:	b283      	uxth	r3, r0
 8022d4a:	4622      	mov	r2, r4
 8022d4c:	2101      	movs	r1, #1
 8022d4e:	4608      	mov	r0, r1
 8022d50:	f7fc fb2e 	bl	801f3b0 <traceIF_itmPrint>
 8022d54:	4620      	mov	r0, r4
 8022d56:	f7fc fae8 	bl	801f32a <crs_strlen>
 8022d5a:	b282      	uxth	r2, r0
 8022d5c:	4621      	mov	r1, r4
 8022d5e:	2001      	movs	r0, #1
 8022d60:	f7fc fb60 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s state (state of mems software component)", mems_cmd_label);
 8022d64:	462a      	mov	r2, r5
 8022d66:	4971      	ldr	r1, [pc, #452]	; (8022f2c <mems_cmd_help+0x200>)
 8022d68:	4620      	mov	r0, r4
 8022d6a:	f003 fd6d 	bl	8026848 <sprintf>
 8022d6e:	4620      	mov	r0, r4
 8022d70:	f7fc fadb 	bl	801f32a <crs_strlen>
 8022d74:	b283      	uxth	r3, r0
 8022d76:	4622      	mov	r2, r4
 8022d78:	2101      	movs	r1, #1
 8022d7a:	4608      	mov	r0, r1
 8022d7c:	f7fc fb18 	bl	801f3b0 <traceIF_itmPrint>
 8022d80:	4620      	mov	r0, r4
 8022d82:	f7fc fad2 	bl	801f32a <crs_strlen>
 8022d86:	b282      	uxth	r2, r0
 8022d88:	4621      	mov	r1, r4
 8022d8a:	2001      	movs	r0, #1
 8022d8c:	f7fc fb4a 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s disable (disable mems process)", mems_cmd_label);
 8022d90:	462a      	mov	r2, r5
 8022d92:	4967      	ldr	r1, [pc, #412]	; (8022f30 <mems_cmd_help+0x204>)
 8022d94:	4620      	mov	r0, r4
 8022d96:	f003 fd57 	bl	8026848 <sprintf>
 8022d9a:	4620      	mov	r0, r4
 8022d9c:	f7fc fac5 	bl	801f32a <crs_strlen>
 8022da0:	b283      	uxth	r3, r0
 8022da2:	4622      	mov	r2, r4
 8022da4:	2101      	movs	r1, #1
 8022da6:	4608      	mov	r0, r1
 8022da8:	f7fc fb02 	bl	801f3b0 <traceIF_itmPrint>
 8022dac:	4620      	mov	r0, r4
 8022dae:	f7fc fabc 	bl	801f32a <crs_strlen>
 8022db2:	b282      	uxth	r2, r0
 8022db4:	4621      	mov	r1, r4
 8022db6:	2001      	movs	r0, #1
 8022db8:	f7fc fb34 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s enable (enable mems process)", mems_cmd_label);
 8022dbc:	462a      	mov	r2, r5
 8022dbe:	495d      	ldr	r1, [pc, #372]	; (8022f34 <mems_cmd_help+0x208>)
 8022dc0:	4620      	mov	r0, r4
 8022dc2:	f003 fd41 	bl	8026848 <sprintf>
 8022dc6:	4620      	mov	r0, r4
 8022dc8:	f7fc faaf 	bl	801f32a <crs_strlen>
 8022dcc:	b283      	uxth	r3, r0
 8022dce:	4622      	mov	r2, r4
 8022dd0:	2101      	movs	r1, #1
 8022dd2:	4608      	mov	r0, r1
 8022dd4:	f7fc faec 	bl	801f3b0 <traceIF_itmPrint>
 8022dd8:	4620      	mov	r0, r4
 8022dda:	f7fc faa6 	bl	801f32a <crs_strlen>
 8022dde:	b282      	uxth	r2, r0
 8022de0:	4621      	mov	r1, r4
 8022de2:	2001      	movs	r0, #1
 8022de4:	f7fc fb1e 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s period [<ms>] (set/get mems process period)", mems_cmd_label);
 8022de8:	462a      	mov	r2, r5
 8022dea:	4953      	ldr	r1, [pc, #332]	; (8022f38 <mems_cmd_help+0x20c>)
 8022dec:	4620      	mov	r0, r4
 8022dee:	f003 fd2b 	bl	8026848 <sprintf>
 8022df2:	4620      	mov	r0, r4
 8022df4:	f7fc fa99 	bl	801f32a <crs_strlen>
 8022df8:	b283      	uxth	r3, r0
 8022dfa:	4622      	mov	r2, r4
 8022dfc:	2101      	movs	r1, #1
 8022dfe:	4608      	mov	r0, r1
 8022e00:	f7fc fad6 	bl	801f3b0 <traceIF_itmPrint>
 8022e04:	4620      	mov	r0, r4
 8022e06:	f7fc fa90 	bl	801f32a <crs_strlen>
 8022e0a:	b282      	uxth	r2, r0
 8022e0c:	4621      	mov	r1, r4
 8022e0e:	2001      	movs	r0, #1
 8022e10:	f7fc fb08 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s pressure (get current pressure value)", mems_cmd_label);
 8022e14:	462a      	mov	r2, r5
 8022e16:	4949      	ldr	r1, [pc, #292]	; (8022f3c <mems_cmd_help+0x210>)
 8022e18:	4620      	mov	r0, r4
 8022e1a:	f003 fd15 	bl	8026848 <sprintf>
 8022e1e:	4620      	mov	r0, r4
 8022e20:	f7fc fa83 	bl	801f32a <crs_strlen>
 8022e24:	b283      	uxth	r3, r0
 8022e26:	4622      	mov	r2, r4
 8022e28:	2101      	movs	r1, #1
 8022e2a:	4608      	mov	r0, r1
 8022e2c:	f7fc fac0 	bl	801f3b0 <traceIF_itmPrint>
 8022e30:	4620      	mov	r0, r4
 8022e32:	f7fc fa7a 	bl	801f32a <crs_strlen>
 8022e36:	b282      	uxth	r2, r0
 8022e38:	4621      	mov	r1, r4
 8022e3a:	2001      	movs	r0, #1
 8022e3c:	f7fc faf2 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s pressure <ppp>  (set pressure value and disable mems process)", mems_cmd_label);
 8022e40:	462a      	mov	r2, r5
 8022e42:	493f      	ldr	r1, [pc, #252]	; (8022f40 <mems_cmd_help+0x214>)
 8022e44:	4620      	mov	r0, r4
 8022e46:	f003 fcff 	bl	8026848 <sprintf>
 8022e4a:	4620      	mov	r0, r4
 8022e4c:	f7fc fa6d 	bl	801f32a <crs_strlen>
 8022e50:	b283      	uxth	r3, r0
 8022e52:	4622      	mov	r2, r4
 8022e54:	2101      	movs	r1, #1
 8022e56:	4608      	mov	r0, r1
 8022e58:	f7fc faaa 	bl	801f3b0 <traceIF_itmPrint>
 8022e5c:	4620      	mov	r0, r4
 8022e5e:	f7fc fa64 	bl	801f32a <crs_strlen>
 8022e62:	b282      	uxth	r2, r0
 8022e64:	4621      	mov	r1, r4
 8022e66:	2001      	movs	r0, #1
 8022e68:	f7fc fadc 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s temperature (get current temperature value)", mems_cmd_label);
 8022e6c:	462a      	mov	r2, r5
 8022e6e:	4935      	ldr	r1, [pc, #212]	; (8022f44 <mems_cmd_help+0x218>)
 8022e70:	4620      	mov	r0, r4
 8022e72:	f003 fce9 	bl	8026848 <sprintf>
 8022e76:	4620      	mov	r0, r4
 8022e78:	f7fc fa57 	bl	801f32a <crs_strlen>
 8022e7c:	b283      	uxth	r3, r0
 8022e7e:	4622      	mov	r2, r4
 8022e80:	2101      	movs	r1, #1
 8022e82:	4608      	mov	r0, r1
 8022e84:	f7fc fa94 	bl	801f3b0 <traceIF_itmPrint>
 8022e88:	4620      	mov	r0, r4
 8022e8a:	f7fc fa4e 	bl	801f32a <crs_strlen>
 8022e8e:	b282      	uxth	r2, r0
 8022e90:	4621      	mov	r1, r4
 8022e92:	2001      	movs	r0, #1
 8022e94:	f7fc fac6 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s temperature <ttt> (set temperature value and disable mems process)", mems_cmd_label);
 8022e98:	462a      	mov	r2, r5
 8022e9a:	492b      	ldr	r1, [pc, #172]	; (8022f48 <mems_cmd_help+0x21c>)
 8022e9c:	4620      	mov	r0, r4
 8022e9e:	f003 fcd3 	bl	8026848 <sprintf>
 8022ea2:	4620      	mov	r0, r4
 8022ea4:	f7fc fa41 	bl	801f32a <crs_strlen>
 8022ea8:	b283      	uxth	r3, r0
 8022eaa:	4622      	mov	r2, r4
 8022eac:	2101      	movs	r1, #1
 8022eae:	4608      	mov	r0, r1
 8022eb0:	f7fc fa7e 	bl	801f3b0 <traceIF_itmPrint>
 8022eb4:	4620      	mov	r0, r4
 8022eb6:	f7fc fa38 	bl	801f32a <crs_strlen>
 8022eba:	b282      	uxth	r2, r0
 8022ebc:	4621      	mov	r1, r4
 8022ebe:	2001      	movs	r0, #1
 8022ec0:	f7fc fab0 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s humidity (get current humidity value)", mems_cmd_label);
 8022ec4:	462a      	mov	r2, r5
 8022ec6:	4921      	ldr	r1, [pc, #132]	; (8022f4c <mems_cmd_help+0x220>)
 8022ec8:	4620      	mov	r0, r4
 8022eca:	f003 fcbd 	bl	8026848 <sprintf>
 8022ece:	4620      	mov	r0, r4
 8022ed0:	f7fc fa2b 	bl	801f32a <crs_strlen>
 8022ed4:	b283      	uxth	r3, r0
 8022ed6:	4622      	mov	r2, r4
 8022ed8:	2101      	movs	r1, #1
 8022eda:	4608      	mov	r0, r1
 8022edc:	f7fc fa68 	bl	801f3b0 <traceIF_itmPrint>
 8022ee0:	4620      	mov	r0, r4
 8022ee2:	f7fc fa22 	bl	801f32a <crs_strlen>
 8022ee6:	b282      	uxth	r2, r0
 8022ee8:	4621      	mov	r1, r4
 8022eea:	2001      	movs	r0, #1
 8022eec:	f7fc fa9a 	bl	801f424 <traceIF_uartPrintForce>
  PRINT_FORCE("%s humidity <hhh> (set humidity value and disable mems process)", mems_cmd_label);
 8022ef0:	462a      	mov	r2, r5
 8022ef2:	4917      	ldr	r1, [pc, #92]	; (8022f50 <mems_cmd_help+0x224>)
 8022ef4:	4620      	mov	r0, r4
 8022ef6:	f003 fca7 	bl	8026848 <sprintf>
 8022efa:	4620      	mov	r0, r4
 8022efc:	f7fc fa15 	bl	801f32a <crs_strlen>
 8022f00:	b283      	uxth	r3, r0
 8022f02:	4622      	mov	r2, r4
 8022f04:	2101      	movs	r1, #1
 8022f06:	4608      	mov	r0, r1
 8022f08:	f7fc fa52 	bl	801f3b0 <traceIF_itmPrint>
 8022f0c:	4620      	mov	r0, r4
 8022f0e:	f7fc fa0c 	bl	801f32a <crs_strlen>
 8022f12:	b282      	uxth	r2, r0
 8022f14:	4621      	mov	r1, r4
 8022f16:	2001      	movs	r0, #1
 8022f18:	f7fc fa84 	bl	801f424 <traceIF_uartPrintForce>
}
 8022f1c:	bd38      	pop	{r3, r4, r5, pc}
 8022f1e:	bf00      	nop
 8022f20:	08036d68 	.word	0x08036d68
 8022f24:	200047dc 	.word	0x200047dc
 8022f28:	08033524 	.word	0x08033524
 8022f2c:	08036d70 	.word	0x08036d70
 8022f30:	08036da0 	.word	0x08036da0
 8022f34:	08036dc4 	.word	0x08036dc4
 8022f38:	08036de8 	.word	0x08036de8
 8022f3c:	08036e1c 	.word	0x08036e1c
 8022f40:	08036e48 	.word	0x08036e48
 8022f44:	08036e8c 	.word	0x08036e8c
 8022f48:	08036ec0 	.word	0x08036ec0
 8022f4c:	08036f08 	.word	0x08036f08
 8022f50:	08036f34 	.word	0x08036f34

08022f54 <mems_cmd>:
{
 8022f54:	b570      	push	{r4, r5, r6, lr}
 8022f56:	b096      	sub	sp, #88	; 0x58
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8022f58:	49b1      	ldr	r1, [pc, #708]	; (8023220 <mems_cmd+0x2cc>)
 8022f5a:	f003 fd03 	bl	8026964 <strtok>
  if (cmd_p == NULL)
 8022f5e:	b160      	cbz	r0, 8022f7a <mems_cmd+0x26>
 8022f60:	4605      	mov	r5, r0
  else if (memcmp((CRC_CHAR_t *)cmd_p, (CRC_CHAR_t *)mems_cmd_label, crs_strlen(cmd_p)) == 0)
 8022f62:	f7fc f9e2 	bl	801f32a <crs_strlen>
 8022f66:	4602      	mov	r2, r0
 8022f68:	49ae      	ldr	r1, [pc, #696]	; (8023224 <mems_cmd+0x2d0>)
 8022f6a:	4628      	mov	r0, r5
 8022f6c:	f003 fccf 	bl	802690e <memcmp>
 8022f70:	b1f0      	cbz	r0, 8022fb0 <mems_cmd+0x5c>
    __NOP();
 8022f72:	bf00      	nop
}
 8022f74:	2000      	movs	r0, #0
 8022f76:	b016      	add	sp, #88	; 0x58
 8022f78:	bd70      	pop	{r4, r5, r6, pc}
    PRINT_FORCE("bad command\n\r");
 8022f7a:	4cab      	ldr	r4, [pc, #684]	; (8023228 <mems_cmd+0x2d4>)
 8022f7c:	4dab      	ldr	r5, [pc, #684]	; (802322c <mems_cmd+0x2d8>)
 8022f7e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8022f80:	6020      	str	r0, [r4, #0]
 8022f82:	6061      	str	r1, [r4, #4]
 8022f84:	60a2      	str	r2, [r4, #8]
 8022f86:	60e3      	str	r3, [r4, #12]
 8022f88:	4620      	mov	r0, r4
 8022f8a:	f7fc f9ce 	bl	801f32a <crs_strlen>
 8022f8e:	b283      	uxth	r3, r0
 8022f90:	4622      	mov	r2, r4
 8022f92:	2101      	movs	r1, #1
 8022f94:	4608      	mov	r0, r1
 8022f96:	f7fc fa0b 	bl	801f3b0 <traceIF_itmPrint>
 8022f9a:	4620      	mov	r0, r4
 8022f9c:	f7fc f9c5 	bl	801f32a <crs_strlen>
 8022fa0:	b282      	uxth	r2, r0
 8022fa2:	4621      	mov	r1, r4
 8022fa4:	2001      	movs	r0, #1
 8022fa6:	f7fc fa3d 	bl	801f424 <traceIF_uartPrintForce>
    mems_cmd_help();
 8022faa:	f7ff febf 	bl	8022d2c <mems_cmd_help>
 8022fae:	e7e1      	b.n	8022f74 <mems_cmd+0x20>
    for (argc = 0U ; argc < 10U ; argc++)
 8022fb0:	2400      	movs	r4, #0
 8022fb2:	2c09      	cmp	r4, #9
 8022fb4:	d80b      	bhi.n	8022fce <mems_cmd+0x7a>
      argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 8022fb6:	499a      	ldr	r1, [pc, #616]	; (8023220 <mems_cmd+0x2cc>)
 8022fb8:	2000      	movs	r0, #0
 8022fba:	f003 fcd3 	bl	8026964 <strtok>
 8022fbe:	ab16      	add	r3, sp, #88	; 0x58
 8022fc0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8022fc4:	f843 0c28 	str.w	r0, [r3, #-40]
      if (argv_p[argc] == NULL)
 8022fc8:	b108      	cbz	r0, 8022fce <mems_cmd+0x7a>
    for (argc = 0U ; argc < 10U ; argc++)
 8022fca:	3401      	adds	r4, #1
 8022fcc:	e7f1      	b.n	8022fb2 <mems_cmd+0x5e>
    if (argc == 0U)
 8022fce:	b914      	cbnz	r4, 8022fd6 <mems_cmd+0x82>
      mems_cmd_help();
 8022fd0:	f7ff feac 	bl	8022d2c <mems_cmd_help>
 8022fd4:	e7ce      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "help", crs_strlen(argv_p[0])) == 0)
 8022fd6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8022fd8:	4630      	mov	r0, r6
 8022fda:	f7fc f9a6 	bl	801f32a <crs_strlen>
 8022fde:	4602      	mov	r2, r0
 8022fe0:	4993      	ldr	r1, [pc, #588]	; (8023230 <mems_cmd+0x2dc>)
 8022fe2:	4630      	mov	r0, r6
 8022fe4:	f003 fc93 	bl	802690e <memcmp>
 8022fe8:	b910      	cbnz	r0, 8022ff0 <mems_cmd+0x9c>
      mems_cmd_help();
 8022fea:	f7ff fe9f 	bl	8022d2c <mems_cmd_help>
 8022fee:	e7c1      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "state", crs_strlen(argv_p[0])) == 0)
 8022ff0:	4630      	mov	r0, r6
 8022ff2:	f7fc f99a 	bl	801f32a <crs_strlen>
 8022ff6:	4602      	mov	r2, r0
 8022ff8:	498e      	ldr	r1, [pc, #568]	; (8023234 <mems_cmd+0x2e0>)
 8022ffa:	4630      	mov	r0, r6
 8022ffc:	f003 fc87 	bl	802690e <memcmp>
 8023000:	2800      	cmp	r0, #0
 8023002:	d14f      	bne.n	80230a4 <mems_cmd+0x150>
      if (mems_state == 1U)
 8023004:	4b8c      	ldr	r3, [pc, #560]	; (8023238 <mems_cmd+0x2e4>)
 8023006:	681b      	ldr	r3, [r3, #0]
 8023008:	2b01      	cmp	r3, #1
 802300a:	d032      	beq.n	8023072 <mems_cmd+0x11e>
        PRINT_FORCE("mems enabled");
 802300c:	4c86      	ldr	r4, [pc, #536]	; (8023228 <mems_cmd+0x2d4>)
 802300e:	4b8b      	ldr	r3, [pc, #556]	; (802323c <mems_cmd+0x2e8>)
 8023010:	cb07      	ldmia	r3!, {r0, r1, r2}
 8023012:	6020      	str	r0, [r4, #0]
 8023014:	6061      	str	r1, [r4, #4]
 8023016:	60a2      	str	r2, [r4, #8]
 8023018:	881a      	ldrh	r2, [r3, #0]
 802301a:	789b      	ldrb	r3, [r3, #2]
 802301c:	81a2      	strh	r2, [r4, #12]
 802301e:	73a3      	strb	r3, [r4, #14]
 8023020:	4620      	mov	r0, r4
 8023022:	f7fc f982 	bl	801f32a <crs_strlen>
 8023026:	b283      	uxth	r3, r0
 8023028:	4622      	mov	r2, r4
 802302a:	2101      	movs	r1, #1
 802302c:	4608      	mov	r0, r1
 802302e:	f7fc f9bf 	bl	801f3b0 <traceIF_itmPrint>
 8023032:	4620      	mov	r0, r4
 8023034:	f7fc f979 	bl	801f32a <crs_strlen>
 8023038:	b282      	uxth	r2, r0
 802303a:	4621      	mov	r1, r4
 802303c:	2001      	movs	r0, #1
 802303e:	f7fc f9f1 	bl	801f424 <traceIF_uartPrintForce>
        PRINT_FORCE("polling period: %ld", mems_polling_period);
 8023042:	4b7f      	ldr	r3, [pc, #508]	; (8023240 <mems_cmd+0x2ec>)
 8023044:	681a      	ldr	r2, [r3, #0]
 8023046:	497f      	ldr	r1, [pc, #508]	; (8023244 <mems_cmd+0x2f0>)
 8023048:	4620      	mov	r0, r4
 802304a:	f003 fbfd 	bl	8026848 <sprintf>
 802304e:	4620      	mov	r0, r4
 8023050:	f7fc f96b 	bl	801f32a <crs_strlen>
 8023054:	b283      	uxth	r3, r0
 8023056:	4622      	mov	r2, r4
 8023058:	2101      	movs	r1, #1
 802305a:	4608      	mov	r0, r1
 802305c:	f7fc f9a8 	bl	801f3b0 <traceIF_itmPrint>
 8023060:	4620      	mov	r0, r4
 8023062:	f7fc f962 	bl	801f32a <crs_strlen>
 8023066:	b282      	uxth	r2, r0
 8023068:	4621      	mov	r1, r4
 802306a:	2001      	movs	r0, #1
 802306c:	f7fc f9da 	bl	801f424 <traceIF_uartPrintForce>
 8023070:	e780      	b.n	8022f74 <mems_cmd+0x20>
        PRINT_FORCE("mems disabled");
 8023072:	4c6d      	ldr	r4, [pc, #436]	; (8023228 <mems_cmd+0x2d4>)
 8023074:	4d74      	ldr	r5, [pc, #464]	; (8023248 <mems_cmd+0x2f4>)
 8023076:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023078:	6020      	str	r0, [r4, #0]
 802307a:	6061      	str	r1, [r4, #4]
 802307c:	60a2      	str	r2, [r4, #8]
 802307e:	60e3      	str	r3, [r4, #12]
 8023080:	4620      	mov	r0, r4
 8023082:	f7fc f952 	bl	801f32a <crs_strlen>
 8023086:	b283      	uxth	r3, r0
 8023088:	4622      	mov	r2, r4
 802308a:	2101      	movs	r1, #1
 802308c:	4608      	mov	r0, r1
 802308e:	f7fc f98f 	bl	801f3b0 <traceIF_itmPrint>
 8023092:	4620      	mov	r0, r4
 8023094:	f7fc f949 	bl	801f32a <crs_strlen>
 8023098:	b282      	uxth	r2, r0
 802309a:	4621      	mov	r1, r4
 802309c:	2001      	movs	r0, #1
 802309e:	f7fc f9c1 	bl	801f424 <traceIF_uartPrintForce>
 80230a2:	e767      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "enable", crs_strlen(argv_p[0])) == 0)
 80230a4:	4630      	mov	r0, r6
 80230a6:	f7fc f940 	bl	801f32a <crs_strlen>
 80230aa:	4602      	mov	r2, r0
 80230ac:	4967      	ldr	r1, [pc, #412]	; (802324c <mems_cmd+0x2f8>)
 80230ae:	4630      	mov	r0, r6
 80230b0:	f003 fc2d 	bl	802690e <memcmp>
 80230b4:	b9f0      	cbnz	r0, 80230f4 <mems_cmd+0x1a0>
      mems_state = 0U;
 80230b6:	4b60      	ldr	r3, [pc, #384]	; (8023238 <mems_cmd+0x2e4>)
 80230b8:	2200      	movs	r2, #0
 80230ba:	601a      	str	r2, [r3, #0]
      PRINT_FORCE("mems enabled");
 80230bc:	4c5a      	ldr	r4, [pc, #360]	; (8023228 <mems_cmd+0x2d4>)
 80230be:	4b5f      	ldr	r3, [pc, #380]	; (802323c <mems_cmd+0x2e8>)
 80230c0:	cb07      	ldmia	r3!, {r0, r1, r2}
 80230c2:	6020      	str	r0, [r4, #0]
 80230c4:	6061      	str	r1, [r4, #4]
 80230c6:	60a2      	str	r2, [r4, #8]
 80230c8:	881a      	ldrh	r2, [r3, #0]
 80230ca:	789b      	ldrb	r3, [r3, #2]
 80230cc:	81a2      	strh	r2, [r4, #12]
 80230ce:	73a3      	strb	r3, [r4, #14]
 80230d0:	4620      	mov	r0, r4
 80230d2:	f7fc f92a 	bl	801f32a <crs_strlen>
 80230d6:	b283      	uxth	r3, r0
 80230d8:	4622      	mov	r2, r4
 80230da:	2101      	movs	r1, #1
 80230dc:	4608      	mov	r0, r1
 80230de:	f7fc f967 	bl	801f3b0 <traceIF_itmPrint>
 80230e2:	4620      	mov	r0, r4
 80230e4:	f7fc f921 	bl	801f32a <crs_strlen>
 80230e8:	b282      	uxth	r2, r0
 80230ea:	4621      	mov	r1, r4
 80230ec:	2001      	movs	r0, #1
 80230ee:	f7fc f999 	bl	801f424 <traceIF_uartPrintForce>
 80230f2:	e73f      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "disable", crs_strlen(argv_p[0])) == 0)
 80230f4:	4630      	mov	r0, r6
 80230f6:	f7fc f918 	bl	801f32a <crs_strlen>
 80230fa:	4602      	mov	r2, r0
 80230fc:	4954      	ldr	r1, [pc, #336]	; (8023250 <mems_cmd+0x2fc>)
 80230fe:	4630      	mov	r0, r6
 8023100:	f003 fc05 	bl	802690e <memcmp>
 8023104:	b9d8      	cbnz	r0, 802313e <mems_cmd+0x1ea>
      mems_state = 1U;
 8023106:	2601      	movs	r6, #1
 8023108:	4b4b      	ldr	r3, [pc, #300]	; (8023238 <mems_cmd+0x2e4>)
 802310a:	601e      	str	r6, [r3, #0]
      PRINT_FORCE("mems disabled");
 802310c:	4c46      	ldr	r4, [pc, #280]	; (8023228 <mems_cmd+0x2d4>)
 802310e:	4d4e      	ldr	r5, [pc, #312]	; (8023248 <mems_cmd+0x2f4>)
 8023110:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023112:	6020      	str	r0, [r4, #0]
 8023114:	6061      	str	r1, [r4, #4]
 8023116:	60a2      	str	r2, [r4, #8]
 8023118:	60e3      	str	r3, [r4, #12]
 802311a:	4620      	mov	r0, r4
 802311c:	f7fc f905 	bl	801f32a <crs_strlen>
 8023120:	b283      	uxth	r3, r0
 8023122:	4622      	mov	r2, r4
 8023124:	4631      	mov	r1, r6
 8023126:	4630      	mov	r0, r6
 8023128:	f7fc f942 	bl	801f3b0 <traceIF_itmPrint>
 802312c:	4620      	mov	r0, r4
 802312e:	f7fc f8fc 	bl	801f32a <crs_strlen>
 8023132:	b282      	uxth	r2, r0
 8023134:	4621      	mov	r1, r4
 8023136:	4630      	mov	r0, r6
 8023138:	f7fc f974 	bl	801f424 <traceIF_uartPrintForce>
 802313c:	e71a      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "period", crs_strlen(argv_p[0])) == 0)
 802313e:	4630      	mov	r0, r6
 8023140:	f7fc f8f3 	bl	801f32a <crs_strlen>
 8023144:	4602      	mov	r2, r0
 8023146:	4943      	ldr	r1, [pc, #268]	; (8023254 <mems_cmd+0x300>)
 8023148:	4630      	mov	r0, r6
 802314a:	f003 fbe0 	bl	802690e <memcmp>
 802314e:	bb00      	cbnz	r0, 8023192 <mems_cmd+0x23e>
      if (argc == 2U)
 8023150:	2c02      	cmp	r4, #2
 8023152:	d018      	beq.n	8023186 <mems_cmd+0x232>
        PRINT_FORCE("mems polling period: %ld", mems_polling_period);
 8023154:	4c34      	ldr	r4, [pc, #208]	; (8023228 <mems_cmd+0x2d4>)
 8023156:	4b3a      	ldr	r3, [pc, #232]	; (8023240 <mems_cmd+0x2ec>)
 8023158:	681a      	ldr	r2, [r3, #0]
 802315a:	493f      	ldr	r1, [pc, #252]	; (8023258 <mems_cmd+0x304>)
 802315c:	4620      	mov	r0, r4
 802315e:	f003 fb73 	bl	8026848 <sprintf>
 8023162:	4620      	mov	r0, r4
 8023164:	f7fc f8e1 	bl	801f32a <crs_strlen>
 8023168:	b283      	uxth	r3, r0
 802316a:	4622      	mov	r2, r4
 802316c:	2101      	movs	r1, #1
 802316e:	4608      	mov	r0, r1
 8023170:	f7fc f91e 	bl	801f3b0 <traceIF_itmPrint>
 8023174:	4620      	mov	r0, r4
 8023176:	f7fc f8d8 	bl	801f32a <crs_strlen>
 802317a:	b282      	uxth	r2, r0
 802317c:	4621      	mov	r1, r4
 802317e:	2001      	movs	r0, #1
 8023180:	f7fc f950 	bl	801f424 <traceIF_uartPrintForce>
 8023184:	e6f6      	b.n	8022f74 <mems_cmd+0x20>
        mems_polling_period = (uint32_t)crs_atoi(argv_p[1]);
 8023186:	980d      	ldr	r0, [sp, #52]	; 0x34
 8023188:	f7fc f88a 	bl	801f2a0 <crs_atoi>
 802318c:	4b2c      	ldr	r3, [pc, #176]	; (8023240 <mems_cmd+0x2ec>)
 802318e:	6018      	str	r0, [r3, #0]
 8023190:	e6f0      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "pressure", crs_strlen(argv_p[0])) == 0)
 8023192:	4630      	mov	r0, r6
 8023194:	f7fc f8c9 	bl	801f32a <crs_strlen>
 8023198:	4602      	mov	r2, r0
 802319a:	4930      	ldr	r1, [pc, #192]	; (802325c <mems_cmd+0x308>)
 802319c:	4630      	mov	r0, r6
 802319e:	f003 fbb6 	bl	802690e <memcmp>
 80231a2:	2800      	cmp	r0, #0
 80231a4:	d17e      	bne.n	80232a4 <mems_cmd+0x350>
      if (argc == 2U)
 80231a6:	2c02      	cmp	r4, #2
 80231a8:	d022      	beq.n	80231f0 <mems_cmd+0x29c>
      (void)dc_com_read(&dc_com_db, DC_COM_PRESSURE, (void *)&pressure_info, sizeof(pressure_info));
 80231aa:	2310      	movs	r3, #16
 80231ac:	aa08      	add	r2, sp, #32
 80231ae:	492c      	ldr	r1, [pc, #176]	; (8023260 <mems_cmd+0x30c>)
 80231b0:	8809      	ldrh	r1, [r1, #0]
 80231b2:	482c      	ldr	r0, [pc, #176]	; (8023264 <mems_cmd+0x310>)
 80231b4:	f7fe ffbc 	bl	8022130 <dc_com_read>
      if (pressure_info.rt_state ==  DC_SERVICE_ON)
 80231b8:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 80231bc:	2b07      	cmp	r3, #7
 80231be:	d055      	beq.n	802326c <mems_cmd+0x318>
        PRINT_FORCE("%s invalid", argv_p[0]);
 80231c0:	4c19      	ldr	r4, [pc, #100]	; (8023228 <mems_cmd+0x2d4>)
 80231c2:	4632      	mov	r2, r6
 80231c4:	4928      	ldr	r1, [pc, #160]	; (8023268 <mems_cmd+0x314>)
 80231c6:	4620      	mov	r0, r4
 80231c8:	f003 fb3e 	bl	8026848 <sprintf>
 80231cc:	4620      	mov	r0, r4
 80231ce:	f7fc f8ac 	bl	801f32a <crs_strlen>
 80231d2:	b283      	uxth	r3, r0
 80231d4:	4622      	mov	r2, r4
 80231d6:	2101      	movs	r1, #1
 80231d8:	4608      	mov	r0, r1
 80231da:	f7fc f8e9 	bl	801f3b0 <traceIF_itmPrint>
 80231de:	4620      	mov	r0, r4
 80231e0:	f7fc f8a3 	bl	801f32a <crs_strlen>
 80231e4:	b282      	uxth	r2, r0
 80231e6:	4621      	mov	r1, r4
 80231e8:	2001      	movs	r0, #1
 80231ea:	f7fc f91b 	bl	801f424 <traceIF_uartPrintForce>
 80231ee:	e6c1      	b.n	8022f74 <mems_cmd+0x20>
        PRESSURE_Value = (float_t)crs_atoi(argv_p[1]);
 80231f0:	980d      	ldr	r0, [sp, #52]	; 0x34
 80231f2:	f7fc f855 	bl	801f2a0 <crs_atoi>
 80231f6:	ee07 0a90 	vmov	s15, r0
 80231fa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        pressure_info.rt_state         =  DC_SERVICE_ON;
 80231fe:	2307      	movs	r3, #7
 8023200:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
        pressure_info.pressure         =  PRESSURE_Value;
 8023204:	edcd 7a0b 	vstr	s15, [sp, #44]	; 0x2c
        mems_state = 1U;
 8023208:	4b0b      	ldr	r3, [pc, #44]	; (8023238 <mems_cmd+0x2e4>)
 802320a:	2201      	movs	r2, #1
 802320c:	601a      	str	r2, [r3, #0]
        (void)dc_com_write(&dc_com_db, DC_COM_PRESSURE, (void *)&pressure_info, sizeof(pressure_info));
 802320e:	2310      	movs	r3, #16
 8023210:	aa08      	add	r2, sp, #32
 8023212:	4913      	ldr	r1, [pc, #76]	; (8023260 <mems_cmd+0x30c>)
 8023214:	8809      	ldrh	r1, [r1, #0]
 8023216:	4813      	ldr	r0, [pc, #76]	; (8023264 <mems_cmd+0x310>)
 8023218:	f7fe ff3e 	bl	8022098 <dc_com_write>
 802321c:	e7c5      	b.n	80231aa <mems_cmd+0x256>
 802321e:	bf00      	nop
 8023220:	0803382c 	.word	0x0803382c
 8023224:	08036d68 	.word	0x08036d68
 8023228:	200047dc 	.word	0x200047dc
 802322c:	08036f78 	.word	0x08036f78
 8023230:	08033830 	.word	0x08033830
 8023234:	08033bb4 	.word	0x08033bb4
 8023238:	20005c9c 	.word	0x20005c9c
 802323c:	08036f98 	.word	0x08036f98
 8023240:	20005c98 	.word	0x20005c98
 8023244:	08036fa8 	.word	0x08036fa8
 8023248:	08036f88 	.word	0x08036f88
 802324c:	08035db8 	.word	0x08035db8
 8023250:	08035ddc 	.word	0x08035ddc
 8023254:	08036fc0 	.word	0x08036fc0
 8023258:	08036fc8 	.word	0x08036fc8
 802325c:	08036fe4 	.word	0x08036fe4
 8023260:	20000248 	.word	0x20000248
 8023264:	200058b0 	.word	0x200058b0
 8023268:	08037000 	.word	0x08037000
        PRINT_FORCE("pressure: %f", pressure_info.pressure);
 802326c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 802326e:	f7dd f983 	bl	8000578 <__aeabi_f2d>
 8023272:	4602      	mov	r2, r0
 8023274:	460b      	mov	r3, r1
 8023276:	4c7c      	ldr	r4, [pc, #496]	; (8023468 <mems_cmd+0x514>)
 8023278:	497c      	ldr	r1, [pc, #496]	; (802346c <mems_cmd+0x518>)
 802327a:	4620      	mov	r0, r4
 802327c:	f003 fae4 	bl	8026848 <sprintf>
 8023280:	4620      	mov	r0, r4
 8023282:	f7fc f852 	bl	801f32a <crs_strlen>
 8023286:	b283      	uxth	r3, r0
 8023288:	4622      	mov	r2, r4
 802328a:	2101      	movs	r1, #1
 802328c:	4608      	mov	r0, r1
 802328e:	f7fc f88f 	bl	801f3b0 <traceIF_itmPrint>
 8023292:	4620      	mov	r0, r4
 8023294:	f7fc f849 	bl	801f32a <crs_strlen>
 8023298:	b282      	uxth	r2, r0
 802329a:	4621      	mov	r1, r4
 802329c:	2001      	movs	r0, #1
 802329e:	f7fc f8c1 	bl	801f424 <traceIF_uartPrintForce>
 80232a2:	e667      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "humidity", crs_strlen(argv_p[0])) == 0)
 80232a4:	4630      	mov	r0, r6
 80232a6:	f7fc f840 	bl	801f32a <crs_strlen>
 80232aa:	4602      	mov	r2, r0
 80232ac:	4970      	ldr	r1, [pc, #448]	; (8023470 <mems_cmd+0x51c>)
 80232ae:	4630      	mov	r0, r6
 80232b0:	f003 fb2d 	bl	802690e <memcmp>
 80232b4:	2800      	cmp	r0, #0
 80232b6:	d159      	bne.n	802336c <mems_cmd+0x418>
      if (argc == 2U)
 80232b8:	2c02      	cmp	r4, #2
 80232ba:	d023      	beq.n	8023304 <mems_cmd+0x3b0>
      (void)dc_com_read(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 80232bc:	2310      	movs	r3, #16
 80232be:	eb0d 0203 	add.w	r2, sp, r3
 80232c2:	496c      	ldr	r1, [pc, #432]	; (8023474 <mems_cmd+0x520>)
 80232c4:	8809      	ldrh	r1, [r1, #0]
 80232c6:	486c      	ldr	r0, [pc, #432]	; (8023478 <mems_cmd+0x524>)
 80232c8:	f7fe ff32 	bl	8022130 <dc_com_read>
      if (humidity_info.rt_state ==  DC_SERVICE_ON)
 80232cc:	f89d 3018 	ldrb.w	r3, [sp, #24]
 80232d0:	2b07      	cmp	r3, #7
 80232d2:	d02f      	beq.n	8023334 <mems_cmd+0x3e0>
        PRINT_FORCE("%s invalid", argv_p[0]);
 80232d4:	4c64      	ldr	r4, [pc, #400]	; (8023468 <mems_cmd+0x514>)
 80232d6:	4632      	mov	r2, r6
 80232d8:	4968      	ldr	r1, [pc, #416]	; (802347c <mems_cmd+0x528>)
 80232da:	4620      	mov	r0, r4
 80232dc:	f003 fab4 	bl	8026848 <sprintf>
 80232e0:	4620      	mov	r0, r4
 80232e2:	f7fc f822 	bl	801f32a <crs_strlen>
 80232e6:	b283      	uxth	r3, r0
 80232e8:	4622      	mov	r2, r4
 80232ea:	2101      	movs	r1, #1
 80232ec:	4608      	mov	r0, r1
 80232ee:	f7fc f85f 	bl	801f3b0 <traceIF_itmPrint>
 80232f2:	4620      	mov	r0, r4
 80232f4:	f7fc f819 	bl	801f32a <crs_strlen>
 80232f8:	b282      	uxth	r2, r0
 80232fa:	4621      	mov	r1, r4
 80232fc:	2001      	movs	r0, #1
 80232fe:	f7fc f891 	bl	801f424 <traceIF_uartPrintForce>
 8023302:	e637      	b.n	8022f74 <mems_cmd+0x20>
        HUMIDITY_Value = (float_t)crs_atoi(argv_p[1]);
 8023304:	980d      	ldr	r0, [sp, #52]	; 0x34
 8023306:	f7fb ffcb 	bl	801f2a0 <crs_atoi>
 802330a:	ee07 0a90 	vmov	s15, r0
 802330e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        humidity_info.rt_state         =  DC_SERVICE_ON;
 8023312:	2307      	movs	r3, #7
 8023314:	f88d 3018 	strb.w	r3, [sp, #24]
        humidity_info.humidity         =  HUMIDITY_Value;
 8023318:	edcd 7a07 	vstr	s15, [sp, #28]
        mems_state = 1U;
 802331c:	4b58      	ldr	r3, [pc, #352]	; (8023480 <mems_cmd+0x52c>)
 802331e:	2201      	movs	r2, #1
 8023320:	601a      	str	r2, [r3, #0]
        (void)dc_com_write(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8023322:	2310      	movs	r3, #16
 8023324:	eb0d 0203 	add.w	r2, sp, r3
 8023328:	4952      	ldr	r1, [pc, #328]	; (8023474 <mems_cmd+0x520>)
 802332a:	8809      	ldrh	r1, [r1, #0]
 802332c:	4852      	ldr	r0, [pc, #328]	; (8023478 <mems_cmd+0x524>)
 802332e:	f7fe feb3 	bl	8022098 <dc_com_write>
 8023332:	e7c3      	b.n	80232bc <mems_cmd+0x368>
        PRINT_FORCE("humidity: %f", humidity_info.humidity);
 8023334:	9807      	ldr	r0, [sp, #28]
 8023336:	f7dd f91f 	bl	8000578 <__aeabi_f2d>
 802333a:	4602      	mov	r2, r0
 802333c:	460b      	mov	r3, r1
 802333e:	4c4a      	ldr	r4, [pc, #296]	; (8023468 <mems_cmd+0x514>)
 8023340:	4950      	ldr	r1, [pc, #320]	; (8023484 <mems_cmd+0x530>)
 8023342:	4620      	mov	r0, r4
 8023344:	f003 fa80 	bl	8026848 <sprintf>
 8023348:	4620      	mov	r0, r4
 802334a:	f7fb ffee 	bl	801f32a <crs_strlen>
 802334e:	b283      	uxth	r3, r0
 8023350:	4622      	mov	r2, r4
 8023352:	2101      	movs	r1, #1
 8023354:	4608      	mov	r0, r1
 8023356:	f7fc f82b 	bl	801f3b0 <traceIF_itmPrint>
 802335a:	4620      	mov	r0, r4
 802335c:	f7fb ffe5 	bl	801f32a <crs_strlen>
 8023360:	b282      	uxth	r2, r0
 8023362:	4621      	mov	r1, r4
 8023364:	2001      	movs	r0, #1
 8023366:	f7fc f85d 	bl	801f424 <traceIF_uartPrintForce>
 802336a:	e603      	b.n	8022f74 <mems_cmd+0x20>
    else if (memcmp((CRC_CHAR_t *)argv_p[0], "temperature", crs_strlen(argv_p[0])) == 0)
 802336c:	4630      	mov	r0, r6
 802336e:	f7fb ffdc 	bl	801f32a <crs_strlen>
 8023372:	4602      	mov	r2, r0
 8023374:	4944      	ldr	r1, [pc, #272]	; (8023488 <mems_cmd+0x534>)
 8023376:	4630      	mov	r0, r6
 8023378:	f003 fac9 	bl	802690e <memcmp>
 802337c:	2800      	cmp	r0, #0
 802337e:	d157      	bne.n	8023430 <mems_cmd+0x4dc>
      if (argc == 2U)
 8023380:	2c02      	cmp	r4, #2
 8023382:	d022      	beq.n	80233ca <mems_cmd+0x476>
      (void)dc_com_read(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8023384:	2310      	movs	r3, #16
 8023386:	466a      	mov	r2, sp
 8023388:	4940      	ldr	r1, [pc, #256]	; (802348c <mems_cmd+0x538>)
 802338a:	8809      	ldrh	r1, [r1, #0]
 802338c:	483a      	ldr	r0, [pc, #232]	; (8023478 <mems_cmd+0x524>)
 802338e:	f7fe fecf 	bl	8022130 <dc_com_read>
      if (temperature_info.rt_state ==  DC_SERVICE_ON)
 8023392:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8023396:	2b07      	cmp	r3, #7
 8023398:	d02e      	beq.n	80233f8 <mems_cmd+0x4a4>
        PRINT_FORCE("%s invalid", argv_p[0]);
 802339a:	4c33      	ldr	r4, [pc, #204]	; (8023468 <mems_cmd+0x514>)
 802339c:	4632      	mov	r2, r6
 802339e:	4937      	ldr	r1, [pc, #220]	; (802347c <mems_cmd+0x528>)
 80233a0:	4620      	mov	r0, r4
 80233a2:	f003 fa51 	bl	8026848 <sprintf>
 80233a6:	4620      	mov	r0, r4
 80233a8:	f7fb ffbf 	bl	801f32a <crs_strlen>
 80233ac:	b283      	uxth	r3, r0
 80233ae:	4622      	mov	r2, r4
 80233b0:	2101      	movs	r1, #1
 80233b2:	4608      	mov	r0, r1
 80233b4:	f7fb fffc 	bl	801f3b0 <traceIF_itmPrint>
 80233b8:	4620      	mov	r0, r4
 80233ba:	f7fb ffb6 	bl	801f32a <crs_strlen>
 80233be:	b282      	uxth	r2, r0
 80233c0:	4621      	mov	r1, r4
 80233c2:	2001      	movs	r0, #1
 80233c4:	f7fc f82e 	bl	801f424 <traceIF_uartPrintForce>
 80233c8:	e5d4      	b.n	8022f74 <mems_cmd+0x20>
        TEMPERATURE_Value = (float_t)crs_atoi(argv_p[1]);
 80233ca:	980d      	ldr	r0, [sp, #52]	; 0x34
 80233cc:	f7fb ff68 	bl	801f2a0 <crs_atoi>
 80233d0:	ee07 0a90 	vmov	s15, r0
 80233d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        temperature_info.rt_state         =  DC_SERVICE_ON;
 80233d8:	2307      	movs	r3, #7
 80233da:	f88d 3008 	strb.w	r3, [sp, #8]
        temperature_info.temperature      =  TEMPERATURE_Value;
 80233de:	edcd 7a03 	vstr	s15, [sp, #12]
        mems_state = 1U;
 80233e2:	4b27      	ldr	r3, [pc, #156]	; (8023480 <mems_cmd+0x52c>)
 80233e4:	2201      	movs	r2, #1
 80233e6:	601a      	str	r2, [r3, #0]
        (void)dc_com_write(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 80233e8:	2310      	movs	r3, #16
 80233ea:	466a      	mov	r2, sp
 80233ec:	4927      	ldr	r1, [pc, #156]	; (802348c <mems_cmd+0x538>)
 80233ee:	8809      	ldrh	r1, [r1, #0]
 80233f0:	4821      	ldr	r0, [pc, #132]	; (8023478 <mems_cmd+0x524>)
 80233f2:	f7fe fe51 	bl	8022098 <dc_com_write>
 80233f6:	e7c5      	b.n	8023384 <mems_cmd+0x430>
        PRINT_FORCE("temperature: %f", temperature_info.temperature);
 80233f8:	9803      	ldr	r0, [sp, #12]
 80233fa:	f7dd f8bd 	bl	8000578 <__aeabi_f2d>
 80233fe:	4602      	mov	r2, r0
 8023400:	460b      	mov	r3, r1
 8023402:	4c19      	ldr	r4, [pc, #100]	; (8023468 <mems_cmd+0x514>)
 8023404:	4922      	ldr	r1, [pc, #136]	; (8023490 <mems_cmd+0x53c>)
 8023406:	4620      	mov	r0, r4
 8023408:	f003 fa1e 	bl	8026848 <sprintf>
 802340c:	4620      	mov	r0, r4
 802340e:	f7fb ff8c 	bl	801f32a <crs_strlen>
 8023412:	b283      	uxth	r3, r0
 8023414:	4622      	mov	r2, r4
 8023416:	2101      	movs	r1, #1
 8023418:	4608      	mov	r0, r1
 802341a:	f7fb ffc9 	bl	801f3b0 <traceIF_itmPrint>
 802341e:	4620      	mov	r0, r4
 8023420:	f7fb ff83 	bl	801f32a <crs_strlen>
 8023424:	b282      	uxth	r2, r0
 8023426:	4621      	mov	r1, r4
 8023428:	2001      	movs	r0, #1
 802342a:	f7fb fffb 	bl	801f424 <traceIF_uartPrintForce>
 802342e:	e5a1      	b.n	8022f74 <mems_cmd+0x20>
      PRINT_FORCE("%s bad command %s\n\r", cmd_p, argv_p[0]);
 8023430:	4c0d      	ldr	r4, [pc, #52]	; (8023468 <mems_cmd+0x514>)
 8023432:	4633      	mov	r3, r6
 8023434:	462a      	mov	r2, r5
 8023436:	4917      	ldr	r1, [pc, #92]	; (8023494 <mems_cmd+0x540>)
 8023438:	4620      	mov	r0, r4
 802343a:	f003 fa05 	bl	8026848 <sprintf>
 802343e:	4620      	mov	r0, r4
 8023440:	f7fb ff73 	bl	801f32a <crs_strlen>
 8023444:	b283      	uxth	r3, r0
 8023446:	4622      	mov	r2, r4
 8023448:	2101      	movs	r1, #1
 802344a:	4608      	mov	r0, r1
 802344c:	f7fb ffb0 	bl	801f3b0 <traceIF_itmPrint>
 8023450:	4620      	mov	r0, r4
 8023452:	f7fb ff6a 	bl	801f32a <crs_strlen>
 8023456:	b282      	uxth	r2, r0
 8023458:	4621      	mov	r1, r4
 802345a:	2001      	movs	r0, #1
 802345c:	f7fb ffe2 	bl	801f424 <traceIF_uartPrintForce>
      mems_cmd_help();
 8023460:	f7ff fc64 	bl	8022d2c <mems_cmd_help>
 8023464:	e586      	b.n	8022f74 <mems_cmd+0x20>
 8023466:	bf00      	nop
 8023468:	200047dc 	.word	0x200047dc
 802346c:	08036ff0 	.word	0x08036ff0
 8023470:	08037010 	.word	0x08037010
 8023474:	20000244 	.word	0x20000244
 8023478:	200058b0 	.word	0x200058b0
 802347c:	08037000 	.word	0x08037000
 8023480:	20005c9c 	.word	0x20005c9c
 8023484:	0803701c 	.word	0x0803701c
 8023488:	0803702c 	.word	0x0803702c
 802348c:	2000024a 	.word	0x2000024a
 8023490:	08037038 	.word	0x08037038
 8023494:	0803704c 	.word	0x0803704c

08023498 <dc_mems_init>:
{
 8023498:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  mems_state = 0U;
 802349c:	2300      	movs	r3, #0
 802349e:	4a30      	ldr	r2, [pc, #192]	; (8023560 <dc_mems_init+0xc8>)
 80234a0:	6013      	str	r3, [r2, #0]
  mems_polling_period = MEMS_POLLING_PERIOD;
 80234a2:	4a30      	ldr	r2, [pc, #192]	; (8023564 <dc_mems_init+0xcc>)
 80234a4:	f242 7110 	movw	r1, #10000	; 0x2710
 80234a8:	6011      	str	r1, [r2, #0]
  (void)memset((void *)&dc_pressure_info,      0, sizeof(dc_pressure_info_t));
 80234aa:	492f      	ldr	r1, [pc, #188]	; (8023568 <dc_mems_init+0xd0>)
 80234ac:	600b      	str	r3, [r1, #0]
 80234ae:	604b      	str	r3, [r1, #4]
 80234b0:	608b      	str	r3, [r1, #8]
 80234b2:	60cb      	str	r3, [r1, #12]
  (void)memset((void *)&dc_humidity_info,      0, sizeof(dc_humidity_info_t));
 80234b4:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 8023594 <dc_mems_init+0xfc>
 80234b8:	f8c9 3000 	str.w	r3, [r9]
 80234bc:	f8c9 3004 	str.w	r3, [r9, #4]
 80234c0:	f8c9 3008 	str.w	r3, [r9, #8]
 80234c4:	f8c9 300c 	str.w	r3, [r9, #12]
  (void)memset((void *)&dc_temperature_info,   0, sizeof(dc_temperature_info_t));
 80234c8:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8023598 <dc_mems_init+0x100>
 80234cc:	f8c8 3000 	str.w	r3, [r8]
 80234d0:	f8c8 3004 	str.w	r3, [r8, #4]
 80234d4:	f8c8 3008 	str.w	r3, [r8, #8]
 80234d8:	f8c8 300c 	str.w	r3, [r8, #12]
  (void)memset((void *)&dc_accelerometer_info, 0, sizeof(dc_accelerometer_info_t));
 80234dc:	4e23      	ldr	r6, [pc, #140]	; (802356c <dc_mems_init+0xd4>)
 80234de:	6033      	str	r3, [r6, #0]
 80234e0:	6073      	str	r3, [r6, #4]
 80234e2:	60b3      	str	r3, [r6, #8]
 80234e4:	60f3      	str	r3, [r6, #12]
 80234e6:	6133      	str	r3, [r6, #16]
 80234e8:	6173      	str	r3, [r6, #20]
  (void)memset((void *)&dc_gyroscope_info,     0, sizeof(dc_gyroscope_info_t));
 80234ea:	4d21      	ldr	r5, [pc, #132]	; (8023570 <dc_mems_init+0xd8>)
 80234ec:	602b      	str	r3, [r5, #0]
 80234ee:	606b      	str	r3, [r5, #4]
 80234f0:	60ab      	str	r3, [r5, #8]
 80234f2:	60eb      	str	r3, [r5, #12]
 80234f4:	612b      	str	r3, [r5, #16]
 80234f6:	616b      	str	r3, [r5, #20]
  (void)memset((void *)&dc_magnetometer_info,  0, sizeof(dc_magnetometer_info_t));
 80234f8:	4c1e      	ldr	r4, [pc, #120]	; (8023574 <dc_mems_init+0xdc>)
 80234fa:	6023      	str	r3, [r4, #0]
 80234fc:	6063      	str	r3, [r4, #4]
 80234fe:	60a3      	str	r3, [r4, #8]
 8023500:	60e3      	str	r3, [r4, #12]
 8023502:	6123      	str	r3, [r4, #16]
 8023504:	6163      	str	r3, [r4, #20]
  DC_COM_PRESSURE       = dc_com_register_serv(&dc_com_db, (void *)&dc_pressure_info,
 8023506:	4f1c      	ldr	r7, [pc, #112]	; (8023578 <dc_mems_init+0xe0>)
 8023508:	2210      	movs	r2, #16
 802350a:	4638      	mov	r0, r7
 802350c:	f7fe fd60 	bl	8021fd0 <dc_com_register_serv>
 8023510:	4b1a      	ldr	r3, [pc, #104]	; (802357c <dc_mems_init+0xe4>)
 8023512:	8018      	strh	r0, [r3, #0]
  DC_COM_HUMIDITY       = dc_com_register_serv(&dc_com_db, (void *)&dc_humidity_info,
 8023514:	2210      	movs	r2, #16
 8023516:	4649      	mov	r1, r9
 8023518:	4638      	mov	r0, r7
 802351a:	f7fe fd59 	bl	8021fd0 <dc_com_register_serv>
 802351e:	4b18      	ldr	r3, [pc, #96]	; (8023580 <dc_mems_init+0xe8>)
 8023520:	8018      	strh	r0, [r3, #0]
  DC_COM_TEMPERATURE    = dc_com_register_serv(&dc_com_db, (void *)&dc_temperature_info,
 8023522:	2210      	movs	r2, #16
 8023524:	4641      	mov	r1, r8
 8023526:	4638      	mov	r0, r7
 8023528:	f7fe fd52 	bl	8021fd0 <dc_com_register_serv>
 802352c:	4b15      	ldr	r3, [pc, #84]	; (8023584 <dc_mems_init+0xec>)
 802352e:	8018      	strh	r0, [r3, #0]
  DC_COM_ACCELEROMETER  = dc_com_register_serv(&dc_com_db, (void *)&dc_accelerometer_info,
 8023530:	2218      	movs	r2, #24
 8023532:	4631      	mov	r1, r6
 8023534:	4638      	mov	r0, r7
 8023536:	f7fe fd4b 	bl	8021fd0 <dc_com_register_serv>
 802353a:	4b13      	ldr	r3, [pc, #76]	; (8023588 <dc_mems_init+0xf0>)
 802353c:	8018      	strh	r0, [r3, #0]
  DC_COM_GYROSCOPE      = dc_com_register_serv(&dc_com_db, (void *)&dc_gyroscope_info,
 802353e:	2218      	movs	r2, #24
 8023540:	4629      	mov	r1, r5
 8023542:	4638      	mov	r0, r7
 8023544:	f7fe fd44 	bl	8021fd0 <dc_com_register_serv>
 8023548:	4b10      	ldr	r3, [pc, #64]	; (802358c <dc_mems_init+0xf4>)
 802354a:	8018      	strh	r0, [r3, #0]
  DC_COM_MAGNETOMETER   = dc_com_register_serv(&dc_com_db, (void *)&dc_magnetometer_info,
 802354c:	2218      	movs	r2, #24
 802354e:	4621      	mov	r1, r4
 8023550:	4638      	mov	r0, r7
 8023552:	f7fe fd3d 	bl	8021fd0 <dc_com_register_serv>
 8023556:	4b0e      	ldr	r3, [pc, #56]	; (8023590 <dc_mems_init+0xf8>)
 8023558:	8018      	strh	r0, [r3, #0]
}
 802355a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 802355e:	bf00      	nop
 8023560:	20005c9c 	.word	0x20005c9c
 8023564:	20005c98 	.word	0x20005c98
 8023568:	20005c70 	.word	0x20005c70
 802356c:	20005c18 	.word	0x20005c18
 8023570:	20005c30 	.word	0x20005c30
 8023574:	20005c58 	.word	0x20005c58
 8023578:	200058b0 	.word	0x200058b0
 802357c:	20000248 	.word	0x20000248
 8023580:	20000244 	.word	0x20000244
 8023584:	2000024a 	.word	0x2000024a
 8023588:	20000240 	.word	0x20000240
 802358c:	20000242 	.word	0x20000242
 8023590:	20000246 	.word	0x20000246
 8023594:	20005c48 	.word	0x20005c48
 8023598:	20005c80 	.word	0x20005c80

0802359c <dc_mems_start>:
{
 802359c:	b500      	push	{lr}
 802359e:	b083      	sub	sp, #12
  CMD_Declare(mems_cmd_label, mems_cmd, (uint8_t *)"mems management");
 80235a0:	4a0c      	ldr	r2, [pc, #48]	; (80235d4 <dc_mems_start+0x38>)
 80235a2:	490d      	ldr	r1, [pc, #52]	; (80235d8 <dc_mems_start+0x3c>)
 80235a4:	480d      	ldr	r0, [pc, #52]	; (80235dc <dc_mems_start+0x40>)
 80235a6:	f7ff f9a7 	bl	80228f8 <CMD_Declare>
  memsDclibTaskTaskId = rtosalThreadNew((const rtosal_char_t *)"memsDclibTask", (os_pthread)StartMemsDclibTask,
 80235aa:	2200      	movs	r2, #0
 80235ac:	9200      	str	r2, [sp, #0]
 80235ae:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80235b2:	490b      	ldr	r1, [pc, #44]	; (80235e0 <dc_mems_start+0x44>)
 80235b4:	480b      	ldr	r0, [pc, #44]	; (80235e4 <dc_mems_start+0x48>)
 80235b6:	f7fb fda6 	bl	801f106 <rtosalThreadNew>
 80235ba:	4b0b      	ldr	r3, [pc, #44]	; (80235e8 <dc_mems_start+0x4c>)
 80235bc:	6018      	str	r0, [r3, #0]
  if (memsDclibTaskTaskId == NULL)
 80235be:	b110      	cbz	r0, 80235c6 <dc_mems_start+0x2a>
}
 80235c0:	b003      	add	sp, #12
 80235c2:	f85d fb04 	ldr.w	pc, [sp], #4
    ERROR_Handler(DBG_CHAN_MAIN, 11, ERROR_FATAL);
 80235c6:	2203      	movs	r2, #3
 80235c8:	210b      	movs	r1, #11
 80235ca:	2001      	movs	r0, #1
 80235cc:	f7fa feca 	bl	801e364 <ERROR_Handler>
}
 80235d0:	e7f6      	b.n	80235c0 <dc_mems_start+0x24>
 80235d2:	bf00      	nop
 80235d4:	08037064 	.word	0x08037064
 80235d8:	08022f55 	.word	0x08022f55
 80235dc:	08036d68 	.word	0x08036d68
 80235e0:	08022cf1 	.word	0x08022cf1
 80235e4:	08037074 	.word	0x08037074
 80235e8:	20005c90 	.word	0x20005c90

080235ec <custom_log_mems>:

static logBuffer_t logBuffer;
static uint16_t SERVER_LOG_PORT = -1;

static bool custom_log_mems()
{
 80235ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80235ee:	ed2d 8b02 	vpush	{d8}
 80235f2:	b0e9      	sub	sp, #420	; 0x1a4
	dc_temperature_info_t   temperature_info;
	dc_humidity_info_t		humidity_info;
	char 					mems_string[64];
	int						mems_string_len;

	char str_tmp[100] = "";
 80235f4:	2400      	movs	r4, #0
 80235f6:	9437      	str	r4, [sp, #220]	; 0xdc
 80235f8:	2560      	movs	r5, #96	; 0x60
 80235fa:	462a      	mov	r2, r5
 80235fc:	4621      	mov	r1, r4
 80235fe:	a838      	add	r0, sp, #224	; 0xe0
 8023600:	f003 f995 	bl	802692e <memset>
	char str_hum[100] = "";
 8023604:	941e      	str	r4, [sp, #120]	; 0x78
 8023606:	462a      	mov	r2, r5
 8023608:	4621      	mov	r1, r4
 802360a:	a81f      	add	r0, sp, #124	; 0x7c
 802360c:	f003 f98f 	bl	802692e <memset>
	char str_dbm[100] = "";
 8023610:	9405      	str	r4, [sp, #20]
 8023612:	462a      	mov	r2, r5
 8023614:	4621      	mov	r1, r4
 8023616:	a806      	add	r0, sp, #24
 8023618:	f003 f989 	bl	802692e <memset>
	float temp_value = 0;
	float hum_value = 0;
	int32_t dbm_value = cst_cellular_info.cs_signal_level_db;
 802361c:	4b45      	ldr	r3, [pc, #276]	; (8023734 <custom_log_mems+0x148>)
 802361e:	68df      	ldr	r7, [r3, #12]

	// read the MEM data
	(void)dc_com_read(&dc_com_db, DC_COM_TEMPERATURE, (void *)&temperature_info, sizeof(temperature_info));
 8023620:	4c45      	ldr	r4, [pc, #276]	; (8023738 <custom_log_mems+0x14c>)
 8023622:	2310      	movs	r3, #16
 8023624:	aa64      	add	r2, sp, #400	; 0x190
 8023626:	4945      	ldr	r1, [pc, #276]	; (802373c <custom_log_mems+0x150>)
 8023628:	8809      	ldrh	r1, [r1, #0]
 802362a:	4620      	mov	r0, r4
 802362c:	f7fe fd80 	bl	8022130 <dc_com_read>
    (void)dc_com_read(&dc_com_db, DC_COM_HUMIDITY, (void *)&humidity_info, sizeof(humidity_info));
 8023630:	2310      	movs	r3, #16
 8023632:	aa60      	add	r2, sp, #384	; 0x180
 8023634:	4942      	ldr	r1, [pc, #264]	; (8023740 <custom_log_mems+0x154>)
 8023636:	8809      	ldrh	r1, [r1, #0]
 8023638:	4620      	mov	r0, r4
 802363a:	f7fe fd79 	bl	8022130 <dc_com_read>

    temp_value = temperature_info.temperature;
 802363e:	eddd 7a67 	vldr	s15, [sp, #412]	; 0x19c
    int tempInt = (int)temp_value;
 8023642:	eefd 8ae7 	vcvt.s32.f32	s17, s15
	int tmpInt1 = temp_value;
	float tmpFrac = temp_value - tmpInt1;
 8023646:	eeb8 7ae8 	vcvt.f32.s32	s14, s17
 802364a:	ee77 7ac7 	vsub.f32	s15, s15, s14
	int tmpInt2 = trunc(tmpFrac * 100);
 802364e:	ed9f 7a3d 	vldr	s14, [pc, #244]	; 8023744 <custom_log_mems+0x158>
 8023652:	ee67 7a87 	vmul.f32	s15, s15, s14
 8023656:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802365a:	ee17 5a90 	vmov	r5, s15

	hum_value = humidity_info.humidity;
 802365e:	eddd 7a63 	vldr	s15, [sp, #396]	; 0x18c
	int humInt = (int)hum_value;
 8023662:	eebd 8ae7 	vcvt.s32.f32	s16, s15
	int humInt1 = hum_value;
	float humFrac = hum_value - humInt1;
 8023666:	eef8 6ac8 	vcvt.f32.s32	s13, s16
 802366a:	ee77 7ae6 	vsub.f32	s15, s15, s13
	int humInt2 = trunc(humFrac * 100);
 802366e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8023672:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8023676:	ee17 4a90 	vmov	r4, s15

	// convert to string the temperature and humidity
    //mems_string_len= sprintf(mems_string,"time=%d;temperature=%f;humidity=%f;acceleration=%li, %li, %li",xTaskGetTickCount(),temperature_info.temperature, humidity_info.humidity, acc_data.AXIS_X, acc_data.AXIS_Y, acc_data.AXIS_Z);
    //mems_string_len= sprintf(mems_string,"time=%lu;temperature=%f;humidity=%f",(unsigned long)time(NULL),temperature_info.temperature, humidity_info.humidity);
    mems_string_len= sprintf(mems_string, "{\"time\": \"%d\",\"dbm\": \"%d\",\"temperature\": \"%f\",\"humidity\": \"%f\"}", xTaskGetTickCount(), dbm_value, temperature_info.temperature, humidity_info.humidity);
 802367a:	f002 f9f1 	bl	8025a60 <xTaskGetTickCount>
 802367e:	4606      	mov	r6, r0
 8023680:	9863      	ldr	r0, [sp, #396]	; 0x18c
 8023682:	f7dc ff79 	bl	8000578 <__aeabi_f2d>
 8023686:	e9cd 0102 	strd	r0, r1, [sp, #8]
 802368a:	9867      	ldr	r0, [sp, #412]	; 0x19c
 802368c:	f7dc ff74 	bl	8000578 <__aeabi_f2d>
 8023690:	e9cd 0100 	strd	r0, r1, [sp]
 8023694:	463b      	mov	r3, r7
 8023696:	4632      	mov	r2, r6
 8023698:	492b      	ldr	r1, [pc, #172]	; (8023748 <custom_log_mems+0x15c>)
 802369a:	a850      	add	r0, sp, #320	; 0x140
 802369c:	f003 f8d4 	bl	8026848 <sprintf>
 80236a0:	4606      	mov	r6, r0

    snprintf(str_tmp,100," TEMPERATURE = %d.%02d degree C\n\r", tmpInt1, tmpInt2);
 80236a2:	9500      	str	r5, [sp, #0]
 80236a4:	ee18 3a90 	vmov	r3, s17
 80236a8:	4a28      	ldr	r2, [pc, #160]	; (802374c <custom_log_mems+0x160>)
 80236aa:	2164      	movs	r1, #100	; 0x64
 80236ac:	a837      	add	r0, sp, #220	; 0xdc
 80236ae:	f003 f897 	bl	80267e0 <snprintf>
    snprintf(str_hum,100," HUMIDITY = %d.%02d %%\n\r", humInt1, humInt2);
 80236b2:	9400      	str	r4, [sp, #0]
 80236b4:	ee18 3a10 	vmov	r3, s16
 80236b8:	4a25      	ldr	r2, [pc, #148]	; (8023750 <custom_log_mems+0x164>)
 80236ba:	2164      	movs	r1, #100	; 0x64
 80236bc:	a81e      	add	r0, sp, #120	; 0x78
 80236be:	f003 f88f 	bl	80267e0 <snprintf>
    snprintf(str_dbm, 100," DBM = %d\n\r", dbm_value);
 80236c2:	463b      	mov	r3, r7
 80236c4:	4a23      	ldr	r2, [pc, #140]	; (8023754 <custom_log_mems+0x168>)
 80236c6:	2164      	movs	r1, #100	; 0x64
 80236c8:	a805      	add	r0, sp, #20
 80236ca:	f003 f889 	bl	80267e0 <snprintf>

    HAL_UART_Transmit(&huart1,( uint8_t *)str_tmp,sizeof(str_tmp),1000);
 80236ce:	4c22      	ldr	r4, [pc, #136]	; (8023758 <custom_log_mems+0x16c>)
 80236d0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80236d4:	2264      	movs	r2, #100	; 0x64
 80236d6:	a937      	add	r1, sp, #220	; 0xdc
 80236d8:	4620      	mov	r0, r4
 80236da:	f7e7 f8e5 	bl	800a8a8 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart1,( uint8_t *)str_hum,sizeof(str_hum),1000);
 80236de:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80236e2:	2264      	movs	r2, #100	; 0x64
 80236e4:	a91e      	add	r1, sp, #120	; 0x78
 80236e6:	4620      	mov	r0, r4
 80236e8:	f7e7 f8de 	bl	800a8a8 <HAL_UART_Transmit>
	HAL_UART_Transmit(&huart1,( uint8_t *)str_dbm,sizeof(str_dbm),1000);
 80236ec:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80236f0:	2264      	movs	r2, #100	; 0x64
 80236f2:	a905      	add	r1, sp, #20
 80236f4:	4620      	mov	r0, r4
 80236f6:	f7e7 f8d7 	bl	800a8a8 <HAL_UART_Transmit>

	HAL_Delay(1000);
 80236fa:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80236fe:	f7e3 fc51 	bl	8006fa4 <HAL_Delay>
	// append in logBuffer as string
	if ((logBuffer.data_len + mems_string_len) <= (sizeof(logBuffer.data)))
 8023702:	4b16      	ldr	r3, [pc, #88]	; (802375c <custom_log_mems+0x170>)
 8023704:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
 8023708:	1983      	adds	r3, r0, r6
 802370a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 802370e:	d904      	bls.n	802371a <custom_log_mems+0x12e>
		memcpy(&logBuffer.data[logBuffer.data_len], (const void *)mems_string, mems_string_len);
		logBuffer.data_len += mems_string_len;
	}
	else
	{
		return false;
 8023710:	2000      	movs	r0, #0
	}
	return true;
}
 8023712:	b069      	add	sp, #420	; 0x1a4
 8023714:	ecbd 8b02 	vpop	{d8}
 8023718:	bdf0      	pop	{r4, r5, r6, r7, pc}
		memcpy(&logBuffer.data[logBuffer.data_len], (const void *)mems_string, mems_string_len);
 802371a:	4c10      	ldr	r4, [pc, #64]	; (802375c <custom_log_mems+0x170>)
 802371c:	4632      	mov	r2, r6
 802371e:	a950      	add	r1, sp, #320	; 0x140
 8023720:	4420      	add	r0, r4
 8023722:	f003 f9e1 	bl	8026ae8 <memcpy>
		logBuffer.data_len += mems_string_len;
 8023726:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
 802372a:	4433      	add	r3, r6
 802372c:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
	return true;
 8023730:	2001      	movs	r0, #1
 8023732:	e7ee      	b.n	8023712 <custom_log_mems+0x126>
 8023734:	2000406c 	.word	0x2000406c
 8023738:	200058b0 	.word	0x200058b0
 802373c:	2000024a 	.word	0x2000024a
 8023740:	20000244 	.word	0x20000244
 8023744:	42c80000 	.word	0x42c80000
 8023748:	08037084 	.word	0x08037084
 802374c:	080370c4 	.word	0x080370c4
 8023750:	080370e8 	.word	0x080370e8
 8023754:	08037104 	.word	0x08037104
 8023758:	20000c04 	.word	0x20000c04
 802375c:	20005cac 	.word	0x20005cac

08023760 <custom_client_cmd_help>:
  * @param  -
  * @retval -
  */
static cmd_status_t custom_client_cmd_help(uint8_t *cmd_p,
                                           uint8_t *arg_p)
{
 8023760:	b570      	push	{r4, r5, r6, lr}
  cmd_status_t result;

  if ((cmd_p != NULL)
 8023762:	2800      	cmp	r0, #0
 8023764:	d038      	beq.n	80237d8 <custom_client_cmd_help+0x78>
 8023766:	4602      	mov	r2, r0
      && (arg_p != NULL))
 8023768:	2900      	cmp	r1, #0
 802376a:	d037      	beq.n	80237dc <custom_client_cmd_help+0x7c>
  {
    result = CMD_SYNTAX_ERROR;
    PRINT_APP("%s bad parameter %s !!!\n\r", cmd_p, arg_p)
 802376c:	4c1c      	ldr	r4, [pc, #112]	; (80237e0 <custom_client_cmd_help+0x80>)
 802376e:	460b      	mov	r3, r1
 8023770:	491c      	ldr	r1, [pc, #112]	; (80237e4 <custom_client_cmd_help+0x84>)
 8023772:	4620      	mov	r0, r4
 8023774:	f003 f868 	bl	8026848 <sprintf>
 8023778:	4620      	mov	r0, r4
 802377a:	f7fb fdd6 	bl	801f32a <crs_strlen>
 802377e:	b283      	uxth	r3, r0
 8023780:	4622      	mov	r2, r4
 8023782:	2101      	movs	r1, #1
 8023784:	2004      	movs	r0, #4
 8023786:	f7fb fe13 	bl	801f3b0 <traceIF_itmPrint>
 802378a:	4620      	mov	r0, r4
 802378c:	f7fb fdcd 	bl	801f32a <crs_strlen>
 8023790:	b282      	uxth	r2, r0
 8023792:	4621      	mov	r1, r4
 8023794:	2004      	movs	r0, #4
 8023796:	f7fb fe45 	bl	801f424 <traceIF_uartPrintForce>
    result = CMD_SYNTAX_ERROR;
 802379a:	2601      	movs	r6, #1
  {
    result = CMD_OK;
  }
  /* Always print help even after an error */

  CMD_print_help(custom_client_cmd_label);
 802379c:	4d12      	ldr	r5, [pc, #72]	; (80237e8 <custom_client_cmd_help+0x88>)
 802379e:	4628      	mov	r0, r5
 80237a0:	f7ff f90a 	bl	80229b8 <CMD_print_help>
  PRINT_APP("%s help       : display all commands supported by %s\n\r",
 80237a4:	4c0e      	ldr	r4, [pc, #56]	; (80237e0 <custom_client_cmd_help+0x80>)
 80237a6:	462b      	mov	r3, r5
 80237a8:	462a      	mov	r2, r5
 80237aa:	4910      	ldr	r1, [pc, #64]	; (80237ec <custom_client_cmd_help+0x8c>)
 80237ac:	4620      	mov	r0, r4
 80237ae:	f003 f84b 	bl	8026848 <sprintf>
 80237b2:	4620      	mov	r0, r4
 80237b4:	f7fb fdb9 	bl	801f32a <crs_strlen>
 80237b8:	b283      	uxth	r3, r0
 80237ba:	4622      	mov	r2, r4
 80237bc:	2101      	movs	r1, #1
 80237be:	2004      	movs	r0, #4
 80237c0:	f7fb fdf6 	bl	801f3b0 <traceIF_itmPrint>
 80237c4:	4620      	mov	r0, r4
 80237c6:	f7fb fdb0 	bl	801f32a <crs_strlen>
 80237ca:	b282      	uxth	r2, r0
 80237cc:	4621      	mov	r1, r4
 80237ce:	2004      	movs	r0, #4
 80237d0:	f7fb fe28 	bl	801f424 <traceIF_uartPrintForce>
            (CRC_CHAR_t *)custom_client_cmd_label,
            (CRC_CHAR_t *)custom_client_cmd_label)
  /* Describe below all other custom client command supported */

  return (result);
}
 80237d4:	4630      	mov	r0, r6
 80237d6:	bd70      	pop	{r4, r5, r6, pc}
    result = CMD_OK;
 80237d8:	2600      	movs	r6, #0
 80237da:	e7df      	b.n	802379c <custom_client_cmd_help+0x3c>
 80237dc:	2600      	movs	r6, #0
 80237de:	e7dd      	b.n	802379c <custom_client_cmd_help+0x3c>
 80237e0:	20004adc 	.word	0x20004adc
 80237e4:	08037110 	.word	0x08037110
 80237e8:	0803712c 	.word	0x0803712c
 80237ec:	08037134 	.word	0x08037134

080237f0 <custom_client_notif_cb>:
  /* remove next lines to use dc_event_id parameter */
  UNUSED(dc_event_id);

  /* According to dc_event_id value, due a specific treatment */
  /* Example: Modem is attached to the network*/
  if (dc_event_id == DC_CELLULAR_NIFMAN_INFO)
 80237f0:	b283      	uxth	r3, r0
 80237f2:	4a2e      	ldr	r2, [pc, #184]	; (80238ac <custom_client_notif_cb+0xbc>)
 80237f4:	8811      	ldrh	r1, [r2, #0]
 80237f6:	428b      	cmp	r3, r1
 80237f8:	d000      	beq.n	80237fc <custom_client_notif_cb+0xc>
 80237fa:	4770      	bx	lr
{
 80237fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80237fe:	b085      	sub	sp, #20
 8023800:	4604      	mov	r4, r0
  {
    dc_nifman_info_t dc_nifman_info;
    (void)dc_com_read(&dc_com_db, DC_CELLULAR_NIFMAN_INFO,
 8023802:	2310      	movs	r3, #16
 8023804:	466a      	mov	r2, sp
 8023806:	482a      	ldr	r0, [pc, #168]	; (80238b0 <custom_client_notif_cb+0xc0>)
 8023808:	f7fe fc92 	bl	8022130 <dc_com_read>
                      (void *)&dc_nifman_info,
                      sizeof(dc_nifman_info));
    if (dc_nifman_info.rt_state == DC_SERVICE_ON)
 802380c:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8023810:	2b07      	cmp	r3, #7
 8023812:	d022      	beq.n	802385a <custom_client_notif_cb+0x6a>
      PRINT_APP("CustomClt: Network is UP\n\r")
      (void)rtosalMessageQueuePut(custom_client_queue, (uint32_t)dc_event_id, 0U);
    }
    else
    {
      custom_client_modem_is_attached = false;
 8023814:	4b27      	ldr	r3, [pc, #156]	; (80238b4 <custom_client_notif_cb+0xc4>)
 8023816:	2200      	movs	r2, #0
 8023818:	701a      	strb	r2, [r3, #0]
      PRINT_APP("CustomClt: Network is DOWN\n\r")
 802381a:	4c27      	ldr	r4, [pc, #156]	; (80238b8 <custom_client_notif_cb+0xc8>)
 802381c:	4d27      	ldr	r5, [pc, #156]	; (80238bc <custom_client_notif_cb+0xcc>)
 802381e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023820:	6020      	str	r0, [r4, #0]
 8023822:	6061      	str	r1, [r4, #4]
 8023824:	60a2      	str	r2, [r4, #8]
 8023826:	60e3      	str	r3, [r4, #12]
 8023828:	cd07      	ldmia	r5!, {r0, r1, r2}
 802382a:	6120      	str	r0, [r4, #16]
 802382c:	6161      	str	r1, [r4, #20]
 802382e:	61a2      	str	r2, [r4, #24]
 8023830:	782b      	ldrb	r3, [r5, #0]
 8023832:	7723      	strb	r3, [r4, #28]
 8023834:	4620      	mov	r0, r4
 8023836:	f7fb fd78 	bl	801f32a <crs_strlen>
 802383a:	b283      	uxth	r3, r0
 802383c:	4622      	mov	r2, r4
 802383e:	2101      	movs	r1, #1
 8023840:	2004      	movs	r0, #4
 8023842:	f7fb fdb5 	bl	801f3b0 <traceIF_itmPrint>
 8023846:	4620      	mov	r0, r4
 8023848:	f7fb fd6f 	bl	801f32a <crs_strlen>
 802384c:	b282      	uxth	r2, r0
 802384e:	4621      	mov	r1, r4
 8023850:	2004      	movs	r0, #4
 8023852:	f7fb fde7 	bl	801f424 <traceIF_uartPrintForce>
  else
  {
    _NOP();
  }
  */
}
 8023856:	b005      	add	sp, #20
 8023858:	bdf0      	pop	{r4, r5, r6, r7, pc}
      custom_client_modem_is_attached = true;
 802385a:	2701      	movs	r7, #1
 802385c:	4b15      	ldr	r3, [pc, #84]	; (80238b4 <custom_client_notif_cb+0xc4>)
 802385e:	701f      	strb	r7, [r3, #0]
      PRINT_APP("CustomClt: Network is UP\n\r")
 8023860:	4d15      	ldr	r5, [pc, #84]	; (80238b8 <custom_client_notif_cb+0xc8>)
 8023862:	4e17      	ldr	r6, [pc, #92]	; (80238c0 <custom_client_notif_cb+0xd0>)
 8023864:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8023866:	6028      	str	r0, [r5, #0]
 8023868:	6069      	str	r1, [r5, #4]
 802386a:	60aa      	str	r2, [r5, #8]
 802386c:	60eb      	str	r3, [r5, #12]
 802386e:	ce03      	ldmia	r6!, {r0, r1}
 8023870:	6128      	str	r0, [r5, #16]
 8023872:	6169      	str	r1, [r5, #20]
 8023874:	8832      	ldrh	r2, [r6, #0]
 8023876:	78b3      	ldrb	r3, [r6, #2]
 8023878:	832a      	strh	r2, [r5, #24]
 802387a:	76ab      	strb	r3, [r5, #26]
 802387c:	4628      	mov	r0, r5
 802387e:	f7fb fd54 	bl	801f32a <crs_strlen>
 8023882:	b283      	uxth	r3, r0
 8023884:	462a      	mov	r2, r5
 8023886:	4639      	mov	r1, r7
 8023888:	2004      	movs	r0, #4
 802388a:	f7fb fd91 	bl	801f3b0 <traceIF_itmPrint>
 802388e:	4628      	mov	r0, r5
 8023890:	f7fb fd4b 	bl	801f32a <crs_strlen>
 8023894:	b282      	uxth	r2, r0
 8023896:	4629      	mov	r1, r5
 8023898:	2004      	movs	r0, #4
 802389a:	f7fb fdc3 	bl	801f424 <traceIF_uartPrintForce>
      (void)rtosalMessageQueuePut(custom_client_queue, (uint32_t)dc_event_id, 0U);
 802389e:	2200      	movs	r2, #0
 80238a0:	4621      	mov	r1, r4
 80238a2:	4b08      	ldr	r3, [pc, #32]	; (80238c4 <custom_client_notif_cb+0xd4>)
 80238a4:	6818      	ldr	r0, [r3, #0]
 80238a6:	f7fb fc6e 	bl	801f186 <rtosalMessageQueuePut>
 80238aa:	e7d4      	b.n	8023856 <custom_client_notif_cb+0x66>
 80238ac:	2000023a 	.word	0x2000023a
 80238b0:	200058b0 	.word	0x200058b0
 80238b4:	20005ca4 	.word	0x20005ca4
 80238b8:	20004adc 	.word	0x20004adc
 80238bc:	08037188 	.word	0x08037188
 80238c0:	0803716c 	.word	0x0803716c
 80238c4:	20005ca8 	.word	0x20005ca8

080238c8 <ntohs>:
    return (netshort << 8) | (netshort >> 8);
 80238c8:	0a03      	lsrs	r3, r0, #8
 80238ca:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
 80238ce:	b280      	uxth	r0, r0
 80238d0:	4770      	bx	lr
	...

080238d4 <custom_connect_and_send_data>:
{
 80238d4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80238d8:	b089      	sub	sp, #36	; 0x24
 80238da:	4680      	mov	r8, r0
 80238dc:	460f      	mov	r7, r1
 80238de:	4616      	mov	r6, r2
	  int32_t 	timeout = 20000;
 80238e0:	f644 6320 	movw	r3, #20000	; 0x4e20
 80238e4:	9307      	str	r3, [sp, #28]
	  PRINT_INFO("socket creation in progress...\n\r")
 80238e6:	4cc9      	ldr	r4, [pc, #804]	; (8023c0c <custom_connect_and_send_data+0x338>)
 80238e8:	4dc9      	ldr	r5, [pc, #804]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 80238ea:	f104 0e20 	add.w	lr, r4, #32
 80238ee:	46a4      	mov	ip, r4
 80238f0:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 80238f4:	6028      	str	r0, [r5, #0]
 80238f6:	6069      	str	r1, [r5, #4]
 80238f8:	60aa      	str	r2, [r5, #8]
 80238fa:	60eb      	str	r3, [r5, #12]
 80238fc:	4664      	mov	r4, ip
 80238fe:	3510      	adds	r5, #16
 8023900:	45f4      	cmp	ip, lr
 8023902:	d1f4      	bne.n	80238ee <custom_connect_and_send_data+0x1a>
 8023904:	cc03      	ldmia	r4!, {r0, r1}
 8023906:	6028      	str	r0, [r5, #0]
 8023908:	6069      	str	r1, [r5, #4]
 802390a:	8823      	ldrh	r3, [r4, #0]
 802390c:	812b      	strh	r3, [r5, #8]
 802390e:	4cc0      	ldr	r4, [pc, #768]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023910:	4620      	mov	r0, r4
 8023912:	f7fb fd0a 	bl	801f32a <crs_strlen>
 8023916:	b283      	uxth	r3, r0
 8023918:	4622      	mov	r2, r4
 802391a:	2101      	movs	r1, #1
 802391c:	2004      	movs	r0, #4
 802391e:	f7fb fd47 	bl	801f3b0 <traceIF_itmPrint>
 8023922:	4620      	mov	r0, r4
 8023924:	f7fb fd01 	bl	801f32a <crs_strlen>
 8023928:	b283      	uxth	r3, r0
 802392a:	4622      	mov	r2, r4
 802392c:	2101      	movs	r1, #1
 802392e:	2004      	movs	r0, #4
 8023930:	f7fb fd60 	bl	801f3f4 <traceIF_uartPrint>
	  id = com_socket(COM_AF_INET, COM_SOCK_STREAM, COM_IPPROTO_TCP);
 8023934:	2206      	movs	r2, #6
 8023936:	2101      	movs	r1, #1
 8023938:	2002      	movs	r0, #2
 802393a:	f7fc fc0d 	bl	8020158 <com_socket>
      if (id >= 0) /* no invalid value defined in network library */
 802393e:	f1b0 0900 	subs.w	r9, r0, #0
 8023942:	f2c0 81ee 	blt.w	8023d22 <custom_connect_and_send_data+0x44e>
    	  PRINT_INFO("socket create OK")
 8023946:	4db3      	ldr	r5, [pc, #716]	; (8023c14 <custom_connect_and_send_data+0x340>)
 8023948:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 802394a:	6020      	str	r0, [r4, #0]
 802394c:	6061      	str	r1, [r4, #4]
 802394e:	60a2      	str	r2, [r4, #8]
 8023950:	60e3      	str	r3, [r4, #12]
 8023952:	cd03      	ldmia	r5!, {r0, r1}
 8023954:	6120      	str	r0, [r4, #16]
 8023956:	6161      	str	r1, [r4, #20]
 8023958:	882b      	ldrh	r3, [r5, #0]
 802395a:	8323      	strh	r3, [r4, #24]
 802395c:	4620      	mov	r0, r4
 802395e:	f7fb fce4 	bl	801f32a <crs_strlen>
 8023962:	b283      	uxth	r3, r0
 8023964:	4622      	mov	r2, r4
 8023966:	2101      	movs	r1, #1
 8023968:	2004      	movs	r0, #4
 802396a:	f7fb fd21 	bl	801f3b0 <traceIF_itmPrint>
 802396e:	4620      	mov	r0, r4
 8023970:	f7fb fcdb 	bl	801f32a <crs_strlen>
 8023974:	b283      	uxth	r3, r0
 8023976:	4622      	mov	r2, r4
 8023978:	2101      	movs	r1, #1
 802397a:	2004      	movs	r0, #4
 802397c:	f7fb fd3a 	bl	801f3f4 <traceIF_uartPrint>
		if (com_setsockopt(id, COM_SOL_SOCKET, COM_SO_RCVTIMEO, &timeout, (int32_t)sizeof(timeout)) == COM_SOCKETS_ERR_OK)
 8023980:	2304      	movs	r3, #4
 8023982:	9300      	str	r3, [sp, #0]
 8023984:	ab07      	add	r3, sp, #28
 8023986:	f241 0206 	movw	r2, #4102	; 0x1006
 802398a:	f640 71ff 	movw	r1, #4095	; 0xfff
 802398e:	4648      	mov	r0, r9
 8023990:	f7fc fbe6 	bl	8020160 <com_setsockopt>
 8023994:	2800      	cmp	r0, #0
 8023996:	f040 819c 	bne.w	8023cd2 <custom_connect_and_send_data+0x3fe>
	          if (com_setsockopt(id, COM_SOL_SOCKET, COM_SO_SNDTIMEO, &timeout, (int32_t)sizeof(timeout)) == COM_SOCKETS_ERR_OK)
 802399a:	2304      	movs	r3, #4
 802399c:	9300      	str	r3, [sp, #0]
 802399e:	ab07      	add	r3, sp, #28
 80239a0:	f241 0205 	movw	r2, #4101	; 0x1005
 80239a4:	f640 71ff 	movw	r1, #4095	; 0xfff
 80239a8:	4648      	mov	r0, r9
 80239aa:	f7fc fbd9 	bl	8020160 <com_setsockopt>
 80239ae:	2800      	cmp	r0, #0
 80239b0:	f040 8167 	bne.w	8023c82 <custom_connect_and_send_data+0x3ae>
                address.sin_family      = (uint8_t)COM_AF_INET;
 80239b4:	2302      	movs	r3, #2
 80239b6:	f88d 300d 	strb.w	r3, [sp, #13]
                address.sin_addr.s_addr = COM_HTONL(SERVER_LOG_IP);
 80239ba:	4b97      	ldr	r3, [pc, #604]	; (8023c18 <custom_connect_and_send_data+0x344>)
 80239bc:	9304      	str	r3, [sp, #16]
                if(send_mud_link == 1){
 80239be:	2e01      	cmp	r6, #1
 80239c0:	f000 8093 	beq.w	8023aea <custom_connect_and_send_data+0x216>
                	address.sin_port        = COM_HTONS(SERVER_LOG_PORT);
 80239c4:	4b95      	ldr	r3, [pc, #596]	; (8023c1c <custom_connect_and_send_data+0x348>)
 80239c6:	881b      	ldrh	r3, [r3, #0]
 80239c8:	ba5b      	rev16	r3, r3
 80239ca:	f8ad 300e 	strh.w	r3, [sp, #14]
                if (com_connect(id, (com_sockaddr_t const *)&address, (int32_t)sizeof(com_sockaddr_in_t))
 80239ce:	2210      	movs	r2, #16
 80239d0:	a903      	add	r1, sp, #12
 80239d2:	4648      	mov	r0, r9
 80239d4:	f7fc fbcc 	bl	8020170 <com_connect>
 80239d8:	2800      	cmp	r0, #0
 80239da:	f040 80f2 	bne.w	8023bc2 <custom_connect_and_send_data+0x2ee>
                	PRINT_INFO("Send data in progress....\n\r");
 80239de:	f8df c25c 	ldr.w	ip, [pc, #604]	; 8023c3c <custom_connect_and_send_data+0x368>
 80239e2:	4c8b      	ldr	r4, [pc, #556]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 80239e4:	f10c 0e20 	add.w	lr, ip, #32
 80239e8:	4665      	mov	r5, ip
 80239ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80239ec:	6020      	str	r0, [r4, #0]
 80239ee:	6061      	str	r1, [r4, #4]
 80239f0:	60a2      	str	r2, [r4, #8]
 80239f2:	60e3      	str	r3, [r4, #12]
 80239f4:	46ac      	mov	ip, r5
 80239f6:	3410      	adds	r4, #16
 80239f8:	4575      	cmp	r5, lr
 80239fa:	d1f5      	bne.n	80239e8 <custom_connect_and_send_data+0x114>
 80239fc:	6828      	ldr	r0, [r5, #0]
 80239fe:	6020      	str	r0, [r4, #0]
 8023a00:	792b      	ldrb	r3, [r5, #4]
 8023a02:	7123      	strb	r3, [r4, #4]
 8023a04:	4c82      	ldr	r4, [pc, #520]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023a06:	4620      	mov	r0, r4
 8023a08:	f7fb fc8f 	bl	801f32a <crs_strlen>
 8023a0c:	b283      	uxth	r3, r0
 8023a0e:	4622      	mov	r2, r4
 8023a10:	2101      	movs	r1, #1
 8023a12:	2004      	movs	r0, #4
 8023a14:	f7fb fccc 	bl	801f3b0 <traceIF_itmPrint>
 8023a18:	4620      	mov	r0, r4
 8023a1a:	f7fb fc86 	bl	801f32a <crs_strlen>
 8023a1e:	b283      	uxth	r3, r0
 8023a20:	4622      	mov	r2, r4
 8023a22:	2101      	movs	r1, #1
 8023a24:	2004      	movs	r0, #4
 8023a26:	f7fb fce5 	bl	801f3f4 <traceIF_uartPrint>
                	PRINT_INFO("%s\n\r", buffer_addr);
 8023a2a:	4642      	mov	r2, r8
 8023a2c:	497c      	ldr	r1, [pc, #496]	; (8023c20 <custom_connect_and_send_data+0x34c>)
 8023a2e:	4620      	mov	r0, r4
 8023a30:	f002 ff0a 	bl	8026848 <sprintf>
 8023a34:	4620      	mov	r0, r4
 8023a36:	f7fb fc78 	bl	801f32a <crs_strlen>
 8023a3a:	b283      	uxth	r3, r0
 8023a3c:	4622      	mov	r2, r4
 8023a3e:	2101      	movs	r1, #1
 8023a40:	2004      	movs	r0, #4
 8023a42:	f7fb fcb5 	bl	801f3b0 <traceIF_itmPrint>
 8023a46:	4620      	mov	r0, r4
 8023a48:	f7fb fc6f 	bl	801f32a <crs_strlen>
 8023a4c:	b283      	uxth	r3, r0
 8023a4e:	4622      	mov	r2, r4
 8023a50:	2101      	movs	r1, #1
 8023a52:	2004      	movs	r0, #4
 8023a54:	f7fb fcce 	bl	801f3f4 <traceIF_uartPrint>
                	ret = com_send(id, (const com_char_t *)buffer_addr, buffer_len, COM_MSG_WAIT);
 8023a58:	2300      	movs	r3, #0
 8023a5a:	463a      	mov	r2, r7
 8023a5c:	4641      	mov	r1, r8
 8023a5e:	4648      	mov	r0, r9
 8023a60:	f7fc fb8a 	bl	8020178 <com_send>
                	if (ret == buffer_len)
 8023a64:	4287      	cmp	r7, r0
 8023a66:	d045      	beq.n	8023af4 <custom_connect_and_send_data+0x220>
	  result = false;
 8023a68:	2400      	movs	r4, #0
                	PRINT_INFO("before data size%d", socketResponse.data_len);
 8023a6a:	4d69      	ldr	r5, [pc, #420]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023a6c:	2200      	movs	r2, #0
 8023a6e:	496d      	ldr	r1, [pc, #436]	; (8023c24 <custom_connect_and_send_data+0x350>)
 8023a70:	4628      	mov	r0, r5
 8023a72:	f002 fee9 	bl	8026848 <sprintf>
 8023a76:	4628      	mov	r0, r5
 8023a78:	f7fb fc57 	bl	801f32a <crs_strlen>
 8023a7c:	b283      	uxth	r3, r0
 8023a7e:	462a      	mov	r2, r5
 8023a80:	2101      	movs	r1, #1
 8023a82:	2004      	movs	r0, #4
 8023a84:	f7fb fc94 	bl	801f3b0 <traceIF_itmPrint>
 8023a88:	4628      	mov	r0, r5
 8023a8a:	f7fb fc4e 	bl	801f32a <crs_strlen>
 8023a8e:	b283      	uxth	r3, r0
 8023a90:	462a      	mov	r2, r5
 8023a92:	2101      	movs	r1, #1
 8023a94:	2004      	movs	r0, #4
 8023a96:	f7fb fcad 	bl	801f3f4 <traceIF_uartPrint>
                	if (send_mud_link==1)
 8023a9a:	2e01      	cmp	r6, #1
 8023a9c:	d02c      	beq.n	8023af8 <custom_connect_and_send_data+0x224>
					if (com_closesocket(id) == COM_SOCKETS_ERR_OK)
 8023a9e:	4648      	mov	r0, r9
 8023aa0:	f7fc fb72 	bl	8020188 <com_closesocket>
 8023aa4:	2800      	cmp	r0, #0
 8023aa6:	d16e      	bne.n	8023b86 <custom_connect_and_send_data+0x2b2>
						PRINT_INFO("socket close OK\n\r")
 8023aa8:	4d59      	ldr	r5, [pc, #356]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023aaa:	4e5f      	ldr	r6, [pc, #380]	; (8023c28 <custom_connect_and_send_data+0x354>)
 8023aac:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8023aae:	6028      	str	r0, [r5, #0]
 8023ab0:	6069      	str	r1, [r5, #4]
 8023ab2:	60aa      	str	r2, [r5, #8]
 8023ab4:	60eb      	str	r3, [r5, #12]
 8023ab6:	ce03      	ldmia	r6!, {r0, r1}
 8023ab8:	6128      	str	r0, [r5, #16]
 8023aba:	6169      	str	r1, [r5, #20]
 8023abc:	8832      	ldrh	r2, [r6, #0]
 8023abe:	78b3      	ldrb	r3, [r6, #2]
 8023ac0:	832a      	strh	r2, [r5, #24]
 8023ac2:	76ab      	strb	r3, [r5, #26]
 8023ac4:	4628      	mov	r0, r5
 8023ac6:	f7fb fc30 	bl	801f32a <crs_strlen>
 8023aca:	b283      	uxth	r3, r0
 8023acc:	462a      	mov	r2, r5
 8023ace:	2101      	movs	r1, #1
 8023ad0:	2004      	movs	r0, #4
 8023ad2:	f7fb fc6d 	bl	801f3b0 <traceIF_itmPrint>
 8023ad6:	4628      	mov	r0, r5
 8023ad8:	f7fb fc27 	bl	801f32a <crs_strlen>
 8023adc:	b283      	uxth	r3, r0
 8023ade:	462a      	mov	r2, r5
 8023ae0:	2101      	movs	r1, #1
 8023ae2:	2004      	movs	r0, #4
 8023ae4:	f7fb fc86 	bl	801f3f4 <traceIF_uartPrint>
 8023ae8:	e13b      	b.n	8023d62 <custom_connect_and_send_data+0x48e>
                    address.sin_port        = COM_HTONS(MUD_LINK_PORT);
 8023aea:	f24a 030f 	movw	r3, #40975	; 0xa00f
 8023aee:	f8ad 300e 	strh.w	r3, [sp, #14]
 8023af2:	e76c      	b.n	80239ce <custom_connect_and_send_data+0xfa>
						result = true;
 8023af4:	2401      	movs	r4, #1
 8023af6:	e7b8      	b.n	8023a6a <custom_connect_and_send_data+0x196>
						int32_t ret2 = com_recv(id, (com_char_t *)buf, 2, COM_MSG_WAIT);
 8023af8:	2300      	movs	r3, #0
 8023afa:	2202      	movs	r2, #2
 8023afc:	a902      	add	r1, sp, #8
 8023afe:	4648      	mov	r0, r9
 8023b00:	f7fc fb3e 	bl	8020180 <com_recv>
 8023b04:	4602      	mov	r2, r0
						if (ret2 == 2) {
 8023b06:	2802      	cmp	r0, #2
 8023b08:	d01c      	beq.n	8023b44 <custom_connect_and_send_data+0x270>
							PRINT_INFO("Receive failed, got %d bytes\n", ret2);
 8023b0a:	4c41      	ldr	r4, [pc, #260]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023b0c:	4947      	ldr	r1, [pc, #284]	; (8023c2c <custom_connect_and_send_data+0x358>)
 8023b0e:	4620      	mov	r0, r4
 8023b10:	f002 fe9a 	bl	8026848 <sprintf>
 8023b14:	4620      	mov	r0, r4
 8023b16:	f7fb fc08 	bl	801f32a <crs_strlen>
 8023b1a:	b283      	uxth	r3, r0
 8023b1c:	4622      	mov	r2, r4
 8023b1e:	2101      	movs	r1, #1
 8023b20:	2004      	movs	r0, #4
 8023b22:	f7fb fc45 	bl	801f3b0 <traceIF_itmPrint>
 8023b26:	4620      	mov	r0, r4
 8023b28:	f7fb fbff 	bl	801f32a <crs_strlen>
 8023b2c:	b283      	uxth	r3, r0
 8023b2e:	4622      	mov	r2, r4
 8023b30:	2101      	movs	r1, #1
 8023b32:	2004      	movs	r0, #4
 8023b34:	f7fb fc5e 	bl	801f3f4 <traceIF_uartPrint>
							SERVER_LOG_PORT = -1;
 8023b38:	4b38      	ldr	r3, [pc, #224]	; (8023c1c <custom_connect_and_send_data+0x348>)
 8023b3a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8023b3e:	801a      	strh	r2, [r3, #0]
							result = false;
 8023b40:	2400      	movs	r4, #0
 8023b42:	e7ac      	b.n	8023a9e <custom_connect_and_send_data+0x1ca>
							uint16_t port = ntohs(net_port);
 8023b44:	f8bd 0008 	ldrh.w	r0, [sp, #8]
 8023b48:	f7ff febe 	bl	80238c8 <ntohs>
 8023b4c:	4605      	mov	r5, r0
							PRINT_INFO("Received port = %u\n", port);  // Should print 5000
 8023b4e:	4c30      	ldr	r4, [pc, #192]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023b50:	4602      	mov	r2, r0
 8023b52:	4937      	ldr	r1, [pc, #220]	; (8023c30 <custom_connect_and_send_data+0x35c>)
 8023b54:	4620      	mov	r0, r4
 8023b56:	f002 fe77 	bl	8026848 <sprintf>
 8023b5a:	4620      	mov	r0, r4
 8023b5c:	f7fb fbe5 	bl	801f32a <crs_strlen>
 8023b60:	b283      	uxth	r3, r0
 8023b62:	4622      	mov	r2, r4
 8023b64:	2101      	movs	r1, #1
 8023b66:	2004      	movs	r0, #4
 8023b68:	f7fb fc22 	bl	801f3b0 <traceIF_itmPrint>
 8023b6c:	4620      	mov	r0, r4
 8023b6e:	f7fb fbdc 	bl	801f32a <crs_strlen>
 8023b72:	b283      	uxth	r3, r0
 8023b74:	4622      	mov	r2, r4
 8023b76:	2101      	movs	r1, #1
 8023b78:	2004      	movs	r0, #4
 8023b7a:	f7fb fc3b 	bl	801f3f4 <traceIF_uartPrint>
							SERVER_LOG_PORT = port;
 8023b7e:	4b27      	ldr	r3, [pc, #156]	; (8023c1c <custom_connect_and_send_data+0x348>)
 8023b80:	801d      	strh	r5, [r3, #0]
							result = true;
 8023b82:	2401      	movs	r4, #1
 8023b84:	e78b      	b.n	8023a9e <custom_connect_and_send_data+0x1ca>
						PRINT_INFO("socket close NOK\n\r")
 8023b86:	4d22      	ldr	r5, [pc, #136]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023b88:	4e2a      	ldr	r6, [pc, #168]	; (8023c34 <custom_connect_and_send_data+0x360>)
 8023b8a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8023b8c:	6028      	str	r0, [r5, #0]
 8023b8e:	6069      	str	r1, [r5, #4]
 8023b90:	60aa      	str	r2, [r5, #8]
 8023b92:	60eb      	str	r3, [r5, #12]
 8023b94:	ce07      	ldmia	r6!, {r0, r1, r2}
 8023b96:	6128      	str	r0, [r5, #16]
 8023b98:	6169      	str	r1, [r5, #20]
 8023b9a:	61aa      	str	r2, [r5, #24]
 8023b9c:	4628      	mov	r0, r5
 8023b9e:	f7fb fbc4 	bl	801f32a <crs_strlen>
 8023ba2:	b283      	uxth	r3, r0
 8023ba4:	462a      	mov	r2, r5
 8023ba6:	2101      	movs	r1, #1
 8023ba8:	2004      	movs	r0, #4
 8023baa:	f7fb fc01 	bl	801f3b0 <traceIF_itmPrint>
 8023bae:	4628      	mov	r0, r5
 8023bb0:	f7fb fbbb 	bl	801f32a <crs_strlen>
 8023bb4:	b283      	uxth	r3, r0
 8023bb6:	462a      	mov	r2, r5
 8023bb8:	2101      	movs	r1, #1
 8023bba:	2004      	movs	r0, #4
 8023bbc:	f7fb fc1a 	bl	801f3f4 <traceIF_uartPrint>
 8023bc0:	e0cf      	b.n	8023d62 <custom_connect_and_send_data+0x48e>
                	PRINT_INFO("socket connect NOK\n\r")
 8023bc2:	4c13      	ldr	r4, [pc, #76]	; (8023c10 <custom_connect_and_send_data+0x33c>)
 8023bc4:	4d1c      	ldr	r5, [pc, #112]	; (8023c38 <custom_connect_and_send_data+0x364>)
 8023bc6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023bc8:	6020      	str	r0, [r4, #0]
 8023bca:	6061      	str	r1, [r4, #4]
 8023bcc:	60a2      	str	r2, [r4, #8]
 8023bce:	60e3      	str	r3, [r4, #12]
 8023bd0:	cd07      	ldmia	r5!, {r0, r1, r2}
 8023bd2:	6120      	str	r0, [r4, #16]
 8023bd4:	6161      	str	r1, [r4, #20]
 8023bd6:	61a2      	str	r2, [r4, #24]
 8023bd8:	882b      	ldrh	r3, [r5, #0]
 8023bda:	83a3      	strh	r3, [r4, #28]
 8023bdc:	4620      	mov	r0, r4
 8023bde:	f7fb fba4 	bl	801f32a <crs_strlen>
 8023be2:	b283      	uxth	r3, r0
 8023be4:	4622      	mov	r2, r4
 8023be6:	2101      	movs	r1, #1
 8023be8:	2004      	movs	r0, #4
 8023bea:	f7fb fbe1 	bl	801f3b0 <traceIF_itmPrint>
 8023bee:	4620      	mov	r0, r4
 8023bf0:	f7fb fb9b 	bl	801f32a <crs_strlen>
 8023bf4:	b283      	uxth	r3, r0
 8023bf6:	4622      	mov	r2, r4
 8023bf8:	2101      	movs	r1, #1
 8023bfa:	2004      	movs	r0, #4
 8023bfc:	f7fb fbfa 	bl	801f3f4 <traceIF_uartPrint>
					if (com_closesocket(id) == COM_SOCKETS_ERR_OK)
 8023c00:	4648      	mov	r0, r9
 8023c02:	f7fc fac1 	bl	8020188 <com_closesocket>
 8023c06:	b1d8      	cbz	r0, 8023c40 <custom_connect_and_send_data+0x36c>
	  result = false;
 8023c08:	2400      	movs	r4, #0
 8023c0a:	e0aa      	b.n	8023d62 <custom_connect_and_send_data+0x48e>
 8023c0c:	080371a8 	.word	0x080371a8
 8023c10:	20004adc 	.word	0x20004adc
 8023c14:	080371d4 	.word	0x080371d4
 8023c18:	a6a11533 	.word	0xa6a11533
 8023c1c:	2000024c 	.word	0x2000024c
 8023c20:	08037218 	.word	0x08037218
 8023c24:	08037228 	.word	0x08037228
 8023c28:	0803728c 	.word	0x0803728c
 8023c2c:	08037264 	.word	0x08037264
 8023c30:	08037244 	.word	0x08037244
 8023c34:	080372a8 	.word	0x080372a8
 8023c38:	080372c4 	.word	0x080372c4
 8023c3c:	080371f0 	.word	0x080371f0
							PRINT_INFO("socket close OK\n\r")
 8023c40:	4d4a      	ldr	r5, [pc, #296]	; (8023d6c <custom_connect_and_send_data+0x498>)
 8023c42:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023c44:	6020      	str	r0, [r4, #0]
 8023c46:	6061      	str	r1, [r4, #4]
 8023c48:	60a2      	str	r2, [r4, #8]
 8023c4a:	60e3      	str	r3, [r4, #12]
 8023c4c:	cd03      	ldmia	r5!, {r0, r1}
 8023c4e:	6120      	str	r0, [r4, #16]
 8023c50:	6161      	str	r1, [r4, #20]
 8023c52:	882a      	ldrh	r2, [r5, #0]
 8023c54:	78ab      	ldrb	r3, [r5, #2]
 8023c56:	8322      	strh	r2, [r4, #24]
 8023c58:	76a3      	strb	r3, [r4, #26]
 8023c5a:	4620      	mov	r0, r4
 8023c5c:	f7fb fb65 	bl	801f32a <crs_strlen>
 8023c60:	b283      	uxth	r3, r0
 8023c62:	4622      	mov	r2, r4
 8023c64:	2101      	movs	r1, #1
 8023c66:	2004      	movs	r0, #4
 8023c68:	f7fb fba2 	bl	801f3b0 <traceIF_itmPrint>
 8023c6c:	4620      	mov	r0, r4
 8023c6e:	f7fb fb5c 	bl	801f32a <crs_strlen>
 8023c72:	b283      	uxth	r3, r0
 8023c74:	4622      	mov	r2, r4
 8023c76:	2101      	movs	r1, #1
 8023c78:	2004      	movs	r0, #4
 8023c7a:	f7fb fbbb 	bl	801f3f4 <traceIF_uartPrint>
	  result = false;
 8023c7e:	2400      	movs	r4, #0
 8023c80:	e06f      	b.n	8023d62 <custom_connect_and_send_data+0x48e>
	        	  PRINT_INFO("socket setsockopt SNDTIMEO NOK\n\r")
 8023c82:	4d3b      	ldr	r5, [pc, #236]	; (8023d70 <custom_connect_and_send_data+0x49c>)
 8023c84:	4c3b      	ldr	r4, [pc, #236]	; (8023d74 <custom_connect_and_send_data+0x4a0>)
 8023c86:	f105 0720 	add.w	r7, r5, #32
 8023c8a:	462e      	mov	r6, r5
 8023c8c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8023c8e:	6020      	str	r0, [r4, #0]
 8023c90:	6061      	str	r1, [r4, #4]
 8023c92:	60a2      	str	r2, [r4, #8]
 8023c94:	60e3      	str	r3, [r4, #12]
 8023c96:	4635      	mov	r5, r6
 8023c98:	3410      	adds	r4, #16
 8023c9a:	42be      	cmp	r6, r7
 8023c9c:	d1f5      	bne.n	8023c8a <custom_connect_and_send_data+0x3b6>
 8023c9e:	cd03      	ldmia	r5!, {r0, r1}
 8023ca0:	6020      	str	r0, [r4, #0]
 8023ca2:	6061      	str	r1, [r4, #4]
 8023ca4:	882b      	ldrh	r3, [r5, #0]
 8023ca6:	8123      	strh	r3, [r4, #8]
 8023ca8:	4c32      	ldr	r4, [pc, #200]	; (8023d74 <custom_connect_and_send_data+0x4a0>)
 8023caa:	4620      	mov	r0, r4
 8023cac:	f7fb fb3d 	bl	801f32a <crs_strlen>
 8023cb0:	b283      	uxth	r3, r0
 8023cb2:	4622      	mov	r2, r4
 8023cb4:	2101      	movs	r1, #1
 8023cb6:	2004      	movs	r0, #4
 8023cb8:	f7fb fb7a 	bl	801f3b0 <traceIF_itmPrint>
 8023cbc:	4620      	mov	r0, r4
 8023cbe:	f7fb fb34 	bl	801f32a <crs_strlen>
 8023cc2:	b283      	uxth	r3, r0
 8023cc4:	4622      	mov	r2, r4
 8023cc6:	2101      	movs	r1, #1
 8023cc8:	2004      	movs	r0, #4
 8023cca:	f7fb fb93 	bl	801f3f4 <traceIF_uartPrint>
	  result = false;
 8023cce:	2400      	movs	r4, #0
 8023cd0:	e047      	b.n	8023d62 <custom_connect_and_send_data+0x48e>
			PRINT_INFO("socket setsockopt RCVTIMEO NOK\n\r")
 8023cd2:	4d29      	ldr	r5, [pc, #164]	; (8023d78 <custom_connect_and_send_data+0x4a4>)
 8023cd4:	4c27      	ldr	r4, [pc, #156]	; (8023d74 <custom_connect_and_send_data+0x4a0>)
 8023cd6:	f105 0720 	add.w	r7, r5, #32
 8023cda:	462e      	mov	r6, r5
 8023cdc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8023cde:	6020      	str	r0, [r4, #0]
 8023ce0:	6061      	str	r1, [r4, #4]
 8023ce2:	60a2      	str	r2, [r4, #8]
 8023ce4:	60e3      	str	r3, [r4, #12]
 8023ce6:	4635      	mov	r5, r6
 8023ce8:	3410      	adds	r4, #16
 8023cea:	42be      	cmp	r6, r7
 8023cec:	d1f5      	bne.n	8023cda <custom_connect_and_send_data+0x406>
 8023cee:	cd03      	ldmia	r5!, {r0, r1}
 8023cf0:	6020      	str	r0, [r4, #0]
 8023cf2:	6061      	str	r1, [r4, #4]
 8023cf4:	882b      	ldrh	r3, [r5, #0]
 8023cf6:	8123      	strh	r3, [r4, #8]
 8023cf8:	4c1e      	ldr	r4, [pc, #120]	; (8023d74 <custom_connect_and_send_data+0x4a0>)
 8023cfa:	4620      	mov	r0, r4
 8023cfc:	f7fb fb15 	bl	801f32a <crs_strlen>
 8023d00:	b283      	uxth	r3, r0
 8023d02:	4622      	mov	r2, r4
 8023d04:	2101      	movs	r1, #1
 8023d06:	2004      	movs	r0, #4
 8023d08:	f7fb fb52 	bl	801f3b0 <traceIF_itmPrint>
 8023d0c:	4620      	mov	r0, r4
 8023d0e:	f7fb fb0c 	bl	801f32a <crs_strlen>
 8023d12:	b283      	uxth	r3, r0
 8023d14:	4622      	mov	r2, r4
 8023d16:	2101      	movs	r1, #1
 8023d18:	2004      	movs	r0, #4
 8023d1a:	f7fb fb6b 	bl	801f3f4 <traceIF_uartPrint>
	  result = false;
 8023d1e:	2400      	movs	r4, #0
 8023d20:	e01f      	b.n	8023d62 <custom_connect_and_send_data+0x48e>
    	  PRINT_INFO("socket create NOK\n\r")
 8023d22:	4c14      	ldr	r4, [pc, #80]	; (8023d74 <custom_connect_and_send_data+0x4a0>)
 8023d24:	4d15      	ldr	r5, [pc, #84]	; (8023d7c <custom_connect_and_send_data+0x4a8>)
 8023d26:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023d28:	6020      	str	r0, [r4, #0]
 8023d2a:	6061      	str	r1, [r4, #4]
 8023d2c:	60a2      	str	r2, [r4, #8]
 8023d2e:	60e3      	str	r3, [r4, #12]
 8023d30:	cd07      	ldmia	r5!, {r0, r1, r2}
 8023d32:	6120      	str	r0, [r4, #16]
 8023d34:	6161      	str	r1, [r4, #20]
 8023d36:	61a2      	str	r2, [r4, #24]
 8023d38:	782b      	ldrb	r3, [r5, #0]
 8023d3a:	7723      	strb	r3, [r4, #28]
 8023d3c:	4620      	mov	r0, r4
 8023d3e:	f7fb faf4 	bl	801f32a <crs_strlen>
 8023d42:	b283      	uxth	r3, r0
 8023d44:	4622      	mov	r2, r4
 8023d46:	2101      	movs	r1, #1
 8023d48:	2004      	movs	r0, #4
 8023d4a:	f7fb fb31 	bl	801f3b0 <traceIF_itmPrint>
 8023d4e:	4620      	mov	r0, r4
 8023d50:	f7fb faeb 	bl	801f32a <crs_strlen>
 8023d54:	b283      	uxth	r3, r0
 8023d56:	4622      	mov	r2, r4
 8023d58:	2101      	movs	r1, #1
 8023d5a:	2004      	movs	r0, #4
 8023d5c:	f7fb fb4a 	bl	801f3f4 <traceIF_uartPrint>
	  result = false;
 8023d60:	2400      	movs	r4, #0
}
 8023d62:	4620      	mov	r0, r4
 8023d64:	b009      	add	sp, #36	; 0x24
 8023d66:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8023d6a:	bf00      	nop
 8023d6c:	0803728c 	.word	0x0803728c
 8023d70:	080372e4 	.word	0x080372e4
 8023d74:	20004adc 	.word	0x20004adc
 8023d78:	08037310 	.word	0x08037310
 8023d7c:	0803733c 	.word	0x0803733c

08023d80 <send_mudfile_link>:
  * @param  p_argument - parameter osThread
  * @note   Unused parameter
  * @retval -
  */
static bool send_mudfile_link()
{
 8023d80:	b570      	push	{r4, r5, r6, lr}
 8023d82:	b09c      	sub	sp, #112	; 0x70
	int	mems_string_len;
	char mems_string[100];
	mems_string_len = snprintf(mems_string, sizeof(mems_string), "http://%s/%d", MUD_URL, MUD_DEVICE_ID);
 8023d84:	2301      	movs	r3, #1
 8023d86:	9300      	str	r3, [sp, #0]
 8023d88:	4b3f      	ldr	r3, [pc, #252]	; (8023e88 <send_mudfile_link+0x108>)
 8023d8a:	4a40      	ldr	r2, [pc, #256]	; (8023e8c <send_mudfile_link+0x10c>)
 8023d8c:	2164      	movs	r1, #100	; 0x64
 8023d8e:	a803      	add	r0, sp, #12
 8023d90:	f002 fd26 	bl	80267e0 <snprintf>
	if ((logBuffer.data_len + mems_string_len) <= (sizeof(logBuffer.data)))
 8023d94:	4b3e      	ldr	r3, [pc, #248]	; (8023e90 <send_mudfile_link+0x110>)
 8023d96:	f8d3 5400 	ldr.w	r5, [r3, #1024]	; 0x400
 8023d9a:	f105 031d 	add.w	r3, r5, #29
 8023d9e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8023da2:	d83e      	bhi.n	8023e22 <send_mudfile_link+0xa2>
		{
			memcpy(&logBuffer.data[logBuffer.data_len], (const void *)mems_string, mems_string_len);
 8023da4:	4e3a      	ldr	r6, [pc, #232]	; (8023e90 <send_mudfile_link+0x110>)
 8023da6:	eb06 0c05 	add.w	ip, r6, r5
 8023daa:	ac03      	add	r4, sp, #12
 8023dac:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8023dae:	5170      	str	r0, [r6, r5]
 8023db0:	f8cc 1004 	str.w	r1, [ip, #4]
 8023db4:	f8cc 2008 	str.w	r2, [ip, #8]
 8023db8:	f8cc 300c 	str.w	r3, [ip, #12]
 8023dbc:	cc07      	ldmia	r4!, {r0, r1, r2}
 8023dbe:	f8cc 0010 	str.w	r0, [ip, #16]
 8023dc2:	f8cc 1014 	str.w	r1, [ip, #20]
 8023dc6:	f8cc 2018 	str.w	r2, [ip, #24]
 8023dca:	7823      	ldrb	r3, [r4, #0]
 8023dcc:	f88c 301c 	strb.w	r3, [ip, #28]
			logBuffer.data_len += mems_string_len;
 8023dd0:	f8d6 3400 	ldr.w	r3, [r6, #1024]	; 0x400
 8023dd4:	331d      	adds	r3, #29
 8023dd6:	f8c6 3400 	str.w	r3, [r6, #1024]	; 0x400
 8023dda:	e022      	b.n	8023e22 <send_mudfile_link+0xa2>
		}
	do {
		if (custom_connect_and_send_data(logBuffer.data, logBuffer.data_len, 1))
		{
			PRINT_INFO("data port received")
 8023ddc:	4c2d      	ldr	r4, [pc, #180]	; (8023e94 <send_mudfile_link+0x114>)
 8023dde:	4d2e      	ldr	r5, [pc, #184]	; (8023e98 <send_mudfile_link+0x118>)
 8023de0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8023de2:	6020      	str	r0, [r4, #0]
 8023de4:	6061      	str	r1, [r4, #4]
 8023de6:	60a2      	str	r2, [r4, #8]
 8023de8:	60e3      	str	r3, [r4, #12]
 8023dea:	cd07      	ldmia	r5!, {r0, r1, r2}
 8023dec:	6120      	str	r0, [r4, #16]
 8023dee:	6161      	str	r1, [r4, #20]
 8023df0:	61a2      	str	r2, [r4, #24]
 8023df2:	4620      	mov	r0, r4
 8023df4:	f7fb fa99 	bl	801f32a <crs_strlen>
 8023df8:	b283      	uxth	r3, r0
 8023dfa:	4622      	mov	r2, r4
 8023dfc:	2101      	movs	r1, #1
 8023dfe:	2004      	movs	r0, #4
 8023e00:	f7fb fad6 	bl	801f3b0 <traceIF_itmPrint>
 8023e04:	4620      	mov	r0, r4
 8023e06:	f7fb fa90 	bl	801f32a <crs_strlen>
 8023e0a:	b283      	uxth	r3, r0
 8023e0c:	4622      	mov	r2, r4
 8023e0e:	2101      	movs	r1, #1
 8023e10:	2004      	movs	r0, #4
 8023e12:	f7fb faef 	bl	801f3f4 <traceIF_uartPrint>
		{
			const TickType_t delay = 5000;
			PRINT_INFO("Mud link failed. Trying again in %d milliseconds.", delay);
			vTaskDelay( delay );
		}
	} while (SERVER_LOG_PORT == -1 || SERVER_LOG_PORT == 65535);
 8023e16:	4b21      	ldr	r3, [pc, #132]	; (8023e9c <send_mudfile_link+0x11c>)
 8023e18:	881a      	ldrh	r2, [r3, #0]
 8023e1a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8023e1e:	429a      	cmp	r2, r3
 8023e20:	d125      	bne.n	8023e6e <send_mudfile_link+0xee>
		if (custom_connect_and_send_data(logBuffer.data, logBuffer.data_len, 1))
 8023e22:	481b      	ldr	r0, [pc, #108]	; (8023e90 <send_mudfile_link+0x110>)
 8023e24:	2201      	movs	r2, #1
 8023e26:	f8d0 1400 	ldr.w	r1, [r0, #1024]	; 0x400
 8023e2a:	f7ff fd53 	bl	80238d4 <custom_connect_and_send_data>
 8023e2e:	2800      	cmp	r0, #0
 8023e30:	d1d4      	bne.n	8023ddc <send_mudfile_link+0x5c>
			PRINT_INFO("Mud link failed. Trying again in %d milliseconds.", delay);
 8023e32:	4c18      	ldr	r4, [pc, #96]	; (8023e94 <send_mudfile_link+0x114>)
 8023e34:	f241 3288 	movw	r2, #5000	; 0x1388
 8023e38:	4919      	ldr	r1, [pc, #100]	; (8023ea0 <send_mudfile_link+0x120>)
 8023e3a:	4620      	mov	r0, r4
 8023e3c:	f002 fd04 	bl	8026848 <sprintf>
 8023e40:	4620      	mov	r0, r4
 8023e42:	f7fb fa72 	bl	801f32a <crs_strlen>
 8023e46:	b283      	uxth	r3, r0
 8023e48:	4622      	mov	r2, r4
 8023e4a:	2101      	movs	r1, #1
 8023e4c:	2004      	movs	r0, #4
 8023e4e:	f7fb faaf 	bl	801f3b0 <traceIF_itmPrint>
 8023e52:	4620      	mov	r0, r4
 8023e54:	f7fb fa69 	bl	801f32a <crs_strlen>
 8023e58:	b283      	uxth	r3, r0
 8023e5a:	4622      	mov	r2, r4
 8023e5c:	2101      	movs	r1, #1
 8023e5e:	2004      	movs	r0, #4
 8023e60:	f7fb fac8 	bl	801f3f4 <traceIF_uartPrint>
			vTaskDelay( delay );
 8023e64:	f241 3088 	movw	r0, #5000	; 0x1388
 8023e68:	f001 ff10 	bl	8025c8c <vTaskDelay>
 8023e6c:	e7d3      	b.n	8023e16 <send_mudfile_link+0x96>


	//custom_connect_and_send_data(logBuffer.data, logBuffer.data_len, 1);
	memset(logBuffer.data, 0, sizeof(logBuffer.data));
 8023e6e:	4c08      	ldr	r4, [pc, #32]	; (8023e90 <send_mudfile_link+0x110>)
 8023e70:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8023e74:	2100      	movs	r1, #0
 8023e76:	4620      	mov	r0, r4
 8023e78:	f002 fd59 	bl	802692e <memset>
	logBuffer.data_len=0;
 8023e7c:	2300      	movs	r3, #0
 8023e7e:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
	return true;
}
 8023e82:	2001      	movs	r0, #1
 8023e84:	b01c      	add	sp, #112	; 0x70
 8023e86:	bd70      	pop	{r4, r5, r6, pc}
 8023e88:	0803735c 	.word	0x0803735c
 8023e8c:	08037374 	.word	0x08037374
 8023e90:	20005cac 	.word	0x20005cac
 8023e94:	20004adc 	.word	0x20004adc
 8023e98:	08037384 	.word	0x08037384
 8023e9c:	2000024c 	.word	0x2000024c
 8023ea0:	080373a0 	.word	0x080373a0

08023ea4 <custom_client_cmd>:
{
 8023ea4:	b530      	push	{r4, r5, lr}
 8023ea6:	b08b      	sub	sp, #44	; 0x2c
 8023ea8:	4605      	mov	r5, r0
  PRINT_APP("\n\r")
 8023eaa:	4c48      	ldr	r4, [pc, #288]	; (8023fcc <custom_client_cmd+0x128>)
 8023eac:	4b48      	ldr	r3, [pc, #288]	; (8023fd0 <custom_client_cmd+0x12c>)
 8023eae:	881a      	ldrh	r2, [r3, #0]
 8023eb0:	789b      	ldrb	r3, [r3, #2]
 8023eb2:	8022      	strh	r2, [r4, #0]
 8023eb4:	70a3      	strb	r3, [r4, #2]
 8023eb6:	4620      	mov	r0, r4
 8023eb8:	f7fb fa37 	bl	801f32a <crs_strlen>
 8023ebc:	b283      	uxth	r3, r0
 8023ebe:	4622      	mov	r2, r4
 8023ec0:	2101      	movs	r1, #1
 8023ec2:	2004      	movs	r0, #4
 8023ec4:	f7fb fa74 	bl	801f3b0 <traceIF_itmPrint>
 8023ec8:	4620      	mov	r0, r4
 8023eca:	f7fb fa2e 	bl	801f32a <crs_strlen>
 8023ece:	b282      	uxth	r2, r0
 8023ed0:	4621      	mov	r1, r4
 8023ed2:	2004      	movs	r0, #4
 8023ed4:	f7fb faa6 	bl	801f424 <traceIF_uartPrintForce>
  cmd_p = (uint8_t *)strtok((CRC_CHAR_t *)cmd_line_p, " \t");
 8023ed8:	493e      	ldr	r1, [pc, #248]	; (8023fd4 <custom_client_cmd+0x130>)
 8023eda:	4628      	mov	r0, r5
 8023edc:	f002 fd42 	bl	8026964 <strtok>
 8023ee0:	4605      	mov	r5, r0
             crs_strlen(cmd_p))
 8023ee2:	f7fb fa22 	bl	801f32a <crs_strlen>
 8023ee6:	4602      	mov	r2, r0
  if (memcmp((CRC_CHAR_t *)cmd_p,
 8023ee8:	493b      	ldr	r1, [pc, #236]	; (8023fd8 <custom_client_cmd+0x134>)
 8023eea:	4628      	mov	r0, r5
 8023eec:	f002 fd0f 	bl	802690e <memcmp>
 8023ef0:	b110      	cbz	r0, 8023ef8 <custom_client_cmd+0x54>
  cmd_status = CMD_OK;
 8023ef2:	2000      	movs	r0, #0
}
 8023ef4:	b00b      	add	sp, #44	; 0x2c
 8023ef6:	bd30      	pop	{r4, r5, pc}
    for (argc = 0U; argc < 10U; argc++)
 8023ef8:	2400      	movs	r4, #0
 8023efa:	2c09      	cmp	r4, #9
 8023efc:	d80b      	bhi.n	8023f16 <custom_client_cmd+0x72>
      argv_p[argc] = (uint8_t *)strtok(NULL, " \t");
 8023efe:	4935      	ldr	r1, [pc, #212]	; (8023fd4 <custom_client_cmd+0x130>)
 8023f00:	2000      	movs	r0, #0
 8023f02:	f002 fd2f 	bl	8026964 <strtok>
 8023f06:	ab0a      	add	r3, sp, #40	; 0x28
 8023f08:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8023f0c:	f843 0c28 	str.w	r0, [r3, #-40]
      if (argv_p[argc] == NULL)
 8023f10:	b108      	cbz	r0, 8023f16 <custom_client_cmd+0x72>
    for (argc = 0U; argc < 10U; argc++)
 8023f12:	3401      	adds	r4, #1
 8023f14:	e7f1      	b.n	8023efa <custom_client_cmd+0x56>
    if (argc == 0U)
 8023f16:	b90c      	cbnz	r4, 8023f1c <custom_client_cmd+0x78>
  cmd_status = CMD_OK;
 8023f18:	2000      	movs	r0, #0
 8023f1a:	e7eb      	b.n	8023ef4 <custom_client_cmd+0x50>
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8023f1c:	9c00      	ldr	r4, [sp, #0]
                    crs_strlen(argv_p[0])) == 0)
 8023f1e:	4620      	mov	r0, r4
 8023f20:	f7fb fa03 	bl	801f32a <crs_strlen>
 8023f24:	4602      	mov	r2, r0
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8023f26:	492d      	ldr	r1, [pc, #180]	; (8023fdc <custom_client_cmd+0x138>)
 8023f28:	4620      	mov	r0, r4
 8023f2a:	f002 fcf0 	bl	802690e <memcmp>
 8023f2e:	b9e0      	cbnz	r0, 8023f6a <custom_client_cmd+0xc6>
		if (custom_connect_and_send_data(logBuffer.data, logBuffer.data_len, 0)== true)
 8023f30:	482b      	ldr	r0, [pc, #172]	; (8023fe0 <custom_client_cmd+0x13c>)
 8023f32:	2200      	movs	r2, #0
 8023f34:	f8d0 1400 	ldr.w	r1, [r0, #1024]	; 0x400
 8023f38:	f7ff fccc 	bl	80238d4 <custom_connect_and_send_data>
 8023f3c:	b950      	cbnz	r0, 8023f54 <custom_client_cmd+0xb0>
		memset(logBuffer.data, 0, sizeof(logBuffer.data));
 8023f3e:	4c28      	ldr	r4, [pc, #160]	; (8023fe0 <custom_client_cmd+0x13c>)
 8023f40:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8023f44:	2100      	movs	r1, #0
 8023f46:	4620      	mov	r0, r4
 8023f48:	f002 fcf1 	bl	802692e <memset>
		logBuffer.data_len=0;
 8023f4c:	2000      	movs	r0, #0
 8023f4e:	f8c4 0400 	str.w	r0, [r4, #1024]	; 0x400
 8023f52:	e7cf      	b.n	8023ef4 <custom_client_cmd+0x50>
			memset(logBuffer.data, 0, sizeof(logBuffer.data));
 8023f54:	4c22      	ldr	r4, [pc, #136]	; (8023fe0 <custom_client_cmd+0x13c>)
 8023f56:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8023f5a:	2100      	movs	r1, #0
 8023f5c:	4620      	mov	r0, r4
 8023f5e:	f002 fce6 	bl	802692e <memset>
			logBuffer.data_len=0;
 8023f62:	2300      	movs	r3, #0
 8023f64:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
 8023f68:	e7e9      	b.n	8023f3e <custom_client_cmd+0x9a>
					crs_strlen(argv_p[0])) == 0)
 8023f6a:	4620      	mov	r0, r4
 8023f6c:	f7fb f9dd 	bl	801f32a <crs_strlen>
 8023f70:	4602      	mov	r2, r0
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8023f72:	491c      	ldr	r1, [pc, #112]	; (8023fe4 <custom_client_cmd+0x140>)
 8023f74:	4620      	mov	r0, r4
 8023f76:	f002 fcca 	bl	802690e <memcmp>
 8023f7a:	b998      	cbnz	r0, 8023fa4 <custom_client_cmd+0x100>
		if (custom_connect_and_send_data(logBuffer.data, logBuffer.data_len, 0)== true)
 8023f7c:	4818      	ldr	r0, [pc, #96]	; (8023fe0 <custom_client_cmd+0x13c>)
 8023f7e:	2200      	movs	r2, #0
 8023f80:	f8d0 1400 	ldr.w	r1, [r0, #1024]	; 0x400
 8023f84:	f7ff fca6 	bl	80238d4 <custom_connect_and_send_data>
 8023f88:	b908      	cbnz	r0, 8023f8e <custom_client_cmd+0xea>
  cmd_status = CMD_OK;
 8023f8a:	2000      	movs	r0, #0
 8023f8c:	e7b2      	b.n	8023ef4 <custom_client_cmd+0x50>
			memset(logBuffer.data, 0, sizeof(logBuffer.data));
 8023f8e:	4c14      	ldr	r4, [pc, #80]	; (8023fe0 <custom_client_cmd+0x13c>)
 8023f90:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8023f94:	2100      	movs	r1, #0
 8023f96:	4620      	mov	r0, r4
 8023f98:	f002 fcc9 	bl	802692e <memset>
			logBuffer.data_len=0;
 8023f9c:	2000      	movs	r0, #0
 8023f9e:	f8c4 0400 	str.w	r0, [r4, #1024]	; 0x400
 8023fa2:	e7a7      	b.n	8023ef4 <custom_client_cmd+0x50>
                    crs_strlen(argv_p[0])) == 0)
 8023fa4:	4620      	mov	r0, r4
 8023fa6:	f7fb f9c0 	bl	801f32a <crs_strlen>
 8023faa:	4602      	mov	r2, r0
    else if (memcmp((CRC_CHAR_t *)argv_p[0],
 8023fac:	490e      	ldr	r1, [pc, #56]	; (8023fe8 <custom_client_cmd+0x144>)
 8023fae:	4620      	mov	r0, r4
 8023fb0:	f002 fcad 	bl	802690e <memcmp>
 8023fb4:	b920      	cbnz	r0, 8023fc0 <custom_client_cmd+0x11c>
      cmd_status = custom_client_cmd_help(NULL, NULL);
 8023fb6:	2100      	movs	r1, #0
 8023fb8:	4608      	mov	r0, r1
 8023fba:	f7ff fbd1 	bl	8023760 <custom_client_cmd_help>
 8023fbe:	e799      	b.n	8023ef4 <custom_client_cmd+0x50>
      cmd_status = custom_client_cmd_help(cmd_p, argv_p[0]);
 8023fc0:	4621      	mov	r1, r4
 8023fc2:	4628      	mov	r0, r5
 8023fc4:	f7ff fbcc 	bl	8023760 <custom_client_cmd_help>
 8023fc8:	e794      	b.n	8023ef4 <custom_client_cmd+0x50>
 8023fca:	bf00      	nop
 8023fcc:	20004adc 	.word	0x20004adc
 8023fd0:	0802eac4 	.word	0x0802eac4
 8023fd4:	0803382c 	.word	0x0803382c
 8023fd8:	0803712c 	.word	0x0803712c
 8023fdc:	080373e8 	.word	0x080373e8
 8023fe0:	20005cac 	.word	0x20005cac
 8023fe4:	080373dc 	.word	0x080373dc
 8023fe8:	08033830 	.word	0x08033830

08023fec <custom_client_thread>:
static void custom_client_thread(void *p_argument)
{
 8023fec:	b500      	push	{lr}
 8023fee:	b087      	sub	sp, #28
  UNUSED(p_argument);

    /* Add below code of your application */
    /* Example : */
    /* Wait network is up to do something */
	uint32_t msg_queue = 0U;
 8023ff0:	2300      	movs	r3, #0
 8023ff2:	9305      	str	r3, [sp, #20]
	(void)rtosalMessageQueueGet(custom_client_queue, &msg_queue, RTOSAL_WAIT_FOREVER);
 8023ff4:	f04f 32ff 	mov.w	r2, #4294967295
 8023ff8:	a905      	add	r1, sp, #20
 8023ffa:	4b0c      	ldr	r3, [pc, #48]	; (802402c <custom_client_thread+0x40>)
 8023ffc:	6818      	ldr	r0, [r3, #0]
 8023ffe:	f7fb f8c6 	bl	801f18e <rtosalMessageQueueGet>

    /* Block for 5000ms. */
    const TickType_t xDelay = 1000 / portTICK_PERIOD_MS;
    send_mudfile_link();
 8024002:	f7ff febd 	bl	8023d80 <send_mudfile_link>
    for( ;; )
    {
        // Perform action here: log the mems
        custom_log_mems();
 8024006:	f7ff faf1 	bl	80235ec <custom_log_mems>
        uint8_t cmd[] = "custclt send";
 802400a:	4b09      	ldr	r3, [pc, #36]	; (8024030 <custom_client_thread+0x44>)
 802400c:	f10d 0c04 	add.w	ip, sp, #4
 8024010:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8024012:	e8ac 0007 	stmia.w	ip!, {r0, r1, r2}
 8024016:	f88c 3000 	strb.w	r3, [ip]
		custom_client_cmd(cmd);
 802401a:	a801      	add	r0, sp, #4
 802401c:	f7ff ff42 	bl	8023ea4 <custom_client_cmd>

        // Wait for the next cycle.
        vTaskDelay( xDelay );
 8024020:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8024024:	f001 fe32 	bl	8025c8c <vTaskDelay>
    for( ;; )
 8024028:	e7ed      	b.n	8024006 <custom_client_thread+0x1a>
 802402a:	bf00      	nop
 802402c:	20005ca8 	.word	0x20005ca8
 8024030:	080373e0 	.word	0x080373e0

08024034 <custom_client_init>:
  * @note   Custom Client initialization
  * @param  -
  * @retval -
  */
void custom_client_init(void)
{
 8024034:	b508      	push	{r3, lr}
  /* Custom Client static initialization */

  /* Example: */
  custom_client_modem_is_attached = false;
 8024036:	2000      	movs	r0, #0
 8024038:	4b07      	ldr	r3, [pc, #28]	; (8024058 <custom_client_init+0x24>)
 802403a:	7018      	strb	r0, [r3, #0]

  /* CustomClient queue creation */
  custom_client_queue = rtosalMessageQueueNew(NULL, 1U);
 802403c:	2101      	movs	r1, #1
 802403e:	f7fb f896 	bl	801f16e <rtosalMessageQueueNew>
 8024042:	4b06      	ldr	r3, [pc, #24]	; (802405c <custom_client_init+0x28>)
 8024044:	6018      	str	r0, [r3, #0]
  if (custom_client_queue == NULL)
 8024046:	b100      	cbz	r0, 802404a <custom_client_init+0x16>
  {
    ERROR_Handler(DBG_CHAN_CUSTOMCLIENT, 1, ERROR_FATAL);
  }
}
 8024048:	bd08      	pop	{r3, pc}
    ERROR_Handler(DBG_CHAN_CUSTOMCLIENT, 1, ERROR_FATAL);
 802404a:	2203      	movs	r2, #3
 802404c:	2101      	movs	r1, #1
 802404e:	2004      	movs	r0, #4
 8024050:	f7fa f988 	bl	801e364 <ERROR_Handler>
}
 8024054:	e7f8      	b.n	8024048 <custom_client_init+0x14>
 8024056:	bf00      	nop
 8024058:	20005ca4 	.word	0x20005ca4
 802405c:	20005ca8 	.word	0x20005ca8

08024060 <custom_client_start>:
  * @note   Custom Client start
  * @param  -
  * @retval -
  */
void custom_client_start(void)
{
 8024060:	b500      	push	{lr}
 8024062:	b083      	sub	sp, #12

  /* Cellular is now initialized
    Registration to other components is now possible */

  /* Registration to datacache */
  (void)dc_com_register_gen_event_cb(&dc_com_db, custom_client_notif_cb, (void *) NULL);
 8024064:	2200      	movs	r2, #0
 8024066:	490e      	ldr	r1, [pc, #56]	; (80240a0 <custom_client_start+0x40>)
 8024068:	480e      	ldr	r0, [pc, #56]	; (80240a4 <custom_client_start+0x44>)
 802406a:	f7fd ffe5 	bl	8022038 <dc_com_register_gen_event_cb>

#if ((USE_CMD_CONSOLE == 1)  && (CUSTOM_CLIENT_CMD != 0U))
  CMD_Declare(custom_client_cmd_label, custom_client_cmd, (uint8_t *)"customclient commands");
 802406e:	4a0e      	ldr	r2, [pc, #56]	; (80240a8 <custom_client_start+0x48>)
 8024070:	490e      	ldr	r1, [pc, #56]	; (80240ac <custom_client_start+0x4c>)
 8024072:	480f      	ldr	r0, [pc, #60]	; (80240b0 <custom_client_start+0x50>)
 8024074:	f7fe fc40 	bl	80228f8 <CMD_Declare>
#endif /* (USE_CMD_CONSOLE == 1) && (CUSTOM_CLIENT_CMD != 0U) */

  /* Create CustomClient thread  */
  CustomClient_TaskHandle = rtosalThreadNew((const rtosal_char_t *)"CustomCltThread", (os_pthread)custom_client_thread,
 8024078:	2200      	movs	r2, #0
 802407a:	9200      	str	r2, [sp, #0]
 802407c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8024080:	490c      	ldr	r1, [pc, #48]	; (80240b4 <custom_client_start+0x54>)
 8024082:	480d      	ldr	r0, [pc, #52]	; (80240b8 <custom_client_start+0x58>)
 8024084:	f7fb f83f 	bl	801f106 <rtosalThreadNew>
 8024088:	4b0c      	ldr	r3, [pc, #48]	; (80240bc <custom_client_start+0x5c>)
 802408a:	6018      	str	r0, [r3, #0]
                                            CUSTOMCLIENT_THREAD_PRIO, CUSTOMCLIENT_THREAD_STACK_SIZE, NULL);

  if (CustomClient_TaskHandle == NULL)
 802408c:	b110      	cbz	r0, 8024094 <custom_client_start+0x34>
  {
#if (USE_STACK_ANALYSIS == 1)
    (void)stackAnalysis_addStackSizeByHandle(CustomClient_TaskHandle, CUSTOMCLIENT_THREAD_STACK_SIZE);
#endif /* USE_STACK_ANALYSIS == 1 */
  }
}
 802408e:	b003      	add	sp, #12
 8024090:	f85d fb04 	ldr.w	pc, [sp], #4
    ERROR_Handler(DBG_CHAN_CUSTOMCLIENT, 2, ERROR_FATAL);
 8024094:	2203      	movs	r2, #3
 8024096:	2102      	movs	r1, #2
 8024098:	2004      	movs	r0, #4
 802409a:	f7fa f963 	bl	801e364 <ERROR_Handler>
}
 802409e:	e7f6      	b.n	802408e <custom_client_start+0x2e>
 80240a0:	080237f1 	.word	0x080237f1
 80240a4:	200058b0 	.word	0x200058b0
 80240a8:	080373f0 	.word	0x080373f0
 80240ac:	08023ea5 	.word	0x08023ea5
 80240b0:	0803712c 	.word	0x0803712c
 80240b4:	08023fed 	.word	0x08023fed
 80240b8:	08037408 	.word	0x08037408
 80240bc:	20005ca0 	.word	0x20005ca0

080240c0 <applications_init>:
  * @brief  Initialize the applications
  * @param  -
  * @retval -
  */
static void applications_init(void)
{
 80240c0:	b508      	push	{r3, lr}
#if (USE_CUSTOM_CLIENT == 1)
  custom_client_init();
 80240c2:	f7ff ffb7 	bl	8024034 <custom_client_init>
#endif /* (USE_COM_CLIENT == 1)  */

#if (USE_MQTT_CLIENT == 1)
  mqttclient_init();
#endif /* (USE_MQTT_CLIENT == 1) */
}
 80240c6:	bd08      	pop	{r3, pc}

080240c8 <utilities_init>:
  * @brief  Initialize the utilities
  * @param  -
  * @retval -
  */
static void utilities_init(void)
{
 80240c8:	b508      	push	{r3, lr}
  /* call to stackAnalysis_init() must be done earlier */
#if ((USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1))
  dc_mems_init();
 80240ca:	f7ff f9e5 	bl	8023498 <dc_mems_init>
#endif /* (USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1) */

#if (USE_DC_GENERIC == 1)
  dc_generic_init();
#endif /* (USE_DC_GENERIC == 1) */
}
 80240ce:	bd08      	pop	{r3, pc}

080240d0 <applications_start>:
  * @brief  Start the applications
  * @param  -
  * @retval -
  */
static void applications_start(void)
{
 80240d0:	b508      	push	{r3, lr}
#if (USE_CUSTOM_CLIENT == 1)
  custom_client_start();
 80240d2:	f7ff ffc5 	bl	8024060 <custom_client_start>
#endif /* (USE_COM_CLIENT == 1)  */

#if (USE_MQTT_CLIENT == 1)
  mqttclient_start();
#endif /* (USE_MQTT_CLIENT == 1) */
}
 80240d6:	bd08      	pop	{r3, pc}

080240d8 <utilities_start>:
  * @brief  Start the utilities
  * @param  -
  * @retval -
  */
static void utilities_start(void)
{
 80240d8:	b508      	push	{r3, lr}
#if (USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1)
  dc_mems_start();
 80240da:	f7ff fa5f 	bl	802359c <dc_mems_start>
#endif /* (USE_DC_MEMS == 1) || (USE_SIMU_MEMS == 1) */

#if (USE_DC_GENERIC == 1)
  dc_generic_start();
#endif /* (USE_DC_GENERIC == 1) */
}
 80240de:	bd08      	pop	{r3, pc}

080240e0 <StartDefaultTask>:
}


/* StartDefaultTask function */
void StartDefaultTask(void *p_argument)
{
 80240e0:	b508      	push	{r3, lr}
  UNUSED(p_argument);

  /* RandomNumberGenerator */
  srand(rtosalGetSysTimerCount());
 80240e2:	f7fb f80c 	bl	801f0fe <rtosalGetSysTimerCount>
 80240e6:	f002 fa93 	bl	8026610 <srand>
  (void)board_buttons_init();
#endif /* USE_BUTTONS == 1 */

#if (USE_LEDS == 1)
  /* Board Leds initialization    */
  (void)board_leds_init();
 80240ea:	f7fa f9e5 	bl	801e4b8 <board_leds_init>
#endif /* USE_LEDS == 1 */

#if (USE_PRINTF == 0U)
  /* Error Handler in the modules below may use trace print */
  /* Recall traceIF_init() in case MX_FREERTOS_Init is not used or is redefined */
  traceIF_init();
 80240ee:	f7fb fdad 	bl	801fc4c <traceIF_init>
  (void)stackAnalysis_addStackSizeByHandle(xTimerGetTimerDaemonTaskHandle(),
                                           (uint16_t)configTIMER_TASK_STACK_DEPTH);
#endif /* USE_STACK_ANALYSIS == 1 */

#if (USE_CMD_CONSOLE == 1)
  CMD_init();
 80240f2:	f7fe fc7f 	bl	80229f4 <CMD_init>

  /* Cellular components statical init */
#if (USE_NETWORK_LIBRARY == 1)
  cellular_net_init();
#else
  cellular_init();
 80240f6:	f7fb fe5d 	bl	801fdb4 <cellular_init>
#endif /* (USE_NETWORK_LIBRARY == 1) */

  /* Application components statical init  */
  applications_init();
 80240fa:	f7ff ffe1 	bl	80240c0 <applications_init>

  /* Other optional components statical init */
  utilities_init();
 80240fe:	f7ff ffe3 	bl	80240c8 <utilities_init>
    (void)board_buttons_start();
#endif /* USE_BUTTONS == 1 */

#if (USE_LEDS == 1)
    /* Board Leds start    */
    (void)board_leds_start();
 8024102:	f7fa f9e5 	bl	801e4d0 <board_leds_start>

    /* Cellular components start */
#if (USE_NETWORK_LIBRARY == 1)
    cellular_net_start();
#else
    cellular_start();
 8024106:	f7fb fe65 	bl	801fdd4 <cellular_start>
#endif /* (USE_NETWORK_LIBRARY == 1) */

    /* Application components start */
    applications_start();
 802410a:	f7ff ffe1 	bl	80240d0 <applications_start>

    /* Utilities components start */
    utilities_start();
 802410e:	f7ff ffe3 	bl	80240d8 <utilities_start>
  }

#if (USE_CMD_CONSOLE == 1)
  CMD_start();
 8024112:	f7fe fcc3 	bl	8022a9c <CMD_start>
  /* If stack analysis is activated check stack overflow after all init/start */
  (void)stackAnalysis_trace();
#endif /* USE_STACK_ANALYSIS == 1 */
  /* Platform Initialization and Thread Start are done */
  /* No more need of this thread wait a little before to free the memory */
  (void)rtosalDelay(2000U);
 8024116:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 802411a:	f7fb f85e 	bl	801f1da <rtosalDelay>
  vTaskDelete(NULL);
 802411e:	2000      	movs	r0, #0
 8024120:	f001 fbe4 	bl	80258ec <vTaskDelete>
}
 8024124:	bd08      	pop	{r3, pc}
	...

08024128 <MX_FREERTOS_Init>:
{
 8024128:	b500      	push	{lr}
 802412a:	b083      	sub	sp, #12
  defaultTaskHandle = rtosalThreadNew((const rtosal_char_t *)"StartDefaultThread", (os_pthread)StartDefaultTask,
 802412c:	2300      	movs	r3, #0
 802412e:	9300      	str	r3, [sp, #0]
 8024130:	f44f 73c0 	mov.w	r3, #384	; 0x180
 8024134:	2201      	movs	r2, #1
 8024136:	4909      	ldr	r1, [pc, #36]	; (802415c <MX_FREERTOS_Init+0x34>)
 8024138:	4809      	ldr	r0, [pc, #36]	; (8024160 <MX_FREERTOS_Init+0x38>)
 802413a:	f7fa ffe4 	bl	801f106 <rtosalThreadNew>
 802413e:	4b09      	ldr	r3, [pc, #36]	; (8024164 <MX_FREERTOS_Init+0x3c>)
 8024140:	6018      	str	r0, [r3, #0]
  if (defaultTaskHandle == NULL)
 8024142:	b110      	cbz	r0, 802414a <MX_FREERTOS_Init+0x22>
}
 8024144:	b003      	add	sp, #12
 8024146:	f85d fb04 	ldr.w	pc, [sp], #4
    traceIF_init();
 802414a:	f7fb fd7f 	bl	801fc4c <traceIF_init>
    ERROR_Handler(DBG_CHAN_MAIN, 0, ERROR_FATAL);
 802414e:	2203      	movs	r2, #3
 8024150:	2100      	movs	r1, #0
 8024152:	2001      	movs	r0, #1
 8024154:	f7fa f906 	bl	801e364 <ERROR_Handler>
}
 8024158:	e7f4      	b.n	8024144 <MX_FREERTOS_Init+0x1c>
 802415a:	bf00      	nop
 802415c:	080240e1 	.word	0x080240e1
 8024160:	08037418 	.word	0x08037418
 8024164:	200060b0 	.word	0x200060b0

08024168 <makeFreeRtosPriority>:
/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  
  if (priority != osPriorityError) {
 8024168:	2884      	cmp	r0, #132	; 0x84
 802416a:	d001      	beq.n	8024170 <makeFreeRtosPriority+0x8>
    fpriority += (priority - osPriorityIdle);
 802416c:	3003      	adds	r0, #3
 802416e:	4770      	bx	lr
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 8024170:	2000      	movs	r0, #0
  }
  
  return fpriority;
}
 8024172:	4770      	bx	lr

08024174 <inHandlerMode>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8024174:	f3ef 8005 	mrs	r0, IPSR

/* Determine whether we are in thread mode or handler mode. */
static int inHandlerMode (void)
{
  return __get_IPSR() != 0;
}
 8024178:	3800      	subs	r0, #0
 802417a:	bf18      	it	ne
 802417c:	2001      	movne	r0, #1
 802417e:	4770      	bx	lr

08024180 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8024180:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8024182:	f001 fc23 	bl	80259cc <vTaskStartScheduler>
  
  return osOK;
}
 8024186:	2000      	movs	r0, #0
 8024188:	bd08      	pop	{r3, pc}

0802418a <osKernelSysTick>:
* @param  None
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
 802418a:	b508      	push	{r3, lr}
  if (inHandlerMode()) {
 802418c:	f7ff fff2 	bl	8024174 <inHandlerMode>
 8024190:	b110      	cbz	r0, 8024198 <osKernelSysTick+0xe>
    return xTaskGetTickCountFromISR();
 8024192:	f001 fc6b 	bl	8025a6c <xTaskGetTickCountFromISR>
  }
  else {
    return xTaskGetTickCount();
  }
}
 8024196:	bd08      	pop	{r3, pc}
    return xTaskGetTickCount();
 8024198:	f001 fc62 	bl	8025a60 <xTaskGetTickCount>
 802419c:	e7fb      	b.n	8024196 <osKernelSysTick+0xc>

0802419e <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 802419e:	b5f0      	push	{r4, r5, r6, r7, lr}
 80241a0:	b085      	sub	sp, #20
 80241a2:	460c      	mov	r4, r1

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80241a4:	6845      	ldr	r5, [r0, #4]
 80241a6:	6806      	ldr	r6, [r0, #0]
                   thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
 80241a8:	6907      	ldr	r7, [r0, #16]
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80241aa:	f9b0 0008 	ldrsh.w	r0, [r0, #8]
 80241ae:	f7ff ffdb 	bl	8024168 <makeFreeRtosPriority>
 80241b2:	ab03      	add	r3, sp, #12
 80241b4:	9301      	str	r3, [sp, #4]
 80241b6:	9000      	str	r0, [sp, #0]
 80241b8:	4623      	mov	r3, r4
 80241ba:	b2ba      	uxth	r2, r7
 80241bc:	4631      	mov	r1, r6
 80241be:	4628      	mov	r0, r5
 80241c0:	f001 fb62 	bl	8025888 <xTaskCreate>
 80241c4:	2801      	cmp	r0, #1
 80241c6:	d102      	bne.n	80241ce <osThreadCreate+0x30>
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 80241c8:	9803      	ldr	r0, [sp, #12]
}
 80241ca:	b005      	add	sp, #20
 80241cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return NULL;
 80241ce:	2000      	movs	r0, #0
 80241d0:	e7fb      	b.n	80241ca <osThreadCreate+0x2c>

080241d2 <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 80241d2:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 80241d4:	b900      	cbnz	r0, 80241d8 <osDelay+0x6>
 80241d6:	2001      	movs	r0, #1
 80241d8:	f001 fd58 	bl	8025c8c <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 80241dc:	2000      	movs	r0, #0
 80241de:	bd08      	pop	{r3, pc}

080241e0 <osTimerCreate>:
* @param  argument      argument to the timer call back function.
* @retval  timer ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
*/
osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
{
 80241e0:	b500      	push	{lr}
 80241e2:	b083      	sub	sp, #12
 80241e4:	4613      	mov	r3, r2
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TimerCallbackFunction_t)timer_def->ptimer,
                      (StaticTimer_t *)timer_def->controlblock);  
#else
  return xTimerCreate((const char *)"",
 80241e6:	2901      	cmp	r1, #1
 80241e8:	d009      	beq.n	80241fe <osTimerCreate+0x1e>
 80241ea:	2200      	movs	r2, #0
                      1, // period should be filled when starting the Timer using osTimerStart
                      (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
                      (void *) argument,
                      (TimerCallbackFunction_t)timer_def->ptimer);
 80241ec:	6801      	ldr	r1, [r0, #0]
  return xTimerCreate((const char *)"",
 80241ee:	9100      	str	r1, [sp, #0]
 80241f0:	2101      	movs	r1, #1
 80241f2:	4804      	ldr	r0, [pc, #16]	; (8024204 <osTimerCreate+0x24>)
 80241f4:	f002 f86c 	bl	80262d0 <xTimerCreate>
#endif

#else 
	return NULL;
#endif
}
 80241f8:	b003      	add	sp, #12
 80241fa:	f85d fb04 	ldr.w	pc, [sp], #4
  return xTimerCreate((const char *)"",
 80241fe:	2201      	movs	r2, #1
 8024200:	e7f4      	b.n	80241ec <osTimerCreate+0xc>
 8024202:	bf00      	nop
 8024204:	08035c54 	.word	0x08035c54

08024208 <osTimerStart>:
* @param  millisec      time delay value of the timer.
* @retval  status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
{
 8024208:	b530      	push	{r4, r5, lr}
 802420a:	b085      	sub	sp, #20
 802420c:	4604      	mov	r4, r0
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 802420e:	2300      	movs	r3, #0
 8024210:	9303      	str	r3, [sp, #12]
  TickType_t ticks = millisec / portTICK_PERIOD_MS;

  if (ticks == 0)
 8024212:	460d      	mov	r5, r1
 8024214:	b901      	cbnz	r1, 8024218 <osTimerStart+0x10>
    ticks = 1;
 8024216:	2501      	movs	r5, #1
    
  if (inHandlerMode()) 
 8024218:	f7ff ffac 	bl	8024174 <inHandlerMode>
 802421c:	b1d0      	cbz	r0, 8024254 <osTimerStart+0x4c>
  {
    if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
 802421e:	2300      	movs	r3, #0
 8024220:	9300      	str	r3, [sp, #0]
 8024222:	ab03      	add	r3, sp, #12
 8024224:	462a      	mov	r2, r5
 8024226:	2109      	movs	r1, #9
 8024228:	4620      	mov	r0, r4
 802422a:	f002 f86d 	bl	8026308 <xTimerGenericCommand>
 802422e:	2801      	cmp	r0, #1
 8024230:	d002      	beq.n	8024238 <osTimerStart+0x30>
    {
      result = osErrorOS;
 8024232:	20ff      	movs	r0, #255	; 0xff

#else 
  result = osErrorOS;
#endif
  return result;
}
 8024234:	b005      	add	sp, #20
 8024236:	bd30      	pop	{r4, r5, pc}
      portEND_SWITCHING_ISR(taskWoken);     
 8024238:	9b03      	ldr	r3, [sp, #12]
 802423a:	b1c3      	cbz	r3, 802426e <osTimerStart+0x66>
 802423c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024240:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024244:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024248:	f3bf 8f4f 	dsb	sy
 802424c:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8024250:	2000      	movs	r0, #0
 8024252:	e7ef      	b.n	8024234 <osTimerStart+0x2c>
    if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
 8024254:	2300      	movs	r3, #0
 8024256:	9300      	str	r3, [sp, #0]
 8024258:	462a      	mov	r2, r5
 802425a:	2104      	movs	r1, #4
 802425c:	4620      	mov	r0, r4
 802425e:	f002 f853 	bl	8026308 <xTimerGenericCommand>
 8024262:	2801      	cmp	r0, #1
 8024264:	d001      	beq.n	802426a <osTimerStart+0x62>
      result = osErrorOS;
 8024266:	20ff      	movs	r0, #255	; 0xff
  return result;
 8024268:	e7e4      	b.n	8024234 <osTimerStart+0x2c>
  osStatus result = osOK;
 802426a:	2000      	movs	r0, #0
 802426c:	e7e2      	b.n	8024234 <osTimerStart+0x2c>
 802426e:	2000      	movs	r0, #0
 8024270:	e7e0      	b.n	8024234 <osTimerStart+0x2c>

08024272 <osTimerStop>:
* @param  timer_id      timer ID obtained by \ref osTimerCreate
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
*/
osStatus osTimerStop (osTimerId timer_id)
{
 8024272:	b510      	push	{r4, lr}
 8024274:	b084      	sub	sp, #16
 8024276:	4604      	mov	r4, r0
  osStatus result = osOK;
#if (configUSE_TIMERS == 1)  
  portBASE_TYPE taskWoken = pdFALSE;
 8024278:	2300      	movs	r3, #0
 802427a:	9303      	str	r3, [sp, #12]

  if (inHandlerMode()) {
 802427c:	f7ff ff7a 	bl	8024174 <inHandlerMode>
 8024280:	b1b0      	cbz	r0, 80242b0 <osTimerStop+0x3e>
    if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
 8024282:	2200      	movs	r2, #0
 8024284:	9200      	str	r2, [sp, #0]
 8024286:	ab03      	add	r3, sp, #12
 8024288:	2108      	movs	r1, #8
 802428a:	4620      	mov	r0, r4
 802428c:	f002 f83c 	bl	8026308 <xTimerGenericCommand>
 8024290:	2801      	cmp	r0, #1
 8024292:	d11b      	bne.n	80242cc <osTimerStop+0x5a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8024294:	9b03      	ldr	r3, [sp, #12]
 8024296:	b1db      	cbz	r3, 80242d0 <osTimerStop+0x5e>
 8024298:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802429c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80242a0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80242a4:	f3bf 8f4f 	dsb	sy
 80242a8:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 80242ac:	2000      	movs	r0, #0
 80242ae:	e009      	b.n	80242c4 <osTimerStop+0x52>
  }
  else {
    if (xTimerStop(timer_id, 0) != pdPASS) {
 80242b0:	2200      	movs	r2, #0
 80242b2:	9200      	str	r2, [sp, #0]
 80242b4:	4613      	mov	r3, r2
 80242b6:	2103      	movs	r1, #3
 80242b8:	4620      	mov	r0, r4
 80242ba:	f002 f825 	bl	8026308 <xTimerGenericCommand>
 80242be:	2801      	cmp	r0, #1
 80242c0:	d002      	beq.n	80242c8 <osTimerStop+0x56>
      result = osErrorOS;
 80242c2:	20ff      	movs	r0, #255	; 0xff
  }
#else 
  result = osErrorOS;
#endif 
  return result;
}
 80242c4:	b004      	add	sp, #16
 80242c6:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 80242c8:	2000      	movs	r0, #0
 80242ca:	e7fb      	b.n	80242c4 <osTimerStop+0x52>
      return osErrorOS;
 80242cc:	20ff      	movs	r0, #255	; 0xff
 80242ce:	e7f9      	b.n	80242c4 <osTimerStop+0x52>
  osStatus result = osOK;
 80242d0:	2000      	movs	r0, #0
 80242d2:	e7f7      	b.n	80242c4 <osTimerStop+0x52>

080242d4 <osMutexCreate>:
* @param  mutex_def     mutex definition referenced with \ref osMutex.
* @retval  mutex ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
*/
osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
{
 80242d4:	b508      	push	{r3, lr}
    return xSemaphoreCreateMutex(); 
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
#else  
    return xSemaphoreCreateMutex(); 
 80242d6:	2001      	movs	r0, #1
 80242d8:	f000 fe75 	bl	8024fc6 <xQueueCreateMutex>
#endif
#else
  return NULL;
#endif
}
 80242dc:	bd08      	pop	{r3, pc}

080242de <osMutexWait>:
* @param millisec      timeout value or 0 in case of no time-out.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
{
 80242de:	b530      	push	{r4, r5, lr}
 80242e0:	b083      	sub	sp, #12
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 80242e2:	2300      	movs	r3, #0
 80242e4:	9301      	str	r3, [sp, #4]
  
  
  if (mutex_id == NULL) {
 80242e6:	b310      	cbz	r0, 802432e <osMutexWait+0x50>
 80242e8:	460c      	mov	r4, r1
 80242ea:	4605      	mov	r5, r0
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 80242ec:	f7ff ff42 	bl	8024174 <inHandlerMode>
 80242f0:	b1a0      	cbz	r0, 802431c <osMutexWait+0x3e>
    if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
 80242f2:	aa01      	add	r2, sp, #4
 80242f4:	2100      	movs	r1, #0
 80242f6:	4628      	mov	r0, r5
 80242f8:	f001 f8b1 	bl	802545e <xQueueReceiveFromISR>
 80242fc:	2801      	cmp	r0, #1
 80242fe:	d118      	bne.n	8024332 <osMutexWait+0x54>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 8024300:	9b01      	ldr	r3, [sp, #4]
 8024302:	b1c3      	cbz	r3, 8024336 <osMutexWait+0x58>
 8024304:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024308:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802430c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024310:	f3bf 8f4f 	dsb	sy
 8024314:	f3bf 8f6f 	isb	sy
  } 
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 8024318:	2000      	movs	r0, #0
 802431a:	e006      	b.n	802432a <osMutexWait+0x4c>
  else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
 802431c:	4621      	mov	r1, r4
 802431e:	4628      	mov	r0, r5
 8024320:	f000 ffca 	bl	80252b8 <xQueueSemaphoreTake>
 8024324:	2801      	cmp	r0, #1
 8024326:	d108      	bne.n	802433a <osMutexWait+0x5c>
  return osOK;
 8024328:	2000      	movs	r0, #0
}
 802432a:	b003      	add	sp, #12
 802432c:	bd30      	pop	{r4, r5, pc}
    return osErrorParameter;
 802432e:	2080      	movs	r0, #128	; 0x80
 8024330:	e7fb      	b.n	802432a <osMutexWait+0x4c>
      return osErrorOS;
 8024332:	20ff      	movs	r0, #255	; 0xff
 8024334:	e7f9      	b.n	802432a <osMutexWait+0x4c>
  return osOK;
 8024336:	2000      	movs	r0, #0
 8024338:	e7f7      	b.n	802432a <osMutexWait+0x4c>
    return osErrorOS;
 802433a:	20ff      	movs	r0, #255	; 0xff
 802433c:	e7f5      	b.n	802432a <osMutexWait+0x4c>

0802433e <osMutexRelease>:
* @param mutex_id      mutex ID obtained by \ref osMutexCreate.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osMutexRelease (osMutexId mutex_id)
{
 802433e:	b510      	push	{r4, lr}
 8024340:	b082      	sub	sp, #8
 8024342:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 8024344:	2300      	movs	r3, #0
 8024346:	9301      	str	r3, [sp, #4]
  
  if (inHandlerMode()) {
 8024348:	f7ff ff14 	bl	8024174 <inHandlerMode>
 802434c:	b198      	cbz	r0, 8024376 <osMutexRelease+0x38>
    if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
 802434e:	a901      	add	r1, sp, #4
 8024350:	4620      	mov	r0, r4
 8024352:	f000 fea9 	bl	80250a8 <xQueueGiveFromISR>
 8024356:	2801      	cmp	r0, #1
 8024358:	d11a      	bne.n	8024390 <osMutexRelease+0x52>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 802435a:	9b01      	ldr	r3, [sp, #4]
 802435c:	b1d3      	cbz	r3, 8024394 <osMutexRelease+0x56>
 802435e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024362:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024366:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 802436a:	f3bf 8f4f 	dsb	sy
 802436e:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8024372:	2000      	movs	r0, #0
 8024374:	e008      	b.n	8024388 <osMutexRelease+0x4a>
  }
  else if (xSemaphoreGive(mutex_id) != pdTRUE) 
 8024376:	2300      	movs	r3, #0
 8024378:	461a      	mov	r2, r3
 802437a:	4619      	mov	r1, r3
 802437c:	4620      	mov	r0, r4
 802437e:	f000 fd52 	bl	8024e26 <xQueueGenericSend>
 8024382:	2801      	cmp	r0, #1
 8024384:	d002      	beq.n	802438c <osMutexRelease+0x4e>
  {
    result = osErrorOS;
 8024386:	20ff      	movs	r0, #255	; 0xff
  }
  return result;
}
 8024388:	b002      	add	sp, #8
 802438a:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 802438c:	2000      	movs	r0, #0
 802438e:	e7fb      	b.n	8024388 <osMutexRelease+0x4a>
      return osErrorOS;
 8024390:	20ff      	movs	r0, #255	; 0xff
 8024392:	e7f9      	b.n	8024388 <osMutexRelease+0x4a>
  osStatus result = osOK;
 8024394:	2000      	movs	r0, #0
 8024396:	e7f7      	b.n	8024388 <osMutexRelease+0x4a>

08024398 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
 8024398:	b510      	push	{r4, lr}
#endif    
  }
#else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
  osSemaphoreId sema;
 
  if (count == 1) {
 802439a:	2901      	cmp	r1, #1
 802439c:	d005      	beq.n	80243aa <osSemaphoreCreate+0x12>
    vSemaphoreCreateBinary(sema);
    return sema;
  }
  else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
    return xSemaphoreCreateCounting(count, count);
 802439e:	4608      	mov	r0, r1
 80243a0:	f000 fd23 	bl	8024dea <xQueueCreateCountingSemaphore>
 80243a4:	4604      	mov	r4, r0
#else
    return NULL;
#endif
  }
#endif
}
 80243a6:	4620      	mov	r0, r4
 80243a8:	bd10      	pop	{r4, pc}
    vSemaphoreCreateBinary(sema);
 80243aa:	2203      	movs	r2, #3
 80243ac:	2100      	movs	r1, #0
 80243ae:	2001      	movs	r0, #1
 80243b0:	f000 fcf7 	bl	8024da2 <xQueueGenericCreate>
 80243b4:	4604      	mov	r4, r0
 80243b6:	2800      	cmp	r0, #0
 80243b8:	d0f5      	beq.n	80243a6 <osSemaphoreCreate+0xe>
 80243ba:	2300      	movs	r3, #0
 80243bc:	461a      	mov	r2, r3
 80243be:	4619      	mov	r1, r3
 80243c0:	f000 fd31 	bl	8024e26 <xQueueGenericSend>
    return sema;
 80243c4:	e7ef      	b.n	80243a6 <osSemaphoreCreate+0xe>

080243c6 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
 80243c6:	b570      	push	{r4, r5, r6, lr}
 80243c8:	b082      	sub	sp, #8
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
 80243ca:	2300      	movs	r3, #0
 80243cc:	9301      	str	r3, [sp, #4]
  
  
  if (semaphore_id == NULL) {
 80243ce:	b318      	cbz	r0, 8024418 <osSemaphoreWait+0x52>
 80243d0:	460c      	mov	r4, r1
 80243d2:	4606      	mov	r6, r0
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 80243d4:	f7ff fece 	bl	8024174 <inHandlerMode>
 80243d8:	4605      	mov	r5, r0
 80243da:	b1a0      	cbz	r0, 8024406 <osSemaphoreWait+0x40>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 80243dc:	aa01      	add	r2, sp, #4
 80243de:	2100      	movs	r1, #0
 80243e0:	4630      	mov	r0, r6
 80243e2:	f001 f83c 	bl	802545e <xQueueReceiveFromISR>
 80243e6:	2801      	cmp	r0, #1
 80243e8:	d118      	bne.n	802441c <osSemaphoreWait+0x56>
      return osErrorOS;
    }
	portEND_SWITCHING_ISR(taskWoken);
 80243ea:	9d01      	ldr	r5, [sp, #4]
 80243ec:	b18d      	cbz	r5, 8024412 <osSemaphoreWait+0x4c>
 80243ee:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80243f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80243f6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80243fa:	f3bf 8f4f 	dsb	sy
 80243fe:	f3bf 8f6f 	isb	sy
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    return osErrorOS;
  }
  
  return osOK;
 8024402:	2500      	movs	r5, #0
 8024404:	e005      	b.n	8024412 <osSemaphoreWait+0x4c>
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
 8024406:	4621      	mov	r1, r4
 8024408:	4630      	mov	r0, r6
 802440a:	f000 ff55 	bl	80252b8 <xQueueSemaphoreTake>
 802440e:	2801      	cmp	r0, #1
 8024410:	d106      	bne.n	8024420 <osSemaphoreWait+0x5a>
}
 8024412:	4628      	mov	r0, r5
 8024414:	b002      	add	sp, #8
 8024416:	bd70      	pop	{r4, r5, r6, pc}
    return osErrorParameter;
 8024418:	2580      	movs	r5, #128	; 0x80
 802441a:	e7fa      	b.n	8024412 <osSemaphoreWait+0x4c>
      return osErrorOS;
 802441c:	25ff      	movs	r5, #255	; 0xff
 802441e:	e7f8      	b.n	8024412 <osSemaphoreWait+0x4c>
    return osErrorOS;
 8024420:	25ff      	movs	r5, #255	; 0xff
 8024422:	e7f6      	b.n	8024412 <osSemaphoreWait+0x4c>

08024424 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
 8024424:	b510      	push	{r4, lr}
 8024426:	b082      	sub	sp, #8
 8024428:	4604      	mov	r4, r0
  osStatus result = osOK;
  portBASE_TYPE taskWoken = pdFALSE;
 802442a:	2300      	movs	r3, #0
 802442c:	9301      	str	r3, [sp, #4]
  
  
  if (inHandlerMode()) {
 802442e:	f7ff fea1 	bl	8024174 <inHandlerMode>
 8024432:	b198      	cbz	r0, 802445c <osSemaphoreRelease+0x38>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
 8024434:	a901      	add	r1, sp, #4
 8024436:	4620      	mov	r0, r4
 8024438:	f000 fe36 	bl	80250a8 <xQueueGiveFromISR>
 802443c:	2801      	cmp	r0, #1
 802443e:	d11a      	bne.n	8024476 <osSemaphoreRelease+0x52>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 8024440:	9b01      	ldr	r3, [sp, #4]
 8024442:	b1d3      	cbz	r3, 802447a <osSemaphoreRelease+0x56>
 8024444:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024448:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802444c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024450:	f3bf 8f4f 	dsb	sy
 8024454:	f3bf 8f6f 	isb	sy
  osStatus result = osOK;
 8024458:	2000      	movs	r0, #0
 802445a:	e008      	b.n	802446e <osSemaphoreRelease+0x4a>
  }
  else {
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
 802445c:	2300      	movs	r3, #0
 802445e:	461a      	mov	r2, r3
 8024460:	4619      	mov	r1, r3
 8024462:	4620      	mov	r0, r4
 8024464:	f000 fcdf 	bl	8024e26 <xQueueGenericSend>
 8024468:	2801      	cmp	r0, #1
 802446a:	d002      	beq.n	8024472 <osSemaphoreRelease+0x4e>
      result = osErrorOS;
 802446c:	20ff      	movs	r0, #255	; 0xff
    }
  }
  
  return result;
}
 802446e:	b002      	add	sp, #8
 8024470:	bd10      	pop	{r4, pc}
  osStatus result = osOK;
 8024472:	2000      	movs	r0, #0
 8024474:	e7fb      	b.n	802446e <osSemaphoreRelease+0x4a>
      return osErrorOS;
 8024476:	20ff      	movs	r0, #255	; 0xff
 8024478:	e7f9      	b.n	802446e <osSemaphoreRelease+0x4a>
  osStatus result = osOK;
 802447a:	2000      	movs	r0, #0
 802447c:	e7f7      	b.n	802446e <osSemaphoreRelease+0x4a>

0802447e <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
 802447e:	b508      	push	{r3, lr}
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  }
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
 8024480:	2200      	movs	r2, #0
 8024482:	6841      	ldr	r1, [r0, #4]
 8024484:	6800      	ldr	r0, [r0, #0]
 8024486:	f000 fc8c 	bl	8024da2 <xQueueGenericCreate>
#endif
}
 802448a:	bd08      	pop	{r3, pc}

0802448c <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
 802448c:	b530      	push	{r4, r5, lr}
 802448e:	b085      	sub	sp, #20
 8024490:	4604      	mov	r4, r0
 8024492:	9101      	str	r1, [sp, #4]
  portBASE_TYPE taskWoken = pdFALSE;
 8024494:	2300      	movs	r3, #0
 8024496:	9303      	str	r3, [sp, #12]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  if (ticks == 0) {
 8024498:	4615      	mov	r5, r2
 802449a:	b902      	cbnz	r2, 802449e <osMessagePut+0x12>
    ticks = 1;
 802449c:	2501      	movs	r5, #1
  }
  
  if (inHandlerMode()) {
 802449e:	f7ff fe69 	bl	8024174 <inHandlerMode>
 80244a2:	b1a8      	cbz	r0, 80244d0 <osMessagePut+0x44>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
 80244a4:	2300      	movs	r3, #0
 80244a6:	aa03      	add	r2, sp, #12
 80244a8:	a901      	add	r1, sp, #4
 80244aa:	4620      	mov	r0, r4
 80244ac:	f000 fd96 	bl	8024fdc <xQueueGenericSendFromISR>
 80244b0:	2801      	cmp	r0, #1
 80244b2:	d118      	bne.n	80244e6 <osMessagePut+0x5a>
      return osErrorOS;
    }
    portEND_SWITCHING_ISR(taskWoken);
 80244b4:	9b03      	ldr	r3, [sp, #12]
 80244b6:	b1c3      	cbz	r3, 80244ea <osMessagePut+0x5e>
 80244b8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80244bc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80244c0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80244c4:	f3bf 8f4f 	dsb	sy
 80244c8:	f3bf 8f6f 	isb	sy
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
      return osErrorOS;
    }
  }
  
  return osOK;
 80244cc:	2000      	movs	r0, #0
 80244ce:	e008      	b.n	80244e2 <osMessagePut+0x56>
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
 80244d0:	2300      	movs	r3, #0
 80244d2:	462a      	mov	r2, r5
 80244d4:	a901      	add	r1, sp, #4
 80244d6:	4620      	mov	r0, r4
 80244d8:	f000 fca5 	bl	8024e26 <xQueueGenericSend>
 80244dc:	2801      	cmp	r0, #1
 80244de:	d106      	bne.n	80244ee <osMessagePut+0x62>
  return osOK;
 80244e0:	2000      	movs	r0, #0
}
 80244e2:	b005      	add	sp, #20
 80244e4:	bd30      	pop	{r4, r5, pc}
      return osErrorOS;
 80244e6:	20ff      	movs	r0, #255	; 0xff
 80244e8:	e7fb      	b.n	80244e2 <osMessagePut+0x56>
  return osOK;
 80244ea:	2000      	movs	r0, #0
 80244ec:	e7f9      	b.n	80244e2 <osMessagePut+0x56>
      return osErrorOS;
 80244ee:	20ff      	movs	r0, #255	; 0xff
 80244f0:	e7f7      	b.n	80244e2 <osMessagePut+0x56>

080244f2 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
 80244f2:	b570      	push	{r4, r5, r6, lr}
 80244f4:	b084      	sub	sp, #16
 80244f6:	4604      	mov	r4, r0
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
 80244f8:	9102      	str	r1, [sp, #8]
  event.value.v = 0;
 80244fa:	2300      	movs	r3, #0
 80244fc:	9301      	str	r3, [sp, #4]
  
  if (queue_id == NULL) {
 80244fe:	b1e1      	cbz	r1, 802453a <osMessageGet+0x48>
 8024500:	460d      	mov	r5, r1
 8024502:	4616      	mov	r6, r2
    event.status = osErrorParameter;
    return event;
  }
  
  taskWoken = pdFALSE;
 8024504:	2300      	movs	r3, #0
 8024506:	9303      	str	r3, [sp, #12]
    if (ticks == 0) {
      ticks = 1;
    }
  }
  
  if (inHandlerMode()) {
 8024508:	f7ff fe34 	bl	8024174 <inHandlerMode>
 802450c:	b300      	cbz	r0, 8024550 <osMessageGet+0x5e>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
 802450e:	aa03      	add	r2, sp, #12
 8024510:	a901      	add	r1, sp, #4
 8024512:	4628      	mov	r0, r5
 8024514:	f000 ffa3 	bl	802545e <xQueueReceiveFromISR>
 8024518:	2801      	cmp	r0, #1
 802451a:	d016      	beq.n	802454a <osMessageGet+0x58>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = osOK;
 802451c:	2300      	movs	r3, #0
 802451e:	9300      	str	r3, [sp, #0]
    }
    portEND_SWITCHING_ISR(taskWoken);
 8024520:	9b03      	ldr	r3, [sp, #12]
 8024522:	b1fb      	cbz	r3, 8024564 <osMessageGet+0x72>
 8024524:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024528:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802452c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024530:	f3bf 8f4f 	dsb	sy
 8024534:	f3bf 8f6f 	isb	sy
 8024538:	e014      	b.n	8024564 <osMessageGet+0x72>
    event.status = osErrorParameter;
 802453a:	2380      	movs	r3, #128	; 0x80
 802453c:	9300      	str	r3, [sp, #0]
    return event;
 802453e:	466b      	mov	r3, sp
 8024540:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8024544:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 8024548:	e011      	b.n	802456e <osMessageGet+0x7c>
      event.status = osEventMessage;
 802454a:	2310      	movs	r3, #16
 802454c:	9300      	str	r3, [sp, #0]
 802454e:	e7e7      	b.n	8024520 <osMessageGet+0x2e>
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
 8024550:	4632      	mov	r2, r6
 8024552:	a901      	add	r1, sp, #4
 8024554:	4628      	mov	r0, r5
 8024556:	f000 fe00 	bl	802515a <xQueueReceive>
 802455a:	2801      	cmp	r0, #1
 802455c:	d00a      	beq.n	8024574 <osMessageGet+0x82>
      /* We have mail */
      event.status = osEventMessage;
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
 802455e:	b106      	cbz	r6, 8024562 <osMessageGet+0x70>
 8024560:	2640      	movs	r6, #64	; 0x40
 8024562:	9600      	str	r6, [sp, #0]
    }
  }
  
  return event;
 8024564:	466b      	mov	r3, sp
 8024566:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 802456a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
 802456e:	4620      	mov	r0, r4
 8024570:	b004      	add	sp, #16
 8024572:	bd70      	pop	{r4, r5, r6, pc}
      event.status = osEventMessage;
 8024574:	2310      	movs	r3, #16
 8024576:	9300      	str	r3, [sp, #0]
 8024578:	e7f4      	b.n	8024564 <osMessageGet+0x72>
	...

0802457c <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 802457c:	4a13      	ldr	r2, [pc, #76]	; (80245cc <prvHeapInit+0x50>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 802457e:	f012 0f07 	tst.w	r2, #7
 8024582:	d01f      	beq.n	80245c4 <prvHeapInit+0x48>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8024584:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8024586:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 802458a:	f5c1 433b 	rsb	r3, r1, #47872	; 0xbb00
 802458e:	3320      	adds	r3, #32
 8024590:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8024592:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8024594:	480e      	ldr	r0, [pc, #56]	; (80245d0 <prvHeapInit+0x54>)
 8024596:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8024598:	2100      	movs	r1, #0
 802459a:	6041      	str	r1, [r0, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 802459c:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 802459e:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80245a0:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 80245a4:	480b      	ldr	r0, [pc, #44]	; (80245d4 <prvHeapInit+0x58>)
 80245a6:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
 80245a8:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 80245aa:	6019      	str	r1, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80245ac:	1a99      	subs	r1, r3, r2
 80245ae:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80245b0:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80245b2:	4b09      	ldr	r3, [pc, #36]	; (80245d8 <prvHeapInit+0x5c>)
 80245b4:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80245b6:	4b09      	ldr	r3, [pc, #36]	; (80245dc <prvHeapInit+0x60>)
 80245b8:	6019      	str	r1, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80245ba:	4b09      	ldr	r3, [pc, #36]	; (80245e0 <prvHeapInit+0x64>)
 80245bc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80245c0:	601a      	str	r2, [r3, #0]
}
 80245c2:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80245c4:	f64b 3320 	movw	r3, #47904	; 0xbb20
 80245c8:	e7e4      	b.n	8024594 <prvHeapInit+0x18>
 80245ca:	bf00      	nop
 80245cc:	200060b8 	.word	0x200060b8
 80245d0:	20011be4 	.word	0x20011be4
 80245d4:	200060b4 	.word	0x200060b4
 80245d8:	20011be0 	.word	0x20011be0
 80245dc:	20011bdc 	.word	0x20011bdc
 80245e0:	20011bd8 	.word	0x20011bd8

080245e4 <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80245e4:	4b16      	ldr	r3, [pc, #88]	; (8024640 <prvInsertBlockIntoFreeList+0x5c>)
 80245e6:	461a      	mov	r2, r3
 80245e8:	681b      	ldr	r3, [r3, #0]
 80245ea:	4283      	cmp	r3, r0
 80245ec:	d3fb      	bcc.n	80245e6 <prvInsertBlockIntoFreeList+0x2>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80245ee:	6851      	ldr	r1, [r2, #4]
 80245f0:	eb02 0c01 	add.w	ip, r2, r1
 80245f4:	4584      	cmp	ip, r0
 80245f6:	d009      	beq.n	802460c <prvInsertBlockIntoFreeList+0x28>
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80245f8:	6841      	ldr	r1, [r0, #4]
 80245fa:	eb00 0c01 	add.w	ip, r0, r1
 80245fe:	4563      	cmp	r3, ip
 8024600:	d009      	beq.n	8024616 <prvInsertBlockIntoFreeList+0x32>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8024602:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8024604:	4290      	cmp	r0, r2
 8024606:	d019      	beq.n	802463c <prvInsertBlockIntoFreeList+0x58>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8024608:	6010      	str	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
 802460a:	4770      	bx	lr
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 802460c:	6840      	ldr	r0, [r0, #4]
 802460e:	4401      	add	r1, r0
 8024610:	6051      	str	r1, [r2, #4]
		pxBlockToInsert = pxIterator;
 8024612:	4610      	mov	r0, r2
 8024614:	e7f0      	b.n	80245f8 <prvInsertBlockIntoFreeList+0x14>
{
 8024616:	b410      	push	{r4}
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8024618:	4c0a      	ldr	r4, [pc, #40]	; (8024644 <prvInsertBlockIntoFreeList+0x60>)
 802461a:	6824      	ldr	r4, [r4, #0]
 802461c:	42a3      	cmp	r3, r4
 802461e:	d00b      	beq.n	8024638 <prvInsertBlockIntoFreeList+0x54>
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8024620:	685b      	ldr	r3, [r3, #4]
 8024622:	4419      	add	r1, r3
 8024624:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8024626:	6813      	ldr	r3, [r2, #0]
 8024628:	681b      	ldr	r3, [r3, #0]
 802462a:	6003      	str	r3, [r0, #0]
	if( pxIterator != pxBlockToInsert )
 802462c:	4290      	cmp	r0, r2
 802462e:	d000      	beq.n	8024632 <prvInsertBlockIntoFreeList+0x4e>
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8024630:	6010      	str	r0, [r2, #0]
	}
}
 8024632:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024636:	4770      	bx	lr
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8024638:	6004      	str	r4, [r0, #0]
 802463a:	e7f7      	b.n	802462c <prvInsertBlockIntoFreeList+0x48>
 802463c:	4770      	bx	lr
 802463e:	bf00      	nop
 8024640:	20011be4 	.word	0x20011be4
 8024644:	200060b4 	.word	0x200060b4

08024648 <pvPortMalloc>:
{
 8024648:	b570      	push	{r4, r5, r6, lr}
 802464a:	4605      	mov	r5, r0
	vTaskSuspendAll();
 802464c:	f001 fa00 	bl	8025a50 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8024650:	4b34      	ldr	r3, [pc, #208]	; (8024724 <pvPortMalloc+0xdc>)
 8024652:	681b      	ldr	r3, [r3, #0]
 8024654:	b1a3      	cbz	r3, 8024680 <pvPortMalloc+0x38>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8024656:	4b34      	ldr	r3, [pc, #208]	; (8024728 <pvPortMalloc+0xe0>)
 8024658:	681b      	ldr	r3, [r3, #0]
 802465a:	421d      	tst	r5, r3
 802465c:	d14a      	bne.n	80246f4 <pvPortMalloc+0xac>
			if( xWantedSize > 0 )
 802465e:	b135      	cbz	r5, 802466e <pvPortMalloc+0x26>
				xWantedSize += xHeapStructSize;
 8024660:	3508      	adds	r5, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8024662:	f015 0f07 	tst.w	r5, #7
 8024666:	d002      	beq.n	802466e <pvPortMalloc+0x26>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8024668:	f025 0507 	bic.w	r5, r5, #7
 802466c:	3508      	adds	r5, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 802466e:	2d00      	cmp	r5, #0
 8024670:	d042      	beq.n	80246f8 <pvPortMalloc+0xb0>
 8024672:	4b2e      	ldr	r3, [pc, #184]	; (802472c <pvPortMalloc+0xe4>)
 8024674:	681b      	ldr	r3, [r3, #0]
 8024676:	42ab      	cmp	r3, r5
 8024678:	d34d      	bcc.n	8024716 <pvPortMalloc+0xce>
				pxBlock = xStart.pxNextFreeBlock;
 802467a:	4a2d      	ldr	r2, [pc, #180]	; (8024730 <pvPortMalloc+0xe8>)
 802467c:	6814      	ldr	r4, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 802467e:	e004      	b.n	802468a <pvPortMalloc+0x42>
			prvHeapInit();
 8024680:	f7ff ff7c 	bl	802457c <prvHeapInit>
 8024684:	e7e7      	b.n	8024656 <pvPortMalloc+0xe>
					pxPreviousBlock = pxBlock;
 8024686:	4622      	mov	r2, r4
					pxBlock = pxBlock->pxNextFreeBlock;
 8024688:	461c      	mov	r4, r3
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 802468a:	6863      	ldr	r3, [r4, #4]
 802468c:	42ab      	cmp	r3, r5
 802468e:	d202      	bcs.n	8024696 <pvPortMalloc+0x4e>
 8024690:	6823      	ldr	r3, [r4, #0]
 8024692:	2b00      	cmp	r3, #0
 8024694:	d1f7      	bne.n	8024686 <pvPortMalloc+0x3e>
				if( pxBlock != pxEnd )
 8024696:	4b23      	ldr	r3, [pc, #140]	; (8024724 <pvPortMalloc+0xdc>)
 8024698:	681b      	ldr	r3, [r3, #0]
 802469a:	42a3      	cmp	r3, r4
 802469c:	d03d      	beq.n	802471a <pvPortMalloc+0xd2>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 802469e:	6816      	ldr	r6, [r2, #0]
 80246a0:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80246a2:	6823      	ldr	r3, [r4, #0]
 80246a4:	6013      	str	r3, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80246a6:	6863      	ldr	r3, [r4, #4]
 80246a8:	1b5b      	subs	r3, r3, r5
 80246aa:	2b10      	cmp	r3, #16
 80246ac:	d910      	bls.n	80246d0 <pvPortMalloc+0x88>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80246ae:	1960      	adds	r0, r4, r5
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80246b0:	f010 0f07 	tst.w	r0, #7
 80246b4:	d008      	beq.n	80246c8 <pvPortMalloc+0x80>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80246b6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80246ba:	f383 8811 	msr	BASEPRI, r3
 80246be:	f3bf 8f6f 	isb	sy
 80246c2:	f3bf 8f4f 	dsb	sy
 80246c6:	e7fe      	b.n	80246c6 <pvPortMalloc+0x7e>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80246c8:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80246ca:	6065      	str	r5, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80246cc:	f7ff ff8a 	bl	80245e4 <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80246d0:	6862      	ldr	r2, [r4, #4]
 80246d2:	4916      	ldr	r1, [pc, #88]	; (802472c <pvPortMalloc+0xe4>)
 80246d4:	680b      	ldr	r3, [r1, #0]
 80246d6:	1a9b      	subs	r3, r3, r2
 80246d8:	600b      	str	r3, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80246da:	4916      	ldr	r1, [pc, #88]	; (8024734 <pvPortMalloc+0xec>)
 80246dc:	6809      	ldr	r1, [r1, #0]
 80246de:	428b      	cmp	r3, r1
 80246e0:	d201      	bcs.n	80246e6 <pvPortMalloc+0x9e>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80246e2:	4914      	ldr	r1, [pc, #80]	; (8024734 <pvPortMalloc+0xec>)
 80246e4:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80246e6:	4b10      	ldr	r3, [pc, #64]	; (8024728 <pvPortMalloc+0xe0>)
 80246e8:	681b      	ldr	r3, [r3, #0]
 80246ea:	4313      	orrs	r3, r2
 80246ec:	6063      	str	r3, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80246ee:	2300      	movs	r3, #0
 80246f0:	6023      	str	r3, [r4, #0]
 80246f2:	e002      	b.n	80246fa <pvPortMalloc+0xb2>
void *pvReturn = NULL;
 80246f4:	2600      	movs	r6, #0
 80246f6:	e000      	b.n	80246fa <pvPortMalloc+0xb2>
 80246f8:	2600      	movs	r6, #0
	( void ) xTaskResumeAll();
 80246fa:	f001 fa4b 	bl	8025b94 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 80246fe:	f016 0f07 	tst.w	r6, #7
 8024702:	d00c      	beq.n	802471e <pvPortMalloc+0xd6>
 8024704:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024708:	f383 8811 	msr	BASEPRI, r3
 802470c:	f3bf 8f6f 	isb	sy
 8024710:	f3bf 8f4f 	dsb	sy
 8024714:	e7fe      	b.n	8024714 <pvPortMalloc+0xcc>
void *pvReturn = NULL;
 8024716:	2600      	movs	r6, #0
 8024718:	e7ef      	b.n	80246fa <pvPortMalloc+0xb2>
 802471a:	2600      	movs	r6, #0
 802471c:	e7ed      	b.n	80246fa <pvPortMalloc+0xb2>
}
 802471e:	4630      	mov	r0, r6
 8024720:	bd70      	pop	{r4, r5, r6, pc}
 8024722:	bf00      	nop
 8024724:	200060b4 	.word	0x200060b4
 8024728:	20011bd8 	.word	0x20011bd8
 802472c:	20011bdc 	.word	0x20011bdc
 8024730:	20011be4 	.word	0x20011be4
 8024734:	20011be0 	.word	0x20011be0

08024738 <vPortFree>:
	if( pv != NULL )
 8024738:	b380      	cbz	r0, 802479c <vPortFree+0x64>
{
 802473a:	b538      	push	{r3, r4, r5, lr}
 802473c:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 802473e:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8024742:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8024746:	4a16      	ldr	r2, [pc, #88]	; (80247a0 <vPortFree+0x68>)
 8024748:	6812      	ldr	r2, [r2, #0]
 802474a:	4213      	tst	r3, r2
 802474c:	d108      	bne.n	8024760 <vPortFree+0x28>
 802474e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024752:	f383 8811 	msr	BASEPRI, r3
 8024756:	f3bf 8f6f 	isb	sy
 802475a:	f3bf 8f4f 	dsb	sy
 802475e:	e7fe      	b.n	802475e <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8024760:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8024764:	b141      	cbz	r1, 8024778 <vPortFree+0x40>
 8024766:	f04f 0350 	mov.w	r3, #80	; 0x50
 802476a:	f383 8811 	msr	BASEPRI, r3
 802476e:	f3bf 8f6f 	isb	sy
 8024772:	f3bf 8f4f 	dsb	sy
 8024776:	e7fe      	b.n	8024776 <vPortFree+0x3e>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8024778:	ea23 0302 	bic.w	r3, r3, r2
 802477c:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8024780:	f001 f966 	bl	8025a50 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8024784:	f854 1c04 	ldr.w	r1, [r4, #-4]
 8024788:	4a06      	ldr	r2, [pc, #24]	; (80247a4 <vPortFree+0x6c>)
 802478a:	6813      	ldr	r3, [r2, #0]
 802478c:	440b      	add	r3, r1
 802478e:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8024790:	4628      	mov	r0, r5
 8024792:	f7ff ff27 	bl	80245e4 <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 8024796:	f001 f9fd 	bl	8025b94 <xTaskResumeAll>
}
 802479a:	bd38      	pop	{r3, r4, r5, pc}
 802479c:	4770      	bx	lr
 802479e:	bf00      	nop
 80247a0:	20011bd8 	.word	0x20011bd8
 80247a4:	20011bdc 	.word	0x20011bdc

080247a8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80247a8:	f100 0308 	add.w	r3, r0, #8
 80247ac:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80247ae:	f04f 32ff 	mov.w	r2, #4294967295
 80247b2:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80247b4:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80247b6:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80247b8:	2300      	movs	r3, #0
 80247ba:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 80247bc:	4770      	bx	lr

080247be <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 80247be:	2300      	movs	r3, #0
 80247c0:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 80247c2:	4770      	bx	lr

080247c4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80247c4:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80247c6:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80247c8:	689a      	ldr	r2, [r3, #8]
 80247ca:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 80247cc:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 80247ce:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 80247d0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80247d2:	6803      	ldr	r3, [r0, #0]
 80247d4:	3301      	adds	r3, #1
 80247d6:	6003      	str	r3, [r0, #0]
}
 80247d8:	4770      	bx	lr

080247da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 80247da:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 80247dc:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 80247de:	f1b5 3fff 	cmp.w	r5, #4294967295
 80247e2:	d011      	beq.n	8024808 <vListInsert+0x2e>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 80247e4:	f100 0308 	add.w	r3, r0, #8
 80247e8:	461c      	mov	r4, r3
 80247ea:	685b      	ldr	r3, [r3, #4]
 80247ec:	681a      	ldr	r2, [r3, #0]
 80247ee:	42aa      	cmp	r2, r5
 80247f0:	d9fa      	bls.n	80247e8 <vListInsert+0xe>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 80247f2:	6863      	ldr	r3, [r4, #4]
 80247f4:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 80247f6:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80247f8:	608c      	str	r4, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 80247fa:	6061      	str	r1, [r4, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 80247fc:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 80247fe:	6803      	ldr	r3, [r0, #0]
 8024800:	3301      	adds	r3, #1
 8024802:	6003      	str	r3, [r0, #0]
}
 8024804:	bc30      	pop	{r4, r5}
 8024806:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8024808:	6904      	ldr	r4, [r0, #16]
 802480a:	e7f2      	b.n	80247f2 <vListInsert+0x18>

0802480c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 802480c:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 802480e:	6841      	ldr	r1, [r0, #4]
 8024810:	6882      	ldr	r2, [r0, #8]
 8024812:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8024814:	6841      	ldr	r1, [r0, #4]
 8024816:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8024818:	685a      	ldr	r2, [r3, #4]
 802481a:	4282      	cmp	r2, r0
 802481c:	d006      	beq.n	802482c <uxListRemove+0x20>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 802481e:	2200      	movs	r2, #0
 8024820:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8024822:	681a      	ldr	r2, [r3, #0]
 8024824:	3a01      	subs	r2, #1
 8024826:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8024828:	6818      	ldr	r0, [r3, #0]
}
 802482a:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 802482c:	6882      	ldr	r2, [r0, #8]
 802482e:	605a      	str	r2, [r3, #4]
 8024830:	e7f5      	b.n	802481e <uxListRemove+0x12>
	...

08024834 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8024834:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8024836:	2300      	movs	r3, #0
 8024838:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 802483a:	4b0d      	ldr	r3, [pc, #52]	; (8024870 <prvTaskExitError+0x3c>)
 802483c:	681b      	ldr	r3, [r3, #0]
 802483e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024842:	d008      	beq.n	8024856 <prvTaskExitError+0x22>
 8024844:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024848:	f383 8811 	msr	BASEPRI, r3
 802484c:	f3bf 8f6f 	isb	sy
 8024850:	f3bf 8f4f 	dsb	sy
 8024854:	e7fe      	b.n	8024854 <prvTaskExitError+0x20>
 8024856:	f04f 0350 	mov.w	r3, #80	; 0x50
 802485a:	f383 8811 	msr	BASEPRI, r3
 802485e:	f3bf 8f6f 	isb	sy
 8024862:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8024866:	9b01      	ldr	r3, [sp, #4]
 8024868:	2b00      	cmp	r3, #0
 802486a:	d0fc      	beq.n	8024866 <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 802486c:	b002      	add	sp, #8
 802486e:	4770      	bx	lr
 8024870:	20000250 	.word	0x20000250

08024874 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8024874:	4808      	ldr	r0, [pc, #32]	; (8024898 <prvPortStartFirstTask+0x24>)
 8024876:	6800      	ldr	r0, [r0, #0]
 8024878:	6800      	ldr	r0, [r0, #0]
 802487a:	f380 8808 	msr	MSP, r0
 802487e:	f04f 0000 	mov.w	r0, #0
 8024882:	f380 8814 	msr	CONTROL, r0
 8024886:	b662      	cpsie	i
 8024888:	b661      	cpsie	f
 802488a:	f3bf 8f4f 	dsb	sy
 802488e:	f3bf 8f6f 	isb	sy
 8024892:	df00      	svc	0
 8024894:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8024896:	0000      	.short	0x0000
 8024898:	e000ed08 	.word	0xe000ed08

0802489c <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 802489c:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80248ac <vPortEnableVFP+0x10>
 80248a0:	6801      	ldr	r1, [r0, #0]
 80248a2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80248a6:	6001      	str	r1, [r0, #0]
 80248a8:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 80248aa:	0000      	.short	0x0000
 80248ac:	e000ed88 	.word	0xe000ed88

080248b0 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80248b0:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80248b4:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80248b8:	f021 0101 	bic.w	r1, r1, #1
 80248bc:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80248c0:	4b05      	ldr	r3, [pc, #20]	; (80248d8 <pxPortInitialiseStack+0x28>)
 80248c2:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80248c6:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 80248ca:	f06f 0302 	mvn.w	r3, #2
 80248ce:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80248d2:	3844      	subs	r0, #68	; 0x44
 80248d4:	4770      	bx	lr
 80248d6:	bf00      	nop
 80248d8:	08024835 	.word	0x08024835
 80248dc:	00000000 	.word	0x00000000

080248e0 <SVC_Handler>:
	__asm volatile (
 80248e0:	4b07      	ldr	r3, [pc, #28]	; (8024900 <pxCurrentTCBConst2>)
 80248e2:	6819      	ldr	r1, [r3, #0]
 80248e4:	6808      	ldr	r0, [r1, #0]
 80248e6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80248ea:	f380 8809 	msr	PSP, r0
 80248ee:	f3bf 8f6f 	isb	sy
 80248f2:	f04f 0000 	mov.w	r0, #0
 80248f6:	f380 8811 	msr	BASEPRI, r0
 80248fa:	4770      	bx	lr
 80248fc:	f3af 8000 	nop.w

08024900 <pxCurrentTCBConst2>:
 8024900:	20011c34 	.word	0x20011c34

08024904 <vPortEnterCritical>:
 8024904:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024908:	f383 8811 	msr	BASEPRI, r3
 802490c:	f3bf 8f6f 	isb	sy
 8024910:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8024914:	4a0b      	ldr	r2, [pc, #44]	; (8024944 <vPortEnterCritical+0x40>)
 8024916:	6813      	ldr	r3, [r2, #0]
 8024918:	3301      	adds	r3, #1
 802491a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 802491c:	2b01      	cmp	r3, #1
 802491e:	d000      	beq.n	8024922 <vPortEnterCritical+0x1e>
}
 8024920:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8024922:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024926:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
 802492a:	f013 0fff 	tst.w	r3, #255	; 0xff
 802492e:	d0f7      	beq.n	8024920 <vPortEnterCritical+0x1c>
 8024930:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024934:	f383 8811 	msr	BASEPRI, r3
 8024938:	f3bf 8f6f 	isb	sy
 802493c:	f3bf 8f4f 	dsb	sy
 8024940:	e7fe      	b.n	8024940 <vPortEnterCritical+0x3c>
 8024942:	bf00      	nop
 8024944:	20000250 	.word	0x20000250

08024948 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8024948:	4b09      	ldr	r3, [pc, #36]	; (8024970 <vPortExitCritical+0x28>)
 802494a:	681b      	ldr	r3, [r3, #0]
 802494c:	b943      	cbnz	r3, 8024960 <vPortExitCritical+0x18>
 802494e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024952:	f383 8811 	msr	BASEPRI, r3
 8024956:	f3bf 8f6f 	isb	sy
 802495a:	f3bf 8f4f 	dsb	sy
 802495e:	e7fe      	b.n	802495e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8024960:	3b01      	subs	r3, #1
 8024962:	4a03      	ldr	r2, [pc, #12]	; (8024970 <vPortExitCritical+0x28>)
 8024964:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8024966:	b90b      	cbnz	r3, 802496c <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8024968:	f383 8811 	msr	BASEPRI, r3
}
 802496c:	4770      	bx	lr
 802496e:	bf00      	nop
 8024970:	20000250 	.word	0x20000250
	...

08024980 <PendSV_Handler>:
	__asm volatile
 8024980:	f3ef 8009 	mrs	r0, PSP
 8024984:	f3bf 8f6f 	isb	sy
 8024988:	4b15      	ldr	r3, [pc, #84]	; (80249e0 <pxCurrentTCBConst>)
 802498a:	681a      	ldr	r2, [r3, #0]
 802498c:	f01e 0f10 	tst.w	lr, #16
 8024990:	bf08      	it	eq
 8024992:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8024996:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802499a:	6010      	str	r0, [r2, #0]
 802499c:	e92d 0009 	stmdb	sp!, {r0, r3}
 80249a0:	f04f 0050 	mov.w	r0, #80	; 0x50
 80249a4:	f380 8811 	msr	BASEPRI, r0
 80249a8:	f3bf 8f4f 	dsb	sy
 80249ac:	f3bf 8f6f 	isb	sy
 80249b0:	f001 f992 	bl	8025cd8 <vTaskSwitchContext>
 80249b4:	f04f 0000 	mov.w	r0, #0
 80249b8:	f380 8811 	msr	BASEPRI, r0
 80249bc:	bc09      	pop	{r0, r3}
 80249be:	6819      	ldr	r1, [r3, #0]
 80249c0:	6808      	ldr	r0, [r1, #0]
 80249c2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80249c6:	f01e 0f10 	tst.w	lr, #16
 80249ca:	bf08      	it	eq
 80249cc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80249d0:	f380 8809 	msr	PSP, r0
 80249d4:	f3bf 8f6f 	isb	sy
 80249d8:	4770      	bx	lr
 80249da:	bf00      	nop
 80249dc:	f3af 8000 	nop.w

080249e0 <pxCurrentTCBConst>:
 80249e0:	20011c34 	.word	0x20011c34

080249e4 <xPortSysTickHandler>:
{
 80249e4:	b508      	push	{r3, lr}
	__asm volatile
 80249e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80249ea:	f383 8811 	msr	BASEPRI, r3
 80249ee:	f3bf 8f6f 	isb	sy
 80249f2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80249f6:	f001 f841 	bl	8025a7c <xTaskIncrementTick>
 80249fa:	b128      	cbz	r0, 8024a08 <xPortSysTickHandler+0x24>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80249fc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024a00:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024a04:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
	__asm volatile
 8024a08:	2300      	movs	r3, #0
 8024a0a:	f383 8811 	msr	BASEPRI, r3
}
 8024a0e:	bd08      	pop	{r3, pc}

08024a10 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8024a10:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8024a14:	2300      	movs	r3, #0
 8024a16:	6113      	str	r3, [r2, #16]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8024a18:	6193      	str	r3, [r2, #24]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8024a1a:	4b05      	ldr	r3, [pc, #20]	; (8024a30 <vPortSetupTimerInterrupt+0x20>)
 8024a1c:	681b      	ldr	r3, [r3, #0]
 8024a1e:	4905      	ldr	r1, [pc, #20]	; (8024a34 <vPortSetupTimerInterrupt+0x24>)
 8024a20:	fba1 1303 	umull	r1, r3, r1, r3
 8024a24:	099b      	lsrs	r3, r3, #6
 8024a26:	3b01      	subs	r3, #1
 8024a28:	6153      	str	r3, [r2, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8024a2a:	2307      	movs	r3, #7
 8024a2c:	6113      	str	r3, [r2, #16]
}
 8024a2e:	4770      	bx	lr
 8024a30:	20000034 	.word	0x20000034
 8024a34:	10624dd3 	.word	0x10624dd3

08024a38 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8024a38:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024a3c:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 8024a40:	4b3d      	ldr	r3, [pc, #244]	; (8024b38 <xPortStartScheduler+0x100>)
 8024a42:	429a      	cmp	r2, r3
 8024a44:	d01c      	beq.n	8024a80 <xPortStartScheduler+0x48>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8024a46:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024a4a:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 8024a4e:	4b3b      	ldr	r3, [pc, #236]	; (8024b3c <xPortStartScheduler+0x104>)
 8024a50:	429a      	cmp	r2, r3
 8024a52:	d01e      	beq.n	8024a92 <xPortStartScheduler+0x5a>
{
 8024a54:	b530      	push	{r4, r5, lr}
 8024a56:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8024a58:	4b39      	ldr	r3, [pc, #228]	; (8024b40 <xPortStartScheduler+0x108>)
 8024a5a:	781a      	ldrb	r2, [r3, #0]
 8024a5c:	b2d2      	uxtb	r2, r2
 8024a5e:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8024a60:	22ff      	movs	r2, #255	; 0xff
 8024a62:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8024a64:	781b      	ldrb	r3, [r3, #0]
 8024a66:	b2db      	uxtb	r3, r3
 8024a68:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8024a6c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8024a70:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8024a74:	4a33      	ldr	r2, [pc, #204]	; (8024b44 <xPortStartScheduler+0x10c>)
 8024a76:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8024a78:	4b33      	ldr	r3, [pc, #204]	; (8024b48 <xPortStartScheduler+0x110>)
 8024a7a:	2207      	movs	r2, #7
 8024a7c:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8024a7e:	e01b      	b.n	8024ab8 <xPortStartScheduler+0x80>
	__asm volatile
 8024a80:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024a84:	f383 8811 	msr	BASEPRI, r3
 8024a88:	f3bf 8f6f 	isb	sy
 8024a8c:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8024a90:	e7fe      	b.n	8024a90 <xPortStartScheduler+0x58>
 8024a92:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024a96:	f383 8811 	msr	BASEPRI, r3
 8024a9a:	f3bf 8f6f 	isb	sy
 8024a9e:	f3bf 8f4f 	dsb	sy
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8024aa2:	e7fe      	b.n	8024aa2 <xPortStartScheduler+0x6a>
			ulMaxPRIGROUPValue--;
 8024aa4:	4a28      	ldr	r2, [pc, #160]	; (8024b48 <xPortStartScheduler+0x110>)
 8024aa6:	6813      	ldr	r3, [r2, #0]
 8024aa8:	3b01      	subs	r3, #1
 8024aaa:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8024aac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8024ab0:	005b      	lsls	r3, r3, #1
 8024ab2:	b2db      	uxtb	r3, r3
 8024ab4:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8024ab8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8024abc:	f013 0f80 	tst.w	r3, #128	; 0x80
 8024ac0:	d1f0      	bne.n	8024aa4 <xPortStartScheduler+0x6c>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8024ac2:	4b21      	ldr	r3, [pc, #132]	; (8024b48 <xPortStartScheduler+0x110>)
 8024ac4:	681b      	ldr	r3, [r3, #0]
 8024ac6:	2b03      	cmp	r3, #3
 8024ac8:	d008      	beq.n	8024adc <xPortStartScheduler+0xa4>
 8024aca:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024ace:	f383 8811 	msr	BASEPRI, r3
 8024ad2:	f3bf 8f6f 	isb	sy
 8024ad6:	f3bf 8f4f 	dsb	sy
 8024ada:	e7fe      	b.n	8024ada <xPortStartScheduler+0xa2>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8024adc:	021b      	lsls	r3, r3, #8
 8024ade:	4a1a      	ldr	r2, [pc, #104]	; (8024b48 <xPortStartScheduler+0x110>)
 8024ae0:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8024ae2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8024ae6:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8024ae8:	9b01      	ldr	r3, [sp, #4]
 8024aea:	b2db      	uxtb	r3, r3
 8024aec:	4a14      	ldr	r2, [pc, #80]	; (8024b40 <xPortStartScheduler+0x108>)
 8024aee:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8024af0:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
 8024af4:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 8024af8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8024afc:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8024b00:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 8024b04:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 8024b08:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
	vPortSetupTimerInterrupt();
 8024b0c:	f7ff ff80 	bl	8024a10 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8024b10:	2500      	movs	r5, #0
 8024b12:	4b0e      	ldr	r3, [pc, #56]	; (8024b4c <xPortStartScheduler+0x114>)
 8024b14:	601d      	str	r5, [r3, #0]
	vPortEnableVFP();
 8024b16:	f7ff fec1 	bl	802489c <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8024b1a:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
 8024b1e:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8024b22:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
	prvPortStartFirstTask();
 8024b26:	f7ff fea5 	bl	8024874 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8024b2a:	f001 f8d5 	bl	8025cd8 <vTaskSwitchContext>
	prvTaskExitError();
 8024b2e:	f7ff fe81 	bl	8024834 <prvTaskExitError>
}
 8024b32:	4628      	mov	r0, r5
 8024b34:	b003      	add	sp, #12
 8024b36:	bd30      	pop	{r4, r5, pc}
 8024b38:	410fc271 	.word	0x410fc271
 8024b3c:	410fc270 	.word	0x410fc270
 8024b40:	e000e400 	.word	0xe000e400
 8024b44:	20011bec 	.word	0x20011bec
 8024b48:	20011bf0 	.word	0x20011bf0
 8024b4c:	20000250 	.word	0x20000250

08024b50 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8024b50:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8024b54:	2b0f      	cmp	r3, #15
 8024b56:	d90f      	bls.n	8024b78 <vPortValidateInterruptPriority+0x28>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8024b58:	4a11      	ldr	r2, [pc, #68]	; (8024ba0 <vPortValidateInterruptPriority+0x50>)
 8024b5a:	5c9b      	ldrb	r3, [r3, r2]
 8024b5c:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8024b5e:	4a11      	ldr	r2, [pc, #68]	; (8024ba4 <vPortValidateInterruptPriority+0x54>)
 8024b60:	7812      	ldrb	r2, [r2, #0]
 8024b62:	429a      	cmp	r2, r3
 8024b64:	d908      	bls.n	8024b78 <vPortValidateInterruptPriority+0x28>
 8024b66:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024b6a:	f383 8811 	msr	BASEPRI, r3
 8024b6e:	f3bf 8f6f 	isb	sy
 8024b72:	f3bf 8f4f 	dsb	sy
 8024b76:	e7fe      	b.n	8024b76 <vPortValidateInterruptPriority+0x26>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8024b78:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024b7c:	f8d3 3d0c 	ldr.w	r3, [r3, #3340]	; 0xd0c
 8024b80:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8024b84:	4a08      	ldr	r2, [pc, #32]	; (8024ba8 <vPortValidateInterruptPriority+0x58>)
 8024b86:	6812      	ldr	r2, [r2, #0]
 8024b88:	4293      	cmp	r3, r2
 8024b8a:	d908      	bls.n	8024b9e <vPortValidateInterruptPriority+0x4e>
 8024b8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024b90:	f383 8811 	msr	BASEPRI, r3
 8024b94:	f3bf 8f6f 	isb	sy
 8024b98:	f3bf 8f4f 	dsb	sy
 8024b9c:	e7fe      	b.n	8024b9c <vPortValidateInterruptPriority+0x4c>
	}
 8024b9e:	4770      	bx	lr
 8024ba0:	e000e3f0 	.word	0xe000e3f0
 8024ba4:	20011bec 	.word	0x20011bec
 8024ba8:	20011bf0 	.word	0x20011bf0

08024bac <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 8024bac:	4603      	mov	r3, r0
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 8024bae:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8024bb0:	b118      	cbz	r0, 8024bba <prvGetDisinheritPriorityAfterTimeout+0xe>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 8024bb2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8024bb4:	6818      	ldr	r0, [r3, #0]
 8024bb6:	f1c0 0007 	rsb	r0, r0, #7
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
		}

		return uxHighestPriorityOfWaitingTasks;
	}
 8024bba:	4770      	bx	lr

08024bbc <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 8024bbc:	b510      	push	{r4, lr}
 8024bbe:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8024bc0:	f7ff fea0 	bl	8024904 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8024bc4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8024bc6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024bc8:	429a      	cmp	r2, r3
 8024bca:	d004      	beq.n	8024bd6 <prvIsQueueFull+0x1a>
		{
			xReturn = pdTRUE;
		}
		else
		{
			xReturn = pdFALSE;
 8024bcc:	2400      	movs	r4, #0
		}
	}
	taskEXIT_CRITICAL();
 8024bce:	f7ff febb 	bl	8024948 <vPortExitCritical>

	return xReturn;
}
 8024bd2:	4620      	mov	r0, r4
 8024bd4:	bd10      	pop	{r4, pc}
			xReturn = pdTRUE;
 8024bd6:	2401      	movs	r4, #1
 8024bd8:	e7f9      	b.n	8024bce <prvIsQueueFull+0x12>

08024bda <prvIsQueueEmpty>:
{
 8024bda:	b510      	push	{r4, lr}
 8024bdc:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8024bde:	f7ff fe91 	bl	8024904 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8024be2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024be4:	b923      	cbnz	r3, 8024bf0 <prvIsQueueEmpty+0x16>
			xReturn = pdTRUE;
 8024be6:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 8024be8:	f7ff feae 	bl	8024948 <vPortExitCritical>
}
 8024bec:	4620      	mov	r0, r4
 8024bee:	bd10      	pop	{r4, pc}
			xReturn = pdFALSE;
 8024bf0:	2400      	movs	r4, #0
 8024bf2:	e7f9      	b.n	8024be8 <prvIsQueueEmpty+0xe>

08024bf4 <prvCopyDataToQueue>:
{
 8024bf4:	b570      	push	{r4, r5, r6, lr}
 8024bf6:	4604      	mov	r4, r0
 8024bf8:	4615      	mov	r5, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8024bfa:	6b86      	ldr	r6, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8024bfc:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8024bfe:	b95a      	cbnz	r2, 8024c18 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8024c00:	6803      	ldr	r3, [r0, #0]
 8024c02:	b11b      	cbz	r3, 8024c0c <prvCopyDataToQueue+0x18>
BaseType_t xReturn = pdFALSE;
 8024c04:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8024c06:	3601      	adds	r6, #1
 8024c08:	63a6      	str	r6, [r4, #56]	; 0x38
}
 8024c0a:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 8024c0c:	6880      	ldr	r0, [r0, #8]
 8024c0e:	f001 f9e9 	bl	8025fe4 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 8024c12:	2300      	movs	r3, #0
 8024c14:	60a3      	str	r3, [r4, #8]
 8024c16:	e7f6      	b.n	8024c06 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
 8024c18:	b96d      	cbnz	r5, 8024c36 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8024c1a:	6840      	ldr	r0, [r0, #4]
 8024c1c:	f001 ff64 	bl	8026ae8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8024c20:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8024c22:	6863      	ldr	r3, [r4, #4]
 8024c24:	4413      	add	r3, r2
 8024c26:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8024c28:	68a2      	ldr	r2, [r4, #8]
 8024c2a:	4293      	cmp	r3, r2
 8024c2c:	d319      	bcc.n	8024c62 <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8024c2e:	6823      	ldr	r3, [r4, #0]
 8024c30:	6063      	str	r3, [r4, #4]
BaseType_t xReturn = pdFALSE;
 8024c32:	4628      	mov	r0, r5
 8024c34:	e7e7      	b.n	8024c06 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 8024c36:	68c0      	ldr	r0, [r0, #12]
 8024c38:	f001 ff56 	bl	8026ae8 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8024c3c:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8024c3e:	4251      	negs	r1, r2
 8024c40:	68e3      	ldr	r3, [r4, #12]
 8024c42:	1a9b      	subs	r3, r3, r2
 8024c44:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8024c46:	6822      	ldr	r2, [r4, #0]
 8024c48:	4293      	cmp	r3, r2
 8024c4a:	d202      	bcs.n	8024c52 <prvCopyDataToQueue+0x5e>
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8024c4c:	68a3      	ldr	r3, [r4, #8]
 8024c4e:	440b      	add	r3, r1
 8024c50:	60e3      	str	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8024c52:	2d02      	cmp	r5, #2
 8024c54:	d001      	beq.n	8024c5a <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
 8024c56:	2000      	movs	r0, #0
 8024c58:	e7d5      	b.n	8024c06 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8024c5a:	b126      	cbz	r6, 8024c66 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
 8024c5c:	3e01      	subs	r6, #1
BaseType_t xReturn = pdFALSE;
 8024c5e:	2000      	movs	r0, #0
 8024c60:	e7d1      	b.n	8024c06 <prvCopyDataToQueue+0x12>
 8024c62:	4628      	mov	r0, r5
 8024c64:	e7cf      	b.n	8024c06 <prvCopyDataToQueue+0x12>
 8024c66:	2000      	movs	r0, #0
 8024c68:	e7cd      	b.n	8024c06 <prvCopyDataToQueue+0x12>

08024c6a <prvCopyDataFromQueue>:
{
 8024c6a:	4603      	mov	r3, r0
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8024c6c:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8024c6e:	b16a      	cbz	r2, 8024c8c <prvCopyDataFromQueue+0x22>
{
 8024c70:	b510      	push	{r4, lr}
 8024c72:	4608      	mov	r0, r1
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 8024c74:	68d9      	ldr	r1, [r3, #12]
 8024c76:	4411      	add	r1, r2
 8024c78:	60d9      	str	r1, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8024c7a:	689c      	ldr	r4, [r3, #8]
 8024c7c:	42a1      	cmp	r1, r4
 8024c7e:	d301      	bcc.n	8024c84 <prvCopyDataFromQueue+0x1a>
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 8024c80:	6819      	ldr	r1, [r3, #0]
 8024c82:	60d9      	str	r1, [r3, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 8024c84:	68d9      	ldr	r1, [r3, #12]
 8024c86:	f001 ff2f 	bl	8026ae8 <memcpy>
}
 8024c8a:	bd10      	pop	{r4, pc}
 8024c8c:	4770      	bx	lr

08024c8e <prvUnlockQueue>:
{
 8024c8e:	b538      	push	{r3, r4, r5, lr}
 8024c90:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
 8024c92:	f7ff fe37 	bl	8024904 <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
 8024c96:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8024c9a:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8024c9c:	e001      	b.n	8024ca2 <prvUnlockQueue+0x14>
			--cTxLock;
 8024c9e:	3c01      	subs	r4, #1
 8024ca0:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8024ca2:	2c00      	cmp	r4, #0
 8024ca4:	dd0a      	ble.n	8024cbc <prvUnlockQueue+0x2e>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8024ca6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8024ca8:	b143      	cbz	r3, 8024cbc <prvUnlockQueue+0x2e>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8024caa:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8024cae:	f001 f893 	bl	8025dd8 <xTaskRemoveFromEventList>
 8024cb2:	2800      	cmp	r0, #0
 8024cb4:	d0f3      	beq.n	8024c9e <prvUnlockQueue+0x10>
						vTaskMissedYield();
 8024cb6:	f001 f923 	bl	8025f00 <vTaskMissedYield>
 8024cba:	e7f0      	b.n	8024c9e <prvUnlockQueue+0x10>
		pxQueue->cTxLock = queueUNLOCKED;
 8024cbc:	23ff      	movs	r3, #255	; 0xff
 8024cbe:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
 8024cc2:	f7ff fe41 	bl	8024948 <vPortExitCritical>
	taskENTER_CRITICAL();
 8024cc6:	f7ff fe1d 	bl	8024904 <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
 8024cca:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 8024cce:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8024cd0:	e001      	b.n	8024cd6 <prvUnlockQueue+0x48>
				--cRxLock;
 8024cd2:	3c01      	subs	r4, #1
 8024cd4:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8024cd6:	2c00      	cmp	r4, #0
 8024cd8:	dd0a      	ble.n	8024cf0 <prvUnlockQueue+0x62>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8024cda:	692b      	ldr	r3, [r5, #16]
 8024cdc:	b143      	cbz	r3, 8024cf0 <prvUnlockQueue+0x62>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8024cde:	f105 0010 	add.w	r0, r5, #16
 8024ce2:	f001 f879 	bl	8025dd8 <xTaskRemoveFromEventList>
 8024ce6:	2800      	cmp	r0, #0
 8024ce8:	d0f3      	beq.n	8024cd2 <prvUnlockQueue+0x44>
					vTaskMissedYield();
 8024cea:	f001 f909 	bl	8025f00 <vTaskMissedYield>
 8024cee:	e7f0      	b.n	8024cd2 <prvUnlockQueue+0x44>
		pxQueue->cRxLock = queueUNLOCKED;
 8024cf0:	23ff      	movs	r3, #255	; 0xff
 8024cf2:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
 8024cf6:	f7ff fe27 	bl	8024948 <vPortExitCritical>
}
 8024cfa:	bd38      	pop	{r3, r4, r5, pc}

08024cfc <xQueueGenericReset>:
{
 8024cfc:	b538      	push	{r3, r4, r5, lr}
	configASSERT( pxQueue );
 8024cfe:	b1e0      	cbz	r0, 8024d3a <xQueueGenericReset+0x3e>
 8024d00:	460d      	mov	r5, r1
 8024d02:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 8024d04:	f7ff fdfe 	bl	8024904 <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8024d08:	6823      	ldr	r3, [r4, #0]
 8024d0a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8024d0c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8024d0e:	fb01 3002 	mla	r0, r1, r2, r3
 8024d12:	60a0      	str	r0, [r4, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8024d14:	2000      	movs	r0, #0
 8024d16:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8024d18:	6063      	str	r3, [r4, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 8024d1a:	3a01      	subs	r2, #1
 8024d1c:	fb02 3301 	mla	r3, r2, r1, r3
 8024d20:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8024d22:	23ff      	movs	r3, #255	; 0xff
 8024d24:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8024d28:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 8024d2c:	b9fd      	cbnz	r5, 8024d6e <xQueueGenericReset+0x72>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8024d2e:	6923      	ldr	r3, [r4, #16]
 8024d30:	b963      	cbnz	r3, 8024d4c <xQueueGenericReset+0x50>
	taskEXIT_CRITICAL();
 8024d32:	f7ff fe09 	bl	8024948 <vPortExitCritical>
}
 8024d36:	2001      	movs	r0, #1
 8024d38:	bd38      	pop	{r3, r4, r5, pc}
 8024d3a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024d3e:	f383 8811 	msr	BASEPRI, r3
 8024d42:	f3bf 8f6f 	isb	sy
 8024d46:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8024d4a:	e7fe      	b.n	8024d4a <xQueueGenericReset+0x4e>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8024d4c:	f104 0010 	add.w	r0, r4, #16
 8024d50:	f001 f842 	bl	8025dd8 <xTaskRemoveFromEventList>
 8024d54:	2800      	cmp	r0, #0
 8024d56:	d0ec      	beq.n	8024d32 <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 8024d58:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024d5c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024d60:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024d64:	f3bf 8f4f 	dsb	sy
 8024d68:	f3bf 8f6f 	isb	sy
 8024d6c:	e7e1      	b.n	8024d32 <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8024d6e:	f104 0010 	add.w	r0, r4, #16
 8024d72:	f7ff fd19 	bl	80247a8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8024d76:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8024d7a:	f7ff fd15 	bl	80247a8 <vListInitialise>
 8024d7e:	e7d8      	b.n	8024d32 <xQueueGenericReset+0x36>

08024d80 <prvInitialiseNewQueue>:
{
 8024d80:	b538      	push	{r3, r4, r5, lr}
 8024d82:	461d      	mov	r5, r3
 8024d84:	9c04      	ldr	r4, [sp, #16]
	if( uxItemSize == ( UBaseType_t ) 0 )
 8024d86:	460b      	mov	r3, r1
 8024d88:	b949      	cbnz	r1, 8024d9e <prvInitialiseNewQueue+0x1e>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8024d8a:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
 8024d8c:	63e0      	str	r0, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8024d8e:	6423      	str	r3, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8024d90:	2101      	movs	r1, #1
 8024d92:	4620      	mov	r0, r4
 8024d94:	f7ff ffb2 	bl	8024cfc <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
 8024d98:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
}
 8024d9c:	bd38      	pop	{r3, r4, r5, pc}
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 8024d9e:	6022      	str	r2, [r4, #0]
 8024da0:	e7f4      	b.n	8024d8c <prvInitialiseNewQueue+0xc>

08024da2 <xQueueGenericCreate>:
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8024da2:	b940      	cbnz	r0, 8024db6 <xQueueGenericCreate+0x14>
 8024da4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024da8:	f383 8811 	msr	BASEPRI, r3
 8024dac:	f3bf 8f6f 	isb	sy
 8024db0:	f3bf 8f4f 	dsb	sy
 8024db4:	e7fe      	b.n	8024db4 <xQueueGenericCreate+0x12>
	{
 8024db6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024db8:	b083      	sub	sp, #12
 8024dba:	460c      	mov	r4, r1
 8024dbc:	4615      	mov	r5, r2
 8024dbe:	4606      	mov	r6, r0
		if( uxItemSize == ( UBaseType_t ) 0 )
 8024dc0:	b189      	cbz	r1, 8024de6 <xQueueGenericCreate+0x44>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8024dc2:	fb01 f000 	mul.w	r0, r1, r0
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 8024dc6:	3050      	adds	r0, #80	; 0x50
 8024dc8:	f7ff fc3e 	bl	8024648 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8024dcc:	4607      	mov	r7, r0
 8024dce:	b138      	cbz	r0, 8024de0 <xQueueGenericCreate+0x3e>
			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8024dd0:	9000      	str	r0, [sp, #0]
 8024dd2:	462b      	mov	r3, r5
 8024dd4:	f100 0250 	add.w	r2, r0, #80	; 0x50
 8024dd8:	4621      	mov	r1, r4
 8024dda:	4630      	mov	r0, r6
 8024ddc:	f7ff ffd0 	bl	8024d80 <prvInitialiseNewQueue>
	}
 8024de0:	4638      	mov	r0, r7
 8024de2:	b003      	add	sp, #12
 8024de4:	bdf0      	pop	{r4, r5, r6, r7, pc}
			xQueueSizeInBytes = ( size_t ) 0;
 8024de6:	4608      	mov	r0, r1
 8024de8:	e7ed      	b.n	8024dc6 <xQueueGenericCreate+0x24>

08024dea <xQueueCreateCountingSemaphore>:
		configASSERT( uxMaxCount != 0 );
 8024dea:	b940      	cbnz	r0, 8024dfe <xQueueCreateCountingSemaphore+0x14>
 8024dec:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024df0:	f383 8811 	msr	BASEPRI, r3
 8024df4:	f3bf 8f6f 	isb	sy
 8024df8:	f3bf 8f4f 	dsb	sy
 8024dfc:	e7fe      	b.n	8024dfc <xQueueCreateCountingSemaphore+0x12>
	{
 8024dfe:	b510      	push	{r4, lr}
 8024e00:	460c      	mov	r4, r1
		configASSERT( uxInitialCount <= uxMaxCount );
 8024e02:	4288      	cmp	r0, r1
 8024e04:	d208      	bcs.n	8024e18 <xQueueCreateCountingSemaphore+0x2e>
 8024e06:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e0a:	f383 8811 	msr	BASEPRI, r3
 8024e0e:	f3bf 8f6f 	isb	sy
 8024e12:	f3bf 8f4f 	dsb	sy
 8024e16:	e7fe      	b.n	8024e16 <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 8024e18:	2202      	movs	r2, #2
 8024e1a:	2100      	movs	r1, #0
 8024e1c:	f7ff ffc1 	bl	8024da2 <xQueueGenericCreate>
		if( xHandle != NULL )
 8024e20:	b100      	cbz	r0, 8024e24 <xQueueCreateCountingSemaphore+0x3a>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 8024e22:	6384      	str	r4, [r0, #56]	; 0x38
	}
 8024e24:	bd10      	pop	{r4, pc}

08024e26 <xQueueGenericSend>:
{
 8024e26:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024e28:	b085      	sub	sp, #20
 8024e2a:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 8024e2c:	b188      	cbz	r0, 8024e52 <xQueueGenericSend+0x2c>
 8024e2e:	460f      	mov	r7, r1
 8024e30:	461d      	mov	r5, r3
 8024e32:	4604      	mov	r4, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8024e34:	b1b1      	cbz	r1, 8024e64 <xQueueGenericSend+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8024e36:	2d02      	cmp	r5, #2
 8024e38:	d120      	bne.n	8024e7c <xQueueGenericSend+0x56>
 8024e3a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024e3c:	2b01      	cmp	r3, #1
 8024e3e:	d01d      	beq.n	8024e7c <xQueueGenericSend+0x56>
 8024e40:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e44:	f383 8811 	msr	BASEPRI, r3
 8024e48:	f3bf 8f6f 	isb	sy
 8024e4c:	f3bf 8f4f 	dsb	sy
 8024e50:	e7fe      	b.n	8024e50 <xQueueGenericSend+0x2a>
 8024e52:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e56:	f383 8811 	msr	BASEPRI, r3
 8024e5a:	f3bf 8f6f 	isb	sy
 8024e5e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8024e62:	e7fe      	b.n	8024e62 <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8024e64:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8024e66:	2b00      	cmp	r3, #0
 8024e68:	d0e5      	beq.n	8024e36 <xQueueGenericSend+0x10>
 8024e6a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e6e:	f383 8811 	msr	BASEPRI, r3
 8024e72:	f3bf 8f6f 	isb	sy
 8024e76:	f3bf 8f4f 	dsb	sy
 8024e7a:	e7fe      	b.n	8024e7a <xQueueGenericSend+0x54>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8024e7c:	f001 f846 	bl	8025f0c <xTaskGetSchedulerState>
 8024e80:	4606      	mov	r6, r0
 8024e82:	b958      	cbnz	r0, 8024e9c <xQueueGenericSend+0x76>
 8024e84:	9b01      	ldr	r3, [sp, #4]
 8024e86:	2b00      	cmp	r3, #0
 8024e88:	d048      	beq.n	8024f1c <xQueueGenericSend+0xf6>
 8024e8a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024e8e:	f383 8811 	msr	BASEPRI, r3
 8024e92:	f3bf 8f6f 	isb	sy
 8024e96:	f3bf 8f4f 	dsb	sy
 8024e9a:	e7fe      	b.n	8024e9a <xQueueGenericSend+0x74>
 8024e9c:	2600      	movs	r6, #0
 8024e9e:	e03d      	b.n	8024f1c <xQueueGenericSend+0xf6>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8024ea0:	462a      	mov	r2, r5
 8024ea2:	4639      	mov	r1, r7
 8024ea4:	4620      	mov	r0, r4
 8024ea6:	f7ff fea5 	bl	8024bf4 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8024eaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8024eac:	b97b      	cbnz	r3, 8024ece <xQueueGenericSend+0xa8>
					else if( xYieldRequired != pdFALSE )
 8024eae:	b148      	cbz	r0, 8024ec4 <xQueueGenericSend+0x9e>
						queueYIELD_IF_USING_PREEMPTION();
 8024eb0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024eb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024eb8:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024ebc:	f3bf 8f4f 	dsb	sy
 8024ec0:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8024ec4:	f7ff fd40 	bl	8024948 <vPortExitCritical>
				return pdPASS;
 8024ec8:	2001      	movs	r0, #1
}
 8024eca:	b005      	add	sp, #20
 8024ecc:	bdf0      	pop	{r4, r5, r6, r7, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8024ece:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8024ed2:	f000 ff81 	bl	8025dd8 <xTaskRemoveFromEventList>
 8024ed6:	2800      	cmp	r0, #0
 8024ed8:	d0f4      	beq.n	8024ec4 <xQueueGenericSend+0x9e>
							queueYIELD_IF_USING_PREEMPTION();
 8024eda:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024ede:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024ee2:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024ee6:	f3bf 8f4f 	dsb	sy
 8024eea:	f3bf 8f6f 	isb	sy
 8024eee:	e7e9      	b.n	8024ec4 <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
 8024ef0:	f7ff fd2a 	bl	8024948 <vPortExitCritical>
					return errQUEUE_FULL;
 8024ef4:	2000      	movs	r0, #0
 8024ef6:	e7e8      	b.n	8024eca <xQueueGenericSend+0xa4>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8024ef8:	a802      	add	r0, sp, #8
 8024efa:	f000 ffb3 	bl	8025e64 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8024efe:	2601      	movs	r6, #1
 8024f00:	e019      	b.n	8024f36 <xQueueGenericSend+0x110>
		prvLockQueue( pxQueue );
 8024f02:	2300      	movs	r3, #0
 8024f04:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8024f08:	e021      	b.n	8024f4e <xQueueGenericSend+0x128>
 8024f0a:	2300      	movs	r3, #0
 8024f0c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8024f10:	e023      	b.n	8024f5a <xQueueGenericSend+0x134>
				prvUnlockQueue( pxQueue );
 8024f12:	4620      	mov	r0, r4
 8024f14:	f7ff febb 	bl	8024c8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8024f18:	f000 fe3c 	bl	8025b94 <xTaskResumeAll>
		taskENTER_CRITICAL();
 8024f1c:	f7ff fcf2 	bl	8024904 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8024f20:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8024f22:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024f24:	429a      	cmp	r2, r3
 8024f26:	d3bb      	bcc.n	8024ea0 <xQueueGenericSend+0x7a>
 8024f28:	2d02      	cmp	r5, #2
 8024f2a:	d0b9      	beq.n	8024ea0 <xQueueGenericSend+0x7a>
				if( xTicksToWait == ( TickType_t ) 0 )
 8024f2c:	9b01      	ldr	r3, [sp, #4]
 8024f2e:	2b00      	cmp	r3, #0
 8024f30:	d0de      	beq.n	8024ef0 <xQueueGenericSend+0xca>
				else if( xEntryTimeSet == pdFALSE )
 8024f32:	2e00      	cmp	r6, #0
 8024f34:	d0e0      	beq.n	8024ef8 <xQueueGenericSend+0xd2>
		taskEXIT_CRITICAL();
 8024f36:	f7ff fd07 	bl	8024948 <vPortExitCritical>
		vTaskSuspendAll();
 8024f3a:	f000 fd89 	bl	8025a50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8024f3e:	f7ff fce1 	bl	8024904 <vPortEnterCritical>
 8024f42:	f894 2044 	ldrb.w	r2, [r4, #68]	; 0x44
 8024f46:	b252      	sxtb	r2, r2
 8024f48:	f1b2 3fff 	cmp.w	r2, #4294967295
 8024f4c:	d0d9      	beq.n	8024f02 <xQueueGenericSend+0xdc>
 8024f4e:	f894 2045 	ldrb.w	r2, [r4, #69]	; 0x45
 8024f52:	b252      	sxtb	r2, r2
 8024f54:	f1b2 3fff 	cmp.w	r2, #4294967295
 8024f58:	d0d7      	beq.n	8024f0a <xQueueGenericSend+0xe4>
 8024f5a:	f7ff fcf5 	bl	8024948 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8024f5e:	a901      	add	r1, sp, #4
 8024f60:	a802      	add	r0, sp, #8
 8024f62:	f000 ff8b 	bl	8025e7c <xTaskCheckForTimeOut>
 8024f66:	b9d8      	cbnz	r0, 8024fa0 <xQueueGenericSend+0x17a>
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8024f68:	4620      	mov	r0, r4
 8024f6a:	f7ff fe27 	bl	8024bbc <prvIsQueueFull>
 8024f6e:	2800      	cmp	r0, #0
 8024f70:	d0cf      	beq.n	8024f12 <xQueueGenericSend+0xec>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8024f72:	9901      	ldr	r1, [sp, #4]
 8024f74:	f104 0010 	add.w	r0, r4, #16
 8024f78:	f000 fefa 	bl	8025d70 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8024f7c:	4620      	mov	r0, r4
 8024f7e:	f7ff fe86 	bl	8024c8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8024f82:	f000 fe07 	bl	8025b94 <xTaskResumeAll>
 8024f86:	2800      	cmp	r0, #0
 8024f88:	d1c8      	bne.n	8024f1c <xQueueGenericSend+0xf6>
					portYIELD_WITHIN_API();
 8024f8a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8024f8e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8024f92:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8024f96:	f3bf 8f4f 	dsb	sy
 8024f9a:	f3bf 8f6f 	isb	sy
 8024f9e:	e7bd      	b.n	8024f1c <xQueueGenericSend+0xf6>
			prvUnlockQueue( pxQueue );
 8024fa0:	4620      	mov	r0, r4
 8024fa2:	f7ff fe74 	bl	8024c8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8024fa6:	f000 fdf5 	bl	8025b94 <xTaskResumeAll>
			return errQUEUE_FULL;
 8024faa:	2000      	movs	r0, #0
 8024fac:	e78d      	b.n	8024eca <xQueueGenericSend+0xa4>

08024fae <prvInitialiseMutex>:
		if( pxNewQueue != NULL )
 8024fae:	b148      	cbz	r0, 8024fc4 <prvInitialiseMutex+0x16>
	{
 8024fb0:	b508      	push	{r3, lr}
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 8024fb2:	2100      	movs	r1, #0
 8024fb4:	6081      	str	r1, [r0, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8024fb6:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 8024fb8:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8024fba:	460b      	mov	r3, r1
 8024fbc:	460a      	mov	r2, r1
 8024fbe:	f7ff ff32 	bl	8024e26 <xQueueGenericSend>
	}
 8024fc2:	bd08      	pop	{r3, pc}
 8024fc4:	4770      	bx	lr

08024fc6 <xQueueCreateMutex>:
	{
 8024fc6:	b510      	push	{r4, lr}
 8024fc8:	4602      	mov	r2, r0
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 8024fca:	2100      	movs	r1, #0
 8024fcc:	2001      	movs	r0, #1
 8024fce:	f7ff fee8 	bl	8024da2 <xQueueGenericCreate>
 8024fd2:	4604      	mov	r4, r0
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 8024fd4:	f7ff ffeb 	bl	8024fae <prvInitialiseMutex>
	}
 8024fd8:	4620      	mov	r0, r4
 8024fda:	bd10      	pop	{r4, pc}

08024fdc <xQueueGenericSendFromISR>:
{
 8024fdc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8024fe0:	b190      	cbz	r0, 8025008 <xQueueGenericSendFromISR+0x2c>
 8024fe2:	460f      	mov	r7, r1
 8024fe4:	4616      	mov	r6, r2
 8024fe6:	461c      	mov	r4, r3
 8024fe8:	4605      	mov	r5, r0
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8024fea:	b1b1      	cbz	r1, 802501a <xQueueGenericSendFromISR+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8024fec:	2c02      	cmp	r4, #2
 8024fee:	d120      	bne.n	8025032 <xQueueGenericSendFromISR+0x56>
 8024ff0:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8024ff2:	2b01      	cmp	r3, #1
 8024ff4:	d01d      	beq.n	8025032 <xQueueGenericSendFromISR+0x56>
 8024ff6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8024ffa:	f383 8811 	msr	BASEPRI, r3
 8024ffe:	f3bf 8f6f 	isb	sy
 8025002:	f3bf 8f4f 	dsb	sy
 8025006:	e7fe      	b.n	8025006 <xQueueGenericSendFromISR+0x2a>
 8025008:	f04f 0350 	mov.w	r3, #80	; 0x50
 802500c:	f383 8811 	msr	BASEPRI, r3
 8025010:	f3bf 8f6f 	isb	sy
 8025014:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 8025018:	e7fe      	b.n	8025018 <xQueueGenericSendFromISR+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 802501a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 802501c:	2b00      	cmp	r3, #0
 802501e:	d0e5      	beq.n	8024fec <xQueueGenericSendFromISR+0x10>
 8025020:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025024:	f383 8811 	msr	BASEPRI, r3
 8025028:	f3bf 8f6f 	isb	sy
 802502c:	f3bf 8f4f 	dsb	sy
 8025030:	e7fe      	b.n	8025030 <xQueueGenericSendFromISR+0x54>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8025032:	f7ff fd8d 	bl	8024b50 <vPortValidateInterruptPriority>
	__asm volatile
 8025036:	f3ef 8811 	mrs	r8, BASEPRI
 802503a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802503e:	f383 8811 	msr	BASEPRI, r3
 8025042:	f3bf 8f6f 	isb	sy
 8025046:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 802504a:	6baa      	ldr	r2, [r5, #56]	; 0x38
 802504c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 802504e:	429a      	cmp	r2, r3
 8025050:	d306      	bcc.n	8025060 <xQueueGenericSendFromISR+0x84>
 8025052:	2c02      	cmp	r4, #2
 8025054:	d004      	beq.n	8025060 <xQueueGenericSendFromISR+0x84>
			xReturn = errQUEUE_FULL;
 8025056:	2000      	movs	r0, #0
	__asm volatile
 8025058:	f388 8811 	msr	BASEPRI, r8
}
 802505c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			const int8_t cTxLock = pxQueue->cTxLock;
 8025060:	f895 9045 	ldrb.w	r9, [r5, #69]	; 0x45
 8025064:	fa4f f989 	sxtb.w	r9, r9
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8025068:	4622      	mov	r2, r4
 802506a:	4639      	mov	r1, r7
 802506c:	4628      	mov	r0, r5
 802506e:	f7ff fdc1 	bl	8024bf4 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 8025072:	f1b9 3fff 	cmp.w	r9, #4294967295
 8025076:	d006      	beq.n	8025086 <xQueueGenericSendFromISR+0xaa>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 8025078:	f109 0301 	add.w	r3, r9, #1
 802507c:	b25b      	sxtb	r3, r3
 802507e:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
			xReturn = pdPASS;
 8025082:	2001      	movs	r0, #1
 8025084:	e7e8      	b.n	8025058 <xQueueGenericSendFromISR+0x7c>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8025086:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8025088:	b90b      	cbnz	r3, 802508e <xQueueGenericSendFromISR+0xb2>
			xReturn = pdPASS;
 802508a:	2001      	movs	r0, #1
 802508c:	e7e4      	b.n	8025058 <xQueueGenericSendFromISR+0x7c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 802508e:	f105 0024 	add.w	r0, r5, #36	; 0x24
 8025092:	f000 fea1 	bl	8025dd8 <xTaskRemoveFromEventList>
 8025096:	b118      	cbz	r0, 80250a0 <xQueueGenericSendFromISR+0xc4>
							if( pxHigherPriorityTaskWoken != NULL )
 8025098:	b126      	cbz	r6, 80250a4 <xQueueGenericSendFromISR+0xc8>
								*pxHigherPriorityTaskWoken = pdTRUE;
 802509a:	2001      	movs	r0, #1
 802509c:	6030      	str	r0, [r6, #0]
 802509e:	e7db      	b.n	8025058 <xQueueGenericSendFromISR+0x7c>
			xReturn = pdPASS;
 80250a0:	2001      	movs	r0, #1
 80250a2:	e7d9      	b.n	8025058 <xQueueGenericSendFromISR+0x7c>
 80250a4:	2001      	movs	r0, #1
 80250a6:	e7d7      	b.n	8025058 <xQueueGenericSendFromISR+0x7c>

080250a8 <xQueueGiveFromISR>:
	configASSERT( pxQueue );
 80250a8:	b168      	cbz	r0, 80250c6 <xQueueGiveFromISR+0x1e>
{
 80250aa:	b570      	push	{r4, r5, r6, lr}
 80250ac:	460c      	mov	r4, r1
 80250ae:	4605      	mov	r5, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 80250b0:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80250b2:	b18b      	cbz	r3, 80250d8 <xQueueGiveFromISR+0x30>
	__asm volatile
 80250b4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80250b8:	f383 8811 	msr	BASEPRI, r3
 80250bc:	f3bf 8f6f 	isb	sy
 80250c0:	f3bf 8f4f 	dsb	sy
 80250c4:	e7fe      	b.n	80250c4 <xQueueGiveFromISR+0x1c>
 80250c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80250ca:	f383 8811 	msr	BASEPRI, r3
 80250ce:	f3bf 8f6f 	isb	sy
 80250d2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80250d6:	e7fe      	b.n	80250d6 <xQueueGiveFromISR+0x2e>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 80250d8:	6803      	ldr	r3, [r0, #0]
 80250da:	b1eb      	cbz	r3, 8025118 <xQueueGiveFromISR+0x70>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80250dc:	f7ff fd38 	bl	8024b50 <vPortValidateInterruptPriority>
	__asm volatile
 80250e0:	f3ef 8611 	mrs	r6, BASEPRI
 80250e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80250e8:	f383 8811 	msr	BASEPRI, r3
 80250ec:	f3bf 8f6f 	isb	sy
 80250f0:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80250f4:	6baa      	ldr	r2, [r5, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
 80250f6:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 80250f8:	4293      	cmp	r3, r2
 80250fa:	d926      	bls.n	802514a <xQueueGiveFromISR+0xa2>
			const int8_t cTxLock = pxQueue->cTxLock;
 80250fc:	f895 3045 	ldrb.w	r3, [r5, #69]	; 0x45
 8025100:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8025102:	3201      	adds	r2, #1
 8025104:	63aa      	str	r2, [r5, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
 8025106:	f1b3 3fff 	cmp.w	r3, #4294967295
 802510a:	d011      	beq.n	8025130 <xQueueGiveFromISR+0x88>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 802510c:	3301      	adds	r3, #1
 802510e:	b25b      	sxtb	r3, r3
 8025110:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
			xReturn = pdPASS;
 8025114:	2001      	movs	r0, #1
 8025116:	e019      	b.n	802514c <xQueueGiveFromISR+0xa4>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 8025118:	6883      	ldr	r3, [r0, #8]
 802511a:	2b00      	cmp	r3, #0
 802511c:	d0de      	beq.n	80250dc <xQueueGiveFromISR+0x34>
	__asm volatile
 802511e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025122:	f383 8811 	msr	BASEPRI, r3
 8025126:	f3bf 8f6f 	isb	sy
 802512a:	f3bf 8f4f 	dsb	sy
 802512e:	e7fe      	b.n	802512e <xQueueGiveFromISR+0x86>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8025130:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8025132:	b90b      	cbnz	r3, 8025138 <xQueueGiveFromISR+0x90>
			xReturn = pdPASS;
 8025134:	2001      	movs	r0, #1
 8025136:	e009      	b.n	802514c <xQueueGiveFromISR+0xa4>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8025138:	f105 0024 	add.w	r0, r5, #36	; 0x24
 802513c:	f000 fe4c 	bl	8025dd8 <xTaskRemoveFromEventList>
 8025140:	b138      	cbz	r0, 8025152 <xQueueGiveFromISR+0xaa>
							if( pxHigherPriorityTaskWoken != NULL )
 8025142:	b144      	cbz	r4, 8025156 <xQueueGiveFromISR+0xae>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8025144:	2001      	movs	r0, #1
 8025146:	6020      	str	r0, [r4, #0]
 8025148:	e000      	b.n	802514c <xQueueGiveFromISR+0xa4>
			xReturn = errQUEUE_FULL;
 802514a:	2000      	movs	r0, #0
	__asm volatile
 802514c:	f386 8811 	msr	BASEPRI, r6
}
 8025150:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = pdPASS;
 8025152:	2001      	movs	r0, #1
 8025154:	e7fa      	b.n	802514c <xQueueGiveFromISR+0xa4>
 8025156:	2001      	movs	r0, #1
 8025158:	e7f8      	b.n	802514c <xQueueGiveFromISR+0xa4>

0802515a <xQueueReceive>:
{
 802515a:	b5f0      	push	{r4, r5, r6, r7, lr}
 802515c:	b085      	sub	sp, #20
 802515e:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 8025160:	b190      	cbz	r0, 8025188 <xQueueReceive+0x2e>
 8025162:	460f      	mov	r7, r1
 8025164:	4604      	mov	r4, r0
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8025166:	b1c1      	cbz	r1, 802519a <xQueueReceive+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8025168:	f000 fed0 	bl	8025f0c <xTaskGetSchedulerState>
 802516c:	4606      	mov	r6, r0
 802516e:	bb00      	cbnz	r0, 80251b2 <xQueueReceive+0x58>
 8025170:	9b01      	ldr	r3, [sp, #4]
 8025172:	2b00      	cmp	r3, #0
 8025174:	d05e      	beq.n	8025234 <xQueueReceive+0xda>
	__asm volatile
 8025176:	f04f 0350 	mov.w	r3, #80	; 0x50
 802517a:	f383 8811 	msr	BASEPRI, r3
 802517e:	f3bf 8f6f 	isb	sy
 8025182:	f3bf 8f4f 	dsb	sy
 8025186:	e7fe      	b.n	8025186 <xQueueReceive+0x2c>
 8025188:	f04f 0350 	mov.w	r3, #80	; 0x50
 802518c:	f383 8811 	msr	BASEPRI, r3
 8025190:	f3bf 8f6f 	isb	sy
 8025194:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 8025198:	e7fe      	b.n	8025198 <xQueueReceive+0x3e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 802519a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 802519c:	2b00      	cmp	r3, #0
 802519e:	d0e3      	beq.n	8025168 <xQueueReceive+0xe>
 80251a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80251a4:	f383 8811 	msr	BASEPRI, r3
 80251a8:	f3bf 8f6f 	isb	sy
 80251ac:	f3bf 8f4f 	dsb	sy
 80251b0:	e7fe      	b.n	80251b0 <xQueueReceive+0x56>
 80251b2:	2600      	movs	r6, #0
 80251b4:	e03e      	b.n	8025234 <xQueueReceive+0xda>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80251b6:	4639      	mov	r1, r7
 80251b8:	4620      	mov	r0, r4
 80251ba:	f7ff fd56 	bl	8024c6a <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80251be:	3d01      	subs	r5, #1
 80251c0:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80251c2:	6923      	ldr	r3, [r4, #16]
 80251c4:	b923      	cbnz	r3, 80251d0 <xQueueReceive+0x76>
				taskEXIT_CRITICAL();
 80251c6:	f7ff fbbf 	bl	8024948 <vPortExitCritical>
				return pdPASS;
 80251ca:	2001      	movs	r0, #1
}
 80251cc:	b005      	add	sp, #20
 80251ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80251d0:	f104 0010 	add.w	r0, r4, #16
 80251d4:	f000 fe00 	bl	8025dd8 <xTaskRemoveFromEventList>
 80251d8:	2800      	cmp	r0, #0
 80251da:	d0f4      	beq.n	80251c6 <xQueueReceive+0x6c>
						queueYIELD_IF_USING_PREEMPTION();
 80251dc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80251e0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80251e4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80251e8:	f3bf 8f4f 	dsb	sy
 80251ec:	f3bf 8f6f 	isb	sy
 80251f0:	e7e9      	b.n	80251c6 <xQueueReceive+0x6c>
					taskEXIT_CRITICAL();
 80251f2:	f7ff fba9 	bl	8024948 <vPortExitCritical>
					return errQUEUE_EMPTY;
 80251f6:	2000      	movs	r0, #0
 80251f8:	e7e8      	b.n	80251cc <xQueueReceive+0x72>
					vTaskInternalSetTimeOutState( &xTimeOut );
 80251fa:	a802      	add	r0, sp, #8
 80251fc:	f000 fe32 	bl	8025e64 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8025200:	2601      	movs	r6, #1
 8025202:	e021      	b.n	8025248 <xQueueReceive+0xee>
		prvLockQueue( pxQueue );
 8025204:	2300      	movs	r3, #0
 8025206:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 802520a:	e029      	b.n	8025260 <xQueueReceive+0x106>
 802520c:	2300      	movs	r3, #0
 802520e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8025212:	e02b      	b.n	802526c <xQueueReceive+0x112>
				prvUnlockQueue( pxQueue );
 8025214:	4620      	mov	r0, r4
 8025216:	f7ff fd3a 	bl	8024c8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 802521a:	f000 fcbb 	bl	8025b94 <xTaskResumeAll>
 802521e:	e009      	b.n	8025234 <xQueueReceive+0xda>
			prvUnlockQueue( pxQueue );
 8025220:	4620      	mov	r0, r4
 8025222:	f7ff fd34 	bl	8024c8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8025226:	f000 fcb5 	bl	8025b94 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 802522a:	4620      	mov	r0, r4
 802522c:	f7ff fcd5 	bl	8024bda <prvIsQueueEmpty>
 8025230:	2800      	cmp	r0, #0
 8025232:	d13f      	bne.n	80252b4 <xQueueReceive+0x15a>
		taskENTER_CRITICAL();
 8025234:	f7ff fb66 	bl	8024904 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8025238:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 802523a:	2d00      	cmp	r5, #0
 802523c:	d1bb      	bne.n	80251b6 <xQueueReceive+0x5c>
				if( xTicksToWait == ( TickType_t ) 0 )
 802523e:	9b01      	ldr	r3, [sp, #4]
 8025240:	2b00      	cmp	r3, #0
 8025242:	d0d6      	beq.n	80251f2 <xQueueReceive+0x98>
				else if( xEntryTimeSet == pdFALSE )
 8025244:	2e00      	cmp	r6, #0
 8025246:	d0d8      	beq.n	80251fa <xQueueReceive+0xa0>
		taskEXIT_CRITICAL();
 8025248:	f7ff fb7e 	bl	8024948 <vPortExitCritical>
		vTaskSuspendAll();
 802524c:	f000 fc00 	bl	8025a50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8025250:	f7ff fb58 	bl	8024904 <vPortEnterCritical>
 8025254:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8025258:	b25b      	sxtb	r3, r3
 802525a:	f1b3 3fff 	cmp.w	r3, #4294967295
 802525e:	d0d1      	beq.n	8025204 <xQueueReceive+0xaa>
 8025260:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8025264:	b25b      	sxtb	r3, r3
 8025266:	f1b3 3fff 	cmp.w	r3, #4294967295
 802526a:	d0cf      	beq.n	802520c <xQueueReceive+0xb2>
 802526c:	f7ff fb6c 	bl	8024948 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8025270:	a901      	add	r1, sp, #4
 8025272:	a802      	add	r0, sp, #8
 8025274:	f000 fe02 	bl	8025e7c <xTaskCheckForTimeOut>
 8025278:	2800      	cmp	r0, #0
 802527a:	d1d1      	bne.n	8025220 <xQueueReceive+0xc6>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 802527c:	4620      	mov	r0, r4
 802527e:	f7ff fcac 	bl	8024bda <prvIsQueueEmpty>
 8025282:	2800      	cmp	r0, #0
 8025284:	d0c6      	beq.n	8025214 <xQueueReceive+0xba>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8025286:	9901      	ldr	r1, [sp, #4]
 8025288:	f104 0024 	add.w	r0, r4, #36	; 0x24
 802528c:	f000 fd70 	bl	8025d70 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8025290:	4620      	mov	r0, r4
 8025292:	f7ff fcfc 	bl	8024c8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8025296:	f000 fc7d 	bl	8025b94 <xTaskResumeAll>
 802529a:	2800      	cmp	r0, #0
 802529c:	d1ca      	bne.n	8025234 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
 802529e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80252a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80252a6:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80252aa:	f3bf 8f4f 	dsb	sy
 80252ae:	f3bf 8f6f 	isb	sy
 80252b2:	e7bf      	b.n	8025234 <xQueueReceive+0xda>
				return errQUEUE_EMPTY;
 80252b4:	2000      	movs	r0, #0
 80252b6:	e789      	b.n	80251cc <xQueueReceive+0x72>

080252b8 <xQueueSemaphoreTake>:
{
 80252b8:	b570      	push	{r4, r5, r6, lr}
 80252ba:	b084      	sub	sp, #16
 80252bc:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
 80252be:	b158      	cbz	r0, 80252d8 <xQueueSemaphoreTake+0x20>
 80252c0:	4604      	mov	r4, r0
	configASSERT( pxQueue->uxItemSize == 0 );
 80252c2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80252c4:	b18b      	cbz	r3, 80252ea <xQueueSemaphoreTake+0x32>
 80252c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80252ca:	f383 8811 	msr	BASEPRI, r3
 80252ce:	f3bf 8f6f 	isb	sy
 80252d2:	f3bf 8f4f 	dsb	sy
 80252d6:	e7fe      	b.n	80252d6 <xQueueSemaphoreTake+0x1e>
 80252d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80252dc:	f383 8811 	msr	BASEPRI, r3
 80252e0:	f3bf 8f6f 	isb	sy
 80252e4:	f3bf 8f4f 	dsb	sy
	configASSERT( ( pxQueue ) );
 80252e8:	e7fe      	b.n	80252e8 <xQueueSemaphoreTake+0x30>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80252ea:	f000 fe0f 	bl	8025f0c <xTaskGetSchedulerState>
 80252ee:	4605      	mov	r5, r0
 80252f0:	b950      	cbnz	r0, 8025308 <xQueueSemaphoreTake+0x50>
 80252f2:	9b01      	ldr	r3, [sp, #4]
 80252f4:	b15b      	cbz	r3, 802530e <xQueueSemaphoreTake+0x56>
 80252f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80252fa:	f383 8811 	msr	BASEPRI, r3
 80252fe:	f3bf 8f6f 	isb	sy
 8025302:	f3bf 8f4f 	dsb	sy
 8025306:	e7fe      	b.n	8025306 <xQueueSemaphoreTake+0x4e>
 8025308:	2600      	movs	r6, #0
 802530a:	4635      	mov	r5, r6
 802530c:	e055      	b.n	80253ba <xQueueSemaphoreTake+0x102>
 802530e:	4606      	mov	r6, r0
 8025310:	e053      	b.n	80253ba <xQueueSemaphoreTake+0x102>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 8025312:	3b01      	subs	r3, #1
 8025314:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8025316:	6823      	ldr	r3, [r4, #0]
 8025318:	b13b      	cbz	r3, 802532a <xQueueSemaphoreTake+0x72>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 802531a:	6923      	ldr	r3, [r4, #16]
 802531c:	b94b      	cbnz	r3, 8025332 <xQueueSemaphoreTake+0x7a>
				taskEXIT_CRITICAL();
 802531e:	f7ff fb13 	bl	8024948 <vPortExitCritical>
				return pdPASS;
 8025322:	2601      	movs	r6, #1
}
 8025324:	4630      	mov	r0, r6
 8025326:	b004      	add	sp, #16
 8025328:	bd70      	pop	{r4, r5, r6, pc}
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 802532a:	f000 ff13 	bl	8026154 <pvTaskIncrementMutexHeldCount>
 802532e:	60a0      	str	r0, [r4, #8]
 8025330:	e7f3      	b.n	802531a <xQueueSemaphoreTake+0x62>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8025332:	f104 0010 	add.w	r0, r4, #16
 8025336:	f000 fd4f 	bl	8025dd8 <xTaskRemoveFromEventList>
 802533a:	2800      	cmp	r0, #0
 802533c:	d0ef      	beq.n	802531e <xQueueSemaphoreTake+0x66>
						queueYIELD_IF_USING_PREEMPTION();
 802533e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8025342:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025346:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 802534a:	f3bf 8f4f 	dsb	sy
 802534e:	f3bf 8f6f 	isb	sy
 8025352:	e7e4      	b.n	802531e <xQueueSemaphoreTake+0x66>
						configASSERT( xInheritanceOccurred == pdFALSE );
 8025354:	b146      	cbz	r6, 8025368 <xQueueSemaphoreTake+0xb0>
 8025356:	f04f 0350 	mov.w	r3, #80	; 0x50
 802535a:	f383 8811 	msr	BASEPRI, r3
 802535e:	f3bf 8f6f 	isb	sy
 8025362:	f3bf 8f4f 	dsb	sy
 8025366:	e7fe      	b.n	8025366 <xQueueSemaphoreTake+0xae>
					taskEXIT_CRITICAL();
 8025368:	f7ff faee 	bl	8024948 <vPortExitCritical>
					return errQUEUE_EMPTY;
 802536c:	e7da      	b.n	8025324 <xQueueSemaphoreTake+0x6c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 802536e:	a802      	add	r0, sp, #8
 8025370:	f000 fd78 	bl	8025e64 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8025374:	2501      	movs	r5, #1
 8025376:	e02a      	b.n	80253ce <xQueueSemaphoreTake+0x116>
		prvLockQueue( pxQueue );
 8025378:	2300      	movs	r3, #0
 802537a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 802537e:	e032      	b.n	80253e6 <xQueueSemaphoreTake+0x12e>
 8025380:	2300      	movs	r3, #0
 8025382:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8025386:	e034      	b.n	80253f2 <xQueueSemaphoreTake+0x13a>
						taskENTER_CRITICAL();
 8025388:	f7ff fabc 	bl	8024904 <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 802538c:	68a0      	ldr	r0, [r4, #8]
 802538e:	f000 fdcd 	bl	8025f2c <xTaskPriorityInherit>
 8025392:	4606      	mov	r6, r0
						taskEXIT_CRITICAL();
 8025394:	f7ff fad8 	bl	8024948 <vPortExitCritical>
 8025398:	e03b      	b.n	8025412 <xQueueSemaphoreTake+0x15a>
				prvUnlockQueue( pxQueue );
 802539a:	4620      	mov	r0, r4
 802539c:	f7ff fc77 	bl	8024c8e <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80253a0:	f000 fbf8 	bl	8025b94 <xTaskResumeAll>
 80253a4:	e009      	b.n	80253ba <xQueueSemaphoreTake+0x102>
			prvUnlockQueue( pxQueue );
 80253a6:	4620      	mov	r0, r4
 80253a8:	f7ff fc71 	bl	8024c8e <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80253ac:	f000 fbf2 	bl	8025b94 <xTaskResumeAll>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80253b0:	4620      	mov	r0, r4
 80253b2:	f7ff fc12 	bl	8024bda <prvIsQueueEmpty>
 80253b6:	2800      	cmp	r0, #0
 80253b8:	d142      	bne.n	8025440 <xQueueSemaphoreTake+0x188>
		taskENTER_CRITICAL();
 80253ba:	f7ff faa3 	bl	8024904 <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 80253be:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 80253c0:	2b00      	cmp	r3, #0
 80253c2:	d1a6      	bne.n	8025312 <xQueueSemaphoreTake+0x5a>
				if( xTicksToWait == ( TickType_t ) 0 )
 80253c4:	9b01      	ldr	r3, [sp, #4]
 80253c6:	2b00      	cmp	r3, #0
 80253c8:	d0c4      	beq.n	8025354 <xQueueSemaphoreTake+0x9c>
				else if( xEntryTimeSet == pdFALSE )
 80253ca:	2d00      	cmp	r5, #0
 80253cc:	d0cf      	beq.n	802536e <xQueueSemaphoreTake+0xb6>
		taskEXIT_CRITICAL();
 80253ce:	f7ff fabb 	bl	8024948 <vPortExitCritical>
		vTaskSuspendAll();
 80253d2:	f000 fb3d 	bl	8025a50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80253d6:	f7ff fa95 	bl	8024904 <vPortEnterCritical>
 80253da:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80253de:	b25b      	sxtb	r3, r3
 80253e0:	f1b3 3fff 	cmp.w	r3, #4294967295
 80253e4:	d0c8      	beq.n	8025378 <xQueueSemaphoreTake+0xc0>
 80253e6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80253ea:	b25b      	sxtb	r3, r3
 80253ec:	f1b3 3fff 	cmp.w	r3, #4294967295
 80253f0:	d0c6      	beq.n	8025380 <xQueueSemaphoreTake+0xc8>
 80253f2:	f7ff faa9 	bl	8024948 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80253f6:	a901      	add	r1, sp, #4
 80253f8:	a802      	add	r0, sp, #8
 80253fa:	f000 fd3f 	bl	8025e7c <xTaskCheckForTimeOut>
 80253fe:	2800      	cmp	r0, #0
 8025400:	d1d1      	bne.n	80253a6 <xQueueSemaphoreTake+0xee>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8025402:	4620      	mov	r0, r4
 8025404:	f7ff fbe9 	bl	8024bda <prvIsQueueEmpty>
 8025408:	2800      	cmp	r0, #0
 802540a:	d0c6      	beq.n	802539a <xQueueSemaphoreTake+0xe2>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 802540c:	6823      	ldr	r3, [r4, #0]
 802540e:	2b00      	cmp	r3, #0
 8025410:	d0ba      	beq.n	8025388 <xQueueSemaphoreTake+0xd0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8025412:	9901      	ldr	r1, [sp, #4]
 8025414:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8025418:	f000 fcaa 	bl	8025d70 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 802541c:	4620      	mov	r0, r4
 802541e:	f7ff fc36 	bl	8024c8e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8025422:	f000 fbb7 	bl	8025b94 <xTaskResumeAll>
 8025426:	2800      	cmp	r0, #0
 8025428:	d1c7      	bne.n	80253ba <xQueueSemaphoreTake+0x102>
					portYIELD_WITHIN_API();
 802542a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802542e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025432:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8025436:	f3bf 8f4f 	dsb	sy
 802543a:	f3bf 8f6f 	isb	sy
 802543e:	e7bc      	b.n	80253ba <xQueueSemaphoreTake+0x102>
					if( xInheritanceOccurred != pdFALSE )
 8025440:	b90e      	cbnz	r6, 8025446 <xQueueSemaphoreTake+0x18e>
				return errQUEUE_EMPTY;
 8025442:	2600      	movs	r6, #0
 8025444:	e76e      	b.n	8025324 <xQueueSemaphoreTake+0x6c>
						taskENTER_CRITICAL();
 8025446:	f7ff fa5d 	bl	8024904 <vPortEnterCritical>
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 802544a:	4620      	mov	r0, r4
 802544c:	f7ff fbae 	bl	8024bac <prvGetDisinheritPriorityAfterTimeout>
 8025450:	4601      	mov	r1, r0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 8025452:	68a0      	ldr	r0, [r4, #8]
 8025454:	f000 fe1e 	bl	8026094 <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
 8025458:	f7ff fa76 	bl	8024948 <vPortExitCritical>
 802545c:	e7f1      	b.n	8025442 <xQueueSemaphoreTake+0x18a>

0802545e <xQueueReceiveFromISR>:
{
 802545e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8025462:	b1b0      	cbz	r0, 8025492 <xQueueReceiveFromISR+0x34>
 8025464:	460d      	mov	r5, r1
 8025466:	4690      	mov	r8, r2
 8025468:	4604      	mov	r4, r0
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 802546a:	b1d9      	cbz	r1, 80254a4 <xQueueReceiveFromISR+0x46>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 802546c:	f7ff fb70 	bl	8024b50 <vPortValidateInterruptPriority>
	__asm volatile
 8025470:	f3ef 8711 	mrs	r7, BASEPRI
 8025474:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025478:	f383 8811 	msr	BASEPRI, r3
 802547c:	f3bf 8f6f 	isb	sy
 8025480:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8025484:	6ba6      	ldr	r6, [r4, #56]	; 0x38
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8025486:	b9ce      	cbnz	r6, 80254bc <xQueueReceiveFromISR+0x5e>
			xReturn = pdFAIL;
 8025488:	2000      	movs	r0, #0
	__asm volatile
 802548a:	f387 8811 	msr	BASEPRI, r7
}
 802548e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	__asm volatile
 8025492:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025496:	f383 8811 	msr	BASEPRI, r3
 802549a:	f3bf 8f6f 	isb	sy
 802549e:	f3bf 8f4f 	dsb	sy
	configASSERT( pxQueue );
 80254a2:	e7fe      	b.n	80254a2 <xQueueReceiveFromISR+0x44>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80254a4:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80254a6:	2b00      	cmp	r3, #0
 80254a8:	d0e0      	beq.n	802546c <xQueueReceiveFromISR+0xe>
 80254aa:	f04f 0350 	mov.w	r3, #80	; 0x50
 80254ae:	f383 8811 	msr	BASEPRI, r3
 80254b2:	f3bf 8f6f 	isb	sy
 80254b6:	f3bf 8f4f 	dsb	sy
 80254ba:	e7fe      	b.n	80254ba <xQueueReceiveFromISR+0x5c>
			const int8_t cRxLock = pxQueue->cRxLock;
 80254bc:	f894 9044 	ldrb.w	r9, [r4, #68]	; 0x44
 80254c0:	fa4f f989 	sxtb.w	r9, r9
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 80254c4:	4629      	mov	r1, r5
 80254c6:	4620      	mov	r0, r4
 80254c8:	f7ff fbcf 	bl	8024c6a <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 80254cc:	1e73      	subs	r3, r6, #1
 80254ce:	63a3      	str	r3, [r4, #56]	; 0x38
			if( cRxLock == queueUNLOCKED )
 80254d0:	f1b9 3fff 	cmp.w	r9, #4294967295
 80254d4:	d006      	beq.n	80254e4 <xQueueReceiveFromISR+0x86>
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 80254d6:	f109 0301 	add.w	r3, r9, #1
 80254da:	b25b      	sxtb	r3, r3
 80254dc:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
			xReturn = pdPASS;
 80254e0:	2001      	movs	r0, #1
 80254e2:	e7d2      	b.n	802548a <xQueueReceiveFromISR+0x2c>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80254e4:	6923      	ldr	r3, [r4, #16]
 80254e6:	b90b      	cbnz	r3, 80254ec <xQueueReceiveFromISR+0x8e>
			xReturn = pdPASS;
 80254e8:	2001      	movs	r0, #1
 80254ea:	e7ce      	b.n	802548a <xQueueReceiveFromISR+0x2c>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80254ec:	f104 0010 	add.w	r0, r4, #16
 80254f0:	f000 fc72 	bl	8025dd8 <xTaskRemoveFromEventList>
 80254f4:	b130      	cbz	r0, 8025504 <xQueueReceiveFromISR+0xa6>
						if( pxHigherPriorityTaskWoken != NULL )
 80254f6:	f1b8 0f00 	cmp.w	r8, #0
 80254fa:	d005      	beq.n	8025508 <xQueueReceiveFromISR+0xaa>
							*pxHigherPriorityTaskWoken = pdTRUE;
 80254fc:	2001      	movs	r0, #1
 80254fe:	f8c8 0000 	str.w	r0, [r8]
 8025502:	e7c2      	b.n	802548a <xQueueReceiveFromISR+0x2c>
			xReturn = pdPASS;
 8025504:	2001      	movs	r0, #1
 8025506:	e7c0      	b.n	802548a <xQueueReceiveFromISR+0x2c>
 8025508:	2001      	movs	r0, #1
 802550a:	e7be      	b.n	802548a <xQueueReceiveFromISR+0x2c>

0802550c <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 802550c:	2300      	movs	r3, #0
 802550e:	2b07      	cmp	r3, #7
 8025510:	d80c      	bhi.n	802552c <vQueueAddToRegistry+0x20>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8025512:	4a07      	ldr	r2, [pc, #28]	; (8025530 <vQueueAddToRegistry+0x24>)
 8025514:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8025518:	b10a      	cbz	r2, 802551e <vQueueAddToRegistry+0x12>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 802551a:	3301      	adds	r3, #1
 802551c:	e7f7      	b.n	802550e <vQueueAddToRegistry+0x2>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 802551e:	4a04      	ldr	r2, [pc, #16]	; (8025530 <vQueueAddToRegistry+0x24>)
 8025520:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8025524:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
 8025528:	6050      	str	r0, [r2, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 802552a:	4770      	bx	lr
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 802552c:	4770      	bx	lr
 802552e:	bf00      	nop
 8025530:	20011bf4 	.word	0x20011bf4

08025534 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 8025534:	b570      	push	{r4, r5, r6, lr}
 8025536:	4604      	mov	r4, r0
 8025538:	460d      	mov	r5, r1
 802553a:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 802553c:	f7ff f9e2 	bl	8024904 <vPortEnterCritical>
 8025540:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8025544:	b25b      	sxtb	r3, r3
 8025546:	f1b3 3fff 	cmp.w	r3, #4294967295
 802554a:	d00d      	beq.n	8025568 <vQueueWaitForMessageRestricted+0x34>
 802554c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8025550:	b25b      	sxtb	r3, r3
 8025552:	f1b3 3fff 	cmp.w	r3, #4294967295
 8025556:	d00b      	beq.n	8025570 <vQueueWaitForMessageRestricted+0x3c>
 8025558:	f7ff f9f6 	bl	8024948 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 802555c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 802555e:	b15b      	cbz	r3, 8025578 <vQueueWaitForMessageRestricted+0x44>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8025560:	4620      	mov	r0, r4
 8025562:	f7ff fb94 	bl	8024c8e <prvUnlockQueue>
	}
 8025566:	bd70      	pop	{r4, r5, r6, pc}
		prvLockQueue( pxQueue );
 8025568:	2300      	movs	r3, #0
 802556a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 802556e:	e7ed      	b.n	802554c <vQueueWaitForMessageRestricted+0x18>
 8025570:	2300      	movs	r3, #0
 8025572:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8025576:	e7ef      	b.n	8025558 <vQueueWaitForMessageRestricted+0x24>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 8025578:	4632      	mov	r2, r6
 802557a:	4629      	mov	r1, r5
 802557c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8025580:	f000 fc0e 	bl	8025da0 <vTaskPlaceOnEventListRestricted>
 8025584:	e7ec      	b.n	8025560 <vQueueWaitForMessageRestricted+0x2c>
	...

08025588 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8025588:	4b08      	ldr	r3, [pc, #32]	; (80255ac <prvResetNextTaskUnblockTime+0x24>)
 802558a:	681b      	ldr	r3, [r3, #0]
 802558c:	681b      	ldr	r3, [r3, #0]
 802558e:	b923      	cbnz	r3, 802559a <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8025590:	4b07      	ldr	r3, [pc, #28]	; (80255b0 <prvResetNextTaskUnblockTime+0x28>)
 8025592:	f04f 32ff 	mov.w	r2, #4294967295
 8025596:	601a      	str	r2, [r3, #0]
 8025598:	4770      	bx	lr
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 802559a:	4b04      	ldr	r3, [pc, #16]	; (80255ac <prvResetNextTaskUnblockTime+0x24>)
 802559c:	681b      	ldr	r3, [r3, #0]
 802559e:	68db      	ldr	r3, [r3, #12]
 80255a0:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80255a2:	685a      	ldr	r2, [r3, #4]
 80255a4:	4b02      	ldr	r3, [pc, #8]	; (80255b0 <prvResetNextTaskUnblockTime+0x28>)
 80255a6:	601a      	str	r2, [r3, #0]
	}
}
 80255a8:	4770      	bx	lr
 80255aa:	bf00      	nop
 80255ac:	20011c38 	.word	0x20011c38
 80255b0:	20011d10 	.word	0x20011d10

080255b4 <prvDeleteTCB>:
	{
 80255b4:	b510      	push	{r4, lr}
 80255b6:	4604      	mov	r4, r0
			vPortFree( pxTCB->pxStack );
 80255b8:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80255ba:	f7ff f8bd 	bl	8024738 <vPortFree>
			vPortFree( pxTCB );
 80255be:	4620      	mov	r0, r4
 80255c0:	f7ff f8ba 	bl	8024738 <vPortFree>
	}
 80255c4:	bd10      	pop	{r4, pc}

080255c6 <prvInitialiseNewTask>:
{
 80255c6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80255ca:	4680      	mov	r8, r0
 80255cc:	460d      	mov	r5, r1
 80255ce:	4617      	mov	r7, r2
 80255d0:	4699      	mov	r9, r3
 80255d2:	9e08      	ldr	r6, [sp, #32]
 80255d4:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
 80255d8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 80255da:	0092      	lsls	r2, r2, #2
 80255dc:	21a5      	movs	r1, #165	; 0xa5
 80255de:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80255e0:	f001 f9a5 	bl	802692e <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80255e4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80255e6:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
 80255ea:	3a01      	subs	r2, #1
 80255ec:	eb03 0782 	add.w	r7, r3, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 80255f0:	f027 0707 	bic.w	r7, r7, #7
	if( pcName != NULL )
 80255f4:	b3a5      	cbz	r5, 8025660 <prvInitialiseNewTask+0x9a>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80255f6:	f04f 0c00 	mov.w	ip, #0
 80255fa:	f1bc 0f0f 	cmp.w	ip, #15
 80255fe:	d809      	bhi.n	8025614 <prvInitialiseNewTask+0x4e>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8025600:	f815 300c 	ldrb.w	r3, [r5, ip]
 8025604:	eb04 020c 	add.w	r2, r4, ip
 8025608:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 802560c:	b113      	cbz	r3, 8025614 <prvInitialiseNewTask+0x4e>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 802560e:	f10c 0c01 	add.w	ip, ip, #1
 8025612:	e7f2      	b.n	80255fa <prvInitialiseNewTask+0x34>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8025614:	2300      	movs	r3, #0
 8025616:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 802561a:	2e06      	cmp	r6, #6
 802561c:	d900      	bls.n	8025620 <prvInitialiseNewTask+0x5a>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 802561e:	2606      	movs	r6, #6
	pxNewTCB->uxPriority = uxPriority;
 8025620:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8025622:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8025624:	2500      	movs	r5, #0
 8025626:	6525      	str	r5, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8025628:	1d20      	adds	r0, r4, #4
 802562a:	f7ff f8c8 	bl	80247be <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 802562e:	f104 0018 	add.w	r0, r4, #24
 8025632:	f7ff f8c4 	bl	80247be <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8025636:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025638:	f1c6 0607 	rsb	r6, r6, #7
 802563c:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 802563e:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulNotifiedValue = 0;
 8025640:	6565      	str	r5, [r4, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8025642:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8025646:	464a      	mov	r2, r9
 8025648:	4641      	mov	r1, r8
 802564a:	4638      	mov	r0, r7
 802564c:	f7ff f930 	bl	80248b0 <pxPortInitialiseStack>
 8025650:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8025652:	f1ba 0f00 	cmp.w	sl, #0
 8025656:	d001      	beq.n	802565c <prvInitialiseNewTask+0x96>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8025658:	f8ca 4000 	str.w	r4, [sl]
}
 802565c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 8025660:	2300      	movs	r3, #0
 8025662:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8025666:	e7d8      	b.n	802561a <prvInitialiseNewTask+0x54>

08025668 <prvInitialiseTaskLists>:
{
 8025668:	b538      	push	{r3, r4, r5, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 802566a:	2400      	movs	r4, #0
 802566c:	e007      	b.n	802567e <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 802566e:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8025672:	0093      	lsls	r3, r2, #2
 8025674:	480e      	ldr	r0, [pc, #56]	; (80256b0 <prvInitialiseTaskLists+0x48>)
 8025676:	4418      	add	r0, r3
 8025678:	f7ff f896 	bl	80247a8 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 802567c:	3401      	adds	r4, #1
 802567e:	2c06      	cmp	r4, #6
 8025680:	d9f5      	bls.n	802566e <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 8025682:	4d0c      	ldr	r5, [pc, #48]	; (80256b4 <prvInitialiseTaskLists+0x4c>)
 8025684:	4628      	mov	r0, r5
 8025686:	f7ff f88f 	bl	80247a8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 802568a:	4c0b      	ldr	r4, [pc, #44]	; (80256b8 <prvInitialiseTaskLists+0x50>)
 802568c:	4620      	mov	r0, r4
 802568e:	f7ff f88b 	bl	80247a8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8025692:	480a      	ldr	r0, [pc, #40]	; (80256bc <prvInitialiseTaskLists+0x54>)
 8025694:	f7ff f888 	bl	80247a8 <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8025698:	4809      	ldr	r0, [pc, #36]	; (80256c0 <prvInitialiseTaskLists+0x58>)
 802569a:	f7ff f885 	bl	80247a8 <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 802569e:	4809      	ldr	r0, [pc, #36]	; (80256c4 <prvInitialiseTaskLists+0x5c>)
 80256a0:	f7ff f882 	bl	80247a8 <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 80256a4:	4b08      	ldr	r3, [pc, #32]	; (80256c8 <prvInitialiseTaskLists+0x60>)
 80256a6:	601d      	str	r5, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 80256a8:	4b08      	ldr	r3, [pc, #32]	; (80256cc <prvInitialiseTaskLists+0x64>)
 80256aa:	601c      	str	r4, [r3, #0]
}
 80256ac:	bd38      	pop	{r3, r4, r5, pc}
 80256ae:	bf00      	nop
 80256b0:	20011c40 	.word	0x20011c40
 80256b4:	20011ce4 	.word	0x20011ce4
 80256b8:	20011cf8 	.word	0x20011cf8
 80256bc:	20011d18 	.word	0x20011d18
 80256c0:	20011d44 	.word	0x20011d44
 80256c4:	20011d30 	.word	0x20011d30
 80256c8:	20011c38 	.word	0x20011c38
 80256cc:	20011c3c 	.word	0x20011c3c

080256d0 <prvAddNewTaskToReadyList>:
{
 80256d0:	b510      	push	{r4, lr}
 80256d2:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 80256d4:	f7ff f916 	bl	8024904 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 80256d8:	4a22      	ldr	r2, [pc, #136]	; (8025764 <prvAddNewTaskToReadyList+0x94>)
 80256da:	6813      	ldr	r3, [r2, #0]
 80256dc:	3301      	adds	r3, #1
 80256de:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 80256e0:	4b21      	ldr	r3, [pc, #132]	; (8025768 <prvAddNewTaskToReadyList+0x98>)
 80256e2:	681b      	ldr	r3, [r3, #0]
 80256e4:	b15b      	cbz	r3, 80256fe <prvAddNewTaskToReadyList+0x2e>
			if( xSchedulerRunning == pdFALSE )
 80256e6:	4b21      	ldr	r3, [pc, #132]	; (802576c <prvAddNewTaskToReadyList+0x9c>)
 80256e8:	681b      	ldr	r3, [r3, #0]
 80256ea:	b96b      	cbnz	r3, 8025708 <prvAddNewTaskToReadyList+0x38>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80256ec:	4b1e      	ldr	r3, [pc, #120]	; (8025768 <prvAddNewTaskToReadyList+0x98>)
 80256ee:	681b      	ldr	r3, [r3, #0]
 80256f0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80256f2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80256f4:	429a      	cmp	r2, r3
 80256f6:	d807      	bhi.n	8025708 <prvAddNewTaskToReadyList+0x38>
					pxCurrentTCB = pxNewTCB;
 80256f8:	4b1b      	ldr	r3, [pc, #108]	; (8025768 <prvAddNewTaskToReadyList+0x98>)
 80256fa:	601c      	str	r4, [r3, #0]
 80256fc:	e004      	b.n	8025708 <prvAddNewTaskToReadyList+0x38>
			pxCurrentTCB = pxNewTCB;
 80256fe:	4b1a      	ldr	r3, [pc, #104]	; (8025768 <prvAddNewTaskToReadyList+0x98>)
 8025700:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8025702:	6813      	ldr	r3, [r2, #0]
 8025704:	2b01      	cmp	r3, #1
 8025706:	d029      	beq.n	802575c <prvAddNewTaskToReadyList+0x8c>
		uxTaskNumber++;
 8025708:	4a19      	ldr	r2, [pc, #100]	; (8025770 <prvAddNewTaskToReadyList+0xa0>)
 802570a:	6813      	ldr	r3, [r2, #0]
 802570c:	3301      	adds	r3, #1
 802570e:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8025710:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8025712:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8025714:	2301      	movs	r3, #1
 8025716:	4083      	lsls	r3, r0
 8025718:	4a16      	ldr	r2, [pc, #88]	; (8025774 <prvAddNewTaskToReadyList+0xa4>)
 802571a:	6811      	ldr	r1, [r2, #0]
 802571c:	430b      	orrs	r3, r1
 802571e:	6013      	str	r3, [r2, #0]
 8025720:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025724:	1d21      	adds	r1, r4, #4
 8025726:	4b14      	ldr	r3, [pc, #80]	; (8025778 <prvAddNewTaskToReadyList+0xa8>)
 8025728:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 802572c:	f7ff f84a 	bl	80247c4 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8025730:	f7ff f90a 	bl	8024948 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8025734:	4b0d      	ldr	r3, [pc, #52]	; (802576c <prvAddNewTaskToReadyList+0x9c>)
 8025736:	681b      	ldr	r3, [r3, #0]
 8025738:	b17b      	cbz	r3, 802575a <prvAddNewTaskToReadyList+0x8a>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 802573a:	4b0b      	ldr	r3, [pc, #44]	; (8025768 <prvAddNewTaskToReadyList+0x98>)
 802573c:	681b      	ldr	r3, [r3, #0]
 802573e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8025740:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8025742:	429a      	cmp	r2, r3
 8025744:	d209      	bcs.n	802575a <prvAddNewTaskToReadyList+0x8a>
			taskYIELD_IF_USING_PREEMPTION();
 8025746:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 802574a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802574e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8025752:	f3bf 8f4f 	dsb	sy
 8025756:	f3bf 8f6f 	isb	sy
}
 802575a:	bd10      	pop	{r4, pc}
				prvInitialiseTaskLists();
 802575c:	f7ff ff84 	bl	8025668 <prvInitialiseTaskLists>
 8025760:	e7d2      	b.n	8025708 <prvAddNewTaskToReadyList+0x38>
 8025762:	bf00      	nop
 8025764:	20011ccc 	.word	0x20011ccc
 8025768:	20011c34 	.word	0x20011c34
 802576c:	20011d2c 	.word	0x20011d2c
 8025770:	20011cdc 	.word	0x20011cdc
 8025774:	20011ce0 	.word	0x20011ce0
 8025778:	20011c40 	.word	0x20011c40

0802577c <prvCheckTasksWaitingTermination>:
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 802577c:	4b0f      	ldr	r3, [pc, #60]	; (80257bc <prvCheckTasksWaitingTermination+0x40>)
 802577e:	681b      	ldr	r3, [r3, #0]
 8025780:	b1d3      	cbz	r3, 80257b8 <prvCheckTasksWaitingTermination+0x3c>
{
 8025782:	b510      	push	{r4, lr}
			taskENTER_CRITICAL();
 8025784:	f7ff f8be 	bl	8024904 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025788:	4b0d      	ldr	r3, [pc, #52]	; (80257c0 <prvCheckTasksWaitingTermination+0x44>)
 802578a:	68db      	ldr	r3, [r3, #12]
 802578c:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 802578e:	1d20      	adds	r0, r4, #4
 8025790:	f7ff f83c 	bl	802480c <uxListRemove>
				--uxCurrentNumberOfTasks;
 8025794:	4a0b      	ldr	r2, [pc, #44]	; (80257c4 <prvCheckTasksWaitingTermination+0x48>)
 8025796:	6813      	ldr	r3, [r2, #0]
 8025798:	3b01      	subs	r3, #1
 802579a:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 802579c:	4a07      	ldr	r2, [pc, #28]	; (80257bc <prvCheckTasksWaitingTermination+0x40>)
 802579e:	6813      	ldr	r3, [r2, #0]
 80257a0:	3b01      	subs	r3, #1
 80257a2:	6013      	str	r3, [r2, #0]
			taskEXIT_CRITICAL();
 80257a4:	f7ff f8d0 	bl	8024948 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 80257a8:	4620      	mov	r0, r4
 80257aa:	f7ff ff03 	bl	80255b4 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80257ae:	4b03      	ldr	r3, [pc, #12]	; (80257bc <prvCheckTasksWaitingTermination+0x40>)
 80257b0:	681b      	ldr	r3, [r3, #0]
 80257b2:	2b00      	cmp	r3, #0
 80257b4:	d1e6      	bne.n	8025784 <prvCheckTasksWaitingTermination+0x8>
}
 80257b6:	bd10      	pop	{r4, pc}
 80257b8:	4770      	bx	lr
 80257ba:	bf00      	nop
 80257bc:	20011cd0 	.word	0x20011cd0
 80257c0:	20011d44 	.word	0x20011d44
 80257c4:	20011ccc 	.word	0x20011ccc

080257c8 <prvIdleTask>:
{
 80257c8:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 80257ca:	f7ff ffd7 	bl	802577c <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80257ce:	4b07      	ldr	r3, [pc, #28]	; (80257ec <prvIdleTask+0x24>)
 80257d0:	681b      	ldr	r3, [r3, #0]
 80257d2:	2b01      	cmp	r3, #1
 80257d4:	d9f9      	bls.n	80257ca <prvIdleTask+0x2>
				taskYIELD();
 80257d6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80257da:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80257de:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80257e2:	f3bf 8f4f 	dsb	sy
 80257e6:	f3bf 8f6f 	isb	sy
 80257ea:	e7ee      	b.n	80257ca <prvIdleTask+0x2>
 80257ec:	20011c40 	.word	0x20011c40

080257f0 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80257f0:	b570      	push	{r4, r5, r6, lr}
 80257f2:	4604      	mov	r4, r0
 80257f4:	460d      	mov	r5, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80257f6:	4b1d      	ldr	r3, [pc, #116]	; (802586c <prvAddCurrentTaskToDelayedList+0x7c>)
 80257f8:	681e      	ldr	r6, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80257fa:	4b1d      	ldr	r3, [pc, #116]	; (8025870 <prvAddCurrentTaskToDelayedList+0x80>)
 80257fc:	6818      	ldr	r0, [r3, #0]
 80257fe:	3004      	adds	r0, #4
 8025800:	f7ff f804 	bl	802480c <uxListRemove>
 8025804:	b948      	cbnz	r0, 802581a <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 8025806:	4b1a      	ldr	r3, [pc, #104]	; (8025870 <prvAddCurrentTaskToDelayedList+0x80>)
 8025808:	681b      	ldr	r3, [r3, #0]
 802580a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 802580c:	2201      	movs	r2, #1
 802580e:	409a      	lsls	r2, r3
 8025810:	4918      	ldr	r1, [pc, #96]	; (8025874 <prvAddCurrentTaskToDelayedList+0x84>)
 8025812:	680b      	ldr	r3, [r1, #0]
 8025814:	ea23 0302 	bic.w	r3, r3, r2
 8025818:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 802581a:	f1b4 3fff 	cmp.w	r4, #4294967295
 802581e:	d00d      	beq.n	802583c <prvAddCurrentTaskToDelayedList+0x4c>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8025820:	4434      	add	r4, r6

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8025822:	4b13      	ldr	r3, [pc, #76]	; (8025870 <prvAddCurrentTaskToDelayedList+0x80>)
 8025824:	681b      	ldr	r3, [r3, #0]
 8025826:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8025828:	42a6      	cmp	r6, r4
 802582a:	d910      	bls.n	802584e <prvAddCurrentTaskToDelayedList+0x5e>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 802582c:	4b12      	ldr	r3, [pc, #72]	; (8025878 <prvAddCurrentTaskToDelayedList+0x88>)
 802582e:	6818      	ldr	r0, [r3, #0]
 8025830:	4b0f      	ldr	r3, [pc, #60]	; (8025870 <prvAddCurrentTaskToDelayedList+0x80>)
 8025832:	6819      	ldr	r1, [r3, #0]
 8025834:	3104      	adds	r1, #4
 8025836:	f7fe ffd0 	bl	80247da <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 802583a:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 802583c:	2d00      	cmp	r5, #0
 802583e:	d0ef      	beq.n	8025820 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8025840:	4b0b      	ldr	r3, [pc, #44]	; (8025870 <prvAddCurrentTaskToDelayedList+0x80>)
 8025842:	6819      	ldr	r1, [r3, #0]
 8025844:	3104      	adds	r1, #4
 8025846:	480d      	ldr	r0, [pc, #52]	; (802587c <prvAddCurrentTaskToDelayedList+0x8c>)
 8025848:	f7fe ffbc 	bl	80247c4 <vListInsertEnd>
 802584c:	e7f5      	b.n	802583a <prvAddCurrentTaskToDelayedList+0x4a>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 802584e:	4b0c      	ldr	r3, [pc, #48]	; (8025880 <prvAddCurrentTaskToDelayedList+0x90>)
 8025850:	6818      	ldr	r0, [r3, #0]
 8025852:	4b07      	ldr	r3, [pc, #28]	; (8025870 <prvAddCurrentTaskToDelayedList+0x80>)
 8025854:	6819      	ldr	r1, [r3, #0]
 8025856:	3104      	adds	r1, #4
 8025858:	f7fe ffbf 	bl	80247da <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 802585c:	4b09      	ldr	r3, [pc, #36]	; (8025884 <prvAddCurrentTaskToDelayedList+0x94>)
 802585e:	681b      	ldr	r3, [r3, #0]
 8025860:	42a3      	cmp	r3, r4
 8025862:	d9ea      	bls.n	802583a <prvAddCurrentTaskToDelayedList+0x4a>
					xNextTaskUnblockTime = xTimeToWake;
 8025864:	4b07      	ldr	r3, [pc, #28]	; (8025884 <prvAddCurrentTaskToDelayedList+0x94>)
 8025866:	601c      	str	r4, [r3, #0]
}
 8025868:	e7e7      	b.n	802583a <prvAddCurrentTaskToDelayedList+0x4a>
 802586a:	bf00      	nop
 802586c:	20011d58 	.word	0x20011d58
 8025870:	20011c34 	.word	0x20011c34
 8025874:	20011ce0 	.word	0x20011ce0
 8025878:	20011c3c 	.word	0x20011c3c
 802587c:	20011d30 	.word	0x20011d30
 8025880:	20011c38 	.word	0x20011c38
 8025884:	20011d10 	.word	0x20011d10

08025888 <xTaskCreate>:
	{
 8025888:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 802588c:	b085      	sub	sp, #20
 802588e:	4607      	mov	r7, r0
 8025890:	4688      	mov	r8, r1
 8025892:	4614      	mov	r4, r2
 8025894:	461e      	mov	r6, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8025896:	0090      	lsls	r0, r2, #2
 8025898:	f7fe fed6 	bl	8024648 <pvPortMalloc>
			if( pxStack != NULL )
 802589c:	b1f0      	cbz	r0, 80258dc <xTaskCreate+0x54>
 802589e:	4681      	mov	r9, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 80258a0:	205c      	movs	r0, #92	; 0x5c
 80258a2:	f7fe fed1 	bl	8024648 <pvPortMalloc>
				if( pxNewTCB != NULL )
 80258a6:	4605      	mov	r5, r0
 80258a8:	b1a0      	cbz	r0, 80258d4 <xTaskCreate+0x4c>
					pxNewTCB->pxStack = pxStack;
 80258aa:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
 80258ae:	b1d5      	cbz	r5, 80258e6 <xTaskCreate+0x5e>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 80258b0:	2300      	movs	r3, #0
 80258b2:	9303      	str	r3, [sp, #12]
 80258b4:	9502      	str	r5, [sp, #8]
 80258b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80258b8:	9301      	str	r3, [sp, #4]
 80258ba:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80258bc:	9300      	str	r3, [sp, #0]
 80258be:	4633      	mov	r3, r6
 80258c0:	4622      	mov	r2, r4
 80258c2:	4641      	mov	r1, r8
 80258c4:	4638      	mov	r0, r7
 80258c6:	f7ff fe7e 	bl	80255c6 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 80258ca:	4628      	mov	r0, r5
 80258cc:	f7ff ff00 	bl	80256d0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 80258d0:	2001      	movs	r0, #1
 80258d2:	e005      	b.n	80258e0 <xTaskCreate+0x58>
					vPortFree( pxStack );
 80258d4:	4648      	mov	r0, r9
 80258d6:	f7fe ff2f 	bl	8024738 <vPortFree>
 80258da:	e7e8      	b.n	80258ae <xTaskCreate+0x26>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80258dc:	f04f 30ff 	mov.w	r0, #4294967295
	}
 80258e0:	b005      	add	sp, #20
 80258e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80258e6:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 80258ea:	e7f9      	b.n	80258e0 <xTaskCreate+0x58>

080258ec <vTaskDelete>:
	{
 80258ec:	b538      	push	{r3, r4, r5, lr}
 80258ee:	4604      	mov	r4, r0
		taskENTER_CRITICAL();
 80258f0:	f7ff f808 	bl	8024904 <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80258f4:	2c00      	cmp	r4, #0
 80258f6:	d034      	beq.n	8025962 <vTaskDelete+0x76>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80258f8:	1d25      	adds	r5, r4, #4
 80258fa:	4628      	mov	r0, r5
 80258fc:	f7fe ff86 	bl	802480c <uxListRemove>
 8025900:	b970      	cbnz	r0, 8025920 <vTaskDelete+0x34>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8025902:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8025904:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8025908:	009b      	lsls	r3, r3, #2
 802590a:	4927      	ldr	r1, [pc, #156]	; (80259a8 <vTaskDelete+0xbc>)
 802590c:	58cb      	ldr	r3, [r1, r3]
 802590e:	b93b      	cbnz	r3, 8025920 <vTaskDelete+0x34>
 8025910:	2301      	movs	r3, #1
 8025912:	fa03 f202 	lsl.w	r2, r3, r2
 8025916:	4925      	ldr	r1, [pc, #148]	; (80259ac <vTaskDelete+0xc0>)
 8025918:	680b      	ldr	r3, [r1, #0]
 802591a:	ea23 0302 	bic.w	r3, r3, r2
 802591e:	600b      	str	r3, [r1, #0]
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8025920:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8025922:	b11b      	cbz	r3, 802592c <vTaskDelete+0x40>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8025924:	f104 0018 	add.w	r0, r4, #24
 8025928:	f7fe ff70 	bl	802480c <uxListRemove>
			uxTaskNumber++;
 802592c:	4a20      	ldr	r2, [pc, #128]	; (80259b0 <vTaskDelete+0xc4>)
 802592e:	6813      	ldr	r3, [r2, #0]
 8025930:	3301      	adds	r3, #1
 8025932:	6013      	str	r3, [r2, #0]
			if( pxTCB == pxCurrentTCB )
 8025934:	4b1f      	ldr	r3, [pc, #124]	; (80259b4 <vTaskDelete+0xc8>)
 8025936:	681b      	ldr	r3, [r3, #0]
 8025938:	42a3      	cmp	r3, r4
 802593a:	d015      	beq.n	8025968 <vTaskDelete+0x7c>
				--uxCurrentNumberOfTasks;
 802593c:	4a1e      	ldr	r2, [pc, #120]	; (80259b8 <vTaskDelete+0xcc>)
 802593e:	6813      	ldr	r3, [r2, #0]
 8025940:	3b01      	subs	r3, #1
 8025942:	6013      	str	r3, [r2, #0]
				prvDeleteTCB( pxTCB );
 8025944:	4620      	mov	r0, r4
 8025946:	f7ff fe35 	bl	80255b4 <prvDeleteTCB>
				prvResetNextTaskUnblockTime();
 802594a:	f7ff fe1d 	bl	8025588 <prvResetNextTaskUnblockTime>
		taskEXIT_CRITICAL();
 802594e:	f7fe fffb 	bl	8024948 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
 8025952:	4b1a      	ldr	r3, [pc, #104]	; (80259bc <vTaskDelete+0xd0>)
 8025954:	681b      	ldr	r3, [r3, #0]
 8025956:	b11b      	cbz	r3, 8025960 <vTaskDelete+0x74>
			if( pxTCB == pxCurrentTCB )
 8025958:	4b16      	ldr	r3, [pc, #88]	; (80259b4 <vTaskDelete+0xc8>)
 802595a:	681b      	ldr	r3, [r3, #0]
 802595c:	42a3      	cmp	r3, r4
 802595e:	d00c      	beq.n	802597a <vTaskDelete+0x8e>
	}
 8025960:	bd38      	pop	{r3, r4, r5, pc}
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 8025962:	4b14      	ldr	r3, [pc, #80]	; (80259b4 <vTaskDelete+0xc8>)
 8025964:	681c      	ldr	r4, [r3, #0]
 8025966:	e7c7      	b.n	80258f8 <vTaskDelete+0xc>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 8025968:	4629      	mov	r1, r5
 802596a:	4815      	ldr	r0, [pc, #84]	; (80259c0 <vTaskDelete+0xd4>)
 802596c:	f7fe ff2a 	bl	80247c4 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
 8025970:	4a14      	ldr	r2, [pc, #80]	; (80259c4 <vTaskDelete+0xd8>)
 8025972:	6813      	ldr	r3, [r2, #0]
 8025974:	3301      	adds	r3, #1
 8025976:	6013      	str	r3, [r2, #0]
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
 8025978:	e7e9      	b.n	802594e <vTaskDelete+0x62>
				configASSERT( uxSchedulerSuspended == 0 );
 802597a:	4b13      	ldr	r3, [pc, #76]	; (80259c8 <vTaskDelete+0xdc>)
 802597c:	681b      	ldr	r3, [r3, #0]
 802597e:	b143      	cbz	r3, 8025992 <vTaskDelete+0xa6>
 8025980:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025984:	f383 8811 	msr	BASEPRI, r3
 8025988:	f3bf 8f6f 	isb	sy
 802598c:	f3bf 8f4f 	dsb	sy
 8025990:	e7fe      	b.n	8025990 <vTaskDelete+0xa4>
				portYIELD_WITHIN_API();
 8025992:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8025996:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 802599a:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 802599e:	f3bf 8f4f 	dsb	sy
 80259a2:	f3bf 8f6f 	isb	sy
	}
 80259a6:	e7db      	b.n	8025960 <vTaskDelete+0x74>
 80259a8:	20011c40 	.word	0x20011c40
 80259ac:	20011ce0 	.word	0x20011ce0
 80259b0:	20011cdc 	.word	0x20011cdc
 80259b4:	20011c34 	.word	0x20011c34
 80259b8:	20011ccc 	.word	0x20011ccc
 80259bc:	20011d2c 	.word	0x20011d2c
 80259c0:	20011d44 	.word	0x20011d44
 80259c4:	20011cd0 	.word	0x20011cd0
 80259c8:	20011cd8 	.word	0x20011cd8

080259cc <vTaskStartScheduler>:
{
 80259cc:	b500      	push	{lr}
 80259ce:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 80259d0:	4b19      	ldr	r3, [pc, #100]	; (8025a38 <vTaskStartScheduler+0x6c>)
 80259d2:	9301      	str	r3, [sp, #4]
 80259d4:	2300      	movs	r3, #0
 80259d6:	9300      	str	r3, [sp, #0]
 80259d8:	2280      	movs	r2, #128	; 0x80
 80259da:	4918      	ldr	r1, [pc, #96]	; (8025a3c <vTaskStartScheduler+0x70>)
 80259dc:	4818      	ldr	r0, [pc, #96]	; (8025a40 <vTaskStartScheduler+0x74>)
 80259de:	f7ff ff53 	bl	8025888 <xTaskCreate>
		if( xReturn == pdPASS )
 80259e2:	2801      	cmp	r0, #1
 80259e4:	d007      	beq.n	80259f6 <vTaskStartScheduler+0x2a>
	if( xReturn == pdPASS )
 80259e6:	2801      	cmp	r0, #1
 80259e8:	d008      	beq.n	80259fc <vTaskStartScheduler+0x30>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80259ea:	f1b0 3fff 	cmp.w	r0, #4294967295
 80259ee:	d01a      	beq.n	8025a26 <vTaskStartScheduler+0x5a>
}
 80259f0:	b003      	add	sp, #12
 80259f2:	f85d fb04 	ldr.w	pc, [sp], #4
			xReturn = xTimerCreateTimerTask();
 80259f6:	f000 fc43 	bl	8026280 <xTimerCreateTimerTask>
 80259fa:	e7f4      	b.n	80259e6 <vTaskStartScheduler+0x1a>
 80259fc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025a00:	f383 8811 	msr	BASEPRI, r3
 8025a04:	f3bf 8f6f 	isb	sy
 8025a08:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8025a0c:	4b0d      	ldr	r3, [pc, #52]	; (8025a44 <vTaskStartScheduler+0x78>)
 8025a0e:	f04f 32ff 	mov.w	r2, #4294967295
 8025a12:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8025a14:	4b0c      	ldr	r3, [pc, #48]	; (8025a48 <vTaskStartScheduler+0x7c>)
 8025a16:	2201      	movs	r2, #1
 8025a18:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8025a1a:	4b0c      	ldr	r3, [pc, #48]	; (8025a4c <vTaskStartScheduler+0x80>)
 8025a1c:	2200      	movs	r2, #0
 8025a1e:	601a      	str	r2, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8025a20:	f7ff f80a 	bl	8024a38 <xPortStartScheduler>
 8025a24:	e7e4      	b.n	80259f0 <vTaskStartScheduler+0x24>
 8025a26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025a2a:	f383 8811 	msr	BASEPRI, r3
 8025a2e:	f3bf 8f6f 	isb	sy
 8025a32:	f3bf 8f4f 	dsb	sy
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8025a36:	e7fe      	b.n	8025a36 <vTaskStartScheduler+0x6a>
 8025a38:	20011d0c 	.word	0x20011d0c
 8025a3c:	0803742c 	.word	0x0803742c
 8025a40:	080257c9 	.word	0x080257c9
 8025a44:	20011d10 	.word	0x20011d10
 8025a48:	20011d2c 	.word	0x20011d2c
 8025a4c:	20011d58 	.word	0x20011d58

08025a50 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8025a50:	4a02      	ldr	r2, [pc, #8]	; (8025a5c <vTaskSuspendAll+0xc>)
 8025a52:	6813      	ldr	r3, [r2, #0]
 8025a54:	3301      	adds	r3, #1
 8025a56:	6013      	str	r3, [r2, #0]
}
 8025a58:	4770      	bx	lr
 8025a5a:	bf00      	nop
 8025a5c:	20011cd8 	.word	0x20011cd8

08025a60 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8025a60:	4b01      	ldr	r3, [pc, #4]	; (8025a68 <xTaskGetTickCount+0x8>)
 8025a62:	6818      	ldr	r0, [r3, #0]
}
 8025a64:	4770      	bx	lr
 8025a66:	bf00      	nop
 8025a68:	20011d58 	.word	0x20011d58

08025a6c <xTaskGetTickCountFromISR>:
{
 8025a6c:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8025a6e:	f7ff f86f 	bl	8024b50 <vPortValidateInterruptPriority>
		xReturn = xTickCount;
 8025a72:	4b01      	ldr	r3, [pc, #4]	; (8025a78 <xTaskGetTickCountFromISR+0xc>)
 8025a74:	6818      	ldr	r0, [r3, #0]
}
 8025a76:	bd08      	pop	{r3, pc}
 8025a78:	20011d58 	.word	0x20011d58

08025a7c <xTaskIncrementTick>:
{
 8025a7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8025a7e:	4b3a      	ldr	r3, [pc, #232]	; (8025b68 <xTaskIncrementTick+0xec>)
 8025a80:	681b      	ldr	r3, [r3, #0]
 8025a82:	2b00      	cmp	r3, #0
 8025a84:	d164      	bne.n	8025b50 <xTaskIncrementTick+0xd4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8025a86:	4b39      	ldr	r3, [pc, #228]	; (8025b6c <xTaskIncrementTick+0xf0>)
 8025a88:	681d      	ldr	r5, [r3, #0]
 8025a8a:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 8025a8c:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8025a8e:	b9c5      	cbnz	r5, 8025ac2 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8025a90:	4b37      	ldr	r3, [pc, #220]	; (8025b70 <xTaskIncrementTick+0xf4>)
 8025a92:	681b      	ldr	r3, [r3, #0]
 8025a94:	681b      	ldr	r3, [r3, #0]
 8025a96:	b143      	cbz	r3, 8025aaa <xTaskIncrementTick+0x2e>
 8025a98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025a9c:	f383 8811 	msr	BASEPRI, r3
 8025aa0:	f3bf 8f6f 	isb	sy
 8025aa4:	f3bf 8f4f 	dsb	sy
 8025aa8:	e7fe      	b.n	8025aa8 <xTaskIncrementTick+0x2c>
 8025aaa:	4a31      	ldr	r2, [pc, #196]	; (8025b70 <xTaskIncrementTick+0xf4>)
 8025aac:	6811      	ldr	r1, [r2, #0]
 8025aae:	4b31      	ldr	r3, [pc, #196]	; (8025b74 <xTaskIncrementTick+0xf8>)
 8025ab0:	6818      	ldr	r0, [r3, #0]
 8025ab2:	6010      	str	r0, [r2, #0]
 8025ab4:	6019      	str	r1, [r3, #0]
 8025ab6:	4a30      	ldr	r2, [pc, #192]	; (8025b78 <xTaskIncrementTick+0xfc>)
 8025ab8:	6813      	ldr	r3, [r2, #0]
 8025aba:	3301      	adds	r3, #1
 8025abc:	6013      	str	r3, [r2, #0]
 8025abe:	f7ff fd63 	bl	8025588 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8025ac2:	4b2e      	ldr	r3, [pc, #184]	; (8025b7c <xTaskIncrementTick+0x100>)
 8025ac4:	681b      	ldr	r3, [r3, #0]
 8025ac6:	42ab      	cmp	r3, r5
 8025ac8:	d938      	bls.n	8025b3c <xTaskIncrementTick+0xc0>
BaseType_t xSwitchRequired = pdFALSE;
 8025aca:	2700      	movs	r7, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8025acc:	4b2c      	ldr	r3, [pc, #176]	; (8025b80 <xTaskIncrementTick+0x104>)
 8025ace:	681b      	ldr	r3, [r3, #0]
 8025ad0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025ad2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8025ad6:	009a      	lsls	r2, r3, #2
 8025ad8:	4b2a      	ldr	r3, [pc, #168]	; (8025b84 <xTaskIncrementTick+0x108>)
 8025ada:	589b      	ldr	r3, [r3, r2]
 8025adc:	2b01      	cmp	r3, #1
 8025ade:	d93c      	bls.n	8025b5a <xTaskIncrementTick+0xde>
				xSwitchRequired = pdTRUE;
 8025ae0:	2701      	movs	r7, #1
 8025ae2:	e03a      	b.n	8025b5a <xTaskIncrementTick+0xde>
							xSwitchRequired = pdTRUE;
 8025ae4:	2701      	movs	r7, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8025ae6:	4b22      	ldr	r3, [pc, #136]	; (8025b70 <xTaskIncrementTick+0xf4>)
 8025ae8:	681b      	ldr	r3, [r3, #0]
 8025aea:	681b      	ldr	r3, [r3, #0]
 8025aec:	b343      	cbz	r3, 8025b40 <xTaskIncrementTick+0xc4>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025aee:	4b20      	ldr	r3, [pc, #128]	; (8025b70 <xTaskIncrementTick+0xf4>)
 8025af0:	681b      	ldr	r3, [r3, #0]
 8025af2:	68db      	ldr	r3, [r3, #12]
 8025af4:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8025af6:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
 8025af8:	429d      	cmp	r5, r3
 8025afa:	d326      	bcc.n	8025b4a <xTaskIncrementTick+0xce>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8025afc:	1d26      	adds	r6, r4, #4
 8025afe:	4630      	mov	r0, r6
 8025b00:	f7fe fe84 	bl	802480c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8025b04:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8025b06:	b11b      	cbz	r3, 8025b10 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8025b08:	f104 0018 	add.w	r0, r4, #24
 8025b0c:	f7fe fe7e 	bl	802480c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8025b10:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8025b12:	2201      	movs	r2, #1
 8025b14:	409a      	lsls	r2, r3
 8025b16:	491c      	ldr	r1, [pc, #112]	; (8025b88 <xTaskIncrementTick+0x10c>)
 8025b18:	6808      	ldr	r0, [r1, #0]
 8025b1a:	4302      	orrs	r2, r0
 8025b1c:	600a      	str	r2, [r1, #0]
 8025b1e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8025b22:	009a      	lsls	r2, r3, #2
 8025b24:	4631      	mov	r1, r6
 8025b26:	4817      	ldr	r0, [pc, #92]	; (8025b84 <xTaskIncrementTick+0x108>)
 8025b28:	4410      	add	r0, r2
 8025b2a:	f7fe fe4b 	bl	80247c4 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8025b2e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8025b30:	4b13      	ldr	r3, [pc, #76]	; (8025b80 <xTaskIncrementTick+0x104>)
 8025b32:	681b      	ldr	r3, [r3, #0]
 8025b34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025b36:	429a      	cmp	r2, r3
 8025b38:	d2d4      	bcs.n	8025ae4 <xTaskIncrementTick+0x68>
 8025b3a:	e7d4      	b.n	8025ae6 <xTaskIncrementTick+0x6a>
BaseType_t xSwitchRequired = pdFALSE;
 8025b3c:	2700      	movs	r7, #0
 8025b3e:	e7d2      	b.n	8025ae6 <xTaskIncrementTick+0x6a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025b40:	4b0e      	ldr	r3, [pc, #56]	; (8025b7c <xTaskIncrementTick+0x100>)
 8025b42:	f04f 32ff 	mov.w	r2, #4294967295
 8025b46:	601a      	str	r2, [r3, #0]
					break;
 8025b48:	e7c0      	b.n	8025acc <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 8025b4a:	4a0c      	ldr	r2, [pc, #48]	; (8025b7c <xTaskIncrementTick+0x100>)
 8025b4c:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8025b4e:	e7bd      	b.n	8025acc <xTaskIncrementTick+0x50>
		++uxPendedTicks;
 8025b50:	4a0e      	ldr	r2, [pc, #56]	; (8025b8c <xTaskIncrementTick+0x110>)
 8025b52:	6813      	ldr	r3, [r2, #0]
 8025b54:	3301      	adds	r3, #1
 8025b56:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8025b58:	2700      	movs	r7, #0
		if( xYieldPending != pdFALSE )
 8025b5a:	4b0d      	ldr	r3, [pc, #52]	; (8025b90 <xTaskIncrementTick+0x114>)
 8025b5c:	681b      	ldr	r3, [r3, #0]
 8025b5e:	b103      	cbz	r3, 8025b62 <xTaskIncrementTick+0xe6>
			xSwitchRequired = pdTRUE;
 8025b60:	2701      	movs	r7, #1
}
 8025b62:	4638      	mov	r0, r7
 8025b64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8025b66:	bf00      	nop
 8025b68:	20011cd8 	.word	0x20011cd8
 8025b6c:	20011d58 	.word	0x20011d58
 8025b70:	20011c38 	.word	0x20011c38
 8025b74:	20011c3c 	.word	0x20011c3c
 8025b78:	20011d14 	.word	0x20011d14
 8025b7c:	20011d10 	.word	0x20011d10
 8025b80:	20011c34 	.word	0x20011c34
 8025b84:	20011c40 	.word	0x20011c40
 8025b88:	20011ce0 	.word	0x20011ce0
 8025b8c:	20011cd4 	.word	0x20011cd4
 8025b90:	20011d5c 	.word	0x20011d5c

08025b94 <xTaskResumeAll>:
{
 8025b94:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended );
 8025b96:	4b35      	ldr	r3, [pc, #212]	; (8025c6c <xTaskResumeAll+0xd8>)
 8025b98:	681b      	ldr	r3, [r3, #0]
 8025b9a:	b943      	cbnz	r3, 8025bae <xTaskResumeAll+0x1a>
 8025b9c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025ba0:	f383 8811 	msr	BASEPRI, r3
 8025ba4:	f3bf 8f6f 	isb	sy
 8025ba8:	f3bf 8f4f 	dsb	sy
 8025bac:	e7fe      	b.n	8025bac <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
 8025bae:	f7fe fea9 	bl	8024904 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8025bb2:	4b2e      	ldr	r3, [pc, #184]	; (8025c6c <xTaskResumeAll+0xd8>)
 8025bb4:	681a      	ldr	r2, [r3, #0]
 8025bb6:	3a01      	subs	r2, #1
 8025bb8:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8025bba:	681b      	ldr	r3, [r3, #0]
 8025bbc:	2b00      	cmp	r3, #0
 8025bbe:	d14f      	bne.n	8025c60 <xTaskResumeAll+0xcc>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8025bc0:	4b2b      	ldr	r3, [pc, #172]	; (8025c70 <xTaskResumeAll+0xdc>)
 8025bc2:	681b      	ldr	r3, [r3, #0]
 8025bc4:	b90b      	cbnz	r3, 8025bca <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 8025bc6:	2400      	movs	r4, #0
 8025bc8:	e04b      	b.n	8025c62 <xTaskResumeAll+0xce>
TCB_t *pxTCB = NULL;
 8025bca:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8025bcc:	4b29      	ldr	r3, [pc, #164]	; (8025c74 <xTaskResumeAll+0xe0>)
 8025bce:	681b      	ldr	r3, [r3, #0]
 8025bd0:	b31b      	cbz	r3, 8025c1a <xTaskResumeAll+0x86>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025bd2:	4b28      	ldr	r3, [pc, #160]	; (8025c74 <xTaskResumeAll+0xe0>)
 8025bd4:	68db      	ldr	r3, [r3, #12]
 8025bd6:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8025bd8:	f104 0018 	add.w	r0, r4, #24
 8025bdc:	f7fe fe16 	bl	802480c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8025be0:	1d25      	adds	r5, r4, #4
 8025be2:	4628      	mov	r0, r5
 8025be4:	f7fe fe12 	bl	802480c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8025be8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8025bea:	2301      	movs	r3, #1
 8025bec:	4083      	lsls	r3, r0
 8025bee:	4a22      	ldr	r2, [pc, #136]	; (8025c78 <xTaskResumeAll+0xe4>)
 8025bf0:	6811      	ldr	r1, [r2, #0]
 8025bf2:	430b      	orrs	r3, r1
 8025bf4:	6013      	str	r3, [r2, #0]
 8025bf6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025bfa:	4629      	mov	r1, r5
 8025bfc:	4b1f      	ldr	r3, [pc, #124]	; (8025c7c <xTaskResumeAll+0xe8>)
 8025bfe:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8025c02:	f7fe fddf 	bl	80247c4 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8025c06:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8025c08:	4b1d      	ldr	r3, [pc, #116]	; (8025c80 <xTaskResumeAll+0xec>)
 8025c0a:	681b      	ldr	r3, [r3, #0]
 8025c0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025c0e:	429a      	cmp	r2, r3
 8025c10:	d3dc      	bcc.n	8025bcc <xTaskResumeAll+0x38>
						xYieldPending = pdTRUE;
 8025c12:	4b1c      	ldr	r3, [pc, #112]	; (8025c84 <xTaskResumeAll+0xf0>)
 8025c14:	2201      	movs	r2, #1
 8025c16:	601a      	str	r2, [r3, #0]
 8025c18:	e7d8      	b.n	8025bcc <xTaskResumeAll+0x38>
				if( pxTCB != NULL )
 8025c1a:	b10c      	cbz	r4, 8025c20 <xTaskResumeAll+0x8c>
					prvResetNextTaskUnblockTime();
 8025c1c:	f7ff fcb4 	bl	8025588 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8025c20:	4b19      	ldr	r3, [pc, #100]	; (8025c88 <xTaskResumeAll+0xf4>)
 8025c22:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8025c24:	b984      	cbnz	r4, 8025c48 <xTaskResumeAll+0xb4>
				if( xYieldPending != pdFALSE )
 8025c26:	4b17      	ldr	r3, [pc, #92]	; (8025c84 <xTaskResumeAll+0xf0>)
 8025c28:	681c      	ldr	r4, [r3, #0]
 8025c2a:	b1d4      	cbz	r4, 8025c62 <xTaskResumeAll+0xce>
					taskYIELD_IF_USING_PREEMPTION();
 8025c2c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8025c30:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025c34:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8025c38:	f3bf 8f4f 	dsb	sy
 8025c3c:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8025c40:	2401      	movs	r4, #1
 8025c42:	e00e      	b.n	8025c62 <xTaskResumeAll+0xce>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8025c44:	3c01      	subs	r4, #1
 8025c46:	d007      	beq.n	8025c58 <xTaskResumeAll+0xc4>
							if( xTaskIncrementTick() != pdFALSE )
 8025c48:	f7ff ff18 	bl	8025a7c <xTaskIncrementTick>
 8025c4c:	2800      	cmp	r0, #0
 8025c4e:	d0f9      	beq.n	8025c44 <xTaskResumeAll+0xb0>
								xYieldPending = pdTRUE;
 8025c50:	4b0c      	ldr	r3, [pc, #48]	; (8025c84 <xTaskResumeAll+0xf0>)
 8025c52:	2201      	movs	r2, #1
 8025c54:	601a      	str	r2, [r3, #0]
 8025c56:	e7f5      	b.n	8025c44 <xTaskResumeAll+0xb0>
						uxPendedTicks = 0;
 8025c58:	4b0b      	ldr	r3, [pc, #44]	; (8025c88 <xTaskResumeAll+0xf4>)
 8025c5a:	2200      	movs	r2, #0
 8025c5c:	601a      	str	r2, [r3, #0]
 8025c5e:	e7e2      	b.n	8025c26 <xTaskResumeAll+0x92>
BaseType_t xAlreadyYielded = pdFALSE;
 8025c60:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8025c62:	f7fe fe71 	bl	8024948 <vPortExitCritical>
}
 8025c66:	4620      	mov	r0, r4
 8025c68:	bd38      	pop	{r3, r4, r5, pc}
 8025c6a:	bf00      	nop
 8025c6c:	20011cd8 	.word	0x20011cd8
 8025c70:	20011ccc 	.word	0x20011ccc
 8025c74:	20011d18 	.word	0x20011d18
 8025c78:	20011ce0 	.word	0x20011ce0
 8025c7c:	20011c40 	.word	0x20011c40
 8025c80:	20011c34 	.word	0x20011c34
 8025c84:	20011d5c 	.word	0x20011d5c
 8025c88:	20011cd4 	.word	0x20011cd4

08025c8c <vTaskDelay>:
	{
 8025c8c:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8025c8e:	b1a8      	cbz	r0, 8025cbc <vTaskDelay+0x30>
 8025c90:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 8025c92:	4b10      	ldr	r3, [pc, #64]	; (8025cd4 <vTaskDelay+0x48>)
 8025c94:	681b      	ldr	r3, [r3, #0]
 8025c96:	b143      	cbz	r3, 8025caa <vTaskDelay+0x1e>
 8025c98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025c9c:	f383 8811 	msr	BASEPRI, r3
 8025ca0:	f3bf 8f6f 	isb	sy
 8025ca4:	f3bf 8f4f 	dsb	sy
 8025ca8:	e7fe      	b.n	8025ca8 <vTaskDelay+0x1c>
			vTaskSuspendAll();
 8025caa:	f7ff fed1 	bl	8025a50 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8025cae:	2100      	movs	r1, #0
 8025cb0:	4620      	mov	r0, r4
 8025cb2:	f7ff fd9d 	bl	80257f0 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8025cb6:	f7ff ff6d 	bl	8025b94 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8025cba:	b948      	cbnz	r0, 8025cd0 <vTaskDelay+0x44>
			portYIELD_WITHIN_API();
 8025cbc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8025cc0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8025cc4:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8025cc8:	f3bf 8f4f 	dsb	sy
 8025ccc:	f3bf 8f6f 	isb	sy
	}
 8025cd0:	bd10      	pop	{r4, pc}
 8025cd2:	bf00      	nop
 8025cd4:	20011cd8 	.word	0x20011cd8

08025cd8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8025cd8:	4b20      	ldr	r3, [pc, #128]	; (8025d5c <vTaskSwitchContext+0x84>)
 8025cda:	681b      	ldr	r3, [r3, #0]
 8025cdc:	b11b      	cbz	r3, 8025ce6 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8025cde:	4b20      	ldr	r3, [pc, #128]	; (8025d60 <vTaskSwitchContext+0x88>)
 8025ce0:	2201      	movs	r2, #1
 8025ce2:	601a      	str	r2, [r3, #0]
 8025ce4:	4770      	bx	lr
		xYieldPending = pdFALSE;
 8025ce6:	4b1e      	ldr	r3, [pc, #120]	; (8025d60 <vTaskSwitchContext+0x88>)
 8025ce8:	2200      	movs	r2, #0
 8025cea:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025cec:	4b1d      	ldr	r3, [pc, #116]	; (8025d64 <vTaskSwitchContext+0x8c>)
 8025cee:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8025cf0:	fab3 f383 	clz	r3, r3
 8025cf4:	b2db      	uxtb	r3, r3
 8025cf6:	f1c3 031f 	rsb	r3, r3, #31
 8025cfa:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8025cfe:	008a      	lsls	r2, r1, #2
 8025d00:	4919      	ldr	r1, [pc, #100]	; (8025d68 <vTaskSwitchContext+0x90>)
 8025d02:	588a      	ldr	r2, [r1, r2]
 8025d04:	b942      	cbnz	r2, 8025d18 <vTaskSwitchContext+0x40>
	__asm volatile
 8025d06:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025d0a:	f383 8811 	msr	BASEPRI, r3
 8025d0e:	f3bf 8f6f 	isb	sy
 8025d12:	f3bf 8f4f 	dsb	sy
 8025d16:	e7fe      	b.n	8025d16 <vTaskSwitchContext+0x3e>
 8025d18:	4913      	ldr	r1, [pc, #76]	; (8025d68 <vTaskSwitchContext+0x90>)
 8025d1a:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 8025d1e:	0082      	lsls	r2, r0, #2
 8025d20:	440a      	add	r2, r1
 8025d22:	6850      	ldr	r0, [r2, #4]
 8025d24:	6840      	ldr	r0, [r0, #4]
 8025d26:	6050      	str	r0, [r2, #4]
 8025d28:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 8025d2c:	ea4f 028c 	mov.w	r2, ip, lsl #2
 8025d30:	3208      	adds	r2, #8
 8025d32:	4411      	add	r1, r2
 8025d34:	4288      	cmp	r0, r1
 8025d36:	d009      	beq.n	8025d4c <vTaskSwitchContext+0x74>
 8025d38:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8025d3c:	009a      	lsls	r2, r3, #2
 8025d3e:	4b0a      	ldr	r3, [pc, #40]	; (8025d68 <vTaskSwitchContext+0x90>)
 8025d40:	4413      	add	r3, r2
 8025d42:	685b      	ldr	r3, [r3, #4]
 8025d44:	68da      	ldr	r2, [r3, #12]
 8025d46:	4b09      	ldr	r3, [pc, #36]	; (8025d6c <vTaskSwitchContext+0x94>)
 8025d48:	601a      	str	r2, [r3, #0]
}
 8025d4a:	4770      	bx	lr
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025d4c:	6840      	ldr	r0, [r0, #4]
 8025d4e:	4662      	mov	r2, ip
 8025d50:	0091      	lsls	r1, r2, #2
 8025d52:	4a05      	ldr	r2, [pc, #20]	; (8025d68 <vTaskSwitchContext+0x90>)
 8025d54:	440a      	add	r2, r1
 8025d56:	6050      	str	r0, [r2, #4]
 8025d58:	e7ee      	b.n	8025d38 <vTaskSwitchContext+0x60>
 8025d5a:	bf00      	nop
 8025d5c:	20011cd8 	.word	0x20011cd8
 8025d60:	20011d5c 	.word	0x20011d5c
 8025d64:	20011ce0 	.word	0x20011ce0
 8025d68:	20011c40 	.word	0x20011c40
 8025d6c:	20011c34 	.word	0x20011c34

08025d70 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 8025d70:	b158      	cbz	r0, 8025d8a <vTaskPlaceOnEventList+0x1a>
{
 8025d72:	b510      	push	{r4, lr}
 8025d74:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8025d76:	4a09      	ldr	r2, [pc, #36]	; (8025d9c <vTaskPlaceOnEventList+0x2c>)
 8025d78:	6811      	ldr	r1, [r2, #0]
 8025d7a:	3118      	adds	r1, #24
 8025d7c:	f7fe fd2d 	bl	80247da <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8025d80:	2101      	movs	r1, #1
 8025d82:	4620      	mov	r0, r4
 8025d84:	f7ff fd34 	bl	80257f0 <prvAddCurrentTaskToDelayedList>
}
 8025d88:	bd10      	pop	{r4, pc}
 8025d8a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025d8e:	f383 8811 	msr	BASEPRI, r3
 8025d92:	f3bf 8f6f 	isb	sy
 8025d96:	f3bf 8f4f 	dsb	sy
	configASSERT( pxEventList );
 8025d9a:	e7fe      	b.n	8025d9a <vTaskPlaceOnEventList+0x2a>
 8025d9c:	20011c34 	.word	0x20011c34

08025da0 <vTaskPlaceOnEventListRestricted>:
	{
 8025da0:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 8025da2:	b170      	cbz	r0, 8025dc2 <vTaskPlaceOnEventListRestricted+0x22>
 8025da4:	460d      	mov	r5, r1
 8025da6:	4614      	mov	r4, r2
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8025da8:	4a0a      	ldr	r2, [pc, #40]	; (8025dd4 <vTaskPlaceOnEventListRestricted+0x34>)
 8025daa:	6811      	ldr	r1, [r2, #0]
 8025dac:	3118      	adds	r1, #24
 8025dae:	f7fe fd09 	bl	80247c4 <vListInsertEnd>
		if( xWaitIndefinitely != pdFALSE )
 8025db2:	b10c      	cbz	r4, 8025db8 <vTaskPlaceOnEventListRestricted+0x18>
			xTicksToWait = portMAX_DELAY;
 8025db4:	f04f 35ff 	mov.w	r5, #4294967295
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8025db8:	4621      	mov	r1, r4
 8025dba:	4628      	mov	r0, r5
 8025dbc:	f7ff fd18 	bl	80257f0 <prvAddCurrentTaskToDelayedList>
	}
 8025dc0:	bd38      	pop	{r3, r4, r5, pc}
 8025dc2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025dc6:	f383 8811 	msr	BASEPRI, r3
 8025dca:	f3bf 8f6f 	isb	sy
 8025dce:	f3bf 8f4f 	dsb	sy
		configASSERT( pxEventList );
 8025dd2:	e7fe      	b.n	8025dd2 <vTaskPlaceOnEventListRestricted+0x32>
 8025dd4:	20011c34 	.word	0x20011c34

08025dd8 <xTaskRemoveFromEventList>:
{
 8025dd8:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8025dda:	68c3      	ldr	r3, [r0, #12]
 8025ddc:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8025dde:	b324      	cbz	r4, 8025e2a <xTaskRemoveFromEventList+0x52>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8025de0:	f104 0518 	add.w	r5, r4, #24
 8025de4:	4628      	mov	r0, r5
 8025de6:	f7fe fd11 	bl	802480c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8025dea:	4b18      	ldr	r3, [pc, #96]	; (8025e4c <xTaskRemoveFromEventList+0x74>)
 8025dec:	681b      	ldr	r3, [r3, #0]
 8025dee:	bb2b      	cbnz	r3, 8025e3c <xTaskRemoveFromEventList+0x64>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8025df0:	1d25      	adds	r5, r4, #4
 8025df2:	4628      	mov	r0, r5
 8025df4:	f7fe fd0a 	bl	802480c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8025df8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8025dfa:	2301      	movs	r3, #1
 8025dfc:	4083      	lsls	r3, r0
 8025dfe:	4a14      	ldr	r2, [pc, #80]	; (8025e50 <xTaskRemoveFromEventList+0x78>)
 8025e00:	6811      	ldr	r1, [r2, #0]
 8025e02:	430b      	orrs	r3, r1
 8025e04:	6013      	str	r3, [r2, #0]
 8025e06:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025e0a:	4629      	mov	r1, r5
 8025e0c:	4b11      	ldr	r3, [pc, #68]	; (8025e54 <xTaskRemoveFromEventList+0x7c>)
 8025e0e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8025e12:	f7fe fcd7 	bl	80247c4 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8025e16:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8025e18:	4b0f      	ldr	r3, [pc, #60]	; (8025e58 <xTaskRemoveFromEventList+0x80>)
 8025e1a:	681b      	ldr	r3, [r3, #0]
 8025e1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025e1e:	429a      	cmp	r2, r3
 8025e20:	d911      	bls.n	8025e46 <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
 8025e22:	2001      	movs	r0, #1
 8025e24:	4b0d      	ldr	r3, [pc, #52]	; (8025e5c <xTaskRemoveFromEventList+0x84>)
 8025e26:	6018      	str	r0, [r3, #0]
}
 8025e28:	bd38      	pop	{r3, r4, r5, pc}
 8025e2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025e2e:	f383 8811 	msr	BASEPRI, r3
 8025e32:	f3bf 8f6f 	isb	sy
 8025e36:	f3bf 8f4f 	dsb	sy
	configASSERT( pxUnblockedTCB );
 8025e3a:	e7fe      	b.n	8025e3a <xTaskRemoveFromEventList+0x62>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8025e3c:	4629      	mov	r1, r5
 8025e3e:	4808      	ldr	r0, [pc, #32]	; (8025e60 <xTaskRemoveFromEventList+0x88>)
 8025e40:	f7fe fcc0 	bl	80247c4 <vListInsertEnd>
 8025e44:	e7e7      	b.n	8025e16 <xTaskRemoveFromEventList+0x3e>
		xReturn = pdFALSE;
 8025e46:	2000      	movs	r0, #0
	return xReturn;
 8025e48:	e7ee      	b.n	8025e28 <xTaskRemoveFromEventList+0x50>
 8025e4a:	bf00      	nop
 8025e4c:	20011cd8 	.word	0x20011cd8
 8025e50:	20011ce0 	.word	0x20011ce0
 8025e54:	20011c40 	.word	0x20011c40
 8025e58:	20011c34 	.word	0x20011c34
 8025e5c:	20011d5c 	.word	0x20011d5c
 8025e60:	20011d18 	.word	0x20011d18

08025e64 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8025e64:	4b03      	ldr	r3, [pc, #12]	; (8025e74 <vTaskInternalSetTimeOutState+0x10>)
 8025e66:	681b      	ldr	r3, [r3, #0]
 8025e68:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8025e6a:	4b03      	ldr	r3, [pc, #12]	; (8025e78 <vTaskInternalSetTimeOutState+0x14>)
 8025e6c:	681b      	ldr	r3, [r3, #0]
 8025e6e:	6043      	str	r3, [r0, #4]
}
 8025e70:	4770      	bx	lr
 8025e72:	bf00      	nop
 8025e74:	20011d14 	.word	0x20011d14
 8025e78:	20011d58 	.word	0x20011d58

08025e7c <xTaskCheckForTimeOut>:
{
 8025e7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 8025e7e:	b1c8      	cbz	r0, 8025eb4 <xTaskCheckForTimeOut+0x38>
 8025e80:	460c      	mov	r4, r1
 8025e82:	4605      	mov	r5, r0
	configASSERT( pxTicksToWait );
 8025e84:	b1f9      	cbz	r1, 8025ec6 <xTaskCheckForTimeOut+0x4a>
	taskENTER_CRITICAL();
 8025e86:	f7fe fd3d 	bl	8024904 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8025e8a:	4b1b      	ldr	r3, [pc, #108]	; (8025ef8 <xTaskCheckForTimeOut+0x7c>)
 8025e8c:	6819      	ldr	r1, [r3, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8025e8e:	686b      	ldr	r3, [r5, #4]
 8025e90:	1ac8      	subs	r0, r1, r3
			if( *pxTicksToWait == portMAX_DELAY )
 8025e92:	6822      	ldr	r2, [r4, #0]
 8025e94:	f1b2 3fff 	cmp.w	r2, #4294967295
 8025e98:	d026      	beq.n	8025ee8 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8025e9a:	4e18      	ldr	r6, [pc, #96]	; (8025efc <xTaskCheckForTimeOut+0x80>)
 8025e9c:	6836      	ldr	r6, [r6, #0]
 8025e9e:	682f      	ldr	r7, [r5, #0]
 8025ea0:	42b7      	cmp	r7, r6
 8025ea2:	d001      	beq.n	8025ea8 <xTaskCheckForTimeOut+0x2c>
 8025ea4:	428b      	cmp	r3, r1
 8025ea6:	d924      	bls.n	8025ef2 <xTaskCheckForTimeOut+0x76>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8025ea8:	4282      	cmp	r2, r0
 8025eaa:	d815      	bhi.n	8025ed8 <xTaskCheckForTimeOut+0x5c>
			*pxTicksToWait = 0;
 8025eac:	2300      	movs	r3, #0
 8025eae:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
 8025eb0:	2401      	movs	r4, #1
 8025eb2:	e01a      	b.n	8025eea <xTaskCheckForTimeOut+0x6e>
 8025eb4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025eb8:	f383 8811 	msr	BASEPRI, r3
 8025ebc:	f3bf 8f6f 	isb	sy
 8025ec0:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTimeOut );
 8025ec4:	e7fe      	b.n	8025ec4 <xTaskCheckForTimeOut+0x48>
 8025ec6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025eca:	f383 8811 	msr	BASEPRI, r3
 8025ece:	f3bf 8f6f 	isb	sy
 8025ed2:	f3bf 8f4f 	dsb	sy
	configASSERT( pxTicksToWait );
 8025ed6:	e7fe      	b.n	8025ed6 <xTaskCheckForTimeOut+0x5a>
			*pxTicksToWait -= xElapsedTime;
 8025ed8:	1a5b      	subs	r3, r3, r1
 8025eda:	4413      	add	r3, r2
 8025edc:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 8025ede:	4628      	mov	r0, r5
 8025ee0:	f7ff ffc0 	bl	8025e64 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 8025ee4:	2400      	movs	r4, #0
 8025ee6:	e000      	b.n	8025eea <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
 8025ee8:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8025eea:	f7fe fd2d 	bl	8024948 <vPortExitCritical>
}
 8025eee:	4620      	mov	r0, r4
 8025ef0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			xReturn = pdTRUE;
 8025ef2:	2401      	movs	r4, #1
 8025ef4:	e7f9      	b.n	8025eea <xTaskCheckForTimeOut+0x6e>
 8025ef6:	bf00      	nop
 8025ef8:	20011d58 	.word	0x20011d58
 8025efc:	20011d14 	.word	0x20011d14

08025f00 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 8025f00:	4b01      	ldr	r3, [pc, #4]	; (8025f08 <vTaskMissedYield+0x8>)
 8025f02:	2201      	movs	r2, #1
 8025f04:	601a      	str	r2, [r3, #0]
}
 8025f06:	4770      	bx	lr
 8025f08:	20011d5c 	.word	0x20011d5c

08025f0c <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8025f0c:	4b05      	ldr	r3, [pc, #20]	; (8025f24 <xTaskGetSchedulerState+0x18>)
 8025f0e:	681b      	ldr	r3, [r3, #0]
 8025f10:	b133      	cbz	r3, 8025f20 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8025f12:	4b05      	ldr	r3, [pc, #20]	; (8025f28 <xTaskGetSchedulerState+0x1c>)
 8025f14:	681b      	ldr	r3, [r3, #0]
 8025f16:	b10b      	cbz	r3, 8025f1c <xTaskGetSchedulerState+0x10>
				xReturn = taskSCHEDULER_SUSPENDED;
 8025f18:	2000      	movs	r0, #0
	}
 8025f1a:	4770      	bx	lr
				xReturn = taskSCHEDULER_RUNNING;
 8025f1c:	2002      	movs	r0, #2
 8025f1e:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8025f20:	2001      	movs	r0, #1
 8025f22:	4770      	bx	lr
 8025f24:	20011d2c 	.word	0x20011d2c
 8025f28:	20011cd8 	.word	0x20011cd8

08025f2c <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
 8025f2c:	2800      	cmp	r0, #0
 8025f2e:	d04f      	beq.n	8025fd0 <xTaskPriorityInherit+0xa4>
	{
 8025f30:	b538      	push	{r3, r4, r5, lr}
 8025f32:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 8025f34:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8025f36:	4a28      	ldr	r2, [pc, #160]	; (8025fd8 <xTaskPriorityInherit+0xac>)
 8025f38:	6812      	ldr	r2, [r2, #0]
 8025f3a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8025f3c:	4293      	cmp	r3, r2
 8025f3e:	d23f      	bcs.n	8025fc0 <xTaskPriorityInherit+0x94>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8025f40:	6982      	ldr	r2, [r0, #24]
 8025f42:	2a00      	cmp	r2, #0
 8025f44:	db05      	blt.n	8025f52 <xTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8025f46:	4a24      	ldr	r2, [pc, #144]	; (8025fd8 <xTaskPriorityInherit+0xac>)
 8025f48:	6812      	ldr	r2, [r2, #0]
 8025f4a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8025f4c:	f1c2 0207 	rsb	r2, r2, #7
 8025f50:	6182      	str	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 8025f52:	6961      	ldr	r1, [r4, #20]
 8025f54:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8025f58:	4a20      	ldr	r2, [pc, #128]	; (8025fdc <xTaskPriorityInherit+0xb0>)
 8025f5a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025f5e:	4299      	cmp	r1, r3
 8025f60:	d005      	beq.n	8025f6e <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8025f62:	4b1d      	ldr	r3, [pc, #116]	; (8025fd8 <xTaskPriorityInherit+0xac>)
 8025f64:	681b      	ldr	r3, [r3, #0]
 8025f66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025f68:	62e3      	str	r3, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
 8025f6a:	2001      	movs	r0, #1
	}
 8025f6c:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8025f6e:	1d25      	adds	r5, r4, #4
 8025f70:	4628      	mov	r0, r5
 8025f72:	f7fe fc4b 	bl	802480c <uxListRemove>
 8025f76:	b970      	cbnz	r0, 8025f96 <xTaskPriorityInherit+0x6a>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
 8025f78:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8025f7a:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 8025f7e:	009b      	lsls	r3, r3, #2
 8025f80:	4916      	ldr	r1, [pc, #88]	; (8025fdc <xTaskPriorityInherit+0xb0>)
 8025f82:	58cb      	ldr	r3, [r1, r3]
 8025f84:	b93b      	cbnz	r3, 8025f96 <xTaskPriorityInherit+0x6a>
 8025f86:	2301      	movs	r3, #1
 8025f88:	fa03 f202 	lsl.w	r2, r3, r2
 8025f8c:	4914      	ldr	r1, [pc, #80]	; (8025fe0 <xTaskPriorityInherit+0xb4>)
 8025f8e:	680b      	ldr	r3, [r1, #0]
 8025f90:	ea23 0302 	bic.w	r3, r3, r2
 8025f94:	600b      	str	r3, [r1, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 8025f96:	4b10      	ldr	r3, [pc, #64]	; (8025fd8 <xTaskPriorityInherit+0xac>)
 8025f98:	681b      	ldr	r3, [r3, #0]
 8025f9a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8025f9c:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 8025f9e:	2401      	movs	r4, #1
 8025fa0:	fa04 f300 	lsl.w	r3, r4, r0
 8025fa4:	4a0e      	ldr	r2, [pc, #56]	; (8025fe0 <xTaskPriorityInherit+0xb4>)
 8025fa6:	6811      	ldr	r1, [r2, #0]
 8025fa8:	430b      	orrs	r3, r1
 8025faa:	6013      	str	r3, [r2, #0]
 8025fac:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8025fb0:	4629      	mov	r1, r5
 8025fb2:	4b0a      	ldr	r3, [pc, #40]	; (8025fdc <xTaskPriorityInherit+0xb0>)
 8025fb4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8025fb8:	f7fe fc04 	bl	80247c4 <vListInsertEnd>
				xReturn = pdTRUE;
 8025fbc:	4620      	mov	r0, r4
 8025fbe:	e7d5      	b.n	8025f6c <xTaskPriorityInherit+0x40>
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 8025fc0:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8025fc2:	4b05      	ldr	r3, [pc, #20]	; (8025fd8 <xTaskPriorityInherit+0xac>)
 8025fc4:	681b      	ldr	r3, [r3, #0]
 8025fc6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8025fc8:	429a      	cmp	r2, r3
 8025fca:	d303      	bcc.n	8025fd4 <xTaskPriorityInherit+0xa8>
	BaseType_t xReturn = pdFALSE;
 8025fcc:	2000      	movs	r0, #0
 8025fce:	e7cd      	b.n	8025f6c <xTaskPriorityInherit+0x40>
 8025fd0:	2000      	movs	r0, #0
	}
 8025fd2:	4770      	bx	lr
					xReturn = pdTRUE;
 8025fd4:	2001      	movs	r0, #1
		return xReturn;
 8025fd6:	e7c9      	b.n	8025f6c <xTaskPriorityInherit+0x40>
 8025fd8:	20011c34 	.word	0x20011c34
 8025fdc:	20011c40 	.word	0x20011c40
 8025fe0:	20011ce0 	.word	0x20011ce0

08025fe4 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8025fe4:	2800      	cmp	r0, #0
 8025fe6:	d04b      	beq.n	8026080 <xTaskPriorityDisinherit+0x9c>
	{
 8025fe8:	b538      	push	{r3, r4, r5, lr}
 8025fea:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
 8025fec:	4b26      	ldr	r3, [pc, #152]	; (8026088 <xTaskPriorityDisinherit+0xa4>)
 8025fee:	681b      	ldr	r3, [r3, #0]
 8025ff0:	4283      	cmp	r3, r0
 8025ff2:	d008      	beq.n	8026006 <xTaskPriorityDisinherit+0x22>
 8025ff4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8025ff8:	f383 8811 	msr	BASEPRI, r3
 8025ffc:	f3bf 8f6f 	isb	sy
 8026000:	f3bf 8f4f 	dsb	sy
 8026004:	e7fe      	b.n	8026004 <xTaskPriorityDisinherit+0x20>
			configASSERT( pxTCB->uxMutexesHeld );
 8026006:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8026008:	b943      	cbnz	r3, 802601c <xTaskPriorityDisinherit+0x38>
 802600a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802600e:	f383 8811 	msr	BASEPRI, r3
 8026012:	f3bf 8f6f 	isb	sy
 8026016:	f3bf 8f4f 	dsb	sy
 802601a:	e7fe      	b.n	802601a <xTaskPriorityDisinherit+0x36>
			( pxTCB->uxMutexesHeld )--;
 802601c:	3b01      	subs	r3, #1
 802601e:	6503      	str	r3, [r0, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8026020:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 8026022:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8026024:	4291      	cmp	r1, r2
 8026026:	d02d      	beq.n	8026084 <xTaskPriorityDisinherit+0xa0>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8026028:	b10b      	cbz	r3, 802602e <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 802602a:	2000      	movs	r0, #0
	}
 802602c:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 802602e:	1d05      	adds	r5, r0, #4
 8026030:	4628      	mov	r0, r5
 8026032:	f7fe fbeb 	bl	802480c <uxListRemove>
 8026036:	b968      	cbnz	r0, 8026054 <xTaskPriorityDisinherit+0x70>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8026038:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 802603a:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 802603e:	0092      	lsls	r2, r2, #2
 8026040:	4912      	ldr	r1, [pc, #72]	; (802608c <xTaskPriorityDisinherit+0xa8>)
 8026042:	588a      	ldr	r2, [r1, r2]
 8026044:	b932      	cbnz	r2, 8026054 <xTaskPriorityDisinherit+0x70>
 8026046:	2201      	movs	r2, #1
 8026048:	409a      	lsls	r2, r3
 802604a:	4911      	ldr	r1, [pc, #68]	; (8026090 <xTaskPriorityDisinherit+0xac>)
 802604c:	680b      	ldr	r3, [r1, #0]
 802604e:	ea23 0302 	bic.w	r3, r3, r2
 8026052:	600b      	str	r3, [r1, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8026054:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8026056:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8026058:	f1c0 0307 	rsb	r3, r0, #7
 802605c:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 802605e:	2401      	movs	r4, #1
 8026060:	fa04 f300 	lsl.w	r3, r4, r0
 8026064:	4a0a      	ldr	r2, [pc, #40]	; (8026090 <xTaskPriorityDisinherit+0xac>)
 8026066:	6811      	ldr	r1, [r2, #0]
 8026068:	430b      	orrs	r3, r1
 802606a:	6013      	str	r3, [r2, #0]
 802606c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8026070:	4629      	mov	r1, r5
 8026072:	4b06      	ldr	r3, [pc, #24]	; (802608c <xTaskPriorityDisinherit+0xa8>)
 8026074:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8026078:	f7fe fba4 	bl	80247c4 <vListInsertEnd>
					xReturn = pdTRUE;
 802607c:	4620      	mov	r0, r4
 802607e:	e7d5      	b.n	802602c <xTaskPriorityDisinherit+0x48>
	BaseType_t xReturn = pdFALSE;
 8026080:	2000      	movs	r0, #0
	}
 8026082:	4770      	bx	lr
	BaseType_t xReturn = pdFALSE;
 8026084:	2000      	movs	r0, #0
 8026086:	e7d1      	b.n	802602c <xTaskPriorityDisinherit+0x48>
 8026088:	20011c34 	.word	0x20011c34
 802608c:	20011c40 	.word	0x20011c40
 8026090:	20011ce0 	.word	0x20011ce0

08026094 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
 8026094:	2800      	cmp	r0, #0
 8026096:	d055      	beq.n	8026144 <vTaskPriorityDisinheritAfterTimeout+0xb0>
	{
 8026098:	b538      	push	{r3, r4, r5, lr}
 802609a:	4604      	mov	r4, r0
			configASSERT( pxTCB->uxMutexesHeld );
 802609c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 802609e:	b943      	cbnz	r3, 80260b2 <vTaskPriorityDisinheritAfterTimeout+0x1e>
 80260a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80260a4:	f383 8811 	msr	BASEPRI, r3
 80260a8:	f3bf 8f6f 	isb	sy
 80260ac:	f3bf 8f4f 	dsb	sy
 80260b0:	e7fe      	b.n	80260b0 <vTaskPriorityDisinheritAfterTimeout+0x1c>
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 80260b2:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 80260b4:	428a      	cmp	r2, r1
 80260b6:	d200      	bcs.n	80260ba <vTaskPriorityDisinheritAfterTimeout+0x26>
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 80260b8:	460a      	mov	r2, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
 80260ba:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80260bc:	4291      	cmp	r1, r2
 80260be:	d001      	beq.n	80260c4 <vTaskPriorityDisinheritAfterTimeout+0x30>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 80260c0:	2b01      	cmp	r3, #1
 80260c2:	d000      	beq.n	80260c6 <vTaskPriorityDisinheritAfterTimeout+0x32>
	}
 80260c4:	bd38      	pop	{r3, r4, r5, pc}
					configASSERT( pxTCB != pxCurrentTCB );
 80260c6:	4b20      	ldr	r3, [pc, #128]	; (8026148 <vTaskPriorityDisinheritAfterTimeout+0xb4>)
 80260c8:	681b      	ldr	r3, [r3, #0]
 80260ca:	42a3      	cmp	r3, r4
 80260cc:	d031      	beq.n	8026132 <vTaskPriorityDisinheritAfterTimeout+0x9e>
					pxTCB->uxPriority = uxPriorityToUse;
 80260ce:	62e2      	str	r2, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80260d0:	69a3      	ldr	r3, [r4, #24]
 80260d2:	2b00      	cmp	r3, #0
 80260d4:	db02      	blt.n	80260dc <vTaskPriorityDisinheritAfterTimeout+0x48>
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80260d6:	f1c2 0207 	rsb	r2, r2, #7
 80260da:	61a2      	str	r2, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80260dc:	6962      	ldr	r2, [r4, #20]
 80260de:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 80260e2:	4b1a      	ldr	r3, [pc, #104]	; (802614c <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 80260e4:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 80260e8:	429a      	cmp	r2, r3
 80260ea:	d1eb      	bne.n	80260c4 <vTaskPriorityDisinheritAfterTimeout+0x30>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80260ec:	1d25      	adds	r5, r4, #4
 80260ee:	4628      	mov	r0, r5
 80260f0:	f7fe fb8c 	bl	802480c <uxListRemove>
 80260f4:	b968      	cbnz	r0, 8026112 <vTaskPriorityDisinheritAfterTimeout+0x7e>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80260f6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80260f8:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80260fc:	0092      	lsls	r2, r2, #2
 80260fe:	4913      	ldr	r1, [pc, #76]	; (802614c <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 8026100:	588a      	ldr	r2, [r1, r2]
 8026102:	b932      	cbnz	r2, 8026112 <vTaskPriorityDisinheritAfterTimeout+0x7e>
 8026104:	2201      	movs	r2, #1
 8026106:	409a      	lsls	r2, r3
 8026108:	4911      	ldr	r1, [pc, #68]	; (8026150 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
 802610a:	680b      	ldr	r3, [r1, #0]
 802610c:	ea23 0302 	bic.w	r3, r3, r2
 8026110:	600b      	str	r3, [r1, #0]
						prvAddTaskToReadyList( pxTCB );
 8026112:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8026114:	2301      	movs	r3, #1
 8026116:	4083      	lsls	r3, r0
 8026118:	4a0d      	ldr	r2, [pc, #52]	; (8026150 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
 802611a:	6811      	ldr	r1, [r2, #0]
 802611c:	430b      	orrs	r3, r1
 802611e:	6013      	str	r3, [r2, #0]
 8026120:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8026124:	4629      	mov	r1, r5
 8026126:	4b09      	ldr	r3, [pc, #36]	; (802614c <vTaskPriorityDisinheritAfterTimeout+0xb8>)
 8026128:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 802612c:	f7fe fb4a 	bl	80247c4 <vListInsertEnd>
	}
 8026130:	e7c8      	b.n	80260c4 <vTaskPriorityDisinheritAfterTimeout+0x30>
 8026132:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026136:	f383 8811 	msr	BASEPRI, r3
 802613a:	f3bf 8f6f 	isb	sy
 802613e:	f3bf 8f4f 	dsb	sy
					configASSERT( pxTCB != pxCurrentTCB );
 8026142:	e7fe      	b.n	8026142 <vTaskPriorityDisinheritAfterTimeout+0xae>
 8026144:	4770      	bx	lr
 8026146:	bf00      	nop
 8026148:	20011c34 	.word	0x20011c34
 802614c:	20011c40 	.word	0x20011c40
 8026150:	20011ce0 	.word	0x20011ce0

08026154 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 8026154:	4b05      	ldr	r3, [pc, #20]	; (802616c <pvTaskIncrementMutexHeldCount+0x18>)
 8026156:	681b      	ldr	r3, [r3, #0]
 8026158:	b123      	cbz	r3, 8026164 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
 802615a:	4b04      	ldr	r3, [pc, #16]	; (802616c <pvTaskIncrementMutexHeldCount+0x18>)
 802615c:	681a      	ldr	r2, [r3, #0]
 802615e:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8026160:	3301      	adds	r3, #1
 8026162:	6513      	str	r3, [r2, #80]	; 0x50
		return pxCurrentTCB;
 8026164:	4b01      	ldr	r3, [pc, #4]	; (802616c <pvTaskIncrementMutexHeldCount+0x18>)
 8026166:	6818      	ldr	r0, [r3, #0]
	}
 8026168:	4770      	bx	lr
 802616a:	bf00      	nop
 802616c:	20011c34 	.word	0x20011c34

08026170 <prvGetNextExpireTime>:
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8026170:	4b06      	ldr	r3, [pc, #24]	; (802618c <prvGetNextExpireTime+0x1c>)
 8026172:	681a      	ldr	r2, [r3, #0]
 8026174:	6813      	ldr	r3, [r2, #0]
 8026176:	b92b      	cbnz	r3, 8026184 <prvGetNextExpireTime+0x14>
 8026178:	2301      	movs	r3, #1
 802617a:	6003      	str	r3, [r0, #0]
	if( *pxListWasEmpty == pdFALSE )
 802617c:	b923      	cbnz	r3, 8026188 <prvGetNextExpireTime+0x18>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 802617e:	68d3      	ldr	r3, [r2, #12]
 8026180:	6818      	ldr	r0, [r3, #0]
 8026182:	4770      	bx	lr
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8026184:	2300      	movs	r3, #0
 8026186:	e7f8      	b.n	802617a <prvGetNextExpireTime+0xa>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 8026188:	2000      	movs	r0, #0
	}

	return xNextExpireTime;
}
 802618a:	4770      	bx	lr
 802618c:	20011d60 	.word	0x20011d60

08026190 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 8026190:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8026192:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8026194:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
 8026196:	4291      	cmp	r1, r2
 8026198:	d80c      	bhi.n	80261b4 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 802619a:	1ad2      	subs	r2, r2, r3
 802619c:	6983      	ldr	r3, [r0, #24]
 802619e:	429a      	cmp	r2, r3
 80261a0:	d301      	bcc.n	80261a6 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 80261a2:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 80261a4:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 80261a6:	1d01      	adds	r1, r0, #4
 80261a8:	4b09      	ldr	r3, [pc, #36]	; (80261d0 <prvInsertTimerInActiveList+0x40>)
 80261aa:	6818      	ldr	r0, [r3, #0]
 80261ac:	f7fe fb15 	bl	80247da <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 80261b0:	2000      	movs	r0, #0
 80261b2:	e7f7      	b.n	80261a4 <prvInsertTimerInActiveList+0x14>
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 80261b4:	429a      	cmp	r2, r3
 80261b6:	d201      	bcs.n	80261bc <prvInsertTimerInActiveList+0x2c>
 80261b8:	4299      	cmp	r1, r3
 80261ba:	d206      	bcs.n	80261ca <prvInsertTimerInActiveList+0x3a>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80261bc:	1d01      	adds	r1, r0, #4
 80261be:	4b05      	ldr	r3, [pc, #20]	; (80261d4 <prvInsertTimerInActiveList+0x44>)
 80261c0:	6818      	ldr	r0, [r3, #0]
 80261c2:	f7fe fb0a 	bl	80247da <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 80261c6:	2000      	movs	r0, #0
 80261c8:	e7ec      	b.n	80261a4 <prvInsertTimerInActiveList+0x14>
			xProcessTimerNow = pdTRUE;
 80261ca:	2001      	movs	r0, #1
	return xProcessTimerNow;
 80261cc:	e7ea      	b.n	80261a4 <prvInsertTimerInActiveList+0x14>
 80261ce:	bf00      	nop
 80261d0:	20011d64 	.word	0x20011d64
 80261d4:	20011d60 	.word	0x20011d60

080261d8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 80261d8:	b538      	push	{r3, r4, r5, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 80261da:	f7fe fb93 	bl	8024904 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 80261de:	4b0f      	ldr	r3, [pc, #60]	; (802621c <prvCheckForValidListAndQueue+0x44>)
 80261e0:	681b      	ldr	r3, [r3, #0]
 80261e2:	b113      	cbz	r3, 80261ea <prvCheckForValidListAndQueue+0x12>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 80261e4:	f7fe fbb0 	bl	8024948 <vPortExitCritical>
}
 80261e8:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &xActiveTimerList1 );
 80261ea:	4d0d      	ldr	r5, [pc, #52]	; (8026220 <prvCheckForValidListAndQueue+0x48>)
 80261ec:	4628      	mov	r0, r5
 80261ee:	f7fe fadb 	bl	80247a8 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80261f2:	4c0c      	ldr	r4, [pc, #48]	; (8026224 <prvCheckForValidListAndQueue+0x4c>)
 80261f4:	4620      	mov	r0, r4
 80261f6:	f7fe fad7 	bl	80247a8 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 80261fa:	4b0b      	ldr	r3, [pc, #44]	; (8026228 <prvCheckForValidListAndQueue+0x50>)
 80261fc:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 80261fe:	4b0b      	ldr	r3, [pc, #44]	; (802622c <prvCheckForValidListAndQueue+0x54>)
 8026200:	601c      	str	r4, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 8026202:	2200      	movs	r2, #0
 8026204:	210c      	movs	r1, #12
 8026206:	200a      	movs	r0, #10
 8026208:	f7fe fdcb 	bl	8024da2 <xQueueGenericCreate>
 802620c:	4b03      	ldr	r3, [pc, #12]	; (802621c <prvCheckForValidListAndQueue+0x44>)
 802620e:	6018      	str	r0, [r3, #0]
				if( xTimerQueue != NULL )
 8026210:	2800      	cmp	r0, #0
 8026212:	d0e7      	beq.n	80261e4 <prvCheckForValidListAndQueue+0xc>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8026214:	4906      	ldr	r1, [pc, #24]	; (8026230 <prvCheckForValidListAndQueue+0x58>)
 8026216:	f7ff f979 	bl	802550c <vQueueAddToRegistry>
 802621a:	e7e3      	b.n	80261e4 <prvCheckForValidListAndQueue+0xc>
 802621c:	20011d94 	.word	0x20011d94
 8026220:	20011d68 	.word	0x20011d68
 8026224:	20011d7c 	.word	0x20011d7c
 8026228:	20011d60 	.word	0x20011d60
 802622c:	20011d64 	.word	0x20011d64
 8026230:	08037434 	.word	0x08037434

08026234 <prvInitialiseNewTimer>:
{
 8026234:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8026238:	9f07      	ldr	r7, [sp, #28]
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 802623a:	b941      	cbnz	r1, 802624e <prvInitialiseNewTimer+0x1a>
 802623c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026240:	f383 8811 	msr	BASEPRI, r3
 8026244:	f3bf 8f6f 	isb	sy
 8026248:	f3bf 8f4f 	dsb	sy
 802624c:	e7fe      	b.n	802624c <prvInitialiseNewTimer+0x18>
 802624e:	4606      	mov	r6, r0
 8026250:	4614      	mov	r4, r2
 8026252:	461d      	mov	r5, r3
 8026254:	4688      	mov	r8, r1
	if( pxNewTimer != NULL )
 8026256:	b18f      	cbz	r7, 802627c <prvInitialiseNewTimer+0x48>
		prvCheckForValidListAndQueue();
 8026258:	f7ff ffbe 	bl	80261d8 <prvCheckForValidListAndQueue>
		pxNewTimer->pcTimerName = pcTimerName;
 802625c:	603e      	str	r6, [r7, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 802625e:	f8c7 8018 	str.w	r8, [r7, #24]
		pxNewTimer->pvTimerID = pvTimerID;
 8026262:	61fd      	str	r5, [r7, #28]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8026264:	9b06      	ldr	r3, [sp, #24]
 8026266:	623b      	str	r3, [r7, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8026268:	1d38      	adds	r0, r7, #4
 802626a:	f7fe faa8 	bl	80247be <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 802626e:	b12c      	cbz	r4, 802627c <prvInitialiseNewTimer+0x48>
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 8026270:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8026274:	f043 0304 	orr.w	r3, r3, #4
 8026278:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
}
 802627c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08026280 <xTimerCreateTimerTask>:
{
 8026280:	b500      	push	{lr}
 8026282:	b083      	sub	sp, #12
	prvCheckForValidListAndQueue();
 8026284:	f7ff ffa8 	bl	80261d8 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 8026288:	4b0d      	ldr	r3, [pc, #52]	; (80262c0 <xTimerCreateTimerTask+0x40>)
 802628a:	681b      	ldr	r3, [r3, #0]
 802628c:	b15b      	cbz	r3, 80262a6 <xTimerCreateTimerTask+0x26>
			xReturn = xTaskCreate(	prvTimerTask,
 802628e:	4b0d      	ldr	r3, [pc, #52]	; (80262c4 <xTimerCreateTimerTask+0x44>)
 8026290:	9301      	str	r3, [sp, #4]
 8026292:	2302      	movs	r3, #2
 8026294:	9300      	str	r3, [sp, #0]
 8026296:	2300      	movs	r3, #0
 8026298:	f44f 7280 	mov.w	r2, #256	; 0x100
 802629c:	490a      	ldr	r1, [pc, #40]	; (80262c8 <xTimerCreateTimerTask+0x48>)
 802629e:	480b      	ldr	r0, [pc, #44]	; (80262cc <xTimerCreateTimerTask+0x4c>)
 80262a0:	f7ff faf2 	bl	8025888 <xTaskCreate>
	configASSERT( xReturn );
 80262a4:	b940      	cbnz	r0, 80262b8 <xTimerCreateTimerTask+0x38>
 80262a6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80262aa:	f383 8811 	msr	BASEPRI, r3
 80262ae:	f3bf 8f6f 	isb	sy
 80262b2:	f3bf 8f4f 	dsb	sy
 80262b6:	e7fe      	b.n	80262b6 <xTimerCreateTimerTask+0x36>
}
 80262b8:	b003      	add	sp, #12
 80262ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80262be:	bf00      	nop
 80262c0:	20011d94 	.word	0x20011d94
 80262c4:	20011d98 	.word	0x20011d98
 80262c8:	0803743c 	.word	0x0803743c
 80262cc:	080265f9 	.word	0x080265f9

080262d0 <xTimerCreate>:
	{
 80262d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80262d4:	b082      	sub	sp, #8
 80262d6:	4604      	mov	r4, r0
 80262d8:	4688      	mov	r8, r1
 80262da:	4617      	mov	r7, r2
 80262dc:	461d      	mov	r5, r3
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 80262de:	202c      	movs	r0, #44	; 0x2c
 80262e0:	f7fe f9b2 	bl	8024648 <pvPortMalloc>
		if( pxNewTimer != NULL )
 80262e4:	4606      	mov	r6, r0
 80262e6:	b158      	cbz	r0, 8026300 <xTimerCreate+0x30>
			pxNewTimer->ucStatus = 0x00;
 80262e8:	2300      	movs	r3, #0
 80262ea:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 80262ee:	9001      	str	r0, [sp, #4]
 80262f0:	9b08      	ldr	r3, [sp, #32]
 80262f2:	9300      	str	r3, [sp, #0]
 80262f4:	462b      	mov	r3, r5
 80262f6:	463a      	mov	r2, r7
 80262f8:	4641      	mov	r1, r8
 80262fa:	4620      	mov	r0, r4
 80262fc:	f7ff ff9a 	bl	8026234 <prvInitialiseNewTimer>
	}
 8026300:	4630      	mov	r0, r6
 8026302:	b002      	add	sp, #8
 8026304:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08026308 <xTimerGenericCommand>:
	configASSERT( xTimer );
 8026308:	b1b8      	cbz	r0, 802633a <xTimerGenericCommand+0x32>
 802630a:	469c      	mov	ip, r3
 802630c:	4603      	mov	r3, r0
	if( xTimerQueue != NULL )
 802630e:	4818      	ldr	r0, [pc, #96]	; (8026370 <xTimerGenericCommand+0x68>)
 8026310:	6800      	ldr	r0, [r0, #0]
 8026312:	b358      	cbz	r0, 802636c <xTimerGenericCommand+0x64>
{
 8026314:	b500      	push	{lr}
 8026316:	b085      	sub	sp, #20
		xMessage.xMessageID = xCommandID;
 8026318:	9101      	str	r1, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 802631a:	9202      	str	r2, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 802631c:	9303      	str	r3, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 802631e:	2905      	cmp	r1, #5
 8026320:	dc1c      	bgt.n	802635c <xTimerGenericCommand+0x54>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8026322:	f7ff fdf3 	bl	8025f0c <xTaskGetSchedulerState>
 8026326:	2802      	cmp	r0, #2
 8026328:	d010      	beq.n	802634c <xTimerGenericCommand+0x44>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 802632a:	2300      	movs	r3, #0
 802632c:	461a      	mov	r2, r3
 802632e:	a901      	add	r1, sp, #4
 8026330:	480f      	ldr	r0, [pc, #60]	; (8026370 <xTimerGenericCommand+0x68>)
 8026332:	6800      	ldr	r0, [r0, #0]
 8026334:	f7fe fd77 	bl	8024e26 <xQueueGenericSend>
 8026338:	e015      	b.n	8026366 <xTimerGenericCommand+0x5e>
 802633a:	f04f 0350 	mov.w	r3, #80	; 0x50
 802633e:	f383 8811 	msr	BASEPRI, r3
 8026342:	f3bf 8f6f 	isb	sy
 8026346:	f3bf 8f4f 	dsb	sy
	configASSERT( xTimer );
 802634a:	e7fe      	b.n	802634a <xTimerGenericCommand+0x42>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 802634c:	2300      	movs	r3, #0
 802634e:	9a06      	ldr	r2, [sp, #24]
 8026350:	a901      	add	r1, sp, #4
 8026352:	4807      	ldr	r0, [pc, #28]	; (8026370 <xTimerGenericCommand+0x68>)
 8026354:	6800      	ldr	r0, [r0, #0]
 8026356:	f7fe fd66 	bl	8024e26 <xQueueGenericSend>
 802635a:	e004      	b.n	8026366 <xTimerGenericCommand+0x5e>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 802635c:	2300      	movs	r3, #0
 802635e:	4662      	mov	r2, ip
 8026360:	a901      	add	r1, sp, #4
 8026362:	f7fe fe3b 	bl	8024fdc <xQueueGenericSendFromISR>
}
 8026366:	b005      	add	sp, #20
 8026368:	f85d fb04 	ldr.w	pc, [sp], #4
BaseType_t xReturn = pdFAIL;
 802636c:	2000      	movs	r0, #0
}
 802636e:	4770      	bx	lr
 8026370:	20011d94 	.word	0x20011d94

08026374 <prvSwitchTimerLists>:
{
 8026374:	b570      	push	{r4, r5, r6, lr}
 8026376:	b082      	sub	sp, #8
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8026378:	4b1b      	ldr	r3, [pc, #108]	; (80263e8 <prvSwitchTimerLists+0x74>)
 802637a:	681b      	ldr	r3, [r3, #0]
 802637c:	681a      	ldr	r2, [r3, #0]
 802637e:	b362      	cbz	r2, 80263da <prvSwitchTimerLists+0x66>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8026380:	68db      	ldr	r3, [r3, #12]
 8026382:	681e      	ldr	r6, [r3, #0]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8026384:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8026386:	1d25      	adds	r5, r4, #4
 8026388:	4628      	mov	r0, r5
 802638a:	f7fe fa3f 	bl	802480c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 802638e:	6a23      	ldr	r3, [r4, #32]
 8026390:	4620      	mov	r0, r4
 8026392:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8026394:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8026398:	f013 0f04 	tst.w	r3, #4
 802639c:	d0ec      	beq.n	8026378 <prvSwitchTimerLists+0x4>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 802639e:	69a3      	ldr	r3, [r4, #24]
 80263a0:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 80263a2:	429e      	cmp	r6, r3
 80263a4:	d207      	bcs.n	80263b6 <prvSwitchTimerLists+0x42>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80263a6:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80263a8:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80263aa:	4629      	mov	r1, r5
 80263ac:	4b0e      	ldr	r3, [pc, #56]	; (80263e8 <prvSwitchTimerLists+0x74>)
 80263ae:	6818      	ldr	r0, [r3, #0]
 80263b0:	f7fe fa13 	bl	80247da <vListInsert>
 80263b4:	e7e0      	b.n	8026378 <prvSwitchTimerLists+0x4>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80263b6:	2100      	movs	r1, #0
 80263b8:	9100      	str	r1, [sp, #0]
 80263ba:	460b      	mov	r3, r1
 80263bc:	4632      	mov	r2, r6
 80263be:	4620      	mov	r0, r4
 80263c0:	f7ff ffa2 	bl	8026308 <xTimerGenericCommand>
				configASSERT( xResult );
 80263c4:	2800      	cmp	r0, #0
 80263c6:	d1d7      	bne.n	8026378 <prvSwitchTimerLists+0x4>
 80263c8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80263cc:	f383 8811 	msr	BASEPRI, r3
 80263d0:	f3bf 8f6f 	isb	sy
 80263d4:	f3bf 8f4f 	dsb	sy
 80263d8:	e7fe      	b.n	80263d8 <prvSwitchTimerLists+0x64>
	pxCurrentTimerList = pxOverflowTimerList;
 80263da:	4a04      	ldr	r2, [pc, #16]	; (80263ec <prvSwitchTimerLists+0x78>)
 80263dc:	6810      	ldr	r0, [r2, #0]
 80263de:	4902      	ldr	r1, [pc, #8]	; (80263e8 <prvSwitchTimerLists+0x74>)
 80263e0:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
 80263e2:	6013      	str	r3, [r2, #0]
}
 80263e4:	b002      	add	sp, #8
 80263e6:	bd70      	pop	{r4, r5, r6, pc}
 80263e8:	20011d60 	.word	0x20011d60
 80263ec:	20011d64 	.word	0x20011d64

080263f0 <prvSampleTimeNow>:
{
 80263f0:	b538      	push	{r3, r4, r5, lr}
 80263f2:	4605      	mov	r5, r0
	xTimeNow = xTaskGetTickCount();
 80263f4:	f7ff fb34 	bl	8025a60 <xTaskGetTickCount>
 80263f8:	4604      	mov	r4, r0
	if( xTimeNow < xLastTime )
 80263fa:	4b07      	ldr	r3, [pc, #28]	; (8026418 <prvSampleTimeNow+0x28>)
 80263fc:	681b      	ldr	r3, [r3, #0]
 80263fe:	4283      	cmp	r3, r0
 8026400:	d805      	bhi.n	802640e <prvSampleTimeNow+0x1e>
		*pxTimerListsWereSwitched = pdFALSE;
 8026402:	2300      	movs	r3, #0
 8026404:	602b      	str	r3, [r5, #0]
	xLastTime = xTimeNow;
 8026406:	4b04      	ldr	r3, [pc, #16]	; (8026418 <prvSampleTimeNow+0x28>)
 8026408:	601c      	str	r4, [r3, #0]
}
 802640a:	4620      	mov	r0, r4
 802640c:	bd38      	pop	{r3, r4, r5, pc}
		prvSwitchTimerLists();
 802640e:	f7ff ffb1 	bl	8026374 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 8026412:	2301      	movs	r3, #1
 8026414:	602b      	str	r3, [r5, #0]
 8026416:	e7f6      	b.n	8026406 <prvSampleTimeNow+0x16>
 8026418:	20011d90 	.word	0x20011d90

0802641c <prvProcessExpiredTimer>:
{
 802641c:	b570      	push	{r4, r5, r6, lr}
 802641e:	b082      	sub	sp, #8
 8026420:	4606      	mov	r6, r0
 8026422:	460d      	mov	r5, r1
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8026424:	4917      	ldr	r1, [pc, #92]	; (8026484 <prvProcessExpiredTimer+0x68>)
 8026426:	6809      	ldr	r1, [r1, #0]
 8026428:	68c9      	ldr	r1, [r1, #12]
 802642a:	68cc      	ldr	r4, [r1, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 802642c:	1d20      	adds	r0, r4, #4
 802642e:	f7fe f9ed 	bl	802480c <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8026432:	f894 c028 	ldrb.w	ip, [r4, #40]	; 0x28
 8026436:	f01c 0f04 	tst.w	ip, #4
 802643a:	d108      	bne.n	802644e <prvProcessExpiredTimer+0x32>
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 802643c:	f02c 0c01 	bic.w	ip, ip, #1
 8026440:	f884 c028 	strb.w	ip, [r4, #40]	; 0x28
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8026444:	6a23      	ldr	r3, [r4, #32]
 8026446:	4620      	mov	r0, r4
 8026448:	4798      	blx	r3
}
 802644a:	b002      	add	sp, #8
 802644c:	bd70      	pop	{r4, r5, r6, pc}
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 802644e:	69a1      	ldr	r1, [r4, #24]
 8026450:	4633      	mov	r3, r6
 8026452:	462a      	mov	r2, r5
 8026454:	4431      	add	r1, r6
 8026456:	4620      	mov	r0, r4
 8026458:	f7ff fe9a 	bl	8026190 <prvInsertTimerInActiveList>
 802645c:	2800      	cmp	r0, #0
 802645e:	d0f1      	beq.n	8026444 <prvProcessExpiredTimer+0x28>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8026460:	2100      	movs	r1, #0
 8026462:	9100      	str	r1, [sp, #0]
 8026464:	460b      	mov	r3, r1
 8026466:	4632      	mov	r2, r6
 8026468:	4620      	mov	r0, r4
 802646a:	f7ff ff4d 	bl	8026308 <xTimerGenericCommand>
			configASSERT( xResult );
 802646e:	2800      	cmp	r0, #0
 8026470:	d1e8      	bne.n	8026444 <prvProcessExpiredTimer+0x28>
 8026472:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026476:	f383 8811 	msr	BASEPRI, r3
 802647a:	f3bf 8f6f 	isb	sy
 802647e:	f3bf 8f4f 	dsb	sy
 8026482:	e7fe      	b.n	8026482 <prvProcessExpiredTimer+0x66>
 8026484:	20011d60 	.word	0x20011d60

08026488 <prvProcessTimerOrBlockTask>:
{
 8026488:	b570      	push	{r4, r5, r6, lr}
 802648a:	b082      	sub	sp, #8
 802648c:	4606      	mov	r6, r0
 802648e:	460c      	mov	r4, r1
	vTaskSuspendAll();
 8026490:	f7ff fade 	bl	8025a50 <vTaskSuspendAll>
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8026494:	a801      	add	r0, sp, #4
 8026496:	f7ff ffab 	bl	80263f0 <prvSampleTimeNow>
		if( xTimerListsWereSwitched == pdFALSE )
 802649a:	9b01      	ldr	r3, [sp, #4]
 802649c:	bb33      	cbnz	r3, 80264ec <prvProcessTimerOrBlockTask+0x64>
 802649e:	4605      	mov	r5, r0
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 80264a0:	b90c      	cbnz	r4, 80264a6 <prvProcessTimerOrBlockTask+0x1e>
 80264a2:	42b0      	cmp	r0, r6
 80264a4:	d219      	bcs.n	80264da <prvProcessTimerOrBlockTask+0x52>
				if( xListWasEmpty != pdFALSE )
 80264a6:	b124      	cbz	r4, 80264b2 <prvProcessTimerOrBlockTask+0x2a>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80264a8:	4a12      	ldr	r2, [pc, #72]	; (80264f4 <prvProcessTimerOrBlockTask+0x6c>)
 80264aa:	6812      	ldr	r2, [r2, #0]
 80264ac:	6812      	ldr	r2, [r2, #0]
 80264ae:	b9da      	cbnz	r2, 80264e8 <prvProcessTimerOrBlockTask+0x60>
 80264b0:	2401      	movs	r4, #1
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 80264b2:	4622      	mov	r2, r4
 80264b4:	1b71      	subs	r1, r6, r5
 80264b6:	4b10      	ldr	r3, [pc, #64]	; (80264f8 <prvProcessTimerOrBlockTask+0x70>)
 80264b8:	6818      	ldr	r0, [r3, #0]
 80264ba:	f7ff f83b 	bl	8025534 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 80264be:	f7ff fb69 	bl	8025b94 <xTaskResumeAll>
 80264c2:	b9a8      	cbnz	r0, 80264f0 <prvProcessTimerOrBlockTask+0x68>
					portYIELD_WITHIN_API();
 80264c4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80264c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80264cc:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80264d0:	f3bf 8f4f 	dsb	sy
 80264d4:	f3bf 8f6f 	isb	sy
 80264d8:	e00a      	b.n	80264f0 <prvProcessTimerOrBlockTask+0x68>
				( void ) xTaskResumeAll();
 80264da:	f7ff fb5b 	bl	8025b94 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 80264de:	4629      	mov	r1, r5
 80264e0:	4630      	mov	r0, r6
 80264e2:	f7ff ff9b 	bl	802641c <prvProcessExpiredTimer>
 80264e6:	e003      	b.n	80264f0 <prvProcessTimerOrBlockTask+0x68>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80264e8:	461c      	mov	r4, r3
 80264ea:	e7e2      	b.n	80264b2 <prvProcessTimerOrBlockTask+0x2a>
			( void ) xTaskResumeAll();
 80264ec:	f7ff fb52 	bl	8025b94 <xTaskResumeAll>
}
 80264f0:	b002      	add	sp, #8
 80264f2:	bd70      	pop	{r4, r5, r6, pc}
 80264f4:	20011d64 	.word	0x20011d64
 80264f8:	20011d94 	.word	0x20011d94

080264fc <prvProcessReceivedCommands>:
{
 80264fc:	b510      	push	{r4, lr}
 80264fe:	b086      	sub	sp, #24
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8026500:	2200      	movs	r2, #0
 8026502:	a903      	add	r1, sp, #12
 8026504:	4b3b      	ldr	r3, [pc, #236]	; (80265f4 <prvProcessReceivedCommands+0xf8>)
 8026506:	6818      	ldr	r0, [r3, #0]
 8026508:	f7fe fe27 	bl	802515a <xQueueReceive>
 802650c:	2800      	cmp	r0, #0
 802650e:	d06e      	beq.n	80265ee <prvProcessReceivedCommands+0xf2>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8026510:	9b03      	ldr	r3, [sp, #12]
 8026512:	2b00      	cmp	r3, #0
 8026514:	dbf4      	blt.n	8026500 <prvProcessReceivedCommands+0x4>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 8026516:	9c05      	ldr	r4, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 8026518:	6963      	ldr	r3, [r4, #20]
 802651a:	b113      	cbz	r3, 8026522 <prvProcessReceivedCommands+0x26>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 802651c:	1d20      	adds	r0, r4, #4
 802651e:	f7fe f975 	bl	802480c <uxListRemove>
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8026522:	a802      	add	r0, sp, #8
 8026524:	f7ff ff64 	bl	80263f0 <prvSampleTimeNow>
			switch( xMessage.xMessageID )
 8026528:	9b03      	ldr	r3, [sp, #12]
 802652a:	2b09      	cmp	r3, #9
 802652c:	d8e8      	bhi.n	8026500 <prvProcessReceivedCommands+0x4>
 802652e:	e8df f003 	tbb	[pc, r3]
 8026532:	0505      	.short	0x0505
 8026534:	50373005 	.word	0x50373005
 8026538:	37300505 	.word	0x37300505
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 802653c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8026540:	f043 0301 	orr.w	r3, r3, #1
 8026544:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8026548:	9b04      	ldr	r3, [sp, #16]
 802654a:	69a1      	ldr	r1, [r4, #24]
 802654c:	4602      	mov	r2, r0
 802654e:	4419      	add	r1, r3
 8026550:	4620      	mov	r0, r4
 8026552:	f7ff fe1d 	bl	8026190 <prvInsertTimerInActiveList>
 8026556:	2800      	cmp	r0, #0
 8026558:	d0d2      	beq.n	8026500 <prvProcessReceivedCommands+0x4>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 802655a:	6a23      	ldr	r3, [r4, #32]
 802655c:	4620      	mov	r0, r4
 802655e:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8026560:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8026564:	f013 0f04 	tst.w	r3, #4
 8026568:	d0ca      	beq.n	8026500 <prvProcessReceivedCommands+0x4>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 802656a:	69a2      	ldr	r2, [r4, #24]
 802656c:	2100      	movs	r1, #0
 802656e:	9100      	str	r1, [sp, #0]
 8026570:	460b      	mov	r3, r1
 8026572:	9804      	ldr	r0, [sp, #16]
 8026574:	4402      	add	r2, r0
 8026576:	4620      	mov	r0, r4
 8026578:	f7ff fec6 	bl	8026308 <xTimerGenericCommand>
							configASSERT( xResult );
 802657c:	2800      	cmp	r0, #0
 802657e:	d1bf      	bne.n	8026500 <prvProcessReceivedCommands+0x4>
 8026580:	f04f 0350 	mov.w	r3, #80	; 0x50
 8026584:	f383 8811 	msr	BASEPRI, r3
 8026588:	f3bf 8f6f 	isb	sy
 802658c:	f3bf 8f4f 	dsb	sy
 8026590:	e7fe      	b.n	8026590 <prvProcessReceivedCommands+0x94>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 8026592:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8026596:	f023 0301 	bic.w	r3, r3, #1
 802659a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					break;
 802659e:	e7af      	b.n	8026500 <prvProcessReceivedCommands+0x4>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80265a0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80265a4:	f043 0301 	orr.w	r3, r3, #1
 80265a8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80265ac:	9904      	ldr	r1, [sp, #16]
 80265ae:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80265b0:	b131      	cbz	r1, 80265c0 <prvProcessReceivedCommands+0xc4>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80265b2:	4603      	mov	r3, r0
 80265b4:	4602      	mov	r2, r0
 80265b6:	4401      	add	r1, r0
 80265b8:	4620      	mov	r0, r4
 80265ba:	f7ff fde9 	bl	8026190 <prvInsertTimerInActiveList>
					break;
 80265be:	e79f      	b.n	8026500 <prvProcessReceivedCommands+0x4>
 80265c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80265c4:	f383 8811 	msr	BASEPRI, r3
 80265c8:	f3bf 8f6f 	isb	sy
 80265cc:	f3bf 8f4f 	dsb	sy
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80265d0:	e7fe      	b.n	80265d0 <prvProcessReceivedCommands+0xd4>
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 80265d2:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80265d6:	f013 0f02 	tst.w	r3, #2
 80265da:	d004      	beq.n	80265e6 <prvProcessReceivedCommands+0xea>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 80265dc:	f023 0301 	bic.w	r3, r3, #1
 80265e0:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
 80265e4:	e78c      	b.n	8026500 <prvProcessReceivedCommands+0x4>
							vPortFree( pxTimer );
 80265e6:	4620      	mov	r0, r4
 80265e8:	f7fe f8a6 	bl	8024738 <vPortFree>
 80265ec:	e788      	b.n	8026500 <prvProcessReceivedCommands+0x4>
}
 80265ee:	b006      	add	sp, #24
 80265f0:	bd10      	pop	{r4, pc}
 80265f2:	bf00      	nop
 80265f4:	20011d94 	.word	0x20011d94

080265f8 <prvTimerTask>:
{
 80265f8:	b500      	push	{lr}
 80265fa:	b083      	sub	sp, #12
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 80265fc:	a801      	add	r0, sp, #4
 80265fe:	f7ff fdb7 	bl	8026170 <prvGetNextExpireTime>
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 8026602:	9901      	ldr	r1, [sp, #4]
 8026604:	f7ff ff40 	bl	8026488 <prvProcessTimerOrBlockTask>
		prvProcessReceivedCommands();
 8026608:	f7ff ff78 	bl	80264fc <prvProcessReceivedCommands>
	for( ;; )
 802660c:	e7f6      	b.n	80265fc <prvTimerTask+0x4>
	...

08026610 <srand>:
 8026610:	4b03      	ldr	r3, [pc, #12]	; (8026620 <srand+0x10>)
 8026612:	681b      	ldr	r3, [r3, #0]
 8026614:	2200      	movs	r2, #0
 8026616:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
 802661a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 802661e:	4770      	bx	lr
 8026620:	20000380 	.word	0x20000380

08026624 <rand>:
 8026624:	4b0a      	ldr	r3, [pc, #40]	; (8026650 <rand+0x2c>)
 8026626:	480b      	ldr	r0, [pc, #44]	; (8026654 <rand+0x30>)
 8026628:	6819      	ldr	r1, [r3, #0]
 802662a:	4a0b      	ldr	r2, [pc, #44]	; (8026658 <rand+0x34>)
 802662c:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
 8026630:	b510      	push	{r4, lr}
 8026632:	f8d1 409c 	ldr.w	r4, [r1, #156]	; 0x9c
 8026636:	4358      	muls	r0, r3
 8026638:	fb02 0004 	mla	r0, r2, r4, r0
 802663c:	fba3 3202 	umull	r3, r2, r3, r2
 8026640:	3301      	adds	r3, #1
 8026642:	eb40 0002 	adc.w	r0, r0, r2
 8026646:	e9c1 3026 	strd	r3, r0, [r1, #152]	; 0x98
 802664a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 802664e:	bd10      	pop	{r4, pc}
 8026650:	20000380 	.word	0x20000380
 8026654:	5851f42d 	.word	0x5851f42d
 8026658:	4c957f2d 	.word	0x4c957f2d

0802665c <std>:
 802665c:	2300      	movs	r3, #0
 802665e:	b510      	push	{r4, lr}
 8026660:	4604      	mov	r4, r0
 8026662:	e9c0 3300 	strd	r3, r3, [r0]
 8026666:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802666a:	6083      	str	r3, [r0, #8]
 802666c:	8181      	strh	r1, [r0, #12]
 802666e:	6643      	str	r3, [r0, #100]	; 0x64
 8026670:	81c2      	strh	r2, [r0, #14]
 8026672:	6183      	str	r3, [r0, #24]
 8026674:	4619      	mov	r1, r3
 8026676:	2208      	movs	r2, #8
 8026678:	305c      	adds	r0, #92	; 0x5c
 802667a:	f000 f958 	bl	802692e <memset>
 802667e:	4b0d      	ldr	r3, [pc, #52]	; (80266b4 <std+0x58>)
 8026680:	6223      	str	r3, [r4, #32]
 8026682:	4b0d      	ldr	r3, [pc, #52]	; (80266b8 <std+0x5c>)
 8026684:	6263      	str	r3, [r4, #36]	; 0x24
 8026686:	4b0d      	ldr	r3, [pc, #52]	; (80266bc <std+0x60>)
 8026688:	62a3      	str	r3, [r4, #40]	; 0x28
 802668a:	4b0d      	ldr	r3, [pc, #52]	; (80266c0 <std+0x64>)
 802668c:	62e3      	str	r3, [r4, #44]	; 0x2c
 802668e:	4b0d      	ldr	r3, [pc, #52]	; (80266c4 <std+0x68>)
 8026690:	61e4      	str	r4, [r4, #28]
 8026692:	429c      	cmp	r4, r3
 8026694:	d006      	beq.n	80266a4 <std+0x48>
 8026696:	f103 0268 	add.w	r2, r3, #104	; 0x68
 802669a:	4294      	cmp	r4, r2
 802669c:	d002      	beq.n	80266a4 <std+0x48>
 802669e:	33d0      	adds	r3, #208	; 0xd0
 80266a0:	429c      	cmp	r4, r3
 80266a2:	d105      	bne.n	80266b0 <std+0x54>
 80266a4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80266a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80266ac:	f000 ba10 	b.w	8026ad0 <__retarget_lock_init_recursive>
 80266b0:	bd10      	pop	{r4, pc}
 80266b2:	bf00      	nop
 80266b4:	08026889 	.word	0x08026889
 80266b8:	080268ab 	.word	0x080268ab
 80266bc:	080268e3 	.word	0x080268e3
 80266c0:	08026907 	.word	0x08026907
 80266c4:	20011d9c 	.word	0x20011d9c

080266c8 <stdio_exit_handler>:
 80266c8:	4a02      	ldr	r2, [pc, #8]	; (80266d4 <stdio_exit_handler+0xc>)
 80266ca:	4903      	ldr	r1, [pc, #12]	; (80266d8 <stdio_exit_handler+0x10>)
 80266cc:	4803      	ldr	r0, [pc, #12]	; (80266dc <stdio_exit_handler+0x14>)
 80266ce:	f000 b869 	b.w	80267a4 <_fwalk_sglue>
 80266d2:	bf00      	nop
 80266d4:	20000254 	.word	0x20000254
 80266d8:	080285b5 	.word	0x080285b5
 80266dc:	20000260 	.word	0x20000260

080266e0 <cleanup_stdio>:
 80266e0:	6841      	ldr	r1, [r0, #4]
 80266e2:	4b0c      	ldr	r3, [pc, #48]	; (8026714 <cleanup_stdio+0x34>)
 80266e4:	4299      	cmp	r1, r3
 80266e6:	b510      	push	{r4, lr}
 80266e8:	4604      	mov	r4, r0
 80266ea:	d001      	beq.n	80266f0 <cleanup_stdio+0x10>
 80266ec:	f001 ff62 	bl	80285b4 <_fclose_r>
 80266f0:	68a1      	ldr	r1, [r4, #8]
 80266f2:	4b09      	ldr	r3, [pc, #36]	; (8026718 <cleanup_stdio+0x38>)
 80266f4:	4299      	cmp	r1, r3
 80266f6:	d002      	beq.n	80266fe <cleanup_stdio+0x1e>
 80266f8:	4620      	mov	r0, r4
 80266fa:	f001 ff5b 	bl	80285b4 <_fclose_r>
 80266fe:	68e1      	ldr	r1, [r4, #12]
 8026700:	4b06      	ldr	r3, [pc, #24]	; (802671c <cleanup_stdio+0x3c>)
 8026702:	4299      	cmp	r1, r3
 8026704:	d004      	beq.n	8026710 <cleanup_stdio+0x30>
 8026706:	4620      	mov	r0, r4
 8026708:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802670c:	f001 bf52 	b.w	80285b4 <_fclose_r>
 8026710:	bd10      	pop	{r4, pc}
 8026712:	bf00      	nop
 8026714:	20011d9c 	.word	0x20011d9c
 8026718:	20011e04 	.word	0x20011e04
 802671c:	20011e6c 	.word	0x20011e6c

08026720 <global_stdio_init.part.0>:
 8026720:	b510      	push	{r4, lr}
 8026722:	4b0b      	ldr	r3, [pc, #44]	; (8026750 <global_stdio_init.part.0+0x30>)
 8026724:	4c0b      	ldr	r4, [pc, #44]	; (8026754 <global_stdio_init.part.0+0x34>)
 8026726:	4a0c      	ldr	r2, [pc, #48]	; (8026758 <global_stdio_init.part.0+0x38>)
 8026728:	601a      	str	r2, [r3, #0]
 802672a:	4620      	mov	r0, r4
 802672c:	2200      	movs	r2, #0
 802672e:	2104      	movs	r1, #4
 8026730:	f7ff ff94 	bl	802665c <std>
 8026734:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8026738:	2201      	movs	r2, #1
 802673a:	2109      	movs	r1, #9
 802673c:	f7ff ff8e 	bl	802665c <std>
 8026740:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
 8026744:	2202      	movs	r2, #2
 8026746:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802674a:	2112      	movs	r1, #18
 802674c:	f7ff bf86 	b.w	802665c <std>
 8026750:	20011ed4 	.word	0x20011ed4
 8026754:	20011d9c 	.word	0x20011d9c
 8026758:	080266c9 	.word	0x080266c9

0802675c <__sfp_lock_acquire>:
 802675c:	4801      	ldr	r0, [pc, #4]	; (8026764 <__sfp_lock_acquire+0x8>)
 802675e:	f000 b9b9 	b.w	8026ad4 <__retarget_lock_acquire_recursive>
 8026762:	bf00      	nop
 8026764:	20011ede 	.word	0x20011ede

08026768 <__sfp_lock_release>:
 8026768:	4801      	ldr	r0, [pc, #4]	; (8026770 <__sfp_lock_release+0x8>)
 802676a:	f000 b9b4 	b.w	8026ad6 <__retarget_lock_release_recursive>
 802676e:	bf00      	nop
 8026770:	20011ede 	.word	0x20011ede

08026774 <__sinit>:
 8026774:	b510      	push	{r4, lr}
 8026776:	4604      	mov	r4, r0
 8026778:	f7ff fff0 	bl	802675c <__sfp_lock_acquire>
 802677c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802677e:	b11b      	cbz	r3, 8026788 <__sinit+0x14>
 8026780:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8026784:	f7ff bff0 	b.w	8026768 <__sfp_lock_release>
 8026788:	4b04      	ldr	r3, [pc, #16]	; (802679c <__sinit+0x28>)
 802678a:	6363      	str	r3, [r4, #52]	; 0x34
 802678c:	4b04      	ldr	r3, [pc, #16]	; (80267a0 <__sinit+0x2c>)
 802678e:	681b      	ldr	r3, [r3, #0]
 8026790:	2b00      	cmp	r3, #0
 8026792:	d1f5      	bne.n	8026780 <__sinit+0xc>
 8026794:	f7ff ffc4 	bl	8026720 <global_stdio_init.part.0>
 8026798:	e7f2      	b.n	8026780 <__sinit+0xc>
 802679a:	bf00      	nop
 802679c:	080266e1 	.word	0x080266e1
 80267a0:	20011ed4 	.word	0x20011ed4

080267a4 <_fwalk_sglue>:
 80267a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80267a8:	4607      	mov	r7, r0
 80267aa:	4688      	mov	r8, r1
 80267ac:	4614      	mov	r4, r2
 80267ae:	2600      	movs	r6, #0
 80267b0:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80267b4:	f1b9 0901 	subs.w	r9, r9, #1
 80267b8:	d505      	bpl.n	80267c6 <_fwalk_sglue+0x22>
 80267ba:	6824      	ldr	r4, [r4, #0]
 80267bc:	2c00      	cmp	r4, #0
 80267be:	d1f7      	bne.n	80267b0 <_fwalk_sglue+0xc>
 80267c0:	4630      	mov	r0, r6
 80267c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80267c6:	89ab      	ldrh	r3, [r5, #12]
 80267c8:	2b01      	cmp	r3, #1
 80267ca:	d907      	bls.n	80267dc <_fwalk_sglue+0x38>
 80267cc:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80267d0:	3301      	adds	r3, #1
 80267d2:	d003      	beq.n	80267dc <_fwalk_sglue+0x38>
 80267d4:	4629      	mov	r1, r5
 80267d6:	4638      	mov	r0, r7
 80267d8:	47c0      	blx	r8
 80267da:	4306      	orrs	r6, r0
 80267dc:	3568      	adds	r5, #104	; 0x68
 80267de:	e7e9      	b.n	80267b4 <_fwalk_sglue+0x10>

080267e0 <snprintf>:
 80267e0:	b40c      	push	{r2, r3}
 80267e2:	b530      	push	{r4, r5, lr}
 80267e4:	4b17      	ldr	r3, [pc, #92]	; (8026844 <snprintf+0x64>)
 80267e6:	1e0c      	subs	r4, r1, #0
 80267e8:	681d      	ldr	r5, [r3, #0]
 80267ea:	b09d      	sub	sp, #116	; 0x74
 80267ec:	da08      	bge.n	8026800 <snprintf+0x20>
 80267ee:	238b      	movs	r3, #139	; 0x8b
 80267f0:	602b      	str	r3, [r5, #0]
 80267f2:	f04f 30ff 	mov.w	r0, #4294967295
 80267f6:	b01d      	add	sp, #116	; 0x74
 80267f8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80267fc:	b002      	add	sp, #8
 80267fe:	4770      	bx	lr
 8026800:	f44f 7302 	mov.w	r3, #520	; 0x208
 8026804:	f8ad 3014 	strh.w	r3, [sp, #20]
 8026808:	bf14      	ite	ne
 802680a:	f104 33ff 	addne.w	r3, r4, #4294967295
 802680e:	4623      	moveq	r3, r4
 8026810:	9304      	str	r3, [sp, #16]
 8026812:	9307      	str	r3, [sp, #28]
 8026814:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8026818:	9002      	str	r0, [sp, #8]
 802681a:	9006      	str	r0, [sp, #24]
 802681c:	f8ad 3016 	strh.w	r3, [sp, #22]
 8026820:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8026822:	ab21      	add	r3, sp, #132	; 0x84
 8026824:	a902      	add	r1, sp, #8
 8026826:	4628      	mov	r0, r5
 8026828:	9301      	str	r3, [sp, #4]
 802682a:	f000 fcd5 	bl	80271d8 <_svfprintf_r>
 802682e:	1c43      	adds	r3, r0, #1
 8026830:	bfbc      	itt	lt
 8026832:	238b      	movlt	r3, #139	; 0x8b
 8026834:	602b      	strlt	r3, [r5, #0]
 8026836:	2c00      	cmp	r4, #0
 8026838:	d0dd      	beq.n	80267f6 <snprintf+0x16>
 802683a:	9b02      	ldr	r3, [sp, #8]
 802683c:	2200      	movs	r2, #0
 802683e:	701a      	strb	r2, [r3, #0]
 8026840:	e7d9      	b.n	80267f6 <snprintf+0x16>
 8026842:	bf00      	nop
 8026844:	20000380 	.word	0x20000380

08026848 <sprintf>:
 8026848:	b40e      	push	{r1, r2, r3}
 802684a:	b500      	push	{lr}
 802684c:	b09c      	sub	sp, #112	; 0x70
 802684e:	ab1d      	add	r3, sp, #116	; 0x74
 8026850:	9002      	str	r0, [sp, #8]
 8026852:	9006      	str	r0, [sp, #24]
 8026854:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8026858:	4809      	ldr	r0, [pc, #36]	; (8026880 <sprintf+0x38>)
 802685a:	9107      	str	r1, [sp, #28]
 802685c:	9104      	str	r1, [sp, #16]
 802685e:	4909      	ldr	r1, [pc, #36]	; (8026884 <sprintf+0x3c>)
 8026860:	f853 2b04 	ldr.w	r2, [r3], #4
 8026864:	9105      	str	r1, [sp, #20]
 8026866:	6800      	ldr	r0, [r0, #0]
 8026868:	9301      	str	r3, [sp, #4]
 802686a:	a902      	add	r1, sp, #8
 802686c:	f000 fcb4 	bl	80271d8 <_svfprintf_r>
 8026870:	9b02      	ldr	r3, [sp, #8]
 8026872:	2200      	movs	r2, #0
 8026874:	701a      	strb	r2, [r3, #0]
 8026876:	b01c      	add	sp, #112	; 0x70
 8026878:	f85d eb04 	ldr.w	lr, [sp], #4
 802687c:	b003      	add	sp, #12
 802687e:	4770      	bx	lr
 8026880:	20000380 	.word	0x20000380
 8026884:	ffff0208 	.word	0xffff0208

08026888 <__sread>:
 8026888:	b510      	push	{r4, lr}
 802688a:	460c      	mov	r4, r1
 802688c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8026890:	f000 f8d0 	bl	8026a34 <_read_r>
 8026894:	2800      	cmp	r0, #0
 8026896:	bfab      	itete	ge
 8026898:	6d23      	ldrge	r3, [r4, #80]	; 0x50
 802689a:	89a3      	ldrhlt	r3, [r4, #12]
 802689c:	181b      	addge	r3, r3, r0
 802689e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 80268a2:	bfac      	ite	ge
 80268a4:	6523      	strge	r3, [r4, #80]	; 0x50
 80268a6:	81a3      	strhlt	r3, [r4, #12]
 80268a8:	bd10      	pop	{r4, pc}

080268aa <__swrite>:
 80268aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80268ae:	461f      	mov	r7, r3
 80268b0:	898b      	ldrh	r3, [r1, #12]
 80268b2:	05db      	lsls	r3, r3, #23
 80268b4:	4605      	mov	r5, r0
 80268b6:	460c      	mov	r4, r1
 80268b8:	4616      	mov	r6, r2
 80268ba:	d505      	bpl.n	80268c8 <__swrite+0x1e>
 80268bc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80268c0:	2302      	movs	r3, #2
 80268c2:	2200      	movs	r2, #0
 80268c4:	f000 f8a4 	bl	8026a10 <_lseek_r>
 80268c8:	89a3      	ldrh	r3, [r4, #12]
 80268ca:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80268ce:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80268d2:	81a3      	strh	r3, [r4, #12]
 80268d4:	4632      	mov	r2, r6
 80268d6:	463b      	mov	r3, r7
 80268d8:	4628      	mov	r0, r5
 80268da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80268de:	f000 b8bb 	b.w	8026a58 <_write_r>

080268e2 <__sseek>:
 80268e2:	b510      	push	{r4, lr}
 80268e4:	460c      	mov	r4, r1
 80268e6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80268ea:	f000 f891 	bl	8026a10 <_lseek_r>
 80268ee:	1c43      	adds	r3, r0, #1
 80268f0:	89a3      	ldrh	r3, [r4, #12]
 80268f2:	bf15      	itete	ne
 80268f4:	6520      	strne	r0, [r4, #80]	; 0x50
 80268f6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80268fa:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80268fe:	81a3      	strheq	r3, [r4, #12]
 8026900:	bf18      	it	ne
 8026902:	81a3      	strhne	r3, [r4, #12]
 8026904:	bd10      	pop	{r4, pc}

08026906 <__sclose>:
 8026906:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802690a:	f000 b871 	b.w	80269f0 <_close_r>

0802690e <memcmp>:
 802690e:	b510      	push	{r4, lr}
 8026910:	3901      	subs	r1, #1
 8026912:	4402      	add	r2, r0
 8026914:	4290      	cmp	r0, r2
 8026916:	d101      	bne.n	802691c <memcmp+0xe>
 8026918:	2000      	movs	r0, #0
 802691a:	e005      	b.n	8026928 <memcmp+0x1a>
 802691c:	7803      	ldrb	r3, [r0, #0]
 802691e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8026922:	42a3      	cmp	r3, r4
 8026924:	d001      	beq.n	802692a <memcmp+0x1c>
 8026926:	1b18      	subs	r0, r3, r4
 8026928:	bd10      	pop	{r4, pc}
 802692a:	3001      	adds	r0, #1
 802692c:	e7f2      	b.n	8026914 <memcmp+0x6>

0802692e <memset>:
 802692e:	4402      	add	r2, r0
 8026930:	4603      	mov	r3, r0
 8026932:	4293      	cmp	r3, r2
 8026934:	d100      	bne.n	8026938 <memset+0xa>
 8026936:	4770      	bx	lr
 8026938:	f803 1b01 	strb.w	r1, [r3], #1
 802693c:	e7f9      	b.n	8026932 <memset+0x4>

0802693e <strncmp>:
 802693e:	b510      	push	{r4, lr}
 8026940:	b16a      	cbz	r2, 802695e <strncmp+0x20>
 8026942:	3901      	subs	r1, #1
 8026944:	1884      	adds	r4, r0, r2
 8026946:	f810 2b01 	ldrb.w	r2, [r0], #1
 802694a:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 802694e:	429a      	cmp	r2, r3
 8026950:	d103      	bne.n	802695a <strncmp+0x1c>
 8026952:	42a0      	cmp	r0, r4
 8026954:	d001      	beq.n	802695a <strncmp+0x1c>
 8026956:	2a00      	cmp	r2, #0
 8026958:	d1f5      	bne.n	8026946 <strncmp+0x8>
 802695a:	1ad0      	subs	r0, r2, r3
 802695c:	bd10      	pop	{r4, pc}
 802695e:	4610      	mov	r0, r2
 8026960:	e7fc      	b.n	802695c <strncmp+0x1e>
	...

08026964 <strtok>:
 8026964:	4b02      	ldr	r3, [pc, #8]	; (8026970 <strtok+0xc>)
 8026966:	681a      	ldr	r2, [r3, #0]
 8026968:	2301      	movs	r3, #1
 802696a:	3250      	adds	r2, #80	; 0x50
 802696c:	f000 b802 	b.w	8026974 <__strtok_r>
 8026970:	20000380 	.word	0x20000380

08026974 <__strtok_r>:
 8026974:	b5f0      	push	{r4, r5, r6, r7, lr}
 8026976:	b908      	cbnz	r0, 802697c <__strtok_r+0x8>
 8026978:	6810      	ldr	r0, [r2, #0]
 802697a:	b188      	cbz	r0, 80269a0 <__strtok_r+0x2c>
 802697c:	4604      	mov	r4, r0
 802697e:	4620      	mov	r0, r4
 8026980:	f814 5b01 	ldrb.w	r5, [r4], #1
 8026984:	460f      	mov	r7, r1
 8026986:	f817 6b01 	ldrb.w	r6, [r7], #1
 802698a:	b91e      	cbnz	r6, 8026994 <__strtok_r+0x20>
 802698c:	b965      	cbnz	r5, 80269a8 <__strtok_r+0x34>
 802698e:	6015      	str	r5, [r2, #0]
 8026990:	4628      	mov	r0, r5
 8026992:	e005      	b.n	80269a0 <__strtok_r+0x2c>
 8026994:	42b5      	cmp	r5, r6
 8026996:	d1f6      	bne.n	8026986 <__strtok_r+0x12>
 8026998:	2b00      	cmp	r3, #0
 802699a:	d1f0      	bne.n	802697e <__strtok_r+0xa>
 802699c:	6014      	str	r4, [r2, #0]
 802699e:	7003      	strb	r3, [r0, #0]
 80269a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80269a2:	461c      	mov	r4, r3
 80269a4:	e00c      	b.n	80269c0 <__strtok_r+0x4c>
 80269a6:	b915      	cbnz	r5, 80269ae <__strtok_r+0x3a>
 80269a8:	f814 3b01 	ldrb.w	r3, [r4], #1
 80269ac:	460e      	mov	r6, r1
 80269ae:	f816 5b01 	ldrb.w	r5, [r6], #1
 80269b2:	42ab      	cmp	r3, r5
 80269b4:	d1f7      	bne.n	80269a6 <__strtok_r+0x32>
 80269b6:	2b00      	cmp	r3, #0
 80269b8:	d0f3      	beq.n	80269a2 <__strtok_r+0x2e>
 80269ba:	2300      	movs	r3, #0
 80269bc:	f804 3c01 	strb.w	r3, [r4, #-1]
 80269c0:	6014      	str	r4, [r2, #0]
 80269c2:	e7ed      	b.n	80269a0 <__strtok_r+0x2c>

080269c4 <strstr>:
 80269c4:	780a      	ldrb	r2, [r1, #0]
 80269c6:	b570      	push	{r4, r5, r6, lr}
 80269c8:	b96a      	cbnz	r2, 80269e6 <strstr+0x22>
 80269ca:	bd70      	pop	{r4, r5, r6, pc}
 80269cc:	429a      	cmp	r2, r3
 80269ce:	d109      	bne.n	80269e4 <strstr+0x20>
 80269d0:	460c      	mov	r4, r1
 80269d2:	4605      	mov	r5, r0
 80269d4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 80269d8:	2b00      	cmp	r3, #0
 80269da:	d0f6      	beq.n	80269ca <strstr+0x6>
 80269dc:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 80269e0:	429e      	cmp	r6, r3
 80269e2:	d0f7      	beq.n	80269d4 <strstr+0x10>
 80269e4:	3001      	adds	r0, #1
 80269e6:	7803      	ldrb	r3, [r0, #0]
 80269e8:	2b00      	cmp	r3, #0
 80269ea:	d1ef      	bne.n	80269cc <strstr+0x8>
 80269ec:	4618      	mov	r0, r3
 80269ee:	e7ec      	b.n	80269ca <strstr+0x6>

080269f0 <_close_r>:
 80269f0:	b538      	push	{r3, r4, r5, lr}
 80269f2:	4d06      	ldr	r5, [pc, #24]	; (8026a0c <_close_r+0x1c>)
 80269f4:	2300      	movs	r3, #0
 80269f6:	4604      	mov	r4, r0
 80269f8:	4608      	mov	r0, r1
 80269fa:	602b      	str	r3, [r5, #0]
 80269fc:	f7da ff18 	bl	8001830 <_close>
 8026a00:	1c43      	adds	r3, r0, #1
 8026a02:	d102      	bne.n	8026a0a <_close_r+0x1a>
 8026a04:	682b      	ldr	r3, [r5, #0]
 8026a06:	b103      	cbz	r3, 8026a0a <_close_r+0x1a>
 8026a08:	6023      	str	r3, [r4, #0]
 8026a0a:	bd38      	pop	{r3, r4, r5, pc}
 8026a0c:	20011ed8 	.word	0x20011ed8

08026a10 <_lseek_r>:
 8026a10:	b538      	push	{r3, r4, r5, lr}
 8026a12:	4d07      	ldr	r5, [pc, #28]	; (8026a30 <_lseek_r+0x20>)
 8026a14:	4604      	mov	r4, r0
 8026a16:	4608      	mov	r0, r1
 8026a18:	4611      	mov	r1, r2
 8026a1a:	2200      	movs	r2, #0
 8026a1c:	602a      	str	r2, [r5, #0]
 8026a1e:	461a      	mov	r2, r3
 8026a20:	f7da ff10 	bl	8001844 <_lseek>
 8026a24:	1c43      	adds	r3, r0, #1
 8026a26:	d102      	bne.n	8026a2e <_lseek_r+0x1e>
 8026a28:	682b      	ldr	r3, [r5, #0]
 8026a2a:	b103      	cbz	r3, 8026a2e <_lseek_r+0x1e>
 8026a2c:	6023      	str	r3, [r4, #0]
 8026a2e:	bd38      	pop	{r3, r4, r5, pc}
 8026a30:	20011ed8 	.word	0x20011ed8

08026a34 <_read_r>:
 8026a34:	b538      	push	{r3, r4, r5, lr}
 8026a36:	4d07      	ldr	r5, [pc, #28]	; (8026a54 <_read_r+0x20>)
 8026a38:	4604      	mov	r4, r0
 8026a3a:	4608      	mov	r0, r1
 8026a3c:	4611      	mov	r1, r2
 8026a3e:	2200      	movs	r2, #0
 8026a40:	602a      	str	r2, [r5, #0]
 8026a42:	461a      	mov	r2, r3
 8026a44:	f7da fed6 	bl	80017f4 <_read>
 8026a48:	1c43      	adds	r3, r0, #1
 8026a4a:	d102      	bne.n	8026a52 <_read_r+0x1e>
 8026a4c:	682b      	ldr	r3, [r5, #0]
 8026a4e:	b103      	cbz	r3, 8026a52 <_read_r+0x1e>
 8026a50:	6023      	str	r3, [r4, #0]
 8026a52:	bd38      	pop	{r3, r4, r5, pc}
 8026a54:	20011ed8 	.word	0x20011ed8

08026a58 <_write_r>:
 8026a58:	b538      	push	{r3, r4, r5, lr}
 8026a5a:	4d07      	ldr	r5, [pc, #28]	; (8026a78 <_write_r+0x20>)
 8026a5c:	4604      	mov	r4, r0
 8026a5e:	4608      	mov	r0, r1
 8026a60:	4611      	mov	r1, r2
 8026a62:	2200      	movs	r2, #0
 8026a64:	602a      	str	r2, [r5, #0]
 8026a66:	461a      	mov	r2, r3
 8026a68:	f7da fed4 	bl	8001814 <_write>
 8026a6c:	1c43      	adds	r3, r0, #1
 8026a6e:	d102      	bne.n	8026a76 <_write_r+0x1e>
 8026a70:	682b      	ldr	r3, [r5, #0]
 8026a72:	b103      	cbz	r3, 8026a76 <_write_r+0x1e>
 8026a74:	6023      	str	r3, [r4, #0]
 8026a76:	bd38      	pop	{r3, r4, r5, pc}
 8026a78:	20011ed8 	.word	0x20011ed8

08026a7c <__errno>:
 8026a7c:	4b01      	ldr	r3, [pc, #4]	; (8026a84 <__errno+0x8>)
 8026a7e:	6818      	ldr	r0, [r3, #0]
 8026a80:	4770      	bx	lr
 8026a82:	bf00      	nop
 8026a84:	20000380 	.word	0x20000380

08026a88 <__libc_init_array>:
 8026a88:	b570      	push	{r4, r5, r6, lr}
 8026a8a:	4d0d      	ldr	r5, [pc, #52]	; (8026ac0 <__libc_init_array+0x38>)
 8026a8c:	4c0d      	ldr	r4, [pc, #52]	; (8026ac4 <__libc_init_array+0x3c>)
 8026a8e:	1b64      	subs	r4, r4, r5
 8026a90:	10a4      	asrs	r4, r4, #2
 8026a92:	2600      	movs	r6, #0
 8026a94:	42a6      	cmp	r6, r4
 8026a96:	d109      	bne.n	8026aac <__libc_init_array+0x24>
 8026a98:	4d0b      	ldr	r5, [pc, #44]	; (8026ac8 <__libc_init_array+0x40>)
 8026a9a:	4c0c      	ldr	r4, [pc, #48]	; (8026acc <__libc_init_array+0x44>)
 8026a9c:	f004 fbee 	bl	802b27c <_init>
 8026aa0:	1b64      	subs	r4, r4, r5
 8026aa2:	10a4      	asrs	r4, r4, #2
 8026aa4:	2600      	movs	r6, #0
 8026aa6:	42a6      	cmp	r6, r4
 8026aa8:	d105      	bne.n	8026ab6 <__libc_init_array+0x2e>
 8026aaa:	bd70      	pop	{r4, r5, r6, pc}
 8026aac:	f855 3b04 	ldr.w	r3, [r5], #4
 8026ab0:	4798      	blx	r3
 8026ab2:	3601      	adds	r6, #1
 8026ab4:	e7ee      	b.n	8026a94 <__libc_init_array+0xc>
 8026ab6:	f855 3b04 	ldr.w	r3, [r5], #4
 8026aba:	4798      	blx	r3
 8026abc:	3601      	adds	r6, #1
 8026abe:	e7f2      	b.n	8026aa6 <__libc_init_array+0x1e>
 8026ac0:	080377d8 	.word	0x080377d8
 8026ac4:	080377d8 	.word	0x080377d8
 8026ac8:	080377d8 	.word	0x080377d8
 8026acc:	080377e0 	.word	0x080377e0

08026ad0 <__retarget_lock_init_recursive>:
 8026ad0:	4770      	bx	lr

08026ad2 <__retarget_lock_close_recursive>:
 8026ad2:	4770      	bx	lr

08026ad4 <__retarget_lock_acquire_recursive>:
 8026ad4:	4770      	bx	lr

08026ad6 <__retarget_lock_release_recursive>:
 8026ad6:	4770      	bx	lr

08026ad8 <strcpy>:
 8026ad8:	4603      	mov	r3, r0
 8026ada:	f811 2b01 	ldrb.w	r2, [r1], #1
 8026ade:	f803 2b01 	strb.w	r2, [r3], #1
 8026ae2:	2a00      	cmp	r2, #0
 8026ae4:	d1f9      	bne.n	8026ada <strcpy+0x2>
 8026ae6:	4770      	bx	lr

08026ae8 <memcpy>:
 8026ae8:	440a      	add	r2, r1
 8026aea:	4291      	cmp	r1, r2
 8026aec:	f100 33ff 	add.w	r3, r0, #4294967295
 8026af0:	d100      	bne.n	8026af4 <memcpy+0xc>
 8026af2:	4770      	bx	lr
 8026af4:	b510      	push	{r4, lr}
 8026af6:	f811 4b01 	ldrb.w	r4, [r1], #1
 8026afa:	f803 4f01 	strb.w	r4, [r3, #1]!
 8026afe:	4291      	cmp	r1, r2
 8026b00:	d1f9      	bne.n	8026af6 <memcpy+0xe>
 8026b02:	bd10      	pop	{r4, pc}

08026b04 <register_fini>:
 8026b04:	4b02      	ldr	r3, [pc, #8]	; (8026b10 <register_fini+0xc>)
 8026b06:	b113      	cbz	r3, 8026b0e <register_fini+0xa>
 8026b08:	4802      	ldr	r0, [pc, #8]	; (8026b14 <register_fini+0x10>)
 8026b0a:	f000 b805 	b.w	8026b18 <atexit>
 8026b0e:	4770      	bx	lr
 8026b10:	00000000 	.word	0x00000000
 8026b14:	08028825 	.word	0x08028825

08026b18 <atexit>:
 8026b18:	2300      	movs	r3, #0
 8026b1a:	4601      	mov	r1, r0
 8026b1c:	461a      	mov	r2, r3
 8026b1e:	4618      	mov	r0, r3
 8026b20:	f001 bed8 	b.w	80288d4 <__register_exitproc>

08026b24 <_malloc_trim_r>:
 8026b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8026b28:	4606      	mov	r6, r0
 8026b2a:	2008      	movs	r0, #8
 8026b2c:	460c      	mov	r4, r1
 8026b2e:	f001 fe8d 	bl	802884c <sysconf>
 8026b32:	4f23      	ldr	r7, [pc, #140]	; (8026bc0 <_malloc_trim_r+0x9c>)
 8026b34:	4680      	mov	r8, r0
 8026b36:	4630      	mov	r0, r6
 8026b38:	f000 fb42 	bl	80271c0 <__malloc_lock>
 8026b3c:	68bb      	ldr	r3, [r7, #8]
 8026b3e:	685d      	ldr	r5, [r3, #4]
 8026b40:	f025 0503 	bic.w	r5, r5, #3
 8026b44:	1b2c      	subs	r4, r5, r4
 8026b46:	3c11      	subs	r4, #17
 8026b48:	4444      	add	r4, r8
 8026b4a:	fbb4 f4f8 	udiv	r4, r4, r8
 8026b4e:	3c01      	subs	r4, #1
 8026b50:	fb08 f404 	mul.w	r4, r8, r4
 8026b54:	45a0      	cmp	r8, r4
 8026b56:	dd05      	ble.n	8026b64 <_malloc_trim_r+0x40>
 8026b58:	4630      	mov	r0, r6
 8026b5a:	f000 fb37 	bl	80271cc <__malloc_unlock>
 8026b5e:	2000      	movs	r0, #0
 8026b60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8026b64:	2100      	movs	r1, #0
 8026b66:	4630      	mov	r0, r6
 8026b68:	f001 fe4c 	bl	8028804 <_sbrk_r>
 8026b6c:	68bb      	ldr	r3, [r7, #8]
 8026b6e:	442b      	add	r3, r5
 8026b70:	4298      	cmp	r0, r3
 8026b72:	d1f1      	bne.n	8026b58 <_malloc_trim_r+0x34>
 8026b74:	4261      	negs	r1, r4
 8026b76:	4630      	mov	r0, r6
 8026b78:	f001 fe44 	bl	8028804 <_sbrk_r>
 8026b7c:	3001      	adds	r0, #1
 8026b7e:	d110      	bne.n	8026ba2 <_malloc_trim_r+0x7e>
 8026b80:	2100      	movs	r1, #0
 8026b82:	4630      	mov	r0, r6
 8026b84:	f001 fe3e 	bl	8028804 <_sbrk_r>
 8026b88:	68ba      	ldr	r2, [r7, #8]
 8026b8a:	1a83      	subs	r3, r0, r2
 8026b8c:	2b0f      	cmp	r3, #15
 8026b8e:	dde3      	ble.n	8026b58 <_malloc_trim_r+0x34>
 8026b90:	490c      	ldr	r1, [pc, #48]	; (8026bc4 <_malloc_trim_r+0xa0>)
 8026b92:	6809      	ldr	r1, [r1, #0]
 8026b94:	1a40      	subs	r0, r0, r1
 8026b96:	490c      	ldr	r1, [pc, #48]	; (8026bc8 <_malloc_trim_r+0xa4>)
 8026b98:	f043 0301 	orr.w	r3, r3, #1
 8026b9c:	6008      	str	r0, [r1, #0]
 8026b9e:	6053      	str	r3, [r2, #4]
 8026ba0:	e7da      	b.n	8026b58 <_malloc_trim_r+0x34>
 8026ba2:	68bb      	ldr	r3, [r7, #8]
 8026ba4:	4a08      	ldr	r2, [pc, #32]	; (8026bc8 <_malloc_trim_r+0xa4>)
 8026ba6:	1b2d      	subs	r5, r5, r4
 8026ba8:	f045 0501 	orr.w	r5, r5, #1
 8026bac:	605d      	str	r5, [r3, #4]
 8026bae:	6813      	ldr	r3, [r2, #0]
 8026bb0:	4630      	mov	r0, r6
 8026bb2:	1b1b      	subs	r3, r3, r4
 8026bb4:	6013      	str	r3, [r2, #0]
 8026bb6:	f000 fb09 	bl	80271cc <__malloc_unlock>
 8026bba:	2001      	movs	r0, #1
 8026bbc:	e7d0      	b.n	8026b60 <_malloc_trim_r+0x3c>
 8026bbe:	bf00      	nop
 8026bc0:	20000388 	.word	0x20000388
 8026bc4:	20000790 	.word	0x20000790
 8026bc8:	20011ee4 	.word	0x20011ee4

08026bcc <_free_r>:
 8026bcc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026bce:	4605      	mov	r5, r0
 8026bd0:	460f      	mov	r7, r1
 8026bd2:	2900      	cmp	r1, #0
 8026bd4:	f000 80b1 	beq.w	8026d3a <_free_r+0x16e>
 8026bd8:	f000 faf2 	bl	80271c0 <__malloc_lock>
 8026bdc:	f857 2c04 	ldr.w	r2, [r7, #-4]
 8026be0:	4856      	ldr	r0, [pc, #344]	; (8026d3c <_free_r+0x170>)
 8026be2:	f022 0401 	bic.w	r4, r2, #1
 8026be6:	f1a7 0308 	sub.w	r3, r7, #8
 8026bea:	eb03 0c04 	add.w	ip, r3, r4
 8026bee:	6881      	ldr	r1, [r0, #8]
 8026bf0:	f8dc 6004 	ldr.w	r6, [ip, #4]
 8026bf4:	4561      	cmp	r1, ip
 8026bf6:	f026 0603 	bic.w	r6, r6, #3
 8026bfa:	f002 0201 	and.w	r2, r2, #1
 8026bfe:	d11b      	bne.n	8026c38 <_free_r+0x6c>
 8026c00:	4426      	add	r6, r4
 8026c02:	b93a      	cbnz	r2, 8026c14 <_free_r+0x48>
 8026c04:	f857 2c08 	ldr.w	r2, [r7, #-8]
 8026c08:	1a9b      	subs	r3, r3, r2
 8026c0a:	4416      	add	r6, r2
 8026c0c:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
 8026c10:	60ca      	str	r2, [r1, #12]
 8026c12:	6091      	str	r1, [r2, #8]
 8026c14:	f046 0201 	orr.w	r2, r6, #1
 8026c18:	605a      	str	r2, [r3, #4]
 8026c1a:	6083      	str	r3, [r0, #8]
 8026c1c:	4b48      	ldr	r3, [pc, #288]	; (8026d40 <_free_r+0x174>)
 8026c1e:	681b      	ldr	r3, [r3, #0]
 8026c20:	42b3      	cmp	r3, r6
 8026c22:	d804      	bhi.n	8026c2e <_free_r+0x62>
 8026c24:	4b47      	ldr	r3, [pc, #284]	; (8026d44 <_free_r+0x178>)
 8026c26:	4628      	mov	r0, r5
 8026c28:	6819      	ldr	r1, [r3, #0]
 8026c2a:	f7ff ff7b 	bl	8026b24 <_malloc_trim_r>
 8026c2e:	4628      	mov	r0, r5
 8026c30:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8026c34:	f000 baca 	b.w	80271cc <__malloc_unlock>
 8026c38:	f8cc 6004 	str.w	r6, [ip, #4]
 8026c3c:	2a00      	cmp	r2, #0
 8026c3e:	d138      	bne.n	8026cb2 <_free_r+0xe6>
 8026c40:	f857 1c08 	ldr.w	r1, [r7, #-8]
 8026c44:	1a5b      	subs	r3, r3, r1
 8026c46:	440c      	add	r4, r1
 8026c48:	6899      	ldr	r1, [r3, #8]
 8026c4a:	f100 0708 	add.w	r7, r0, #8
 8026c4e:	42b9      	cmp	r1, r7
 8026c50:	d031      	beq.n	8026cb6 <_free_r+0xea>
 8026c52:	68df      	ldr	r7, [r3, #12]
 8026c54:	60cf      	str	r7, [r1, #12]
 8026c56:	60b9      	str	r1, [r7, #8]
 8026c58:	eb0c 0106 	add.w	r1, ip, r6
 8026c5c:	6849      	ldr	r1, [r1, #4]
 8026c5e:	07c9      	lsls	r1, r1, #31
 8026c60:	d40b      	bmi.n	8026c7a <_free_r+0xae>
 8026c62:	f8dc 1008 	ldr.w	r1, [ip, #8]
 8026c66:	4434      	add	r4, r6
 8026c68:	bb3a      	cbnz	r2, 8026cba <_free_r+0xee>
 8026c6a:	4e37      	ldr	r6, [pc, #220]	; (8026d48 <_free_r+0x17c>)
 8026c6c:	42b1      	cmp	r1, r6
 8026c6e:	d124      	bne.n	8026cba <_free_r+0xee>
 8026c70:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8026c74:	e9c3 1102 	strd	r1, r1, [r3, #8]
 8026c78:	2201      	movs	r2, #1
 8026c7a:	f044 0101 	orr.w	r1, r4, #1
 8026c7e:	6059      	str	r1, [r3, #4]
 8026c80:	511c      	str	r4, [r3, r4]
 8026c82:	2a00      	cmp	r2, #0
 8026c84:	d1d3      	bne.n	8026c2e <_free_r+0x62>
 8026c86:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
 8026c8a:	d21b      	bcs.n	8026cc4 <_free_r+0xf8>
 8026c8c:	08e2      	lsrs	r2, r4, #3
 8026c8e:	2101      	movs	r1, #1
 8026c90:	0964      	lsrs	r4, r4, #5
 8026c92:	40a1      	lsls	r1, r4
 8026c94:	6844      	ldr	r4, [r0, #4]
 8026c96:	3201      	adds	r2, #1
 8026c98:	4321      	orrs	r1, r4
 8026c9a:	6041      	str	r1, [r0, #4]
 8026c9c:	f850 4032 	ldr.w	r4, [r0, r2, lsl #3]
 8026ca0:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
 8026ca4:	3908      	subs	r1, #8
 8026ca6:	e9c3 4102 	strd	r4, r1, [r3, #8]
 8026caa:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
 8026cae:	60e3      	str	r3, [r4, #12]
 8026cb0:	e7bd      	b.n	8026c2e <_free_r+0x62>
 8026cb2:	2200      	movs	r2, #0
 8026cb4:	e7d0      	b.n	8026c58 <_free_r+0x8c>
 8026cb6:	2201      	movs	r2, #1
 8026cb8:	e7ce      	b.n	8026c58 <_free_r+0x8c>
 8026cba:	f8dc 600c 	ldr.w	r6, [ip, #12]
 8026cbe:	60ce      	str	r6, [r1, #12]
 8026cc0:	60b1      	str	r1, [r6, #8]
 8026cc2:	e7da      	b.n	8026c7a <_free_r+0xae>
 8026cc4:	f5b4 6f20 	cmp.w	r4, #2560	; 0xa00
 8026cc8:	ea4f 2254 	mov.w	r2, r4, lsr #9
 8026ccc:	d214      	bcs.n	8026cf8 <_free_r+0x12c>
 8026cce:	09a2      	lsrs	r2, r4, #6
 8026cd0:	3238      	adds	r2, #56	; 0x38
 8026cd2:	1c51      	adds	r1, r2, #1
 8026cd4:	eb00 06c2 	add.w	r6, r0, r2, lsl #3
 8026cd8:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
 8026cdc:	428e      	cmp	r6, r1
 8026cde:	d125      	bne.n	8026d2c <_free_r+0x160>
 8026ce0:	2401      	movs	r4, #1
 8026ce2:	1092      	asrs	r2, r2, #2
 8026ce4:	fa04 f202 	lsl.w	r2, r4, r2
 8026ce8:	6844      	ldr	r4, [r0, #4]
 8026cea:	4322      	orrs	r2, r4
 8026cec:	6042      	str	r2, [r0, #4]
 8026cee:	e9c3 1602 	strd	r1, r6, [r3, #8]
 8026cf2:	60b3      	str	r3, [r6, #8]
 8026cf4:	60cb      	str	r3, [r1, #12]
 8026cf6:	e79a      	b.n	8026c2e <_free_r+0x62>
 8026cf8:	2a14      	cmp	r2, #20
 8026cfa:	d801      	bhi.n	8026d00 <_free_r+0x134>
 8026cfc:	325b      	adds	r2, #91	; 0x5b
 8026cfe:	e7e8      	b.n	8026cd2 <_free_r+0x106>
 8026d00:	2a54      	cmp	r2, #84	; 0x54
 8026d02:	d802      	bhi.n	8026d0a <_free_r+0x13e>
 8026d04:	0b22      	lsrs	r2, r4, #12
 8026d06:	326e      	adds	r2, #110	; 0x6e
 8026d08:	e7e3      	b.n	8026cd2 <_free_r+0x106>
 8026d0a:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8026d0e:	d802      	bhi.n	8026d16 <_free_r+0x14a>
 8026d10:	0be2      	lsrs	r2, r4, #15
 8026d12:	3277      	adds	r2, #119	; 0x77
 8026d14:	e7dd      	b.n	8026cd2 <_free_r+0x106>
 8026d16:	f240 5154 	movw	r1, #1364	; 0x554
 8026d1a:	428a      	cmp	r2, r1
 8026d1c:	bf9a      	itte	ls
 8026d1e:	0ca2      	lsrls	r2, r4, #18
 8026d20:	327c      	addls	r2, #124	; 0x7c
 8026d22:	227e      	movhi	r2, #126	; 0x7e
 8026d24:	e7d5      	b.n	8026cd2 <_free_r+0x106>
 8026d26:	6889      	ldr	r1, [r1, #8]
 8026d28:	428e      	cmp	r6, r1
 8026d2a:	d004      	beq.n	8026d36 <_free_r+0x16a>
 8026d2c:	684a      	ldr	r2, [r1, #4]
 8026d2e:	f022 0203 	bic.w	r2, r2, #3
 8026d32:	42a2      	cmp	r2, r4
 8026d34:	d8f7      	bhi.n	8026d26 <_free_r+0x15a>
 8026d36:	68ce      	ldr	r6, [r1, #12]
 8026d38:	e7d9      	b.n	8026cee <_free_r+0x122>
 8026d3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8026d3c:	20000388 	.word	0x20000388
 8026d40:	20000794 	.word	0x20000794
 8026d44:	20011f14 	.word	0x20011f14
 8026d48:	20000390 	.word	0x20000390

08026d4c <_malloc_r>:
 8026d4c:	f101 030b 	add.w	r3, r1, #11
 8026d50:	2b16      	cmp	r3, #22
 8026d52:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8026d56:	4605      	mov	r5, r0
 8026d58:	d906      	bls.n	8026d68 <_malloc_r+0x1c>
 8026d5a:	f033 0707 	bics.w	r7, r3, #7
 8026d5e:	d504      	bpl.n	8026d6a <_malloc_r+0x1e>
 8026d60:	230c      	movs	r3, #12
 8026d62:	602b      	str	r3, [r5, #0]
 8026d64:	2400      	movs	r4, #0
 8026d66:	e1a3      	b.n	80270b0 <_malloc_r+0x364>
 8026d68:	2710      	movs	r7, #16
 8026d6a:	42b9      	cmp	r1, r7
 8026d6c:	d8f8      	bhi.n	8026d60 <_malloc_r+0x14>
 8026d6e:	4628      	mov	r0, r5
 8026d70:	f000 fa26 	bl	80271c0 <__malloc_lock>
 8026d74:	f5b7 7ffc 	cmp.w	r7, #504	; 0x1f8
 8026d78:	4eaf      	ldr	r6, [pc, #700]	; (8027038 <_malloc_r+0x2ec>)
 8026d7a:	d237      	bcs.n	8026dec <_malloc_r+0xa0>
 8026d7c:	f107 0208 	add.w	r2, r7, #8
 8026d80:	4432      	add	r2, r6
 8026d82:	f1a2 0108 	sub.w	r1, r2, #8
 8026d86:	6854      	ldr	r4, [r2, #4]
 8026d88:	428c      	cmp	r4, r1
 8026d8a:	ea4f 03d7 	mov.w	r3, r7, lsr #3
 8026d8e:	d102      	bne.n	8026d96 <_malloc_r+0x4a>
 8026d90:	68d4      	ldr	r4, [r2, #12]
 8026d92:	42a2      	cmp	r2, r4
 8026d94:	d010      	beq.n	8026db8 <_malloc_r+0x6c>
 8026d96:	6863      	ldr	r3, [r4, #4]
 8026d98:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 8026d9c:	f023 0303 	bic.w	r3, r3, #3
 8026da0:	60ca      	str	r2, [r1, #12]
 8026da2:	4423      	add	r3, r4
 8026da4:	6091      	str	r1, [r2, #8]
 8026da6:	685a      	ldr	r2, [r3, #4]
 8026da8:	f042 0201 	orr.w	r2, r2, #1
 8026dac:	605a      	str	r2, [r3, #4]
 8026dae:	4628      	mov	r0, r5
 8026db0:	f000 fa0c 	bl	80271cc <__malloc_unlock>
 8026db4:	3408      	adds	r4, #8
 8026db6:	e17b      	b.n	80270b0 <_malloc_r+0x364>
 8026db8:	3302      	adds	r3, #2
 8026dba:	6934      	ldr	r4, [r6, #16]
 8026dbc:	499f      	ldr	r1, [pc, #636]	; (802703c <_malloc_r+0x2f0>)
 8026dbe:	428c      	cmp	r4, r1
 8026dc0:	d077      	beq.n	8026eb2 <_malloc_r+0x166>
 8026dc2:	6862      	ldr	r2, [r4, #4]
 8026dc4:	f022 0c03 	bic.w	ip, r2, #3
 8026dc8:	ebac 0007 	sub.w	r0, ip, r7
 8026dcc:	280f      	cmp	r0, #15
 8026dce:	dd48      	ble.n	8026e62 <_malloc_r+0x116>
 8026dd0:	19e2      	adds	r2, r4, r7
 8026dd2:	f040 0301 	orr.w	r3, r0, #1
 8026dd6:	f047 0701 	orr.w	r7, r7, #1
 8026dda:	6067      	str	r7, [r4, #4]
 8026ddc:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8026de0:	e9c2 1102 	strd	r1, r1, [r2, #8]
 8026de4:	6053      	str	r3, [r2, #4]
 8026de6:	f844 000c 	str.w	r0, [r4, ip]
 8026dea:	e7e0      	b.n	8026dae <_malloc_r+0x62>
 8026dec:	0a7b      	lsrs	r3, r7, #9
 8026dee:	d02a      	beq.n	8026e46 <_malloc_r+0xfa>
 8026df0:	2b04      	cmp	r3, #4
 8026df2:	d812      	bhi.n	8026e1a <_malloc_r+0xce>
 8026df4:	09bb      	lsrs	r3, r7, #6
 8026df6:	3338      	adds	r3, #56	; 0x38
 8026df8:	1c5a      	adds	r2, r3, #1
 8026dfa:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
 8026dfe:	f1a2 0c08 	sub.w	ip, r2, #8
 8026e02:	6854      	ldr	r4, [r2, #4]
 8026e04:	4564      	cmp	r4, ip
 8026e06:	d006      	beq.n	8026e16 <_malloc_r+0xca>
 8026e08:	6862      	ldr	r2, [r4, #4]
 8026e0a:	f022 0203 	bic.w	r2, r2, #3
 8026e0e:	1bd0      	subs	r0, r2, r7
 8026e10:	280f      	cmp	r0, #15
 8026e12:	dd1c      	ble.n	8026e4e <_malloc_r+0x102>
 8026e14:	3b01      	subs	r3, #1
 8026e16:	3301      	adds	r3, #1
 8026e18:	e7cf      	b.n	8026dba <_malloc_r+0x6e>
 8026e1a:	2b14      	cmp	r3, #20
 8026e1c:	d801      	bhi.n	8026e22 <_malloc_r+0xd6>
 8026e1e:	335b      	adds	r3, #91	; 0x5b
 8026e20:	e7ea      	b.n	8026df8 <_malloc_r+0xac>
 8026e22:	2b54      	cmp	r3, #84	; 0x54
 8026e24:	d802      	bhi.n	8026e2c <_malloc_r+0xe0>
 8026e26:	0b3b      	lsrs	r3, r7, #12
 8026e28:	336e      	adds	r3, #110	; 0x6e
 8026e2a:	e7e5      	b.n	8026df8 <_malloc_r+0xac>
 8026e2c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8026e30:	d802      	bhi.n	8026e38 <_malloc_r+0xec>
 8026e32:	0bfb      	lsrs	r3, r7, #15
 8026e34:	3377      	adds	r3, #119	; 0x77
 8026e36:	e7df      	b.n	8026df8 <_malloc_r+0xac>
 8026e38:	f240 5254 	movw	r2, #1364	; 0x554
 8026e3c:	4293      	cmp	r3, r2
 8026e3e:	d804      	bhi.n	8026e4a <_malloc_r+0xfe>
 8026e40:	0cbb      	lsrs	r3, r7, #18
 8026e42:	337c      	adds	r3, #124	; 0x7c
 8026e44:	e7d8      	b.n	8026df8 <_malloc_r+0xac>
 8026e46:	233f      	movs	r3, #63	; 0x3f
 8026e48:	e7d6      	b.n	8026df8 <_malloc_r+0xac>
 8026e4a:	237e      	movs	r3, #126	; 0x7e
 8026e4c:	e7d4      	b.n	8026df8 <_malloc_r+0xac>
 8026e4e:	2800      	cmp	r0, #0
 8026e50:	68e1      	ldr	r1, [r4, #12]
 8026e52:	db04      	blt.n	8026e5e <_malloc_r+0x112>
 8026e54:	68a3      	ldr	r3, [r4, #8]
 8026e56:	60d9      	str	r1, [r3, #12]
 8026e58:	608b      	str	r3, [r1, #8]
 8026e5a:	18a3      	adds	r3, r4, r2
 8026e5c:	e7a3      	b.n	8026da6 <_malloc_r+0x5a>
 8026e5e:	460c      	mov	r4, r1
 8026e60:	e7d0      	b.n	8026e04 <_malloc_r+0xb8>
 8026e62:	2800      	cmp	r0, #0
 8026e64:	e9c6 1104 	strd	r1, r1, [r6, #16]
 8026e68:	db07      	blt.n	8026e7a <_malloc_r+0x12e>
 8026e6a:	44a4      	add	ip, r4
 8026e6c:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8026e70:	f043 0301 	orr.w	r3, r3, #1
 8026e74:	f8cc 3004 	str.w	r3, [ip, #4]
 8026e78:	e799      	b.n	8026dae <_malloc_r+0x62>
 8026e7a:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
 8026e7e:	6870      	ldr	r0, [r6, #4]
 8026e80:	f080 8095 	bcs.w	8026fae <_malloc_r+0x262>
 8026e84:	ea4f 02dc 	mov.w	r2, ip, lsr #3
 8026e88:	ea4f 1e5c 	mov.w	lr, ip, lsr #5
 8026e8c:	f04f 0c01 	mov.w	ip, #1
 8026e90:	3201      	adds	r2, #1
 8026e92:	fa0c fc0e 	lsl.w	ip, ip, lr
 8026e96:	ea4c 0000 	orr.w	r0, ip, r0
 8026e9a:	6070      	str	r0, [r6, #4]
 8026e9c:	f856 c032 	ldr.w	ip, [r6, r2, lsl #3]
 8026ea0:	eb06 00c2 	add.w	r0, r6, r2, lsl #3
 8026ea4:	3808      	subs	r0, #8
 8026ea6:	e9c4 c002 	strd	ip, r0, [r4, #8]
 8026eaa:	f846 4032 	str.w	r4, [r6, r2, lsl #3]
 8026eae:	f8cc 400c 	str.w	r4, [ip, #12]
 8026eb2:	1098      	asrs	r0, r3, #2
 8026eb4:	2201      	movs	r2, #1
 8026eb6:	4082      	lsls	r2, r0
 8026eb8:	6870      	ldr	r0, [r6, #4]
 8026eba:	4290      	cmp	r0, r2
 8026ebc:	d326      	bcc.n	8026f0c <_malloc_r+0x1c0>
 8026ebe:	4210      	tst	r0, r2
 8026ec0:	d106      	bne.n	8026ed0 <_malloc_r+0x184>
 8026ec2:	f023 0303 	bic.w	r3, r3, #3
 8026ec6:	0052      	lsls	r2, r2, #1
 8026ec8:	4210      	tst	r0, r2
 8026eca:	f103 0304 	add.w	r3, r3, #4
 8026ece:	d0fa      	beq.n	8026ec6 <_malloc_r+0x17a>
 8026ed0:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
 8026ed4:	46c1      	mov	r9, r8
 8026ed6:	469e      	mov	lr, r3
 8026ed8:	f8d9 400c 	ldr.w	r4, [r9, #12]
 8026edc:	454c      	cmp	r4, r9
 8026ede:	f040 80b9 	bne.w	8027054 <_malloc_r+0x308>
 8026ee2:	f10e 0e01 	add.w	lr, lr, #1
 8026ee6:	f01e 0f03 	tst.w	lr, #3
 8026eea:	f109 0908 	add.w	r9, r9, #8
 8026eee:	d1f3      	bne.n	8026ed8 <_malloc_r+0x18c>
 8026ef0:	0798      	lsls	r0, r3, #30
 8026ef2:	f040 80e3 	bne.w	80270bc <_malloc_r+0x370>
 8026ef6:	6873      	ldr	r3, [r6, #4]
 8026ef8:	ea23 0302 	bic.w	r3, r3, r2
 8026efc:	6073      	str	r3, [r6, #4]
 8026efe:	6870      	ldr	r0, [r6, #4]
 8026f00:	0052      	lsls	r2, r2, #1
 8026f02:	4290      	cmp	r0, r2
 8026f04:	d302      	bcc.n	8026f0c <_malloc_r+0x1c0>
 8026f06:	2a00      	cmp	r2, #0
 8026f08:	f040 80e5 	bne.w	80270d6 <_malloc_r+0x38a>
 8026f0c:	f8d6 a008 	ldr.w	sl, [r6, #8]
 8026f10:	f8da 3004 	ldr.w	r3, [sl, #4]
 8026f14:	f023 0903 	bic.w	r9, r3, #3
 8026f18:	45b9      	cmp	r9, r7
 8026f1a:	d304      	bcc.n	8026f26 <_malloc_r+0x1da>
 8026f1c:	eba9 0207 	sub.w	r2, r9, r7
 8026f20:	2a0f      	cmp	r2, #15
 8026f22:	f300 8141 	bgt.w	80271a8 <_malloc_r+0x45c>
 8026f26:	4b46      	ldr	r3, [pc, #280]	; (8027040 <_malloc_r+0x2f4>)
 8026f28:	6819      	ldr	r1, [r3, #0]
 8026f2a:	3110      	adds	r1, #16
 8026f2c:	4439      	add	r1, r7
 8026f2e:	2008      	movs	r0, #8
 8026f30:	9101      	str	r1, [sp, #4]
 8026f32:	f001 fc8b 	bl	802884c <sysconf>
 8026f36:	4a43      	ldr	r2, [pc, #268]	; (8027044 <_malloc_r+0x2f8>)
 8026f38:	9901      	ldr	r1, [sp, #4]
 8026f3a:	6813      	ldr	r3, [r2, #0]
 8026f3c:	3301      	adds	r3, #1
 8026f3e:	bf1f      	itttt	ne
 8026f40:	f101 31ff 	addne.w	r1, r1, #4294967295
 8026f44:	1809      	addne	r1, r1, r0
 8026f46:	4243      	negne	r3, r0
 8026f48:	4019      	andne	r1, r3
 8026f4a:	4680      	mov	r8, r0
 8026f4c:	4628      	mov	r0, r5
 8026f4e:	9101      	str	r1, [sp, #4]
 8026f50:	f001 fc58 	bl	8028804 <_sbrk_r>
 8026f54:	1c42      	adds	r2, r0, #1
 8026f56:	eb0a 0b09 	add.w	fp, sl, r9
 8026f5a:	4604      	mov	r4, r0
 8026f5c:	f000 80f7 	beq.w	802714e <_malloc_r+0x402>
 8026f60:	4583      	cmp	fp, r0
 8026f62:	9901      	ldr	r1, [sp, #4]
 8026f64:	4a37      	ldr	r2, [pc, #220]	; (8027044 <_malloc_r+0x2f8>)
 8026f66:	d902      	bls.n	8026f6e <_malloc_r+0x222>
 8026f68:	45b2      	cmp	sl, r6
 8026f6a:	f040 80f0 	bne.w	802714e <_malloc_r+0x402>
 8026f6e:	4b36      	ldr	r3, [pc, #216]	; (8027048 <_malloc_r+0x2fc>)
 8026f70:	6818      	ldr	r0, [r3, #0]
 8026f72:	45a3      	cmp	fp, r4
 8026f74:	eb00 0e01 	add.w	lr, r0, r1
 8026f78:	f8c3 e000 	str.w	lr, [r3]
 8026f7c:	f108 3cff 	add.w	ip, r8, #4294967295
 8026f80:	f040 80ab 	bne.w	80270da <_malloc_r+0x38e>
 8026f84:	ea1b 0f0c 	tst.w	fp, ip
 8026f88:	f040 80a7 	bne.w	80270da <_malloc_r+0x38e>
 8026f8c:	68b2      	ldr	r2, [r6, #8]
 8026f8e:	4449      	add	r1, r9
 8026f90:	f041 0101 	orr.w	r1, r1, #1
 8026f94:	6051      	str	r1, [r2, #4]
 8026f96:	4a2d      	ldr	r2, [pc, #180]	; (802704c <_malloc_r+0x300>)
 8026f98:	681b      	ldr	r3, [r3, #0]
 8026f9a:	6811      	ldr	r1, [r2, #0]
 8026f9c:	428b      	cmp	r3, r1
 8026f9e:	bf88      	it	hi
 8026fa0:	6013      	strhi	r3, [r2, #0]
 8026fa2:	4a2b      	ldr	r2, [pc, #172]	; (8027050 <_malloc_r+0x304>)
 8026fa4:	6811      	ldr	r1, [r2, #0]
 8026fa6:	428b      	cmp	r3, r1
 8026fa8:	bf88      	it	hi
 8026faa:	6013      	strhi	r3, [r2, #0]
 8026fac:	e0cf      	b.n	802714e <_malloc_r+0x402>
 8026fae:	f5bc 6f20 	cmp.w	ip, #2560	; 0xa00
 8026fb2:	ea4f 225c 	mov.w	r2, ip, lsr #9
 8026fb6:	d218      	bcs.n	8026fea <_malloc_r+0x29e>
 8026fb8:	ea4f 129c 	mov.w	r2, ip, lsr #6
 8026fbc:	3238      	adds	r2, #56	; 0x38
 8026fbe:	f102 0e01 	add.w	lr, r2, #1
 8026fc2:	eb06 08c2 	add.w	r8, r6, r2, lsl #3
 8026fc6:	f856 e03e 	ldr.w	lr, [r6, lr, lsl #3]
 8026fca:	45f0      	cmp	r8, lr
 8026fcc:	d12b      	bne.n	8027026 <_malloc_r+0x2da>
 8026fce:	1092      	asrs	r2, r2, #2
 8026fd0:	f04f 0c01 	mov.w	ip, #1
 8026fd4:	fa0c f202 	lsl.w	r2, ip, r2
 8026fd8:	4302      	orrs	r2, r0
 8026fda:	6072      	str	r2, [r6, #4]
 8026fdc:	e9c4 e802 	strd	lr, r8, [r4, #8]
 8026fe0:	f8c8 4008 	str.w	r4, [r8, #8]
 8026fe4:	f8ce 400c 	str.w	r4, [lr, #12]
 8026fe8:	e763      	b.n	8026eb2 <_malloc_r+0x166>
 8026fea:	2a14      	cmp	r2, #20
 8026fec:	d801      	bhi.n	8026ff2 <_malloc_r+0x2a6>
 8026fee:	325b      	adds	r2, #91	; 0x5b
 8026ff0:	e7e5      	b.n	8026fbe <_malloc_r+0x272>
 8026ff2:	2a54      	cmp	r2, #84	; 0x54
 8026ff4:	d803      	bhi.n	8026ffe <_malloc_r+0x2b2>
 8026ff6:	ea4f 321c 	mov.w	r2, ip, lsr #12
 8026ffa:	326e      	adds	r2, #110	; 0x6e
 8026ffc:	e7df      	b.n	8026fbe <_malloc_r+0x272>
 8026ffe:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8027002:	d803      	bhi.n	802700c <_malloc_r+0x2c0>
 8027004:	ea4f 32dc 	mov.w	r2, ip, lsr #15
 8027008:	3277      	adds	r2, #119	; 0x77
 802700a:	e7d8      	b.n	8026fbe <_malloc_r+0x272>
 802700c:	f240 5e54 	movw	lr, #1364	; 0x554
 8027010:	4572      	cmp	r2, lr
 8027012:	bf9a      	itte	ls
 8027014:	ea4f 429c 	movls.w	r2, ip, lsr #18
 8027018:	327c      	addls	r2, #124	; 0x7c
 802701a:	227e      	movhi	r2, #126	; 0x7e
 802701c:	e7cf      	b.n	8026fbe <_malloc_r+0x272>
 802701e:	f8de e008 	ldr.w	lr, [lr, #8]
 8027022:	45f0      	cmp	r8, lr
 8027024:	d005      	beq.n	8027032 <_malloc_r+0x2e6>
 8027026:	f8de 2004 	ldr.w	r2, [lr, #4]
 802702a:	f022 0203 	bic.w	r2, r2, #3
 802702e:	4562      	cmp	r2, ip
 8027030:	d8f5      	bhi.n	802701e <_malloc_r+0x2d2>
 8027032:	f8de 800c 	ldr.w	r8, [lr, #12]
 8027036:	e7d1      	b.n	8026fdc <_malloc_r+0x290>
 8027038:	20000388 	.word	0x20000388
 802703c:	20000390 	.word	0x20000390
 8027040:	20011f14 	.word	0x20011f14
 8027044:	20000790 	.word	0x20000790
 8027048:	20011ee4 	.word	0x20011ee4
 802704c:	20011f0c 	.word	0x20011f0c
 8027050:	20011f10 	.word	0x20011f10
 8027054:	6860      	ldr	r0, [r4, #4]
 8027056:	f8d4 c00c 	ldr.w	ip, [r4, #12]
 802705a:	f020 0003 	bic.w	r0, r0, #3
 802705e:	eba0 0a07 	sub.w	sl, r0, r7
 8027062:	f1ba 0f0f 	cmp.w	sl, #15
 8027066:	dd12      	ble.n	802708e <_malloc_r+0x342>
 8027068:	68a3      	ldr	r3, [r4, #8]
 802706a:	19e2      	adds	r2, r4, r7
 802706c:	f047 0701 	orr.w	r7, r7, #1
 8027070:	6067      	str	r7, [r4, #4]
 8027072:	f8c3 c00c 	str.w	ip, [r3, #12]
 8027076:	f8cc 3008 	str.w	r3, [ip, #8]
 802707a:	f04a 0301 	orr.w	r3, sl, #1
 802707e:	e9c6 2204 	strd	r2, r2, [r6, #16]
 8027082:	e9c2 1102 	strd	r1, r1, [r2, #8]
 8027086:	6053      	str	r3, [r2, #4]
 8027088:	f844 a000 	str.w	sl, [r4, r0]
 802708c:	e68f      	b.n	8026dae <_malloc_r+0x62>
 802708e:	f1ba 0f00 	cmp.w	sl, #0
 8027092:	db11      	blt.n	80270b8 <_malloc_r+0x36c>
 8027094:	4420      	add	r0, r4
 8027096:	6843      	ldr	r3, [r0, #4]
 8027098:	f043 0301 	orr.w	r3, r3, #1
 802709c:	6043      	str	r3, [r0, #4]
 802709e:	f854 3f08 	ldr.w	r3, [r4, #8]!
 80270a2:	4628      	mov	r0, r5
 80270a4:	f8c3 c00c 	str.w	ip, [r3, #12]
 80270a8:	f8cc 3008 	str.w	r3, [ip, #8]
 80270ac:	f000 f88e 	bl	80271cc <__malloc_unlock>
 80270b0:	4620      	mov	r0, r4
 80270b2:	b003      	add	sp, #12
 80270b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80270b8:	4664      	mov	r4, ip
 80270ba:	e70f      	b.n	8026edc <_malloc_r+0x190>
 80270bc:	f858 0908 	ldr.w	r0, [r8], #-8
 80270c0:	4540      	cmp	r0, r8
 80270c2:	f103 33ff 	add.w	r3, r3, #4294967295
 80270c6:	f43f af13 	beq.w	8026ef0 <_malloc_r+0x1a4>
 80270ca:	e718      	b.n	8026efe <_malloc_r+0x1b2>
 80270cc:	3304      	adds	r3, #4
 80270ce:	0052      	lsls	r2, r2, #1
 80270d0:	4210      	tst	r0, r2
 80270d2:	d0fb      	beq.n	80270cc <_malloc_r+0x380>
 80270d4:	e6fc      	b.n	8026ed0 <_malloc_r+0x184>
 80270d6:	4673      	mov	r3, lr
 80270d8:	e7fa      	b.n	80270d0 <_malloc_r+0x384>
 80270da:	6810      	ldr	r0, [r2, #0]
 80270dc:	3001      	adds	r0, #1
 80270de:	bf1b      	ittet	ne
 80270e0:	eba4 0b0b 	subne.w	fp, r4, fp
 80270e4:	eb0b 020e 	addne.w	r2, fp, lr
 80270e8:	6014      	streq	r4, [r2, #0]
 80270ea:	601a      	strne	r2, [r3, #0]
 80270ec:	f014 0b07 	ands.w	fp, r4, #7
 80270f0:	bf1a      	itte	ne
 80270f2:	f1cb 0008 	rsbne	r0, fp, #8
 80270f6:	1824      	addne	r4, r4, r0
 80270f8:	4658      	moveq	r0, fp
 80270fa:	1862      	adds	r2, r4, r1
 80270fc:	ea02 010c 	and.w	r1, r2, ip
 8027100:	4480      	add	r8, r0
 8027102:	eba8 0801 	sub.w	r8, r8, r1
 8027106:	ea08 080c 	and.w	r8, r8, ip
 802710a:	4641      	mov	r1, r8
 802710c:	4628      	mov	r0, r5
 802710e:	9201      	str	r2, [sp, #4]
 8027110:	f001 fb78 	bl	8028804 <_sbrk_r>
 8027114:	1c43      	adds	r3, r0, #1
 8027116:	9a01      	ldr	r2, [sp, #4]
 8027118:	4b28      	ldr	r3, [pc, #160]	; (80271bc <_malloc_r+0x470>)
 802711a:	d107      	bne.n	802712c <_malloc_r+0x3e0>
 802711c:	f1bb 0f00 	cmp.w	fp, #0
 8027120:	d023      	beq.n	802716a <_malloc_r+0x41e>
 8027122:	f1ab 0008 	sub.w	r0, fp, #8
 8027126:	4410      	add	r0, r2
 8027128:	f04f 0800 	mov.w	r8, #0
 802712c:	681a      	ldr	r2, [r3, #0]
 802712e:	60b4      	str	r4, [r6, #8]
 8027130:	1b00      	subs	r0, r0, r4
 8027132:	4440      	add	r0, r8
 8027134:	4442      	add	r2, r8
 8027136:	f040 0001 	orr.w	r0, r0, #1
 802713a:	45b2      	cmp	sl, r6
 802713c:	601a      	str	r2, [r3, #0]
 802713e:	6060      	str	r0, [r4, #4]
 8027140:	f43f af29 	beq.w	8026f96 <_malloc_r+0x24a>
 8027144:	f1b9 0f0f 	cmp.w	r9, #15
 8027148:	d812      	bhi.n	8027170 <_malloc_r+0x424>
 802714a:	2301      	movs	r3, #1
 802714c:	6063      	str	r3, [r4, #4]
 802714e:	68b3      	ldr	r3, [r6, #8]
 8027150:	685b      	ldr	r3, [r3, #4]
 8027152:	f023 0303 	bic.w	r3, r3, #3
 8027156:	42bb      	cmp	r3, r7
 8027158:	eba3 0207 	sub.w	r2, r3, r7
 802715c:	d301      	bcc.n	8027162 <_malloc_r+0x416>
 802715e:	2a0f      	cmp	r2, #15
 8027160:	dc22      	bgt.n	80271a8 <_malloc_r+0x45c>
 8027162:	4628      	mov	r0, r5
 8027164:	f000 f832 	bl	80271cc <__malloc_unlock>
 8027168:	e5fc      	b.n	8026d64 <_malloc_r+0x18>
 802716a:	4610      	mov	r0, r2
 802716c:	46d8      	mov	r8, fp
 802716e:	e7dd      	b.n	802712c <_malloc_r+0x3e0>
 8027170:	f8da 2004 	ldr.w	r2, [sl, #4]
 8027174:	f1a9 090c 	sub.w	r9, r9, #12
 8027178:	f029 0907 	bic.w	r9, r9, #7
 802717c:	f002 0201 	and.w	r2, r2, #1
 8027180:	ea42 0209 	orr.w	r2, r2, r9
 8027184:	f8ca 2004 	str.w	r2, [sl, #4]
 8027188:	2105      	movs	r1, #5
 802718a:	eb0a 0209 	add.w	r2, sl, r9
 802718e:	f1b9 0f0f 	cmp.w	r9, #15
 8027192:	e9c2 1101 	strd	r1, r1, [r2, #4]
 8027196:	f67f aefe 	bls.w	8026f96 <_malloc_r+0x24a>
 802719a:	f10a 0108 	add.w	r1, sl, #8
 802719e:	4628      	mov	r0, r5
 80271a0:	f7ff fd14 	bl	8026bcc <_free_r>
 80271a4:	4b05      	ldr	r3, [pc, #20]	; (80271bc <_malloc_r+0x470>)
 80271a6:	e6f6      	b.n	8026f96 <_malloc_r+0x24a>
 80271a8:	68b4      	ldr	r4, [r6, #8]
 80271aa:	f047 0301 	orr.w	r3, r7, #1
 80271ae:	4427      	add	r7, r4
 80271b0:	f042 0201 	orr.w	r2, r2, #1
 80271b4:	6063      	str	r3, [r4, #4]
 80271b6:	60b7      	str	r7, [r6, #8]
 80271b8:	607a      	str	r2, [r7, #4]
 80271ba:	e5f8      	b.n	8026dae <_malloc_r+0x62>
 80271bc:	20011ee4 	.word	0x20011ee4

080271c0 <__malloc_lock>:
 80271c0:	4801      	ldr	r0, [pc, #4]	; (80271c8 <__malloc_lock+0x8>)
 80271c2:	f7ff bc87 	b.w	8026ad4 <__retarget_lock_acquire_recursive>
 80271c6:	bf00      	nop
 80271c8:	20011edd 	.word	0x20011edd

080271cc <__malloc_unlock>:
 80271cc:	4801      	ldr	r0, [pc, #4]	; (80271d4 <__malloc_unlock+0x8>)
 80271ce:	f7ff bc82 	b.w	8026ad6 <__retarget_lock_release_recursive>
 80271d2:	bf00      	nop
 80271d4:	20011edd 	.word	0x20011edd

080271d8 <_svfprintf_r>:
 80271d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80271dc:	ed2d 8b04 	vpush	{d8-d9}
 80271e0:	b0cf      	sub	sp, #316	; 0x13c
 80271e2:	4689      	mov	r9, r1
 80271e4:	9203      	str	r2, [sp, #12]
 80271e6:	461d      	mov	r5, r3
 80271e8:	4682      	mov	sl, r0
 80271ea:	f001 fb07 	bl	80287fc <_localeconv_r>
 80271ee:	6803      	ldr	r3, [r0, #0]
 80271f0:	9313      	str	r3, [sp, #76]	; 0x4c
 80271f2:	4618      	mov	r0, r3
 80271f4:	f7d8 fffe 	bl	80001f4 <strlen>
 80271f8:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 80271fc:	900e      	str	r0, [sp, #56]	; 0x38
 80271fe:	0619      	lsls	r1, r3, #24
 8027200:	d51a      	bpl.n	8027238 <_svfprintf_r+0x60>
 8027202:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8027206:	b9bb      	cbnz	r3, 8027238 <_svfprintf_r+0x60>
 8027208:	2140      	movs	r1, #64	; 0x40
 802720a:	4650      	mov	r0, sl
 802720c:	f7ff fd9e 	bl	8026d4c <_malloc_r>
 8027210:	f8c9 0000 	str.w	r0, [r9]
 8027214:	f8c9 0010 	str.w	r0, [r9, #16]
 8027218:	b958      	cbnz	r0, 8027232 <_svfprintf_r+0x5a>
 802721a:	230c      	movs	r3, #12
 802721c:	f8ca 3000 	str.w	r3, [sl]
 8027220:	f04f 33ff 	mov.w	r3, #4294967295
 8027224:	930b      	str	r3, [sp, #44]	; 0x2c
 8027226:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8027228:	b04f      	add	sp, #316	; 0x13c
 802722a:	ecbd 8b04 	vpop	{d8-d9}
 802722e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8027232:	2340      	movs	r3, #64	; 0x40
 8027234:	f8c9 3014 	str.w	r3, [r9, #20]
 8027238:	ed9f 7b91 	vldr	d7, [pc, #580]	; 8027480 <_svfprintf_r+0x2a8>
 802723c:	2300      	movs	r3, #0
 802723e:	e9cd 3323 	strd	r3, r3, [sp, #140]	; 0x8c
 8027242:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 8027246:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
 802724a:	ac25      	add	r4, sp, #148	; 0x94
 802724c:	9422      	str	r4, [sp, #136]	; 0x88
 802724e:	9305      	str	r3, [sp, #20]
 8027250:	9309      	str	r3, [sp, #36]	; 0x24
 8027252:	9311      	str	r3, [sp, #68]	; 0x44
 8027254:	9314      	str	r3, [sp, #80]	; 0x50
 8027256:	930b      	str	r3, [sp, #44]	; 0x2c
 8027258:	9b03      	ldr	r3, [sp, #12]
 802725a:	461e      	mov	r6, r3
 802725c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8027260:	b10a      	cbz	r2, 8027266 <_svfprintf_r+0x8e>
 8027262:	2a25      	cmp	r2, #37	; 0x25
 8027264:	d1f9      	bne.n	802725a <_svfprintf_r+0x82>
 8027266:	9b03      	ldr	r3, [sp, #12]
 8027268:	1af7      	subs	r7, r6, r3
 802726a:	d00d      	beq.n	8027288 <_svfprintf_r+0xb0>
 802726c:	e9c4 3700 	strd	r3, r7, [r4]
 8027270:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8027272:	443b      	add	r3, r7
 8027274:	9324      	str	r3, [sp, #144]	; 0x90
 8027276:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027278:	3301      	adds	r3, #1
 802727a:	2b07      	cmp	r3, #7
 802727c:	9323      	str	r3, [sp, #140]	; 0x8c
 802727e:	dc78      	bgt.n	8027372 <_svfprintf_r+0x19a>
 8027280:	3408      	adds	r4, #8
 8027282:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8027284:	443b      	add	r3, r7
 8027286:	930b      	str	r3, [sp, #44]	; 0x2c
 8027288:	7833      	ldrb	r3, [r6, #0]
 802728a:	2b00      	cmp	r3, #0
 802728c:	f001 815a 	beq.w	8028544 <_svfprintf_r+0x136c>
 8027290:	2300      	movs	r3, #0
 8027292:	3601      	adds	r6, #1
 8027294:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8027298:	f04f 38ff 	mov.w	r8, #4294967295
 802729c:	930f      	str	r3, [sp, #60]	; 0x3c
 802729e:	469b      	mov	fp, r3
 80272a0:	270a      	movs	r7, #10
 80272a2:	212b      	movs	r1, #43	; 0x2b
 80272a4:	4633      	mov	r3, r6
 80272a6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80272aa:	9207      	str	r2, [sp, #28]
 80272ac:	930a      	str	r3, [sp, #40]	; 0x28
 80272ae:	9b07      	ldr	r3, [sp, #28]
 80272b0:	3b20      	subs	r3, #32
 80272b2:	2b5a      	cmp	r3, #90	; 0x5a
 80272b4:	f200 85c6 	bhi.w	8027e44 <_svfprintf_r+0xc6c>
 80272b8:	e8df f013 	tbh	[pc, r3, lsl #1]
 80272bc:	05c4007e 	.word	0x05c4007e
 80272c0:	008605c4 	.word	0x008605c4
 80272c4:	05c405c4 	.word	0x05c405c4
 80272c8:	006505c4 	.word	0x006505c4
 80272cc:	05c405c4 	.word	0x05c405c4
 80272d0:	00930089 	.word	0x00930089
 80272d4:	009005c4 	.word	0x009005c4
 80272d8:	05c40096 	.word	0x05c40096
 80272dc:	00b200af 	.word	0x00b200af
 80272e0:	00b200b2 	.word	0x00b200b2
 80272e4:	00b200b2 	.word	0x00b200b2
 80272e8:	00b200b2 	.word	0x00b200b2
 80272ec:	00b200b2 	.word	0x00b200b2
 80272f0:	05c405c4 	.word	0x05c405c4
 80272f4:	05c405c4 	.word	0x05c405c4
 80272f8:	05c405c4 	.word	0x05c405c4
 80272fc:	012905c4 	.word	0x012905c4
 8027300:	00e605c4 	.word	0x00e605c4
 8027304:	012900f9 	.word	0x012900f9
 8027308:	01290129 	.word	0x01290129
 802730c:	05c405c4 	.word	0x05c405c4
 8027310:	05c405c4 	.word	0x05c405c4
 8027314:	05c400c2 	.word	0x05c400c2
 8027318:	049105c4 	.word	0x049105c4
 802731c:	05c405c4 	.word	0x05c405c4
 8027320:	04db05c4 	.word	0x04db05c4
 8027324:	050105c4 	.word	0x050105c4
 8027328:	05c405c4 	.word	0x05c405c4
 802732c:	05c40523 	.word	0x05c40523
 8027330:	05c405c4 	.word	0x05c405c4
 8027334:	05c405c4 	.word	0x05c405c4
 8027338:	05c405c4 	.word	0x05c405c4
 802733c:	012905c4 	.word	0x012905c4
 8027340:	00e605c4 	.word	0x00e605c4
 8027344:	012900fb 	.word	0x012900fb
 8027348:	01290129 	.word	0x01290129
 802734c:	00fb00c5 	.word	0x00fb00c5
 8027350:	05c400d9 	.word	0x05c400d9
 8027354:	05c400d2 	.word	0x05c400d2
 8027358:	0493046c 	.word	0x0493046c
 802735c:	00d904ca 	.word	0x00d904ca
 8027360:	04db05c4 	.word	0x04db05c4
 8027364:	0503007c 	.word	0x0503007c
 8027368:	05c405c4 	.word	0x05c405c4
 802736c:	05c40542 	.word	0x05c40542
 8027370:	007c      	.short	0x007c
 8027372:	aa22      	add	r2, sp, #136	; 0x88
 8027374:	4649      	mov	r1, r9
 8027376:	4650      	mov	r0, sl
 8027378:	f002 fe41 	bl	8029ffe <__ssprint_r>
 802737c:	2800      	cmp	r0, #0
 802737e:	f040 8137 	bne.w	80275f0 <_svfprintf_r+0x418>
 8027382:	ac25      	add	r4, sp, #148	; 0x94
 8027384:	e77d      	b.n	8027282 <_svfprintf_r+0xaa>
 8027386:	4650      	mov	r0, sl
 8027388:	f001 fa38 	bl	80287fc <_localeconv_r>
 802738c:	6843      	ldr	r3, [r0, #4]
 802738e:	9314      	str	r3, [sp, #80]	; 0x50
 8027390:	4618      	mov	r0, r3
 8027392:	f7d8 ff2f 	bl	80001f4 <strlen>
 8027396:	9011      	str	r0, [sp, #68]	; 0x44
 8027398:	4650      	mov	r0, sl
 802739a:	f001 fa2f 	bl	80287fc <_localeconv_r>
 802739e:	6883      	ldr	r3, [r0, #8]
 80273a0:	9309      	str	r3, [sp, #36]	; 0x24
 80273a2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80273a4:	212b      	movs	r1, #43	; 0x2b
 80273a6:	b12b      	cbz	r3, 80273b4 <_svfprintf_r+0x1dc>
 80273a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80273aa:	b11b      	cbz	r3, 80273b4 <_svfprintf_r+0x1dc>
 80273ac:	781b      	ldrb	r3, [r3, #0]
 80273ae:	b10b      	cbz	r3, 80273b4 <_svfprintf_r+0x1dc>
 80273b0:	f44b 6b80 	orr.w	fp, fp, #1024	; 0x400
 80273b4:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 80273b6:	e775      	b.n	80272a4 <_svfprintf_r+0xcc>
 80273b8:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 80273bc:	2b00      	cmp	r3, #0
 80273be:	d1f9      	bne.n	80273b4 <_svfprintf_r+0x1dc>
 80273c0:	2320      	movs	r3, #32
 80273c2:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80273c6:	e7f5      	b.n	80273b4 <_svfprintf_r+0x1dc>
 80273c8:	f04b 0b01 	orr.w	fp, fp, #1
 80273cc:	e7f2      	b.n	80273b4 <_svfprintf_r+0x1dc>
 80273ce:	f855 3b04 	ldr.w	r3, [r5], #4
 80273d2:	930f      	str	r3, [sp, #60]	; 0x3c
 80273d4:	2b00      	cmp	r3, #0
 80273d6:	daed      	bge.n	80273b4 <_svfprintf_r+0x1dc>
 80273d8:	425b      	negs	r3, r3
 80273da:	930f      	str	r3, [sp, #60]	; 0x3c
 80273dc:	f04b 0b04 	orr.w	fp, fp, #4
 80273e0:	e7e8      	b.n	80273b4 <_svfprintf_r+0x1dc>
 80273e2:	f88d 106b 	strb.w	r1, [sp, #107]	; 0x6b
 80273e6:	e7e5      	b.n	80273b4 <_svfprintf_r+0x1dc>
 80273e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80273ea:	f813 2b01 	ldrb.w	r2, [r3], #1
 80273ee:	9207      	str	r2, [sp, #28]
 80273f0:	2a2a      	cmp	r2, #42	; 0x2a
 80273f2:	d10f      	bne.n	8027414 <_svfprintf_r+0x23c>
 80273f4:	f855 2b04 	ldr.w	r2, [r5], #4
 80273f8:	930a      	str	r3, [sp, #40]	; 0x28
 80273fa:	ea42 78e2 	orr.w	r8, r2, r2, asr #31
 80273fe:	e7d9      	b.n	80273b4 <_svfprintf_r+0x1dc>
 8027400:	fb07 2808 	mla	r8, r7, r8, r2
 8027404:	f813 2b01 	ldrb.w	r2, [r3], #1
 8027408:	9207      	str	r2, [sp, #28]
 802740a:	9a07      	ldr	r2, [sp, #28]
 802740c:	3a30      	subs	r2, #48	; 0x30
 802740e:	2a09      	cmp	r2, #9
 8027410:	d9f6      	bls.n	8027400 <_svfprintf_r+0x228>
 8027412:	e74b      	b.n	80272ac <_svfprintf_r+0xd4>
 8027414:	f04f 0800 	mov.w	r8, #0
 8027418:	e7f7      	b.n	802740a <_svfprintf_r+0x232>
 802741a:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 802741e:	e7c9      	b.n	80273b4 <_svfprintf_r+0x1dc>
 8027420:	2200      	movs	r2, #0
 8027422:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027424:	920f      	str	r2, [sp, #60]	; 0x3c
 8027426:	9a07      	ldr	r2, [sp, #28]
 8027428:	980f      	ldr	r0, [sp, #60]	; 0x3c
 802742a:	3a30      	subs	r2, #48	; 0x30
 802742c:	fb07 2200 	mla	r2, r7, r0, r2
 8027430:	920f      	str	r2, [sp, #60]	; 0x3c
 8027432:	f813 2b01 	ldrb.w	r2, [r3], #1
 8027436:	9207      	str	r2, [sp, #28]
 8027438:	3a30      	subs	r2, #48	; 0x30
 802743a:	2a09      	cmp	r2, #9
 802743c:	d9f3      	bls.n	8027426 <_svfprintf_r+0x24e>
 802743e:	e735      	b.n	80272ac <_svfprintf_r+0xd4>
 8027440:	f04b 0b08 	orr.w	fp, fp, #8
 8027444:	e7b6      	b.n	80273b4 <_svfprintf_r+0x1dc>
 8027446:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027448:	781b      	ldrb	r3, [r3, #0]
 802744a:	2b68      	cmp	r3, #104	; 0x68
 802744c:	bf01      	itttt	eq
 802744e:	9b0a      	ldreq	r3, [sp, #40]	; 0x28
 8027450:	3301      	addeq	r3, #1
 8027452:	930a      	streq	r3, [sp, #40]	; 0x28
 8027454:	f44b 7b00 	orreq.w	fp, fp, #512	; 0x200
 8027458:	bf18      	it	ne
 802745a:	f04b 0b40 	orrne.w	fp, fp, #64	; 0x40
 802745e:	e7a9      	b.n	80273b4 <_svfprintf_r+0x1dc>
 8027460:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027462:	781b      	ldrb	r3, [r3, #0]
 8027464:	2b6c      	cmp	r3, #108	; 0x6c
 8027466:	d105      	bne.n	8027474 <_svfprintf_r+0x29c>
 8027468:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802746a:	3301      	adds	r3, #1
 802746c:	930a      	str	r3, [sp, #40]	; 0x28
 802746e:	f04b 0b20 	orr.w	fp, fp, #32
 8027472:	e79f      	b.n	80273b4 <_svfprintf_r+0x1dc>
 8027474:	f04b 0b10 	orr.w	fp, fp, #16
 8027478:	e79c      	b.n	80273b4 <_svfprintf_r+0x1dc>
 802747a:	bf00      	nop
 802747c:	f3af 8000 	nop.w
	...
 8027488:	462a      	mov	r2, r5
 802748a:	f852 3b04 	ldr.w	r3, [r2], #4
 802748e:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8027492:	2300      	movs	r3, #0
 8027494:	9206      	str	r2, [sp, #24]
 8027496:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 802749a:	9304      	str	r3, [sp, #16]
 802749c:	461f      	mov	r7, r3
 802749e:	461e      	mov	r6, r3
 80274a0:	9308      	str	r3, [sp, #32]
 80274a2:	461d      	mov	r5, r3
 80274a4:	ab35      	add	r3, sp, #212	; 0xd4
 80274a6:	f04f 0801 	mov.w	r8, #1
 80274aa:	9303      	str	r3, [sp, #12]
 80274ac:	e1b9      	b.n	8027822 <_svfprintf_r+0x64a>
 80274ae:	f04b 0b10 	orr.w	fp, fp, #16
 80274b2:	f01b 0f20 	tst.w	fp, #32
 80274b6:	d012      	beq.n	80274de <_svfprintf_r+0x306>
 80274b8:	3507      	adds	r5, #7
 80274ba:	f025 0307 	bic.w	r3, r5, #7
 80274be:	461a      	mov	r2, r3
 80274c0:	685e      	ldr	r6, [r3, #4]
 80274c2:	f852 5b08 	ldr.w	r5, [r2], #8
 80274c6:	9206      	str	r2, [sp, #24]
 80274c8:	2e00      	cmp	r6, #0
 80274ca:	da06      	bge.n	80274da <_svfprintf_r+0x302>
 80274cc:	426d      	negs	r5, r5
 80274ce:	f04f 032d 	mov.w	r3, #45	; 0x2d
 80274d2:	eb66 0646 	sbc.w	r6, r6, r6, lsl #1
 80274d6:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 80274da:	2301      	movs	r3, #1
 80274dc:	e392      	b.n	8027c04 <_svfprintf_r+0xa2c>
 80274de:	462b      	mov	r3, r5
 80274e0:	f01b 0f10 	tst.w	fp, #16
 80274e4:	f853 6b04 	ldr.w	r6, [r3], #4
 80274e8:	9306      	str	r3, [sp, #24]
 80274ea:	d002      	beq.n	80274f2 <_svfprintf_r+0x31a>
 80274ec:	4635      	mov	r5, r6
 80274ee:	17f6      	asrs	r6, r6, #31
 80274f0:	e7ea      	b.n	80274c8 <_svfprintf_r+0x2f0>
 80274f2:	f01b 0f40 	tst.w	fp, #64	; 0x40
 80274f6:	d003      	beq.n	8027500 <_svfprintf_r+0x328>
 80274f8:	b235      	sxth	r5, r6
 80274fa:	f346 36c0 	sbfx	r6, r6, #15, #1
 80274fe:	e7e3      	b.n	80274c8 <_svfprintf_r+0x2f0>
 8027500:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8027504:	d0f2      	beq.n	80274ec <_svfprintf_r+0x314>
 8027506:	b275      	sxtb	r5, r6
 8027508:	f346 16c0 	sbfx	r6, r6, #7, #1
 802750c:	e7dc      	b.n	80274c8 <_svfprintf_r+0x2f0>
 802750e:	3507      	adds	r5, #7
 8027510:	f025 0307 	bic.w	r3, r5, #7
 8027514:	ecb3 7b02 	vldmia	r3!, {d7}
 8027518:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
 802751c:	9306      	str	r3, [sp, #24]
 802751e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027520:	ee09 3a10 	vmov	s18, r3
 8027524:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8027526:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802752a:	ee09 3a90 	vmov	s19, r3
 802752e:	f04f 32ff 	mov.w	r2, #4294967295
 8027532:	4b34      	ldr	r3, [pc, #208]	; (8027604 <_svfprintf_r+0x42c>)
 8027534:	ec51 0b19 	vmov	r0, r1, d9
 8027538:	f7d9 fb10 	bl	8000b5c <__aeabi_dcmpun>
 802753c:	bb18      	cbnz	r0, 8027586 <_svfprintf_r+0x3ae>
 802753e:	4b31      	ldr	r3, [pc, #196]	; (8027604 <_svfprintf_r+0x42c>)
 8027540:	ec51 0b19 	vmov	r0, r1, d9
 8027544:	f04f 32ff 	mov.w	r2, #4294967295
 8027548:	f7d9 faea 	bl	8000b20 <__aeabi_dcmple>
 802754c:	b9d8      	cbnz	r0, 8027586 <_svfprintf_r+0x3ae>
 802754e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8027552:	2200      	movs	r2, #0
 8027554:	2300      	movs	r3, #0
 8027556:	f7d9 fad9 	bl	8000b0c <__aeabi_dcmplt>
 802755a:	b110      	cbz	r0, 8027562 <_svfprintf_r+0x38a>
 802755c:	232d      	movs	r3, #45	; 0x2d
 802755e:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8027562:	4a29      	ldr	r2, [pc, #164]	; (8027608 <_svfprintf_r+0x430>)
 8027564:	4b29      	ldr	r3, [pc, #164]	; (802760c <_svfprintf_r+0x434>)
 8027566:	9907      	ldr	r1, [sp, #28]
 8027568:	2947      	cmp	r1, #71	; 0x47
 802756a:	bfc8      	it	gt
 802756c:	461a      	movgt	r2, r3
 802756e:	2300      	movs	r3, #0
 8027570:	9203      	str	r2, [sp, #12]
 8027572:	f02b 0b80 	bic.w	fp, fp, #128	; 0x80
 8027576:	9304      	str	r3, [sp, #16]
 8027578:	f04f 0803 	mov.w	r8, #3
 802757c:	461f      	mov	r7, r3
 802757e:	461e      	mov	r6, r3
 8027580:	9308      	str	r3, [sp, #32]
 8027582:	461d      	mov	r5, r3
 8027584:	e14d      	b.n	8027822 <_svfprintf_r+0x64a>
 8027586:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
 802758a:	4610      	mov	r0, r2
 802758c:	4619      	mov	r1, r3
 802758e:	f7d9 fae5 	bl	8000b5c <__aeabi_dcmpun>
 8027592:	b140      	cbz	r0, 80275a6 <_svfprintf_r+0x3ce>
 8027594:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8027596:	4a1e      	ldr	r2, [pc, #120]	; (8027610 <_svfprintf_r+0x438>)
 8027598:	2b00      	cmp	r3, #0
 802759a:	bfbc      	itt	lt
 802759c:	232d      	movlt	r3, #45	; 0x2d
 802759e:	f88d 306b 	strblt.w	r3, [sp, #107]	; 0x6b
 80275a2:	4b1c      	ldr	r3, [pc, #112]	; (8027614 <_svfprintf_r+0x43c>)
 80275a4:	e7df      	b.n	8027566 <_svfprintf_r+0x38e>
 80275a6:	9b07      	ldr	r3, [sp, #28]
 80275a8:	f023 0320 	bic.w	r3, r3, #32
 80275ac:	2b41      	cmp	r3, #65	; 0x41
 80275ae:	9308      	str	r3, [sp, #32]
 80275b0:	d132      	bne.n	8027618 <_svfprintf_r+0x440>
 80275b2:	2330      	movs	r3, #48	; 0x30
 80275b4:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 80275b8:	9b07      	ldr	r3, [sp, #28]
 80275ba:	2b61      	cmp	r3, #97	; 0x61
 80275bc:	bf0c      	ite	eq
 80275be:	2378      	moveq	r3, #120	; 0x78
 80275c0:	2358      	movne	r3, #88	; 0x58
 80275c2:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
 80275c6:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 80275ca:	f04b 0b02 	orr.w	fp, fp, #2
 80275ce:	f340 8204 	ble.w	80279da <_svfprintf_r+0x802>
 80275d2:	f108 0101 	add.w	r1, r8, #1
 80275d6:	4650      	mov	r0, sl
 80275d8:	f7ff fbb8 	bl	8026d4c <_malloc_r>
 80275dc:	9003      	str	r0, [sp, #12]
 80275de:	2800      	cmp	r0, #0
 80275e0:	f040 81ff 	bne.w	80279e2 <_svfprintf_r+0x80a>
 80275e4:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 80275e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80275ec:	f8a9 300c 	strh.w	r3, [r9, #12]
 80275f0:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 80275f4:	f013 0f40 	tst.w	r3, #64	; 0x40
 80275f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80275fa:	bf18      	it	ne
 80275fc:	f04f 33ff 	movne.w	r3, #4294967295
 8027600:	e610      	b.n	8027224 <_svfprintf_r+0x4c>
 8027602:	bf00      	nop
 8027604:	7fefffff 	.word	0x7fefffff
 8027608:	08037545 	.word	0x08037545
 802760c:	08037549 	.word	0x08037549
 8027610:	0803754d 	.word	0x0803754d
 8027614:	08037551 	.word	0x08037551
 8027618:	f1b8 3fff 	cmp.w	r8, #4294967295
 802761c:	f000 81e4 	beq.w	80279e8 <_svfprintf_r+0x810>
 8027620:	9b08      	ldr	r3, [sp, #32]
 8027622:	2b47      	cmp	r3, #71	; 0x47
 8027624:	f040 81e4 	bne.w	80279f0 <_svfprintf_r+0x818>
 8027628:	f1b8 0f00 	cmp.w	r8, #0
 802762c:	f040 81e0 	bne.w	80279f0 <_svfprintf_r+0x818>
 8027630:	f8cd 8010 	str.w	r8, [sp, #16]
 8027634:	f04f 0801 	mov.w	r8, #1
 8027638:	f44b 7380 	orr.w	r3, fp, #256	; 0x100
 802763c:	9310      	str	r3, [sp, #64]	; 0x40
 802763e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8027640:	2b00      	cmp	r3, #0
 8027642:	f280 81d7 	bge.w	80279f4 <_svfprintf_r+0x81c>
 8027646:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8027648:	ee08 3a10 	vmov	s16, r3
 802764c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 802764e:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8027652:	ee08 3a90 	vmov	s17, r3
 8027656:	232d      	movs	r3, #45	; 0x2d
 8027658:	9318      	str	r3, [sp, #96]	; 0x60
 802765a:	9b08      	ldr	r3, [sp, #32]
 802765c:	2b41      	cmp	r3, #65	; 0x41
 802765e:	f040 81e7 	bne.w	8027a30 <_svfprintf_r+0x858>
 8027662:	eeb0 0a48 	vmov.f32	s0, s16
 8027666:	eef0 0a68 	vmov.f32	s1, s17
 802766a:	a81c      	add	r0, sp, #112	; 0x70
 802766c:	f001 f8fa 	bl	8028864 <frexp>
 8027670:	2200      	movs	r2, #0
 8027672:	f04f 537f 	mov.w	r3, #1069547520	; 0x3fc00000
 8027676:	ec51 0b10 	vmov	r0, r1, d0
 802767a:	f7d8 ffd5 	bl	8000628 <__aeabi_dmul>
 802767e:	2200      	movs	r2, #0
 8027680:	2300      	movs	r3, #0
 8027682:	4606      	mov	r6, r0
 8027684:	460f      	mov	r7, r1
 8027686:	f7d9 fa37 	bl	8000af8 <__aeabi_dcmpeq>
 802768a:	b108      	cbz	r0, 8027690 <_svfprintf_r+0x4b8>
 802768c:	2301      	movs	r3, #1
 802768e:	931c      	str	r3, [sp, #112]	; 0x70
 8027690:	4bac      	ldr	r3, [pc, #688]	; (8027944 <_svfprintf_r+0x76c>)
 8027692:	4aad      	ldr	r2, [pc, #692]	; (8027948 <_svfprintf_r+0x770>)
 8027694:	9907      	ldr	r1, [sp, #28]
 8027696:	9d03      	ldr	r5, [sp, #12]
 8027698:	2961      	cmp	r1, #97	; 0x61
 802769a:	bf18      	it	ne
 802769c:	461a      	movne	r2, r3
 802769e:	f108 33ff 	add.w	r3, r8, #4294967295
 80276a2:	9217      	str	r2, [sp, #92]	; 0x5c
 80276a4:	9305      	str	r3, [sp, #20]
 80276a6:	4ba9      	ldr	r3, [pc, #676]	; (802794c <_svfprintf_r+0x774>)
 80276a8:	2200      	movs	r2, #0
 80276aa:	4630      	mov	r0, r6
 80276ac:	4639      	mov	r1, r7
 80276ae:	f7d8 ffbb 	bl	8000628 <__aeabi_dmul>
 80276b2:	460f      	mov	r7, r1
 80276b4:	4606      	mov	r6, r0
 80276b6:	f7d9 fa67 	bl	8000b88 <__aeabi_d2iz>
 80276ba:	9019      	str	r0, [sp, #100]	; 0x64
 80276bc:	f7d8 ff4a 	bl	8000554 <__aeabi_i2d>
 80276c0:	4602      	mov	r2, r0
 80276c2:	460b      	mov	r3, r1
 80276c4:	4630      	mov	r0, r6
 80276c6:	4639      	mov	r1, r7
 80276c8:	f7d8 fdf6 	bl	80002b8 <__aeabi_dsub>
 80276cc:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80276ce:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80276d0:	5c9b      	ldrb	r3, [r3, r2]
 80276d2:	f805 3b01 	strb.w	r3, [r5], #1
 80276d6:	9b05      	ldr	r3, [sp, #20]
 80276d8:	9312      	str	r3, [sp, #72]	; 0x48
 80276da:	1c5a      	adds	r2, r3, #1
 80276dc:	4606      	mov	r6, r0
 80276de:	460f      	mov	r7, r1
 80276e0:	d007      	beq.n	80276f2 <_svfprintf_r+0x51a>
 80276e2:	3b01      	subs	r3, #1
 80276e4:	9305      	str	r3, [sp, #20]
 80276e6:	2200      	movs	r2, #0
 80276e8:	2300      	movs	r3, #0
 80276ea:	f7d9 fa05 	bl	8000af8 <__aeabi_dcmpeq>
 80276ee:	2800      	cmp	r0, #0
 80276f0:	d0d9      	beq.n	80276a6 <_svfprintf_r+0x4ce>
 80276f2:	4b97      	ldr	r3, [pc, #604]	; (8027950 <_svfprintf_r+0x778>)
 80276f4:	2200      	movs	r2, #0
 80276f6:	4630      	mov	r0, r6
 80276f8:	4639      	mov	r1, r7
 80276fa:	f7d9 fa25 	bl	8000b48 <__aeabi_dcmpgt>
 80276fe:	b960      	cbnz	r0, 802771a <_svfprintf_r+0x542>
 8027700:	4b93      	ldr	r3, [pc, #588]	; (8027950 <_svfprintf_r+0x778>)
 8027702:	2200      	movs	r2, #0
 8027704:	4630      	mov	r0, r6
 8027706:	4639      	mov	r1, r7
 8027708:	f7d9 f9f6 	bl	8000af8 <__aeabi_dcmpeq>
 802770c:	2800      	cmp	r0, #0
 802770e:	f000 818a 	beq.w	8027a26 <_svfprintf_r+0x84e>
 8027712:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8027714:	07de      	lsls	r6, r3, #31
 8027716:	f140 8186 	bpl.w	8027a26 <_svfprintf_r+0x84e>
 802771a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 802771c:	9520      	str	r5, [sp, #128]	; 0x80
 802771e:	7bd9      	ldrb	r1, [r3, #15]
 8027720:	2030      	movs	r0, #48	; 0x30
 8027722:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8027724:	1e53      	subs	r3, r2, #1
 8027726:	9320      	str	r3, [sp, #128]	; 0x80
 8027728:	f812 3c01 	ldrb.w	r3, [r2, #-1]
 802772c:	428b      	cmp	r3, r1
 802772e:	f000 8169 	beq.w	8027a04 <_svfprintf_r+0x82c>
 8027732:	2b39      	cmp	r3, #57	; 0x39
 8027734:	bf0b      	itete	eq
 8027736:	9b17      	ldreq	r3, [sp, #92]	; 0x5c
 8027738:	3301      	addne	r3, #1
 802773a:	7a9b      	ldrbeq	r3, [r3, #10]
 802773c:	b2db      	uxtbne	r3, r3
 802773e:	f802 3c01 	strb.w	r3, [r2, #-1]
 8027742:	9b03      	ldr	r3, [sp, #12]
 8027744:	1aeb      	subs	r3, r5, r3
 8027746:	9305      	str	r3, [sp, #20]
 8027748:	9b08      	ldr	r3, [sp, #32]
 802774a:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 802774c:	2b47      	cmp	r3, #71	; 0x47
 802774e:	f040 81b9 	bne.w	8027ac4 <_svfprintf_r+0x8ec>
 8027752:	1ce8      	adds	r0, r5, #3
 8027754:	db02      	blt.n	802775c <_svfprintf_r+0x584>
 8027756:	45a8      	cmp	r8, r5
 8027758:	f280 81d7 	bge.w	8027b0a <_svfprintf_r+0x932>
 802775c:	9b07      	ldr	r3, [sp, #28]
 802775e:	3b02      	subs	r3, #2
 8027760:	9307      	str	r3, [sp, #28]
 8027762:	9907      	ldr	r1, [sp, #28]
 8027764:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8027768:	f021 0120 	bic.w	r1, r1, #32
 802776c:	2941      	cmp	r1, #65	; 0x41
 802776e:	bf08      	it	eq
 8027770:	320f      	addeq	r2, #15
 8027772:	f105 33ff 	add.w	r3, r5, #4294967295
 8027776:	bf06      	itte	eq
 8027778:	b2d2      	uxtbeq	r2, r2
 802777a:	2101      	moveq	r1, #1
 802777c:	2100      	movne	r1, #0
 802777e:	2b00      	cmp	r3, #0
 8027780:	931c      	str	r3, [sp, #112]	; 0x70
 8027782:	bfb8      	it	lt
 8027784:	f1c5 0301 	rsblt	r3, r5, #1
 8027788:	f88d 2078 	strb.w	r2, [sp, #120]	; 0x78
 802778c:	bfb4      	ite	lt
 802778e:	222d      	movlt	r2, #45	; 0x2d
 8027790:	222b      	movge	r2, #43	; 0x2b
 8027792:	2b09      	cmp	r3, #9
 8027794:	f88d 2079 	strb.w	r2, [sp, #121]	; 0x79
 8027798:	f340 81aa 	ble.w	8027af0 <_svfprintf_r+0x918>
 802779c:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 80277a0:	260a      	movs	r6, #10
 80277a2:	4602      	mov	r2, r0
 80277a4:	fb93 f5f6 	sdiv	r5, r3, r6
 80277a8:	fb06 3115 	mls	r1, r6, r5, r3
 80277ac:	3130      	adds	r1, #48	; 0x30
 80277ae:	f802 1c01 	strb.w	r1, [r2, #-1]
 80277b2:	4619      	mov	r1, r3
 80277b4:	2963      	cmp	r1, #99	; 0x63
 80277b6:	f100 30ff 	add.w	r0, r0, #4294967295
 80277ba:	462b      	mov	r3, r5
 80277bc:	dcf1      	bgt.n	80277a2 <_svfprintf_r+0x5ca>
 80277be:	3330      	adds	r3, #48	; 0x30
 80277c0:	1e91      	subs	r1, r2, #2
 80277c2:	f800 3c01 	strb.w	r3, [r0, #-1]
 80277c6:	f10d 0579 	add.w	r5, sp, #121	; 0x79
 80277ca:	460b      	mov	r3, r1
 80277cc:	f10d 0087 	add.w	r0, sp, #135	; 0x87
 80277d0:	4283      	cmp	r3, r0
 80277d2:	f0c0 8188 	bcc.w	8027ae6 <_svfprintf_r+0x90e>
 80277d6:	f10d 0389 	add.w	r3, sp, #137	; 0x89
 80277da:	1a9b      	subs	r3, r3, r2
 80277dc:	4281      	cmp	r1, r0
 80277de:	bf88      	it	hi
 80277e0:	2300      	movhi	r3, #0
 80277e2:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 80277e6:	441a      	add	r2, r3
 80277e8:	ab1e      	add	r3, sp, #120	; 0x78
 80277ea:	1ad3      	subs	r3, r2, r3
 80277ec:	9a05      	ldr	r2, [sp, #20]
 80277ee:	9315      	str	r3, [sp, #84]	; 0x54
 80277f0:	2a01      	cmp	r2, #1
 80277f2:	eb03 0802 	add.w	r8, r3, r2
 80277f6:	dc02      	bgt.n	80277fe <_svfprintf_r+0x626>
 80277f8:	f01b 0f01 	tst.w	fp, #1
 80277fc:	d001      	beq.n	8027802 <_svfprintf_r+0x62a>
 80277fe:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027800:	4498      	add	r8, r3
 8027802:	f42b 6380 	bic.w	r3, fp, #1024	; 0x400
 8027806:	2600      	movs	r6, #0
 8027808:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 802780c:	9310      	str	r3, [sp, #64]	; 0x40
 802780e:	9608      	str	r6, [sp, #32]
 8027810:	4635      	mov	r5, r6
 8027812:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8027814:	b113      	cbz	r3, 802781c <_svfprintf_r+0x644>
 8027816:	232d      	movs	r3, #45	; 0x2d
 8027818:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 802781c:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
 8027820:	2700      	movs	r7, #0
 8027822:	4547      	cmp	r7, r8
 8027824:	463b      	mov	r3, r7
 8027826:	bfb8      	it	lt
 8027828:	4643      	movlt	r3, r8
 802782a:	9310      	str	r3, [sp, #64]	; 0x40
 802782c:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
 8027830:	b113      	cbz	r3, 8027838 <_svfprintf_r+0x660>
 8027832:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8027834:	3301      	adds	r3, #1
 8027836:	9310      	str	r3, [sp, #64]	; 0x40
 8027838:	f01b 0302 	ands.w	r3, fp, #2
 802783c:	9317      	str	r3, [sp, #92]	; 0x5c
 802783e:	bf1e      	ittt	ne
 8027840:	9b10      	ldrne	r3, [sp, #64]	; 0x40
 8027842:	3302      	addne	r3, #2
 8027844:	9310      	strne	r3, [sp, #64]	; 0x40
 8027846:	f01b 0384 	ands.w	r3, fp, #132	; 0x84
 802784a:	9318      	str	r3, [sp, #96]	; 0x60
 802784c:	d122      	bne.n	8027894 <_svfprintf_r+0x6bc>
 802784e:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 8027852:	1a9b      	subs	r3, r3, r2
 8027854:	2b00      	cmp	r3, #0
 8027856:	9312      	str	r3, [sp, #72]	; 0x48
 8027858:	dd1c      	ble.n	8027894 <_svfprintf_r+0x6bc>
 802785a:	9812      	ldr	r0, [sp, #72]	; 0x48
 802785c:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 8027860:	2810      	cmp	r0, #16
 8027862:	483c      	ldr	r0, [pc, #240]	; (8027954 <_svfprintf_r+0x77c>)
 8027864:	6020      	str	r0, [r4, #0]
 8027866:	f102 0201 	add.w	r2, r2, #1
 802786a:	f104 0108 	add.w	r1, r4, #8
 802786e:	f300 82f7 	bgt.w	8027e60 <_svfprintf_r+0xc88>
 8027872:	9812      	ldr	r0, [sp, #72]	; 0x48
 8027874:	6060      	str	r0, [r4, #4]
 8027876:	4403      	add	r3, r0
 8027878:	2a07      	cmp	r2, #7
 802787a:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 802787e:	f340 8304 	ble.w	8027e8a <_svfprintf_r+0xcb2>
 8027882:	aa22      	add	r2, sp, #136	; 0x88
 8027884:	4649      	mov	r1, r9
 8027886:	4650      	mov	r0, sl
 8027888:	f002 fbb9 	bl	8029ffe <__ssprint_r>
 802788c:	2800      	cmp	r0, #0
 802788e:	f040 8637 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027892:	ac25      	add	r4, sp, #148	; 0x94
 8027894:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
 8027898:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802789a:	b16a      	cbz	r2, 80278b8 <_svfprintf_r+0x6e0>
 802789c:	f10d 026b 	add.w	r2, sp, #107	; 0x6b
 80278a0:	6022      	str	r2, [r4, #0]
 80278a2:	2201      	movs	r2, #1
 80278a4:	4413      	add	r3, r2
 80278a6:	9324      	str	r3, [sp, #144]	; 0x90
 80278a8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80278aa:	6062      	str	r2, [r4, #4]
 80278ac:	4413      	add	r3, r2
 80278ae:	2b07      	cmp	r3, #7
 80278b0:	9323      	str	r3, [sp, #140]	; 0x8c
 80278b2:	f300 82ec 	bgt.w	8027e8e <_svfprintf_r+0xcb6>
 80278b6:	3408      	adds	r4, #8
 80278b8:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80278ba:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80278bc:	b162      	cbz	r2, 80278d8 <_svfprintf_r+0x700>
 80278be:	aa1b      	add	r2, sp, #108	; 0x6c
 80278c0:	6022      	str	r2, [r4, #0]
 80278c2:	2202      	movs	r2, #2
 80278c4:	4413      	add	r3, r2
 80278c6:	9324      	str	r3, [sp, #144]	; 0x90
 80278c8:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80278ca:	6062      	str	r2, [r4, #4]
 80278cc:	3301      	adds	r3, #1
 80278ce:	2b07      	cmp	r3, #7
 80278d0:	9323      	str	r3, [sp, #140]	; 0x8c
 80278d2:	f300 82e6 	bgt.w	8027ea2 <_svfprintf_r+0xcca>
 80278d6:	3408      	adds	r4, #8
 80278d8:	9b18      	ldr	r3, [sp, #96]	; 0x60
 80278da:	2b80      	cmp	r3, #128	; 0x80
 80278dc:	d122      	bne.n	8027924 <_svfprintf_r+0x74c>
 80278de:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 80278e2:	1a9b      	subs	r3, r3, r2
 80278e4:	2b00      	cmp	r3, #0
 80278e6:	9312      	str	r3, [sp, #72]	; 0x48
 80278e8:	dd1c      	ble.n	8027924 <_svfprintf_r+0x74c>
 80278ea:	9812      	ldr	r0, [sp, #72]	; 0x48
 80278ec:	e9dd 2323 	ldrd	r2, r3, [sp, #140]	; 0x8c
 80278f0:	2810      	cmp	r0, #16
 80278f2:	4819      	ldr	r0, [pc, #100]	; (8027958 <_svfprintf_r+0x780>)
 80278f4:	6020      	str	r0, [r4, #0]
 80278f6:	f102 0201 	add.w	r2, r2, #1
 80278fa:	f104 0108 	add.w	r1, r4, #8
 80278fe:	f300 82da 	bgt.w	8027eb6 <_svfprintf_r+0xcde>
 8027902:	9812      	ldr	r0, [sp, #72]	; 0x48
 8027904:	6060      	str	r0, [r4, #4]
 8027906:	4403      	add	r3, r0
 8027908:	2a07      	cmp	r2, #7
 802790a:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 802790e:	f340 82e7 	ble.w	8027ee0 <_svfprintf_r+0xd08>
 8027912:	aa22      	add	r2, sp, #136	; 0x88
 8027914:	4649      	mov	r1, r9
 8027916:	4650      	mov	r0, sl
 8027918:	f002 fb71 	bl	8029ffe <__ssprint_r>
 802791c:	2800      	cmp	r0, #0
 802791e:	f040 85ef 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027922:	ac25      	add	r4, sp, #148	; 0x94
 8027924:	eba7 0708 	sub.w	r7, r7, r8
 8027928:	2f00      	cmp	r7, #0
 802792a:	dd27      	ble.n	802797c <_svfprintf_r+0x7a4>
 802792c:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8027930:	4809      	ldr	r0, [pc, #36]	; (8027958 <_svfprintf_r+0x780>)
 8027932:	6020      	str	r0, [r4, #0]
 8027934:	2f10      	cmp	r7, #16
 8027936:	f103 0301 	add.w	r3, r3, #1
 802793a:	f104 0108 	add.w	r1, r4, #8
 802793e:	f300 82d1 	bgt.w	8027ee4 <_svfprintf_r+0xd0c>
 8027942:	e00b      	b.n	802795c <_svfprintf_r+0x784>
 8027944:	08037566 	.word	0x08037566
 8027948:	08037555 	.word	0x08037555
 802794c:	40300000 	.word	0x40300000
 8027950:	3fe00000 	.word	0x3fe00000
 8027954:	08037579 	.word	0x08037579
 8027958:	08037589 	.word	0x08037589
 802795c:	6067      	str	r7, [r4, #4]
 802795e:	2b07      	cmp	r3, #7
 8027960:	4417      	add	r7, r2
 8027962:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8027966:	f340 82d0 	ble.w	8027f0a <_svfprintf_r+0xd32>
 802796a:	aa22      	add	r2, sp, #136	; 0x88
 802796c:	4649      	mov	r1, r9
 802796e:	4650      	mov	r0, sl
 8027970:	f002 fb45 	bl	8029ffe <__ssprint_r>
 8027974:	2800      	cmp	r0, #0
 8027976:	f040 85c3 	bne.w	8028500 <_svfprintf_r+0x1328>
 802797a:	ac25      	add	r4, sp, #148	; 0x94
 802797c:	f41b 7f80 	tst.w	fp, #256	; 0x100
 8027980:	9f24      	ldr	r7, [sp, #144]	; 0x90
 8027982:	f040 82c9 	bne.w	8027f18 <_svfprintf_r+0xd40>
 8027986:	9b03      	ldr	r3, [sp, #12]
 8027988:	e9c4 3800 	strd	r3, r8, [r4]
 802798c:	4447      	add	r7, r8
 802798e:	9724      	str	r7, [sp, #144]	; 0x90
 8027990:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027992:	3301      	adds	r3, #1
 8027994:	2b07      	cmp	r3, #7
 8027996:	9323      	str	r3, [sp, #140]	; 0x8c
 8027998:	f300 8303 	bgt.w	8027fa2 <_svfprintf_r+0xdca>
 802799c:	3408      	adds	r4, #8
 802799e:	f01b 0f04 	tst.w	fp, #4
 80279a2:	f040 858f 	bne.w	80284c4 <_svfprintf_r+0x12ec>
 80279a6:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 80279aa:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80279ac:	428a      	cmp	r2, r1
 80279ae:	bfac      	ite	ge
 80279b0:	189b      	addge	r3, r3, r2
 80279b2:	185b      	addlt	r3, r3, r1
 80279b4:	930b      	str	r3, [sp, #44]	; 0x2c
 80279b6:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80279b8:	b13b      	cbz	r3, 80279ca <_svfprintf_r+0x7f2>
 80279ba:	aa22      	add	r2, sp, #136	; 0x88
 80279bc:	4649      	mov	r1, r9
 80279be:	4650      	mov	r0, sl
 80279c0:	f002 fb1d 	bl	8029ffe <__ssprint_r>
 80279c4:	2800      	cmp	r0, #0
 80279c6:	f040 859b 	bne.w	8028500 <_svfprintf_r+0x1328>
 80279ca:	2300      	movs	r3, #0
 80279cc:	9323      	str	r3, [sp, #140]	; 0x8c
 80279ce:	9b04      	ldr	r3, [sp, #16]
 80279d0:	2b00      	cmp	r3, #0
 80279d2:	f040 85b1 	bne.w	8028538 <_svfprintf_r+0x1360>
 80279d6:	ac25      	add	r4, sp, #148	; 0x94
 80279d8:	e0e7      	b.n	8027baa <_svfprintf_r+0x9d2>
 80279da:	ab35      	add	r3, sp, #212	; 0xd4
 80279dc:	9004      	str	r0, [sp, #16]
 80279de:	9303      	str	r3, [sp, #12]
 80279e0:	e62a      	b.n	8027638 <_svfprintf_r+0x460>
 80279e2:	9b03      	ldr	r3, [sp, #12]
 80279e4:	9304      	str	r3, [sp, #16]
 80279e6:	e627      	b.n	8027638 <_svfprintf_r+0x460>
 80279e8:	9004      	str	r0, [sp, #16]
 80279ea:	f04f 0806 	mov.w	r8, #6
 80279ee:	e623      	b.n	8027638 <_svfprintf_r+0x460>
 80279f0:	9004      	str	r0, [sp, #16]
 80279f2:	e621      	b.n	8027638 <_svfprintf_r+0x460>
 80279f4:	ed9d 7b0c 	vldr	d7, [sp, #48]	; 0x30
 80279f8:	2300      	movs	r3, #0
 80279fa:	eeb0 8a47 	vmov.f32	s16, s14
 80279fe:	eef0 8a67 	vmov.f32	s17, s15
 8027a02:	e629      	b.n	8027658 <_svfprintf_r+0x480>
 8027a04:	f802 0c01 	strb.w	r0, [r2, #-1]
 8027a08:	e68b      	b.n	8027722 <_svfprintf_r+0x54a>
 8027a0a:	f803 0b01 	strb.w	r0, [r3], #1
 8027a0e:	1aca      	subs	r2, r1, r3
 8027a10:	2a00      	cmp	r2, #0
 8027a12:	dafa      	bge.n	8027a0a <_svfprintf_r+0x832>
 8027a14:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8027a16:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8027a18:	3201      	adds	r2, #1
 8027a1a:	f103 0301 	add.w	r3, r3, #1
 8027a1e:	bfb8      	it	lt
 8027a20:	2300      	movlt	r3, #0
 8027a22:	441d      	add	r5, r3
 8027a24:	e68d      	b.n	8027742 <_svfprintf_r+0x56a>
 8027a26:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8027a28:	462b      	mov	r3, r5
 8027a2a:	18a9      	adds	r1, r5, r2
 8027a2c:	2030      	movs	r0, #48	; 0x30
 8027a2e:	e7ee      	b.n	8027a0e <_svfprintf_r+0x836>
 8027a30:	9b08      	ldr	r3, [sp, #32]
 8027a32:	2b46      	cmp	r3, #70	; 0x46
 8027a34:	d005      	beq.n	8027a42 <_svfprintf_r+0x86a>
 8027a36:	2b45      	cmp	r3, #69	; 0x45
 8027a38:	d11d      	bne.n	8027a76 <_svfprintf_r+0x89e>
 8027a3a:	f108 0501 	add.w	r5, r8, #1
 8027a3e:	2102      	movs	r1, #2
 8027a40:	e001      	b.n	8027a46 <_svfprintf_r+0x86e>
 8027a42:	4645      	mov	r5, r8
 8027a44:	2103      	movs	r1, #3
 8027a46:	ab20      	add	r3, sp, #128	; 0x80
 8027a48:	9301      	str	r3, [sp, #4]
 8027a4a:	ab1d      	add	r3, sp, #116	; 0x74
 8027a4c:	9300      	str	r3, [sp, #0]
 8027a4e:	462a      	mov	r2, r5
 8027a50:	ab1c      	add	r3, sp, #112	; 0x70
 8027a52:	4650      	mov	r0, sl
 8027a54:	eeb0 0a48 	vmov.f32	s0, s16
 8027a58:	eef0 0a68 	vmov.f32	s1, s17
 8027a5c:	f001 f804 	bl	8028a68 <_dtoa_r>
 8027a60:	9b08      	ldr	r3, [sp, #32]
 8027a62:	9003      	str	r0, [sp, #12]
 8027a64:	2b47      	cmp	r3, #71	; 0x47
 8027a66:	d108      	bne.n	8027a7a <_svfprintf_r+0x8a2>
 8027a68:	f01b 0f01 	tst.w	fp, #1
 8027a6c:	d105      	bne.n	8027a7a <_svfprintf_r+0x8a2>
 8027a6e:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8027a70:	9a03      	ldr	r2, [sp, #12]
 8027a72:	1a9b      	subs	r3, r3, r2
 8027a74:	e667      	b.n	8027746 <_svfprintf_r+0x56e>
 8027a76:	4645      	mov	r5, r8
 8027a78:	e7e1      	b.n	8027a3e <_svfprintf_r+0x866>
 8027a7a:	9b03      	ldr	r3, [sp, #12]
 8027a7c:	195e      	adds	r6, r3, r5
 8027a7e:	9b08      	ldr	r3, [sp, #32]
 8027a80:	2b46      	cmp	r3, #70	; 0x46
 8027a82:	d10f      	bne.n	8027aa4 <_svfprintf_r+0x8cc>
 8027a84:	9b03      	ldr	r3, [sp, #12]
 8027a86:	781b      	ldrb	r3, [r3, #0]
 8027a88:	2b30      	cmp	r3, #48	; 0x30
 8027a8a:	d109      	bne.n	8027aa0 <_svfprintf_r+0x8c8>
 8027a8c:	ec51 0b18 	vmov	r0, r1, d8
 8027a90:	2200      	movs	r2, #0
 8027a92:	2300      	movs	r3, #0
 8027a94:	f7d9 f830 	bl	8000af8 <__aeabi_dcmpeq>
 8027a98:	b910      	cbnz	r0, 8027aa0 <_svfprintf_r+0x8c8>
 8027a9a:	f1c5 0501 	rsb	r5, r5, #1
 8027a9e:	951c      	str	r5, [sp, #112]	; 0x70
 8027aa0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8027aa2:	441e      	add	r6, r3
 8027aa4:	ec51 0b18 	vmov	r0, r1, d8
 8027aa8:	2200      	movs	r2, #0
 8027aaa:	2300      	movs	r3, #0
 8027aac:	f7d9 f824 	bl	8000af8 <__aeabi_dcmpeq>
 8027ab0:	b100      	cbz	r0, 8027ab4 <_svfprintf_r+0x8dc>
 8027ab2:	9620      	str	r6, [sp, #128]	; 0x80
 8027ab4:	2230      	movs	r2, #48	; 0x30
 8027ab6:	9b20      	ldr	r3, [sp, #128]	; 0x80
 8027ab8:	429e      	cmp	r6, r3
 8027aba:	d9d8      	bls.n	8027a6e <_svfprintf_r+0x896>
 8027abc:	1c59      	adds	r1, r3, #1
 8027abe:	9120      	str	r1, [sp, #128]	; 0x80
 8027ac0:	701a      	strb	r2, [r3, #0]
 8027ac2:	e7f8      	b.n	8027ab6 <_svfprintf_r+0x8de>
 8027ac4:	9b08      	ldr	r3, [sp, #32]
 8027ac6:	2b46      	cmp	r3, #70	; 0x46
 8027ac8:	f47f ae4b 	bne.w	8027762 <_svfprintf_r+0x58a>
 8027acc:	f00b 0301 	and.w	r3, fp, #1
 8027ad0:	2d00      	cmp	r5, #0
 8027ad2:	ea43 0308 	orr.w	r3, r3, r8
 8027ad6:	dd25      	ble.n	8027b24 <_svfprintf_r+0x94c>
 8027ad8:	b383      	cbz	r3, 8027b3c <_svfprintf_r+0x964>
 8027ada:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027adc:	18eb      	adds	r3, r5, r3
 8027ade:	4498      	add	r8, r3
 8027ae0:	2366      	movs	r3, #102	; 0x66
 8027ae2:	9307      	str	r3, [sp, #28]
 8027ae4:	e030      	b.n	8027b48 <_svfprintf_r+0x970>
 8027ae6:	f813 6b01 	ldrb.w	r6, [r3], #1
 8027aea:	f805 6f01 	strb.w	r6, [r5, #1]!
 8027aee:	e66f      	b.n	80277d0 <_svfprintf_r+0x5f8>
 8027af0:	b941      	cbnz	r1, 8027b04 <_svfprintf_r+0x92c>
 8027af2:	2230      	movs	r2, #48	; 0x30
 8027af4:	f88d 207a 	strb.w	r2, [sp, #122]	; 0x7a
 8027af8:	f10d 027b 	add.w	r2, sp, #123	; 0x7b
 8027afc:	3330      	adds	r3, #48	; 0x30
 8027afe:	f802 3b01 	strb.w	r3, [r2], #1
 8027b02:	e671      	b.n	80277e8 <_svfprintf_r+0x610>
 8027b04:	f10d 027a 	add.w	r2, sp, #122	; 0x7a
 8027b08:	e7f8      	b.n	8027afc <_svfprintf_r+0x924>
 8027b0a:	9b05      	ldr	r3, [sp, #20]
 8027b0c:	42ab      	cmp	r3, r5
 8027b0e:	dd0d      	ble.n	8027b2c <_svfprintf_r+0x954>
 8027b10:	9b05      	ldr	r3, [sp, #20]
 8027b12:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027b14:	2d00      	cmp	r5, #0
 8027b16:	eb03 0802 	add.w	r8, r3, r2
 8027b1a:	dc0d      	bgt.n	8027b38 <_svfprintf_r+0x960>
 8027b1c:	f1c5 0301 	rsb	r3, r5, #1
 8027b20:	4498      	add	r8, r3
 8027b22:	e009      	b.n	8027b38 <_svfprintf_r+0x960>
 8027b24:	b163      	cbz	r3, 8027b40 <_svfprintf_r+0x968>
 8027b26:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027b28:	3301      	adds	r3, #1
 8027b2a:	e7d8      	b.n	8027ade <_svfprintf_r+0x906>
 8027b2c:	f01b 0f01 	tst.w	fp, #1
 8027b30:	d01d      	beq.n	8027b6e <_svfprintf_r+0x996>
 8027b32:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027b34:	eb05 0803 	add.w	r8, r5, r3
 8027b38:	2367      	movs	r3, #103	; 0x67
 8027b3a:	e7d2      	b.n	8027ae2 <_svfprintf_r+0x90a>
 8027b3c:	46a8      	mov	r8, r5
 8027b3e:	e7cf      	b.n	8027ae0 <_svfprintf_r+0x908>
 8027b40:	2366      	movs	r3, #102	; 0x66
 8027b42:	9307      	str	r3, [sp, #28]
 8027b44:	f04f 0801 	mov.w	r8, #1
 8027b48:	f41b 6380 	ands.w	r3, fp, #1024	; 0x400
 8027b4c:	9308      	str	r3, [sp, #32]
 8027b4e:	d01f      	beq.n	8027b90 <_svfprintf_r+0x9b8>
 8027b50:	2600      	movs	r6, #0
 8027b52:	2d00      	cmp	r5, #0
 8027b54:	9608      	str	r6, [sp, #32]
 8027b56:	f77f ae5c 	ble.w	8027812 <_svfprintf_r+0x63a>
 8027b5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027b5c:	781b      	ldrb	r3, [r3, #0]
 8027b5e:	2bff      	cmp	r3, #255	; 0xff
 8027b60:	d107      	bne.n	8027b72 <_svfprintf_r+0x99a>
 8027b62:	9b08      	ldr	r3, [sp, #32]
 8027b64:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8027b66:	4433      	add	r3, r6
 8027b68:	fb02 8803 	mla	r8, r2, r3, r8
 8027b6c:	e651      	b.n	8027812 <_svfprintf_r+0x63a>
 8027b6e:	46a8      	mov	r8, r5
 8027b70:	e7e2      	b.n	8027b38 <_svfprintf_r+0x960>
 8027b72:	42ab      	cmp	r3, r5
 8027b74:	daf5      	bge.n	8027b62 <_svfprintf_r+0x98a>
 8027b76:	1aed      	subs	r5, r5, r3
 8027b78:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027b7a:	785b      	ldrb	r3, [r3, #1]
 8027b7c:	b133      	cbz	r3, 8027b8c <_svfprintf_r+0x9b4>
 8027b7e:	9b08      	ldr	r3, [sp, #32]
 8027b80:	3301      	adds	r3, #1
 8027b82:	9308      	str	r3, [sp, #32]
 8027b84:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027b86:	3301      	adds	r3, #1
 8027b88:	9309      	str	r3, [sp, #36]	; 0x24
 8027b8a:	e7e6      	b.n	8027b5a <_svfprintf_r+0x982>
 8027b8c:	3601      	adds	r6, #1
 8027b8e:	e7e4      	b.n	8027b5a <_svfprintf_r+0x982>
 8027b90:	9e08      	ldr	r6, [sp, #32]
 8027b92:	e63e      	b.n	8027812 <_svfprintf_r+0x63a>
 8027b94:	1d2b      	adds	r3, r5, #4
 8027b96:	f01b 0f20 	tst.w	fp, #32
 8027b9a:	9306      	str	r3, [sp, #24]
 8027b9c:	d00a      	beq.n	8027bb4 <_svfprintf_r+0x9dc>
 8027b9e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8027ba0:	682b      	ldr	r3, [r5, #0]
 8027ba2:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8027ba4:	17d2      	asrs	r2, r2, #31
 8027ba6:	e9c3 1200 	strd	r1, r2, [r3]
 8027baa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8027bac:	9d06      	ldr	r5, [sp, #24]
 8027bae:	9303      	str	r3, [sp, #12]
 8027bb0:	f7ff bb52 	b.w	8027258 <_svfprintf_r+0x80>
 8027bb4:	f01b 0f10 	tst.w	fp, #16
 8027bb8:	d003      	beq.n	8027bc2 <_svfprintf_r+0x9ea>
 8027bba:	682b      	ldr	r3, [r5, #0]
 8027bbc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8027bbe:	601a      	str	r2, [r3, #0]
 8027bc0:	e7f3      	b.n	8027baa <_svfprintf_r+0x9d2>
 8027bc2:	f01b 0f40 	tst.w	fp, #64	; 0x40
 8027bc6:	d003      	beq.n	8027bd0 <_svfprintf_r+0x9f8>
 8027bc8:	682b      	ldr	r3, [r5, #0]
 8027bca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8027bcc:	801a      	strh	r2, [r3, #0]
 8027bce:	e7ec      	b.n	8027baa <_svfprintf_r+0x9d2>
 8027bd0:	f41b 7f00 	tst.w	fp, #512	; 0x200
 8027bd4:	d0f1      	beq.n	8027bba <_svfprintf_r+0x9e2>
 8027bd6:	682b      	ldr	r3, [r5, #0]
 8027bd8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8027bda:	701a      	strb	r2, [r3, #0]
 8027bdc:	e7e5      	b.n	8027baa <_svfprintf_r+0x9d2>
 8027bde:	f04b 0b10 	orr.w	fp, fp, #16
 8027be2:	f01b 0320 	ands.w	r3, fp, #32
 8027be6:	d020      	beq.n	8027c2a <_svfprintf_r+0xa52>
 8027be8:	3507      	adds	r5, #7
 8027bea:	f025 0307 	bic.w	r3, r5, #7
 8027bee:	461a      	mov	r2, r3
 8027bf0:	685e      	ldr	r6, [r3, #4]
 8027bf2:	f852 5b08 	ldr.w	r5, [r2], #8
 8027bf6:	9206      	str	r2, [sp, #24]
 8027bf8:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8027bfc:	2300      	movs	r3, #0
 8027bfe:	2200      	movs	r2, #0
 8027c00:	f88d 206b 	strb.w	r2, [sp, #107]	; 0x6b
 8027c04:	f1b8 3fff 	cmp.w	r8, #4294967295
 8027c08:	f000 84a7 	beq.w	802855a <_svfprintf_r+0x1382>
 8027c0c:	f02b 0280 	bic.w	r2, fp, #128	; 0x80
 8027c10:	9204      	str	r2, [sp, #16]
 8027c12:	ea55 0206 	orrs.w	r2, r5, r6
 8027c16:	f040 84a6 	bne.w	8028566 <_svfprintf_r+0x138e>
 8027c1a:	f1b8 0f00 	cmp.w	r8, #0
 8027c1e:	f000 8107 	beq.w	8027e30 <_svfprintf_r+0xc58>
 8027c22:	2b01      	cmp	r3, #1
 8027c24:	f040 84a2 	bne.w	802856c <_svfprintf_r+0x1394>
 8027c28:	e0a3      	b.n	8027d72 <_svfprintf_r+0xb9a>
 8027c2a:	462a      	mov	r2, r5
 8027c2c:	f01b 0610 	ands.w	r6, fp, #16
 8027c30:	f852 5b04 	ldr.w	r5, [r2], #4
 8027c34:	9206      	str	r2, [sp, #24]
 8027c36:	d001      	beq.n	8027c3c <_svfprintf_r+0xa64>
 8027c38:	461e      	mov	r6, r3
 8027c3a:	e7dd      	b.n	8027bf8 <_svfprintf_r+0xa20>
 8027c3c:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 8027c40:	d001      	beq.n	8027c46 <_svfprintf_r+0xa6e>
 8027c42:	b2ad      	uxth	r5, r5
 8027c44:	e7d8      	b.n	8027bf8 <_svfprintf_r+0xa20>
 8027c46:	f41b 7600 	ands.w	r6, fp, #512	; 0x200
 8027c4a:	d0d5      	beq.n	8027bf8 <_svfprintf_r+0xa20>
 8027c4c:	b2ed      	uxtb	r5, r5
 8027c4e:	e7f3      	b.n	8027c38 <_svfprintf_r+0xa60>
 8027c50:	462b      	mov	r3, r5
 8027c52:	2278      	movs	r2, #120	; 0x78
 8027c54:	f853 5b04 	ldr.w	r5, [r3], #4
 8027c58:	9306      	str	r3, [sp, #24]
 8027c5a:	f647 0330 	movw	r3, #30768	; 0x7830
 8027c5e:	f8ad 306c 	strh.w	r3, [sp, #108]	; 0x6c
 8027c62:	4bab      	ldr	r3, [pc, #684]	; (8027f10 <_svfprintf_r+0xd38>)
 8027c64:	9316      	str	r3, [sp, #88]	; 0x58
 8027c66:	2600      	movs	r6, #0
 8027c68:	f04b 0b02 	orr.w	fp, fp, #2
 8027c6c:	2302      	movs	r3, #2
 8027c6e:	9207      	str	r2, [sp, #28]
 8027c70:	e7c5      	b.n	8027bfe <_svfprintf_r+0xa26>
 8027c72:	462b      	mov	r3, r5
 8027c74:	f1b8 3fff 	cmp.w	r8, #4294967295
 8027c78:	f853 2b04 	ldr.w	r2, [r3], #4
 8027c7c:	9203      	str	r2, [sp, #12]
 8027c7e:	f04f 0500 	mov.w	r5, #0
 8027c82:	9306      	str	r3, [sp, #24]
 8027c84:	f88d 506b 	strb.w	r5, [sp, #107]	; 0x6b
 8027c88:	d010      	beq.n	8027cac <_svfprintf_r+0xad4>
 8027c8a:	9803      	ldr	r0, [sp, #12]
 8027c8c:	4642      	mov	r2, r8
 8027c8e:	4629      	mov	r1, r5
 8027c90:	f7d8 fabe 	bl	8000210 <memchr>
 8027c94:	9004      	str	r0, [sp, #16]
 8027c96:	2800      	cmp	r0, #0
 8027c98:	f000 80e0 	beq.w	8027e5c <_svfprintf_r+0xc84>
 8027c9c:	9a03      	ldr	r2, [sp, #12]
 8027c9e:	9504      	str	r5, [sp, #16]
 8027ca0:	eba0 0802 	sub.w	r8, r0, r2
 8027ca4:	462f      	mov	r7, r5
 8027ca6:	462e      	mov	r6, r5
 8027ca8:	9508      	str	r5, [sp, #32]
 8027caa:	e5ba      	b.n	8027822 <_svfprintf_r+0x64a>
 8027cac:	9803      	ldr	r0, [sp, #12]
 8027cae:	f7d8 faa1 	bl	80001f4 <strlen>
 8027cb2:	462f      	mov	r7, r5
 8027cb4:	4680      	mov	r8, r0
 8027cb6:	9504      	str	r5, [sp, #16]
 8027cb8:	463e      	mov	r6, r7
 8027cba:	463b      	mov	r3, r7
 8027cbc:	e460      	b.n	8027580 <_svfprintf_r+0x3a8>
 8027cbe:	f04b 0b10 	orr.w	fp, fp, #16
 8027cc2:	f01b 0320 	ands.w	r3, fp, #32
 8027cc6:	d009      	beq.n	8027cdc <_svfprintf_r+0xb04>
 8027cc8:	3507      	adds	r5, #7
 8027cca:	f025 0307 	bic.w	r3, r5, #7
 8027cce:	461a      	mov	r2, r3
 8027cd0:	685e      	ldr	r6, [r3, #4]
 8027cd2:	f852 5b08 	ldr.w	r5, [r2], #8
 8027cd6:	9206      	str	r2, [sp, #24]
 8027cd8:	2301      	movs	r3, #1
 8027cda:	e790      	b.n	8027bfe <_svfprintf_r+0xa26>
 8027cdc:	462a      	mov	r2, r5
 8027cde:	f01b 0610 	ands.w	r6, fp, #16
 8027ce2:	f852 5b04 	ldr.w	r5, [r2], #4
 8027ce6:	9206      	str	r2, [sp, #24]
 8027ce8:	d001      	beq.n	8027cee <_svfprintf_r+0xb16>
 8027cea:	461e      	mov	r6, r3
 8027cec:	e7f4      	b.n	8027cd8 <_svfprintf_r+0xb00>
 8027cee:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 8027cf2:	d001      	beq.n	8027cf8 <_svfprintf_r+0xb20>
 8027cf4:	b2ad      	uxth	r5, r5
 8027cf6:	e7ef      	b.n	8027cd8 <_svfprintf_r+0xb00>
 8027cf8:	f41b 7600 	ands.w	r6, fp, #512	; 0x200
 8027cfc:	d0ec      	beq.n	8027cd8 <_svfprintf_r+0xb00>
 8027cfe:	b2ed      	uxtb	r5, r5
 8027d00:	e7f3      	b.n	8027cea <_svfprintf_r+0xb12>
 8027d02:	4b84      	ldr	r3, [pc, #528]	; (8027f14 <_svfprintf_r+0xd3c>)
 8027d04:	9316      	str	r3, [sp, #88]	; 0x58
 8027d06:	f01b 0320 	ands.w	r3, fp, #32
 8027d0a:	d01b      	beq.n	8027d44 <_svfprintf_r+0xb6c>
 8027d0c:	3507      	adds	r5, #7
 8027d0e:	f025 0307 	bic.w	r3, r5, #7
 8027d12:	461a      	mov	r2, r3
 8027d14:	685e      	ldr	r6, [r3, #4]
 8027d16:	f852 5b08 	ldr.w	r5, [r2], #8
 8027d1a:	9206      	str	r2, [sp, #24]
 8027d1c:	f01b 0f01 	tst.w	fp, #1
 8027d20:	d00a      	beq.n	8027d38 <_svfprintf_r+0xb60>
 8027d22:	ea55 0306 	orrs.w	r3, r5, r6
 8027d26:	d007      	beq.n	8027d38 <_svfprintf_r+0xb60>
 8027d28:	2330      	movs	r3, #48	; 0x30
 8027d2a:	f88d 306c 	strb.w	r3, [sp, #108]	; 0x6c
 8027d2e:	9b07      	ldr	r3, [sp, #28]
 8027d30:	f88d 306d 	strb.w	r3, [sp, #109]	; 0x6d
 8027d34:	f04b 0b02 	orr.w	fp, fp, #2
 8027d38:	f42b 6b80 	bic.w	fp, fp, #1024	; 0x400
 8027d3c:	2302      	movs	r3, #2
 8027d3e:	e75e      	b.n	8027bfe <_svfprintf_r+0xa26>
 8027d40:	4b73      	ldr	r3, [pc, #460]	; (8027f10 <_svfprintf_r+0xd38>)
 8027d42:	e7df      	b.n	8027d04 <_svfprintf_r+0xb2c>
 8027d44:	462a      	mov	r2, r5
 8027d46:	f01b 0610 	ands.w	r6, fp, #16
 8027d4a:	f852 5b04 	ldr.w	r5, [r2], #4
 8027d4e:	9206      	str	r2, [sp, #24]
 8027d50:	d001      	beq.n	8027d56 <_svfprintf_r+0xb7e>
 8027d52:	461e      	mov	r6, r3
 8027d54:	e7e2      	b.n	8027d1c <_svfprintf_r+0xb44>
 8027d56:	f01b 0340 	ands.w	r3, fp, #64	; 0x40
 8027d5a:	d001      	beq.n	8027d60 <_svfprintf_r+0xb88>
 8027d5c:	b2ad      	uxth	r5, r5
 8027d5e:	e7dd      	b.n	8027d1c <_svfprintf_r+0xb44>
 8027d60:	f41b 7600 	ands.w	r6, fp, #512	; 0x200
 8027d64:	d0da      	beq.n	8027d1c <_svfprintf_r+0xb44>
 8027d66:	b2ed      	uxtb	r5, r5
 8027d68:	e7f3      	b.n	8027d52 <_svfprintf_r+0xb7a>
 8027d6a:	2d0a      	cmp	r5, #10
 8027d6c:	f176 0300 	sbcs.w	r3, r6, #0
 8027d70:	d206      	bcs.n	8027d80 <_svfprintf_r+0xba8>
 8027d72:	3530      	adds	r5, #48	; 0x30
 8027d74:	f88d 5137 	strb.w	r5, [sp, #311]	; 0x137
 8027d78:	f20d 1337 	addw	r3, sp, #311	; 0x137
 8027d7c:	f000 bc16 	b.w	80285ac <_svfprintf_r+0x13d4>
 8027d80:	2300      	movs	r3, #0
 8027d82:	9305      	str	r3, [sp, #20]
 8027d84:	9b04      	ldr	r3, [sp, #16]
 8027d86:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8027d8a:	af4e      	add	r7, sp, #312	; 0x138
 8027d8c:	9308      	str	r3, [sp, #32]
 8027d8e:	220a      	movs	r2, #10
 8027d90:	2300      	movs	r3, #0
 8027d92:	4628      	mov	r0, r5
 8027d94:	4631      	mov	r1, r6
 8027d96:	f7d8 ff1f 	bl	8000bd8 <__aeabi_uldivmod>
 8027d9a:	1e7b      	subs	r3, r7, #1
 8027d9c:	9303      	str	r3, [sp, #12]
 8027d9e:	9b05      	ldr	r3, [sp, #20]
 8027da0:	9010      	str	r0, [sp, #64]	; 0x40
 8027da2:	3301      	adds	r3, #1
 8027da4:	9305      	str	r3, [sp, #20]
 8027da6:	9b08      	ldr	r3, [sp, #32]
 8027da8:	3230      	adds	r2, #48	; 0x30
 8027daa:	468b      	mov	fp, r1
 8027dac:	f807 2c01 	strb.w	r2, [r7, #-1]
 8027db0:	b1d3      	cbz	r3, 8027de8 <_svfprintf_r+0xc10>
 8027db2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027db4:	9a05      	ldr	r2, [sp, #20]
 8027db6:	781b      	ldrb	r3, [r3, #0]
 8027db8:	429a      	cmp	r2, r3
 8027dba:	d115      	bne.n	8027de8 <_svfprintf_r+0xc10>
 8027dbc:	2aff      	cmp	r2, #255	; 0xff
 8027dbe:	d013      	beq.n	8027de8 <_svfprintf_r+0xc10>
 8027dc0:	2d0a      	cmp	r5, #10
 8027dc2:	f176 0300 	sbcs.w	r3, r6, #0
 8027dc6:	d30f      	bcc.n	8027de8 <_svfprintf_r+0xc10>
 8027dc8:	9b03      	ldr	r3, [sp, #12]
 8027dca:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8027dcc:	9914      	ldr	r1, [sp, #80]	; 0x50
 8027dce:	1a9b      	subs	r3, r3, r2
 8027dd0:	4618      	mov	r0, r3
 8027dd2:	9303      	str	r3, [sp, #12]
 8027dd4:	f000 fcf9 	bl	80287ca <strncpy>
 8027dd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027dda:	785b      	ldrb	r3, [r3, #1]
 8027ddc:	b11b      	cbz	r3, 8027de6 <_svfprintf_r+0xc0e>
 8027dde:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027de0:	3301      	adds	r3, #1
 8027de2:	9309      	str	r3, [sp, #36]	; 0x24
 8027de4:	2300      	movs	r3, #0
 8027de6:	9305      	str	r3, [sp, #20]
 8027de8:	2d0a      	cmp	r5, #10
 8027dea:	f176 0600 	sbcs.w	r6, r6, #0
 8027dee:	d20b      	bcs.n	8027e08 <_svfprintf_r+0xc30>
 8027df0:	9b03      	ldr	r3, [sp, #12]
 8027df2:	f8dd b010 	ldr.w	fp, [sp, #16]
 8027df6:	aa4e      	add	r2, sp, #312	; 0x138
 8027df8:	4647      	mov	r7, r8
 8027dfa:	eba2 0803 	sub.w	r8, r2, r3
 8027dfe:	2300      	movs	r3, #0
 8027e00:	9304      	str	r3, [sp, #16]
 8027e02:	461e      	mov	r6, r3
 8027e04:	f7ff bbbc 	b.w	8027580 <_svfprintf_r+0x3a8>
 8027e08:	9d10      	ldr	r5, [sp, #64]	; 0x40
 8027e0a:	9f03      	ldr	r7, [sp, #12]
 8027e0c:	465e      	mov	r6, fp
 8027e0e:	e7be      	b.n	8027d8e <_svfprintf_r+0xbb6>
 8027e10:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8027e12:	f005 030f 	and.w	r3, r5, #15
 8027e16:	092d      	lsrs	r5, r5, #4
 8027e18:	5cd3      	ldrb	r3, [r2, r3]
 8027e1a:	9a03      	ldr	r2, [sp, #12]
 8027e1c:	ea45 7506 	orr.w	r5, r5, r6, lsl #28
 8027e20:	f802 3d01 	strb.w	r3, [r2, #-1]!
 8027e24:	0936      	lsrs	r6, r6, #4
 8027e26:	ea55 0306 	orrs.w	r3, r5, r6
 8027e2a:	9203      	str	r2, [sp, #12]
 8027e2c:	d1f0      	bne.n	8027e10 <_svfprintf_r+0xc38>
 8027e2e:	e7df      	b.n	8027df0 <_svfprintf_r+0xc18>
 8027e30:	b933      	cbnz	r3, 8027e40 <_svfprintf_r+0xc68>
 8027e32:	f01b 0f01 	tst.w	fp, #1
 8027e36:	d003      	beq.n	8027e40 <_svfprintf_r+0xc68>
 8027e38:	2330      	movs	r3, #48	; 0x30
 8027e3a:	f88d 3137 	strb.w	r3, [sp, #311]	; 0x137
 8027e3e:	e79b      	b.n	8027d78 <_svfprintf_r+0xba0>
 8027e40:	ab4e      	add	r3, sp, #312	; 0x138
 8027e42:	e3b3      	b.n	80285ac <_svfprintf_r+0x13d4>
 8027e44:	9b07      	ldr	r3, [sp, #28]
 8027e46:	2b00      	cmp	r3, #0
 8027e48:	f000 837c 	beq.w	8028544 <_svfprintf_r+0x136c>
 8027e4c:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
 8027e50:	2300      	movs	r3, #0
 8027e52:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b
 8027e56:	9506      	str	r5, [sp, #24]
 8027e58:	f7ff bb1f 	b.w	802749a <_svfprintf_r+0x2c2>
 8027e5c:	9f04      	ldr	r7, [sp, #16]
 8027e5e:	e72b      	b.n	8027cb8 <_svfprintf_r+0xae0>
 8027e60:	2010      	movs	r0, #16
 8027e62:	4403      	add	r3, r0
 8027e64:	2a07      	cmp	r2, #7
 8027e66:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8027e6a:	6060      	str	r0, [r4, #4]
 8027e6c:	dd08      	ble.n	8027e80 <_svfprintf_r+0xca8>
 8027e6e:	aa22      	add	r2, sp, #136	; 0x88
 8027e70:	4649      	mov	r1, r9
 8027e72:	4650      	mov	r0, sl
 8027e74:	f002 f8c3 	bl	8029ffe <__ssprint_r>
 8027e78:	2800      	cmp	r0, #0
 8027e7a:	f040 8341 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027e7e:	a925      	add	r1, sp, #148	; 0x94
 8027e80:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8027e82:	3b10      	subs	r3, #16
 8027e84:	9312      	str	r3, [sp, #72]	; 0x48
 8027e86:	460c      	mov	r4, r1
 8027e88:	e4e7      	b.n	802785a <_svfprintf_r+0x682>
 8027e8a:	460c      	mov	r4, r1
 8027e8c:	e502      	b.n	8027894 <_svfprintf_r+0x6bc>
 8027e8e:	aa22      	add	r2, sp, #136	; 0x88
 8027e90:	4649      	mov	r1, r9
 8027e92:	4650      	mov	r0, sl
 8027e94:	f002 f8b3 	bl	8029ffe <__ssprint_r>
 8027e98:	2800      	cmp	r0, #0
 8027e9a:	f040 8331 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027e9e:	ac25      	add	r4, sp, #148	; 0x94
 8027ea0:	e50a      	b.n	80278b8 <_svfprintf_r+0x6e0>
 8027ea2:	aa22      	add	r2, sp, #136	; 0x88
 8027ea4:	4649      	mov	r1, r9
 8027ea6:	4650      	mov	r0, sl
 8027ea8:	f002 f8a9 	bl	8029ffe <__ssprint_r>
 8027eac:	2800      	cmp	r0, #0
 8027eae:	f040 8327 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027eb2:	ac25      	add	r4, sp, #148	; 0x94
 8027eb4:	e510      	b.n	80278d8 <_svfprintf_r+0x700>
 8027eb6:	2010      	movs	r0, #16
 8027eb8:	4403      	add	r3, r0
 8027eba:	2a07      	cmp	r2, #7
 8027ebc:	e9cd 2323 	strd	r2, r3, [sp, #140]	; 0x8c
 8027ec0:	6060      	str	r0, [r4, #4]
 8027ec2:	dd08      	ble.n	8027ed6 <_svfprintf_r+0xcfe>
 8027ec4:	aa22      	add	r2, sp, #136	; 0x88
 8027ec6:	4649      	mov	r1, r9
 8027ec8:	4650      	mov	r0, sl
 8027eca:	f002 f898 	bl	8029ffe <__ssprint_r>
 8027ece:	2800      	cmp	r0, #0
 8027ed0:	f040 8316 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027ed4:	a925      	add	r1, sp, #148	; 0x94
 8027ed6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8027ed8:	3b10      	subs	r3, #16
 8027eda:	9312      	str	r3, [sp, #72]	; 0x48
 8027edc:	460c      	mov	r4, r1
 8027ede:	e504      	b.n	80278ea <_svfprintf_r+0x712>
 8027ee0:	460c      	mov	r4, r1
 8027ee2:	e51f      	b.n	8027924 <_svfprintf_r+0x74c>
 8027ee4:	2010      	movs	r0, #16
 8027ee6:	4402      	add	r2, r0
 8027ee8:	2b07      	cmp	r3, #7
 8027eea:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8027eee:	6060      	str	r0, [r4, #4]
 8027ef0:	dd08      	ble.n	8027f04 <_svfprintf_r+0xd2c>
 8027ef2:	aa22      	add	r2, sp, #136	; 0x88
 8027ef4:	4649      	mov	r1, r9
 8027ef6:	4650      	mov	r0, sl
 8027ef8:	f002 f881 	bl	8029ffe <__ssprint_r>
 8027efc:	2800      	cmp	r0, #0
 8027efe:	f040 82ff 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027f02:	a925      	add	r1, sp, #148	; 0x94
 8027f04:	3f10      	subs	r7, #16
 8027f06:	460c      	mov	r4, r1
 8027f08:	e510      	b.n	802792c <_svfprintf_r+0x754>
 8027f0a:	460c      	mov	r4, r1
 8027f0c:	e536      	b.n	802797c <_svfprintf_r+0x7a4>
 8027f0e:	bf00      	nop
 8027f10:	08037555 	.word	0x08037555
 8027f14:	08037566 	.word	0x08037566
 8027f18:	9b07      	ldr	r3, [sp, #28]
 8027f1a:	2b65      	cmp	r3, #101	; 0x65
 8027f1c:	f340 823a 	ble.w	8028394 <_svfprintf_r+0x11bc>
 8027f20:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 8027f24:	2200      	movs	r2, #0
 8027f26:	2300      	movs	r3, #0
 8027f28:	f7d8 fde6 	bl	8000af8 <__aeabi_dcmpeq>
 8027f2c:	2800      	cmp	r0, #0
 8027f2e:	d068      	beq.n	8028002 <_svfprintf_r+0xe2a>
 8027f30:	4b6d      	ldr	r3, [pc, #436]	; (80280e8 <_svfprintf_r+0xf10>)
 8027f32:	6023      	str	r3, [r4, #0]
 8027f34:	2301      	movs	r3, #1
 8027f36:	441f      	add	r7, r3
 8027f38:	6063      	str	r3, [r4, #4]
 8027f3a:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027f3c:	9724      	str	r7, [sp, #144]	; 0x90
 8027f3e:	3301      	adds	r3, #1
 8027f40:	2b07      	cmp	r3, #7
 8027f42:	9323      	str	r3, [sp, #140]	; 0x8c
 8027f44:	dc37      	bgt.n	8027fb6 <_svfprintf_r+0xdde>
 8027f46:	3408      	adds	r4, #8
 8027f48:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8027f4a:	9a05      	ldr	r2, [sp, #20]
 8027f4c:	4293      	cmp	r3, r2
 8027f4e:	db03      	blt.n	8027f58 <_svfprintf_r+0xd80>
 8027f50:	f01b 0f01 	tst.w	fp, #1
 8027f54:	f43f ad23 	beq.w	802799e <_svfprintf_r+0x7c6>
 8027f58:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8027f5a:	6023      	str	r3, [r4, #0]
 8027f5c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8027f5e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8027f60:	6063      	str	r3, [r4, #4]
 8027f62:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8027f64:	4413      	add	r3, r2
 8027f66:	9324      	str	r3, [sp, #144]	; 0x90
 8027f68:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8027f6a:	3301      	adds	r3, #1
 8027f6c:	2b07      	cmp	r3, #7
 8027f6e:	9323      	str	r3, [sp, #140]	; 0x8c
 8027f70:	dc2b      	bgt.n	8027fca <_svfprintf_r+0xdf2>
 8027f72:	3408      	adds	r4, #8
 8027f74:	9b05      	ldr	r3, [sp, #20]
 8027f76:	1e5d      	subs	r5, r3, #1
 8027f78:	2d00      	cmp	r5, #0
 8027f7a:	f77f ad10 	ble.w	802799e <_svfprintf_r+0x7c6>
 8027f7e:	4e5b      	ldr	r6, [pc, #364]	; (80280ec <_svfprintf_r+0xf14>)
 8027f80:	2710      	movs	r7, #16
 8027f82:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8027f86:	2d10      	cmp	r5, #16
 8027f88:	f103 0301 	add.w	r3, r3, #1
 8027f8c:	f104 0108 	add.w	r1, r4, #8
 8027f90:	6026      	str	r6, [r4, #0]
 8027f92:	dc24      	bgt.n	8027fde <_svfprintf_r+0xe06>
 8027f94:	6065      	str	r5, [r4, #4]
 8027f96:	4415      	add	r5, r2
 8027f98:	9524      	str	r5, [sp, #144]	; 0x90
 8027f9a:	2b07      	cmp	r3, #7
 8027f9c:	9323      	str	r3, [sp, #140]	; 0x8c
 8027f9e:	f340 828e 	ble.w	80284be <_svfprintf_r+0x12e6>
 8027fa2:	aa22      	add	r2, sp, #136	; 0x88
 8027fa4:	4649      	mov	r1, r9
 8027fa6:	4650      	mov	r0, sl
 8027fa8:	f002 f829 	bl	8029ffe <__ssprint_r>
 8027fac:	2800      	cmp	r0, #0
 8027fae:	f040 82a7 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027fb2:	ac25      	add	r4, sp, #148	; 0x94
 8027fb4:	e4f3      	b.n	802799e <_svfprintf_r+0x7c6>
 8027fb6:	aa22      	add	r2, sp, #136	; 0x88
 8027fb8:	4649      	mov	r1, r9
 8027fba:	4650      	mov	r0, sl
 8027fbc:	f002 f81f 	bl	8029ffe <__ssprint_r>
 8027fc0:	2800      	cmp	r0, #0
 8027fc2:	f040 829d 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027fc6:	ac25      	add	r4, sp, #148	; 0x94
 8027fc8:	e7be      	b.n	8027f48 <_svfprintf_r+0xd70>
 8027fca:	aa22      	add	r2, sp, #136	; 0x88
 8027fcc:	4649      	mov	r1, r9
 8027fce:	4650      	mov	r0, sl
 8027fd0:	f002 f815 	bl	8029ffe <__ssprint_r>
 8027fd4:	2800      	cmp	r0, #0
 8027fd6:	f040 8293 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027fda:	ac25      	add	r4, sp, #148	; 0x94
 8027fdc:	e7ca      	b.n	8027f74 <_svfprintf_r+0xd9c>
 8027fde:	3210      	adds	r2, #16
 8027fe0:	2b07      	cmp	r3, #7
 8027fe2:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8027fe6:	6067      	str	r7, [r4, #4]
 8027fe8:	dd08      	ble.n	8027ffc <_svfprintf_r+0xe24>
 8027fea:	aa22      	add	r2, sp, #136	; 0x88
 8027fec:	4649      	mov	r1, r9
 8027fee:	4650      	mov	r0, sl
 8027ff0:	f002 f805 	bl	8029ffe <__ssprint_r>
 8027ff4:	2800      	cmp	r0, #0
 8027ff6:	f040 8283 	bne.w	8028500 <_svfprintf_r+0x1328>
 8027ffa:	a925      	add	r1, sp, #148	; 0x94
 8027ffc:	3d10      	subs	r5, #16
 8027ffe:	460c      	mov	r4, r1
 8028000:	e7bf      	b.n	8027f82 <_svfprintf_r+0xdaa>
 8028002:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8028004:	2b00      	cmp	r3, #0
 8028006:	dc73      	bgt.n	80280f0 <_svfprintf_r+0xf18>
 8028008:	4b37      	ldr	r3, [pc, #220]	; (80280e8 <_svfprintf_r+0xf10>)
 802800a:	6023      	str	r3, [r4, #0]
 802800c:	2301      	movs	r3, #1
 802800e:	441f      	add	r7, r3
 8028010:	6063      	str	r3, [r4, #4]
 8028012:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8028014:	9724      	str	r7, [sp, #144]	; 0x90
 8028016:	3301      	adds	r3, #1
 8028018:	2b07      	cmp	r3, #7
 802801a:	9323      	str	r3, [sp, #140]	; 0x8c
 802801c:	dc3d      	bgt.n	802809a <_svfprintf_r+0xec2>
 802801e:	3408      	adds	r4, #8
 8028020:	9905      	ldr	r1, [sp, #20]
 8028022:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8028024:	9a24      	ldr	r2, [sp, #144]	; 0x90
 8028026:	430b      	orrs	r3, r1
 8028028:	f00b 0101 	and.w	r1, fp, #1
 802802c:	430b      	orrs	r3, r1
 802802e:	f43f acb6 	beq.w	802799e <_svfprintf_r+0x7c6>
 8028032:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8028034:	6023      	str	r3, [r4, #0]
 8028036:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8028038:	6063      	str	r3, [r4, #4]
 802803a:	441a      	add	r2, r3
 802803c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802803e:	9224      	str	r2, [sp, #144]	; 0x90
 8028040:	3301      	adds	r3, #1
 8028042:	2b07      	cmp	r3, #7
 8028044:	9323      	str	r3, [sp, #140]	; 0x8c
 8028046:	dc32      	bgt.n	80280ae <_svfprintf_r+0xed6>
 8028048:	3408      	adds	r4, #8
 802804a:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 802804c:	2d00      	cmp	r5, #0
 802804e:	da1b      	bge.n	8028088 <_svfprintf_r+0xeb0>
 8028050:	4e26      	ldr	r6, [pc, #152]	; (80280ec <_svfprintf_r+0xf14>)
 8028052:	426d      	negs	r5, r5
 8028054:	4623      	mov	r3, r4
 8028056:	2710      	movs	r7, #16
 8028058:	e9dd 2123 	ldrd	r2, r1, [sp, #140]	; 0x8c
 802805c:	2d10      	cmp	r5, #16
 802805e:	f102 0201 	add.w	r2, r2, #1
 8028062:	f104 0408 	add.w	r4, r4, #8
 8028066:	601e      	str	r6, [r3, #0]
 8028068:	dc2b      	bgt.n	80280c2 <_svfprintf_r+0xeea>
 802806a:	605d      	str	r5, [r3, #4]
 802806c:	2a07      	cmp	r2, #7
 802806e:	440d      	add	r5, r1
 8028070:	e9cd 2523 	strd	r2, r5, [sp, #140]	; 0x8c
 8028074:	dd08      	ble.n	8028088 <_svfprintf_r+0xeb0>
 8028076:	aa22      	add	r2, sp, #136	; 0x88
 8028078:	4649      	mov	r1, r9
 802807a:	4650      	mov	r0, sl
 802807c:	f001 ffbf 	bl	8029ffe <__ssprint_r>
 8028080:	2800      	cmp	r0, #0
 8028082:	f040 823d 	bne.w	8028500 <_svfprintf_r+0x1328>
 8028086:	ac25      	add	r4, sp, #148	; 0x94
 8028088:	9b03      	ldr	r3, [sp, #12]
 802808a:	6023      	str	r3, [r4, #0]
 802808c:	9b05      	ldr	r3, [sp, #20]
 802808e:	9a05      	ldr	r2, [sp, #20]
 8028090:	6063      	str	r3, [r4, #4]
 8028092:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8028094:	4413      	add	r3, r2
 8028096:	9324      	str	r3, [sp, #144]	; 0x90
 8028098:	e47a      	b.n	8027990 <_svfprintf_r+0x7b8>
 802809a:	aa22      	add	r2, sp, #136	; 0x88
 802809c:	4649      	mov	r1, r9
 802809e:	4650      	mov	r0, sl
 80280a0:	f001 ffad 	bl	8029ffe <__ssprint_r>
 80280a4:	2800      	cmp	r0, #0
 80280a6:	f040 822b 	bne.w	8028500 <_svfprintf_r+0x1328>
 80280aa:	ac25      	add	r4, sp, #148	; 0x94
 80280ac:	e7b8      	b.n	8028020 <_svfprintf_r+0xe48>
 80280ae:	aa22      	add	r2, sp, #136	; 0x88
 80280b0:	4649      	mov	r1, r9
 80280b2:	4650      	mov	r0, sl
 80280b4:	f001 ffa3 	bl	8029ffe <__ssprint_r>
 80280b8:	2800      	cmp	r0, #0
 80280ba:	f040 8221 	bne.w	8028500 <_svfprintf_r+0x1328>
 80280be:	ac25      	add	r4, sp, #148	; 0x94
 80280c0:	e7c3      	b.n	802804a <_svfprintf_r+0xe72>
 80280c2:	3110      	adds	r1, #16
 80280c4:	2a07      	cmp	r2, #7
 80280c6:	e9cd 2123 	strd	r2, r1, [sp, #140]	; 0x8c
 80280ca:	605f      	str	r7, [r3, #4]
 80280cc:	dd08      	ble.n	80280e0 <_svfprintf_r+0xf08>
 80280ce:	aa22      	add	r2, sp, #136	; 0x88
 80280d0:	4649      	mov	r1, r9
 80280d2:	4650      	mov	r0, sl
 80280d4:	f001 ff93 	bl	8029ffe <__ssprint_r>
 80280d8:	2800      	cmp	r0, #0
 80280da:	f040 8211 	bne.w	8028500 <_svfprintf_r+0x1328>
 80280de:	ac25      	add	r4, sp, #148	; 0x94
 80280e0:	3d10      	subs	r5, #16
 80280e2:	4623      	mov	r3, r4
 80280e4:	e7b8      	b.n	8028058 <_svfprintf_r+0xe80>
 80280e6:	bf00      	nop
 80280e8:	08037577 	.word	0x08037577
 80280ec:	08037589 	.word	0x08037589
 80280f0:	9b05      	ldr	r3, [sp, #20]
 80280f2:	42ab      	cmp	r3, r5
 80280f4:	bfa8      	it	ge
 80280f6:	462b      	movge	r3, r5
 80280f8:	2b00      	cmp	r3, #0
 80280fa:	4698      	mov	r8, r3
 80280fc:	dd0a      	ble.n	8028114 <_svfprintf_r+0xf3c>
 80280fe:	9b03      	ldr	r3, [sp, #12]
 8028100:	e9c4 3800 	strd	r3, r8, [r4]
 8028104:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8028106:	3301      	adds	r3, #1
 8028108:	4447      	add	r7, r8
 802810a:	2b07      	cmp	r3, #7
 802810c:	9724      	str	r7, [sp, #144]	; 0x90
 802810e:	9323      	str	r3, [sp, #140]	; 0x8c
 8028110:	dc7b      	bgt.n	802820a <_svfprintf_r+0x1032>
 8028112:	3408      	adds	r4, #8
 8028114:	f1b8 0f00 	cmp.w	r8, #0
 8028118:	bfac      	ite	ge
 802811a:	eba5 0708 	subge.w	r7, r5, r8
 802811e:	462f      	movlt	r7, r5
 8028120:	2f00      	cmp	r7, #0
 8028122:	dd1a      	ble.n	802815a <_svfprintf_r+0xf82>
 8028124:	f8df 8368 	ldr.w	r8, [pc, #872]	; 8028490 <_svfprintf_r+0x12b8>
 8028128:	f8c4 8000 	str.w	r8, [r4]
 802812c:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8028130:	2f10      	cmp	r7, #16
 8028132:	f103 0301 	add.w	r3, r3, #1
 8028136:	f104 0108 	add.w	r1, r4, #8
 802813a:	dc70      	bgt.n	802821e <_svfprintf_r+0x1046>
 802813c:	6067      	str	r7, [r4, #4]
 802813e:	2b07      	cmp	r3, #7
 8028140:	4417      	add	r7, r2
 8028142:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 8028146:	dd7d      	ble.n	8028244 <_svfprintf_r+0x106c>
 8028148:	aa22      	add	r2, sp, #136	; 0x88
 802814a:	4649      	mov	r1, r9
 802814c:	4650      	mov	r0, sl
 802814e:	f001 ff56 	bl	8029ffe <__ssprint_r>
 8028152:	2800      	cmp	r0, #0
 8028154:	f040 81d4 	bne.w	8028500 <_svfprintf_r+0x1328>
 8028158:	ac25      	add	r4, sp, #148	; 0x94
 802815a:	9b03      	ldr	r3, [sp, #12]
 802815c:	f41b 6f80 	tst.w	fp, #1024	; 0x400
 8028160:	441d      	add	r5, r3
 8028162:	d00a      	beq.n	802817a <_svfprintf_r+0xfa2>
 8028164:	9b08      	ldr	r3, [sp, #32]
 8028166:	2b00      	cmp	r3, #0
 8028168:	d16e      	bne.n	8028248 <_svfprintf_r+0x1070>
 802816a:	2e00      	cmp	r6, #0
 802816c:	d16e      	bne.n	802824c <_svfprintf_r+0x1074>
 802816e:	9b03      	ldr	r3, [sp, #12]
 8028170:	9a05      	ldr	r2, [sp, #20]
 8028172:	4413      	add	r3, r2
 8028174:	429d      	cmp	r5, r3
 8028176:	bf28      	it	cs
 8028178:	461d      	movcs	r5, r3
 802817a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 802817c:	9a05      	ldr	r2, [sp, #20]
 802817e:	4293      	cmp	r3, r2
 8028180:	db02      	blt.n	8028188 <_svfprintf_r+0xfb0>
 8028182:	f01b 0f01 	tst.w	fp, #1
 8028186:	d00e      	beq.n	80281a6 <_svfprintf_r+0xfce>
 8028188:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 802818a:	6023      	str	r3, [r4, #0]
 802818c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 802818e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8028190:	6063      	str	r3, [r4, #4]
 8028192:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8028194:	4413      	add	r3, r2
 8028196:	9324      	str	r3, [sp, #144]	; 0x90
 8028198:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802819a:	3301      	adds	r3, #1
 802819c:	2b07      	cmp	r3, #7
 802819e:	9323      	str	r3, [sp, #140]	; 0x8c
 80281a0:	f300 80d2 	bgt.w	8028348 <_svfprintf_r+0x1170>
 80281a4:	3408      	adds	r4, #8
 80281a6:	9b05      	ldr	r3, [sp, #20]
 80281a8:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 80281aa:	9a05      	ldr	r2, [sp, #20]
 80281ac:	1b9e      	subs	r6, r3, r6
 80281ae:	9b03      	ldr	r3, [sp, #12]
 80281b0:	4413      	add	r3, r2
 80281b2:	1b5b      	subs	r3, r3, r5
 80281b4:	429e      	cmp	r6, r3
 80281b6:	bfa8      	it	ge
 80281b8:	461e      	movge	r6, r3
 80281ba:	2e00      	cmp	r6, #0
 80281bc:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80281be:	dd0a      	ble.n	80281d6 <_svfprintf_r+0xffe>
 80281c0:	4433      	add	r3, r6
 80281c2:	9324      	str	r3, [sp, #144]	; 0x90
 80281c4:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80281c6:	3301      	adds	r3, #1
 80281c8:	2b07      	cmp	r3, #7
 80281ca:	e9c4 5600 	strd	r5, r6, [r4]
 80281ce:	9323      	str	r3, [sp, #140]	; 0x8c
 80281d0:	f300 80c4 	bgt.w	802835c <_svfprintf_r+0x1184>
 80281d4:	3408      	adds	r4, #8
 80281d6:	9d1c      	ldr	r5, [sp, #112]	; 0x70
 80281d8:	9b05      	ldr	r3, [sp, #20]
 80281da:	2e00      	cmp	r6, #0
 80281dc:	eba3 0505 	sub.w	r5, r3, r5
 80281e0:	bfa8      	it	ge
 80281e2:	1bad      	subge	r5, r5, r6
 80281e4:	2d00      	cmp	r5, #0
 80281e6:	f77f abda 	ble.w	802799e <_svfprintf_r+0x7c6>
 80281ea:	4ea9      	ldr	r6, [pc, #676]	; (8028490 <_svfprintf_r+0x12b8>)
 80281ec:	2710      	movs	r7, #16
 80281ee:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80281f2:	2d10      	cmp	r5, #16
 80281f4:	f103 0301 	add.w	r3, r3, #1
 80281f8:	f104 0108 	add.w	r1, r4, #8
 80281fc:	6026      	str	r6, [r4, #0]
 80281fe:	f300 80b7 	bgt.w	8028370 <_svfprintf_r+0x1198>
 8028202:	442a      	add	r2, r5
 8028204:	6065      	str	r5, [r4, #4]
 8028206:	9224      	str	r2, [sp, #144]	; 0x90
 8028208:	e6c7      	b.n	8027f9a <_svfprintf_r+0xdc2>
 802820a:	aa22      	add	r2, sp, #136	; 0x88
 802820c:	4649      	mov	r1, r9
 802820e:	4650      	mov	r0, sl
 8028210:	f001 fef5 	bl	8029ffe <__ssprint_r>
 8028214:	2800      	cmp	r0, #0
 8028216:	f040 8173 	bne.w	8028500 <_svfprintf_r+0x1328>
 802821a:	ac25      	add	r4, sp, #148	; 0x94
 802821c:	e77a      	b.n	8028114 <_svfprintf_r+0xf3c>
 802821e:	2010      	movs	r0, #16
 8028220:	4402      	add	r2, r0
 8028222:	2b07      	cmp	r3, #7
 8028224:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8028228:	6060      	str	r0, [r4, #4]
 802822a:	dd08      	ble.n	802823e <_svfprintf_r+0x1066>
 802822c:	aa22      	add	r2, sp, #136	; 0x88
 802822e:	4649      	mov	r1, r9
 8028230:	4650      	mov	r0, sl
 8028232:	f001 fee4 	bl	8029ffe <__ssprint_r>
 8028236:	2800      	cmp	r0, #0
 8028238:	f040 8162 	bne.w	8028500 <_svfprintf_r+0x1328>
 802823c:	a925      	add	r1, sp, #148	; 0x94
 802823e:	3f10      	subs	r7, #16
 8028240:	460c      	mov	r4, r1
 8028242:	e771      	b.n	8028128 <_svfprintf_r+0xf50>
 8028244:	460c      	mov	r4, r1
 8028246:	e788      	b.n	802815a <_svfprintf_r+0xf82>
 8028248:	2e00      	cmp	r6, #0
 802824a:	d04d      	beq.n	80282e8 <_svfprintf_r+0x1110>
 802824c:	3e01      	subs	r6, #1
 802824e:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8028250:	6023      	str	r3, [r4, #0]
 8028252:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8028254:	9a11      	ldr	r2, [sp, #68]	; 0x44
 8028256:	6063      	str	r3, [r4, #4]
 8028258:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802825a:	4413      	add	r3, r2
 802825c:	9324      	str	r3, [sp, #144]	; 0x90
 802825e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8028260:	3301      	adds	r3, #1
 8028262:	2b07      	cmp	r3, #7
 8028264:	9323      	str	r3, [sp, #140]	; 0x8c
 8028266:	dc46      	bgt.n	80282f6 <_svfprintf_r+0x111e>
 8028268:	3408      	adds	r4, #8
 802826a:	9b03      	ldr	r3, [sp, #12]
 802826c:	9a05      	ldr	r2, [sp, #20]
 802826e:	eb03 0802 	add.w	r8, r3, r2
 8028272:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8028274:	781b      	ldrb	r3, [r3, #0]
 8028276:	eba8 0805 	sub.w	r8, r8, r5
 802827a:	4598      	cmp	r8, r3
 802827c:	bfa8      	it	ge
 802827e:	4698      	movge	r8, r3
 8028280:	f1b8 0f00 	cmp.w	r8, #0
 8028284:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8028286:	dd09      	ble.n	802829c <_svfprintf_r+0x10c4>
 8028288:	4443      	add	r3, r8
 802828a:	9324      	str	r3, [sp, #144]	; 0x90
 802828c:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 802828e:	3301      	adds	r3, #1
 8028290:	2b07      	cmp	r3, #7
 8028292:	e9c4 5800 	strd	r5, r8, [r4]
 8028296:	9323      	str	r3, [sp, #140]	; 0x8c
 8028298:	dc37      	bgt.n	802830a <_svfprintf_r+0x1132>
 802829a:	3408      	adds	r4, #8
 802829c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802829e:	781f      	ldrb	r7, [r3, #0]
 80282a0:	f1b8 0f00 	cmp.w	r8, #0
 80282a4:	bfa8      	it	ge
 80282a6:	eba7 0708 	subge.w	r7, r7, r8
 80282aa:	2f00      	cmp	r7, #0
 80282ac:	dd18      	ble.n	80282e0 <_svfprintf_r+0x1108>
 80282ae:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80282b2:	4877      	ldr	r0, [pc, #476]	; (8028490 <_svfprintf_r+0x12b8>)
 80282b4:	6020      	str	r0, [r4, #0]
 80282b6:	2f10      	cmp	r7, #16
 80282b8:	f103 0301 	add.w	r3, r3, #1
 80282bc:	f104 0108 	add.w	r1, r4, #8
 80282c0:	dc2d      	bgt.n	802831e <_svfprintf_r+0x1146>
 80282c2:	443a      	add	r2, r7
 80282c4:	2b07      	cmp	r3, #7
 80282c6:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 80282ca:	6067      	str	r7, [r4, #4]
 80282cc:	dd3a      	ble.n	8028344 <_svfprintf_r+0x116c>
 80282ce:	aa22      	add	r2, sp, #136	; 0x88
 80282d0:	4649      	mov	r1, r9
 80282d2:	4650      	mov	r0, sl
 80282d4:	f001 fe93 	bl	8029ffe <__ssprint_r>
 80282d8:	2800      	cmp	r0, #0
 80282da:	f040 8111 	bne.w	8028500 <_svfprintf_r+0x1328>
 80282de:	ac25      	add	r4, sp, #148	; 0x94
 80282e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80282e2:	781b      	ldrb	r3, [r3, #0]
 80282e4:	441d      	add	r5, r3
 80282e6:	e73d      	b.n	8028164 <_svfprintf_r+0xf8c>
 80282e8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80282ea:	3b01      	subs	r3, #1
 80282ec:	9309      	str	r3, [sp, #36]	; 0x24
 80282ee:	9b08      	ldr	r3, [sp, #32]
 80282f0:	3b01      	subs	r3, #1
 80282f2:	9308      	str	r3, [sp, #32]
 80282f4:	e7ab      	b.n	802824e <_svfprintf_r+0x1076>
 80282f6:	aa22      	add	r2, sp, #136	; 0x88
 80282f8:	4649      	mov	r1, r9
 80282fa:	4650      	mov	r0, sl
 80282fc:	f001 fe7f 	bl	8029ffe <__ssprint_r>
 8028300:	2800      	cmp	r0, #0
 8028302:	f040 80fd 	bne.w	8028500 <_svfprintf_r+0x1328>
 8028306:	ac25      	add	r4, sp, #148	; 0x94
 8028308:	e7af      	b.n	802826a <_svfprintf_r+0x1092>
 802830a:	aa22      	add	r2, sp, #136	; 0x88
 802830c:	4649      	mov	r1, r9
 802830e:	4650      	mov	r0, sl
 8028310:	f001 fe75 	bl	8029ffe <__ssprint_r>
 8028314:	2800      	cmp	r0, #0
 8028316:	f040 80f3 	bne.w	8028500 <_svfprintf_r+0x1328>
 802831a:	ac25      	add	r4, sp, #148	; 0x94
 802831c:	e7be      	b.n	802829c <_svfprintf_r+0x10c4>
 802831e:	2010      	movs	r0, #16
 8028320:	4402      	add	r2, r0
 8028322:	2b07      	cmp	r3, #7
 8028324:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8028328:	6060      	str	r0, [r4, #4]
 802832a:	dd08      	ble.n	802833e <_svfprintf_r+0x1166>
 802832c:	aa22      	add	r2, sp, #136	; 0x88
 802832e:	4649      	mov	r1, r9
 8028330:	4650      	mov	r0, sl
 8028332:	f001 fe64 	bl	8029ffe <__ssprint_r>
 8028336:	2800      	cmp	r0, #0
 8028338:	f040 80e2 	bne.w	8028500 <_svfprintf_r+0x1328>
 802833c:	a925      	add	r1, sp, #148	; 0x94
 802833e:	3f10      	subs	r7, #16
 8028340:	460c      	mov	r4, r1
 8028342:	e7b4      	b.n	80282ae <_svfprintf_r+0x10d6>
 8028344:	460c      	mov	r4, r1
 8028346:	e7cb      	b.n	80282e0 <_svfprintf_r+0x1108>
 8028348:	aa22      	add	r2, sp, #136	; 0x88
 802834a:	4649      	mov	r1, r9
 802834c:	4650      	mov	r0, sl
 802834e:	f001 fe56 	bl	8029ffe <__ssprint_r>
 8028352:	2800      	cmp	r0, #0
 8028354:	f040 80d4 	bne.w	8028500 <_svfprintf_r+0x1328>
 8028358:	ac25      	add	r4, sp, #148	; 0x94
 802835a:	e724      	b.n	80281a6 <_svfprintf_r+0xfce>
 802835c:	aa22      	add	r2, sp, #136	; 0x88
 802835e:	4649      	mov	r1, r9
 8028360:	4650      	mov	r0, sl
 8028362:	f001 fe4c 	bl	8029ffe <__ssprint_r>
 8028366:	2800      	cmp	r0, #0
 8028368:	f040 80ca 	bne.w	8028500 <_svfprintf_r+0x1328>
 802836c:	ac25      	add	r4, sp, #148	; 0x94
 802836e:	e732      	b.n	80281d6 <_svfprintf_r+0xffe>
 8028370:	3210      	adds	r2, #16
 8028372:	2b07      	cmp	r3, #7
 8028374:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 8028378:	6067      	str	r7, [r4, #4]
 802837a:	dd08      	ble.n	802838e <_svfprintf_r+0x11b6>
 802837c:	aa22      	add	r2, sp, #136	; 0x88
 802837e:	4649      	mov	r1, r9
 8028380:	4650      	mov	r0, sl
 8028382:	f001 fe3c 	bl	8029ffe <__ssprint_r>
 8028386:	2800      	cmp	r0, #0
 8028388:	f040 80ba 	bne.w	8028500 <_svfprintf_r+0x1328>
 802838c:	a925      	add	r1, sp, #148	; 0x94
 802838e:	3d10      	subs	r5, #16
 8028390:	460c      	mov	r4, r1
 8028392:	e72c      	b.n	80281ee <_svfprintf_r+0x1016>
 8028394:	9a05      	ldr	r2, [sp, #20]
 8028396:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8028398:	2a01      	cmp	r2, #1
 802839a:	9a03      	ldr	r2, [sp, #12]
 802839c:	6022      	str	r2, [r4, #0]
 802839e:	f107 0701 	add.w	r7, r7, #1
 80283a2:	f103 0301 	add.w	r3, r3, #1
 80283a6:	f04f 0201 	mov.w	r2, #1
 80283aa:	e9cd 3723 	strd	r3, r7, [sp, #140]	; 0x8c
 80283ae:	f104 0508 	add.w	r5, r4, #8
 80283b2:	6062      	str	r2, [r4, #4]
 80283b4:	dc02      	bgt.n	80283bc <_svfprintf_r+0x11e4>
 80283b6:	f01b 0f01 	tst.w	fp, #1
 80283ba:	d07b      	beq.n	80284b4 <_svfprintf_r+0x12dc>
 80283bc:	2b07      	cmp	r3, #7
 80283be:	dd08      	ble.n	80283d2 <_svfprintf_r+0x11fa>
 80283c0:	aa22      	add	r2, sp, #136	; 0x88
 80283c2:	4649      	mov	r1, r9
 80283c4:	4650      	mov	r0, sl
 80283c6:	f001 fe1a 	bl	8029ffe <__ssprint_r>
 80283ca:	2800      	cmp	r0, #0
 80283cc:	f040 8098 	bne.w	8028500 <_svfprintf_r+0x1328>
 80283d0:	ad25      	add	r5, sp, #148	; 0x94
 80283d2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80283d4:	602b      	str	r3, [r5, #0]
 80283d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80283d8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80283da:	606b      	str	r3, [r5, #4]
 80283dc:	9b24      	ldr	r3, [sp, #144]	; 0x90
 80283de:	4413      	add	r3, r2
 80283e0:	9324      	str	r3, [sp, #144]	; 0x90
 80283e2:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 80283e4:	3301      	adds	r3, #1
 80283e6:	2b07      	cmp	r3, #7
 80283e8:	9323      	str	r3, [sp, #140]	; 0x8c
 80283ea:	dc32      	bgt.n	8028452 <_svfprintf_r+0x127a>
 80283ec:	3508      	adds	r5, #8
 80283ee:	9b05      	ldr	r3, [sp, #20]
 80283f0:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
 80283f4:	1e5c      	subs	r4, r3, #1
 80283f6:	2200      	movs	r2, #0
 80283f8:	2300      	movs	r3, #0
 80283fa:	e9dd 7623 	ldrd	r7, r6, [sp, #140]	; 0x8c
 80283fe:	f7d8 fb7b 	bl	8000af8 <__aeabi_dcmpeq>
 8028402:	2800      	cmp	r0, #0
 8028404:	d12e      	bne.n	8028464 <_svfprintf_r+0x128c>
 8028406:	9b03      	ldr	r3, [sp, #12]
 8028408:	3301      	adds	r3, #1
 802840a:	e9c5 3400 	strd	r3, r4, [r5]
 802840e:	9b05      	ldr	r3, [sp, #20]
 8028410:	3701      	adds	r7, #1
 8028412:	3e01      	subs	r6, #1
 8028414:	441e      	add	r6, r3
 8028416:	2f07      	cmp	r7, #7
 8028418:	e9cd 7623 	strd	r7, r6, [sp, #140]	; 0x8c
 802841c:	dd4d      	ble.n	80284ba <_svfprintf_r+0x12e2>
 802841e:	aa22      	add	r2, sp, #136	; 0x88
 8028420:	4649      	mov	r1, r9
 8028422:	4650      	mov	r0, sl
 8028424:	f001 fdeb 	bl	8029ffe <__ssprint_r>
 8028428:	2800      	cmp	r0, #0
 802842a:	d169      	bne.n	8028500 <_svfprintf_r+0x1328>
 802842c:	ad25      	add	r5, sp, #148	; 0x94
 802842e:	ab1e      	add	r3, sp, #120	; 0x78
 8028430:	602b      	str	r3, [r5, #0]
 8028432:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8028434:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8028436:	606b      	str	r3, [r5, #4]
 8028438:	9b24      	ldr	r3, [sp, #144]	; 0x90
 802843a:	4413      	add	r3, r2
 802843c:	9324      	str	r3, [sp, #144]	; 0x90
 802843e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
 8028440:	3301      	adds	r3, #1
 8028442:	2b07      	cmp	r3, #7
 8028444:	9323      	str	r3, [sp, #140]	; 0x8c
 8028446:	f73f adac 	bgt.w	8027fa2 <_svfprintf_r+0xdca>
 802844a:	f105 0408 	add.w	r4, r5, #8
 802844e:	f7ff baa6 	b.w	802799e <_svfprintf_r+0x7c6>
 8028452:	aa22      	add	r2, sp, #136	; 0x88
 8028454:	4649      	mov	r1, r9
 8028456:	4650      	mov	r0, sl
 8028458:	f001 fdd1 	bl	8029ffe <__ssprint_r>
 802845c:	2800      	cmp	r0, #0
 802845e:	d14f      	bne.n	8028500 <_svfprintf_r+0x1328>
 8028460:	ad25      	add	r5, sp, #148	; 0x94
 8028462:	e7c4      	b.n	80283ee <_svfprintf_r+0x1216>
 8028464:	2c00      	cmp	r4, #0
 8028466:	dde2      	ble.n	802842e <_svfprintf_r+0x1256>
 8028468:	4e09      	ldr	r6, [pc, #36]	; (8028490 <_svfprintf_r+0x12b8>)
 802846a:	2710      	movs	r7, #16
 802846c:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 8028470:	2c10      	cmp	r4, #16
 8028472:	f103 0301 	add.w	r3, r3, #1
 8028476:	f105 0108 	add.w	r1, r5, #8
 802847a:	602e      	str	r6, [r5, #0]
 802847c:	dc0a      	bgt.n	8028494 <_svfprintf_r+0x12bc>
 802847e:	606c      	str	r4, [r5, #4]
 8028480:	2b07      	cmp	r3, #7
 8028482:	4414      	add	r4, r2
 8028484:	e9cd 3423 	strd	r3, r4, [sp, #140]	; 0x8c
 8028488:	dcc9      	bgt.n	802841e <_svfprintf_r+0x1246>
 802848a:	460d      	mov	r5, r1
 802848c:	e7cf      	b.n	802842e <_svfprintf_r+0x1256>
 802848e:	bf00      	nop
 8028490:	08037589 	.word	0x08037589
 8028494:	3210      	adds	r2, #16
 8028496:	2b07      	cmp	r3, #7
 8028498:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 802849c:	606f      	str	r7, [r5, #4]
 802849e:	dd06      	ble.n	80284ae <_svfprintf_r+0x12d6>
 80284a0:	aa22      	add	r2, sp, #136	; 0x88
 80284a2:	4649      	mov	r1, r9
 80284a4:	4650      	mov	r0, sl
 80284a6:	f001 fdaa 	bl	8029ffe <__ssprint_r>
 80284aa:	bb48      	cbnz	r0, 8028500 <_svfprintf_r+0x1328>
 80284ac:	a925      	add	r1, sp, #148	; 0x94
 80284ae:	3c10      	subs	r4, #16
 80284b0:	460d      	mov	r5, r1
 80284b2:	e7db      	b.n	802846c <_svfprintf_r+0x1294>
 80284b4:	2b07      	cmp	r3, #7
 80284b6:	ddba      	ble.n	802842e <_svfprintf_r+0x1256>
 80284b8:	e7b1      	b.n	802841e <_svfprintf_r+0x1246>
 80284ba:	3508      	adds	r5, #8
 80284bc:	e7b7      	b.n	802842e <_svfprintf_r+0x1256>
 80284be:	460c      	mov	r4, r1
 80284c0:	f7ff ba6d 	b.w	802799e <_svfprintf_r+0x7c6>
 80284c4:	e9dd 320f 	ldrd	r3, r2, [sp, #60]	; 0x3c
 80284c8:	1a9d      	subs	r5, r3, r2
 80284ca:	2d00      	cmp	r5, #0
 80284cc:	f77f aa6b 	ble.w	80279a6 <_svfprintf_r+0x7ce>
 80284d0:	4e37      	ldr	r6, [pc, #220]	; (80285b0 <_svfprintf_r+0x13d8>)
 80284d2:	2710      	movs	r7, #16
 80284d4:	e9dd 3223 	ldrd	r3, r2, [sp, #140]	; 0x8c
 80284d8:	2d10      	cmp	r5, #16
 80284da:	f103 0301 	add.w	r3, r3, #1
 80284de:	6026      	str	r6, [r4, #0]
 80284e0:	dc18      	bgt.n	8028514 <_svfprintf_r+0x133c>
 80284e2:	6065      	str	r5, [r4, #4]
 80284e4:	2b07      	cmp	r3, #7
 80284e6:	4415      	add	r5, r2
 80284e8:	e9cd 3523 	strd	r3, r5, [sp, #140]	; 0x8c
 80284ec:	f77f aa5b 	ble.w	80279a6 <_svfprintf_r+0x7ce>
 80284f0:	aa22      	add	r2, sp, #136	; 0x88
 80284f2:	4649      	mov	r1, r9
 80284f4:	4650      	mov	r0, sl
 80284f6:	f001 fd82 	bl	8029ffe <__ssprint_r>
 80284fa:	2800      	cmp	r0, #0
 80284fc:	f43f aa53 	beq.w	80279a6 <_svfprintf_r+0x7ce>
 8028500:	9b04      	ldr	r3, [sp, #16]
 8028502:	2b00      	cmp	r3, #0
 8028504:	f43f a874 	beq.w	80275f0 <_svfprintf_r+0x418>
 8028508:	4619      	mov	r1, r3
 802850a:	4650      	mov	r0, sl
 802850c:	f7fe fb5e 	bl	8026bcc <_free_r>
 8028510:	f7ff b86e 	b.w	80275f0 <_svfprintf_r+0x418>
 8028514:	3210      	adds	r2, #16
 8028516:	2b07      	cmp	r3, #7
 8028518:	e9cd 3223 	strd	r3, r2, [sp, #140]	; 0x8c
 802851c:	6067      	str	r7, [r4, #4]
 802851e:	dc02      	bgt.n	8028526 <_svfprintf_r+0x134e>
 8028520:	3408      	adds	r4, #8
 8028522:	3d10      	subs	r5, #16
 8028524:	e7d6      	b.n	80284d4 <_svfprintf_r+0x12fc>
 8028526:	aa22      	add	r2, sp, #136	; 0x88
 8028528:	4649      	mov	r1, r9
 802852a:	4650      	mov	r0, sl
 802852c:	f001 fd67 	bl	8029ffe <__ssprint_r>
 8028530:	2800      	cmp	r0, #0
 8028532:	d1e5      	bne.n	8028500 <_svfprintf_r+0x1328>
 8028534:	ac25      	add	r4, sp, #148	; 0x94
 8028536:	e7f4      	b.n	8028522 <_svfprintf_r+0x134a>
 8028538:	9904      	ldr	r1, [sp, #16]
 802853a:	4650      	mov	r0, sl
 802853c:	f7fe fb46 	bl	8026bcc <_free_r>
 8028540:	f7ff ba49 	b.w	80279d6 <_svfprintf_r+0x7fe>
 8028544:	9b24      	ldr	r3, [sp, #144]	; 0x90
 8028546:	2b00      	cmp	r3, #0
 8028548:	f43f a852 	beq.w	80275f0 <_svfprintf_r+0x418>
 802854c:	aa22      	add	r2, sp, #136	; 0x88
 802854e:	4649      	mov	r1, r9
 8028550:	4650      	mov	r0, sl
 8028552:	f001 fd54 	bl	8029ffe <__ssprint_r>
 8028556:	f7ff b84b 	b.w	80275f0 <_svfprintf_r+0x418>
 802855a:	ea55 0206 	orrs.w	r2, r5, r6
 802855e:	f8cd b010 	str.w	fp, [sp, #16]
 8028562:	f43f ab5e 	beq.w	8027c22 <_svfprintf_r+0xa4a>
 8028566:	2b01      	cmp	r3, #1
 8028568:	f43f abff 	beq.w	8027d6a <_svfprintf_r+0xb92>
 802856c:	2b02      	cmp	r3, #2
 802856e:	ab4e      	add	r3, sp, #312	; 0x138
 8028570:	9303      	str	r3, [sp, #12]
 8028572:	f43f ac4d 	beq.w	8027e10 <_svfprintf_r+0xc38>
 8028576:	9a03      	ldr	r2, [sp, #12]
 8028578:	f005 0307 	and.w	r3, r5, #7
 802857c:	4611      	mov	r1, r2
 802857e:	3330      	adds	r3, #48	; 0x30
 8028580:	f801 3d01 	strb.w	r3, [r1, #-1]!
 8028584:	08ed      	lsrs	r5, r5, #3
 8028586:	ea45 7546 	orr.w	r5, r5, r6, lsl #29
 802858a:	08f6      	lsrs	r6, r6, #3
 802858c:	9103      	str	r1, [sp, #12]
 802858e:	ea55 0106 	orrs.w	r1, r5, r6
 8028592:	d1f0      	bne.n	8028576 <_svfprintf_r+0x139e>
 8028594:	9904      	ldr	r1, [sp, #16]
 8028596:	07c9      	lsls	r1, r1, #31
 8028598:	f57f ac2a 	bpl.w	8027df0 <_svfprintf_r+0xc18>
 802859c:	2b30      	cmp	r3, #48	; 0x30
 802859e:	f43f ac27 	beq.w	8027df0 <_svfprintf_r+0xc18>
 80285a2:	9903      	ldr	r1, [sp, #12]
 80285a4:	2330      	movs	r3, #48	; 0x30
 80285a6:	f801 3c01 	strb.w	r3, [r1, #-1]
 80285aa:	1e93      	subs	r3, r2, #2
 80285ac:	9303      	str	r3, [sp, #12]
 80285ae:	e41f      	b.n	8027df0 <_svfprintf_r+0xc18>
 80285b0:	08037579 	.word	0x08037579

080285b4 <_fclose_r>:
 80285b4:	b570      	push	{r4, r5, r6, lr}
 80285b6:	4606      	mov	r6, r0
 80285b8:	460c      	mov	r4, r1
 80285ba:	b911      	cbnz	r1, 80285c2 <_fclose_r+0xe>
 80285bc:	2500      	movs	r5, #0
 80285be:	4628      	mov	r0, r5
 80285c0:	bd70      	pop	{r4, r5, r6, pc}
 80285c2:	b118      	cbz	r0, 80285cc <_fclose_r+0x18>
 80285c4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80285c6:	b90b      	cbnz	r3, 80285cc <_fclose_r+0x18>
 80285c8:	f7fe f8d4 	bl	8026774 <__sinit>
 80285cc:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80285ce:	07d8      	lsls	r0, r3, #31
 80285d0:	d405      	bmi.n	80285de <_fclose_r+0x2a>
 80285d2:	89a3      	ldrh	r3, [r4, #12]
 80285d4:	0599      	lsls	r1, r3, #22
 80285d6:	d402      	bmi.n	80285de <_fclose_r+0x2a>
 80285d8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80285da:	f7fe fa7b 	bl	8026ad4 <__retarget_lock_acquire_recursive>
 80285de:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80285e2:	b93b      	cbnz	r3, 80285f4 <_fclose_r+0x40>
 80285e4:	6e65      	ldr	r5, [r4, #100]	; 0x64
 80285e6:	f015 0501 	ands.w	r5, r5, #1
 80285ea:	d1e7      	bne.n	80285bc <_fclose_r+0x8>
 80285ec:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80285ee:	f7fe fa72 	bl	8026ad6 <__retarget_lock_release_recursive>
 80285f2:	e7e4      	b.n	80285be <_fclose_r+0xa>
 80285f4:	4621      	mov	r1, r4
 80285f6:	4630      	mov	r0, r6
 80285f8:	f000 f834 	bl	8028664 <__sflush_r>
 80285fc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80285fe:	4605      	mov	r5, r0
 8028600:	b133      	cbz	r3, 8028610 <_fclose_r+0x5c>
 8028602:	69e1      	ldr	r1, [r4, #28]
 8028604:	4630      	mov	r0, r6
 8028606:	4798      	blx	r3
 8028608:	2800      	cmp	r0, #0
 802860a:	bfb8      	it	lt
 802860c:	f04f 35ff 	movlt.w	r5, #4294967295
 8028610:	89a3      	ldrh	r3, [r4, #12]
 8028612:	061a      	lsls	r2, r3, #24
 8028614:	d503      	bpl.n	802861e <_fclose_r+0x6a>
 8028616:	6921      	ldr	r1, [r4, #16]
 8028618:	4630      	mov	r0, r6
 802861a:	f7fe fad7 	bl	8026bcc <_free_r>
 802861e:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8028620:	b141      	cbz	r1, 8028634 <_fclose_r+0x80>
 8028622:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8028626:	4299      	cmp	r1, r3
 8028628:	d002      	beq.n	8028630 <_fclose_r+0x7c>
 802862a:	4630      	mov	r0, r6
 802862c:	f7fe face 	bl	8026bcc <_free_r>
 8028630:	2300      	movs	r3, #0
 8028632:	6323      	str	r3, [r4, #48]	; 0x30
 8028634:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8028636:	b121      	cbz	r1, 8028642 <_fclose_r+0x8e>
 8028638:	4630      	mov	r0, r6
 802863a:	f7fe fac7 	bl	8026bcc <_free_r>
 802863e:	2300      	movs	r3, #0
 8028640:	6463      	str	r3, [r4, #68]	; 0x44
 8028642:	f7fe f88b 	bl	802675c <__sfp_lock_acquire>
 8028646:	2300      	movs	r3, #0
 8028648:	81a3      	strh	r3, [r4, #12]
 802864a:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802864c:	07db      	lsls	r3, r3, #31
 802864e:	d402      	bmi.n	8028656 <_fclose_r+0xa2>
 8028650:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8028652:	f7fe fa40 	bl	8026ad6 <__retarget_lock_release_recursive>
 8028656:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8028658:	f7fe fa3b 	bl	8026ad2 <__retarget_lock_close_recursive>
 802865c:	f7fe f884 	bl	8026768 <__sfp_lock_release>
 8028660:	e7ad      	b.n	80285be <_fclose_r+0xa>
	...

08028664 <__sflush_r>:
 8028664:	898b      	ldrh	r3, [r1, #12]
 8028666:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 802866a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 802866e:	4605      	mov	r5, r0
 8028670:	0718      	lsls	r0, r3, #28
 8028672:	460c      	mov	r4, r1
 8028674:	d45f      	bmi.n	8028736 <__sflush_r+0xd2>
 8028676:	684b      	ldr	r3, [r1, #4]
 8028678:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 802867c:	2b00      	cmp	r3, #0
 802867e:	818a      	strh	r2, [r1, #12]
 8028680:	dc05      	bgt.n	802868e <__sflush_r+0x2a>
 8028682:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8028684:	2b00      	cmp	r3, #0
 8028686:	dc02      	bgt.n	802868e <__sflush_r+0x2a>
 8028688:	2000      	movs	r0, #0
 802868a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802868e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8028690:	2e00      	cmp	r6, #0
 8028692:	d0f9      	beq.n	8028688 <__sflush_r+0x24>
 8028694:	2300      	movs	r3, #0
 8028696:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 802869a:	682f      	ldr	r7, [r5, #0]
 802869c:	69e1      	ldr	r1, [r4, #28]
 802869e:	602b      	str	r3, [r5, #0]
 80286a0:	d036      	beq.n	8028710 <__sflush_r+0xac>
 80286a2:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80286a4:	89a3      	ldrh	r3, [r4, #12]
 80286a6:	075a      	lsls	r2, r3, #29
 80286a8:	d505      	bpl.n	80286b6 <__sflush_r+0x52>
 80286aa:	6863      	ldr	r3, [r4, #4]
 80286ac:	1ac0      	subs	r0, r0, r3
 80286ae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80286b0:	b10b      	cbz	r3, 80286b6 <__sflush_r+0x52>
 80286b2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80286b4:	1ac0      	subs	r0, r0, r3
 80286b6:	2300      	movs	r3, #0
 80286b8:	4602      	mov	r2, r0
 80286ba:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80286bc:	69e1      	ldr	r1, [r4, #28]
 80286be:	4628      	mov	r0, r5
 80286c0:	47b0      	blx	r6
 80286c2:	1c43      	adds	r3, r0, #1
 80286c4:	89a3      	ldrh	r3, [r4, #12]
 80286c6:	d106      	bne.n	80286d6 <__sflush_r+0x72>
 80286c8:	6829      	ldr	r1, [r5, #0]
 80286ca:	291d      	cmp	r1, #29
 80286cc:	d82f      	bhi.n	802872e <__sflush_r+0xca>
 80286ce:	4a2b      	ldr	r2, [pc, #172]	; (802877c <__sflush_r+0x118>)
 80286d0:	410a      	asrs	r2, r1
 80286d2:	07d6      	lsls	r6, r2, #31
 80286d4:	d42b      	bmi.n	802872e <__sflush_r+0xca>
 80286d6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80286da:	b21b      	sxth	r3, r3
 80286dc:	2200      	movs	r2, #0
 80286de:	6062      	str	r2, [r4, #4]
 80286e0:	04d9      	lsls	r1, r3, #19
 80286e2:	6922      	ldr	r2, [r4, #16]
 80286e4:	81a3      	strh	r3, [r4, #12]
 80286e6:	6022      	str	r2, [r4, #0]
 80286e8:	d504      	bpl.n	80286f4 <__sflush_r+0x90>
 80286ea:	1c42      	adds	r2, r0, #1
 80286ec:	d101      	bne.n	80286f2 <__sflush_r+0x8e>
 80286ee:	682b      	ldr	r3, [r5, #0]
 80286f0:	b903      	cbnz	r3, 80286f4 <__sflush_r+0x90>
 80286f2:	6520      	str	r0, [r4, #80]	; 0x50
 80286f4:	6b21      	ldr	r1, [r4, #48]	; 0x30
 80286f6:	602f      	str	r7, [r5, #0]
 80286f8:	2900      	cmp	r1, #0
 80286fa:	d0c5      	beq.n	8028688 <__sflush_r+0x24>
 80286fc:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8028700:	4299      	cmp	r1, r3
 8028702:	d002      	beq.n	802870a <__sflush_r+0xa6>
 8028704:	4628      	mov	r0, r5
 8028706:	f7fe fa61 	bl	8026bcc <_free_r>
 802870a:	2000      	movs	r0, #0
 802870c:	6320      	str	r0, [r4, #48]	; 0x30
 802870e:	e7bc      	b.n	802868a <__sflush_r+0x26>
 8028710:	2301      	movs	r3, #1
 8028712:	4628      	mov	r0, r5
 8028714:	47b0      	blx	r6
 8028716:	1c41      	adds	r1, r0, #1
 8028718:	d1c4      	bne.n	80286a4 <__sflush_r+0x40>
 802871a:	682b      	ldr	r3, [r5, #0]
 802871c:	2b00      	cmp	r3, #0
 802871e:	d0c1      	beq.n	80286a4 <__sflush_r+0x40>
 8028720:	2b1d      	cmp	r3, #29
 8028722:	d001      	beq.n	8028728 <__sflush_r+0xc4>
 8028724:	2b16      	cmp	r3, #22
 8028726:	d101      	bne.n	802872c <__sflush_r+0xc8>
 8028728:	602f      	str	r7, [r5, #0]
 802872a:	e7ad      	b.n	8028688 <__sflush_r+0x24>
 802872c:	89a3      	ldrh	r3, [r4, #12]
 802872e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8028732:	81a3      	strh	r3, [r4, #12]
 8028734:	e7a9      	b.n	802868a <__sflush_r+0x26>
 8028736:	690f      	ldr	r7, [r1, #16]
 8028738:	2f00      	cmp	r7, #0
 802873a:	d0a5      	beq.n	8028688 <__sflush_r+0x24>
 802873c:	079b      	lsls	r3, r3, #30
 802873e:	680e      	ldr	r6, [r1, #0]
 8028740:	bf08      	it	eq
 8028742:	694b      	ldreq	r3, [r1, #20]
 8028744:	600f      	str	r7, [r1, #0]
 8028746:	bf18      	it	ne
 8028748:	2300      	movne	r3, #0
 802874a:	eba6 0807 	sub.w	r8, r6, r7
 802874e:	608b      	str	r3, [r1, #8]
 8028750:	f1b8 0f00 	cmp.w	r8, #0
 8028754:	dd98      	ble.n	8028688 <__sflush_r+0x24>
 8028756:	69e1      	ldr	r1, [r4, #28]
 8028758:	6a66      	ldr	r6, [r4, #36]	; 0x24
 802875a:	4643      	mov	r3, r8
 802875c:	463a      	mov	r2, r7
 802875e:	4628      	mov	r0, r5
 8028760:	47b0      	blx	r6
 8028762:	2800      	cmp	r0, #0
 8028764:	dc06      	bgt.n	8028774 <__sflush_r+0x110>
 8028766:	89a3      	ldrh	r3, [r4, #12]
 8028768:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802876c:	81a3      	strh	r3, [r4, #12]
 802876e:	f04f 30ff 	mov.w	r0, #4294967295
 8028772:	e78a      	b.n	802868a <__sflush_r+0x26>
 8028774:	4407      	add	r7, r0
 8028776:	eba8 0800 	sub.w	r8, r8, r0
 802877a:	e7e9      	b.n	8028750 <__sflush_r+0xec>
 802877c:	dfbffffe 	.word	0xdfbffffe

08028780 <_fflush_r>:
 8028780:	b538      	push	{r3, r4, r5, lr}
 8028782:	460c      	mov	r4, r1
 8028784:	4605      	mov	r5, r0
 8028786:	b118      	cbz	r0, 8028790 <_fflush_r+0x10>
 8028788:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802878a:	b90b      	cbnz	r3, 8028790 <_fflush_r+0x10>
 802878c:	f7fd fff2 	bl	8026774 <__sinit>
 8028790:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8028794:	b1bb      	cbz	r3, 80287c6 <_fflush_r+0x46>
 8028796:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8028798:	07d0      	lsls	r0, r2, #31
 802879a:	d404      	bmi.n	80287a6 <_fflush_r+0x26>
 802879c:	0599      	lsls	r1, r3, #22
 802879e:	d402      	bmi.n	80287a6 <_fflush_r+0x26>
 80287a0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80287a2:	f7fe f997 	bl	8026ad4 <__retarget_lock_acquire_recursive>
 80287a6:	4628      	mov	r0, r5
 80287a8:	4621      	mov	r1, r4
 80287aa:	f7ff ff5b 	bl	8028664 <__sflush_r>
 80287ae:	6e63      	ldr	r3, [r4, #100]	; 0x64
 80287b0:	07da      	lsls	r2, r3, #31
 80287b2:	4605      	mov	r5, r0
 80287b4:	d405      	bmi.n	80287c2 <_fflush_r+0x42>
 80287b6:	89a3      	ldrh	r3, [r4, #12]
 80287b8:	059b      	lsls	r3, r3, #22
 80287ba:	d402      	bmi.n	80287c2 <_fflush_r+0x42>
 80287bc:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80287be:	f7fe f98a 	bl	8026ad6 <__retarget_lock_release_recursive>
 80287c2:	4628      	mov	r0, r5
 80287c4:	bd38      	pop	{r3, r4, r5, pc}
 80287c6:	461d      	mov	r5, r3
 80287c8:	e7fb      	b.n	80287c2 <_fflush_r+0x42>

080287ca <strncpy>:
 80287ca:	b510      	push	{r4, lr}
 80287cc:	3901      	subs	r1, #1
 80287ce:	4603      	mov	r3, r0
 80287d0:	b132      	cbz	r2, 80287e0 <strncpy+0x16>
 80287d2:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80287d6:	f803 4b01 	strb.w	r4, [r3], #1
 80287da:	3a01      	subs	r2, #1
 80287dc:	2c00      	cmp	r4, #0
 80287de:	d1f7      	bne.n	80287d0 <strncpy+0x6>
 80287e0:	441a      	add	r2, r3
 80287e2:	2100      	movs	r1, #0
 80287e4:	4293      	cmp	r3, r2
 80287e6:	d100      	bne.n	80287ea <strncpy+0x20>
 80287e8:	bd10      	pop	{r4, pc}
 80287ea:	f803 1b01 	strb.w	r1, [r3], #1
 80287ee:	e7f9      	b.n	80287e4 <strncpy+0x1a>

080287f0 <__locale_mb_cur_max>:
 80287f0:	4b01      	ldr	r3, [pc, #4]	; (80287f8 <__locale_mb_cur_max+0x8>)
 80287f2:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
 80287f6:	4770      	bx	lr
 80287f8:	20000798 	.word	0x20000798

080287fc <_localeconv_r>:
 80287fc:	4800      	ldr	r0, [pc, #0]	; (8028800 <_localeconv_r+0x4>)
 80287fe:	4770      	bx	lr
 8028800:	20000888 	.word	0x20000888

08028804 <_sbrk_r>:
 8028804:	b538      	push	{r3, r4, r5, lr}
 8028806:	4d06      	ldr	r5, [pc, #24]	; (8028820 <_sbrk_r+0x1c>)
 8028808:	2300      	movs	r3, #0
 802880a:	4604      	mov	r4, r0
 802880c:	4608      	mov	r0, r1
 802880e:	602b      	str	r3, [r5, #0]
 8028810:	f7d9 f81a 	bl	8001848 <_sbrk>
 8028814:	1c43      	adds	r3, r0, #1
 8028816:	d102      	bne.n	802881e <_sbrk_r+0x1a>
 8028818:	682b      	ldr	r3, [r5, #0]
 802881a:	b103      	cbz	r3, 802881e <_sbrk_r+0x1a>
 802881c:	6023      	str	r3, [r4, #0]
 802881e:	bd38      	pop	{r3, r4, r5, pc}
 8028820:	20011ed8 	.word	0x20011ed8

08028824 <__libc_fini_array>:
 8028824:	b538      	push	{r3, r4, r5, lr}
 8028826:	4d07      	ldr	r5, [pc, #28]	; (8028844 <__libc_fini_array+0x20>)
 8028828:	4c07      	ldr	r4, [pc, #28]	; (8028848 <__libc_fini_array+0x24>)
 802882a:	1b64      	subs	r4, r4, r5
 802882c:	10a4      	asrs	r4, r4, #2
 802882e:	b91c      	cbnz	r4, 8028838 <__libc_fini_array+0x14>
 8028830:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8028834:	f002 bd28 	b.w	802b288 <_fini>
 8028838:	3c01      	subs	r4, #1
 802883a:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 802883e:	4798      	blx	r3
 8028840:	e7f5      	b.n	802882e <__libc_fini_array+0xa>
 8028842:	bf00      	nop
 8028844:	080377e0 	.word	0x080377e0
 8028848:	080377e4 	.word	0x080377e4

0802884c <sysconf>:
 802884c:	2808      	cmp	r0, #8
 802884e:	b508      	push	{r3, lr}
 8028850:	d006      	beq.n	8028860 <sysconf+0x14>
 8028852:	f7fe f913 	bl	8026a7c <__errno>
 8028856:	2316      	movs	r3, #22
 8028858:	6003      	str	r3, [r0, #0]
 802885a:	f04f 30ff 	mov.w	r0, #4294967295
 802885e:	bd08      	pop	{r3, pc}
 8028860:	2080      	movs	r0, #128	; 0x80
 8028862:	e7fc      	b.n	802885e <sysconf+0x12>

08028864 <frexp>:
 8028864:	b570      	push	{r4, r5, r6, lr}
 8028866:	2100      	movs	r1, #0
 8028868:	ec55 4b10 	vmov	r4, r5, d0
 802886c:	6001      	str	r1, [r0, #0]
 802886e:	4916      	ldr	r1, [pc, #88]	; (80288c8 <frexp+0x64>)
 8028870:	f025 4200 	bic.w	r2, r5, #2147483648	; 0x80000000
 8028874:	428a      	cmp	r2, r1
 8028876:	4606      	mov	r6, r0
 8028878:	462b      	mov	r3, r5
 802887a:	dc22      	bgt.n	80288c2 <frexp+0x5e>
 802887c:	ee10 1a10 	vmov	r1, s0
 8028880:	4311      	orrs	r1, r2
 8028882:	d01e      	beq.n	80288c2 <frexp+0x5e>
 8028884:	4911      	ldr	r1, [pc, #68]	; (80288cc <frexp+0x68>)
 8028886:	4029      	ands	r1, r5
 8028888:	b969      	cbnz	r1, 80288a6 <frexp+0x42>
 802888a:	4b11      	ldr	r3, [pc, #68]	; (80288d0 <frexp+0x6c>)
 802888c:	2200      	movs	r2, #0
 802888e:	ee10 0a10 	vmov	r0, s0
 8028892:	4629      	mov	r1, r5
 8028894:	f7d7 fec8 	bl	8000628 <__aeabi_dmul>
 8028898:	460b      	mov	r3, r1
 802889a:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 802889e:	f06f 0135 	mvn.w	r1, #53	; 0x35
 80288a2:	4604      	mov	r4, r0
 80288a4:	6031      	str	r1, [r6, #0]
 80288a6:	6831      	ldr	r1, [r6, #0]
 80288a8:	1512      	asrs	r2, r2, #20
 80288aa:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 80288ae:	f2a2 32fe 	subw	r2, r2, #1022	; 0x3fe
 80288b2:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 80288b6:	4411      	add	r1, r2
 80288b8:	f043 557f 	orr.w	r5, r3, #1069547520	; 0x3fc00000
 80288bc:	6031      	str	r1, [r6, #0]
 80288be:	f445 1500 	orr.w	r5, r5, #2097152	; 0x200000
 80288c2:	ec45 4b10 	vmov	d0, r4, r5
 80288c6:	bd70      	pop	{r4, r5, r6, pc}
 80288c8:	7fefffff 	.word	0x7fefffff
 80288cc:	7ff00000 	.word	0x7ff00000
 80288d0:	43500000 	.word	0x43500000

080288d4 <__register_exitproc>:
 80288d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80288d8:	f8df a074 	ldr.w	sl, [pc, #116]	; 8028950 <__register_exitproc+0x7c>
 80288dc:	4606      	mov	r6, r0
 80288de:	f8da 0000 	ldr.w	r0, [sl]
 80288e2:	4698      	mov	r8, r3
 80288e4:	460f      	mov	r7, r1
 80288e6:	4691      	mov	r9, r2
 80288e8:	f7fe f8f4 	bl	8026ad4 <__retarget_lock_acquire_recursive>
 80288ec:	4b16      	ldr	r3, [pc, #88]	; (8028948 <__register_exitproc+0x74>)
 80288ee:	681c      	ldr	r4, [r3, #0]
 80288f0:	b90c      	cbnz	r4, 80288f6 <__register_exitproc+0x22>
 80288f2:	4c16      	ldr	r4, [pc, #88]	; (802894c <__register_exitproc+0x78>)
 80288f4:	601c      	str	r4, [r3, #0]
 80288f6:	6865      	ldr	r5, [r4, #4]
 80288f8:	f8da 0000 	ldr.w	r0, [sl]
 80288fc:	2d1f      	cmp	r5, #31
 80288fe:	dd05      	ble.n	802890c <__register_exitproc+0x38>
 8028900:	f7fe f8e9 	bl	8026ad6 <__retarget_lock_release_recursive>
 8028904:	f04f 30ff 	mov.w	r0, #4294967295
 8028908:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802890c:	b19e      	cbz	r6, 8028936 <__register_exitproc+0x62>
 802890e:	eb04 0185 	add.w	r1, r4, r5, lsl #2
 8028912:	2201      	movs	r2, #1
 8028914:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
 8028918:	f8d4 3188 	ldr.w	r3, [r4, #392]	; 0x188
 802891c:	40aa      	lsls	r2, r5
 802891e:	4313      	orrs	r3, r2
 8028920:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
 8028924:	2e02      	cmp	r6, #2
 8028926:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
 802892a:	bf02      	ittt	eq
 802892c:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
 8028930:	4313      	orreq	r3, r2
 8028932:	f8c4 318c 	streq.w	r3, [r4, #396]	; 0x18c
 8028936:	1c6b      	adds	r3, r5, #1
 8028938:	3502      	adds	r5, #2
 802893a:	6063      	str	r3, [r4, #4]
 802893c:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
 8028940:	f7fe f8c9 	bl	8026ad6 <__retarget_lock_release_recursive>
 8028944:	2000      	movs	r0, #0
 8028946:	e7df      	b.n	8028908 <__register_exitproc+0x34>
 8028948:	20011ee0 	.word	0x20011ee0
 802894c:	20011f18 	.word	0x20011f18
 8028950:	20000384 	.word	0x20000384

08028954 <quorem>:
 8028954:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028958:	6903      	ldr	r3, [r0, #16]
 802895a:	690c      	ldr	r4, [r1, #16]
 802895c:	42a3      	cmp	r3, r4
 802895e:	4607      	mov	r7, r0
 8028960:	db7e      	blt.n	8028a60 <quorem+0x10c>
 8028962:	3c01      	subs	r4, #1
 8028964:	f101 0814 	add.w	r8, r1, #20
 8028968:	f100 0514 	add.w	r5, r0, #20
 802896c:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8028970:	9301      	str	r3, [sp, #4]
 8028972:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
 8028976:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 802897a:	3301      	adds	r3, #1
 802897c:	429a      	cmp	r2, r3
 802897e:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 8028982:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 8028986:	fbb2 f6f3 	udiv	r6, r2, r3
 802898a:	d331      	bcc.n	80289f0 <quorem+0x9c>
 802898c:	f04f 0e00 	mov.w	lr, #0
 8028990:	4640      	mov	r0, r8
 8028992:	46ac      	mov	ip, r5
 8028994:	46f2      	mov	sl, lr
 8028996:	f850 2b04 	ldr.w	r2, [r0], #4
 802899a:	b293      	uxth	r3, r2
 802899c:	fb06 e303 	mla	r3, r6, r3, lr
 80289a0:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 80289a4:	0c1a      	lsrs	r2, r3, #16
 80289a6:	b29b      	uxth	r3, r3
 80289a8:	ebaa 0303 	sub.w	r3, sl, r3
 80289ac:	f8dc a000 	ldr.w	sl, [ip]
 80289b0:	fa13 f38a 	uxtah	r3, r3, sl
 80289b4:	fb06 220e 	mla	r2, r6, lr, r2
 80289b8:	9300      	str	r3, [sp, #0]
 80289ba:	9b00      	ldr	r3, [sp, #0]
 80289bc:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 80289c0:	b292      	uxth	r2, r2
 80289c2:	ebc2 421a 	rsb	r2, r2, sl, lsr #16
 80289c6:	eb02 4223 	add.w	r2, r2, r3, asr #16
 80289ca:	f8bd 3000 	ldrh.w	r3, [sp]
 80289ce:	4581      	cmp	r9, r0
 80289d0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80289d4:	f84c 3b04 	str.w	r3, [ip], #4
 80289d8:	ea4f 4a22 	mov.w	sl, r2, asr #16
 80289dc:	d2db      	bcs.n	8028996 <quorem+0x42>
 80289de:	f855 300b 	ldr.w	r3, [r5, fp]
 80289e2:	b92b      	cbnz	r3, 80289f0 <quorem+0x9c>
 80289e4:	9b01      	ldr	r3, [sp, #4]
 80289e6:	3b04      	subs	r3, #4
 80289e8:	429d      	cmp	r5, r3
 80289ea:	461a      	mov	r2, r3
 80289ec:	d32c      	bcc.n	8028a48 <quorem+0xf4>
 80289ee:	613c      	str	r4, [r7, #16]
 80289f0:	4638      	mov	r0, r7
 80289f2:	f001 f84f 	bl	8029a94 <__mcmp>
 80289f6:	2800      	cmp	r0, #0
 80289f8:	db22      	blt.n	8028a40 <quorem+0xec>
 80289fa:	3601      	adds	r6, #1
 80289fc:	4629      	mov	r1, r5
 80289fe:	2000      	movs	r0, #0
 8028a00:	f858 2b04 	ldr.w	r2, [r8], #4
 8028a04:	f8d1 c000 	ldr.w	ip, [r1]
 8028a08:	b293      	uxth	r3, r2
 8028a0a:	1ac3      	subs	r3, r0, r3
 8028a0c:	0c12      	lsrs	r2, r2, #16
 8028a0e:	fa13 f38c 	uxtah	r3, r3, ip
 8028a12:	ebc2 421c 	rsb	r2, r2, ip, lsr #16
 8028a16:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8028a1a:	b29b      	uxth	r3, r3
 8028a1c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8028a20:	45c1      	cmp	r9, r8
 8028a22:	f841 3b04 	str.w	r3, [r1], #4
 8028a26:	ea4f 4022 	mov.w	r0, r2, asr #16
 8028a2a:	d2e9      	bcs.n	8028a00 <quorem+0xac>
 8028a2c:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
 8028a30:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 8028a34:	b922      	cbnz	r2, 8028a40 <quorem+0xec>
 8028a36:	3b04      	subs	r3, #4
 8028a38:	429d      	cmp	r5, r3
 8028a3a:	461a      	mov	r2, r3
 8028a3c:	d30a      	bcc.n	8028a54 <quorem+0x100>
 8028a3e:	613c      	str	r4, [r7, #16]
 8028a40:	4630      	mov	r0, r6
 8028a42:	b003      	add	sp, #12
 8028a44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028a48:	6812      	ldr	r2, [r2, #0]
 8028a4a:	3b04      	subs	r3, #4
 8028a4c:	2a00      	cmp	r2, #0
 8028a4e:	d1ce      	bne.n	80289ee <quorem+0x9a>
 8028a50:	3c01      	subs	r4, #1
 8028a52:	e7c9      	b.n	80289e8 <quorem+0x94>
 8028a54:	6812      	ldr	r2, [r2, #0]
 8028a56:	3b04      	subs	r3, #4
 8028a58:	2a00      	cmp	r2, #0
 8028a5a:	d1f0      	bne.n	8028a3e <quorem+0xea>
 8028a5c:	3c01      	subs	r4, #1
 8028a5e:	e7eb      	b.n	8028a38 <quorem+0xe4>
 8028a60:	2000      	movs	r0, #0
 8028a62:	e7ee      	b.n	8028a42 <quorem+0xee>
 8028a64:	0000      	movs	r0, r0
	...

08028a68 <_dtoa_r>:
 8028a68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028a6c:	ed2d 8b04 	vpush	{d8-d9}
 8028a70:	b093      	sub	sp, #76	; 0x4c
 8028a72:	ed8d 0b02 	vstr	d0, [sp, #8]
 8028a76:	9107      	str	r1, [sp, #28]
 8028a78:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8028a7a:	9d20      	ldr	r5, [sp, #128]	; 0x80
 8028a7c:	920a      	str	r2, [sp, #40]	; 0x28
 8028a7e:	ec57 6b10 	vmov	r6, r7, d0
 8028a82:	4604      	mov	r4, r0
 8028a84:	930d      	str	r3, [sp, #52]	; 0x34
 8028a86:	b141      	cbz	r1, 8028a9a <_dtoa_r+0x32>
 8028a88:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8028a8a:	604a      	str	r2, [r1, #4]
 8028a8c:	2301      	movs	r3, #1
 8028a8e:	4093      	lsls	r3, r2
 8028a90:	608b      	str	r3, [r1, #8]
 8028a92:	f000 fdf6 	bl	8029682 <_Bfree>
 8028a96:	2300      	movs	r3, #0
 8028a98:	63a3      	str	r3, [r4, #56]	; 0x38
 8028a9a:	1e3b      	subs	r3, r7, #0
 8028a9c:	bfb9      	ittee	lt
 8028a9e:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 8028aa2:	9303      	strlt	r3, [sp, #12]
 8028aa4:	2300      	movge	r3, #0
 8028aa6:	602b      	strge	r3, [r5, #0]
 8028aa8:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8028aac:	4ba2      	ldr	r3, [pc, #648]	; (8028d38 <_dtoa_r+0x2d0>)
 8028aae:	bfbc      	itt	lt
 8028ab0:	2201      	movlt	r2, #1
 8028ab2:	602a      	strlt	r2, [r5, #0]
 8028ab4:	ea33 0308 	bics.w	r3, r3, r8
 8028ab8:	d11b      	bne.n	8028af2 <_dtoa_r+0x8a>
 8028aba:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8028abc:	f242 730f 	movw	r3, #9999	; 0x270f
 8028ac0:	6013      	str	r3, [r2, #0]
 8028ac2:	f3c8 0313 	ubfx	r3, r8, #0, #20
 8028ac6:	4333      	orrs	r3, r6
 8028ac8:	f000 858f 	beq.w	80295ea <_dtoa_r+0xb82>
 8028acc:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028ace:	b90b      	cbnz	r3, 8028ad4 <_dtoa_r+0x6c>
 8028ad0:	4b9a      	ldr	r3, [pc, #616]	; (8028d3c <_dtoa_r+0x2d4>)
 8028ad2:	e027      	b.n	8028b24 <_dtoa_r+0xbc>
 8028ad4:	4b99      	ldr	r3, [pc, #612]	; (8028d3c <_dtoa_r+0x2d4>)
 8028ad6:	9300      	str	r3, [sp, #0]
 8028ad8:	3303      	adds	r3, #3
 8028ada:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8028adc:	6013      	str	r3, [r2, #0]
 8028ade:	9800      	ldr	r0, [sp, #0]
 8028ae0:	b013      	add	sp, #76	; 0x4c
 8028ae2:	ecbd 8b04 	vpop	{d8-d9}
 8028ae6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8028aea:	4b95      	ldr	r3, [pc, #596]	; (8028d40 <_dtoa_r+0x2d8>)
 8028aec:	9300      	str	r3, [sp, #0]
 8028aee:	3308      	adds	r3, #8
 8028af0:	e7f3      	b.n	8028ada <_dtoa_r+0x72>
 8028af2:	ed9d 7b02 	vldr	d7, [sp, #8]
 8028af6:	2200      	movs	r2, #0
 8028af8:	ec51 0b17 	vmov	r0, r1, d7
 8028afc:	eeb0 8a47 	vmov.f32	s16, s14
 8028b00:	eef0 8a67 	vmov.f32	s17, s15
 8028b04:	2300      	movs	r3, #0
 8028b06:	f7d7 fff7 	bl	8000af8 <__aeabi_dcmpeq>
 8028b0a:	4681      	mov	r9, r0
 8028b0c:	b160      	cbz	r0, 8028b28 <_dtoa_r+0xc0>
 8028b0e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8028b10:	2301      	movs	r3, #1
 8028b12:	6013      	str	r3, [r2, #0]
 8028b14:	9b21      	ldr	r3, [sp, #132]	; 0x84
 8028b16:	2b00      	cmp	r3, #0
 8028b18:	f000 8564 	beq.w	80295e4 <_dtoa_r+0xb7c>
 8028b1c:	4b89      	ldr	r3, [pc, #548]	; (8028d44 <_dtoa_r+0x2dc>)
 8028b1e:	9a21      	ldr	r2, [sp, #132]	; 0x84
 8028b20:	6013      	str	r3, [r2, #0]
 8028b22:	3b01      	subs	r3, #1
 8028b24:	9300      	str	r3, [sp, #0]
 8028b26:	e7da      	b.n	8028ade <_dtoa_r+0x76>
 8028b28:	aa10      	add	r2, sp, #64	; 0x40
 8028b2a:	a911      	add	r1, sp, #68	; 0x44
 8028b2c:	4620      	mov	r0, r4
 8028b2e:	eeb0 0a48 	vmov.f32	s0, s16
 8028b32:	eef0 0a68 	vmov.f32	s1, s17
 8028b36:	f001 f853 	bl	8029be0 <__d2b>
 8028b3a:	f3c8 550a 	ubfx	r5, r8, #20, #11
 8028b3e:	4682      	mov	sl, r0
 8028b40:	2d00      	cmp	r5, #0
 8028b42:	d07e      	beq.n	8028c42 <_dtoa_r+0x1da>
 8028b44:	ee18 3a90 	vmov	r3, s17
 8028b48:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8028b4c:	f043 537f 	orr.w	r3, r3, #1069547520	; 0x3fc00000
 8028b50:	ec51 0b18 	vmov	r0, r1, d8
 8028b54:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8028b58:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8028b5c:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
 8028b60:	4619      	mov	r1, r3
 8028b62:	2200      	movs	r2, #0
 8028b64:	4b78      	ldr	r3, [pc, #480]	; (8028d48 <_dtoa_r+0x2e0>)
 8028b66:	f7d7 fba7 	bl	80002b8 <__aeabi_dsub>
 8028b6a:	a36d      	add	r3, pc, #436	; (adr r3, 8028d20 <_dtoa_r+0x2b8>)
 8028b6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028b70:	f7d7 fd5a 	bl	8000628 <__aeabi_dmul>
 8028b74:	a36c      	add	r3, pc, #432	; (adr r3, 8028d28 <_dtoa_r+0x2c0>)
 8028b76:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028b7a:	f7d7 fb9f 	bl	80002bc <__adddf3>
 8028b7e:	4606      	mov	r6, r0
 8028b80:	4628      	mov	r0, r5
 8028b82:	460f      	mov	r7, r1
 8028b84:	f7d7 fce6 	bl	8000554 <__aeabi_i2d>
 8028b88:	a369      	add	r3, pc, #420	; (adr r3, 8028d30 <_dtoa_r+0x2c8>)
 8028b8a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028b8e:	f7d7 fd4b 	bl	8000628 <__aeabi_dmul>
 8028b92:	4602      	mov	r2, r0
 8028b94:	460b      	mov	r3, r1
 8028b96:	4630      	mov	r0, r6
 8028b98:	4639      	mov	r1, r7
 8028b9a:	f7d7 fb8f 	bl	80002bc <__adddf3>
 8028b9e:	4606      	mov	r6, r0
 8028ba0:	460f      	mov	r7, r1
 8028ba2:	f7d7 fff1 	bl	8000b88 <__aeabi_d2iz>
 8028ba6:	2200      	movs	r2, #0
 8028ba8:	4683      	mov	fp, r0
 8028baa:	2300      	movs	r3, #0
 8028bac:	4630      	mov	r0, r6
 8028bae:	4639      	mov	r1, r7
 8028bb0:	f7d7 ffac 	bl	8000b0c <__aeabi_dcmplt>
 8028bb4:	b148      	cbz	r0, 8028bca <_dtoa_r+0x162>
 8028bb6:	4658      	mov	r0, fp
 8028bb8:	f7d7 fccc 	bl	8000554 <__aeabi_i2d>
 8028bbc:	4632      	mov	r2, r6
 8028bbe:	463b      	mov	r3, r7
 8028bc0:	f7d7 ff9a 	bl	8000af8 <__aeabi_dcmpeq>
 8028bc4:	b908      	cbnz	r0, 8028bca <_dtoa_r+0x162>
 8028bc6:	f10b 3bff 	add.w	fp, fp, #4294967295
 8028bca:	f1bb 0f16 	cmp.w	fp, #22
 8028bce:	d856      	bhi.n	8028c7e <_dtoa_r+0x216>
 8028bd0:	4b5e      	ldr	r3, [pc, #376]	; (8028d4c <_dtoa_r+0x2e4>)
 8028bd2:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8028bd6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028bda:	ec51 0b18 	vmov	r0, r1, d8
 8028bde:	f7d7 ff95 	bl	8000b0c <__aeabi_dcmplt>
 8028be2:	2800      	cmp	r0, #0
 8028be4:	d04d      	beq.n	8028c82 <_dtoa_r+0x21a>
 8028be6:	f10b 3bff 	add.w	fp, fp, #4294967295
 8028bea:	2300      	movs	r3, #0
 8028bec:	930c      	str	r3, [sp, #48]	; 0x30
 8028bee:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8028bf0:	1b5b      	subs	r3, r3, r5
 8028bf2:	1e5a      	subs	r2, r3, #1
 8028bf4:	bf45      	ittet	mi
 8028bf6:	f1c3 0301 	rsbmi	r3, r3, #1
 8028bfa:	9305      	strmi	r3, [sp, #20]
 8028bfc:	2300      	movpl	r3, #0
 8028bfe:	2300      	movmi	r3, #0
 8028c00:	9206      	str	r2, [sp, #24]
 8028c02:	bf54      	ite	pl
 8028c04:	9305      	strpl	r3, [sp, #20]
 8028c06:	9306      	strmi	r3, [sp, #24]
 8028c08:	f1bb 0f00 	cmp.w	fp, #0
 8028c0c:	db3b      	blt.n	8028c86 <_dtoa_r+0x21e>
 8028c0e:	9b06      	ldr	r3, [sp, #24]
 8028c10:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8028c14:	445b      	add	r3, fp
 8028c16:	9306      	str	r3, [sp, #24]
 8028c18:	2300      	movs	r3, #0
 8028c1a:	9308      	str	r3, [sp, #32]
 8028c1c:	9b07      	ldr	r3, [sp, #28]
 8028c1e:	2b09      	cmp	r3, #9
 8028c20:	d868      	bhi.n	8028cf4 <_dtoa_r+0x28c>
 8028c22:	2b05      	cmp	r3, #5
 8028c24:	bfc4      	itt	gt
 8028c26:	3b04      	subgt	r3, #4
 8028c28:	9307      	strgt	r3, [sp, #28]
 8028c2a:	9b07      	ldr	r3, [sp, #28]
 8028c2c:	f1a3 0302 	sub.w	r3, r3, #2
 8028c30:	bfcc      	ite	gt
 8028c32:	2500      	movgt	r5, #0
 8028c34:	2501      	movle	r5, #1
 8028c36:	2b03      	cmp	r3, #3
 8028c38:	d867      	bhi.n	8028d0a <_dtoa_r+0x2a2>
 8028c3a:	e8df f003 	tbb	[pc, r3]
 8028c3e:	3b2e      	.short	0x3b2e
 8028c40:	5939      	.short	0x5939
 8028c42:	e9dd 5310 	ldrd	r5, r3, [sp, #64]	; 0x40
 8028c46:	441d      	add	r5, r3
 8028c48:	f205 4332 	addw	r3, r5, #1074	; 0x432
 8028c4c:	2b20      	cmp	r3, #32
 8028c4e:	bfc1      	itttt	gt
 8028c50:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 8028c54:	fa08 f803 	lslgt.w	r8, r8, r3
 8028c58:	f205 4312 	addwgt	r3, r5, #1042	; 0x412
 8028c5c:	fa26 f303 	lsrgt.w	r3, r6, r3
 8028c60:	bfd6      	itet	le
 8028c62:	f1c3 0320 	rsble	r3, r3, #32
 8028c66:	ea48 0003 	orrgt.w	r0, r8, r3
 8028c6a:	fa06 f003 	lslle.w	r0, r6, r3
 8028c6e:	f7d7 fc61 	bl	8000534 <__aeabi_ui2d>
 8028c72:	2201      	movs	r2, #1
 8028c74:	f1a1 73f8 	sub.w	r3, r1, #32505856	; 0x1f00000
 8028c78:	3d01      	subs	r5, #1
 8028c7a:	920e      	str	r2, [sp, #56]	; 0x38
 8028c7c:	e770      	b.n	8028b60 <_dtoa_r+0xf8>
 8028c7e:	2301      	movs	r3, #1
 8028c80:	e7b4      	b.n	8028bec <_dtoa_r+0x184>
 8028c82:	900c      	str	r0, [sp, #48]	; 0x30
 8028c84:	e7b3      	b.n	8028bee <_dtoa_r+0x186>
 8028c86:	9b05      	ldr	r3, [sp, #20]
 8028c88:	eba3 030b 	sub.w	r3, r3, fp
 8028c8c:	9305      	str	r3, [sp, #20]
 8028c8e:	f1cb 0300 	rsb	r3, fp, #0
 8028c92:	9308      	str	r3, [sp, #32]
 8028c94:	2300      	movs	r3, #0
 8028c96:	930b      	str	r3, [sp, #44]	; 0x2c
 8028c98:	e7c0      	b.n	8028c1c <_dtoa_r+0x1b4>
 8028c9a:	2300      	movs	r3, #0
 8028c9c:	9309      	str	r3, [sp, #36]	; 0x24
 8028c9e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028ca0:	2b00      	cmp	r3, #0
 8028ca2:	dc35      	bgt.n	8028d10 <_dtoa_r+0x2a8>
 8028ca4:	2301      	movs	r3, #1
 8028ca6:	9301      	str	r3, [sp, #4]
 8028ca8:	9304      	str	r3, [sp, #16]
 8028caa:	461a      	mov	r2, r3
 8028cac:	920a      	str	r2, [sp, #40]	; 0x28
 8028cae:	e00b      	b.n	8028cc8 <_dtoa_r+0x260>
 8028cb0:	2301      	movs	r3, #1
 8028cb2:	e7f3      	b.n	8028c9c <_dtoa_r+0x234>
 8028cb4:	2300      	movs	r3, #0
 8028cb6:	9309      	str	r3, [sp, #36]	; 0x24
 8028cb8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028cba:	445b      	add	r3, fp
 8028cbc:	9301      	str	r3, [sp, #4]
 8028cbe:	3301      	adds	r3, #1
 8028cc0:	2b01      	cmp	r3, #1
 8028cc2:	9304      	str	r3, [sp, #16]
 8028cc4:	bfb8      	it	lt
 8028cc6:	2301      	movlt	r3, #1
 8028cc8:	2100      	movs	r1, #0
 8028cca:	2204      	movs	r2, #4
 8028ccc:	f102 0014 	add.w	r0, r2, #20
 8028cd0:	4298      	cmp	r0, r3
 8028cd2:	d921      	bls.n	8028d18 <_dtoa_r+0x2b0>
 8028cd4:	63e1      	str	r1, [r4, #60]	; 0x3c
 8028cd6:	4620      	mov	r0, r4
 8028cd8:	f000 fcae 	bl	8029638 <_Balloc>
 8028cdc:	9000      	str	r0, [sp, #0]
 8028cde:	2800      	cmp	r0, #0
 8028ce0:	d13a      	bne.n	8028d58 <_dtoa_r+0x2f0>
 8028ce2:	4b1b      	ldr	r3, [pc, #108]	; (8028d50 <_dtoa_r+0x2e8>)
 8028ce4:	4602      	mov	r2, r0
 8028ce6:	f240 11af 	movw	r1, #431	; 0x1af
 8028cea:	481a      	ldr	r0, [pc, #104]	; (8028d54 <_dtoa_r+0x2ec>)
 8028cec:	f001 fa1e 	bl	802a12c <__assert_func>
 8028cf0:	2301      	movs	r3, #1
 8028cf2:	e7e0      	b.n	8028cb6 <_dtoa_r+0x24e>
 8028cf4:	2501      	movs	r5, #1
 8028cf6:	2300      	movs	r3, #0
 8028cf8:	9307      	str	r3, [sp, #28]
 8028cfa:	9509      	str	r5, [sp, #36]	; 0x24
 8028cfc:	f04f 33ff 	mov.w	r3, #4294967295
 8028d00:	9301      	str	r3, [sp, #4]
 8028d02:	9304      	str	r3, [sp, #16]
 8028d04:	2200      	movs	r2, #0
 8028d06:	2312      	movs	r3, #18
 8028d08:	e7d0      	b.n	8028cac <_dtoa_r+0x244>
 8028d0a:	2301      	movs	r3, #1
 8028d0c:	9309      	str	r3, [sp, #36]	; 0x24
 8028d0e:	e7f5      	b.n	8028cfc <_dtoa_r+0x294>
 8028d10:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028d12:	9301      	str	r3, [sp, #4]
 8028d14:	9304      	str	r3, [sp, #16]
 8028d16:	e7d7      	b.n	8028cc8 <_dtoa_r+0x260>
 8028d18:	3101      	adds	r1, #1
 8028d1a:	0052      	lsls	r2, r2, #1
 8028d1c:	e7d6      	b.n	8028ccc <_dtoa_r+0x264>
 8028d1e:	bf00      	nop
 8028d20:	636f4361 	.word	0x636f4361
 8028d24:	3fd287a7 	.word	0x3fd287a7
 8028d28:	8b60c8b3 	.word	0x8b60c8b3
 8028d2c:	3fc68a28 	.word	0x3fc68a28
 8028d30:	509f79fb 	.word	0x509f79fb
 8028d34:	3fd34413 	.word	0x3fd34413
 8028d38:	7ff00000 	.word	0x7ff00000
 8028d3c:	080375ac 	.word	0x080375ac
 8028d40:	080375a3 	.word	0x080375a3
 8028d44:	08037578 	.word	0x08037578
 8028d48:	3ff80000 	.word	0x3ff80000
 8028d4c:	080376a0 	.word	0x080376a0
 8028d50:	080375b0 	.word	0x080375b0
 8028d54:	080375c1 	.word	0x080375c1
 8028d58:	9b00      	ldr	r3, [sp, #0]
 8028d5a:	63a3      	str	r3, [r4, #56]	; 0x38
 8028d5c:	9b04      	ldr	r3, [sp, #16]
 8028d5e:	2b0e      	cmp	r3, #14
 8028d60:	f200 80a8 	bhi.w	8028eb4 <_dtoa_r+0x44c>
 8028d64:	2d00      	cmp	r5, #0
 8028d66:	f000 80a5 	beq.w	8028eb4 <_dtoa_r+0x44c>
 8028d6a:	f1bb 0f00 	cmp.w	fp, #0
 8028d6e:	dd38      	ble.n	8028de2 <_dtoa_r+0x37a>
 8028d70:	4bbf      	ldr	r3, [pc, #764]	; (8029070 <_dtoa_r+0x608>)
 8028d72:	f00b 020f 	and.w	r2, fp, #15
 8028d76:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028d7a:	f41b 7f80 	tst.w	fp, #256	; 0x100
 8028d7e:	e9d3 6700 	ldrd	r6, r7, [r3]
 8028d82:	ea4f 182b 	mov.w	r8, fp, asr #4
 8028d86:	d019      	beq.n	8028dbc <_dtoa_r+0x354>
 8028d88:	4bba      	ldr	r3, [pc, #744]	; (8029074 <_dtoa_r+0x60c>)
 8028d8a:	ec51 0b18 	vmov	r0, r1, d8
 8028d8e:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8028d92:	f7d7 fd73 	bl	800087c <__aeabi_ddiv>
 8028d96:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8028d9a:	f008 080f 	and.w	r8, r8, #15
 8028d9e:	2503      	movs	r5, #3
 8028da0:	f8df 92d0 	ldr.w	r9, [pc, #720]	; 8029074 <_dtoa_r+0x60c>
 8028da4:	f1b8 0f00 	cmp.w	r8, #0
 8028da8:	d10a      	bne.n	8028dc0 <_dtoa_r+0x358>
 8028daa:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8028dae:	4632      	mov	r2, r6
 8028db0:	463b      	mov	r3, r7
 8028db2:	f7d7 fd63 	bl	800087c <__aeabi_ddiv>
 8028db6:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8028dba:	e02b      	b.n	8028e14 <_dtoa_r+0x3ac>
 8028dbc:	2502      	movs	r5, #2
 8028dbe:	e7ef      	b.n	8028da0 <_dtoa_r+0x338>
 8028dc0:	f018 0f01 	tst.w	r8, #1
 8028dc4:	d008      	beq.n	8028dd8 <_dtoa_r+0x370>
 8028dc6:	4630      	mov	r0, r6
 8028dc8:	4639      	mov	r1, r7
 8028dca:	e9d9 2300 	ldrd	r2, r3, [r9]
 8028dce:	f7d7 fc2b 	bl	8000628 <__aeabi_dmul>
 8028dd2:	3501      	adds	r5, #1
 8028dd4:	4606      	mov	r6, r0
 8028dd6:	460f      	mov	r7, r1
 8028dd8:	ea4f 0868 	mov.w	r8, r8, asr #1
 8028ddc:	f109 0908 	add.w	r9, r9, #8
 8028de0:	e7e0      	b.n	8028da4 <_dtoa_r+0x33c>
 8028de2:	f000 809f 	beq.w	8028f24 <_dtoa_r+0x4bc>
 8028de6:	f1cb 0600 	rsb	r6, fp, #0
 8028dea:	4ba1      	ldr	r3, [pc, #644]	; (8029070 <_dtoa_r+0x608>)
 8028dec:	4fa1      	ldr	r7, [pc, #644]	; (8029074 <_dtoa_r+0x60c>)
 8028dee:	f006 020f 	and.w	r2, r6, #15
 8028df2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8028df6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8028dfa:	ec51 0b18 	vmov	r0, r1, d8
 8028dfe:	f7d7 fc13 	bl	8000628 <__aeabi_dmul>
 8028e02:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8028e06:	1136      	asrs	r6, r6, #4
 8028e08:	2300      	movs	r3, #0
 8028e0a:	2502      	movs	r5, #2
 8028e0c:	2e00      	cmp	r6, #0
 8028e0e:	d17e      	bne.n	8028f0e <_dtoa_r+0x4a6>
 8028e10:	2b00      	cmp	r3, #0
 8028e12:	d1d0      	bne.n	8028db6 <_dtoa_r+0x34e>
 8028e14:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8028e16:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8028e1a:	2b00      	cmp	r3, #0
 8028e1c:	f000 8084 	beq.w	8028f28 <_dtoa_r+0x4c0>
 8028e20:	4b95      	ldr	r3, [pc, #596]	; (8029078 <_dtoa_r+0x610>)
 8028e22:	2200      	movs	r2, #0
 8028e24:	4640      	mov	r0, r8
 8028e26:	4649      	mov	r1, r9
 8028e28:	f7d7 fe70 	bl	8000b0c <__aeabi_dcmplt>
 8028e2c:	2800      	cmp	r0, #0
 8028e2e:	d07b      	beq.n	8028f28 <_dtoa_r+0x4c0>
 8028e30:	9b04      	ldr	r3, [sp, #16]
 8028e32:	2b00      	cmp	r3, #0
 8028e34:	d078      	beq.n	8028f28 <_dtoa_r+0x4c0>
 8028e36:	9b01      	ldr	r3, [sp, #4]
 8028e38:	2b00      	cmp	r3, #0
 8028e3a:	dd39      	ble.n	8028eb0 <_dtoa_r+0x448>
 8028e3c:	4b8f      	ldr	r3, [pc, #572]	; (802907c <_dtoa_r+0x614>)
 8028e3e:	2200      	movs	r2, #0
 8028e40:	4640      	mov	r0, r8
 8028e42:	4649      	mov	r1, r9
 8028e44:	f7d7 fbf0 	bl	8000628 <__aeabi_dmul>
 8028e48:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8028e4c:	9e01      	ldr	r6, [sp, #4]
 8028e4e:	f10b 37ff 	add.w	r7, fp, #4294967295
 8028e52:	3501      	adds	r5, #1
 8028e54:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
 8028e58:	4628      	mov	r0, r5
 8028e5a:	f7d7 fb7b 	bl	8000554 <__aeabi_i2d>
 8028e5e:	4642      	mov	r2, r8
 8028e60:	464b      	mov	r3, r9
 8028e62:	f7d7 fbe1 	bl	8000628 <__aeabi_dmul>
 8028e66:	4b86      	ldr	r3, [pc, #536]	; (8029080 <_dtoa_r+0x618>)
 8028e68:	2200      	movs	r2, #0
 8028e6a:	f7d7 fa27 	bl	80002bc <__adddf3>
 8028e6e:	f1a1 7350 	sub.w	r3, r1, #54525952	; 0x3400000
 8028e72:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8028e76:	9303      	str	r3, [sp, #12]
 8028e78:	2e00      	cmp	r6, #0
 8028e7a:	d158      	bne.n	8028f2e <_dtoa_r+0x4c6>
 8028e7c:	4b81      	ldr	r3, [pc, #516]	; (8029084 <_dtoa_r+0x61c>)
 8028e7e:	2200      	movs	r2, #0
 8028e80:	4640      	mov	r0, r8
 8028e82:	4649      	mov	r1, r9
 8028e84:	f7d7 fa18 	bl	80002b8 <__aeabi_dsub>
 8028e88:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8028e8c:	4680      	mov	r8, r0
 8028e8e:	4689      	mov	r9, r1
 8028e90:	f7d7 fe5a 	bl	8000b48 <__aeabi_dcmpgt>
 8028e94:	2800      	cmp	r0, #0
 8028e96:	f040 8295 	bne.w	80293c4 <_dtoa_r+0x95c>
 8028e9a:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
 8028e9e:	4640      	mov	r0, r8
 8028ea0:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8028ea4:	4649      	mov	r1, r9
 8028ea6:	f7d7 fe31 	bl	8000b0c <__aeabi_dcmplt>
 8028eaa:	2800      	cmp	r0, #0
 8028eac:	f040 8288 	bne.w	80293c0 <_dtoa_r+0x958>
 8028eb0:	ed8d 8b02 	vstr	d8, [sp, #8]
 8028eb4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8028eb6:	2b00      	cmp	r3, #0
 8028eb8:	f2c0 814d 	blt.w	8029156 <_dtoa_r+0x6ee>
 8028ebc:	f1bb 0f0e 	cmp.w	fp, #14
 8028ec0:	f300 8149 	bgt.w	8029156 <_dtoa_r+0x6ee>
 8028ec4:	4b6a      	ldr	r3, [pc, #424]	; (8029070 <_dtoa_r+0x608>)
 8028ec6:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 8028eca:	e9d3 8900 	ldrd	r8, r9, [r3]
 8028ece:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8028ed0:	2b00      	cmp	r3, #0
 8028ed2:	f280 80db 	bge.w	802908c <_dtoa_r+0x624>
 8028ed6:	9b04      	ldr	r3, [sp, #16]
 8028ed8:	2b00      	cmp	r3, #0
 8028eda:	f300 80d7 	bgt.w	802908c <_dtoa_r+0x624>
 8028ede:	f040 826e 	bne.w	80293be <_dtoa_r+0x956>
 8028ee2:	4b68      	ldr	r3, [pc, #416]	; (8029084 <_dtoa_r+0x61c>)
 8028ee4:	2200      	movs	r2, #0
 8028ee6:	4640      	mov	r0, r8
 8028ee8:	4649      	mov	r1, r9
 8028eea:	f7d7 fb9d 	bl	8000628 <__aeabi_dmul>
 8028eee:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8028ef2:	f7d7 fe1f 	bl	8000b34 <__aeabi_dcmpge>
 8028ef6:	9e04      	ldr	r6, [sp, #16]
 8028ef8:	4637      	mov	r7, r6
 8028efa:	2800      	cmp	r0, #0
 8028efc:	f040 8244 	bne.w	8029388 <_dtoa_r+0x920>
 8028f00:	9d00      	ldr	r5, [sp, #0]
 8028f02:	2331      	movs	r3, #49	; 0x31
 8028f04:	f805 3b01 	strb.w	r3, [r5], #1
 8028f08:	f10b 0b01 	add.w	fp, fp, #1
 8028f0c:	e240      	b.n	8029390 <_dtoa_r+0x928>
 8028f0e:	07f2      	lsls	r2, r6, #31
 8028f10:	d505      	bpl.n	8028f1e <_dtoa_r+0x4b6>
 8028f12:	e9d7 2300 	ldrd	r2, r3, [r7]
 8028f16:	f7d7 fb87 	bl	8000628 <__aeabi_dmul>
 8028f1a:	3501      	adds	r5, #1
 8028f1c:	2301      	movs	r3, #1
 8028f1e:	1076      	asrs	r6, r6, #1
 8028f20:	3708      	adds	r7, #8
 8028f22:	e773      	b.n	8028e0c <_dtoa_r+0x3a4>
 8028f24:	2502      	movs	r5, #2
 8028f26:	e775      	b.n	8028e14 <_dtoa_r+0x3ac>
 8028f28:	9e04      	ldr	r6, [sp, #16]
 8028f2a:	465f      	mov	r7, fp
 8028f2c:	e792      	b.n	8028e54 <_dtoa_r+0x3ec>
 8028f2e:	9900      	ldr	r1, [sp, #0]
 8028f30:	4b4f      	ldr	r3, [pc, #316]	; (8029070 <_dtoa_r+0x608>)
 8028f32:	ed9d 7b02 	vldr	d7, [sp, #8]
 8028f36:	4431      	add	r1, r6
 8028f38:	9102      	str	r1, [sp, #8]
 8028f3a:	9909      	ldr	r1, [sp, #36]	; 0x24
 8028f3c:	eeb0 9a47 	vmov.f32	s18, s14
 8028f40:	eef0 9a67 	vmov.f32	s19, s15
 8028f44:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8028f48:	e953 2302 	ldrd	r2, r3, [r3, #-8]
 8028f4c:	2900      	cmp	r1, #0
 8028f4e:	d044      	beq.n	8028fda <_dtoa_r+0x572>
 8028f50:	494d      	ldr	r1, [pc, #308]	; (8029088 <_dtoa_r+0x620>)
 8028f52:	2000      	movs	r0, #0
 8028f54:	f7d7 fc92 	bl	800087c <__aeabi_ddiv>
 8028f58:	ec53 2b19 	vmov	r2, r3, d9
 8028f5c:	f7d7 f9ac 	bl	80002b8 <__aeabi_dsub>
 8028f60:	9d00      	ldr	r5, [sp, #0]
 8028f62:	ec41 0b19 	vmov	d9, r0, r1
 8028f66:	4649      	mov	r1, r9
 8028f68:	4640      	mov	r0, r8
 8028f6a:	f7d7 fe0d 	bl	8000b88 <__aeabi_d2iz>
 8028f6e:	4606      	mov	r6, r0
 8028f70:	f7d7 faf0 	bl	8000554 <__aeabi_i2d>
 8028f74:	4602      	mov	r2, r0
 8028f76:	460b      	mov	r3, r1
 8028f78:	4640      	mov	r0, r8
 8028f7a:	4649      	mov	r1, r9
 8028f7c:	f7d7 f99c 	bl	80002b8 <__aeabi_dsub>
 8028f80:	3630      	adds	r6, #48	; 0x30
 8028f82:	f805 6b01 	strb.w	r6, [r5], #1
 8028f86:	ec53 2b19 	vmov	r2, r3, d9
 8028f8a:	4680      	mov	r8, r0
 8028f8c:	4689      	mov	r9, r1
 8028f8e:	f7d7 fdbd 	bl	8000b0c <__aeabi_dcmplt>
 8028f92:	2800      	cmp	r0, #0
 8028f94:	d164      	bne.n	8029060 <_dtoa_r+0x5f8>
 8028f96:	4642      	mov	r2, r8
 8028f98:	464b      	mov	r3, r9
 8028f9a:	4937      	ldr	r1, [pc, #220]	; (8029078 <_dtoa_r+0x610>)
 8028f9c:	2000      	movs	r0, #0
 8028f9e:	f7d7 f98b 	bl	80002b8 <__aeabi_dsub>
 8028fa2:	ec53 2b19 	vmov	r2, r3, d9
 8028fa6:	f7d7 fdb1 	bl	8000b0c <__aeabi_dcmplt>
 8028faa:	2800      	cmp	r0, #0
 8028fac:	f040 80b5 	bne.w	802911a <_dtoa_r+0x6b2>
 8028fb0:	9b02      	ldr	r3, [sp, #8]
 8028fb2:	429d      	cmp	r5, r3
 8028fb4:	f43f af7c 	beq.w	8028eb0 <_dtoa_r+0x448>
 8028fb8:	4b30      	ldr	r3, [pc, #192]	; (802907c <_dtoa_r+0x614>)
 8028fba:	ec51 0b19 	vmov	r0, r1, d9
 8028fbe:	2200      	movs	r2, #0
 8028fc0:	f7d7 fb32 	bl	8000628 <__aeabi_dmul>
 8028fc4:	4b2d      	ldr	r3, [pc, #180]	; (802907c <_dtoa_r+0x614>)
 8028fc6:	ec41 0b19 	vmov	d9, r0, r1
 8028fca:	2200      	movs	r2, #0
 8028fcc:	4640      	mov	r0, r8
 8028fce:	4649      	mov	r1, r9
 8028fd0:	f7d7 fb2a 	bl	8000628 <__aeabi_dmul>
 8028fd4:	4680      	mov	r8, r0
 8028fd6:	4689      	mov	r9, r1
 8028fd8:	e7c5      	b.n	8028f66 <_dtoa_r+0x4fe>
 8028fda:	ec51 0b17 	vmov	r0, r1, d7
 8028fde:	f7d7 fb23 	bl	8000628 <__aeabi_dmul>
 8028fe2:	9b02      	ldr	r3, [sp, #8]
 8028fe4:	9d00      	ldr	r5, [sp, #0]
 8028fe6:	930f      	str	r3, [sp, #60]	; 0x3c
 8028fe8:	ec41 0b19 	vmov	d9, r0, r1
 8028fec:	4649      	mov	r1, r9
 8028fee:	4640      	mov	r0, r8
 8028ff0:	f7d7 fdca 	bl	8000b88 <__aeabi_d2iz>
 8028ff4:	4606      	mov	r6, r0
 8028ff6:	f7d7 faad 	bl	8000554 <__aeabi_i2d>
 8028ffa:	3630      	adds	r6, #48	; 0x30
 8028ffc:	4602      	mov	r2, r0
 8028ffe:	460b      	mov	r3, r1
 8029000:	4640      	mov	r0, r8
 8029002:	4649      	mov	r1, r9
 8029004:	f7d7 f958 	bl	80002b8 <__aeabi_dsub>
 8029008:	f805 6b01 	strb.w	r6, [r5], #1
 802900c:	9b02      	ldr	r3, [sp, #8]
 802900e:	429d      	cmp	r5, r3
 8029010:	4680      	mov	r8, r0
 8029012:	4689      	mov	r9, r1
 8029014:	f04f 0200 	mov.w	r2, #0
 8029018:	d124      	bne.n	8029064 <_dtoa_r+0x5fc>
 802901a:	4b1b      	ldr	r3, [pc, #108]	; (8029088 <_dtoa_r+0x620>)
 802901c:	ec51 0b19 	vmov	r0, r1, d9
 8029020:	f7d7 f94c 	bl	80002bc <__adddf3>
 8029024:	4602      	mov	r2, r0
 8029026:	460b      	mov	r3, r1
 8029028:	4640      	mov	r0, r8
 802902a:	4649      	mov	r1, r9
 802902c:	f7d7 fd8c 	bl	8000b48 <__aeabi_dcmpgt>
 8029030:	2800      	cmp	r0, #0
 8029032:	d172      	bne.n	802911a <_dtoa_r+0x6b2>
 8029034:	ec53 2b19 	vmov	r2, r3, d9
 8029038:	4913      	ldr	r1, [pc, #76]	; (8029088 <_dtoa_r+0x620>)
 802903a:	2000      	movs	r0, #0
 802903c:	f7d7 f93c 	bl	80002b8 <__aeabi_dsub>
 8029040:	4602      	mov	r2, r0
 8029042:	460b      	mov	r3, r1
 8029044:	4640      	mov	r0, r8
 8029046:	4649      	mov	r1, r9
 8029048:	f7d7 fd60 	bl	8000b0c <__aeabi_dcmplt>
 802904c:	2800      	cmp	r0, #0
 802904e:	f43f af2f 	beq.w	8028eb0 <_dtoa_r+0x448>
 8029052:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 8029054:	1e6b      	subs	r3, r5, #1
 8029056:	930f      	str	r3, [sp, #60]	; 0x3c
 8029058:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 802905c:	2b30      	cmp	r3, #48	; 0x30
 802905e:	d0f8      	beq.n	8029052 <_dtoa_r+0x5ea>
 8029060:	46bb      	mov	fp, r7
 8029062:	e049      	b.n	80290f8 <_dtoa_r+0x690>
 8029064:	4b05      	ldr	r3, [pc, #20]	; (802907c <_dtoa_r+0x614>)
 8029066:	f7d7 fadf 	bl	8000628 <__aeabi_dmul>
 802906a:	4680      	mov	r8, r0
 802906c:	4689      	mov	r9, r1
 802906e:	e7bd      	b.n	8028fec <_dtoa_r+0x584>
 8029070:	080376a0 	.word	0x080376a0
 8029074:	08037678 	.word	0x08037678
 8029078:	3ff00000 	.word	0x3ff00000
 802907c:	40240000 	.word	0x40240000
 8029080:	401c0000 	.word	0x401c0000
 8029084:	40140000 	.word	0x40140000
 8029088:	3fe00000 	.word	0x3fe00000
 802908c:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8029090:	9d00      	ldr	r5, [sp, #0]
 8029092:	4642      	mov	r2, r8
 8029094:	464b      	mov	r3, r9
 8029096:	4630      	mov	r0, r6
 8029098:	4639      	mov	r1, r7
 802909a:	f7d7 fbef 	bl	800087c <__aeabi_ddiv>
 802909e:	f7d7 fd73 	bl	8000b88 <__aeabi_d2iz>
 80290a2:	9001      	str	r0, [sp, #4]
 80290a4:	f7d7 fa56 	bl	8000554 <__aeabi_i2d>
 80290a8:	4642      	mov	r2, r8
 80290aa:	464b      	mov	r3, r9
 80290ac:	f7d7 fabc 	bl	8000628 <__aeabi_dmul>
 80290b0:	4602      	mov	r2, r0
 80290b2:	460b      	mov	r3, r1
 80290b4:	4630      	mov	r0, r6
 80290b6:	4639      	mov	r1, r7
 80290b8:	f7d7 f8fe 	bl	80002b8 <__aeabi_dsub>
 80290bc:	9e01      	ldr	r6, [sp, #4]
 80290be:	9f04      	ldr	r7, [sp, #16]
 80290c0:	3630      	adds	r6, #48	; 0x30
 80290c2:	f805 6b01 	strb.w	r6, [r5], #1
 80290c6:	9e00      	ldr	r6, [sp, #0]
 80290c8:	1bae      	subs	r6, r5, r6
 80290ca:	42b7      	cmp	r7, r6
 80290cc:	4602      	mov	r2, r0
 80290ce:	460b      	mov	r3, r1
 80290d0:	d134      	bne.n	802913c <_dtoa_r+0x6d4>
 80290d2:	f7d7 f8f3 	bl	80002bc <__adddf3>
 80290d6:	4642      	mov	r2, r8
 80290d8:	464b      	mov	r3, r9
 80290da:	4606      	mov	r6, r0
 80290dc:	460f      	mov	r7, r1
 80290de:	f7d7 fd33 	bl	8000b48 <__aeabi_dcmpgt>
 80290e2:	b9c8      	cbnz	r0, 8029118 <_dtoa_r+0x6b0>
 80290e4:	4642      	mov	r2, r8
 80290e6:	464b      	mov	r3, r9
 80290e8:	4630      	mov	r0, r6
 80290ea:	4639      	mov	r1, r7
 80290ec:	f7d7 fd04 	bl	8000af8 <__aeabi_dcmpeq>
 80290f0:	b110      	cbz	r0, 80290f8 <_dtoa_r+0x690>
 80290f2:	9b01      	ldr	r3, [sp, #4]
 80290f4:	07db      	lsls	r3, r3, #31
 80290f6:	d40f      	bmi.n	8029118 <_dtoa_r+0x6b0>
 80290f8:	4651      	mov	r1, sl
 80290fa:	4620      	mov	r0, r4
 80290fc:	f000 fac1 	bl	8029682 <_Bfree>
 8029100:	2300      	movs	r3, #0
 8029102:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8029104:	702b      	strb	r3, [r5, #0]
 8029106:	f10b 0301 	add.w	r3, fp, #1
 802910a:	6013      	str	r3, [r2, #0]
 802910c:	9b21      	ldr	r3, [sp, #132]	; 0x84
 802910e:	2b00      	cmp	r3, #0
 8029110:	f43f ace5 	beq.w	8028ade <_dtoa_r+0x76>
 8029114:	601d      	str	r5, [r3, #0]
 8029116:	e4e2      	b.n	8028ade <_dtoa_r+0x76>
 8029118:	465f      	mov	r7, fp
 802911a:	462b      	mov	r3, r5
 802911c:	461d      	mov	r5, r3
 802911e:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 8029122:	2a39      	cmp	r2, #57	; 0x39
 8029124:	d106      	bne.n	8029134 <_dtoa_r+0x6cc>
 8029126:	9a00      	ldr	r2, [sp, #0]
 8029128:	429a      	cmp	r2, r3
 802912a:	d1f7      	bne.n	802911c <_dtoa_r+0x6b4>
 802912c:	9900      	ldr	r1, [sp, #0]
 802912e:	2230      	movs	r2, #48	; 0x30
 8029130:	3701      	adds	r7, #1
 8029132:	700a      	strb	r2, [r1, #0]
 8029134:	781a      	ldrb	r2, [r3, #0]
 8029136:	3201      	adds	r2, #1
 8029138:	701a      	strb	r2, [r3, #0]
 802913a:	e791      	b.n	8029060 <_dtoa_r+0x5f8>
 802913c:	4ba3      	ldr	r3, [pc, #652]	; (80293cc <_dtoa_r+0x964>)
 802913e:	2200      	movs	r2, #0
 8029140:	f7d7 fa72 	bl	8000628 <__aeabi_dmul>
 8029144:	2200      	movs	r2, #0
 8029146:	2300      	movs	r3, #0
 8029148:	4606      	mov	r6, r0
 802914a:	460f      	mov	r7, r1
 802914c:	f7d7 fcd4 	bl	8000af8 <__aeabi_dcmpeq>
 8029150:	2800      	cmp	r0, #0
 8029152:	d09e      	beq.n	8029092 <_dtoa_r+0x62a>
 8029154:	e7d0      	b.n	80290f8 <_dtoa_r+0x690>
 8029156:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8029158:	2a00      	cmp	r2, #0
 802915a:	f000 80ca 	beq.w	80292f2 <_dtoa_r+0x88a>
 802915e:	9a07      	ldr	r2, [sp, #28]
 8029160:	2a01      	cmp	r2, #1
 8029162:	f300 80ad 	bgt.w	80292c0 <_dtoa_r+0x858>
 8029166:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 8029168:	2a00      	cmp	r2, #0
 802916a:	f000 80a5 	beq.w	80292b8 <_dtoa_r+0x850>
 802916e:	f203 4333 	addw	r3, r3, #1075	; 0x433
 8029172:	9e08      	ldr	r6, [sp, #32]
 8029174:	9d05      	ldr	r5, [sp, #20]
 8029176:	9a05      	ldr	r2, [sp, #20]
 8029178:	441a      	add	r2, r3
 802917a:	9205      	str	r2, [sp, #20]
 802917c:	9a06      	ldr	r2, [sp, #24]
 802917e:	2101      	movs	r1, #1
 8029180:	441a      	add	r2, r3
 8029182:	4620      	mov	r0, r4
 8029184:	9206      	str	r2, [sp, #24]
 8029186:	f000 fb19 	bl	80297bc <__i2b>
 802918a:	4607      	mov	r7, r0
 802918c:	b165      	cbz	r5, 80291a8 <_dtoa_r+0x740>
 802918e:	9b06      	ldr	r3, [sp, #24]
 8029190:	2b00      	cmp	r3, #0
 8029192:	dd09      	ble.n	80291a8 <_dtoa_r+0x740>
 8029194:	42ab      	cmp	r3, r5
 8029196:	9a05      	ldr	r2, [sp, #20]
 8029198:	bfa8      	it	ge
 802919a:	462b      	movge	r3, r5
 802919c:	1ad2      	subs	r2, r2, r3
 802919e:	9205      	str	r2, [sp, #20]
 80291a0:	9a06      	ldr	r2, [sp, #24]
 80291a2:	1aed      	subs	r5, r5, r3
 80291a4:	1ad3      	subs	r3, r2, r3
 80291a6:	9306      	str	r3, [sp, #24]
 80291a8:	9b08      	ldr	r3, [sp, #32]
 80291aa:	b1f3      	cbz	r3, 80291ea <_dtoa_r+0x782>
 80291ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80291ae:	2b00      	cmp	r3, #0
 80291b0:	f000 80a3 	beq.w	80292fa <_dtoa_r+0x892>
 80291b4:	2e00      	cmp	r6, #0
 80291b6:	dd10      	ble.n	80291da <_dtoa_r+0x772>
 80291b8:	4639      	mov	r1, r7
 80291ba:	4632      	mov	r2, r6
 80291bc:	4620      	mov	r0, r4
 80291be:	f000 fbbd 	bl	802993c <__pow5mult>
 80291c2:	4652      	mov	r2, sl
 80291c4:	4601      	mov	r1, r0
 80291c6:	4607      	mov	r7, r0
 80291c8:	4620      	mov	r0, r4
 80291ca:	f000 fb0d 	bl	80297e8 <__multiply>
 80291ce:	4651      	mov	r1, sl
 80291d0:	4680      	mov	r8, r0
 80291d2:	4620      	mov	r0, r4
 80291d4:	f000 fa55 	bl	8029682 <_Bfree>
 80291d8:	46c2      	mov	sl, r8
 80291da:	9b08      	ldr	r3, [sp, #32]
 80291dc:	1b9a      	subs	r2, r3, r6
 80291de:	d004      	beq.n	80291ea <_dtoa_r+0x782>
 80291e0:	4651      	mov	r1, sl
 80291e2:	4620      	mov	r0, r4
 80291e4:	f000 fbaa 	bl	802993c <__pow5mult>
 80291e8:	4682      	mov	sl, r0
 80291ea:	2101      	movs	r1, #1
 80291ec:	4620      	mov	r0, r4
 80291ee:	f000 fae5 	bl	80297bc <__i2b>
 80291f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80291f4:	2b00      	cmp	r3, #0
 80291f6:	4606      	mov	r6, r0
 80291f8:	f340 8081 	ble.w	80292fe <_dtoa_r+0x896>
 80291fc:	461a      	mov	r2, r3
 80291fe:	4601      	mov	r1, r0
 8029200:	4620      	mov	r0, r4
 8029202:	f000 fb9b 	bl	802993c <__pow5mult>
 8029206:	9b07      	ldr	r3, [sp, #28]
 8029208:	2b01      	cmp	r3, #1
 802920a:	4606      	mov	r6, r0
 802920c:	dd7a      	ble.n	8029304 <_dtoa_r+0x89c>
 802920e:	f04f 0800 	mov.w	r8, #0
 8029212:	6933      	ldr	r3, [r6, #16]
 8029214:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8029218:	6918      	ldr	r0, [r3, #16]
 802921a:	f000 fa81 	bl	8029720 <__hi0bits>
 802921e:	f1c0 0020 	rsb	r0, r0, #32
 8029222:	9b06      	ldr	r3, [sp, #24]
 8029224:	4418      	add	r0, r3
 8029226:	f010 001f 	ands.w	r0, r0, #31
 802922a:	f000 8094 	beq.w	8029356 <_dtoa_r+0x8ee>
 802922e:	f1c0 0320 	rsb	r3, r0, #32
 8029232:	2b04      	cmp	r3, #4
 8029234:	f340 8085 	ble.w	8029342 <_dtoa_r+0x8da>
 8029238:	9b05      	ldr	r3, [sp, #20]
 802923a:	f1c0 001c 	rsb	r0, r0, #28
 802923e:	4403      	add	r3, r0
 8029240:	9305      	str	r3, [sp, #20]
 8029242:	9b06      	ldr	r3, [sp, #24]
 8029244:	4403      	add	r3, r0
 8029246:	4405      	add	r5, r0
 8029248:	9306      	str	r3, [sp, #24]
 802924a:	9b05      	ldr	r3, [sp, #20]
 802924c:	2b00      	cmp	r3, #0
 802924e:	dd05      	ble.n	802925c <_dtoa_r+0x7f4>
 8029250:	4651      	mov	r1, sl
 8029252:	461a      	mov	r2, r3
 8029254:	4620      	mov	r0, r4
 8029256:	f000 fbb1 	bl	80299bc <__lshift>
 802925a:	4682      	mov	sl, r0
 802925c:	9b06      	ldr	r3, [sp, #24]
 802925e:	2b00      	cmp	r3, #0
 8029260:	dd05      	ble.n	802926e <_dtoa_r+0x806>
 8029262:	4631      	mov	r1, r6
 8029264:	461a      	mov	r2, r3
 8029266:	4620      	mov	r0, r4
 8029268:	f000 fba8 	bl	80299bc <__lshift>
 802926c:	4606      	mov	r6, r0
 802926e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8029270:	2b00      	cmp	r3, #0
 8029272:	d072      	beq.n	802935a <_dtoa_r+0x8f2>
 8029274:	4631      	mov	r1, r6
 8029276:	4650      	mov	r0, sl
 8029278:	f000 fc0c 	bl	8029a94 <__mcmp>
 802927c:	2800      	cmp	r0, #0
 802927e:	da6c      	bge.n	802935a <_dtoa_r+0x8f2>
 8029280:	2300      	movs	r3, #0
 8029282:	4651      	mov	r1, sl
 8029284:	220a      	movs	r2, #10
 8029286:	4620      	mov	r0, r4
 8029288:	f000 fa04 	bl	8029694 <__multadd>
 802928c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802928e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8029292:	4682      	mov	sl, r0
 8029294:	2b00      	cmp	r3, #0
 8029296:	f000 81af 	beq.w	80295f8 <_dtoa_r+0xb90>
 802929a:	2300      	movs	r3, #0
 802929c:	4639      	mov	r1, r7
 802929e:	220a      	movs	r2, #10
 80292a0:	4620      	mov	r0, r4
 80292a2:	f000 f9f7 	bl	8029694 <__multadd>
 80292a6:	9b01      	ldr	r3, [sp, #4]
 80292a8:	2b00      	cmp	r3, #0
 80292aa:	4607      	mov	r7, r0
 80292ac:	f300 8096 	bgt.w	80293dc <_dtoa_r+0x974>
 80292b0:	9b07      	ldr	r3, [sp, #28]
 80292b2:	2b02      	cmp	r3, #2
 80292b4:	dc59      	bgt.n	802936a <_dtoa_r+0x902>
 80292b6:	e091      	b.n	80293dc <_dtoa_r+0x974>
 80292b8:	9b10      	ldr	r3, [sp, #64]	; 0x40
 80292ba:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80292be:	e758      	b.n	8029172 <_dtoa_r+0x70a>
 80292c0:	9b04      	ldr	r3, [sp, #16]
 80292c2:	1e5e      	subs	r6, r3, #1
 80292c4:	9b08      	ldr	r3, [sp, #32]
 80292c6:	42b3      	cmp	r3, r6
 80292c8:	bfbf      	itttt	lt
 80292ca:	9b08      	ldrlt	r3, [sp, #32]
 80292cc:	9a0b      	ldrlt	r2, [sp, #44]	; 0x2c
 80292ce:	9608      	strlt	r6, [sp, #32]
 80292d0:	1af3      	sublt	r3, r6, r3
 80292d2:	bfb4      	ite	lt
 80292d4:	18d2      	addlt	r2, r2, r3
 80292d6:	1b9e      	subge	r6, r3, r6
 80292d8:	9b04      	ldr	r3, [sp, #16]
 80292da:	bfbc      	itt	lt
 80292dc:	920b      	strlt	r2, [sp, #44]	; 0x2c
 80292de:	2600      	movlt	r6, #0
 80292e0:	2b00      	cmp	r3, #0
 80292e2:	bfb7      	itett	lt
 80292e4:	e9dd 2304 	ldrdlt	r2, r3, [sp, #16]
 80292e8:	e9dd 3504 	ldrdge	r3, r5, [sp, #16]
 80292ec:	1a9d      	sublt	r5, r3, r2
 80292ee:	2300      	movlt	r3, #0
 80292f0:	e741      	b.n	8029176 <_dtoa_r+0x70e>
 80292f2:	9e08      	ldr	r6, [sp, #32]
 80292f4:	9d05      	ldr	r5, [sp, #20]
 80292f6:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80292f8:	e748      	b.n	802918c <_dtoa_r+0x724>
 80292fa:	9a08      	ldr	r2, [sp, #32]
 80292fc:	e770      	b.n	80291e0 <_dtoa_r+0x778>
 80292fe:	9b07      	ldr	r3, [sp, #28]
 8029300:	2b01      	cmp	r3, #1
 8029302:	dc19      	bgt.n	8029338 <_dtoa_r+0x8d0>
 8029304:	9b02      	ldr	r3, [sp, #8]
 8029306:	b9bb      	cbnz	r3, 8029338 <_dtoa_r+0x8d0>
 8029308:	9b03      	ldr	r3, [sp, #12]
 802930a:	f3c3 0313 	ubfx	r3, r3, #0, #20
 802930e:	b99b      	cbnz	r3, 8029338 <_dtoa_r+0x8d0>
 8029310:	9b03      	ldr	r3, [sp, #12]
 8029312:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8029316:	0d1b      	lsrs	r3, r3, #20
 8029318:	051b      	lsls	r3, r3, #20
 802931a:	b183      	cbz	r3, 802933e <_dtoa_r+0x8d6>
 802931c:	9b05      	ldr	r3, [sp, #20]
 802931e:	3301      	adds	r3, #1
 8029320:	9305      	str	r3, [sp, #20]
 8029322:	9b06      	ldr	r3, [sp, #24]
 8029324:	3301      	adds	r3, #1
 8029326:	9306      	str	r3, [sp, #24]
 8029328:	f04f 0801 	mov.w	r8, #1
 802932c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802932e:	2b00      	cmp	r3, #0
 8029330:	f47f af6f 	bne.w	8029212 <_dtoa_r+0x7aa>
 8029334:	2001      	movs	r0, #1
 8029336:	e774      	b.n	8029222 <_dtoa_r+0x7ba>
 8029338:	f04f 0800 	mov.w	r8, #0
 802933c:	e7f6      	b.n	802932c <_dtoa_r+0x8c4>
 802933e:	4698      	mov	r8, r3
 8029340:	e7f4      	b.n	802932c <_dtoa_r+0x8c4>
 8029342:	d082      	beq.n	802924a <_dtoa_r+0x7e2>
 8029344:	9a05      	ldr	r2, [sp, #20]
 8029346:	331c      	adds	r3, #28
 8029348:	441a      	add	r2, r3
 802934a:	9205      	str	r2, [sp, #20]
 802934c:	9a06      	ldr	r2, [sp, #24]
 802934e:	441a      	add	r2, r3
 8029350:	441d      	add	r5, r3
 8029352:	9206      	str	r2, [sp, #24]
 8029354:	e779      	b.n	802924a <_dtoa_r+0x7e2>
 8029356:	4603      	mov	r3, r0
 8029358:	e7f4      	b.n	8029344 <_dtoa_r+0x8dc>
 802935a:	9b04      	ldr	r3, [sp, #16]
 802935c:	2b00      	cmp	r3, #0
 802935e:	dc37      	bgt.n	80293d0 <_dtoa_r+0x968>
 8029360:	9b07      	ldr	r3, [sp, #28]
 8029362:	2b02      	cmp	r3, #2
 8029364:	dd34      	ble.n	80293d0 <_dtoa_r+0x968>
 8029366:	9b04      	ldr	r3, [sp, #16]
 8029368:	9301      	str	r3, [sp, #4]
 802936a:	9b01      	ldr	r3, [sp, #4]
 802936c:	b963      	cbnz	r3, 8029388 <_dtoa_r+0x920>
 802936e:	4631      	mov	r1, r6
 8029370:	2205      	movs	r2, #5
 8029372:	4620      	mov	r0, r4
 8029374:	f000 f98e 	bl	8029694 <__multadd>
 8029378:	4601      	mov	r1, r0
 802937a:	4606      	mov	r6, r0
 802937c:	4650      	mov	r0, sl
 802937e:	f000 fb89 	bl	8029a94 <__mcmp>
 8029382:	2800      	cmp	r0, #0
 8029384:	f73f adbc 	bgt.w	8028f00 <_dtoa_r+0x498>
 8029388:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 802938a:	9d00      	ldr	r5, [sp, #0]
 802938c:	ea6f 0b03 	mvn.w	fp, r3
 8029390:	f04f 0800 	mov.w	r8, #0
 8029394:	4631      	mov	r1, r6
 8029396:	4620      	mov	r0, r4
 8029398:	f000 f973 	bl	8029682 <_Bfree>
 802939c:	2f00      	cmp	r7, #0
 802939e:	f43f aeab 	beq.w	80290f8 <_dtoa_r+0x690>
 80293a2:	f1b8 0f00 	cmp.w	r8, #0
 80293a6:	d005      	beq.n	80293b4 <_dtoa_r+0x94c>
 80293a8:	45b8      	cmp	r8, r7
 80293aa:	d003      	beq.n	80293b4 <_dtoa_r+0x94c>
 80293ac:	4641      	mov	r1, r8
 80293ae:	4620      	mov	r0, r4
 80293b0:	f000 f967 	bl	8029682 <_Bfree>
 80293b4:	4639      	mov	r1, r7
 80293b6:	4620      	mov	r0, r4
 80293b8:	f000 f963 	bl	8029682 <_Bfree>
 80293bc:	e69c      	b.n	80290f8 <_dtoa_r+0x690>
 80293be:	2600      	movs	r6, #0
 80293c0:	4637      	mov	r7, r6
 80293c2:	e7e1      	b.n	8029388 <_dtoa_r+0x920>
 80293c4:	46bb      	mov	fp, r7
 80293c6:	4637      	mov	r7, r6
 80293c8:	e59a      	b.n	8028f00 <_dtoa_r+0x498>
 80293ca:	bf00      	nop
 80293cc:	40240000 	.word	0x40240000
 80293d0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80293d2:	2b00      	cmp	r3, #0
 80293d4:	f000 80c7 	beq.w	8029566 <_dtoa_r+0xafe>
 80293d8:	9b04      	ldr	r3, [sp, #16]
 80293da:	9301      	str	r3, [sp, #4]
 80293dc:	2d00      	cmp	r5, #0
 80293de:	dd05      	ble.n	80293ec <_dtoa_r+0x984>
 80293e0:	4639      	mov	r1, r7
 80293e2:	462a      	mov	r2, r5
 80293e4:	4620      	mov	r0, r4
 80293e6:	f000 fae9 	bl	80299bc <__lshift>
 80293ea:	4607      	mov	r7, r0
 80293ec:	f1b8 0f00 	cmp.w	r8, #0
 80293f0:	d05a      	beq.n	80294a8 <_dtoa_r+0xa40>
 80293f2:	6879      	ldr	r1, [r7, #4]
 80293f4:	4620      	mov	r0, r4
 80293f6:	f000 f91f 	bl	8029638 <_Balloc>
 80293fa:	4605      	mov	r5, r0
 80293fc:	b920      	cbnz	r0, 8029408 <_dtoa_r+0x9a0>
 80293fe:	4b82      	ldr	r3, [pc, #520]	; (8029608 <_dtoa_r+0xba0>)
 8029400:	4602      	mov	r2, r0
 8029402:	f240 21ef 	movw	r1, #751	; 0x2ef
 8029406:	e470      	b.n	8028cea <_dtoa_r+0x282>
 8029408:	693a      	ldr	r2, [r7, #16]
 802940a:	3202      	adds	r2, #2
 802940c:	0092      	lsls	r2, r2, #2
 802940e:	f107 010c 	add.w	r1, r7, #12
 8029412:	300c      	adds	r0, #12
 8029414:	f7fd fb68 	bl	8026ae8 <memcpy>
 8029418:	2201      	movs	r2, #1
 802941a:	4629      	mov	r1, r5
 802941c:	4620      	mov	r0, r4
 802941e:	f000 facd 	bl	80299bc <__lshift>
 8029422:	9b00      	ldr	r3, [sp, #0]
 8029424:	3301      	adds	r3, #1
 8029426:	9304      	str	r3, [sp, #16]
 8029428:	e9dd 2300 	ldrd	r2, r3, [sp]
 802942c:	4413      	add	r3, r2
 802942e:	9308      	str	r3, [sp, #32]
 8029430:	9b02      	ldr	r3, [sp, #8]
 8029432:	f003 0301 	and.w	r3, r3, #1
 8029436:	46b8      	mov	r8, r7
 8029438:	9306      	str	r3, [sp, #24]
 802943a:	4607      	mov	r7, r0
 802943c:	9b04      	ldr	r3, [sp, #16]
 802943e:	4631      	mov	r1, r6
 8029440:	3b01      	subs	r3, #1
 8029442:	4650      	mov	r0, sl
 8029444:	9301      	str	r3, [sp, #4]
 8029446:	f7ff fa85 	bl	8028954 <quorem>
 802944a:	4641      	mov	r1, r8
 802944c:	9002      	str	r0, [sp, #8]
 802944e:	f100 0930 	add.w	r9, r0, #48	; 0x30
 8029452:	4650      	mov	r0, sl
 8029454:	f000 fb1e 	bl	8029a94 <__mcmp>
 8029458:	463a      	mov	r2, r7
 802945a:	9005      	str	r0, [sp, #20]
 802945c:	4631      	mov	r1, r6
 802945e:	4620      	mov	r0, r4
 8029460:	f000 fb34 	bl	8029acc <__mdiff>
 8029464:	68c2      	ldr	r2, [r0, #12]
 8029466:	4605      	mov	r5, r0
 8029468:	bb02      	cbnz	r2, 80294ac <_dtoa_r+0xa44>
 802946a:	4601      	mov	r1, r0
 802946c:	4650      	mov	r0, sl
 802946e:	f000 fb11 	bl	8029a94 <__mcmp>
 8029472:	4602      	mov	r2, r0
 8029474:	4629      	mov	r1, r5
 8029476:	4620      	mov	r0, r4
 8029478:	9209      	str	r2, [sp, #36]	; 0x24
 802947a:	f000 f902 	bl	8029682 <_Bfree>
 802947e:	9b07      	ldr	r3, [sp, #28]
 8029480:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8029482:	9d04      	ldr	r5, [sp, #16]
 8029484:	ea43 0102 	orr.w	r1, r3, r2
 8029488:	9b06      	ldr	r3, [sp, #24]
 802948a:	4319      	orrs	r1, r3
 802948c:	d110      	bne.n	80294b0 <_dtoa_r+0xa48>
 802948e:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 8029492:	d029      	beq.n	80294e8 <_dtoa_r+0xa80>
 8029494:	9b05      	ldr	r3, [sp, #20]
 8029496:	2b00      	cmp	r3, #0
 8029498:	dd02      	ble.n	80294a0 <_dtoa_r+0xa38>
 802949a:	9b02      	ldr	r3, [sp, #8]
 802949c:	f103 0931 	add.w	r9, r3, #49	; 0x31
 80294a0:	9b01      	ldr	r3, [sp, #4]
 80294a2:	f883 9000 	strb.w	r9, [r3]
 80294a6:	e775      	b.n	8029394 <_dtoa_r+0x92c>
 80294a8:	4638      	mov	r0, r7
 80294aa:	e7ba      	b.n	8029422 <_dtoa_r+0x9ba>
 80294ac:	2201      	movs	r2, #1
 80294ae:	e7e1      	b.n	8029474 <_dtoa_r+0xa0c>
 80294b0:	9b05      	ldr	r3, [sp, #20]
 80294b2:	2b00      	cmp	r3, #0
 80294b4:	db04      	blt.n	80294c0 <_dtoa_r+0xa58>
 80294b6:	9907      	ldr	r1, [sp, #28]
 80294b8:	430b      	orrs	r3, r1
 80294ba:	9906      	ldr	r1, [sp, #24]
 80294bc:	430b      	orrs	r3, r1
 80294be:	d120      	bne.n	8029502 <_dtoa_r+0xa9a>
 80294c0:	2a00      	cmp	r2, #0
 80294c2:	dded      	ble.n	80294a0 <_dtoa_r+0xa38>
 80294c4:	4651      	mov	r1, sl
 80294c6:	2201      	movs	r2, #1
 80294c8:	4620      	mov	r0, r4
 80294ca:	f000 fa77 	bl	80299bc <__lshift>
 80294ce:	4631      	mov	r1, r6
 80294d0:	4682      	mov	sl, r0
 80294d2:	f000 fadf 	bl	8029a94 <__mcmp>
 80294d6:	2800      	cmp	r0, #0
 80294d8:	dc03      	bgt.n	80294e2 <_dtoa_r+0xa7a>
 80294da:	d1e1      	bne.n	80294a0 <_dtoa_r+0xa38>
 80294dc:	f019 0f01 	tst.w	r9, #1
 80294e0:	d0de      	beq.n	80294a0 <_dtoa_r+0xa38>
 80294e2:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 80294e6:	d1d8      	bne.n	802949a <_dtoa_r+0xa32>
 80294e8:	9a01      	ldr	r2, [sp, #4]
 80294ea:	2339      	movs	r3, #57	; 0x39
 80294ec:	7013      	strb	r3, [r2, #0]
 80294ee:	462b      	mov	r3, r5
 80294f0:	461d      	mov	r5, r3
 80294f2:	3b01      	subs	r3, #1
 80294f4:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 80294f8:	2a39      	cmp	r2, #57	; 0x39
 80294fa:	d06c      	beq.n	80295d6 <_dtoa_r+0xb6e>
 80294fc:	3201      	adds	r2, #1
 80294fe:	701a      	strb	r2, [r3, #0]
 8029500:	e748      	b.n	8029394 <_dtoa_r+0x92c>
 8029502:	2a00      	cmp	r2, #0
 8029504:	dd07      	ble.n	8029516 <_dtoa_r+0xaae>
 8029506:	f1b9 0f39 	cmp.w	r9, #57	; 0x39
 802950a:	d0ed      	beq.n	80294e8 <_dtoa_r+0xa80>
 802950c:	9a01      	ldr	r2, [sp, #4]
 802950e:	f109 0301 	add.w	r3, r9, #1
 8029512:	7013      	strb	r3, [r2, #0]
 8029514:	e73e      	b.n	8029394 <_dtoa_r+0x92c>
 8029516:	9b04      	ldr	r3, [sp, #16]
 8029518:	9a08      	ldr	r2, [sp, #32]
 802951a:	f803 9c01 	strb.w	r9, [r3, #-1]
 802951e:	4293      	cmp	r3, r2
 8029520:	d043      	beq.n	80295aa <_dtoa_r+0xb42>
 8029522:	4651      	mov	r1, sl
 8029524:	2300      	movs	r3, #0
 8029526:	220a      	movs	r2, #10
 8029528:	4620      	mov	r0, r4
 802952a:	f000 f8b3 	bl	8029694 <__multadd>
 802952e:	45b8      	cmp	r8, r7
 8029530:	4682      	mov	sl, r0
 8029532:	f04f 0300 	mov.w	r3, #0
 8029536:	f04f 020a 	mov.w	r2, #10
 802953a:	4641      	mov	r1, r8
 802953c:	4620      	mov	r0, r4
 802953e:	d107      	bne.n	8029550 <_dtoa_r+0xae8>
 8029540:	f000 f8a8 	bl	8029694 <__multadd>
 8029544:	4680      	mov	r8, r0
 8029546:	4607      	mov	r7, r0
 8029548:	9b04      	ldr	r3, [sp, #16]
 802954a:	3301      	adds	r3, #1
 802954c:	9304      	str	r3, [sp, #16]
 802954e:	e775      	b.n	802943c <_dtoa_r+0x9d4>
 8029550:	f000 f8a0 	bl	8029694 <__multadd>
 8029554:	4639      	mov	r1, r7
 8029556:	4680      	mov	r8, r0
 8029558:	2300      	movs	r3, #0
 802955a:	220a      	movs	r2, #10
 802955c:	4620      	mov	r0, r4
 802955e:	f000 f899 	bl	8029694 <__multadd>
 8029562:	4607      	mov	r7, r0
 8029564:	e7f0      	b.n	8029548 <_dtoa_r+0xae0>
 8029566:	9b04      	ldr	r3, [sp, #16]
 8029568:	9301      	str	r3, [sp, #4]
 802956a:	9d00      	ldr	r5, [sp, #0]
 802956c:	4631      	mov	r1, r6
 802956e:	4650      	mov	r0, sl
 8029570:	f7ff f9f0 	bl	8028954 <quorem>
 8029574:	f100 0930 	add.w	r9, r0, #48	; 0x30
 8029578:	9b00      	ldr	r3, [sp, #0]
 802957a:	f805 9b01 	strb.w	r9, [r5], #1
 802957e:	1aea      	subs	r2, r5, r3
 8029580:	9b01      	ldr	r3, [sp, #4]
 8029582:	4293      	cmp	r3, r2
 8029584:	dd07      	ble.n	8029596 <_dtoa_r+0xb2e>
 8029586:	4651      	mov	r1, sl
 8029588:	2300      	movs	r3, #0
 802958a:	220a      	movs	r2, #10
 802958c:	4620      	mov	r0, r4
 802958e:	f000 f881 	bl	8029694 <__multadd>
 8029592:	4682      	mov	sl, r0
 8029594:	e7ea      	b.n	802956c <_dtoa_r+0xb04>
 8029596:	9b01      	ldr	r3, [sp, #4]
 8029598:	2b00      	cmp	r3, #0
 802959a:	bfc8      	it	gt
 802959c:	461d      	movgt	r5, r3
 802959e:	9b00      	ldr	r3, [sp, #0]
 80295a0:	bfd8      	it	le
 80295a2:	2501      	movle	r5, #1
 80295a4:	441d      	add	r5, r3
 80295a6:	f04f 0800 	mov.w	r8, #0
 80295aa:	4651      	mov	r1, sl
 80295ac:	2201      	movs	r2, #1
 80295ae:	4620      	mov	r0, r4
 80295b0:	f000 fa04 	bl	80299bc <__lshift>
 80295b4:	4631      	mov	r1, r6
 80295b6:	4682      	mov	sl, r0
 80295b8:	f000 fa6c 	bl	8029a94 <__mcmp>
 80295bc:	2800      	cmp	r0, #0
 80295be:	dc96      	bgt.n	80294ee <_dtoa_r+0xa86>
 80295c0:	d102      	bne.n	80295c8 <_dtoa_r+0xb60>
 80295c2:	f019 0f01 	tst.w	r9, #1
 80295c6:	d192      	bne.n	80294ee <_dtoa_r+0xa86>
 80295c8:	462b      	mov	r3, r5
 80295ca:	461d      	mov	r5, r3
 80295cc:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 80295d0:	2a30      	cmp	r2, #48	; 0x30
 80295d2:	d0fa      	beq.n	80295ca <_dtoa_r+0xb62>
 80295d4:	e6de      	b.n	8029394 <_dtoa_r+0x92c>
 80295d6:	9a00      	ldr	r2, [sp, #0]
 80295d8:	429a      	cmp	r2, r3
 80295da:	d189      	bne.n	80294f0 <_dtoa_r+0xa88>
 80295dc:	f10b 0b01 	add.w	fp, fp, #1
 80295e0:	2331      	movs	r3, #49	; 0x31
 80295e2:	e796      	b.n	8029512 <_dtoa_r+0xaaa>
 80295e4:	4b09      	ldr	r3, [pc, #36]	; (802960c <_dtoa_r+0xba4>)
 80295e6:	f7ff ba9d 	b.w	8028b24 <_dtoa_r+0xbc>
 80295ea:	9b21      	ldr	r3, [sp, #132]	; 0x84
 80295ec:	2b00      	cmp	r3, #0
 80295ee:	f47f aa7c 	bne.w	8028aea <_dtoa_r+0x82>
 80295f2:	4b07      	ldr	r3, [pc, #28]	; (8029610 <_dtoa_r+0xba8>)
 80295f4:	f7ff ba96 	b.w	8028b24 <_dtoa_r+0xbc>
 80295f8:	9b01      	ldr	r3, [sp, #4]
 80295fa:	2b00      	cmp	r3, #0
 80295fc:	dcb5      	bgt.n	802956a <_dtoa_r+0xb02>
 80295fe:	9b07      	ldr	r3, [sp, #28]
 8029600:	2b02      	cmp	r3, #2
 8029602:	f73f aeb2 	bgt.w	802936a <_dtoa_r+0x902>
 8029606:	e7b0      	b.n	802956a <_dtoa_r+0xb02>
 8029608:	080375b0 	.word	0x080375b0
 802960c:	08037577 	.word	0x08037577
 8029610:	080375a3 	.word	0x080375a3

08029614 <__ascii_mbtowc>:
 8029614:	b082      	sub	sp, #8
 8029616:	b901      	cbnz	r1, 802961a <__ascii_mbtowc+0x6>
 8029618:	a901      	add	r1, sp, #4
 802961a:	b142      	cbz	r2, 802962e <__ascii_mbtowc+0x1a>
 802961c:	b14b      	cbz	r3, 8029632 <__ascii_mbtowc+0x1e>
 802961e:	7813      	ldrb	r3, [r2, #0]
 8029620:	600b      	str	r3, [r1, #0]
 8029622:	7812      	ldrb	r2, [r2, #0]
 8029624:	1e10      	subs	r0, r2, #0
 8029626:	bf18      	it	ne
 8029628:	2001      	movne	r0, #1
 802962a:	b002      	add	sp, #8
 802962c:	4770      	bx	lr
 802962e:	4610      	mov	r0, r2
 8029630:	e7fb      	b.n	802962a <__ascii_mbtowc+0x16>
 8029632:	f06f 0001 	mvn.w	r0, #1
 8029636:	e7f8      	b.n	802962a <__ascii_mbtowc+0x16>

08029638 <_Balloc>:
 8029638:	6c43      	ldr	r3, [r0, #68]	; 0x44
 802963a:	b570      	push	{r4, r5, r6, lr}
 802963c:	4605      	mov	r5, r0
 802963e:	460c      	mov	r4, r1
 8029640:	b17b      	cbz	r3, 8029662 <_Balloc+0x2a>
 8029642:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 8029644:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8029648:	b9a0      	cbnz	r0, 8029674 <_Balloc+0x3c>
 802964a:	2101      	movs	r1, #1
 802964c:	fa01 f604 	lsl.w	r6, r1, r4
 8029650:	1d72      	adds	r2, r6, #5
 8029652:	0092      	lsls	r2, r2, #2
 8029654:	4628      	mov	r0, r5
 8029656:	f000 fd87 	bl	802a168 <_calloc_r>
 802965a:	b148      	cbz	r0, 8029670 <_Balloc+0x38>
 802965c:	e9c0 4601 	strd	r4, r6, [r0, #4]
 8029660:	e00b      	b.n	802967a <_Balloc+0x42>
 8029662:	2221      	movs	r2, #33	; 0x21
 8029664:	2104      	movs	r1, #4
 8029666:	f000 fd7f 	bl	802a168 <_calloc_r>
 802966a:	6468      	str	r0, [r5, #68]	; 0x44
 802966c:	2800      	cmp	r0, #0
 802966e:	d1e8      	bne.n	8029642 <_Balloc+0xa>
 8029670:	2000      	movs	r0, #0
 8029672:	bd70      	pop	{r4, r5, r6, pc}
 8029674:	6802      	ldr	r2, [r0, #0]
 8029676:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 802967a:	2300      	movs	r3, #0
 802967c:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8029680:	e7f7      	b.n	8029672 <_Balloc+0x3a>

08029682 <_Bfree>:
 8029682:	b131      	cbz	r1, 8029692 <_Bfree+0x10>
 8029684:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8029686:	684a      	ldr	r2, [r1, #4]
 8029688:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 802968c:	6008      	str	r0, [r1, #0]
 802968e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 8029692:	4770      	bx	lr

08029694 <__multadd>:
 8029694:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8029698:	690d      	ldr	r5, [r1, #16]
 802969a:	4607      	mov	r7, r0
 802969c:	460c      	mov	r4, r1
 802969e:	461e      	mov	r6, r3
 80296a0:	f101 0c14 	add.w	ip, r1, #20
 80296a4:	2000      	movs	r0, #0
 80296a6:	f8dc 3000 	ldr.w	r3, [ip]
 80296aa:	b299      	uxth	r1, r3
 80296ac:	fb02 6101 	mla	r1, r2, r1, r6
 80296b0:	0c1e      	lsrs	r6, r3, #16
 80296b2:	0c0b      	lsrs	r3, r1, #16
 80296b4:	fb02 3306 	mla	r3, r2, r6, r3
 80296b8:	b289      	uxth	r1, r1
 80296ba:	3001      	adds	r0, #1
 80296bc:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 80296c0:	4285      	cmp	r5, r0
 80296c2:	f84c 1b04 	str.w	r1, [ip], #4
 80296c6:	ea4f 4613 	mov.w	r6, r3, lsr #16
 80296ca:	dcec      	bgt.n	80296a6 <__multadd+0x12>
 80296cc:	b30e      	cbz	r6, 8029712 <__multadd+0x7e>
 80296ce:	68a3      	ldr	r3, [r4, #8]
 80296d0:	42ab      	cmp	r3, r5
 80296d2:	dc19      	bgt.n	8029708 <__multadd+0x74>
 80296d4:	6861      	ldr	r1, [r4, #4]
 80296d6:	4638      	mov	r0, r7
 80296d8:	3101      	adds	r1, #1
 80296da:	f7ff ffad 	bl	8029638 <_Balloc>
 80296de:	4680      	mov	r8, r0
 80296e0:	b928      	cbnz	r0, 80296ee <__multadd+0x5a>
 80296e2:	4602      	mov	r2, r0
 80296e4:	4b0c      	ldr	r3, [pc, #48]	; (8029718 <__multadd+0x84>)
 80296e6:	480d      	ldr	r0, [pc, #52]	; (802971c <__multadd+0x88>)
 80296e8:	21ba      	movs	r1, #186	; 0xba
 80296ea:	f000 fd1f 	bl	802a12c <__assert_func>
 80296ee:	6922      	ldr	r2, [r4, #16]
 80296f0:	3202      	adds	r2, #2
 80296f2:	f104 010c 	add.w	r1, r4, #12
 80296f6:	0092      	lsls	r2, r2, #2
 80296f8:	300c      	adds	r0, #12
 80296fa:	f7fd f9f5 	bl	8026ae8 <memcpy>
 80296fe:	4621      	mov	r1, r4
 8029700:	4638      	mov	r0, r7
 8029702:	f7ff ffbe 	bl	8029682 <_Bfree>
 8029706:	4644      	mov	r4, r8
 8029708:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 802970c:	3501      	adds	r5, #1
 802970e:	615e      	str	r6, [r3, #20]
 8029710:	6125      	str	r5, [r4, #16]
 8029712:	4620      	mov	r0, r4
 8029714:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8029718:	080375b0 	.word	0x080375b0
 802971c:	08037619 	.word	0x08037619

08029720 <__hi0bits>:
 8029720:	0c03      	lsrs	r3, r0, #16
 8029722:	041b      	lsls	r3, r3, #16
 8029724:	b9d3      	cbnz	r3, 802975c <__hi0bits+0x3c>
 8029726:	0400      	lsls	r0, r0, #16
 8029728:	2310      	movs	r3, #16
 802972a:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 802972e:	bf04      	itt	eq
 8029730:	0200      	lsleq	r0, r0, #8
 8029732:	3308      	addeq	r3, #8
 8029734:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 8029738:	bf04      	itt	eq
 802973a:	0100      	lsleq	r0, r0, #4
 802973c:	3304      	addeq	r3, #4
 802973e:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 8029742:	bf04      	itt	eq
 8029744:	0080      	lsleq	r0, r0, #2
 8029746:	3302      	addeq	r3, #2
 8029748:	2800      	cmp	r0, #0
 802974a:	db05      	blt.n	8029758 <__hi0bits+0x38>
 802974c:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 8029750:	f103 0301 	add.w	r3, r3, #1
 8029754:	bf08      	it	eq
 8029756:	2320      	moveq	r3, #32
 8029758:	4618      	mov	r0, r3
 802975a:	4770      	bx	lr
 802975c:	2300      	movs	r3, #0
 802975e:	e7e4      	b.n	802972a <__hi0bits+0xa>

08029760 <__lo0bits>:
 8029760:	6803      	ldr	r3, [r0, #0]
 8029762:	f013 0207 	ands.w	r2, r3, #7
 8029766:	d00c      	beq.n	8029782 <__lo0bits+0x22>
 8029768:	07d9      	lsls	r1, r3, #31
 802976a:	d422      	bmi.n	80297b2 <__lo0bits+0x52>
 802976c:	079a      	lsls	r2, r3, #30
 802976e:	bf49      	itett	mi
 8029770:	085b      	lsrmi	r3, r3, #1
 8029772:	089b      	lsrpl	r3, r3, #2
 8029774:	6003      	strmi	r3, [r0, #0]
 8029776:	2201      	movmi	r2, #1
 8029778:	bf5c      	itt	pl
 802977a:	6003      	strpl	r3, [r0, #0]
 802977c:	2202      	movpl	r2, #2
 802977e:	4610      	mov	r0, r2
 8029780:	4770      	bx	lr
 8029782:	b299      	uxth	r1, r3
 8029784:	b909      	cbnz	r1, 802978a <__lo0bits+0x2a>
 8029786:	0c1b      	lsrs	r3, r3, #16
 8029788:	2210      	movs	r2, #16
 802978a:	b2d9      	uxtb	r1, r3
 802978c:	b909      	cbnz	r1, 8029792 <__lo0bits+0x32>
 802978e:	3208      	adds	r2, #8
 8029790:	0a1b      	lsrs	r3, r3, #8
 8029792:	0719      	lsls	r1, r3, #28
 8029794:	bf04      	itt	eq
 8029796:	091b      	lsreq	r3, r3, #4
 8029798:	3204      	addeq	r2, #4
 802979a:	0799      	lsls	r1, r3, #30
 802979c:	bf04      	itt	eq
 802979e:	089b      	lsreq	r3, r3, #2
 80297a0:	3202      	addeq	r2, #2
 80297a2:	07d9      	lsls	r1, r3, #31
 80297a4:	d403      	bmi.n	80297ae <__lo0bits+0x4e>
 80297a6:	085b      	lsrs	r3, r3, #1
 80297a8:	f102 0201 	add.w	r2, r2, #1
 80297ac:	d003      	beq.n	80297b6 <__lo0bits+0x56>
 80297ae:	6003      	str	r3, [r0, #0]
 80297b0:	e7e5      	b.n	802977e <__lo0bits+0x1e>
 80297b2:	2200      	movs	r2, #0
 80297b4:	e7e3      	b.n	802977e <__lo0bits+0x1e>
 80297b6:	2220      	movs	r2, #32
 80297b8:	e7e1      	b.n	802977e <__lo0bits+0x1e>
	...

080297bc <__i2b>:
 80297bc:	b510      	push	{r4, lr}
 80297be:	460c      	mov	r4, r1
 80297c0:	2101      	movs	r1, #1
 80297c2:	f7ff ff39 	bl	8029638 <_Balloc>
 80297c6:	4602      	mov	r2, r0
 80297c8:	b928      	cbnz	r0, 80297d6 <__i2b+0x1a>
 80297ca:	4b05      	ldr	r3, [pc, #20]	; (80297e0 <__i2b+0x24>)
 80297cc:	4805      	ldr	r0, [pc, #20]	; (80297e4 <__i2b+0x28>)
 80297ce:	f240 1145 	movw	r1, #325	; 0x145
 80297d2:	f000 fcab 	bl	802a12c <__assert_func>
 80297d6:	2301      	movs	r3, #1
 80297d8:	6144      	str	r4, [r0, #20]
 80297da:	6103      	str	r3, [r0, #16]
 80297dc:	bd10      	pop	{r4, pc}
 80297de:	bf00      	nop
 80297e0:	080375b0 	.word	0x080375b0
 80297e4:	08037619 	.word	0x08037619

080297e8 <__multiply>:
 80297e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80297ec:	4691      	mov	r9, r2
 80297ee:	690a      	ldr	r2, [r1, #16]
 80297f0:	f8d9 3010 	ldr.w	r3, [r9, #16]
 80297f4:	429a      	cmp	r2, r3
 80297f6:	bfb8      	it	lt
 80297f8:	460b      	movlt	r3, r1
 80297fa:	460c      	mov	r4, r1
 80297fc:	bfbc      	itt	lt
 80297fe:	464c      	movlt	r4, r9
 8029800:	4699      	movlt	r9, r3
 8029802:	6927      	ldr	r7, [r4, #16]
 8029804:	f8d9 a010 	ldr.w	sl, [r9, #16]
 8029808:	68a3      	ldr	r3, [r4, #8]
 802980a:	6861      	ldr	r1, [r4, #4]
 802980c:	eb07 060a 	add.w	r6, r7, sl
 8029810:	42b3      	cmp	r3, r6
 8029812:	b085      	sub	sp, #20
 8029814:	bfb8      	it	lt
 8029816:	3101      	addlt	r1, #1
 8029818:	f7ff ff0e 	bl	8029638 <_Balloc>
 802981c:	b930      	cbnz	r0, 802982c <__multiply+0x44>
 802981e:	4602      	mov	r2, r0
 8029820:	4b44      	ldr	r3, [pc, #272]	; (8029934 <__multiply+0x14c>)
 8029822:	4845      	ldr	r0, [pc, #276]	; (8029938 <__multiply+0x150>)
 8029824:	f44f 71b1 	mov.w	r1, #354	; 0x162
 8029828:	f000 fc80 	bl	802a12c <__assert_func>
 802982c:	f100 0514 	add.w	r5, r0, #20
 8029830:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 8029834:	462b      	mov	r3, r5
 8029836:	2200      	movs	r2, #0
 8029838:	4543      	cmp	r3, r8
 802983a:	d321      	bcc.n	8029880 <__multiply+0x98>
 802983c:	f104 0314 	add.w	r3, r4, #20
 8029840:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8029844:	f109 0314 	add.w	r3, r9, #20
 8029848:	eb03 028a 	add.w	r2, r3, sl, lsl #2
 802984c:	9202      	str	r2, [sp, #8]
 802984e:	1b3a      	subs	r2, r7, r4
 8029850:	3a15      	subs	r2, #21
 8029852:	f022 0203 	bic.w	r2, r2, #3
 8029856:	3204      	adds	r2, #4
 8029858:	f104 0115 	add.w	r1, r4, #21
 802985c:	428f      	cmp	r7, r1
 802985e:	bf38      	it	cc
 8029860:	2204      	movcc	r2, #4
 8029862:	9201      	str	r2, [sp, #4]
 8029864:	9a02      	ldr	r2, [sp, #8]
 8029866:	9303      	str	r3, [sp, #12]
 8029868:	429a      	cmp	r2, r3
 802986a:	d80c      	bhi.n	8029886 <__multiply+0x9e>
 802986c:	2e00      	cmp	r6, #0
 802986e:	dd03      	ble.n	8029878 <__multiply+0x90>
 8029870:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 8029874:	2b00      	cmp	r3, #0
 8029876:	d05b      	beq.n	8029930 <__multiply+0x148>
 8029878:	6106      	str	r6, [r0, #16]
 802987a:	b005      	add	sp, #20
 802987c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029880:	f843 2b04 	str.w	r2, [r3], #4
 8029884:	e7d8      	b.n	8029838 <__multiply+0x50>
 8029886:	f8b3 a000 	ldrh.w	sl, [r3]
 802988a:	f1ba 0f00 	cmp.w	sl, #0
 802988e:	d024      	beq.n	80298da <__multiply+0xf2>
 8029890:	f104 0e14 	add.w	lr, r4, #20
 8029894:	46a9      	mov	r9, r5
 8029896:	f04f 0c00 	mov.w	ip, #0
 802989a:	f85e 2b04 	ldr.w	r2, [lr], #4
 802989e:	f8d9 1000 	ldr.w	r1, [r9]
 80298a2:	fa1f fb82 	uxth.w	fp, r2
 80298a6:	b289      	uxth	r1, r1
 80298a8:	fb0a 110b 	mla	r1, sl, fp, r1
 80298ac:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 80298b0:	f8d9 2000 	ldr.w	r2, [r9]
 80298b4:	4461      	add	r1, ip
 80298b6:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 80298ba:	fb0a c20b 	mla	r2, sl, fp, ip
 80298be:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 80298c2:	b289      	uxth	r1, r1
 80298c4:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 80298c8:	4577      	cmp	r7, lr
 80298ca:	f849 1b04 	str.w	r1, [r9], #4
 80298ce:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 80298d2:	d8e2      	bhi.n	802989a <__multiply+0xb2>
 80298d4:	9a01      	ldr	r2, [sp, #4]
 80298d6:	f845 c002 	str.w	ip, [r5, r2]
 80298da:	9a03      	ldr	r2, [sp, #12]
 80298dc:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 80298e0:	3304      	adds	r3, #4
 80298e2:	f1b9 0f00 	cmp.w	r9, #0
 80298e6:	d021      	beq.n	802992c <__multiply+0x144>
 80298e8:	6829      	ldr	r1, [r5, #0]
 80298ea:	f104 0c14 	add.w	ip, r4, #20
 80298ee:	46ae      	mov	lr, r5
 80298f0:	f04f 0a00 	mov.w	sl, #0
 80298f4:	f8bc b000 	ldrh.w	fp, [ip]
 80298f8:	f8be 2002 	ldrh.w	r2, [lr, #2]
 80298fc:	fb09 220b 	mla	r2, r9, fp, r2
 8029900:	4452      	add	r2, sl
 8029902:	b289      	uxth	r1, r1
 8029904:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8029908:	f84e 1b04 	str.w	r1, [lr], #4
 802990c:	f85c 1b04 	ldr.w	r1, [ip], #4
 8029910:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 8029914:	f8be 1000 	ldrh.w	r1, [lr]
 8029918:	fb09 110a 	mla	r1, r9, sl, r1
 802991c:	eb01 4112 	add.w	r1, r1, r2, lsr #16
 8029920:	4567      	cmp	r7, ip
 8029922:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 8029926:	d8e5      	bhi.n	80298f4 <__multiply+0x10c>
 8029928:	9a01      	ldr	r2, [sp, #4]
 802992a:	50a9      	str	r1, [r5, r2]
 802992c:	3504      	adds	r5, #4
 802992e:	e799      	b.n	8029864 <__multiply+0x7c>
 8029930:	3e01      	subs	r6, #1
 8029932:	e79b      	b.n	802986c <__multiply+0x84>
 8029934:	080375b0 	.word	0x080375b0
 8029938:	08037619 	.word	0x08037619

0802993c <__pow5mult>:
 802993c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8029940:	4615      	mov	r5, r2
 8029942:	f012 0203 	ands.w	r2, r2, #3
 8029946:	4606      	mov	r6, r0
 8029948:	460f      	mov	r7, r1
 802994a:	d007      	beq.n	802995c <__pow5mult+0x20>
 802994c:	4c1a      	ldr	r4, [pc, #104]	; (80299b8 <__pow5mult+0x7c>)
 802994e:	3a01      	subs	r2, #1
 8029950:	2300      	movs	r3, #0
 8029952:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8029956:	f7ff fe9d 	bl	8029694 <__multadd>
 802995a:	4607      	mov	r7, r0
 802995c:	10ad      	asrs	r5, r5, #2
 802995e:	d027      	beq.n	80299b0 <__pow5mult+0x74>
 8029960:	6c34      	ldr	r4, [r6, #64]	; 0x40
 8029962:	b944      	cbnz	r4, 8029976 <__pow5mult+0x3a>
 8029964:	f240 2171 	movw	r1, #625	; 0x271
 8029968:	4630      	mov	r0, r6
 802996a:	f7ff ff27 	bl	80297bc <__i2b>
 802996e:	2300      	movs	r3, #0
 8029970:	6430      	str	r0, [r6, #64]	; 0x40
 8029972:	4604      	mov	r4, r0
 8029974:	6003      	str	r3, [r0, #0]
 8029976:	f04f 0900 	mov.w	r9, #0
 802997a:	07eb      	lsls	r3, r5, #31
 802997c:	d50a      	bpl.n	8029994 <__pow5mult+0x58>
 802997e:	4639      	mov	r1, r7
 8029980:	4622      	mov	r2, r4
 8029982:	4630      	mov	r0, r6
 8029984:	f7ff ff30 	bl	80297e8 <__multiply>
 8029988:	4639      	mov	r1, r7
 802998a:	4680      	mov	r8, r0
 802998c:	4630      	mov	r0, r6
 802998e:	f7ff fe78 	bl	8029682 <_Bfree>
 8029992:	4647      	mov	r7, r8
 8029994:	106d      	asrs	r5, r5, #1
 8029996:	d00b      	beq.n	80299b0 <__pow5mult+0x74>
 8029998:	6820      	ldr	r0, [r4, #0]
 802999a:	b938      	cbnz	r0, 80299ac <__pow5mult+0x70>
 802999c:	4622      	mov	r2, r4
 802999e:	4621      	mov	r1, r4
 80299a0:	4630      	mov	r0, r6
 80299a2:	f7ff ff21 	bl	80297e8 <__multiply>
 80299a6:	6020      	str	r0, [r4, #0]
 80299a8:	f8c0 9000 	str.w	r9, [r0]
 80299ac:	4604      	mov	r4, r0
 80299ae:	e7e4      	b.n	802997a <__pow5mult+0x3e>
 80299b0:	4638      	mov	r0, r7
 80299b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80299b6:	bf00      	nop
 80299b8:	08037768 	.word	0x08037768

080299bc <__lshift>:
 80299bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80299c0:	460c      	mov	r4, r1
 80299c2:	6849      	ldr	r1, [r1, #4]
 80299c4:	6923      	ldr	r3, [r4, #16]
 80299c6:	eb03 1862 	add.w	r8, r3, r2, asr #5
 80299ca:	68a3      	ldr	r3, [r4, #8]
 80299cc:	4607      	mov	r7, r0
 80299ce:	4691      	mov	r9, r2
 80299d0:	ea4f 1a62 	mov.w	sl, r2, asr #5
 80299d4:	f108 0601 	add.w	r6, r8, #1
 80299d8:	42b3      	cmp	r3, r6
 80299da:	db0b      	blt.n	80299f4 <__lshift+0x38>
 80299dc:	4638      	mov	r0, r7
 80299de:	f7ff fe2b 	bl	8029638 <_Balloc>
 80299e2:	4605      	mov	r5, r0
 80299e4:	b948      	cbnz	r0, 80299fa <__lshift+0x3e>
 80299e6:	4602      	mov	r2, r0
 80299e8:	4b28      	ldr	r3, [pc, #160]	; (8029a8c <__lshift+0xd0>)
 80299ea:	4829      	ldr	r0, [pc, #164]	; (8029a90 <__lshift+0xd4>)
 80299ec:	f44f 71ef 	mov.w	r1, #478	; 0x1de
 80299f0:	f000 fb9c 	bl	802a12c <__assert_func>
 80299f4:	3101      	adds	r1, #1
 80299f6:	005b      	lsls	r3, r3, #1
 80299f8:	e7ee      	b.n	80299d8 <__lshift+0x1c>
 80299fa:	2300      	movs	r3, #0
 80299fc:	f100 0114 	add.w	r1, r0, #20
 8029a00:	f100 0210 	add.w	r2, r0, #16
 8029a04:	4618      	mov	r0, r3
 8029a06:	4553      	cmp	r3, sl
 8029a08:	db33      	blt.n	8029a72 <__lshift+0xb6>
 8029a0a:	6920      	ldr	r0, [r4, #16]
 8029a0c:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 8029a10:	f104 0314 	add.w	r3, r4, #20
 8029a14:	f019 091f 	ands.w	r9, r9, #31
 8029a18:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8029a1c:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 8029a20:	d02b      	beq.n	8029a7a <__lshift+0xbe>
 8029a22:	f1c9 0e20 	rsb	lr, r9, #32
 8029a26:	468a      	mov	sl, r1
 8029a28:	2200      	movs	r2, #0
 8029a2a:	6818      	ldr	r0, [r3, #0]
 8029a2c:	fa00 f009 	lsl.w	r0, r0, r9
 8029a30:	4310      	orrs	r0, r2
 8029a32:	f84a 0b04 	str.w	r0, [sl], #4
 8029a36:	f853 2b04 	ldr.w	r2, [r3], #4
 8029a3a:	459c      	cmp	ip, r3
 8029a3c:	fa22 f20e 	lsr.w	r2, r2, lr
 8029a40:	d8f3      	bhi.n	8029a2a <__lshift+0x6e>
 8029a42:	ebac 0304 	sub.w	r3, ip, r4
 8029a46:	3b15      	subs	r3, #21
 8029a48:	f023 0303 	bic.w	r3, r3, #3
 8029a4c:	3304      	adds	r3, #4
 8029a4e:	f104 0015 	add.w	r0, r4, #21
 8029a52:	4584      	cmp	ip, r0
 8029a54:	bf38      	it	cc
 8029a56:	2304      	movcc	r3, #4
 8029a58:	50ca      	str	r2, [r1, r3]
 8029a5a:	b10a      	cbz	r2, 8029a60 <__lshift+0xa4>
 8029a5c:	f108 0602 	add.w	r6, r8, #2
 8029a60:	3e01      	subs	r6, #1
 8029a62:	4638      	mov	r0, r7
 8029a64:	612e      	str	r6, [r5, #16]
 8029a66:	4621      	mov	r1, r4
 8029a68:	f7ff fe0b 	bl	8029682 <_Bfree>
 8029a6c:	4628      	mov	r0, r5
 8029a6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8029a72:	f842 0f04 	str.w	r0, [r2, #4]!
 8029a76:	3301      	adds	r3, #1
 8029a78:	e7c5      	b.n	8029a06 <__lshift+0x4a>
 8029a7a:	3904      	subs	r1, #4
 8029a7c:	f853 2b04 	ldr.w	r2, [r3], #4
 8029a80:	f841 2f04 	str.w	r2, [r1, #4]!
 8029a84:	459c      	cmp	ip, r3
 8029a86:	d8f9      	bhi.n	8029a7c <__lshift+0xc0>
 8029a88:	e7ea      	b.n	8029a60 <__lshift+0xa4>
 8029a8a:	bf00      	nop
 8029a8c:	080375b0 	.word	0x080375b0
 8029a90:	08037619 	.word	0x08037619

08029a94 <__mcmp>:
 8029a94:	b530      	push	{r4, r5, lr}
 8029a96:	6902      	ldr	r2, [r0, #16]
 8029a98:	690c      	ldr	r4, [r1, #16]
 8029a9a:	1b12      	subs	r2, r2, r4
 8029a9c:	d10e      	bne.n	8029abc <__mcmp+0x28>
 8029a9e:	f100 0314 	add.w	r3, r0, #20
 8029aa2:	3114      	adds	r1, #20
 8029aa4:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 8029aa8:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 8029aac:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 8029ab0:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 8029ab4:	42a5      	cmp	r5, r4
 8029ab6:	d003      	beq.n	8029ac0 <__mcmp+0x2c>
 8029ab8:	d305      	bcc.n	8029ac6 <__mcmp+0x32>
 8029aba:	2201      	movs	r2, #1
 8029abc:	4610      	mov	r0, r2
 8029abe:	bd30      	pop	{r4, r5, pc}
 8029ac0:	4283      	cmp	r3, r0
 8029ac2:	d3f3      	bcc.n	8029aac <__mcmp+0x18>
 8029ac4:	e7fa      	b.n	8029abc <__mcmp+0x28>
 8029ac6:	f04f 32ff 	mov.w	r2, #4294967295
 8029aca:	e7f7      	b.n	8029abc <__mcmp+0x28>

08029acc <__mdiff>:
 8029acc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029ad0:	460c      	mov	r4, r1
 8029ad2:	4606      	mov	r6, r0
 8029ad4:	4611      	mov	r1, r2
 8029ad6:	4620      	mov	r0, r4
 8029ad8:	4690      	mov	r8, r2
 8029ada:	f7ff ffdb 	bl	8029a94 <__mcmp>
 8029ade:	1e05      	subs	r5, r0, #0
 8029ae0:	d110      	bne.n	8029b04 <__mdiff+0x38>
 8029ae2:	4629      	mov	r1, r5
 8029ae4:	4630      	mov	r0, r6
 8029ae6:	f7ff fda7 	bl	8029638 <_Balloc>
 8029aea:	b930      	cbnz	r0, 8029afa <__mdiff+0x2e>
 8029aec:	4b3a      	ldr	r3, [pc, #232]	; (8029bd8 <__mdiff+0x10c>)
 8029aee:	4602      	mov	r2, r0
 8029af0:	f240 2137 	movw	r1, #567	; 0x237
 8029af4:	4839      	ldr	r0, [pc, #228]	; (8029bdc <__mdiff+0x110>)
 8029af6:	f000 fb19 	bl	802a12c <__assert_func>
 8029afa:	2301      	movs	r3, #1
 8029afc:	e9c0 3504 	strd	r3, r5, [r0, #16]
 8029b00:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029b04:	bfa4      	itt	ge
 8029b06:	4643      	movge	r3, r8
 8029b08:	46a0      	movge	r8, r4
 8029b0a:	4630      	mov	r0, r6
 8029b0c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 8029b10:	bfa6      	itte	ge
 8029b12:	461c      	movge	r4, r3
 8029b14:	2500      	movge	r5, #0
 8029b16:	2501      	movlt	r5, #1
 8029b18:	f7ff fd8e 	bl	8029638 <_Balloc>
 8029b1c:	b920      	cbnz	r0, 8029b28 <__mdiff+0x5c>
 8029b1e:	4b2e      	ldr	r3, [pc, #184]	; (8029bd8 <__mdiff+0x10c>)
 8029b20:	4602      	mov	r2, r0
 8029b22:	f240 2145 	movw	r1, #581	; 0x245
 8029b26:	e7e5      	b.n	8029af4 <__mdiff+0x28>
 8029b28:	f8d8 7010 	ldr.w	r7, [r8, #16]
 8029b2c:	6926      	ldr	r6, [r4, #16]
 8029b2e:	60c5      	str	r5, [r0, #12]
 8029b30:	f104 0914 	add.w	r9, r4, #20
 8029b34:	f108 0514 	add.w	r5, r8, #20
 8029b38:	f100 0e14 	add.w	lr, r0, #20
 8029b3c:	eb05 0c87 	add.w	ip, r5, r7, lsl #2
 8029b40:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 8029b44:	f108 0210 	add.w	r2, r8, #16
 8029b48:	46f2      	mov	sl, lr
 8029b4a:	2100      	movs	r1, #0
 8029b4c:	f859 3b04 	ldr.w	r3, [r9], #4
 8029b50:	f852 bf04 	ldr.w	fp, [r2, #4]!
 8029b54:	fa11 f88b 	uxtah	r8, r1, fp
 8029b58:	b299      	uxth	r1, r3
 8029b5a:	0c1b      	lsrs	r3, r3, #16
 8029b5c:	eba8 0801 	sub.w	r8, r8, r1
 8029b60:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 8029b64:	eb03 4328 	add.w	r3, r3, r8, asr #16
 8029b68:	fa1f f888 	uxth.w	r8, r8
 8029b6c:	1419      	asrs	r1, r3, #16
 8029b6e:	454e      	cmp	r6, r9
 8029b70:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
 8029b74:	f84a 3b04 	str.w	r3, [sl], #4
 8029b78:	d8e8      	bhi.n	8029b4c <__mdiff+0x80>
 8029b7a:	1b33      	subs	r3, r6, r4
 8029b7c:	3b15      	subs	r3, #21
 8029b7e:	f023 0303 	bic.w	r3, r3, #3
 8029b82:	3304      	adds	r3, #4
 8029b84:	3415      	adds	r4, #21
 8029b86:	42a6      	cmp	r6, r4
 8029b88:	bf38      	it	cc
 8029b8a:	2304      	movcc	r3, #4
 8029b8c:	441d      	add	r5, r3
 8029b8e:	4473      	add	r3, lr
 8029b90:	469e      	mov	lr, r3
 8029b92:	462e      	mov	r6, r5
 8029b94:	4566      	cmp	r6, ip
 8029b96:	d30e      	bcc.n	8029bb6 <__mdiff+0xea>
 8029b98:	f10c 0203 	add.w	r2, ip, #3
 8029b9c:	1b52      	subs	r2, r2, r5
 8029b9e:	f022 0203 	bic.w	r2, r2, #3
 8029ba2:	3d03      	subs	r5, #3
 8029ba4:	45ac      	cmp	ip, r5
 8029ba6:	bf38      	it	cc
 8029ba8:	2200      	movcc	r2, #0
 8029baa:	4413      	add	r3, r2
 8029bac:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8029bb0:	b17a      	cbz	r2, 8029bd2 <__mdiff+0x106>
 8029bb2:	6107      	str	r7, [r0, #16]
 8029bb4:	e7a4      	b.n	8029b00 <__mdiff+0x34>
 8029bb6:	f856 8b04 	ldr.w	r8, [r6], #4
 8029bba:	fa11 f288 	uxtah	r2, r1, r8
 8029bbe:	1414      	asrs	r4, r2, #16
 8029bc0:	eb04 4418 	add.w	r4, r4, r8, lsr #16
 8029bc4:	b292      	uxth	r2, r2
 8029bc6:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
 8029bca:	f84e 2b04 	str.w	r2, [lr], #4
 8029bce:	1421      	asrs	r1, r4, #16
 8029bd0:	e7e0      	b.n	8029b94 <__mdiff+0xc8>
 8029bd2:	3f01      	subs	r7, #1
 8029bd4:	e7ea      	b.n	8029bac <__mdiff+0xe0>
 8029bd6:	bf00      	nop
 8029bd8:	080375b0 	.word	0x080375b0
 8029bdc:	08037619 	.word	0x08037619

08029be0 <__d2b>:
 8029be0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8029be4:	460f      	mov	r7, r1
 8029be6:	2101      	movs	r1, #1
 8029be8:	ec59 8b10 	vmov	r8, r9, d0
 8029bec:	4616      	mov	r6, r2
 8029bee:	f7ff fd23 	bl	8029638 <_Balloc>
 8029bf2:	4604      	mov	r4, r0
 8029bf4:	b930      	cbnz	r0, 8029c04 <__d2b+0x24>
 8029bf6:	4602      	mov	r2, r0
 8029bf8:	4b24      	ldr	r3, [pc, #144]	; (8029c8c <__d2b+0xac>)
 8029bfa:	4825      	ldr	r0, [pc, #148]	; (8029c90 <__d2b+0xb0>)
 8029bfc:	f240 310f 	movw	r1, #783	; 0x30f
 8029c00:	f000 fa94 	bl	802a12c <__assert_func>
 8029c04:	f3c9 550a 	ubfx	r5, r9, #20, #11
 8029c08:	f3c9 0313 	ubfx	r3, r9, #0, #20
 8029c0c:	bb2d      	cbnz	r5, 8029c5a <__d2b+0x7a>
 8029c0e:	9301      	str	r3, [sp, #4]
 8029c10:	f1b8 0300 	subs.w	r3, r8, #0
 8029c14:	d026      	beq.n	8029c64 <__d2b+0x84>
 8029c16:	4668      	mov	r0, sp
 8029c18:	9300      	str	r3, [sp, #0]
 8029c1a:	f7ff fda1 	bl	8029760 <__lo0bits>
 8029c1e:	e9dd 1200 	ldrd	r1, r2, [sp]
 8029c22:	b1e8      	cbz	r0, 8029c60 <__d2b+0x80>
 8029c24:	f1c0 0320 	rsb	r3, r0, #32
 8029c28:	fa02 f303 	lsl.w	r3, r2, r3
 8029c2c:	430b      	orrs	r3, r1
 8029c2e:	40c2      	lsrs	r2, r0
 8029c30:	6163      	str	r3, [r4, #20]
 8029c32:	9201      	str	r2, [sp, #4]
 8029c34:	9b01      	ldr	r3, [sp, #4]
 8029c36:	61a3      	str	r3, [r4, #24]
 8029c38:	2b00      	cmp	r3, #0
 8029c3a:	bf14      	ite	ne
 8029c3c:	2202      	movne	r2, #2
 8029c3e:	2201      	moveq	r2, #1
 8029c40:	6122      	str	r2, [r4, #16]
 8029c42:	b1bd      	cbz	r5, 8029c74 <__d2b+0x94>
 8029c44:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 8029c48:	4405      	add	r5, r0
 8029c4a:	603d      	str	r5, [r7, #0]
 8029c4c:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 8029c50:	6030      	str	r0, [r6, #0]
 8029c52:	4620      	mov	r0, r4
 8029c54:	b003      	add	sp, #12
 8029c56:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8029c5a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8029c5e:	e7d6      	b.n	8029c0e <__d2b+0x2e>
 8029c60:	6161      	str	r1, [r4, #20]
 8029c62:	e7e7      	b.n	8029c34 <__d2b+0x54>
 8029c64:	a801      	add	r0, sp, #4
 8029c66:	f7ff fd7b 	bl	8029760 <__lo0bits>
 8029c6a:	9b01      	ldr	r3, [sp, #4]
 8029c6c:	6163      	str	r3, [r4, #20]
 8029c6e:	3020      	adds	r0, #32
 8029c70:	2201      	movs	r2, #1
 8029c72:	e7e5      	b.n	8029c40 <__d2b+0x60>
 8029c74:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8029c78:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8029c7c:	6038      	str	r0, [r7, #0]
 8029c7e:	6918      	ldr	r0, [r3, #16]
 8029c80:	f7ff fd4e 	bl	8029720 <__hi0bits>
 8029c84:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 8029c88:	e7e2      	b.n	8029c50 <__d2b+0x70>
 8029c8a:	bf00      	nop
 8029c8c:	080375b0 	.word	0x080375b0
 8029c90:	08037619 	.word	0x08037619

08029c94 <_realloc_r>:
 8029c94:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029c98:	4682      	mov	sl, r0
 8029c9a:	460c      	mov	r4, r1
 8029c9c:	b929      	cbnz	r1, 8029caa <_realloc_r+0x16>
 8029c9e:	4611      	mov	r1, r2
 8029ca0:	b003      	add	sp, #12
 8029ca2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029ca6:	f7fd b851 	b.w	8026d4c <_malloc_r>
 8029caa:	9201      	str	r2, [sp, #4]
 8029cac:	f7fd fa88 	bl	80271c0 <__malloc_lock>
 8029cb0:	9a01      	ldr	r2, [sp, #4]
 8029cb2:	f854 5c04 	ldr.w	r5, [r4, #-4]
 8029cb6:	f102 080b 	add.w	r8, r2, #11
 8029cba:	f1b8 0f16 	cmp.w	r8, #22
 8029cbe:	d90b      	bls.n	8029cd8 <_realloc_r+0x44>
 8029cc0:	f038 0807 	bics.w	r8, r8, #7
 8029cc4:	d50a      	bpl.n	8029cdc <_realloc_r+0x48>
 8029cc6:	230c      	movs	r3, #12
 8029cc8:	f8ca 3000 	str.w	r3, [sl]
 8029ccc:	f04f 0b00 	mov.w	fp, #0
 8029cd0:	4658      	mov	r0, fp
 8029cd2:	b003      	add	sp, #12
 8029cd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8029cd8:	f04f 0810 	mov.w	r8, #16
 8029cdc:	4590      	cmp	r8, r2
 8029cde:	d3f2      	bcc.n	8029cc6 <_realloc_r+0x32>
 8029ce0:	f025 0603 	bic.w	r6, r5, #3
 8029ce4:	45b0      	cmp	r8, r6
 8029ce6:	f1a4 0908 	sub.w	r9, r4, #8
 8029cea:	f340 8170 	ble.w	8029fce <_realloc_r+0x33a>
 8029cee:	499c      	ldr	r1, [pc, #624]	; (8029f60 <_realloc_r+0x2cc>)
 8029cf0:	f8d1 c008 	ldr.w	ip, [r1, #8]
 8029cf4:	eb09 0306 	add.w	r3, r9, r6
 8029cf8:	459c      	cmp	ip, r3
 8029cfa:	6859      	ldr	r1, [r3, #4]
 8029cfc:	d005      	beq.n	8029d0a <_realloc_r+0x76>
 8029cfe:	f021 0001 	bic.w	r0, r1, #1
 8029d02:	4418      	add	r0, r3
 8029d04:	6840      	ldr	r0, [r0, #4]
 8029d06:	07c7      	lsls	r7, r0, #31
 8029d08:	d447      	bmi.n	8029d9a <_realloc_r+0x106>
 8029d0a:	f021 0103 	bic.w	r1, r1, #3
 8029d0e:	459c      	cmp	ip, r3
 8029d10:	eb06 0701 	add.w	r7, r6, r1
 8029d14:	d119      	bne.n	8029d4a <_realloc_r+0xb6>
 8029d16:	f108 0010 	add.w	r0, r8, #16
 8029d1a:	42b8      	cmp	r0, r7
 8029d1c:	dc3f      	bgt.n	8029d9e <_realloc_r+0x10a>
 8029d1e:	eb09 0308 	add.w	r3, r9, r8
 8029d22:	4a8f      	ldr	r2, [pc, #572]	; (8029f60 <_realloc_r+0x2cc>)
 8029d24:	eba7 0708 	sub.w	r7, r7, r8
 8029d28:	f047 0701 	orr.w	r7, r7, #1
 8029d2c:	6093      	str	r3, [r2, #8]
 8029d2e:	605f      	str	r7, [r3, #4]
 8029d30:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8029d34:	f003 0301 	and.w	r3, r3, #1
 8029d38:	ea43 0308 	orr.w	r3, r3, r8
 8029d3c:	f844 3c04 	str.w	r3, [r4, #-4]
 8029d40:	4650      	mov	r0, sl
 8029d42:	f7fd fa43 	bl	80271cc <__malloc_unlock>
 8029d46:	46a3      	mov	fp, r4
 8029d48:	e7c2      	b.n	8029cd0 <_realloc_r+0x3c>
 8029d4a:	45b8      	cmp	r8, r7
 8029d4c:	dc27      	bgt.n	8029d9e <_realloc_r+0x10a>
 8029d4e:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8029d52:	60da      	str	r2, [r3, #12]
 8029d54:	6093      	str	r3, [r2, #8]
 8029d56:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8029d5a:	eba7 0008 	sub.w	r0, r7, r8
 8029d5e:	280f      	cmp	r0, #15
 8029d60:	f003 0301 	and.w	r3, r3, #1
 8029d64:	eb09 0207 	add.w	r2, r9, r7
 8029d68:	f240 8133 	bls.w	8029fd2 <_realloc_r+0x33e>
 8029d6c:	eb09 0108 	add.w	r1, r9, r8
 8029d70:	ea48 0303 	orr.w	r3, r8, r3
 8029d74:	f040 0001 	orr.w	r0, r0, #1
 8029d78:	f8c9 3004 	str.w	r3, [r9, #4]
 8029d7c:	6048      	str	r0, [r1, #4]
 8029d7e:	6853      	ldr	r3, [r2, #4]
 8029d80:	f043 0301 	orr.w	r3, r3, #1
 8029d84:	6053      	str	r3, [r2, #4]
 8029d86:	3108      	adds	r1, #8
 8029d88:	4650      	mov	r0, sl
 8029d8a:	f7fc ff1f 	bl	8026bcc <_free_r>
 8029d8e:	4650      	mov	r0, sl
 8029d90:	f7fd fa1c 	bl	80271cc <__malloc_unlock>
 8029d94:	f109 0b08 	add.w	fp, r9, #8
 8029d98:	e79a      	b.n	8029cd0 <_realloc_r+0x3c>
 8029d9a:	2100      	movs	r1, #0
 8029d9c:	460b      	mov	r3, r1
 8029d9e:	07e8      	lsls	r0, r5, #31
 8029da0:	f100 80c6 	bmi.w	8029f30 <_realloc_r+0x29c>
 8029da4:	f854 5c08 	ldr.w	r5, [r4, #-8]
 8029da8:	eba9 0505 	sub.w	r5, r9, r5
 8029dac:	6868      	ldr	r0, [r5, #4]
 8029dae:	f020 0003 	bic.w	r0, r0, #3
 8029db2:	eb00 0b06 	add.w	fp, r0, r6
 8029db6:	2b00      	cmp	r3, #0
 8029db8:	f000 8086 	beq.w	8029ec8 <_realloc_r+0x234>
 8029dbc:	459c      	cmp	ip, r3
 8029dbe:	eb01 070b 	add.w	r7, r1, fp
 8029dc2:	d149      	bne.n	8029e58 <_realloc_r+0x1c4>
 8029dc4:	f108 0310 	add.w	r3, r8, #16
 8029dc8:	42bb      	cmp	r3, r7
 8029dca:	dc7d      	bgt.n	8029ec8 <_realloc_r+0x234>
 8029dcc:	46ab      	mov	fp, r5
 8029dce:	68eb      	ldr	r3, [r5, #12]
 8029dd0:	f85b 2f08 	ldr.w	r2, [fp, #8]!
 8029dd4:	60d3      	str	r3, [r2, #12]
 8029dd6:	609a      	str	r2, [r3, #8]
 8029dd8:	1f32      	subs	r2, r6, #4
 8029dda:	2a24      	cmp	r2, #36	; 0x24
 8029ddc:	d837      	bhi.n	8029e4e <_realloc_r+0x1ba>
 8029dde:	2a13      	cmp	r2, #19
 8029de0:	d933      	bls.n	8029e4a <_realloc_r+0x1b6>
 8029de2:	6823      	ldr	r3, [r4, #0]
 8029de4:	60ab      	str	r3, [r5, #8]
 8029de6:	6863      	ldr	r3, [r4, #4]
 8029de8:	60eb      	str	r3, [r5, #12]
 8029dea:	2a1b      	cmp	r2, #27
 8029dec:	d81b      	bhi.n	8029e26 <_realloc_r+0x192>
 8029dee:	3408      	adds	r4, #8
 8029df0:	f105 0310 	add.w	r3, r5, #16
 8029df4:	6822      	ldr	r2, [r4, #0]
 8029df6:	601a      	str	r2, [r3, #0]
 8029df8:	6862      	ldr	r2, [r4, #4]
 8029dfa:	605a      	str	r2, [r3, #4]
 8029dfc:	68a2      	ldr	r2, [r4, #8]
 8029dfe:	609a      	str	r2, [r3, #8]
 8029e00:	eb05 0308 	add.w	r3, r5, r8
 8029e04:	4a56      	ldr	r2, [pc, #344]	; (8029f60 <_realloc_r+0x2cc>)
 8029e06:	eba7 0708 	sub.w	r7, r7, r8
 8029e0a:	f047 0701 	orr.w	r7, r7, #1
 8029e0e:	6093      	str	r3, [r2, #8]
 8029e10:	605f      	str	r7, [r3, #4]
 8029e12:	686b      	ldr	r3, [r5, #4]
 8029e14:	f003 0301 	and.w	r3, r3, #1
 8029e18:	ea43 0308 	orr.w	r3, r3, r8
 8029e1c:	606b      	str	r3, [r5, #4]
 8029e1e:	4650      	mov	r0, sl
 8029e20:	f7fd f9d4 	bl	80271cc <__malloc_unlock>
 8029e24:	e754      	b.n	8029cd0 <_realloc_r+0x3c>
 8029e26:	68a3      	ldr	r3, [r4, #8]
 8029e28:	612b      	str	r3, [r5, #16]
 8029e2a:	68e3      	ldr	r3, [r4, #12]
 8029e2c:	616b      	str	r3, [r5, #20]
 8029e2e:	2a24      	cmp	r2, #36	; 0x24
 8029e30:	bf01      	itttt	eq
 8029e32:	6923      	ldreq	r3, [r4, #16]
 8029e34:	61ab      	streq	r3, [r5, #24]
 8029e36:	6962      	ldreq	r2, [r4, #20]
 8029e38:	61ea      	streq	r2, [r5, #28]
 8029e3a:	bf19      	ittee	ne
 8029e3c:	3410      	addne	r4, #16
 8029e3e:	f105 0318 	addne.w	r3, r5, #24
 8029e42:	f105 0320 	addeq.w	r3, r5, #32
 8029e46:	3418      	addeq	r4, #24
 8029e48:	e7d4      	b.n	8029df4 <_realloc_r+0x160>
 8029e4a:	465b      	mov	r3, fp
 8029e4c:	e7d2      	b.n	8029df4 <_realloc_r+0x160>
 8029e4e:	4621      	mov	r1, r4
 8029e50:	4658      	mov	r0, fp
 8029e52:	f000 f951 	bl	802a0f8 <memmove>
 8029e56:	e7d3      	b.n	8029e00 <_realloc_r+0x16c>
 8029e58:	45b8      	cmp	r8, r7
 8029e5a:	dc35      	bgt.n	8029ec8 <_realloc_r+0x234>
 8029e5c:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
 8029e60:	4628      	mov	r0, r5
 8029e62:	60da      	str	r2, [r3, #12]
 8029e64:	6093      	str	r3, [r2, #8]
 8029e66:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8029e6a:	68eb      	ldr	r3, [r5, #12]
 8029e6c:	60d3      	str	r3, [r2, #12]
 8029e6e:	609a      	str	r2, [r3, #8]
 8029e70:	1f32      	subs	r2, r6, #4
 8029e72:	2a24      	cmp	r2, #36	; 0x24
 8029e74:	d824      	bhi.n	8029ec0 <_realloc_r+0x22c>
 8029e76:	2a13      	cmp	r2, #19
 8029e78:	d908      	bls.n	8029e8c <_realloc_r+0x1f8>
 8029e7a:	6823      	ldr	r3, [r4, #0]
 8029e7c:	60ab      	str	r3, [r5, #8]
 8029e7e:	6863      	ldr	r3, [r4, #4]
 8029e80:	60eb      	str	r3, [r5, #12]
 8029e82:	2a1b      	cmp	r2, #27
 8029e84:	d80a      	bhi.n	8029e9c <_realloc_r+0x208>
 8029e86:	3408      	adds	r4, #8
 8029e88:	f105 0010 	add.w	r0, r5, #16
 8029e8c:	6823      	ldr	r3, [r4, #0]
 8029e8e:	6003      	str	r3, [r0, #0]
 8029e90:	6863      	ldr	r3, [r4, #4]
 8029e92:	6043      	str	r3, [r0, #4]
 8029e94:	68a3      	ldr	r3, [r4, #8]
 8029e96:	6083      	str	r3, [r0, #8]
 8029e98:	46a9      	mov	r9, r5
 8029e9a:	e75c      	b.n	8029d56 <_realloc_r+0xc2>
 8029e9c:	68a3      	ldr	r3, [r4, #8]
 8029e9e:	612b      	str	r3, [r5, #16]
 8029ea0:	68e3      	ldr	r3, [r4, #12]
 8029ea2:	616b      	str	r3, [r5, #20]
 8029ea4:	2a24      	cmp	r2, #36	; 0x24
 8029ea6:	bf01      	itttt	eq
 8029ea8:	6923      	ldreq	r3, [r4, #16]
 8029eaa:	61ab      	streq	r3, [r5, #24]
 8029eac:	6963      	ldreq	r3, [r4, #20]
 8029eae:	61eb      	streq	r3, [r5, #28]
 8029eb0:	bf19      	ittee	ne
 8029eb2:	3410      	addne	r4, #16
 8029eb4:	f105 0018 	addne.w	r0, r5, #24
 8029eb8:	f105 0020 	addeq.w	r0, r5, #32
 8029ebc:	3418      	addeq	r4, #24
 8029ebe:	e7e5      	b.n	8029e8c <_realloc_r+0x1f8>
 8029ec0:	4621      	mov	r1, r4
 8029ec2:	f000 f919 	bl	802a0f8 <memmove>
 8029ec6:	e7e7      	b.n	8029e98 <_realloc_r+0x204>
 8029ec8:	45d8      	cmp	r8, fp
 8029eca:	dc31      	bgt.n	8029f30 <_realloc_r+0x29c>
 8029ecc:	4628      	mov	r0, r5
 8029ece:	68eb      	ldr	r3, [r5, #12]
 8029ed0:	f850 2f08 	ldr.w	r2, [r0, #8]!
 8029ed4:	60d3      	str	r3, [r2, #12]
 8029ed6:	609a      	str	r2, [r3, #8]
 8029ed8:	1f32      	subs	r2, r6, #4
 8029eda:	2a24      	cmp	r2, #36	; 0x24
 8029edc:	d824      	bhi.n	8029f28 <_realloc_r+0x294>
 8029ede:	2a13      	cmp	r2, #19
 8029ee0:	d908      	bls.n	8029ef4 <_realloc_r+0x260>
 8029ee2:	6823      	ldr	r3, [r4, #0]
 8029ee4:	60ab      	str	r3, [r5, #8]
 8029ee6:	6863      	ldr	r3, [r4, #4]
 8029ee8:	60eb      	str	r3, [r5, #12]
 8029eea:	2a1b      	cmp	r2, #27
 8029eec:	d80a      	bhi.n	8029f04 <_realloc_r+0x270>
 8029eee:	3408      	adds	r4, #8
 8029ef0:	f105 0010 	add.w	r0, r5, #16
 8029ef4:	6823      	ldr	r3, [r4, #0]
 8029ef6:	6003      	str	r3, [r0, #0]
 8029ef8:	6863      	ldr	r3, [r4, #4]
 8029efa:	6043      	str	r3, [r0, #4]
 8029efc:	68a3      	ldr	r3, [r4, #8]
 8029efe:	6083      	str	r3, [r0, #8]
 8029f00:	465f      	mov	r7, fp
 8029f02:	e7c9      	b.n	8029e98 <_realloc_r+0x204>
 8029f04:	68a3      	ldr	r3, [r4, #8]
 8029f06:	612b      	str	r3, [r5, #16]
 8029f08:	68e3      	ldr	r3, [r4, #12]
 8029f0a:	616b      	str	r3, [r5, #20]
 8029f0c:	2a24      	cmp	r2, #36	; 0x24
 8029f0e:	bf01      	itttt	eq
 8029f10:	6923      	ldreq	r3, [r4, #16]
 8029f12:	61ab      	streq	r3, [r5, #24]
 8029f14:	6963      	ldreq	r3, [r4, #20]
 8029f16:	61eb      	streq	r3, [r5, #28]
 8029f18:	bf19      	ittee	ne
 8029f1a:	3410      	addne	r4, #16
 8029f1c:	f105 0018 	addne.w	r0, r5, #24
 8029f20:	f105 0020 	addeq.w	r0, r5, #32
 8029f24:	3418      	addeq	r4, #24
 8029f26:	e7e5      	b.n	8029ef4 <_realloc_r+0x260>
 8029f28:	4621      	mov	r1, r4
 8029f2a:	f000 f8e5 	bl	802a0f8 <memmove>
 8029f2e:	e7e7      	b.n	8029f00 <_realloc_r+0x26c>
 8029f30:	4611      	mov	r1, r2
 8029f32:	4650      	mov	r0, sl
 8029f34:	f7fc ff0a 	bl	8026d4c <_malloc_r>
 8029f38:	4683      	mov	fp, r0
 8029f3a:	2800      	cmp	r0, #0
 8029f3c:	f43f af6f 	beq.w	8029e1e <_realloc_r+0x18a>
 8029f40:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8029f44:	f023 0301 	bic.w	r3, r3, #1
 8029f48:	444b      	add	r3, r9
 8029f4a:	f1a0 0208 	sub.w	r2, r0, #8
 8029f4e:	4293      	cmp	r3, r2
 8029f50:	d108      	bne.n	8029f64 <_realloc_r+0x2d0>
 8029f52:	f850 7c04 	ldr.w	r7, [r0, #-4]
 8029f56:	f027 0703 	bic.w	r7, r7, #3
 8029f5a:	4437      	add	r7, r6
 8029f5c:	e6fb      	b.n	8029d56 <_realloc_r+0xc2>
 8029f5e:	bf00      	nop
 8029f60:	20000388 	.word	0x20000388
 8029f64:	1f32      	subs	r2, r6, #4
 8029f66:	2a24      	cmp	r2, #36	; 0x24
 8029f68:	d82d      	bhi.n	8029fc6 <_realloc_r+0x332>
 8029f6a:	2a13      	cmp	r2, #19
 8029f6c:	d928      	bls.n	8029fc0 <_realloc_r+0x32c>
 8029f6e:	6823      	ldr	r3, [r4, #0]
 8029f70:	6003      	str	r3, [r0, #0]
 8029f72:	6863      	ldr	r3, [r4, #4]
 8029f74:	6043      	str	r3, [r0, #4]
 8029f76:	2a1b      	cmp	r2, #27
 8029f78:	d80e      	bhi.n	8029f98 <_realloc_r+0x304>
 8029f7a:	f104 0208 	add.w	r2, r4, #8
 8029f7e:	f100 0308 	add.w	r3, r0, #8
 8029f82:	6811      	ldr	r1, [r2, #0]
 8029f84:	6019      	str	r1, [r3, #0]
 8029f86:	6851      	ldr	r1, [r2, #4]
 8029f88:	6059      	str	r1, [r3, #4]
 8029f8a:	6892      	ldr	r2, [r2, #8]
 8029f8c:	609a      	str	r2, [r3, #8]
 8029f8e:	4621      	mov	r1, r4
 8029f90:	4650      	mov	r0, sl
 8029f92:	f7fc fe1b 	bl	8026bcc <_free_r>
 8029f96:	e742      	b.n	8029e1e <_realloc_r+0x18a>
 8029f98:	68a3      	ldr	r3, [r4, #8]
 8029f9a:	6083      	str	r3, [r0, #8]
 8029f9c:	68e3      	ldr	r3, [r4, #12]
 8029f9e:	60c3      	str	r3, [r0, #12]
 8029fa0:	2a24      	cmp	r2, #36	; 0x24
 8029fa2:	bf01      	itttt	eq
 8029fa4:	6923      	ldreq	r3, [r4, #16]
 8029fa6:	6103      	streq	r3, [r0, #16]
 8029fa8:	6961      	ldreq	r1, [r4, #20]
 8029faa:	6141      	streq	r1, [r0, #20]
 8029fac:	bf19      	ittee	ne
 8029fae:	f104 0210 	addne.w	r2, r4, #16
 8029fb2:	f100 0310 	addne.w	r3, r0, #16
 8029fb6:	f104 0218 	addeq.w	r2, r4, #24
 8029fba:	f100 0318 	addeq.w	r3, r0, #24
 8029fbe:	e7e0      	b.n	8029f82 <_realloc_r+0x2ee>
 8029fc0:	4603      	mov	r3, r0
 8029fc2:	4622      	mov	r2, r4
 8029fc4:	e7dd      	b.n	8029f82 <_realloc_r+0x2ee>
 8029fc6:	4621      	mov	r1, r4
 8029fc8:	f000 f896 	bl	802a0f8 <memmove>
 8029fcc:	e7df      	b.n	8029f8e <_realloc_r+0x2fa>
 8029fce:	4637      	mov	r7, r6
 8029fd0:	e6c1      	b.n	8029d56 <_realloc_r+0xc2>
 8029fd2:	431f      	orrs	r7, r3
 8029fd4:	f8c9 7004 	str.w	r7, [r9, #4]
 8029fd8:	6853      	ldr	r3, [r2, #4]
 8029fda:	f043 0301 	orr.w	r3, r3, #1
 8029fde:	6053      	str	r3, [r2, #4]
 8029fe0:	e6d5      	b.n	8029d8e <_realloc_r+0xfa>
 8029fe2:	bf00      	nop

08029fe4 <__ascii_wctomb>:
 8029fe4:	b149      	cbz	r1, 8029ffa <__ascii_wctomb+0x16>
 8029fe6:	2aff      	cmp	r2, #255	; 0xff
 8029fe8:	bf85      	ittet	hi
 8029fea:	238a      	movhi	r3, #138	; 0x8a
 8029fec:	6003      	strhi	r3, [r0, #0]
 8029fee:	700a      	strbls	r2, [r1, #0]
 8029ff0:	f04f 30ff 	movhi.w	r0, #4294967295
 8029ff4:	bf98      	it	ls
 8029ff6:	2001      	movls	r0, #1
 8029ff8:	4770      	bx	lr
 8029ffa:	4608      	mov	r0, r1
 8029ffc:	4770      	bx	lr

08029ffe <__ssprint_r>:
 8029ffe:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a002:	6813      	ldr	r3, [r2, #0]
 802a004:	9301      	str	r3, [sp, #4]
 802a006:	6893      	ldr	r3, [r2, #8]
 802a008:	4680      	mov	r8, r0
 802a00a:	460c      	mov	r4, r1
 802a00c:	4617      	mov	r7, r2
 802a00e:	2b00      	cmp	r3, #0
 802a010:	d157      	bne.n	802a0c2 <__ssprint_r+0xc4>
 802a012:	2000      	movs	r0, #0
 802a014:	2300      	movs	r3, #0
 802a016:	607b      	str	r3, [r7, #4]
 802a018:	b003      	add	sp, #12
 802a01a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a01e:	9b01      	ldr	r3, [sp, #4]
 802a020:	e9d3 ab00 	ldrd	sl, fp, [r3]
 802a024:	3308      	adds	r3, #8
 802a026:	9301      	str	r3, [sp, #4]
 802a028:	68a6      	ldr	r6, [r4, #8]
 802a02a:	6820      	ldr	r0, [r4, #0]
 802a02c:	f1bb 0f00 	cmp.w	fp, #0
 802a030:	d0f5      	beq.n	802a01e <__ssprint_r+0x20>
 802a032:	45b3      	cmp	fp, r6
 802a034:	d32d      	bcc.n	802a092 <__ssprint_r+0x94>
 802a036:	89a2      	ldrh	r2, [r4, #12]
 802a038:	f412 6f90 	tst.w	r2, #1152	; 0x480
 802a03c:	d029      	beq.n	802a092 <__ssprint_r+0x94>
 802a03e:	6921      	ldr	r1, [r4, #16]
 802a040:	6965      	ldr	r5, [r4, #20]
 802a042:	eba0 0901 	sub.w	r9, r0, r1
 802a046:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802a04a:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802a04e:	f109 0001 	add.w	r0, r9, #1
 802a052:	106d      	asrs	r5, r5, #1
 802a054:	4458      	add	r0, fp
 802a056:	4285      	cmp	r5, r0
 802a058:	bf38      	it	cc
 802a05a:	4605      	movcc	r5, r0
 802a05c:	0553      	lsls	r3, r2, #21
 802a05e:	d534      	bpl.n	802a0ca <__ssprint_r+0xcc>
 802a060:	4629      	mov	r1, r5
 802a062:	4640      	mov	r0, r8
 802a064:	f7fc fe72 	bl	8026d4c <_malloc_r>
 802a068:	4606      	mov	r6, r0
 802a06a:	2800      	cmp	r0, #0
 802a06c:	d038      	beq.n	802a0e0 <__ssprint_r+0xe2>
 802a06e:	464a      	mov	r2, r9
 802a070:	6921      	ldr	r1, [r4, #16]
 802a072:	f7fc fd39 	bl	8026ae8 <memcpy>
 802a076:	89a2      	ldrh	r2, [r4, #12]
 802a078:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 802a07c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802a080:	81a2      	strh	r2, [r4, #12]
 802a082:	6126      	str	r6, [r4, #16]
 802a084:	6165      	str	r5, [r4, #20]
 802a086:	444e      	add	r6, r9
 802a088:	eba5 0509 	sub.w	r5, r5, r9
 802a08c:	6026      	str	r6, [r4, #0]
 802a08e:	60a5      	str	r5, [r4, #8]
 802a090:	465e      	mov	r6, fp
 802a092:	455e      	cmp	r6, fp
 802a094:	bf28      	it	cs
 802a096:	465e      	movcs	r6, fp
 802a098:	4632      	mov	r2, r6
 802a09a:	4651      	mov	r1, sl
 802a09c:	6820      	ldr	r0, [r4, #0]
 802a09e:	f000 f82b 	bl	802a0f8 <memmove>
 802a0a2:	68a2      	ldr	r2, [r4, #8]
 802a0a4:	1b92      	subs	r2, r2, r6
 802a0a6:	60a2      	str	r2, [r4, #8]
 802a0a8:	6822      	ldr	r2, [r4, #0]
 802a0aa:	4432      	add	r2, r6
 802a0ac:	6022      	str	r2, [r4, #0]
 802a0ae:	68ba      	ldr	r2, [r7, #8]
 802a0b0:	eba2 030b 	sub.w	r3, r2, fp
 802a0b4:	44da      	add	sl, fp
 802a0b6:	60bb      	str	r3, [r7, #8]
 802a0b8:	2b00      	cmp	r3, #0
 802a0ba:	d0aa      	beq.n	802a012 <__ssprint_r+0x14>
 802a0bc:	f04f 0b00 	mov.w	fp, #0
 802a0c0:	e7b2      	b.n	802a028 <__ssprint_r+0x2a>
 802a0c2:	f04f 0a00 	mov.w	sl, #0
 802a0c6:	46d3      	mov	fp, sl
 802a0c8:	e7ae      	b.n	802a028 <__ssprint_r+0x2a>
 802a0ca:	462a      	mov	r2, r5
 802a0cc:	4640      	mov	r0, r8
 802a0ce:	f7ff fde1 	bl	8029c94 <_realloc_r>
 802a0d2:	4606      	mov	r6, r0
 802a0d4:	2800      	cmp	r0, #0
 802a0d6:	d1d4      	bne.n	802a082 <__ssprint_r+0x84>
 802a0d8:	6921      	ldr	r1, [r4, #16]
 802a0da:	4640      	mov	r0, r8
 802a0dc:	f7fc fd76 	bl	8026bcc <_free_r>
 802a0e0:	230c      	movs	r3, #12
 802a0e2:	f8c8 3000 	str.w	r3, [r8]
 802a0e6:	89a3      	ldrh	r3, [r4, #12]
 802a0e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802a0ec:	81a3      	strh	r3, [r4, #12]
 802a0ee:	2300      	movs	r3, #0
 802a0f0:	60bb      	str	r3, [r7, #8]
 802a0f2:	f04f 30ff 	mov.w	r0, #4294967295
 802a0f6:	e78d      	b.n	802a014 <__ssprint_r+0x16>

0802a0f8 <memmove>:
 802a0f8:	4288      	cmp	r0, r1
 802a0fa:	b510      	push	{r4, lr}
 802a0fc:	eb01 0402 	add.w	r4, r1, r2
 802a100:	d902      	bls.n	802a108 <memmove+0x10>
 802a102:	4284      	cmp	r4, r0
 802a104:	4623      	mov	r3, r4
 802a106:	d807      	bhi.n	802a118 <memmove+0x20>
 802a108:	1e43      	subs	r3, r0, #1
 802a10a:	42a1      	cmp	r1, r4
 802a10c:	d008      	beq.n	802a120 <memmove+0x28>
 802a10e:	f811 2b01 	ldrb.w	r2, [r1], #1
 802a112:	f803 2f01 	strb.w	r2, [r3, #1]!
 802a116:	e7f8      	b.n	802a10a <memmove+0x12>
 802a118:	4402      	add	r2, r0
 802a11a:	4601      	mov	r1, r0
 802a11c:	428a      	cmp	r2, r1
 802a11e:	d100      	bne.n	802a122 <memmove+0x2a>
 802a120:	bd10      	pop	{r4, pc}
 802a122:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 802a126:	f802 4d01 	strb.w	r4, [r2, #-1]!
 802a12a:	e7f7      	b.n	802a11c <memmove+0x24>

0802a12c <__assert_func>:
 802a12c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 802a12e:	4614      	mov	r4, r2
 802a130:	461a      	mov	r2, r3
 802a132:	4b09      	ldr	r3, [pc, #36]	; (802a158 <__assert_func+0x2c>)
 802a134:	681b      	ldr	r3, [r3, #0]
 802a136:	4605      	mov	r5, r0
 802a138:	68d8      	ldr	r0, [r3, #12]
 802a13a:	b14c      	cbz	r4, 802a150 <__assert_func+0x24>
 802a13c:	4b07      	ldr	r3, [pc, #28]	; (802a15c <__assert_func+0x30>)
 802a13e:	9100      	str	r1, [sp, #0]
 802a140:	e9cd 3401 	strd	r3, r4, [sp, #4]
 802a144:	4906      	ldr	r1, [pc, #24]	; (802a160 <__assert_func+0x34>)
 802a146:	462b      	mov	r3, r5
 802a148:	f000 f844 	bl	802a1d4 <fiprintf>
 802a14c:	f000 ff65 	bl	802b01a <abort>
 802a150:	4b04      	ldr	r3, [pc, #16]	; (802a164 <__assert_func+0x38>)
 802a152:	461c      	mov	r4, r3
 802a154:	e7f3      	b.n	802a13e <__assert_func+0x12>
 802a156:	bf00      	nop
 802a158:	20000380 	.word	0x20000380
 802a15c:	08037774 	.word	0x08037774
 802a160:	08037781 	.word	0x08037781
 802a164:	080377af 	.word	0x080377af

0802a168 <_calloc_r>:
 802a168:	b538      	push	{r3, r4, r5, lr}
 802a16a:	fba1 1502 	umull	r1, r5, r1, r2
 802a16e:	b92d      	cbnz	r5, 802a17c <_calloc_r+0x14>
 802a170:	f7fc fdec 	bl	8026d4c <_malloc_r>
 802a174:	4604      	mov	r4, r0
 802a176:	b938      	cbnz	r0, 802a188 <_calloc_r+0x20>
 802a178:	4620      	mov	r0, r4
 802a17a:	bd38      	pop	{r3, r4, r5, pc}
 802a17c:	f7fc fc7e 	bl	8026a7c <__errno>
 802a180:	230c      	movs	r3, #12
 802a182:	6003      	str	r3, [r0, #0]
 802a184:	2400      	movs	r4, #0
 802a186:	e7f7      	b.n	802a178 <_calloc_r+0x10>
 802a188:	f850 2c04 	ldr.w	r2, [r0, #-4]
 802a18c:	f022 0203 	bic.w	r2, r2, #3
 802a190:	3a04      	subs	r2, #4
 802a192:	2a24      	cmp	r2, #36	; 0x24
 802a194:	d819      	bhi.n	802a1ca <_calloc_r+0x62>
 802a196:	2a13      	cmp	r2, #19
 802a198:	d915      	bls.n	802a1c6 <_calloc_r+0x5e>
 802a19a:	2a1b      	cmp	r2, #27
 802a19c:	e9c0 5500 	strd	r5, r5, [r0]
 802a1a0:	d806      	bhi.n	802a1b0 <_calloc_r+0x48>
 802a1a2:	f100 0308 	add.w	r3, r0, #8
 802a1a6:	2200      	movs	r2, #0
 802a1a8:	e9c3 2200 	strd	r2, r2, [r3]
 802a1ac:	609a      	str	r2, [r3, #8]
 802a1ae:	e7e3      	b.n	802a178 <_calloc_r+0x10>
 802a1b0:	2a24      	cmp	r2, #36	; 0x24
 802a1b2:	e9c0 5502 	strd	r5, r5, [r0, #8]
 802a1b6:	bf11      	iteee	ne
 802a1b8:	f100 0310 	addne.w	r3, r0, #16
 802a1bc:	6105      	streq	r5, [r0, #16]
 802a1be:	f100 0318 	addeq.w	r3, r0, #24
 802a1c2:	6145      	streq	r5, [r0, #20]
 802a1c4:	e7ef      	b.n	802a1a6 <_calloc_r+0x3e>
 802a1c6:	4603      	mov	r3, r0
 802a1c8:	e7ed      	b.n	802a1a6 <_calloc_r+0x3e>
 802a1ca:	4629      	mov	r1, r5
 802a1cc:	f7fc fbaf 	bl	802692e <memset>
 802a1d0:	e7d2      	b.n	802a178 <_calloc_r+0x10>
	...

0802a1d4 <fiprintf>:
 802a1d4:	b40e      	push	{r1, r2, r3}
 802a1d6:	b503      	push	{r0, r1, lr}
 802a1d8:	4601      	mov	r1, r0
 802a1da:	ab03      	add	r3, sp, #12
 802a1dc:	4805      	ldr	r0, [pc, #20]	; (802a1f4 <fiprintf+0x20>)
 802a1de:	f853 2b04 	ldr.w	r2, [r3], #4
 802a1e2:	6800      	ldr	r0, [r0, #0]
 802a1e4:	9301      	str	r3, [sp, #4]
 802a1e6:	f000 f839 	bl	802a25c <_vfiprintf_r>
 802a1ea:	b002      	add	sp, #8
 802a1ec:	f85d eb04 	ldr.w	lr, [sp], #4
 802a1f0:	b003      	add	sp, #12
 802a1f2:	4770      	bx	lr
 802a1f4:	20000380 	.word	0x20000380

0802a1f8 <__sprint_r>:
 802a1f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a1fc:	6893      	ldr	r3, [r2, #8]
 802a1fe:	4680      	mov	r8, r0
 802a200:	460f      	mov	r7, r1
 802a202:	4614      	mov	r4, r2
 802a204:	b343      	cbz	r3, 802a258 <__sprint_r+0x60>
 802a206:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 802a208:	049d      	lsls	r5, r3, #18
 802a20a:	d522      	bpl.n	802a252 <__sprint_r+0x5a>
 802a20c:	6815      	ldr	r5, [r2, #0]
 802a20e:	3508      	adds	r5, #8
 802a210:	e955 b602 	ldrd	fp, r6, [r5, #-8]
 802a214:	f04f 0900 	mov.w	r9, #0
 802a218:	ea4f 0a96 	mov.w	sl, r6, lsr #2
 802a21c:	45ca      	cmp	sl, r9
 802a21e:	dc0d      	bgt.n	802a23c <__sprint_r+0x44>
 802a220:	68a3      	ldr	r3, [r4, #8]
 802a222:	f026 0603 	bic.w	r6, r6, #3
 802a226:	1b98      	subs	r0, r3, r6
 802a228:	60a0      	str	r0, [r4, #8]
 802a22a:	3508      	adds	r5, #8
 802a22c:	2800      	cmp	r0, #0
 802a22e:	d1ef      	bne.n	802a210 <__sprint_r+0x18>
 802a230:	2300      	movs	r3, #0
 802a232:	60a3      	str	r3, [r4, #8]
 802a234:	2300      	movs	r3, #0
 802a236:	6063      	str	r3, [r4, #4]
 802a238:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a23c:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
 802a240:	463a      	mov	r2, r7
 802a242:	4640      	mov	r0, r8
 802a244:	f000 febf 	bl	802afc6 <_fputwc_r>
 802a248:	1c43      	adds	r3, r0, #1
 802a24a:	d0f1      	beq.n	802a230 <__sprint_r+0x38>
 802a24c:	f109 0901 	add.w	r9, r9, #1
 802a250:	e7e4      	b.n	802a21c <__sprint_r+0x24>
 802a252:	f000 fcd5 	bl	802ac00 <__sfvwrite_r>
 802a256:	e7eb      	b.n	802a230 <__sprint_r+0x38>
 802a258:	4618      	mov	r0, r3
 802a25a:	e7eb      	b.n	802a234 <__sprint_r+0x3c>

0802a25c <_vfiprintf_r>:
 802a25c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a260:	ed2d 8b02 	vpush	{d8}
 802a264:	b0bb      	sub	sp, #236	; 0xec
 802a266:	460f      	mov	r7, r1
 802a268:	9201      	str	r2, [sp, #4]
 802a26a:	461d      	mov	r5, r3
 802a26c:	461c      	mov	r4, r3
 802a26e:	4681      	mov	r9, r0
 802a270:	b118      	cbz	r0, 802a27a <_vfiprintf_r+0x1e>
 802a272:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802a274:	b90b      	cbnz	r3, 802a27a <_vfiprintf_r+0x1e>
 802a276:	f7fc fa7d 	bl	8026774 <__sinit>
 802a27a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802a27c:	07d8      	lsls	r0, r3, #31
 802a27e:	d405      	bmi.n	802a28c <_vfiprintf_r+0x30>
 802a280:	89bb      	ldrh	r3, [r7, #12]
 802a282:	0599      	lsls	r1, r3, #22
 802a284:	d402      	bmi.n	802a28c <_vfiprintf_r+0x30>
 802a286:	6db8      	ldr	r0, [r7, #88]	; 0x58
 802a288:	f7fc fc24 	bl	8026ad4 <__retarget_lock_acquire_recursive>
 802a28c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 802a290:	049a      	lsls	r2, r3, #18
 802a292:	d406      	bmi.n	802a2a2 <_vfiprintf_r+0x46>
 802a294:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802a298:	81bb      	strh	r3, [r7, #12]
 802a29a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802a29c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802a2a0:	667b      	str	r3, [r7, #100]	; 0x64
 802a2a2:	89bb      	ldrh	r3, [r7, #12]
 802a2a4:	071e      	lsls	r6, r3, #28
 802a2a6:	d501      	bpl.n	802a2ac <_vfiprintf_r+0x50>
 802a2a8:	693b      	ldr	r3, [r7, #16]
 802a2aa:	b9bb      	cbnz	r3, 802a2dc <_vfiprintf_r+0x80>
 802a2ac:	4639      	mov	r1, r7
 802a2ae:	4648      	mov	r0, r9
 802a2b0:	f000 fdf0 	bl	802ae94 <__swsetup_r>
 802a2b4:	b190      	cbz	r0, 802a2dc <_vfiprintf_r+0x80>
 802a2b6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802a2b8:	07d8      	lsls	r0, r3, #31
 802a2ba:	d508      	bpl.n	802a2ce <_vfiprintf_r+0x72>
 802a2bc:	f04f 33ff 	mov.w	r3, #4294967295
 802a2c0:	9302      	str	r3, [sp, #8]
 802a2c2:	9802      	ldr	r0, [sp, #8]
 802a2c4:	b03b      	add	sp, #236	; 0xec
 802a2c6:	ecbd 8b02 	vpop	{d8}
 802a2ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a2ce:	89bb      	ldrh	r3, [r7, #12]
 802a2d0:	0599      	lsls	r1, r3, #22
 802a2d2:	d4f3      	bmi.n	802a2bc <_vfiprintf_r+0x60>
 802a2d4:	6db8      	ldr	r0, [r7, #88]	; 0x58
 802a2d6:	f7fc fbfe 	bl	8026ad6 <__retarget_lock_release_recursive>
 802a2da:	e7ef      	b.n	802a2bc <_vfiprintf_r+0x60>
 802a2dc:	89bb      	ldrh	r3, [r7, #12]
 802a2de:	f003 021a 	and.w	r2, r3, #26
 802a2e2:	2a0a      	cmp	r2, #10
 802a2e4:	d116      	bne.n	802a314 <_vfiprintf_r+0xb8>
 802a2e6:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 802a2ea:	2a00      	cmp	r2, #0
 802a2ec:	db12      	blt.n	802a314 <_vfiprintf_r+0xb8>
 802a2ee:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 802a2f0:	07d2      	lsls	r2, r2, #31
 802a2f2:	d404      	bmi.n	802a2fe <_vfiprintf_r+0xa2>
 802a2f4:	059e      	lsls	r6, r3, #22
 802a2f6:	d402      	bmi.n	802a2fe <_vfiprintf_r+0xa2>
 802a2f8:	6db8      	ldr	r0, [r7, #88]	; 0x58
 802a2fa:	f7fc fbec 	bl	8026ad6 <__retarget_lock_release_recursive>
 802a2fe:	9a01      	ldr	r2, [sp, #4]
 802a300:	462b      	mov	r3, r5
 802a302:	4639      	mov	r1, r7
 802a304:	4648      	mov	r0, r9
 802a306:	b03b      	add	sp, #236	; 0xec
 802a308:	ecbd 8b02 	vpop	{d8}
 802a30c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a310:	f000 bc36 	b.w	802ab80 <__sbprintf>
 802a314:	2300      	movs	r3, #0
 802a316:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
 802a31a:	e9cd 3305 	strd	r3, r3, [sp, #20]
 802a31e:	ae11      	add	r6, sp, #68	; 0x44
 802a320:	ee08 3a10 	vmov	s16, r3
 802a324:	960e      	str	r6, [sp, #56]	; 0x38
 802a326:	9307      	str	r3, [sp, #28]
 802a328:	9302      	str	r3, [sp, #8]
 802a32a:	9b01      	ldr	r3, [sp, #4]
 802a32c:	461d      	mov	r5, r3
 802a32e:	f813 2b01 	ldrb.w	r2, [r3], #1
 802a332:	b10a      	cbz	r2, 802a338 <_vfiprintf_r+0xdc>
 802a334:	2a25      	cmp	r2, #37	; 0x25
 802a336:	d1f9      	bne.n	802a32c <_vfiprintf_r+0xd0>
 802a338:	9b01      	ldr	r3, [sp, #4]
 802a33a:	ebb5 0803 	subs.w	r8, r5, r3
 802a33e:	d00d      	beq.n	802a35c <_vfiprintf_r+0x100>
 802a340:	e9c6 3800 	strd	r3, r8, [r6]
 802a344:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802a346:	4443      	add	r3, r8
 802a348:	9310      	str	r3, [sp, #64]	; 0x40
 802a34a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802a34c:	3301      	adds	r3, #1
 802a34e:	2b07      	cmp	r3, #7
 802a350:	930f      	str	r3, [sp, #60]	; 0x3c
 802a352:	dc76      	bgt.n	802a442 <_vfiprintf_r+0x1e6>
 802a354:	3608      	adds	r6, #8
 802a356:	9b02      	ldr	r3, [sp, #8]
 802a358:	4443      	add	r3, r8
 802a35a:	9302      	str	r3, [sp, #8]
 802a35c:	782b      	ldrb	r3, [r5, #0]
 802a35e:	2b00      	cmp	r3, #0
 802a360:	f000 83d0 	beq.w	802ab04 <_vfiprintf_r+0x8a8>
 802a364:	2300      	movs	r3, #0
 802a366:	f04f 32ff 	mov.w	r2, #4294967295
 802a36a:	3501      	adds	r5, #1
 802a36c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 802a370:	9200      	str	r2, [sp, #0]
 802a372:	9303      	str	r3, [sp, #12]
 802a374:	469a      	mov	sl, r3
 802a376:	462a      	mov	r2, r5
 802a378:	f812 3b01 	ldrb.w	r3, [r2], #1
 802a37c:	9201      	str	r2, [sp, #4]
 802a37e:	f1a3 0220 	sub.w	r2, r3, #32
 802a382:	2a5a      	cmp	r2, #90	; 0x5a
 802a384:	f200 831c 	bhi.w	802a9c0 <_vfiprintf_r+0x764>
 802a388:	e8df f012 	tbh	[pc, r2, lsl #1]
 802a38c:	031a007e 	.word	0x031a007e
 802a390:	0086031a 	.word	0x0086031a
 802a394:	031a031a 	.word	0x031a031a
 802a398:	0065031a 	.word	0x0065031a
 802a39c:	031a031a 	.word	0x031a031a
 802a3a0:	00930089 	.word	0x00930089
 802a3a4:	0090031a 	.word	0x0090031a
 802a3a8:	031a0095 	.word	0x031a0095
 802a3ac:	00b300b0 	.word	0x00b300b0
 802a3b0:	00b300b3 	.word	0x00b300b3
 802a3b4:	00b300b3 	.word	0x00b300b3
 802a3b8:	00b300b3 	.word	0x00b300b3
 802a3bc:	00b300b3 	.word	0x00b300b3
 802a3c0:	031a031a 	.word	0x031a031a
 802a3c4:	031a031a 	.word	0x031a031a
 802a3c8:	031a031a 	.word	0x031a031a
 802a3cc:	031a031a 	.word	0x031a031a
 802a3d0:	00dd031a 	.word	0x00dd031a
 802a3d4:	031a00eb 	.word	0x031a00eb
 802a3d8:	031a031a 	.word	0x031a031a
 802a3dc:	031a031a 	.word	0x031a031a
 802a3e0:	031a031a 	.word	0x031a031a
 802a3e4:	031a031a 	.word	0x031a031a
 802a3e8:	013b031a 	.word	0x013b031a
 802a3ec:	031a031a 	.word	0x031a031a
 802a3f0:	0180031a 	.word	0x0180031a
 802a3f4:	025e031a 	.word	0x025e031a
 802a3f8:	031a031a 	.word	0x031a031a
 802a3fc:	031a027e 	.word	0x031a027e
 802a400:	031a031a 	.word	0x031a031a
 802a404:	031a031a 	.word	0x031a031a
 802a408:	031a031a 	.word	0x031a031a
 802a40c:	031a031a 	.word	0x031a031a
 802a410:	00dd031a 	.word	0x00dd031a
 802a414:	031a00ed 	.word	0x031a00ed
 802a418:	031a031a 	.word	0x031a031a
 802a41c:	00ed00c3 	.word	0x00ed00c3
 802a420:	031a00d7 	.word	0x031a00d7
 802a424:	031a00d0 	.word	0x031a00d0
 802a428:	013d0119 	.word	0x013d0119
 802a42c:	00d70172 	.word	0x00d70172
 802a430:	0180031a 	.word	0x0180031a
 802a434:	0260007c 	.word	0x0260007c
 802a438:	031a031a 	.word	0x031a031a
 802a43c:	031a029a 	.word	0x031a029a
 802a440:	007c      	.short	0x007c
 802a442:	aa0e      	add	r2, sp, #56	; 0x38
 802a444:	4639      	mov	r1, r7
 802a446:	4648      	mov	r0, r9
 802a448:	f7ff fed6 	bl	802a1f8 <__sprint_r>
 802a44c:	2800      	cmp	r0, #0
 802a44e:	f040 8338 	bne.w	802aac2 <_vfiprintf_r+0x866>
 802a452:	ae11      	add	r6, sp, #68	; 0x44
 802a454:	e77f      	b.n	802a356 <_vfiprintf_r+0xfa>
 802a456:	4648      	mov	r0, r9
 802a458:	f7fe f9d0 	bl	80287fc <_localeconv_r>
 802a45c:	6843      	ldr	r3, [r0, #4]
 802a45e:	4618      	mov	r0, r3
 802a460:	ee08 3a10 	vmov	s16, r3
 802a464:	f7d5 fec6 	bl	80001f4 <strlen>
 802a468:	9007      	str	r0, [sp, #28]
 802a46a:	4648      	mov	r0, r9
 802a46c:	f7fe f9c6 	bl	80287fc <_localeconv_r>
 802a470:	6883      	ldr	r3, [r0, #8]
 802a472:	9306      	str	r3, [sp, #24]
 802a474:	9b07      	ldr	r3, [sp, #28]
 802a476:	b12b      	cbz	r3, 802a484 <_vfiprintf_r+0x228>
 802a478:	9b06      	ldr	r3, [sp, #24]
 802a47a:	b11b      	cbz	r3, 802a484 <_vfiprintf_r+0x228>
 802a47c:	781b      	ldrb	r3, [r3, #0]
 802a47e:	b10b      	cbz	r3, 802a484 <_vfiprintf_r+0x228>
 802a480:	f44a 6a80 	orr.w	sl, sl, #1024	; 0x400
 802a484:	9d01      	ldr	r5, [sp, #4]
 802a486:	e776      	b.n	802a376 <_vfiprintf_r+0x11a>
 802a488:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 802a48c:	2b00      	cmp	r3, #0
 802a48e:	d1f9      	bne.n	802a484 <_vfiprintf_r+0x228>
 802a490:	2320      	movs	r3, #32
 802a492:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 802a496:	e7f5      	b.n	802a484 <_vfiprintf_r+0x228>
 802a498:	f04a 0a01 	orr.w	sl, sl, #1
 802a49c:	e7f2      	b.n	802a484 <_vfiprintf_r+0x228>
 802a49e:	f854 3b04 	ldr.w	r3, [r4], #4
 802a4a2:	9303      	str	r3, [sp, #12]
 802a4a4:	2b00      	cmp	r3, #0
 802a4a6:	daed      	bge.n	802a484 <_vfiprintf_r+0x228>
 802a4a8:	425b      	negs	r3, r3
 802a4aa:	9303      	str	r3, [sp, #12]
 802a4ac:	f04a 0a04 	orr.w	sl, sl, #4
 802a4b0:	e7e8      	b.n	802a484 <_vfiprintf_r+0x228>
 802a4b2:	232b      	movs	r3, #43	; 0x2b
 802a4b4:	e7ed      	b.n	802a492 <_vfiprintf_r+0x236>
 802a4b6:	9a01      	ldr	r2, [sp, #4]
 802a4b8:	f812 3b01 	ldrb.w	r3, [r2], #1
 802a4bc:	2b2a      	cmp	r3, #42	; 0x2a
 802a4be:	d112      	bne.n	802a4e6 <_vfiprintf_r+0x28a>
 802a4c0:	f854 3b04 	ldr.w	r3, [r4], #4
 802a4c4:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 802a4c8:	e9cd 3200 	strd	r3, r2, [sp]
 802a4cc:	e7da      	b.n	802a484 <_vfiprintf_r+0x228>
 802a4ce:	9b00      	ldr	r3, [sp, #0]
 802a4d0:	200a      	movs	r0, #10
 802a4d2:	fb00 1303 	mla	r3, r0, r3, r1
 802a4d6:	9300      	str	r3, [sp, #0]
 802a4d8:	f812 3b01 	ldrb.w	r3, [r2], #1
 802a4dc:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 802a4e0:	2909      	cmp	r1, #9
 802a4e2:	d9f4      	bls.n	802a4ce <_vfiprintf_r+0x272>
 802a4e4:	e74a      	b.n	802a37c <_vfiprintf_r+0x120>
 802a4e6:	2100      	movs	r1, #0
 802a4e8:	9100      	str	r1, [sp, #0]
 802a4ea:	e7f7      	b.n	802a4dc <_vfiprintf_r+0x280>
 802a4ec:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 802a4f0:	e7c8      	b.n	802a484 <_vfiprintf_r+0x228>
 802a4f2:	2100      	movs	r1, #0
 802a4f4:	9a01      	ldr	r2, [sp, #4]
 802a4f6:	9103      	str	r1, [sp, #12]
 802a4f8:	9903      	ldr	r1, [sp, #12]
 802a4fa:	3b30      	subs	r3, #48	; 0x30
 802a4fc:	200a      	movs	r0, #10
 802a4fe:	fb00 3301 	mla	r3, r0, r1, r3
 802a502:	9303      	str	r3, [sp, #12]
 802a504:	f812 3b01 	ldrb.w	r3, [r2], #1
 802a508:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 802a50c:	2909      	cmp	r1, #9
 802a50e:	d9f3      	bls.n	802a4f8 <_vfiprintf_r+0x29c>
 802a510:	e734      	b.n	802a37c <_vfiprintf_r+0x120>
 802a512:	9b01      	ldr	r3, [sp, #4]
 802a514:	781b      	ldrb	r3, [r3, #0]
 802a516:	2b68      	cmp	r3, #104	; 0x68
 802a518:	bf01      	itttt	eq
 802a51a:	9b01      	ldreq	r3, [sp, #4]
 802a51c:	3301      	addeq	r3, #1
 802a51e:	9301      	streq	r3, [sp, #4]
 802a520:	f44a 7a00 	orreq.w	sl, sl, #512	; 0x200
 802a524:	bf18      	it	ne
 802a526:	f04a 0a40 	orrne.w	sl, sl, #64	; 0x40
 802a52a:	e7ab      	b.n	802a484 <_vfiprintf_r+0x228>
 802a52c:	9b01      	ldr	r3, [sp, #4]
 802a52e:	781b      	ldrb	r3, [r3, #0]
 802a530:	2b6c      	cmp	r3, #108	; 0x6c
 802a532:	d105      	bne.n	802a540 <_vfiprintf_r+0x2e4>
 802a534:	9b01      	ldr	r3, [sp, #4]
 802a536:	3301      	adds	r3, #1
 802a538:	9301      	str	r3, [sp, #4]
 802a53a:	f04a 0a20 	orr.w	sl, sl, #32
 802a53e:	e7a1      	b.n	802a484 <_vfiprintf_r+0x228>
 802a540:	f04a 0a10 	orr.w	sl, sl, #16
 802a544:	e79e      	b.n	802a484 <_vfiprintf_r+0x228>
 802a546:	46a0      	mov	r8, r4
 802a548:	f858 3b04 	ldr.w	r3, [r8], #4
 802a54c:	f88d 3084 	strb.w	r3, [sp, #132]	; 0x84
 802a550:	2300      	movs	r3, #0
 802a552:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 802a556:	2201      	movs	r2, #1
 802a558:	9200      	str	r2, [sp, #0]
 802a55a:	461d      	mov	r5, r3
 802a55c:	f10d 0b84 	add.w	fp, sp, #132	; 0x84
 802a560:	e0a9      	b.n	802a6b6 <_vfiprintf_r+0x45a>
 802a562:	f04a 0a10 	orr.w	sl, sl, #16
 802a566:	f01a 0f20 	tst.w	sl, #32
 802a56a:	d011      	beq.n	802a590 <_vfiprintf_r+0x334>
 802a56c:	3407      	adds	r4, #7
 802a56e:	f024 0307 	bic.w	r3, r4, #7
 802a572:	4698      	mov	r8, r3
 802a574:	685d      	ldr	r5, [r3, #4]
 802a576:	f858 4b08 	ldr.w	r4, [r8], #8
 802a57a:	2d00      	cmp	r5, #0
 802a57c:	da06      	bge.n	802a58c <_vfiprintf_r+0x330>
 802a57e:	4264      	negs	r4, r4
 802a580:	f04f 032d 	mov.w	r3, #45	; 0x2d
 802a584:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 802a588:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 802a58c:	2301      	movs	r3, #1
 802a58e:	e04a      	b.n	802a626 <_vfiprintf_r+0x3ca>
 802a590:	46a0      	mov	r8, r4
 802a592:	f01a 0f10 	tst.w	sl, #16
 802a596:	f858 5b04 	ldr.w	r5, [r8], #4
 802a59a:	d002      	beq.n	802a5a2 <_vfiprintf_r+0x346>
 802a59c:	462c      	mov	r4, r5
 802a59e:	17ed      	asrs	r5, r5, #31
 802a5a0:	e7eb      	b.n	802a57a <_vfiprintf_r+0x31e>
 802a5a2:	f01a 0f40 	tst.w	sl, #64	; 0x40
 802a5a6:	d003      	beq.n	802a5b0 <_vfiprintf_r+0x354>
 802a5a8:	b22c      	sxth	r4, r5
 802a5aa:	f345 35c0 	sbfx	r5, r5, #15, #1
 802a5ae:	e7e4      	b.n	802a57a <_vfiprintf_r+0x31e>
 802a5b0:	f41a 7f00 	tst.w	sl, #512	; 0x200
 802a5b4:	d0f2      	beq.n	802a59c <_vfiprintf_r+0x340>
 802a5b6:	b26c      	sxtb	r4, r5
 802a5b8:	f345 15c0 	sbfx	r5, r5, #7, #1
 802a5bc:	e7dd      	b.n	802a57a <_vfiprintf_r+0x31e>
 802a5be:	f01a 0f20 	tst.w	sl, #32
 802a5c2:	f104 0804 	add.w	r8, r4, #4
 802a5c6:	d007      	beq.n	802a5d8 <_vfiprintf_r+0x37c>
 802a5c8:	9a02      	ldr	r2, [sp, #8]
 802a5ca:	6823      	ldr	r3, [r4, #0]
 802a5cc:	9902      	ldr	r1, [sp, #8]
 802a5ce:	17d2      	asrs	r2, r2, #31
 802a5d0:	e9c3 1200 	strd	r1, r2, [r3]
 802a5d4:	4644      	mov	r4, r8
 802a5d6:	e6a8      	b.n	802a32a <_vfiprintf_r+0xce>
 802a5d8:	f01a 0f10 	tst.w	sl, #16
 802a5dc:	d003      	beq.n	802a5e6 <_vfiprintf_r+0x38a>
 802a5de:	6823      	ldr	r3, [r4, #0]
 802a5e0:	9a02      	ldr	r2, [sp, #8]
 802a5e2:	601a      	str	r2, [r3, #0]
 802a5e4:	e7f6      	b.n	802a5d4 <_vfiprintf_r+0x378>
 802a5e6:	f01a 0f40 	tst.w	sl, #64	; 0x40
 802a5ea:	d003      	beq.n	802a5f4 <_vfiprintf_r+0x398>
 802a5ec:	6823      	ldr	r3, [r4, #0]
 802a5ee:	9a02      	ldr	r2, [sp, #8]
 802a5f0:	801a      	strh	r2, [r3, #0]
 802a5f2:	e7ef      	b.n	802a5d4 <_vfiprintf_r+0x378>
 802a5f4:	f41a 7f00 	tst.w	sl, #512	; 0x200
 802a5f8:	d0f1      	beq.n	802a5de <_vfiprintf_r+0x382>
 802a5fa:	6823      	ldr	r3, [r4, #0]
 802a5fc:	9a02      	ldr	r2, [sp, #8]
 802a5fe:	701a      	strb	r2, [r3, #0]
 802a600:	e7e8      	b.n	802a5d4 <_vfiprintf_r+0x378>
 802a602:	f04a 0a10 	orr.w	sl, sl, #16
 802a606:	f01a 0320 	ands.w	r3, sl, #32
 802a60a:	d01f      	beq.n	802a64c <_vfiprintf_r+0x3f0>
 802a60c:	3407      	adds	r4, #7
 802a60e:	f024 0307 	bic.w	r3, r4, #7
 802a612:	4698      	mov	r8, r3
 802a614:	685d      	ldr	r5, [r3, #4]
 802a616:	f858 4b08 	ldr.w	r4, [r8], #8
 802a61a:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 802a61e:	2300      	movs	r3, #0
 802a620:	2200      	movs	r2, #0
 802a622:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
 802a626:	9a00      	ldr	r2, [sp, #0]
 802a628:	3201      	adds	r2, #1
 802a62a:	f000 8278 	beq.w	802ab1e <_vfiprintf_r+0x8c2>
 802a62e:	f02a 0280 	bic.w	r2, sl, #128	; 0x80
 802a632:	9204      	str	r2, [sp, #16]
 802a634:	ea54 0205 	orrs.w	r2, r4, r5
 802a638:	f040 8277 	bne.w	802ab2a <_vfiprintf_r+0x8ce>
 802a63c:	9a00      	ldr	r2, [sp, #0]
 802a63e:	2a00      	cmp	r2, #0
 802a640:	f000 81b3 	beq.w	802a9aa <_vfiprintf_r+0x74e>
 802a644:	2b01      	cmp	r3, #1
 802a646:	f040 8273 	bne.w	802ab30 <_vfiprintf_r+0x8d4>
 802a64a:	e151      	b.n	802a8f0 <_vfiprintf_r+0x694>
 802a64c:	46a0      	mov	r8, r4
 802a64e:	f01a 0510 	ands.w	r5, sl, #16
 802a652:	f858 4b04 	ldr.w	r4, [r8], #4
 802a656:	d001      	beq.n	802a65c <_vfiprintf_r+0x400>
 802a658:	461d      	mov	r5, r3
 802a65a:	e7de      	b.n	802a61a <_vfiprintf_r+0x3be>
 802a65c:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 802a660:	d001      	beq.n	802a666 <_vfiprintf_r+0x40a>
 802a662:	b2a4      	uxth	r4, r4
 802a664:	e7d9      	b.n	802a61a <_vfiprintf_r+0x3be>
 802a666:	f41a 7500 	ands.w	r5, sl, #512	; 0x200
 802a66a:	d0d6      	beq.n	802a61a <_vfiprintf_r+0x3be>
 802a66c:	b2e4      	uxtb	r4, r4
 802a66e:	e7f3      	b.n	802a658 <_vfiprintf_r+0x3fc>
 802a670:	46a0      	mov	r8, r4
 802a672:	f647 0330 	movw	r3, #30768	; 0x7830
 802a676:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
 802a67a:	f858 4b04 	ldr.w	r4, [r8], #4
 802a67e:	4b9f      	ldr	r3, [pc, #636]	; (802a8fc <_vfiprintf_r+0x6a0>)
 802a680:	9305      	str	r3, [sp, #20]
 802a682:	2500      	movs	r5, #0
 802a684:	f04a 0a02 	orr.w	sl, sl, #2
 802a688:	2302      	movs	r3, #2
 802a68a:	e7c9      	b.n	802a620 <_vfiprintf_r+0x3c4>
 802a68c:	9b00      	ldr	r3, [sp, #0]
 802a68e:	46a0      	mov	r8, r4
 802a690:	2500      	movs	r5, #0
 802a692:	1c5c      	adds	r4, r3, #1
 802a694:	f858 bb04 	ldr.w	fp, [r8], #4
 802a698:	f88d 5033 	strb.w	r5, [sp, #51]	; 0x33
 802a69c:	f000 80cf 	beq.w	802a83e <_vfiprintf_r+0x5e2>
 802a6a0:	461a      	mov	r2, r3
 802a6a2:	4629      	mov	r1, r5
 802a6a4:	4658      	mov	r0, fp
 802a6a6:	f7d5 fdb3 	bl	8000210 <memchr>
 802a6aa:	2800      	cmp	r0, #0
 802a6ac:	f000 8192 	beq.w	802a9d4 <_vfiprintf_r+0x778>
 802a6b0:	eba0 030b 	sub.w	r3, r0, fp
 802a6b4:	9300      	str	r3, [sp, #0]
 802a6b6:	9b00      	ldr	r3, [sp, #0]
 802a6b8:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
 802a6bc:	42ab      	cmp	r3, r5
 802a6be:	bfb8      	it	lt
 802a6c0:	462b      	movlt	r3, r5
 802a6c2:	9304      	str	r3, [sp, #16]
 802a6c4:	b10a      	cbz	r2, 802a6ca <_vfiprintf_r+0x46e>
 802a6c6:	3301      	adds	r3, #1
 802a6c8:	9304      	str	r3, [sp, #16]
 802a6ca:	f01a 0302 	ands.w	r3, sl, #2
 802a6ce:	9308      	str	r3, [sp, #32]
 802a6d0:	bf1e      	ittt	ne
 802a6d2:	9b04      	ldrne	r3, [sp, #16]
 802a6d4:	3302      	addne	r3, #2
 802a6d6:	9304      	strne	r3, [sp, #16]
 802a6d8:	f01a 0384 	ands.w	r3, sl, #132	; 0x84
 802a6dc:	9309      	str	r3, [sp, #36]	; 0x24
 802a6de:	d11f      	bne.n	802a720 <_vfiprintf_r+0x4c4>
 802a6e0:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 802a6e4:	1a9c      	subs	r4, r3, r2
 802a6e6:	2c00      	cmp	r4, #0
 802a6e8:	dd1a      	ble.n	802a720 <_vfiprintf_r+0x4c4>
 802a6ea:	4b85      	ldr	r3, [pc, #532]	; (802a900 <_vfiprintf_r+0x6a4>)
 802a6ec:	6033      	str	r3, [r6, #0]
 802a6ee:	e9dd 2c0f 	ldrd	r2, ip, [sp, #60]	; 0x3c
 802a6f2:	2c10      	cmp	r4, #16
 802a6f4:	f102 0201 	add.w	r2, r2, #1
 802a6f8:	f106 0008 	add.w	r0, r6, #8
 802a6fc:	f300 816c 	bgt.w	802a9d8 <_vfiprintf_r+0x77c>
 802a700:	6074      	str	r4, [r6, #4]
 802a702:	2a07      	cmp	r2, #7
 802a704:	4464      	add	r4, ip
 802a706:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 802a70a:	f340 8178 	ble.w	802a9fe <_vfiprintf_r+0x7a2>
 802a70e:	aa0e      	add	r2, sp, #56	; 0x38
 802a710:	4639      	mov	r1, r7
 802a712:	4648      	mov	r0, r9
 802a714:	f7ff fd70 	bl	802a1f8 <__sprint_r>
 802a718:	2800      	cmp	r0, #0
 802a71a:	f040 81d2 	bne.w	802aac2 <_vfiprintf_r+0x866>
 802a71e:	ae11      	add	r6, sp, #68	; 0x44
 802a720:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
 802a724:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 802a728:	b160      	cbz	r0, 802a744 <_vfiprintf_r+0x4e8>
 802a72a:	f10d 0033 	add.w	r0, sp, #51	; 0x33
 802a72e:	3201      	adds	r2, #1
 802a730:	6030      	str	r0, [r6, #0]
 802a732:	2001      	movs	r0, #1
 802a734:	4401      	add	r1, r0
 802a736:	2a07      	cmp	r2, #7
 802a738:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 802a73c:	6070      	str	r0, [r6, #4]
 802a73e:	f300 8160 	bgt.w	802aa02 <_vfiprintf_r+0x7a6>
 802a742:	3608      	adds	r6, #8
 802a744:	9b08      	ldr	r3, [sp, #32]
 802a746:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 802a74a:	b15b      	cbz	r3, 802a764 <_vfiprintf_r+0x508>
 802a74c:	a80d      	add	r0, sp, #52	; 0x34
 802a74e:	3201      	adds	r2, #1
 802a750:	6030      	str	r0, [r6, #0]
 802a752:	2002      	movs	r0, #2
 802a754:	4401      	add	r1, r0
 802a756:	2a07      	cmp	r2, #7
 802a758:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 802a75c:	6070      	str	r0, [r6, #4]
 802a75e:	f300 8159 	bgt.w	802aa14 <_vfiprintf_r+0x7b8>
 802a762:	3608      	adds	r6, #8
 802a764:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802a766:	2b80      	cmp	r3, #128	; 0x80
 802a768:	d11f      	bne.n	802a7aa <_vfiprintf_r+0x54e>
 802a76a:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
 802a76e:	1a9c      	subs	r4, r3, r2
 802a770:	2c00      	cmp	r4, #0
 802a772:	dd1a      	ble.n	802a7aa <_vfiprintf_r+0x54e>
 802a774:	4b63      	ldr	r3, [pc, #396]	; (802a904 <_vfiprintf_r+0x6a8>)
 802a776:	6033      	str	r3, [r6, #0]
 802a778:	e9dd 2c0f 	ldrd	r2, ip, [sp, #60]	; 0x3c
 802a77c:	2c10      	cmp	r4, #16
 802a77e:	f102 0201 	add.w	r2, r2, #1
 802a782:	f106 0008 	add.w	r0, r6, #8
 802a786:	f300 814e 	bgt.w	802aa26 <_vfiprintf_r+0x7ca>
 802a78a:	6074      	str	r4, [r6, #4]
 802a78c:	2a07      	cmp	r2, #7
 802a78e:	4464      	add	r4, ip
 802a790:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 802a794:	f340 815a 	ble.w	802aa4c <_vfiprintf_r+0x7f0>
 802a798:	aa0e      	add	r2, sp, #56	; 0x38
 802a79a:	4639      	mov	r1, r7
 802a79c:	4648      	mov	r0, r9
 802a79e:	f7ff fd2b 	bl	802a1f8 <__sprint_r>
 802a7a2:	2800      	cmp	r0, #0
 802a7a4:	f040 818d 	bne.w	802aac2 <_vfiprintf_r+0x866>
 802a7a8:	ae11      	add	r6, sp, #68	; 0x44
 802a7aa:	9b00      	ldr	r3, [sp, #0]
 802a7ac:	1aec      	subs	r4, r5, r3
 802a7ae:	2c00      	cmp	r4, #0
 802a7b0:	dd1b      	ble.n	802a7ea <_vfiprintf_r+0x58e>
 802a7b2:	4d54      	ldr	r5, [pc, #336]	; (802a904 <_vfiprintf_r+0x6a8>)
 802a7b4:	2310      	movs	r3, #16
 802a7b6:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 802a7ba:	2c10      	cmp	r4, #16
 802a7bc:	f102 0201 	add.w	r2, r2, #1
 802a7c0:	f106 0008 	add.w	r0, r6, #8
 802a7c4:	6035      	str	r5, [r6, #0]
 802a7c6:	f300 8143 	bgt.w	802aa50 <_vfiprintf_r+0x7f4>
 802a7ca:	6074      	str	r4, [r6, #4]
 802a7cc:	2a07      	cmp	r2, #7
 802a7ce:	440c      	add	r4, r1
 802a7d0:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 802a7d4:	f340 814d 	ble.w	802aa72 <_vfiprintf_r+0x816>
 802a7d8:	aa0e      	add	r2, sp, #56	; 0x38
 802a7da:	4639      	mov	r1, r7
 802a7dc:	4648      	mov	r0, r9
 802a7de:	f7ff fd0b 	bl	802a1f8 <__sprint_r>
 802a7e2:	2800      	cmp	r0, #0
 802a7e4:	f040 816d 	bne.w	802aac2 <_vfiprintf_r+0x866>
 802a7e8:	ae11      	add	r6, sp, #68	; 0x44
 802a7ea:	9b00      	ldr	r3, [sp, #0]
 802a7ec:	9a00      	ldr	r2, [sp, #0]
 802a7ee:	6073      	str	r3, [r6, #4]
 802a7f0:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802a7f2:	f8c6 b000 	str.w	fp, [r6]
 802a7f6:	4413      	add	r3, r2
 802a7f8:	9310      	str	r3, [sp, #64]	; 0x40
 802a7fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 802a7fc:	3301      	adds	r3, #1
 802a7fe:	2b07      	cmp	r3, #7
 802a800:	930f      	str	r3, [sp, #60]	; 0x3c
 802a802:	f300 8138 	bgt.w	802aa76 <_vfiprintf_r+0x81a>
 802a806:	f106 0308 	add.w	r3, r6, #8
 802a80a:	f01a 0f04 	tst.w	sl, #4
 802a80e:	f040 813a 	bne.w	802aa86 <_vfiprintf_r+0x82a>
 802a812:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 802a816:	9904      	ldr	r1, [sp, #16]
 802a818:	428a      	cmp	r2, r1
 802a81a:	bfac      	ite	ge
 802a81c:	189b      	addge	r3, r3, r2
 802a81e:	185b      	addlt	r3, r3, r1
 802a820:	9302      	str	r3, [sp, #8]
 802a822:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802a824:	b13b      	cbz	r3, 802a836 <_vfiprintf_r+0x5da>
 802a826:	aa0e      	add	r2, sp, #56	; 0x38
 802a828:	4639      	mov	r1, r7
 802a82a:	4648      	mov	r0, r9
 802a82c:	f7ff fce4 	bl	802a1f8 <__sprint_r>
 802a830:	2800      	cmp	r0, #0
 802a832:	f040 8146 	bne.w	802aac2 <_vfiprintf_r+0x866>
 802a836:	2300      	movs	r3, #0
 802a838:	930f      	str	r3, [sp, #60]	; 0x3c
 802a83a:	ae11      	add	r6, sp, #68	; 0x44
 802a83c:	e6ca      	b.n	802a5d4 <_vfiprintf_r+0x378>
 802a83e:	4658      	mov	r0, fp
 802a840:	f7d5 fcd8 	bl	80001f4 <strlen>
 802a844:	9000      	str	r0, [sp, #0]
 802a846:	e736      	b.n	802a6b6 <_vfiprintf_r+0x45a>
 802a848:	f04a 0a10 	orr.w	sl, sl, #16
 802a84c:	f01a 0320 	ands.w	r3, sl, #32
 802a850:	d008      	beq.n	802a864 <_vfiprintf_r+0x608>
 802a852:	3407      	adds	r4, #7
 802a854:	f024 0307 	bic.w	r3, r4, #7
 802a858:	4698      	mov	r8, r3
 802a85a:	685d      	ldr	r5, [r3, #4]
 802a85c:	f858 4b08 	ldr.w	r4, [r8], #8
 802a860:	2301      	movs	r3, #1
 802a862:	e6dd      	b.n	802a620 <_vfiprintf_r+0x3c4>
 802a864:	46a0      	mov	r8, r4
 802a866:	f01a 0510 	ands.w	r5, sl, #16
 802a86a:	f858 4b04 	ldr.w	r4, [r8], #4
 802a86e:	d001      	beq.n	802a874 <_vfiprintf_r+0x618>
 802a870:	461d      	mov	r5, r3
 802a872:	e7f5      	b.n	802a860 <_vfiprintf_r+0x604>
 802a874:	f01a 0340 	ands.w	r3, sl, #64	; 0x40
 802a878:	d001      	beq.n	802a87e <_vfiprintf_r+0x622>
 802a87a:	b2a4      	uxth	r4, r4
 802a87c:	e7f0      	b.n	802a860 <_vfiprintf_r+0x604>
 802a87e:	f41a 7500 	ands.w	r5, sl, #512	; 0x200
 802a882:	d0ed      	beq.n	802a860 <_vfiprintf_r+0x604>
 802a884:	b2e4      	uxtb	r4, r4
 802a886:	e7f3      	b.n	802a870 <_vfiprintf_r+0x614>
 802a888:	4a1f      	ldr	r2, [pc, #124]	; (802a908 <_vfiprintf_r+0x6ac>)
 802a88a:	9205      	str	r2, [sp, #20]
 802a88c:	f01a 0220 	ands.w	r2, sl, #32
 802a890:	d018      	beq.n	802a8c4 <_vfiprintf_r+0x668>
 802a892:	3407      	adds	r4, #7
 802a894:	f024 0207 	bic.w	r2, r4, #7
 802a898:	4690      	mov	r8, r2
 802a89a:	6855      	ldr	r5, [r2, #4]
 802a89c:	f858 4b08 	ldr.w	r4, [r8], #8
 802a8a0:	f01a 0f01 	tst.w	sl, #1
 802a8a4:	d009      	beq.n	802a8ba <_vfiprintf_r+0x65e>
 802a8a6:	ea54 0205 	orrs.w	r2, r4, r5
 802a8aa:	bf1f      	itttt	ne
 802a8ac:	2230      	movne	r2, #48	; 0x30
 802a8ae:	f88d 2034 	strbne.w	r2, [sp, #52]	; 0x34
 802a8b2:	f88d 3035 	strbne.w	r3, [sp, #53]	; 0x35
 802a8b6:	f04a 0a02 	orrne.w	sl, sl, #2
 802a8ba:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
 802a8be:	e6e3      	b.n	802a688 <_vfiprintf_r+0x42c>
 802a8c0:	4a0e      	ldr	r2, [pc, #56]	; (802a8fc <_vfiprintf_r+0x6a0>)
 802a8c2:	e7e2      	b.n	802a88a <_vfiprintf_r+0x62e>
 802a8c4:	46a0      	mov	r8, r4
 802a8c6:	f01a 0510 	ands.w	r5, sl, #16
 802a8ca:	f858 4b04 	ldr.w	r4, [r8], #4
 802a8ce:	d001      	beq.n	802a8d4 <_vfiprintf_r+0x678>
 802a8d0:	4615      	mov	r5, r2
 802a8d2:	e7e5      	b.n	802a8a0 <_vfiprintf_r+0x644>
 802a8d4:	f01a 0240 	ands.w	r2, sl, #64	; 0x40
 802a8d8:	d001      	beq.n	802a8de <_vfiprintf_r+0x682>
 802a8da:	b2a4      	uxth	r4, r4
 802a8dc:	e7e0      	b.n	802a8a0 <_vfiprintf_r+0x644>
 802a8de:	f41a 7500 	ands.w	r5, sl, #512	; 0x200
 802a8e2:	d0dd      	beq.n	802a8a0 <_vfiprintf_r+0x644>
 802a8e4:	b2e4      	uxtb	r4, r4
 802a8e6:	e7f3      	b.n	802a8d0 <_vfiprintf_r+0x674>
 802a8e8:	2c0a      	cmp	r4, #10
 802a8ea:	f175 0300 	sbcs.w	r3, r5, #0
 802a8ee:	d20d      	bcs.n	802a90c <_vfiprintf_r+0x6b0>
 802a8f0:	3430      	adds	r4, #48	; 0x30
 802a8f2:	f88d 40e7 	strb.w	r4, [sp, #231]	; 0xe7
 802a8f6:	f10d 0be7 	add.w	fp, sp, #231	; 0xe7
 802a8fa:	e135      	b.n	802ab68 <_vfiprintf_r+0x90c>
 802a8fc:	08037555 	.word	0x08037555
 802a900:	080377b0 	.word	0x080377b0
 802a904:	080377c0 	.word	0x080377c0
 802a908:	08037566 	.word	0x08037566
 802a90c:	ab3a      	add	r3, sp, #232	; 0xe8
 802a90e:	9308      	str	r3, [sp, #32]
 802a910:	9b04      	ldr	r3, [sp, #16]
 802a912:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 802a916:	f04f 0a00 	mov.w	sl, #0
 802a91a:	9309      	str	r3, [sp, #36]	; 0x24
 802a91c:	220a      	movs	r2, #10
 802a91e:	2300      	movs	r3, #0
 802a920:	4620      	mov	r0, r4
 802a922:	4629      	mov	r1, r5
 802a924:	f7d6 f958 	bl	8000bd8 <__aeabi_uldivmod>
 802a928:	9b08      	ldr	r3, [sp, #32]
 802a92a:	3230      	adds	r2, #48	; 0x30
 802a92c:	f103 3bff 	add.w	fp, r3, #4294967295
 802a930:	f803 2c01 	strb.w	r2, [r3, #-1]
 802a934:	9b09      	ldr	r3, [sp, #36]	; 0x24
 802a936:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 802a93a:	f10a 0a01 	add.w	sl, sl, #1
 802a93e:	b1d3      	cbz	r3, 802a976 <_vfiprintf_r+0x71a>
 802a940:	9b06      	ldr	r3, [sp, #24]
 802a942:	781a      	ldrb	r2, [r3, #0]
 802a944:	4552      	cmp	r2, sl
 802a946:	d116      	bne.n	802a976 <_vfiprintf_r+0x71a>
 802a948:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 802a94c:	d013      	beq.n	802a976 <_vfiprintf_r+0x71a>
 802a94e:	2c0a      	cmp	r4, #10
 802a950:	f175 0200 	sbcs.w	r2, r5, #0
 802a954:	d30f      	bcc.n	802a976 <_vfiprintf_r+0x71a>
 802a956:	9b07      	ldr	r3, [sp, #28]
 802a958:	ebab 0b03 	sub.w	fp, fp, r3
 802a95c:	461a      	mov	r2, r3
 802a95e:	ee18 1a10 	vmov	r1, s16
 802a962:	4658      	mov	r0, fp
 802a964:	f7fd ff31 	bl	80287ca <strncpy>
 802a968:	9b06      	ldr	r3, [sp, #24]
 802a96a:	785a      	ldrb	r2, [r3, #1]
 802a96c:	b16a      	cbz	r2, 802a98a <_vfiprintf_r+0x72e>
 802a96e:	3301      	adds	r3, #1
 802a970:	9306      	str	r3, [sp, #24]
 802a972:	f04f 0a00 	mov.w	sl, #0
 802a976:	2c0a      	cmp	r4, #10
 802a978:	f175 0500 	sbcs.w	r5, r5, #0
 802a97c:	f0c0 80f4 	bcc.w	802ab68 <_vfiprintf_r+0x90c>
 802a980:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
 802a984:	f8cd b020 	str.w	fp, [sp, #32]
 802a988:	e7c8      	b.n	802a91c <_vfiprintf_r+0x6c0>
 802a98a:	4692      	mov	sl, r2
 802a98c:	e7f3      	b.n	802a976 <_vfiprintf_r+0x71a>
 802a98e:	f004 020f 	and.w	r2, r4, #15
 802a992:	9b05      	ldr	r3, [sp, #20]
 802a994:	0924      	lsrs	r4, r4, #4
 802a996:	5c9a      	ldrb	r2, [r3, r2]
 802a998:	f80b 2d01 	strb.w	r2, [fp, #-1]!
 802a99c:	ea44 7405 	orr.w	r4, r4, r5, lsl #28
 802a9a0:	092d      	lsrs	r5, r5, #4
 802a9a2:	ea54 0205 	orrs.w	r2, r4, r5
 802a9a6:	d1f2      	bne.n	802a98e <_vfiprintf_r+0x732>
 802a9a8:	e0de      	b.n	802ab68 <_vfiprintf_r+0x90c>
 802a9aa:	b933      	cbnz	r3, 802a9ba <_vfiprintf_r+0x75e>
 802a9ac:	f01a 0f01 	tst.w	sl, #1
 802a9b0:	d003      	beq.n	802a9ba <_vfiprintf_r+0x75e>
 802a9b2:	2330      	movs	r3, #48	; 0x30
 802a9b4:	f88d 30e7 	strb.w	r3, [sp, #231]	; 0xe7
 802a9b8:	e79d      	b.n	802a8f6 <_vfiprintf_r+0x69a>
 802a9ba:	f10d 0be8 	add.w	fp, sp, #232	; 0xe8
 802a9be:	e0d3      	b.n	802ab68 <_vfiprintf_r+0x90c>
 802a9c0:	2b00      	cmp	r3, #0
 802a9c2:	f000 809f 	beq.w	802ab04 <_vfiprintf_r+0x8a8>
 802a9c6:	f88d 3084 	strb.w	r3, [sp, #132]	; 0x84
 802a9ca:	2300      	movs	r3, #0
 802a9cc:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
 802a9d0:	46a0      	mov	r8, r4
 802a9d2:	e5c0      	b.n	802a556 <_vfiprintf_r+0x2fa>
 802a9d4:	4605      	mov	r5, r0
 802a9d6:	e66e      	b.n	802a6b6 <_vfiprintf_r+0x45a>
 802a9d8:	2110      	movs	r1, #16
 802a9da:	6071      	str	r1, [r6, #4]
 802a9dc:	2a07      	cmp	r2, #7
 802a9de:	4461      	add	r1, ip
 802a9e0:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 802a9e4:	dd08      	ble.n	802a9f8 <_vfiprintf_r+0x79c>
 802a9e6:	aa0e      	add	r2, sp, #56	; 0x38
 802a9e8:	4639      	mov	r1, r7
 802a9ea:	4648      	mov	r0, r9
 802a9ec:	f7ff fc04 	bl	802a1f8 <__sprint_r>
 802a9f0:	2800      	cmp	r0, #0
 802a9f2:	d166      	bne.n	802aac2 <_vfiprintf_r+0x866>
 802a9f4:	4b60      	ldr	r3, [pc, #384]	; (802ab78 <_vfiprintf_r+0x91c>)
 802a9f6:	a811      	add	r0, sp, #68	; 0x44
 802a9f8:	3c10      	subs	r4, #16
 802a9fa:	4606      	mov	r6, r0
 802a9fc:	e676      	b.n	802a6ec <_vfiprintf_r+0x490>
 802a9fe:	4606      	mov	r6, r0
 802aa00:	e68e      	b.n	802a720 <_vfiprintf_r+0x4c4>
 802aa02:	aa0e      	add	r2, sp, #56	; 0x38
 802aa04:	4639      	mov	r1, r7
 802aa06:	4648      	mov	r0, r9
 802aa08:	f7ff fbf6 	bl	802a1f8 <__sprint_r>
 802aa0c:	2800      	cmp	r0, #0
 802aa0e:	d158      	bne.n	802aac2 <_vfiprintf_r+0x866>
 802aa10:	ae11      	add	r6, sp, #68	; 0x44
 802aa12:	e697      	b.n	802a744 <_vfiprintf_r+0x4e8>
 802aa14:	aa0e      	add	r2, sp, #56	; 0x38
 802aa16:	4639      	mov	r1, r7
 802aa18:	4648      	mov	r0, r9
 802aa1a:	f7ff fbed 	bl	802a1f8 <__sprint_r>
 802aa1e:	2800      	cmp	r0, #0
 802aa20:	d14f      	bne.n	802aac2 <_vfiprintf_r+0x866>
 802aa22:	ae11      	add	r6, sp, #68	; 0x44
 802aa24:	e69e      	b.n	802a764 <_vfiprintf_r+0x508>
 802aa26:	2110      	movs	r1, #16
 802aa28:	6071      	str	r1, [r6, #4]
 802aa2a:	2a07      	cmp	r2, #7
 802aa2c:	4461      	add	r1, ip
 802aa2e:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 802aa32:	dd08      	ble.n	802aa46 <_vfiprintf_r+0x7ea>
 802aa34:	aa0e      	add	r2, sp, #56	; 0x38
 802aa36:	4639      	mov	r1, r7
 802aa38:	4648      	mov	r0, r9
 802aa3a:	f7ff fbdd 	bl	802a1f8 <__sprint_r>
 802aa3e:	2800      	cmp	r0, #0
 802aa40:	d13f      	bne.n	802aac2 <_vfiprintf_r+0x866>
 802aa42:	4b4e      	ldr	r3, [pc, #312]	; (802ab7c <_vfiprintf_r+0x920>)
 802aa44:	a811      	add	r0, sp, #68	; 0x44
 802aa46:	3c10      	subs	r4, #16
 802aa48:	4606      	mov	r6, r0
 802aa4a:	e694      	b.n	802a776 <_vfiprintf_r+0x51a>
 802aa4c:	4606      	mov	r6, r0
 802aa4e:	e6ac      	b.n	802a7aa <_vfiprintf_r+0x54e>
 802aa50:	3110      	adds	r1, #16
 802aa52:	2a07      	cmp	r2, #7
 802aa54:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 802aa58:	6073      	str	r3, [r6, #4]
 802aa5a:	dd07      	ble.n	802aa6c <_vfiprintf_r+0x810>
 802aa5c:	aa0e      	add	r2, sp, #56	; 0x38
 802aa5e:	4639      	mov	r1, r7
 802aa60:	4648      	mov	r0, r9
 802aa62:	f7ff fbc9 	bl	802a1f8 <__sprint_r>
 802aa66:	bb60      	cbnz	r0, 802aac2 <_vfiprintf_r+0x866>
 802aa68:	a811      	add	r0, sp, #68	; 0x44
 802aa6a:	2310      	movs	r3, #16
 802aa6c:	3c10      	subs	r4, #16
 802aa6e:	4606      	mov	r6, r0
 802aa70:	e6a1      	b.n	802a7b6 <_vfiprintf_r+0x55a>
 802aa72:	4606      	mov	r6, r0
 802aa74:	e6b9      	b.n	802a7ea <_vfiprintf_r+0x58e>
 802aa76:	aa0e      	add	r2, sp, #56	; 0x38
 802aa78:	4639      	mov	r1, r7
 802aa7a:	4648      	mov	r0, r9
 802aa7c:	f7ff fbbc 	bl	802a1f8 <__sprint_r>
 802aa80:	b9f8      	cbnz	r0, 802aac2 <_vfiprintf_r+0x866>
 802aa82:	ab11      	add	r3, sp, #68	; 0x44
 802aa84:	e6c1      	b.n	802a80a <_vfiprintf_r+0x5ae>
 802aa86:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
 802aa8a:	1a54      	subs	r4, r2, r1
 802aa8c:	2c00      	cmp	r4, #0
 802aa8e:	f77f aec0 	ble.w	802a812 <_vfiprintf_r+0x5b6>
 802aa92:	4d39      	ldr	r5, [pc, #228]	; (802ab78 <_vfiprintf_r+0x91c>)
 802aa94:	2610      	movs	r6, #16
 802aa96:	e9dd 210f 	ldrd	r2, r1, [sp, #60]	; 0x3c
 802aa9a:	2c10      	cmp	r4, #16
 802aa9c:	f102 0201 	add.w	r2, r2, #1
 802aaa0:	601d      	str	r5, [r3, #0]
 802aaa2:	dc1d      	bgt.n	802aae0 <_vfiprintf_r+0x884>
 802aaa4:	605c      	str	r4, [r3, #4]
 802aaa6:	2a07      	cmp	r2, #7
 802aaa8:	440c      	add	r4, r1
 802aaaa:	e9cd 240f 	strd	r2, r4, [sp, #60]	; 0x3c
 802aaae:	f77f aeb0 	ble.w	802a812 <_vfiprintf_r+0x5b6>
 802aab2:	aa0e      	add	r2, sp, #56	; 0x38
 802aab4:	4639      	mov	r1, r7
 802aab6:	4648      	mov	r0, r9
 802aab8:	f7ff fb9e 	bl	802a1f8 <__sprint_r>
 802aabc:	2800      	cmp	r0, #0
 802aabe:	f43f aea8 	beq.w	802a812 <_vfiprintf_r+0x5b6>
 802aac2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 802aac4:	07d9      	lsls	r1, r3, #31
 802aac6:	d405      	bmi.n	802aad4 <_vfiprintf_r+0x878>
 802aac8:	89bb      	ldrh	r3, [r7, #12]
 802aaca:	059a      	lsls	r2, r3, #22
 802aacc:	d402      	bmi.n	802aad4 <_vfiprintf_r+0x878>
 802aace:	6db8      	ldr	r0, [r7, #88]	; 0x58
 802aad0:	f7fc f801 	bl	8026ad6 <__retarget_lock_release_recursive>
 802aad4:	89bb      	ldrh	r3, [r7, #12]
 802aad6:	065b      	lsls	r3, r3, #25
 802aad8:	f57f abf3 	bpl.w	802a2c2 <_vfiprintf_r+0x66>
 802aadc:	f7ff bbee 	b.w	802a2bc <_vfiprintf_r+0x60>
 802aae0:	3110      	adds	r1, #16
 802aae2:	2a07      	cmp	r2, #7
 802aae4:	e9cd 210f 	strd	r2, r1, [sp, #60]	; 0x3c
 802aae8:	605e      	str	r6, [r3, #4]
 802aaea:	dc02      	bgt.n	802aaf2 <_vfiprintf_r+0x896>
 802aaec:	3308      	adds	r3, #8
 802aaee:	3c10      	subs	r4, #16
 802aaf0:	e7d1      	b.n	802aa96 <_vfiprintf_r+0x83a>
 802aaf2:	aa0e      	add	r2, sp, #56	; 0x38
 802aaf4:	4639      	mov	r1, r7
 802aaf6:	4648      	mov	r0, r9
 802aaf8:	f7ff fb7e 	bl	802a1f8 <__sprint_r>
 802aafc:	2800      	cmp	r0, #0
 802aafe:	d1e0      	bne.n	802aac2 <_vfiprintf_r+0x866>
 802ab00:	ab11      	add	r3, sp, #68	; 0x44
 802ab02:	e7f4      	b.n	802aaee <_vfiprintf_r+0x892>
 802ab04:	9b10      	ldr	r3, [sp, #64]	; 0x40
 802ab06:	b913      	cbnz	r3, 802ab0e <_vfiprintf_r+0x8b2>
 802ab08:	2300      	movs	r3, #0
 802ab0a:	930f      	str	r3, [sp, #60]	; 0x3c
 802ab0c:	e7d9      	b.n	802aac2 <_vfiprintf_r+0x866>
 802ab0e:	aa0e      	add	r2, sp, #56	; 0x38
 802ab10:	4639      	mov	r1, r7
 802ab12:	4648      	mov	r0, r9
 802ab14:	f7ff fb70 	bl	802a1f8 <__sprint_r>
 802ab18:	2800      	cmp	r0, #0
 802ab1a:	d0f5      	beq.n	802ab08 <_vfiprintf_r+0x8ac>
 802ab1c:	e7d1      	b.n	802aac2 <_vfiprintf_r+0x866>
 802ab1e:	ea54 0205 	orrs.w	r2, r4, r5
 802ab22:	f8cd a010 	str.w	sl, [sp, #16]
 802ab26:	f43f ad8d 	beq.w	802a644 <_vfiprintf_r+0x3e8>
 802ab2a:	2b01      	cmp	r3, #1
 802ab2c:	f43f aedc 	beq.w	802a8e8 <_vfiprintf_r+0x68c>
 802ab30:	2b02      	cmp	r3, #2
 802ab32:	f10d 0be8 	add.w	fp, sp, #232	; 0xe8
 802ab36:	f43f af2a 	beq.w	802a98e <_vfiprintf_r+0x732>
 802ab3a:	f004 0207 	and.w	r2, r4, #7
 802ab3e:	08e4      	lsrs	r4, r4, #3
 802ab40:	ea44 7445 	orr.w	r4, r4, r5, lsl #29
 802ab44:	08ed      	lsrs	r5, r5, #3
 802ab46:	3230      	adds	r2, #48	; 0x30
 802ab48:	ea54 0005 	orrs.w	r0, r4, r5
 802ab4c:	4659      	mov	r1, fp
 802ab4e:	f80b 2d01 	strb.w	r2, [fp, #-1]!
 802ab52:	d1f2      	bne.n	802ab3a <_vfiprintf_r+0x8de>
 802ab54:	9b04      	ldr	r3, [sp, #16]
 802ab56:	07d8      	lsls	r0, r3, #31
 802ab58:	d506      	bpl.n	802ab68 <_vfiprintf_r+0x90c>
 802ab5a:	2a30      	cmp	r2, #48	; 0x30
 802ab5c:	d004      	beq.n	802ab68 <_vfiprintf_r+0x90c>
 802ab5e:	2230      	movs	r2, #48	; 0x30
 802ab60:	f80b 2c01 	strb.w	r2, [fp, #-1]
 802ab64:	f1a1 0b02 	sub.w	fp, r1, #2
 802ab68:	ab3a      	add	r3, sp, #232	; 0xe8
 802ab6a:	eba3 030b 	sub.w	r3, r3, fp
 802ab6e:	9d00      	ldr	r5, [sp, #0]
 802ab70:	f8dd a010 	ldr.w	sl, [sp, #16]
 802ab74:	9300      	str	r3, [sp, #0]
 802ab76:	e59e      	b.n	802a6b6 <_vfiprintf_r+0x45a>
 802ab78:	080377b0 	.word	0x080377b0
 802ab7c:	080377c0 	.word	0x080377c0

0802ab80 <__sbprintf>:
 802ab80:	b570      	push	{r4, r5, r6, lr}
 802ab82:	460c      	mov	r4, r1
 802ab84:	8989      	ldrh	r1, [r1, #12]
 802ab86:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
 802ab8a:	f021 0102 	bic.w	r1, r1, #2
 802ab8e:	f8ad 1014 	strh.w	r1, [sp, #20]
 802ab92:	6e61      	ldr	r1, [r4, #100]	; 0x64
 802ab94:	911b      	str	r1, [sp, #108]	; 0x6c
 802ab96:	89e1      	ldrh	r1, [r4, #14]
 802ab98:	f8ad 1016 	strh.w	r1, [sp, #22]
 802ab9c:	69e1      	ldr	r1, [r4, #28]
 802ab9e:	9109      	str	r1, [sp, #36]	; 0x24
 802aba0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 802aba2:	910b      	str	r1, [sp, #44]	; 0x2c
 802aba4:	a91c      	add	r1, sp, #112	; 0x70
 802aba6:	9102      	str	r1, [sp, #8]
 802aba8:	9106      	str	r1, [sp, #24]
 802abaa:	f44f 6180 	mov.w	r1, #1024	; 0x400
 802abae:	4606      	mov	r6, r0
 802abb0:	9104      	str	r1, [sp, #16]
 802abb2:	9107      	str	r1, [sp, #28]
 802abb4:	a818      	add	r0, sp, #96	; 0x60
 802abb6:	2100      	movs	r1, #0
 802abb8:	e9cd 3200 	strd	r3, r2, [sp]
 802abbc:	9108      	str	r1, [sp, #32]
 802abbe:	f7fb ff87 	bl	8026ad0 <__retarget_lock_init_recursive>
 802abc2:	e9dd 3200 	ldrd	r3, r2, [sp]
 802abc6:	a902      	add	r1, sp, #8
 802abc8:	4630      	mov	r0, r6
 802abca:	f7ff fb47 	bl	802a25c <_vfiprintf_r>
 802abce:	1e05      	subs	r5, r0, #0
 802abd0:	db07      	blt.n	802abe2 <__sbprintf+0x62>
 802abd2:	a902      	add	r1, sp, #8
 802abd4:	4630      	mov	r0, r6
 802abd6:	f7fd fdd3 	bl	8028780 <_fflush_r>
 802abda:	2800      	cmp	r0, #0
 802abdc:	bf18      	it	ne
 802abde:	f04f 35ff 	movne.w	r5, #4294967295
 802abe2:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 802abe6:	9818      	ldr	r0, [sp, #96]	; 0x60
 802abe8:	065b      	lsls	r3, r3, #25
 802abea:	bf42      	ittt	mi
 802abec:	89a3      	ldrhmi	r3, [r4, #12]
 802abee:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 802abf2:	81a3      	strhmi	r3, [r4, #12]
 802abf4:	f7fb ff6d 	bl	8026ad2 <__retarget_lock_close_recursive>
 802abf8:	4628      	mov	r0, r5
 802abfa:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
 802abfe:	bd70      	pop	{r4, r5, r6, pc}

0802ac00 <__sfvwrite_r>:
 802ac00:	6893      	ldr	r3, [r2, #8]
 802ac02:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802ac06:	4606      	mov	r6, r0
 802ac08:	460c      	mov	r4, r1
 802ac0a:	4691      	mov	r9, r2
 802ac0c:	b91b      	cbnz	r3, 802ac16 <__sfvwrite_r+0x16>
 802ac0e:	2000      	movs	r0, #0
 802ac10:	b003      	add	sp, #12
 802ac12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802ac16:	898b      	ldrh	r3, [r1, #12]
 802ac18:	0718      	lsls	r0, r3, #28
 802ac1a:	d54f      	bpl.n	802acbc <__sfvwrite_r+0xbc>
 802ac1c:	690b      	ldr	r3, [r1, #16]
 802ac1e:	2b00      	cmp	r3, #0
 802ac20:	d04c      	beq.n	802acbc <__sfvwrite_r+0xbc>
 802ac22:	89a3      	ldrh	r3, [r4, #12]
 802ac24:	f8d9 8000 	ldr.w	r8, [r9]
 802ac28:	f013 0702 	ands.w	r7, r3, #2
 802ac2c:	d16b      	bne.n	802ad06 <__sfvwrite_r+0x106>
 802ac2e:	f013 0301 	ands.w	r3, r3, #1
 802ac32:	f000 809b 	beq.w	802ad6c <__sfvwrite_r+0x16c>
 802ac36:	4638      	mov	r0, r7
 802ac38:	46ba      	mov	sl, r7
 802ac3a:	46bb      	mov	fp, r7
 802ac3c:	f1bb 0f00 	cmp.w	fp, #0
 802ac40:	f000 8102 	beq.w	802ae48 <__sfvwrite_r+0x248>
 802ac44:	b950      	cbnz	r0, 802ac5c <__sfvwrite_r+0x5c>
 802ac46:	465a      	mov	r2, fp
 802ac48:	210a      	movs	r1, #10
 802ac4a:	4650      	mov	r0, sl
 802ac4c:	f7d5 fae0 	bl	8000210 <memchr>
 802ac50:	2800      	cmp	r0, #0
 802ac52:	f000 80ff 	beq.w	802ae54 <__sfvwrite_r+0x254>
 802ac56:	3001      	adds	r0, #1
 802ac58:	eba0 070a 	sub.w	r7, r0, sl
 802ac5c:	6820      	ldr	r0, [r4, #0]
 802ac5e:	6921      	ldr	r1, [r4, #16]
 802ac60:	68a5      	ldr	r5, [r4, #8]
 802ac62:	6963      	ldr	r3, [r4, #20]
 802ac64:	455f      	cmp	r7, fp
 802ac66:	463a      	mov	r2, r7
 802ac68:	bf28      	it	cs
 802ac6a:	465a      	movcs	r2, fp
 802ac6c:	4288      	cmp	r0, r1
 802ac6e:	f240 80f4 	bls.w	802ae5a <__sfvwrite_r+0x25a>
 802ac72:	441d      	add	r5, r3
 802ac74:	42aa      	cmp	r2, r5
 802ac76:	f340 80f0 	ble.w	802ae5a <__sfvwrite_r+0x25a>
 802ac7a:	4651      	mov	r1, sl
 802ac7c:	462a      	mov	r2, r5
 802ac7e:	f7ff fa3b 	bl	802a0f8 <memmove>
 802ac82:	6823      	ldr	r3, [r4, #0]
 802ac84:	442b      	add	r3, r5
 802ac86:	6023      	str	r3, [r4, #0]
 802ac88:	4621      	mov	r1, r4
 802ac8a:	4630      	mov	r0, r6
 802ac8c:	f7fd fd78 	bl	8028780 <_fflush_r>
 802ac90:	2800      	cmp	r0, #0
 802ac92:	d166      	bne.n	802ad62 <__sfvwrite_r+0x162>
 802ac94:	1b7f      	subs	r7, r7, r5
 802ac96:	f040 80f8 	bne.w	802ae8a <__sfvwrite_r+0x28a>
 802ac9a:	4621      	mov	r1, r4
 802ac9c:	4630      	mov	r0, r6
 802ac9e:	f7fd fd6f 	bl	8028780 <_fflush_r>
 802aca2:	2800      	cmp	r0, #0
 802aca4:	d15d      	bne.n	802ad62 <__sfvwrite_r+0x162>
 802aca6:	f8d9 3008 	ldr.w	r3, [r9, #8]
 802acaa:	1b5b      	subs	r3, r3, r5
 802acac:	44aa      	add	sl, r5
 802acae:	ebab 0b05 	sub.w	fp, fp, r5
 802acb2:	f8c9 3008 	str.w	r3, [r9, #8]
 802acb6:	2b00      	cmp	r3, #0
 802acb8:	d1c0      	bne.n	802ac3c <__sfvwrite_r+0x3c>
 802acba:	e7a8      	b.n	802ac0e <__sfvwrite_r+0xe>
 802acbc:	4621      	mov	r1, r4
 802acbe:	4630      	mov	r0, r6
 802acc0:	f000 f8e8 	bl	802ae94 <__swsetup_r>
 802acc4:	2800      	cmp	r0, #0
 802acc6:	d0ac      	beq.n	802ac22 <__sfvwrite_r+0x22>
 802acc8:	f04f 30ff 	mov.w	r0, #4294967295
 802accc:	e7a0      	b.n	802ac10 <__sfvwrite_r+0x10>
 802acce:	e9d8 a500 	ldrd	sl, r5, [r8]
 802acd2:	f108 0808 	add.w	r8, r8, #8
 802acd6:	f8d4 b024 	ldr.w	fp, [r4, #36]	; 0x24
 802acda:	69e1      	ldr	r1, [r4, #28]
 802acdc:	2d00      	cmp	r5, #0
 802acde:	d0f6      	beq.n	802acce <__sfvwrite_r+0xce>
 802ace0:	42bd      	cmp	r5, r7
 802ace2:	462b      	mov	r3, r5
 802ace4:	4652      	mov	r2, sl
 802ace6:	bf28      	it	cs
 802ace8:	463b      	movcs	r3, r7
 802acea:	4630      	mov	r0, r6
 802acec:	47d8      	blx	fp
 802acee:	2800      	cmp	r0, #0
 802acf0:	dd37      	ble.n	802ad62 <__sfvwrite_r+0x162>
 802acf2:	f8d9 3008 	ldr.w	r3, [r9, #8]
 802acf6:	1a1b      	subs	r3, r3, r0
 802acf8:	4482      	add	sl, r0
 802acfa:	1a2d      	subs	r5, r5, r0
 802acfc:	f8c9 3008 	str.w	r3, [r9, #8]
 802ad00:	2b00      	cmp	r3, #0
 802ad02:	d1e8      	bne.n	802acd6 <__sfvwrite_r+0xd6>
 802ad04:	e783      	b.n	802ac0e <__sfvwrite_r+0xe>
 802ad06:	f04f 0a00 	mov.w	sl, #0
 802ad0a:	4f61      	ldr	r7, [pc, #388]	; (802ae90 <__sfvwrite_r+0x290>)
 802ad0c:	4655      	mov	r5, sl
 802ad0e:	e7e2      	b.n	802acd6 <__sfvwrite_r+0xd6>
 802ad10:	e9d8 7a00 	ldrd	r7, sl, [r8]
 802ad14:	f108 0808 	add.w	r8, r8, #8
 802ad18:	6820      	ldr	r0, [r4, #0]
 802ad1a:	68a2      	ldr	r2, [r4, #8]
 802ad1c:	f1ba 0f00 	cmp.w	sl, #0
 802ad20:	d0f6      	beq.n	802ad10 <__sfvwrite_r+0x110>
 802ad22:	89a3      	ldrh	r3, [r4, #12]
 802ad24:	0599      	lsls	r1, r3, #22
 802ad26:	d563      	bpl.n	802adf0 <__sfvwrite_r+0x1f0>
 802ad28:	4552      	cmp	r2, sl
 802ad2a:	d836      	bhi.n	802ad9a <__sfvwrite_r+0x19a>
 802ad2c:	f413 6f90 	tst.w	r3, #1152	; 0x480
 802ad30:	d033      	beq.n	802ad9a <__sfvwrite_r+0x19a>
 802ad32:	6921      	ldr	r1, [r4, #16]
 802ad34:	6965      	ldr	r5, [r4, #20]
 802ad36:	eba0 0b01 	sub.w	fp, r0, r1
 802ad3a:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 802ad3e:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 802ad42:	f10b 0201 	add.w	r2, fp, #1
 802ad46:	106d      	asrs	r5, r5, #1
 802ad48:	4452      	add	r2, sl
 802ad4a:	4295      	cmp	r5, r2
 802ad4c:	bf38      	it	cc
 802ad4e:	4615      	movcc	r5, r2
 802ad50:	055b      	lsls	r3, r3, #21
 802ad52:	d53d      	bpl.n	802add0 <__sfvwrite_r+0x1d0>
 802ad54:	4629      	mov	r1, r5
 802ad56:	4630      	mov	r0, r6
 802ad58:	f7fb fff8 	bl	8026d4c <_malloc_r>
 802ad5c:	b948      	cbnz	r0, 802ad72 <__sfvwrite_r+0x172>
 802ad5e:	230c      	movs	r3, #12
 802ad60:	6033      	str	r3, [r6, #0]
 802ad62:	89a3      	ldrh	r3, [r4, #12]
 802ad64:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802ad68:	81a3      	strh	r3, [r4, #12]
 802ad6a:	e7ad      	b.n	802acc8 <__sfvwrite_r+0xc8>
 802ad6c:	461f      	mov	r7, r3
 802ad6e:	469a      	mov	sl, r3
 802ad70:	e7d2      	b.n	802ad18 <__sfvwrite_r+0x118>
 802ad72:	465a      	mov	r2, fp
 802ad74:	6921      	ldr	r1, [r4, #16]
 802ad76:	9001      	str	r0, [sp, #4]
 802ad78:	f7fb feb6 	bl	8026ae8 <memcpy>
 802ad7c:	89a2      	ldrh	r2, [r4, #12]
 802ad7e:	9b01      	ldr	r3, [sp, #4]
 802ad80:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 802ad84:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 802ad88:	81a2      	strh	r2, [r4, #12]
 802ad8a:	6123      	str	r3, [r4, #16]
 802ad8c:	6165      	str	r5, [r4, #20]
 802ad8e:	445b      	add	r3, fp
 802ad90:	eba5 050b 	sub.w	r5, r5, fp
 802ad94:	6023      	str	r3, [r4, #0]
 802ad96:	4652      	mov	r2, sl
 802ad98:	60a5      	str	r5, [r4, #8]
 802ad9a:	4552      	cmp	r2, sl
 802ad9c:	bf28      	it	cs
 802ad9e:	4652      	movcs	r2, sl
 802ada0:	6820      	ldr	r0, [r4, #0]
 802ada2:	9201      	str	r2, [sp, #4]
 802ada4:	4639      	mov	r1, r7
 802ada6:	f7ff f9a7 	bl	802a0f8 <memmove>
 802adaa:	68a3      	ldr	r3, [r4, #8]
 802adac:	9a01      	ldr	r2, [sp, #4]
 802adae:	1a9b      	subs	r3, r3, r2
 802adb0:	60a3      	str	r3, [r4, #8]
 802adb2:	6823      	ldr	r3, [r4, #0]
 802adb4:	4413      	add	r3, r2
 802adb6:	4655      	mov	r5, sl
 802adb8:	6023      	str	r3, [r4, #0]
 802adba:	f8d9 3008 	ldr.w	r3, [r9, #8]
 802adbe:	1b5b      	subs	r3, r3, r5
 802adc0:	442f      	add	r7, r5
 802adc2:	ebaa 0a05 	sub.w	sl, sl, r5
 802adc6:	f8c9 3008 	str.w	r3, [r9, #8]
 802adca:	2b00      	cmp	r3, #0
 802adcc:	d1a4      	bne.n	802ad18 <__sfvwrite_r+0x118>
 802adce:	e71e      	b.n	802ac0e <__sfvwrite_r+0xe>
 802add0:	462a      	mov	r2, r5
 802add2:	4630      	mov	r0, r6
 802add4:	f7fe ff5e 	bl	8029c94 <_realloc_r>
 802add8:	4603      	mov	r3, r0
 802adda:	2800      	cmp	r0, #0
 802addc:	d1d5      	bne.n	802ad8a <__sfvwrite_r+0x18a>
 802adde:	6921      	ldr	r1, [r4, #16]
 802ade0:	4630      	mov	r0, r6
 802ade2:	f7fb fef3 	bl	8026bcc <_free_r>
 802ade6:	89a3      	ldrh	r3, [r4, #12]
 802ade8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 802adec:	81a3      	strh	r3, [r4, #12]
 802adee:	e7b6      	b.n	802ad5e <__sfvwrite_r+0x15e>
 802adf0:	6923      	ldr	r3, [r4, #16]
 802adf2:	4283      	cmp	r3, r0
 802adf4:	d302      	bcc.n	802adfc <__sfvwrite_r+0x1fc>
 802adf6:	6961      	ldr	r1, [r4, #20]
 802adf8:	4551      	cmp	r1, sl
 802adfa:	d915      	bls.n	802ae28 <__sfvwrite_r+0x228>
 802adfc:	4552      	cmp	r2, sl
 802adfe:	bf28      	it	cs
 802ae00:	4652      	movcs	r2, sl
 802ae02:	4639      	mov	r1, r7
 802ae04:	4615      	mov	r5, r2
 802ae06:	f7ff f977 	bl	802a0f8 <memmove>
 802ae0a:	68a3      	ldr	r3, [r4, #8]
 802ae0c:	6822      	ldr	r2, [r4, #0]
 802ae0e:	1b5b      	subs	r3, r3, r5
 802ae10:	442a      	add	r2, r5
 802ae12:	60a3      	str	r3, [r4, #8]
 802ae14:	6022      	str	r2, [r4, #0]
 802ae16:	2b00      	cmp	r3, #0
 802ae18:	d1cf      	bne.n	802adba <__sfvwrite_r+0x1ba>
 802ae1a:	4621      	mov	r1, r4
 802ae1c:	4630      	mov	r0, r6
 802ae1e:	f7fd fcaf 	bl	8028780 <_fflush_r>
 802ae22:	2800      	cmp	r0, #0
 802ae24:	d0c9      	beq.n	802adba <__sfvwrite_r+0x1ba>
 802ae26:	e79c      	b.n	802ad62 <__sfvwrite_r+0x162>
 802ae28:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 802ae2c:	459a      	cmp	sl, r3
 802ae2e:	bf38      	it	cc
 802ae30:	4653      	movcc	r3, sl
 802ae32:	6a65      	ldr	r5, [r4, #36]	; 0x24
 802ae34:	fb93 f3f1 	sdiv	r3, r3, r1
 802ae38:	463a      	mov	r2, r7
 802ae3a:	434b      	muls	r3, r1
 802ae3c:	4630      	mov	r0, r6
 802ae3e:	69e1      	ldr	r1, [r4, #28]
 802ae40:	47a8      	blx	r5
 802ae42:	1e05      	subs	r5, r0, #0
 802ae44:	dcb9      	bgt.n	802adba <__sfvwrite_r+0x1ba>
 802ae46:	e78c      	b.n	802ad62 <__sfvwrite_r+0x162>
 802ae48:	e9d8 ab00 	ldrd	sl, fp, [r8]
 802ae4c:	2000      	movs	r0, #0
 802ae4e:	f108 0808 	add.w	r8, r8, #8
 802ae52:	e6f3      	b.n	802ac3c <__sfvwrite_r+0x3c>
 802ae54:	f10b 0701 	add.w	r7, fp, #1
 802ae58:	e700      	b.n	802ac5c <__sfvwrite_r+0x5c>
 802ae5a:	4293      	cmp	r3, r2
 802ae5c:	dc08      	bgt.n	802ae70 <__sfvwrite_r+0x270>
 802ae5e:	6a65      	ldr	r5, [r4, #36]	; 0x24
 802ae60:	69e1      	ldr	r1, [r4, #28]
 802ae62:	4652      	mov	r2, sl
 802ae64:	4630      	mov	r0, r6
 802ae66:	47a8      	blx	r5
 802ae68:	1e05      	subs	r5, r0, #0
 802ae6a:	f73f af13 	bgt.w	802ac94 <__sfvwrite_r+0x94>
 802ae6e:	e778      	b.n	802ad62 <__sfvwrite_r+0x162>
 802ae70:	4651      	mov	r1, sl
 802ae72:	9201      	str	r2, [sp, #4]
 802ae74:	f7ff f940 	bl	802a0f8 <memmove>
 802ae78:	9a01      	ldr	r2, [sp, #4]
 802ae7a:	68a3      	ldr	r3, [r4, #8]
 802ae7c:	1a9b      	subs	r3, r3, r2
 802ae7e:	60a3      	str	r3, [r4, #8]
 802ae80:	6823      	ldr	r3, [r4, #0]
 802ae82:	4413      	add	r3, r2
 802ae84:	6023      	str	r3, [r4, #0]
 802ae86:	4615      	mov	r5, r2
 802ae88:	e704      	b.n	802ac94 <__sfvwrite_r+0x94>
 802ae8a:	2001      	movs	r0, #1
 802ae8c:	e70b      	b.n	802aca6 <__sfvwrite_r+0xa6>
 802ae8e:	bf00      	nop
 802ae90:	7ffffc00 	.word	0x7ffffc00

0802ae94 <__swsetup_r>:
 802ae94:	b538      	push	{r3, r4, r5, lr}
 802ae96:	4b2a      	ldr	r3, [pc, #168]	; (802af40 <__swsetup_r+0xac>)
 802ae98:	4605      	mov	r5, r0
 802ae9a:	6818      	ldr	r0, [r3, #0]
 802ae9c:	460c      	mov	r4, r1
 802ae9e:	b118      	cbz	r0, 802aea8 <__swsetup_r+0x14>
 802aea0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802aea2:	b90b      	cbnz	r3, 802aea8 <__swsetup_r+0x14>
 802aea4:	f7fb fc66 	bl	8026774 <__sinit>
 802aea8:	89a3      	ldrh	r3, [r4, #12]
 802aeaa:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802aeae:	0718      	lsls	r0, r3, #28
 802aeb0:	d422      	bmi.n	802aef8 <__swsetup_r+0x64>
 802aeb2:	06d9      	lsls	r1, r3, #27
 802aeb4:	d407      	bmi.n	802aec6 <__swsetup_r+0x32>
 802aeb6:	2309      	movs	r3, #9
 802aeb8:	602b      	str	r3, [r5, #0]
 802aeba:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 802aebe:	81a3      	strh	r3, [r4, #12]
 802aec0:	f04f 30ff 	mov.w	r0, #4294967295
 802aec4:	e034      	b.n	802af30 <__swsetup_r+0x9c>
 802aec6:	0758      	lsls	r0, r3, #29
 802aec8:	d512      	bpl.n	802aef0 <__swsetup_r+0x5c>
 802aeca:	6b21      	ldr	r1, [r4, #48]	; 0x30
 802aecc:	b141      	cbz	r1, 802aee0 <__swsetup_r+0x4c>
 802aece:	f104 0340 	add.w	r3, r4, #64	; 0x40
 802aed2:	4299      	cmp	r1, r3
 802aed4:	d002      	beq.n	802aedc <__swsetup_r+0x48>
 802aed6:	4628      	mov	r0, r5
 802aed8:	f7fb fe78 	bl	8026bcc <_free_r>
 802aedc:	2300      	movs	r3, #0
 802aede:	6323      	str	r3, [r4, #48]	; 0x30
 802aee0:	89a3      	ldrh	r3, [r4, #12]
 802aee2:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 802aee6:	81a3      	strh	r3, [r4, #12]
 802aee8:	2300      	movs	r3, #0
 802aeea:	6063      	str	r3, [r4, #4]
 802aeec:	6923      	ldr	r3, [r4, #16]
 802aeee:	6023      	str	r3, [r4, #0]
 802aef0:	89a3      	ldrh	r3, [r4, #12]
 802aef2:	f043 0308 	orr.w	r3, r3, #8
 802aef6:	81a3      	strh	r3, [r4, #12]
 802aef8:	6923      	ldr	r3, [r4, #16]
 802aefa:	b94b      	cbnz	r3, 802af10 <__swsetup_r+0x7c>
 802aefc:	89a3      	ldrh	r3, [r4, #12]
 802aefe:	f403 7320 	and.w	r3, r3, #640	; 0x280
 802af02:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 802af06:	d003      	beq.n	802af10 <__swsetup_r+0x7c>
 802af08:	4621      	mov	r1, r4
 802af0a:	4628      	mov	r0, r5
 802af0c:	f000 f8ca 	bl	802b0a4 <__smakebuf_r>
 802af10:	89a0      	ldrh	r0, [r4, #12]
 802af12:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 802af16:	f010 0301 	ands.w	r3, r0, #1
 802af1a:	d00a      	beq.n	802af32 <__swsetup_r+0x9e>
 802af1c:	2300      	movs	r3, #0
 802af1e:	60a3      	str	r3, [r4, #8]
 802af20:	6963      	ldr	r3, [r4, #20]
 802af22:	425b      	negs	r3, r3
 802af24:	61a3      	str	r3, [r4, #24]
 802af26:	6923      	ldr	r3, [r4, #16]
 802af28:	b943      	cbnz	r3, 802af3c <__swsetup_r+0xa8>
 802af2a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 802af2e:	d1c4      	bne.n	802aeba <__swsetup_r+0x26>
 802af30:	bd38      	pop	{r3, r4, r5, pc}
 802af32:	0781      	lsls	r1, r0, #30
 802af34:	bf58      	it	pl
 802af36:	6963      	ldrpl	r3, [r4, #20]
 802af38:	60a3      	str	r3, [r4, #8]
 802af3a:	e7f4      	b.n	802af26 <__swsetup_r+0x92>
 802af3c:	2000      	movs	r0, #0
 802af3e:	e7f7      	b.n	802af30 <__swsetup_r+0x9c>
 802af40:	20000380 	.word	0x20000380

0802af44 <__fputwc>:
 802af44:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 802af48:	4680      	mov	r8, r0
 802af4a:	460e      	mov	r6, r1
 802af4c:	4615      	mov	r5, r2
 802af4e:	f7fd fc4f 	bl	80287f0 <__locale_mb_cur_max>
 802af52:	2801      	cmp	r0, #1
 802af54:	d11c      	bne.n	802af90 <__fputwc+0x4c>
 802af56:	1e73      	subs	r3, r6, #1
 802af58:	2bfe      	cmp	r3, #254	; 0xfe
 802af5a:	d819      	bhi.n	802af90 <__fputwc+0x4c>
 802af5c:	f88d 6004 	strb.w	r6, [sp, #4]
 802af60:	4604      	mov	r4, r0
 802af62:	2700      	movs	r7, #0
 802af64:	f10d 0904 	add.w	r9, sp, #4
 802af68:	42a7      	cmp	r7, r4
 802af6a:	d020      	beq.n	802afae <__fputwc+0x6a>
 802af6c:	68ab      	ldr	r3, [r5, #8]
 802af6e:	f817 1009 	ldrb.w	r1, [r7, r9]
 802af72:	3b01      	subs	r3, #1
 802af74:	2b00      	cmp	r3, #0
 802af76:	60ab      	str	r3, [r5, #8]
 802af78:	da04      	bge.n	802af84 <__fputwc+0x40>
 802af7a:	69aa      	ldr	r2, [r5, #24]
 802af7c:	4293      	cmp	r3, r2
 802af7e:	db1a      	blt.n	802afb6 <__fputwc+0x72>
 802af80:	290a      	cmp	r1, #10
 802af82:	d018      	beq.n	802afb6 <__fputwc+0x72>
 802af84:	682b      	ldr	r3, [r5, #0]
 802af86:	1c5a      	adds	r2, r3, #1
 802af88:	602a      	str	r2, [r5, #0]
 802af8a:	7019      	strb	r1, [r3, #0]
 802af8c:	3701      	adds	r7, #1
 802af8e:	e7eb      	b.n	802af68 <__fputwc+0x24>
 802af90:	a901      	add	r1, sp, #4
 802af92:	f105 035c 	add.w	r3, r5, #92	; 0x5c
 802af96:	4632      	mov	r2, r6
 802af98:	4640      	mov	r0, r8
 802af9a:	f000 f845 	bl	802b028 <_wcrtomb_r>
 802af9e:	1c41      	adds	r1, r0, #1
 802afa0:	4604      	mov	r4, r0
 802afa2:	d1de      	bne.n	802af62 <__fputwc+0x1e>
 802afa4:	89ab      	ldrh	r3, [r5, #12]
 802afa6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 802afaa:	81ab      	strh	r3, [r5, #12]
 802afac:	4606      	mov	r6, r0
 802afae:	4630      	mov	r0, r6
 802afb0:	b003      	add	sp, #12
 802afb2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 802afb6:	462a      	mov	r2, r5
 802afb8:	4640      	mov	r0, r8
 802afba:	f000 f8af 	bl	802b11c <__swbuf_r>
 802afbe:	1c42      	adds	r2, r0, #1
 802afc0:	d1e4      	bne.n	802af8c <__fputwc+0x48>
 802afc2:	4606      	mov	r6, r0
 802afc4:	e7f3      	b.n	802afae <__fputwc+0x6a>

0802afc6 <_fputwc_r>:
 802afc6:	6e53      	ldr	r3, [r2, #100]	; 0x64
 802afc8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 802afca:	4614      	mov	r4, r2
 802afcc:	07da      	lsls	r2, r3, #31
 802afce:	4605      	mov	r5, r0
 802afd0:	d407      	bmi.n	802afe2 <_fputwc_r+0x1c>
 802afd2:	89a3      	ldrh	r3, [r4, #12]
 802afd4:	059b      	lsls	r3, r3, #22
 802afd6:	d404      	bmi.n	802afe2 <_fputwc_r+0x1c>
 802afd8:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802afda:	9101      	str	r1, [sp, #4]
 802afdc:	f7fb fd7a 	bl	8026ad4 <__retarget_lock_acquire_recursive>
 802afe0:	9901      	ldr	r1, [sp, #4]
 802afe2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802afe6:	0498      	lsls	r0, r3, #18
 802afe8:	d406      	bmi.n	802aff8 <_fputwc_r+0x32>
 802afea:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802afee:	81a3      	strh	r3, [r4, #12]
 802aff0:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802aff2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802aff6:	6663      	str	r3, [r4, #100]	; 0x64
 802aff8:	4622      	mov	r2, r4
 802affa:	4628      	mov	r0, r5
 802affc:	f7ff ffa2 	bl	802af44 <__fputwc>
 802b000:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802b002:	07da      	lsls	r2, r3, #31
 802b004:	4605      	mov	r5, r0
 802b006:	d405      	bmi.n	802b014 <_fputwc_r+0x4e>
 802b008:	89a3      	ldrh	r3, [r4, #12]
 802b00a:	059b      	lsls	r3, r3, #22
 802b00c:	d402      	bmi.n	802b014 <_fputwc_r+0x4e>
 802b00e:	6da0      	ldr	r0, [r4, #88]	; 0x58
 802b010:	f7fb fd61 	bl	8026ad6 <__retarget_lock_release_recursive>
 802b014:	4628      	mov	r0, r5
 802b016:	b003      	add	sp, #12
 802b018:	bd30      	pop	{r4, r5, pc}

0802b01a <abort>:
 802b01a:	b508      	push	{r3, lr}
 802b01c:	2006      	movs	r0, #6
 802b01e:	f000 f8ef 	bl	802b200 <raise>
 802b022:	2001      	movs	r0, #1
 802b024:	f7d6 fbe0 	bl	80017e8 <_exit>

0802b028 <_wcrtomb_r>:
 802b028:	b5f0      	push	{r4, r5, r6, r7, lr}
 802b02a:	4c09      	ldr	r4, [pc, #36]	; (802b050 <_wcrtomb_r+0x28>)
 802b02c:	b085      	sub	sp, #20
 802b02e:	f8d4 70e0 	ldr.w	r7, [r4, #224]	; 0xe0
 802b032:	4605      	mov	r5, r0
 802b034:	461e      	mov	r6, r3
 802b036:	b909      	cbnz	r1, 802b03c <_wcrtomb_r+0x14>
 802b038:	460a      	mov	r2, r1
 802b03a:	a901      	add	r1, sp, #4
 802b03c:	47b8      	blx	r7
 802b03e:	1c43      	adds	r3, r0, #1
 802b040:	bf01      	itttt	eq
 802b042:	2300      	moveq	r3, #0
 802b044:	6033      	streq	r3, [r6, #0]
 802b046:	238a      	moveq	r3, #138	; 0x8a
 802b048:	602b      	streq	r3, [r5, #0]
 802b04a:	b005      	add	sp, #20
 802b04c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802b04e:	bf00      	nop
 802b050:	20000798 	.word	0x20000798

0802b054 <__swhatbuf_r>:
 802b054:	b570      	push	{r4, r5, r6, lr}
 802b056:	460c      	mov	r4, r1
 802b058:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 802b05c:	2900      	cmp	r1, #0
 802b05e:	b096      	sub	sp, #88	; 0x58
 802b060:	4615      	mov	r5, r2
 802b062:	461e      	mov	r6, r3
 802b064:	da07      	bge.n	802b076 <__swhatbuf_r+0x22>
 802b066:	89a1      	ldrh	r1, [r4, #12]
 802b068:	f011 0180 	ands.w	r1, r1, #128	; 0x80
 802b06c:	d017      	beq.n	802b09e <__swhatbuf_r+0x4a>
 802b06e:	2100      	movs	r1, #0
 802b070:	2340      	movs	r3, #64	; 0x40
 802b072:	4608      	mov	r0, r1
 802b074:	e00f      	b.n	802b096 <__swhatbuf_r+0x42>
 802b076:	466a      	mov	r2, sp
 802b078:	f000 f8ca 	bl	802b210 <_fstat_r>
 802b07c:	2800      	cmp	r0, #0
 802b07e:	dbf2      	blt.n	802b066 <__swhatbuf_r+0x12>
 802b080:	9901      	ldr	r1, [sp, #4]
 802b082:	f401 4170 	and.w	r1, r1, #61440	; 0xf000
 802b086:	f5a1 5300 	sub.w	r3, r1, #8192	; 0x2000
 802b08a:	4259      	negs	r1, r3
 802b08c:	4159      	adcs	r1, r3
 802b08e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802b092:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802b096:	6031      	str	r1, [r6, #0]
 802b098:	602b      	str	r3, [r5, #0]
 802b09a:	b016      	add	sp, #88	; 0x58
 802b09c:	bd70      	pop	{r4, r5, r6, pc}
 802b09e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 802b0a2:	e7e6      	b.n	802b072 <__swhatbuf_r+0x1e>

0802b0a4 <__smakebuf_r>:
 802b0a4:	898b      	ldrh	r3, [r1, #12]
 802b0a6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 802b0a8:	079d      	lsls	r5, r3, #30
 802b0aa:	4606      	mov	r6, r0
 802b0ac:	460c      	mov	r4, r1
 802b0ae:	d507      	bpl.n	802b0c0 <__smakebuf_r+0x1c>
 802b0b0:	f104 0343 	add.w	r3, r4, #67	; 0x43
 802b0b4:	6023      	str	r3, [r4, #0]
 802b0b6:	6123      	str	r3, [r4, #16]
 802b0b8:	2301      	movs	r3, #1
 802b0ba:	6163      	str	r3, [r4, #20]
 802b0bc:	b002      	add	sp, #8
 802b0be:	bd70      	pop	{r4, r5, r6, pc}
 802b0c0:	ab01      	add	r3, sp, #4
 802b0c2:	466a      	mov	r2, sp
 802b0c4:	f7ff ffc6 	bl	802b054 <__swhatbuf_r>
 802b0c8:	9900      	ldr	r1, [sp, #0]
 802b0ca:	4605      	mov	r5, r0
 802b0cc:	4630      	mov	r0, r6
 802b0ce:	f7fb fe3d 	bl	8026d4c <_malloc_r>
 802b0d2:	b948      	cbnz	r0, 802b0e8 <__smakebuf_r+0x44>
 802b0d4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802b0d8:	059a      	lsls	r2, r3, #22
 802b0da:	d4ef      	bmi.n	802b0bc <__smakebuf_r+0x18>
 802b0dc:	f023 0303 	bic.w	r3, r3, #3
 802b0e0:	f043 0302 	orr.w	r3, r3, #2
 802b0e4:	81a3      	strh	r3, [r4, #12]
 802b0e6:	e7e3      	b.n	802b0b0 <__smakebuf_r+0xc>
 802b0e8:	89a3      	ldrh	r3, [r4, #12]
 802b0ea:	6020      	str	r0, [r4, #0]
 802b0ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802b0f0:	81a3      	strh	r3, [r4, #12]
 802b0f2:	9b00      	ldr	r3, [sp, #0]
 802b0f4:	6163      	str	r3, [r4, #20]
 802b0f6:	9b01      	ldr	r3, [sp, #4]
 802b0f8:	6120      	str	r0, [r4, #16]
 802b0fa:	b15b      	cbz	r3, 802b114 <__smakebuf_r+0x70>
 802b0fc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 802b100:	4630      	mov	r0, r6
 802b102:	f000 f897 	bl	802b234 <_isatty_r>
 802b106:	b128      	cbz	r0, 802b114 <__smakebuf_r+0x70>
 802b108:	89a3      	ldrh	r3, [r4, #12]
 802b10a:	f023 0303 	bic.w	r3, r3, #3
 802b10e:	f043 0301 	orr.w	r3, r3, #1
 802b112:	81a3      	strh	r3, [r4, #12]
 802b114:	89a3      	ldrh	r3, [r4, #12]
 802b116:	431d      	orrs	r5, r3
 802b118:	81a5      	strh	r5, [r4, #12]
 802b11a:	e7cf      	b.n	802b0bc <__smakebuf_r+0x18>

0802b11c <__swbuf_r>:
 802b11c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b11e:	460e      	mov	r6, r1
 802b120:	4614      	mov	r4, r2
 802b122:	4605      	mov	r5, r0
 802b124:	b118      	cbz	r0, 802b12e <__swbuf_r+0x12>
 802b126:	6b43      	ldr	r3, [r0, #52]	; 0x34
 802b128:	b90b      	cbnz	r3, 802b12e <__swbuf_r+0x12>
 802b12a:	f7fb fb23 	bl	8026774 <__sinit>
 802b12e:	69a3      	ldr	r3, [r4, #24]
 802b130:	60a3      	str	r3, [r4, #8]
 802b132:	89a3      	ldrh	r3, [r4, #12]
 802b134:	0719      	lsls	r1, r3, #28
 802b136:	d529      	bpl.n	802b18c <__swbuf_r+0x70>
 802b138:	6923      	ldr	r3, [r4, #16]
 802b13a:	b33b      	cbz	r3, 802b18c <__swbuf_r+0x70>
 802b13c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 802b140:	b2f6      	uxtb	r6, r6
 802b142:	049a      	lsls	r2, r3, #18
 802b144:	4637      	mov	r7, r6
 802b146:	d52a      	bpl.n	802b19e <__swbuf_r+0x82>
 802b148:	6823      	ldr	r3, [r4, #0]
 802b14a:	6922      	ldr	r2, [r4, #16]
 802b14c:	1a98      	subs	r0, r3, r2
 802b14e:	6963      	ldr	r3, [r4, #20]
 802b150:	4283      	cmp	r3, r0
 802b152:	dc04      	bgt.n	802b15e <__swbuf_r+0x42>
 802b154:	4621      	mov	r1, r4
 802b156:	4628      	mov	r0, r5
 802b158:	f7fd fb12 	bl	8028780 <_fflush_r>
 802b15c:	b9e0      	cbnz	r0, 802b198 <__swbuf_r+0x7c>
 802b15e:	68a3      	ldr	r3, [r4, #8]
 802b160:	3b01      	subs	r3, #1
 802b162:	60a3      	str	r3, [r4, #8]
 802b164:	6823      	ldr	r3, [r4, #0]
 802b166:	1c5a      	adds	r2, r3, #1
 802b168:	6022      	str	r2, [r4, #0]
 802b16a:	701e      	strb	r6, [r3, #0]
 802b16c:	6962      	ldr	r2, [r4, #20]
 802b16e:	1c43      	adds	r3, r0, #1
 802b170:	429a      	cmp	r2, r3
 802b172:	d004      	beq.n	802b17e <__swbuf_r+0x62>
 802b174:	89a3      	ldrh	r3, [r4, #12]
 802b176:	07db      	lsls	r3, r3, #31
 802b178:	d506      	bpl.n	802b188 <__swbuf_r+0x6c>
 802b17a:	2e0a      	cmp	r6, #10
 802b17c:	d104      	bne.n	802b188 <__swbuf_r+0x6c>
 802b17e:	4621      	mov	r1, r4
 802b180:	4628      	mov	r0, r5
 802b182:	f7fd fafd 	bl	8028780 <_fflush_r>
 802b186:	b938      	cbnz	r0, 802b198 <__swbuf_r+0x7c>
 802b188:	4638      	mov	r0, r7
 802b18a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802b18c:	4621      	mov	r1, r4
 802b18e:	4628      	mov	r0, r5
 802b190:	f7ff fe80 	bl	802ae94 <__swsetup_r>
 802b194:	2800      	cmp	r0, #0
 802b196:	d0d1      	beq.n	802b13c <__swbuf_r+0x20>
 802b198:	f04f 37ff 	mov.w	r7, #4294967295
 802b19c:	e7f4      	b.n	802b188 <__swbuf_r+0x6c>
 802b19e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 802b1a2:	81a3      	strh	r3, [r4, #12]
 802b1a4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 802b1a6:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 802b1aa:	6663      	str	r3, [r4, #100]	; 0x64
 802b1ac:	e7cc      	b.n	802b148 <__swbuf_r+0x2c>

0802b1ae <_raise_r>:
 802b1ae:	291f      	cmp	r1, #31
 802b1b0:	b538      	push	{r3, r4, r5, lr}
 802b1b2:	4604      	mov	r4, r0
 802b1b4:	460d      	mov	r5, r1
 802b1b6:	d904      	bls.n	802b1c2 <_raise_r+0x14>
 802b1b8:	2316      	movs	r3, #22
 802b1ba:	6003      	str	r3, [r0, #0]
 802b1bc:	f04f 30ff 	mov.w	r0, #4294967295
 802b1c0:	bd38      	pop	{r3, r4, r5, pc}
 802b1c2:	f8d0 2118 	ldr.w	r2, [r0, #280]	; 0x118
 802b1c6:	b112      	cbz	r2, 802b1ce <_raise_r+0x20>
 802b1c8:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 802b1cc:	b94b      	cbnz	r3, 802b1e2 <_raise_r+0x34>
 802b1ce:	4620      	mov	r0, r4
 802b1d0:	f000 f852 	bl	802b278 <_getpid_r>
 802b1d4:	462a      	mov	r2, r5
 802b1d6:	4601      	mov	r1, r0
 802b1d8:	4620      	mov	r0, r4
 802b1da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 802b1de:	f000 b839 	b.w	802b254 <_kill_r>
 802b1e2:	2b01      	cmp	r3, #1
 802b1e4:	d00a      	beq.n	802b1fc <_raise_r+0x4e>
 802b1e6:	1c59      	adds	r1, r3, #1
 802b1e8:	d103      	bne.n	802b1f2 <_raise_r+0x44>
 802b1ea:	2316      	movs	r3, #22
 802b1ec:	6003      	str	r3, [r0, #0]
 802b1ee:	2001      	movs	r0, #1
 802b1f0:	e7e6      	b.n	802b1c0 <_raise_r+0x12>
 802b1f2:	2400      	movs	r4, #0
 802b1f4:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 802b1f8:	4628      	mov	r0, r5
 802b1fa:	4798      	blx	r3
 802b1fc:	2000      	movs	r0, #0
 802b1fe:	e7df      	b.n	802b1c0 <_raise_r+0x12>

0802b200 <raise>:
 802b200:	4b02      	ldr	r3, [pc, #8]	; (802b20c <raise+0xc>)
 802b202:	4601      	mov	r1, r0
 802b204:	6818      	ldr	r0, [r3, #0]
 802b206:	f7ff bfd2 	b.w	802b1ae <_raise_r>
 802b20a:	bf00      	nop
 802b20c:	20000380 	.word	0x20000380

0802b210 <_fstat_r>:
 802b210:	b538      	push	{r3, r4, r5, lr}
 802b212:	4d07      	ldr	r5, [pc, #28]	; (802b230 <_fstat_r+0x20>)
 802b214:	2300      	movs	r3, #0
 802b216:	4604      	mov	r4, r0
 802b218:	4608      	mov	r0, r1
 802b21a:	4611      	mov	r1, r2
 802b21c:	602b      	str	r3, [r5, #0]
 802b21e:	f7d6 fb0a 	bl	8001836 <_fstat>
 802b222:	1c43      	adds	r3, r0, #1
 802b224:	d102      	bne.n	802b22c <_fstat_r+0x1c>
 802b226:	682b      	ldr	r3, [r5, #0]
 802b228:	b103      	cbz	r3, 802b22c <_fstat_r+0x1c>
 802b22a:	6023      	str	r3, [r4, #0]
 802b22c:	bd38      	pop	{r3, r4, r5, pc}
 802b22e:	bf00      	nop
 802b230:	20011ed8 	.word	0x20011ed8

0802b234 <_isatty_r>:
 802b234:	b538      	push	{r3, r4, r5, lr}
 802b236:	4d06      	ldr	r5, [pc, #24]	; (802b250 <_isatty_r+0x1c>)
 802b238:	2300      	movs	r3, #0
 802b23a:	4604      	mov	r4, r0
 802b23c:	4608      	mov	r0, r1
 802b23e:	602b      	str	r3, [r5, #0]
 802b240:	f7d6 fafe 	bl	8001840 <_isatty>
 802b244:	1c43      	adds	r3, r0, #1
 802b246:	d102      	bne.n	802b24e <_isatty_r+0x1a>
 802b248:	682b      	ldr	r3, [r5, #0]
 802b24a:	b103      	cbz	r3, 802b24e <_isatty_r+0x1a>
 802b24c:	6023      	str	r3, [r4, #0]
 802b24e:	bd38      	pop	{r3, r4, r5, pc}
 802b250:	20011ed8 	.word	0x20011ed8

0802b254 <_kill_r>:
 802b254:	b538      	push	{r3, r4, r5, lr}
 802b256:	4d07      	ldr	r5, [pc, #28]	; (802b274 <_kill_r+0x20>)
 802b258:	2300      	movs	r3, #0
 802b25a:	4604      	mov	r4, r0
 802b25c:	4608      	mov	r0, r1
 802b25e:	4611      	mov	r1, r2
 802b260:	602b      	str	r3, [r5, #0]
 802b262:	f7d6 fab9 	bl	80017d8 <_kill>
 802b266:	1c43      	adds	r3, r0, #1
 802b268:	d102      	bne.n	802b270 <_kill_r+0x1c>
 802b26a:	682b      	ldr	r3, [r5, #0]
 802b26c:	b103      	cbz	r3, 802b270 <_kill_r+0x1c>
 802b26e:	6023      	str	r3, [r4, #0]
 802b270:	bd38      	pop	{r3, r4, r5, pc}
 802b272:	bf00      	nop
 802b274:	20011ed8 	.word	0x20011ed8

0802b278 <_getpid_r>:
 802b278:	f7d6 baac 	b.w	80017d4 <_getpid>

0802b27c <_init>:
 802b27c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b27e:	bf00      	nop
 802b280:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802b282:	bc08      	pop	{r3}
 802b284:	469e      	mov	lr, r3
 802b286:	4770      	bx	lr

0802b288 <_fini>:
 802b288:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802b28a:	bf00      	nop
 802b28c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802b28e:	bc08      	pop	{r3}
 802b290:	469e      	mov	lr, r3
 802b292:	4770      	bx	lr
